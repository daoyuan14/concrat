use ::libc;
use ::c2rust_asm_casts;
use c2rust_asm_casts::AsmCastTrait;
use std::arch::asm;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type __jmp_buf_tag;
    pub type x509_st;
    pub type ssl_st;
    pub type ssl_ctx_st;
    pub type ssl_method_st;
    pub type internal_state;
    pub type ossl_init_settings_st;
    static mut stdout: *mut FILE;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn __ctype_toupper_loc() -> *mut *const __int32_t;
    static mut stderr: *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strcasecmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncasecmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn pthread_mutex_lock(__mutex_0: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex_0: *mut pthread_mutex_t) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn DES_ecb_encrypt(
        input: *mut const_DES_cblock,
        output: *mut DES_cblock,
        ks: *mut DES_key_schedule,
        enc: libc::c_int,
    );
    fn DES_set_odd_parity(key: *mut DES_cblock);
    fn DES_set_key(
        key: *mut const_DES_cblock,
        schedule: *mut DES_key_schedule,
    ) -> libc::c_int;
    fn MD4_Init(c: *mut MD4_CTX) -> libc::c_int;
    fn MD4_Update(
        c: *mut MD4_CTX,
        data: *const libc::c_void,
        len: size_t,
    ) -> libc::c_int;
    fn MD4_Final(md: *mut libc::c_uchar, c: *mut MD4_CTX) -> libc::c_int;
    fn time(__timer: *mut time_t) -> time_t;
    fn strftime(
        __s: *mut libc::c_char,
        __maxsize: size_t,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> size_t;
    fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn pthread_setcancelstate(
        __state: libc::c_int,
        __oldstate: *mut libc::c_int,
    ) -> libc::c_int;
    fn pthread_setcanceltype(
        __type: libc::c_int,
        __oldtype: *mut libc::c_int,
    ) -> libc::c_int;
    fn pthread_testcancel();
    fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
    fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
    fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
    fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int) -> libc::c_int;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn times(__buffer: *mut tms) -> clock_t;
    fn __errno_location() -> *mut libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn mktime(__tp: *mut tm) -> time_t;
    fn gmtime(__timer: *const time_t) -> *mut tm;
    fn localtime(__timer: *const time_t) -> *mut tm;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strncat(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn pthread_self() -> pthread_t;
    fn exit(_: libc::c_int) -> !;
    fn perror(__s: *const libc::c_char);
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option::<
            unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_exit(__retval: *mut libc::c_void) -> !;
    fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_cancel(__th: pthread_t) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex_0: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_cond_init(
        __cond_0: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
    fn pthread_cond_signal(__cond_0: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_broadcast(__cond_0: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_wait(
        __cond_0: *mut pthread_cond_t,
        __mutex_0: *mut pthread_mutex_t,
    ) -> libc::c_int;
    fn pthread_cond_timedwait(
        __cond_0: *mut pthread_cond_t,
        __mutex_0: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
    fn gettimeofday(__tv: *mut timeval, __tz: *mut libc::c_void) -> libc::c_int;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn difftime(__time1: time_t, __time0: time_t) -> libc::c_double;
    fn setlocale(
        __category: libc::c_int,
        __locale: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn sigemptyset(__set: *mut sigset_t) -> libc::c_int;
    fn sigaddset(__set: *mut sigset_t, __signo: libc::c_int) -> libc::c_int;
    fn sigprocmask(
        __how: libc::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> libc::c_int;
    fn sigwait(__set: *const sigset_t, __sig: *mut libc::c_int) -> libc::c_int;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn inflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn inflateEnd(strm: z_streamp) -> libc::c_int;
    fn inflateInit2_(
        strm: z_streamp,
        windowBits: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn puts(__s: *const libc::c_char) -> libc::c_int;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;
    fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
    fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: libc::c_int,
    ) -> libc::c_int;
    fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
    static mut optarg: *mut libc::c_char;
    static mut optind: libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn getopt_long(
        __argc: libc::c_int,
        __argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
        __longopts: *const option,
        __longind: *mut libc::c_int,
    ) -> libc::c_int;
    fn ferror(__stream: *mut FILE) -> libc::c_int;
    fn vsprintf(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn closelog();
    fn openlog(
        __ident: *const libc::c_char,
        __option: libc::c_int,
        __facility: libc::c_int,
    );
    fn syslog(__pri: libc::c_int, __fmt: *const libc::c_char, _: ...);
    fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn socket(
        __domain: libc::c_int,
        __type: libc::c_int,
        __protocol: libc::c_int,
    ) -> libc::c_int;
    fn connect(
        __fd: libc::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> libc::c_int;
    fn setsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *const libc::c_void,
        __optlen: socklen_t,
    ) -> libc::c_int;
    fn shutdown(__fd: libc::c_int, __how: libc::c_int) -> libc::c_int;
    fn getaddrinfo(
        __name: *const libc::c_char,
        __service: *const libc::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> libc::c_int;
    fn gai_strerror(__ecode: libc::c_int) -> *const libc::c_char;
    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;
    fn SSL_CTX_free(_: *mut SSL_CTX);
    fn SSL_free(ssl: *mut SSL);
    fn SSL_read(ssl: *mut SSL, buf: *mut libc::c_void, num: libc::c_int) -> libc::c_int;
    fn SSL_write(
        ssl: *mut SSL,
        buf: *const libc::c_void,
        num: libc::c_int,
    ) -> libc::c_int;
    fn SSL_get_error(s: *const SSL, ret_code: libc::c_int) -> libc::c_int;
    fn SSL_shutdown(s: *mut SSL) -> libc::c_int;
    fn SSL_get_shutdown(ssl: *const SSL) -> libc::c_int;
    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex_0: *mut pthread_mutex_t) -> libc::c_int;
    fn CRYPTO_malloc(
        num: size_t,
        file: *const libc::c_char,
        line: libc::c_int,
    ) -> *mut libc::c_void;
    fn CRYPTO_free(ptr: *mut libc::c_void, file: *const libc::c_char, line: libc::c_int);
    fn SSL_CTX_set_options(ctx: *mut SSL_CTX, op: libc::c_ulong) -> libc::c_ulong;
    fn SSL_CTX_set_cipher_list(_: *mut SSL_CTX, str: *const libc::c_char) -> libc::c_int;
    fn SSL_CTX_new(meth: *const SSL_METHOD) -> *mut SSL_CTX;
    fn SSL_CTX_set_timeout(ctx: *mut SSL_CTX, t: libc::c_long) -> libc::c_long;
    fn SSL_set_fd(s: *mut SSL, fd: libc::c_int) -> libc::c_int;
    fn SSL_CTX_use_PrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const libc::c_char,
        type_0: libc::c_int,
    ) -> libc::c_int;
    fn SSL_CTX_use_certificate_chain_file(
        ctx: *mut SSL_CTX,
        file: *const libc::c_char,
    ) -> libc::c_int;
    fn SSL_CTX_check_private_key(ctx: *const SSL_CTX) -> libc::c_int;
    fn SSL_new(ctx: *mut SSL_CTX) -> *mut SSL;
    fn SSL_connect(ssl: *mut SSL) -> libc::c_int;
    fn SSL_ctrl(
        ssl: *mut SSL,
        cmd: libc::c_int,
        larg: libc::c_long,
        parg: *mut libc::c_void,
    ) -> libc::c_long;
    fn SSL_CTX_ctrl(
        ctx: *mut SSL_CTX,
        cmd: libc::c_int,
        larg: libc::c_long,
        parg: *mut libc::c_void,
    ) -> libc::c_long;
    fn TLS_client_method() -> *const SSL_METHOD;
    fn OPENSSL_init_ssl(
        opts: uint64_t,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> libc::c_int;
    fn ERR_get_error() -> libc::c_ulong;
    fn ERR_peek_error() -> libc::c_ulong;
    fn ERR_error_string(e: libc::c_ulong, buf: *mut libc::c_char) -> *mut libc::c_char;
    fn ERR_remove_thread_state(_: *mut libc::c_void);
    fn ERR_remove_state(pid: libc::c_ulong);
    fn pthread_kill(__threadid: pthread_t, __signo: libc::c_int) -> libc::c_int;
    fn strpbrk(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
    fn usleep(__useconds: __useconds_t) -> libc::c_int;
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __gnuc_va_list = __builtin_va_list;
pub type __int32_t = libc::c_int;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ARRAY_T {
    pub index: libc::c_int,
    pub length: libc::c_int,
    pub data: *mut array,
    pub free: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
}
pub type array = *mut libc::c_void;
pub type ARRAY = *mut ARRAY_T;
pub type __ssize_t = libc::c_long;
pub type ssize_t = __ssize_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
pub type md5_uint32 = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct md5_ctx {
    pub A: md5_uint32,
    pub B: md5_uint32,
    pub C: md5_uint32,
    pub D: md5_uint32,
    pub total: [md5_uint32; 2],
    pub buflen: md5_uint32,
    pub buffer: [libc::c_char; 128],
}
pub type __anonenum_BOOLEAN_54306505 = libc::c_uint;
pub const boolean_true: __anonenum_BOOLEAN_54306505 = 1;
pub const boolean_false: __anonenum_BOOLEAN_54306505 = 0;
pub type BOOLEAN = __anonenum_BOOLEAN_54306505;
pub type __anonenum_SCHEME_132615588 = libc::c_uint;
pub const PROXY: __anonenum_SCHEME_132615588 = 4;
pub const FTP: __anonenum_SCHEME_132615588 = 3;
pub const HTTPS: __anonenum_SCHEME_132615588 = 2;
pub const HTTP: __anonenum_SCHEME_132615588 = 1;
pub const UNSUPPORTED: __anonenum_SCHEME_132615588 = 0;
pub type SCHEME = __anonenum_SCHEME_132615588;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CREDS_T {
    pub scheme: SCHEME,
    pub username: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub realm: *mut libc::c_char,
}
pub type CREDS = *mut CREDS_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AUTH_T {
    pub creds: ARRAY,
    pub okay: BOOLEAN,
    pub basic: __anonstruct_basic_352126815,
    pub digest: __anonstruct_digest_352126816,
    pub ntlm: __anonstruct_ntlm_516272236,
    pub proxy: __anonstruct_proxy_1015572126,
    pub lock: pthread_mutex_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_proxy_1015572126 {
    pub required: BOOLEAN,
    pub hostname: *mut libc::c_char,
    pub port: libc::c_int,
    pub encode: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_ntlm_516272236 {
    pub state: STATE,
    pub encode: *mut libc::c_char,
    pub ready: BOOLEAN,
    pub nonce: [libc::c_uchar; 8],
}
pub type STATE = __anonenum_STATE_768722769;
pub type __anonenum_STATE_768722769 = libc::c_uint;
pub const TYPE_L: __anonenum_STATE_768722769 = 4;
pub const TYPE_3: __anonenum_STATE_768722769 = 3;
pub const TYPE_2: __anonenum_STATE_768722769 = 2;
pub const TYPE_1: __anonenum_STATE_768722769 = 1;
pub const TYPE_N: __anonenum_STATE_768722769 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_digest_352126816 {
    pub encode: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_basic_352126815 {
    pub encode: *mut libc::c_char,
}
pub type AUTH = *mut AUTH_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DIGEST_CRED {
    pub username: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub cnonce_value: *mut libc::c_char,
    pub h_a1: *mut libc::c_char,
    pub nc: [libc::c_char; 9],
    pub nc_value: libc::c_uint,
}
pub type DCRED = DIGEST_CRED;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DIGEST_CHLG {
    pub realm: *mut libc::c_char,
    pub domain: *mut libc::c_char,
    pub nonce: *mut libc::c_char,
    pub opaque: *mut libc::c_char,
    pub stale: *mut libc::c_char,
    pub algorithm: *mut libc::c_char,
    pub qop: *mut libc::c_char,
}
pub type DCHLG = DIGEST_CHLG;
pub type __anonenum_LEVEL_649277070 = libc::c_uint;
pub const FATAL: __anonenum_LEVEL_649277070 = 3;
pub const ERROR: __anonenum_LEVEL_649277070 = 2;
pub const WARNING: __anonenum_LEVEL_649277070 = 1;
pub const DEBUG: __anonenum_LEVEL_649277070 = 0;
pub type LEVEL = __anonenum_LEVEL_649277070;
pub type DES_LONG = libc::c_uint;
pub type DES_cblock = [libc::c_uchar; 8];
pub type const_DES_cblock = [libc::c_uchar; 8];
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_ks_909163901 {
    pub cblock: DES_cblock,
    pub deslong: [DES_LONG; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DES_ks {
    pub ks: [__anonunion_ks_909163901; 16],
}
pub type DES_key_schedule = DES_ks;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MD4state_st {
    pub A: libc::c_uint,
    pub B: libc::c_uint,
    pub C: libc::c_uint,
    pub D: libc::c_uint,
    pub Nl: libc::c_uint,
    pub Nh: libc::c_uint,
    pub data: [libc::c_uint; 16],
    pub num: libc::c_uint,
}
pub type MD4_CTX = MD4state_st;
pub type __anonenum_KEY_HEADER_E_282889070 = libc::c_uint;
pub const UNKNOWN: __anonenum_KEY_HEADER_E_282889070 = 7;
pub const QOP: __anonenum_KEY_HEADER_E_282889070 = 6;
pub const ALGORITHM: __anonenum_KEY_HEADER_E_282889070 = 5;
pub const STALE: __anonenum_KEY_HEADER_E_282889070 = 4;
pub const OPAQUE: __anonenum_KEY_HEADER_E_282889070 = 3;
pub const NONCE: __anonenum_KEY_HEADER_E_282889070 = 2;
pub const DOMAIN: __anonenum_KEY_HEADER_E_282889070 = 1;
pub const REALM: __anonenum_KEY_HEADER_E_282889070 = 0;
pub type KEY_HEADER_E = __anonenum_KEY_HEADER_E_282889070;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_KEYPARSER_335600686 {
    pub keyname: *const libc::c_char,
    pub keyval: KEY_HEADER_E,
}
pub type KEYPARSER = __anonstruct_KEYPARSER_335600686;
pub type __clock_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_fd_set_356711149 {
    pub fds_bits: [__fd_mask; 16],
}
pub type fd_set = __anonstruct_fd_set_356711149;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___wseq32_112954846 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_236290450 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __anonstruct___wseq32_112954846,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___g1_start32_958857993 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_958857992 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __anonstruct___g1_start32_958857993,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __annonCompField1: __anonunion____missing_field_name_236290450,
    pub __annonCompField2: __anonunion____missing_field_name_958857992,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_cond_t_951761805 {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type pthread_cond_t = __anonunion_pthread_cond_t_951761805;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
pub type __jmp_buf = [libc::c_long; 8];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___cancel_jmp_buf_572769531 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___pthread_unwind_buf_t_808729522 {
    pub __cancel_jmp_buf: [__anonstruct___cancel_jmp_buf_572769531; 1],
    pub __pad: [*mut libc::c_void; 4],
}
pub type __pthread_unwind_buf_t = __anonstruct___pthread_unwind_buf_t_808729522;
pub type socklen_t = __socklen_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tms {
    pub tms_utime: clock_t,
    pub tms_stime: clock_t,
    pub tms_cutime: clock_t,
    pub tms_cstime: clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct URL_T {
    pub ID: libc::c_int,
    pub url: *mut libc::c_char,
    pub scheme: SCHEME,
    pub method: METHOD,
    pub username: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub hostname: *mut libc::c_char,
    pub port: libc::c_int,
    pub path: *mut libc::c_char,
    pub file: *mut libc::c_char,
    pub params: *mut libc::c_char,
    pub hasparams: BOOLEAN,
    pub query: *mut libc::c_char,
    pub frag: *mut libc::c_char,
    pub request: *mut libc::c_char,
    pub postlen: size_t,
    pub postdata: *mut libc::c_char,
    pub posttemp: *mut libc::c_char,
    pub conttype: *mut libc::c_char,
    pub cached: BOOLEAN,
    pub redir: BOOLEAN,
}
pub type METHOD = libc::c_int;
pub type URL = *mut URL_T;
pub type __anonenum_TYPE_82145593 = libc::c_uint;
pub const NTLM: __anonenum_TYPE_82145593 = 2;
pub const DIGEST: __anonenum_TYPE_82145593 = 1;
pub const BASIC: __anonenum_TYPE_82145593 = 0;
pub type TYPE = __anonenum_TYPE_82145593;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct HASH_T {
    pub size: libc::c_int,
    pub entries: libc::c_int,
    pub index: libc::c_int,
    pub table: *mut *mut NODE___0,
    pub free: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct NODE___0 {
    pub key: *mut libc::c_char,
    pub val: *mut libc::c_void,
    pub next: *mut NODE___0,
}
pub type HASH = *mut HASH_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct COOKIES_T {
    pub head: *mut NODE,
    pub size: size_t,
    pub file: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct NODE {
    pub threadID: size_t,
    pub cookie: COOKIE,
    pub next: *mut NODE,
}
pub type COOKIE = *mut COOKIE_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct COOKIE_T {
    pub name: *mut libc::c_char,
    pub value: *mut libc::c_char,
    pub domain: *mut libc::c_char,
    pub path: *mut libc::c_char,
    pub expires: time_t,
    pub expstr: *mut libc::c_char,
    pub none: *mut libc::c_char,
    pub string: *mut libc::c_char,
    pub session: BOOLEAN,
    pub secure: BOOLEAN,
}
pub type COOKIES = *mut COOKIES_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_LINES_216488822 {
    pub index: libc::c_int,
    pub line: *mut *mut libc::c_char,
}
pub type LINES = __anonstruct_LINES_216488822;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CONFIG {
    pub logging: BOOLEAN,
    pub shlog: BOOLEAN,
    pub limit: libc::c_int,
    pub url: *mut libc::c_char,
    pub logfile: [libc::c_char; 128],
    pub verbose: BOOLEAN,
    pub quiet: BOOLEAN,
    pub parser: BOOLEAN,
    pub csv: BOOLEAN,
    pub fullurl: BOOLEAN,
    pub display: BOOLEAN,
    pub config: BOOLEAN,
    pub color: BOOLEAN,
    pub cusers: libc::c_int,
    pub delay: libc::c_float,
    pub timeout: libc::c_int,
    pub bench: BOOLEAN,
    pub internet: BOOLEAN,
    pub timestamp: BOOLEAN,
    pub time: libc::c_int,
    pub secs: libc::c_int,
    pub reps: libc::c_int,
    pub file: [libc::c_char; 128],
    pub length: libc::c_int,
    pub nomap: *mut LINES,
    pub debug: BOOLEAN,
    pub chunked: BOOLEAN,
    pub unique: BOOLEAN,
    pub get: BOOLEAN,
    pub print: BOOLEAN,
    pub mark: BOOLEAN,
    pub markstr: *mut libc::c_char,
    pub protocol: libc::c_int,
    pub cookies: COOKIES,
    pub uagent: [libc::c_char; 256],
    pub encoding: [libc::c_char; 256],
    pub conttype: [libc::c_char; 256],
    pub bids: libc::c_int,
    pub auth: AUTH,
    pub keepalive: BOOLEAN,
    pub signaled: libc::c_int,
    pub extra: [libc::c_char; 2048],
    pub login: BOOLEAN,
    pub loginurl: *mut libc::c_char,
    pub lurl: ARRAY,
    pub failures: libc::c_int,
    pub failed: libc::c_int,
    pub escape: BOOLEAN,
    pub expire: BOOLEAN,
    pub follow: BOOLEAN,
    pub zero_ok: BOOLEAN,
    pub spinner: BOOLEAN,
    pub cache: BOOLEAN,
    pub rc: [libc::c_char; 256],
    pub ssl_timeout: libc::c_int,
    pub ssl_cert: *mut libc::c_char,
    pub ssl_key: *mut libc::c_char,
    pub ssl_ciphers: *mut libc::c_char,
    pub method: METHOD,
    pub json_output: BOOLEAN,
    pub cond: pthread_cond_t,
    pub lock: pthread_mutex_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pollfd {
    pub fd: libc::c_int,
    pub events: libc::c_short,
    pub revents: libc::c_short,
}
pub type X509 = x509_st;
pub type SSL = ssl_st;
pub type SSL_CTX = ssl_ctx_st;
pub type SSL_METHOD = ssl_method_st;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PAGE_T {
    pub buf: *mut libc::c_char,
    pub len: size_t,
    pub size: size_t,
}
pub type PAGE = *mut PAGE_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DATE_T {
    pub date: *mut libc::c_char,
    pub etag: *mut libc::c_char,
    pub head: *mut libc::c_char,
    pub tm: *mut tm,
    pub safe: tm,
}
pub type DATE = *mut DATE_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CACHE_T {
    pub cache: HASH,
    pub hlen: libc::c_int,
    pub header: *mut libc::c_char,
}
pub type CACHE = *mut CACHE_T;
pub type __anonenum_S_STATUS_297285769 = libc::c_uint;
pub const S_DONE: __anonenum_S_STATUS_297285769 = 8;
pub const S_WRITING: __anonenum_S_STATUS_297285769 = 4;
pub const S_READING: __anonenum_S_STATUS_297285769 = 2;
pub const S_CONNECTING: __anonenum_S_STATUS_297285769 = 1;
pub type S_STATUS = __anonenum_S_STATUS_297285769;
pub type __anonenum_SDSET_930488899 = libc::c_uint;
pub const RDWR: __anonenum_SDSET_930488899 = 3;
pub const WRITE: __anonenum_SDSET_930488899 = 2;
pub const READ: __anonenum_SDSET_930488899 = 1;
pub const UNDEF: __anonenum_SDSET_930488899 = 0;
pub type SDSET = __anonenum_SDSET_930488899;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_content_151561562 {
    pub transfer: libc::c_int,
    pub length: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_connection_887606460 {
    pub max: libc::c_int,
    pub timeout: libc::c_int,
    pub reuse: libc::c_int,
    pub status: libc::c_int,
    pub keepalive: libc::c_int,
    pub tested: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_type_192952330 {
    pub www: TYPE,
    pub proxy: TYPE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_auth_1053230411 {
    pub wchlg: *mut DCHLG,
    pub wcred: *mut DCRED,
    pub www: libc::c_int,
    pub pchlg: *mut DCHLG,
    pub pcred: *mut DCRED,
    pub proxy: libc::c_int,
    pub type_0: __anonstruct_type_192952330,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_ftp_768237192 {
    pub code: libc::c_int,
    pub host: [libc::c_char; 64],
    pub port: libc::c_int,
    pub size: size_t,
    pub pasv: BOOLEAN,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_CONN_573095640 {
    pub sock: libc::c_int,
    pub status: S_STATUS,
    pub encrypt: BOOLEAN,
    pub scheme: SCHEME,
    pub page: PAGE,
    pub cache: CACHE,
    pub content: __anonstruct_content_151561562,
    pub connection: __anonstruct_connection_887606460,
    pub auth: __anonstruct_auth_1053230411,
    pub ssl: *mut SSL,
    pub ctx: *mut SSL_CTX,
    pub method: *const SSL_METHOD,
    pub cert: *mut X509,
    pub inbuffer: size_t,
    pub pos_ini: libc::c_int,
    pub buffer: [libc::c_char; 4096],
    pub chkbuf: [libc::c_char; 1024],
    pub pfd: [pollfd; 1],
    pub ws: *mut fd_set,
    pub rs: *mut fd_set,
    pub state: SDSET,
    pub ftp: __anonstruct_ftp_768237192,
}
pub type CONN = __anonstruct_CONN_573095640;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RESPONSE_T {
    pub headers: HASH,
    pub auth: __anonstruct_auth_478522335,
    pub cached: BOOLEAN,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_auth_478522335 {
    pub www: libc::c_int,
    pub proxy: libc::c_int,
    pub realm: __anonstruct_realm_476363767,
    pub challenge: __anonstruct_challenge_476363768,
    pub type_0: __anonstruct_type_192952330___0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_type_192952330___0 {
    pub www: TYPE,
    pub proxy: TYPE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_challenge_476363768 {
    pub www: *mut libc::c_char,
    pub proxy: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_realm_476363767 {
    pub www: *mut libc::c_char,
    pub proxy: *mut libc::c_char,
}
pub type RESPONSE = *mut RESPONSE_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BROWSER_T {
    pub id: libc::c_int,
    pub tid: size_t,
    pub urls: ARRAY,
    pub parts: ARRAY,
    pub cookies: HASH,
    pub conn: *mut CONN,
    pub type_0: libc::c_int,
    pub state: libc::c_int,
    pub total: libc::c_float,
    pub available: libc::c_float,
    pub lowest: libc::c_float,
    pub highest: libc::c_float,
    pub elapsed: libc::c_float,
    pub time: libc::c_float,
    pub himark: libc::c_float,
    pub lomark: libc::c_float,
    pub start: clock_t,
    pub stop: clock_t,
    pub t_start: tms,
    pub t_stop: tms,
    pub auth: __anonstruct_auth_185766227,
    pub code: libc::c_uint,
    pub count: libc::c_uint,
    pub okay: libc::c_uint,
    pub fail: libc::c_uint,
    pub hits: libc::c_ulong,
    pub bytes: libc::c_ulonglong,
    pub rseed: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_auth_185766227 {
    pub wchlg: *mut DCHLG,
    pub wcred: *mut DCRED,
    pub www: libc::c_int,
    pub pchlg: *mut DCHLG,
    pub pcred: *mut DCRED,
    pub proxy: libc::c_int,
    pub bids: __anonstruct_bids_1053230412,
    pub type_0: __anonstruct_type_1053230413,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_type_1053230413 {
    pub www: TYPE,
    pub proxy: TYPE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_bids_1053230412 {
    pub www: libc::c_int,
    pub proxy: libc::c_int,
}
pub type BROWSER = *mut BROWSER_T;
pub type __anonenum_CTYPE_619574907 = libc::c_uint;
pub const C_EXPIRES: __anonenum_CTYPE_619574907 = 2;
pub const C_LAST: __anonenum_CTYPE_619574907 = 1;
pub const C_ETAG: __anonenum_CTYPE_619574907 = 0;
pub type CTYPE = __anonenum_CTYPE_619574907;
pub type __suseconds_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_condattr_t_488594145 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_condattr_t = __anonunion_pthread_condattr_t_488594145;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct work {
    pub routine: Option::<unsafe extern "C" fn() -> ()>,
    pub arg: *mut libc::c_void,
    pub next: *mut work,
}
pub type WORK = work;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CREW_T {
    pub size: libc::c_int,
    pub maxsize: libc::c_int,
    pub cursize: libc::c_int,
    pub total: libc::c_int,
    pub head: *mut WORK,
    pub tail: *mut WORK,
    pub block: BOOLEAN,
    pub closed: BOOLEAN,
    pub shutdown: BOOLEAN,
    pub threads: *mut pthread_t,
    pub lock: pthread_mutex_t,
    pub not_empty: pthread_cond_t,
    pub not_full: pthread_cond_t,
    pub empty: pthread_cond_t,
}
pub type CREW = *mut CREW_T;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DATA_T {
    pub total: libc::c_float,
    pub available: libc::c_float,
    pub lowest: libc::c_float,
    pub highest: libc::c_float,
    pub elapsed: libc::c_float,
    pub start: clock_t,
    pub stop: clock_t,
    pub t_start: tms,
    pub t_stop: tms,
    pub code: libc::c_uint,
    pub count: libc::c_uint,
    pub okay: libc::c_uint,
    pub fail: libc::c_uint,
    pub bytes: libc::c_ulonglong,
}
pub type DATA = *mut DATA_T;
pub type assume = libc::c_uint;
pub const DATE_TIME: assume = 2;
pub const DATE_YEAR: assume = 1;
pub const DATE_MDAY: assume = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tzinfo {
    pub name: *const libc::c_char,
    pub offset: libc::c_int,
}
pub type va_list___0 = __gnuc_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___sigset_t_991265788 {
    pub __val: [libc::c_ulong; 16],
}
pub type __sigset_t = __anonstruct___sigset_t_991265788;
pub type sigset_t = __sigset_t;
pub type __uint32_t = libc::c_uint;
pub type u_int32_t = __uint32_t;
pub type __anonenum_HTTP_TE_732632201 = libc::c_uint;
pub const TRAILER: __anonenum_HTTP_TE_732632201 = 4;
pub const CHUNKED: __anonenum_HTTP_TE_732632201 = 2;
pub const NONE: __anonenum_HTTP_TE_732632201 = 1;
pub type HTTP_TE = __anonenum_HTTP_TE_732632201;
pub type __anonenum_HTTP_CE_872574738 = libc::c_uint;
pub const BZIP2: __anonenum_HTTP_CE_872574738 = 8;
pub const GZIP: __anonenum_HTTP_CE_872574738 = 4;
pub const DEFLATE: __anonenum_HTTP_CE_872574738 = 2;
pub const COMPRESS: __anonenum_HTTP_CE_872574738 = 1;
pub type HTTP_CE = __anonenum_HTTP_CE_872574738;
pub type Byte = libc::c_uchar;
pub type uInt = libc::c_uint;
pub type uLong = libc::c_ulong;
pub type Bytef = Byte;
pub type voidpf = *mut libc::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut libc::c_char,
    pub state: *mut internal_state,
    pub zalloc: Option::<unsafe extern "C" fn(voidpf, uInt, uInt) -> voidpf>,
    pub zfree: Option::<unsafe extern "C" fn(voidpf, voidpf) -> ()>,
    pub opaque: voidpf,
    pub data_type: libc::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ContentType {
    pub ext: *mut libc::c_char,
    pub ascii: BOOLEAN,
    pub type_0: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct option {
    pub name: *const libc::c_char,
    pub has_arg: libc::c_int,
    pub flag: *mut libc::c_int,
    pub val: libc::c_int,
}
pub type md5_uintptr = libc::c_ulong;
pub type va_list = __builtin_va_list;
pub type __anonenum_HTTP_CONN_945596102 = libc::c_uint;
pub const METER: __anonenum_HTTP_CONN_945596102 = 4;
pub const KEEPALIVE: __anonenum_HTTP_CONN_945596102 = 2;
pub const CLOSE: __anonenum_HTTP_CONN_945596102 = 1;
pub type HTTP_CONN = __anonenum_HTTP_CONN_945596102;
pub type sa_family_t = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct addrinfo {
    pub ai_flags: libc::c_int,
    pub ai_family: libc::c_int,
    pub ai_socktype: libc::c_int,
    pub ai_protocol: libc::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut libc::c_char,
    pub ai_next: *mut addrinfo,
}
pub type nfds_t = libc::c_ulong;
pub type __uint64_t = libc::c_ulong;
pub type uint64_t = __uint64_t;
pub type OPENSSL_INIT_SETTINGS = ossl_init_settings_st;
pub type copy_method = libc::c_uint;
pub const CM_PASSTHROUGH: copy_method = 2;
pub const CM_ENCODE: copy_method = 1;
pub const CM_DECODE: copy_method = 0;
pub type __useconds_t = libc::c_uint;
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp as libc::c_int;
}
#[inline]
unsafe extern "C" fn atol(mut __nptr: *const libc::c_char) -> libc::c_long {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp;
}
#[inline]
unsafe extern "C" fn atof(mut __nptr: *const libc::c_char) -> libc::c_double {
    let mut tmp: libc::c_double = 0.;
    tmp = strtod(__nptr, 0 as *mut libc::c_void as *mut *mut libc::c_char);
    return tmp;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    let mut tmp: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___0: __int32_t = 0;
    if __c >= -(128 as libc::c_int) {
        if __c < 256 as libc::c_int {
            tmp = __ctype_tolower_loc();
            tmp___0 = *(*tmp).offset(__c as isize);
        } else {
            tmp___0 = __c;
        }
    } else {
        tmp___0 = __c;
    }
    return tmp___0;
}
#[inline]
unsafe extern "C" fn toupper(mut __c: libc::c_int) -> libc::c_int {
    let mut tmp: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___0: __int32_t = 0;
    if __c >= -(128 as libc::c_int) {
        if __c < 256 as libc::c_int {
            tmp = __ctype_toupper_loc();
            tmp___0 = *(*tmp).offset(__c as isize);
        } else {
            tmp___0 = __c;
        }
    } else {
        tmp___0 = __c;
    }
    return tmp___0;
}
pub static mut ARRAYSIZE: size_t = ::std::mem::size_of::<ARRAY_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_array() -> ARRAY {
    let mut this: ARRAY = 0 as *mut ARRAY_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = xcalloc(
        ::std::mem::size_of::<ARRAY_T>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    this = tmp as ARRAY;
    (*this).index = -(1 as libc::c_int);
    (*this).length = 0 as libc::c_int;
    (*this)
        .free = ::std::mem::transmute::<
        *mut libc::c_void,
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    >(0 as *mut libc::c_void);
    return this;
}
pub unsafe extern "C" fn array_destroy(mut this: ARRAY) -> ARRAY {
    let mut i: libc::c_int = 0;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as ARRAY;
    }
    if ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        libc::c_ulong,
    >((*this).free) == 0 as *mut libc::c_void as libc::c_ulong
    {
        (*this).free = Some(free as unsafe extern "C" fn(*mut libc::c_void) -> ());
    }
    i = 0 as libc::c_int;
    while i < (*this).length {
        (Some(((*this).free).expect("non-null function pointer")))
            .expect("non-null function pointer")(*((*this).data).offset(i as isize));
        i += 1;
    }
    xfree((*this).data as *mut libc::c_void);
    xfree(this as *mut libc::c_void);
    this = 0 as *mut libc::c_void as ARRAY;
    return this;
}
pub unsafe extern "C" fn array_destroyer(
    mut this: ARRAY,
    mut m: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) -> ARRAY {
    let mut tmp: ARRAY = 0 as *mut ARRAY_T;
    (*this).free = m;
    tmp = array_destroy(this);
    return tmp;
}
pub unsafe extern "C" fn array_set_destroyer(
    mut this: ARRAY,
    mut m: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    (*this).free = m;
}
pub unsafe extern "C" fn array_push(mut this: ARRAY, mut thing: *mut libc::c_void) {
    let mut len: libc::c_int = 0;
    let mut tmp: size_t = 0;
    len = 0 as libc::c_int;
    if thing as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    tmp = strlen(thing as *const libc::c_char);
    len = tmp.wrapping_add(1 as libc::c_ulong) as libc::c_int;
    array_npush(this, thing, len as size_t);
}
pub unsafe extern "C" fn array_npush(
    mut this: ARRAY,
    mut thing: *mut libc::c_void,
    mut len: size_t,
) {
    let mut arr: array = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    if thing as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    if (*this).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if (*this).length == 0 as libc::c_int {
            tmp = xmalloc(::std::mem::size_of::<array>() as libc::c_ulong);
            (*this).data = tmp as *mut array;
        } else {
            tmp___0 = realloc(
                (*this).data as *mut libc::c_void,
                (((*this).length + 1 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<array>() as libc::c_ulong),
            );
            (*this).data = tmp___0 as *mut array;
        }
    } else {
        tmp___0 = realloc(
            (*this).data as *mut libc::c_void,
            (((*this).length + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<array>() as libc::c_ulong),
        );
        (*this).data = tmp___0 as *mut array;
    }
    arr = xmalloc(len.wrapping_add(1 as libc::c_ulong));
    memset(arr, '\u{0}' as i32, len.wrapping_add(1 as libc::c_ulong));
    memcpy(arr, thing as *const libc::c_void, len);
    let ref mut fresh0 = *((*this).data).offset((*this).length as isize);
    *fresh0 = arr;
    (*this).length += 1;
}
pub unsafe extern "C" fn array_get(
    mut this: ARRAY,
    mut index___0: libc::c_int,
) -> *mut libc::c_void {
    if index___0 > (*this).length {
        return 0 as *mut libc::c_void;
    }
    return *((*this).data).offset(index___0 as isize);
}
pub unsafe extern "C" fn array_remove(
    mut this: ARRAY,
    mut index___0: libc::c_int,
) -> *mut libc::c_void {
    let mut length: libc::c_int = 0;
    let mut arr: array = 0 as *mut libc::c_void;
    length = 0 as libc::c_int;
    if index___0 > (*this).length {
        return 0 as *mut libc::c_void;
    }
    arr = *((*this).data).offset(index___0 as isize);
    (*this).length -= 1;
    length = (*this).length;
    while index___0 < length {
        let ref mut fresh1 = *((*this).data).offset(index___0 as isize);
        *fresh1 = *((*this).data).offset((index___0 + 1 as libc::c_int) as isize);
        index___0 += 1;
    }
    return arr;
}
pub unsafe extern "C" fn array_pop(mut this: ARRAY) -> *mut libc::c_void {
    let mut tmp: array = 0 as *mut libc::c_void;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void;
    }
    if (*this).length != 0 {
        (*this).length -= 1;
        tmp = *((*this).data).offset((*this).length as isize);
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    return tmp;
}
pub unsafe extern "C" fn array_next(mut this: ARRAY) -> *mut libc::c_void {
    (*this).index += 1;
    return *((*this).data).offset(((*this).index % (*this).length) as isize);
}
pub unsafe extern "C" fn array_prev(mut this: ARRAY) -> *mut libc::c_void {
    (*this).index -= 1;
    return *((*this).data)
        .offset(
            (((*this).index + ((*this).length - 1 as libc::c_int)) % (*this).length)
                as isize,
        );
}
pub unsafe extern "C" fn array_length(mut this: ARRAY) -> size_t {
    return (*this).length as size_t;
}
pub unsafe extern "C" fn array_to_string(mut this: ARRAY) -> *mut libc::c_char {
    let mut i: size_t = 0;
    let mut len: libc::c_int = 0;
    let mut str: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: size_t = 0;
    len = 0 as libc::c_int;
    if (*this).length == 0 as libc::c_int {
        return b"NULL\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___1 = array_length(this);
        if !(i < tmp___1) {
            break;
        }
        tmp = array_get(this, i as libc::c_int);
        tmp___0 = strlen(tmp as *const libc::c_char);
        len = (len as size_t).wrapping_add(tmp___0.wrapping_add(3 as libc::c_ulong))
            as libc::c_int;
        i = i.wrapping_add(1);
    }
    tmp___2 = malloc((len + 1 as libc::c_int) as size_t);
    str = tmp___2 as *mut libc::c_char;
    memset(str as *mut libc::c_void, '\u{0}' as i32, (len + 1 as libc::c_int) as size_t);
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___5 = array_length(this);
        if !(i < tmp___5) {
            break;
        }
        strcat(str, b"[\0" as *const u8 as *const libc::c_char);
        tmp___3 = array_get(this, i as libc::c_int);
        strcat(str, tmp___3 as *const libc::c_char);
        tmp___4 = array_length(this);
        if i == tmp___4.wrapping_sub(1 as libc::c_ulong) {
            strcat(str, b"]\0" as *const u8 as *const libc::c_char);
        } else {
            strcat(str, b"],\0" as *const u8 as *const libc::c_char);
        }
        i = i.wrapping_add(1);
    }
    return str;
}
pub unsafe extern "C" fn array_print(mut this: ARRAY) {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = array_to_string(this);
    printf(b"%s\n\0" as *const u8 as *const libc::c_char, tmp);
}
pub static mut AUTHSIZE: size_t = ::std::mem::size_of::<AUTH_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_auth() -> AUTH {
    let mut this: AUTH = 0 as *mut AUTH_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(AUTHSIZE, 1 as libc::c_int as size_t);
    this = tmp as AUTH;
    (*this).creds = new_array();
    (*this).basic.encode = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).digest.encode = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).ntlm.encode = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).ntlm.state = TYPE_N;
    (*this).proxy.encode = 0 as *mut libc::c_void as *mut libc::c_char;
    return this;
}
pub unsafe extern "C" fn auth_destroy(mut this: AUTH) -> AUTH {
    (*this).creds = array_destroy((*this).creds);
    xfree((*this).basic.encode as *mut libc::c_void);
    xfree((*this).digest.encode as *mut libc::c_void);
    xfree((*this).ntlm.encode as *mut libc::c_void);
    xfree((*this).proxy.encode as *mut libc::c_void);
    xfree(this as *mut libc::c_void);
    return 0 as *mut libc::c_void as AUTH;
}
pub unsafe extern "C" fn auth_add(mut this: AUTH, mut creds: CREDS) {
    array_npush((*this).creds, creds as *mut libc::c_void, CREDSIZE);
}
pub unsafe extern "C" fn auth_display(mut this: AUTH, mut scheme: SCHEME) {
    let mut i: size_t = 0;
    let mut space: [libc::c_char; 33] = [0; 33];
    let mut first: BOOLEAN = boolean_false;
    let mut tmp: CREDS = 0 as *mut CREDS_T;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: SCHEME = UNSUPPORTED;
    let mut tmp___6: size_t = 0;
    space[0 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[1 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[2 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[3 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[4 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[5 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[6 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[7 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[8 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[9 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[10 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[11 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[12 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[13 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[14 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[15 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[16 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[17 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[18 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[19 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[20 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[21 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[22 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[23 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[24 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[25 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[26 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[27 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[28 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[29 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[30 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[31 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    space[32 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    first = boolean_true;
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___6 = array_length((*this).creds);
        if !(i < tmp___6) {
            break;
        }
        tmp___0 = array_get((*this).creds, i as libc::c_int);
        tmp = tmp___0 as CREDS;
        tmp___5 = creds_get_scheme(tmp);
        if tmp___5 as libc::c_uint == scheme as libc::c_uint {
            tmp___1 = creds_get_realm(tmp);
            tmp___2 = creds_get_password(tmp);
            tmp___3 = creds_get_username(tmp);
            if first as libc::c_uint == 1 as libc::c_uint {
                tmp___4 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___4 = space.as_mut_ptr() as *const libc::c_char;
            }
            printf(
                b"%scredentials:  %s:%s:%s\n\0" as *const u8 as *const libc::c_char,
                tmp___4,
                tmp___3,
                tmp___2,
                tmp___1,
            );
            first = boolean_false;
        }
        i = i.wrapping_add(1);
    };
}
pub unsafe extern "C" fn auth_get_basic_header(
    mut this: AUTH,
    mut scheme: SCHEME,
) -> *mut libc::c_char {
    if scheme as libc::c_uint == 4 as libc::c_uint {
        return (*this).proxy.encode
    } else {
        return (*this).basic.encode
    };
}
pub unsafe extern "C" fn auth_set_basic_header(
    mut this: AUTH,
    mut scheme: SCHEME,
    mut realm: *mut libc::c_char,
) -> BOOLEAN {
    let mut i: size_t = 0;
    let mut tmp: CREDS = 0 as *mut CREDS_T;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: SCHEME = UNSUPPORTED;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: CREDS = 0 as *mut CREDS_T;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: BOOLEAN = boolean_false;
    let mut tmp___9: SCHEME = UNSUPPORTED;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: BOOLEAN = boolean_false;
    let mut tmp___12: size_t = 0;
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___5 = array_length((*this).creds);
        if !(i < tmp___5) {
            break;
        }
        tmp___0 = array_get((*this).creds, i as libc::c_int);
        tmp = tmp___0 as CREDS;
        if realm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        tmp___3 = creds_get_realm(tmp);
        tmp___4 = strmatch(tmp___3, realm);
        if tmp___4 as u64 != 0 {
            tmp___2 = creds_get_scheme(tmp);
            if tmp___2 as libc::c_uint == scheme as libc::c_uint {
                tmp___1 = __basic_header(this, scheme, tmp);
                return tmp___1;
            }
        }
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___12 = array_length((*this).creds);
        if !(i < tmp___12) {
            break;
        }
        tmp___7 = array_get((*this).creds, i as libc::c_int);
        tmp___6 = tmp___7 as CREDS;
        tmp___10 = creds_get_realm(tmp___6);
        tmp___11 = strmatch(
            tmp___10,
            b"any\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___11 as u64 != 0 {
            tmp___9 = creds_get_scheme(tmp___6);
            if tmp___9 as libc::c_uint == scheme as libc::c_uint {
                tmp___8 = __basic_header(this, scheme, tmp___6);
                return tmp___8;
            }
        }
        i = i.wrapping_add(1);
    }
    return boolean_false;
}
pub unsafe extern "C" fn auth_set_ntlm_header(
    mut this: AUTH,
    mut scheme: SCHEME,
    mut header: *mut libc::c_char,
    mut realm: *mut libc::c_char,
) -> BOOLEAN {
    let mut i: size_t = 0;
    let mut tmp: CREDS = 0 as *mut CREDS_T;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: SCHEME = UNSUPPORTED;
    let mut tmp___3: SCHEME = UNSUPPORTED;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: BOOLEAN = boolean_false;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: CREDS = 0 as *mut CREDS_T;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: BOOLEAN = boolean_false;
    let mut tmp___10: SCHEME = UNSUPPORTED;
    let mut tmp___11: SCHEME = UNSUPPORTED;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: BOOLEAN = boolean_false;
    let mut tmp___14: size_t = 0;
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___6 = array_length((*this).creds);
        if !(i < tmp___6) {
            break;
        }
        tmp___0 = array_get((*this).creds, i as libc::c_int);
        tmp = tmp___0 as CREDS;
        if realm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        tmp___4 = creds_get_realm(tmp);
        tmp___5 = strmatch(tmp___4, realm);
        if tmp___5 as u64 != 0 {
            tmp___2 = creds_get_scheme(tmp);
            if tmp___2 as libc::c_uint == 1 as libc::c_uint {
                tmp___1 = __ntlm_header(
                    this,
                    scheme,
                    header as *const libc::c_char,
                    tmp,
                );
                return tmp___1;
            } else {
                tmp___3 = creds_get_scheme(tmp);
                if tmp___3 as libc::c_uint == 2 as libc::c_uint {
                    tmp___1 = __ntlm_header(
                        this,
                        scheme,
                        header as *const libc::c_char,
                        tmp,
                    );
                    return tmp___1;
                }
            }
        }
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___14 = array_length((*this).creds);
        if !(i < tmp___14) {
            break;
        }
        tmp___8 = array_get((*this).creds, i as libc::c_int);
        tmp___7 = tmp___8 as CREDS;
        tmp___12 = creds_get_realm(tmp___7);
        tmp___13 = strmatch(
            tmp___12,
            b"any\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___13 as u64 != 0 {
            tmp___10 = creds_get_scheme(tmp___7);
            if tmp___10 as libc::c_uint == 1 as libc::c_uint {
                tmp___9 = __ntlm_header(
                    this,
                    scheme,
                    header as *const libc::c_char,
                    tmp___7,
                );
                return tmp___9;
            } else {
                tmp___11 = creds_get_scheme(tmp___7);
                if tmp___11 as libc::c_uint == 2 as libc::c_uint {
                    tmp___9 = __ntlm_header(
                        this,
                        scheme,
                        header as *const libc::c_char,
                        tmp___7,
                    );
                    return tmp___9;
                }
            }
        }
        i = i.wrapping_add(1);
    }
    return boolean_false;
}
pub unsafe extern "C" fn auth_get_ntlm_header(
    mut this: AUTH,
    mut scheme: SCHEME,
) -> *mut libc::c_char {
    if scheme as libc::c_uint == 4 as libc::c_uint {
        return (*this).proxy.encode
    } else {
        return (*this).ntlm.encode
    };
}
pub unsafe extern "C" fn auth_get_digest_header(
    mut this: AUTH,
    mut scheme: SCHEME,
    mut chlg: *mut DCHLG,
    mut cred: *mut DCRED,
    mut method___0: *const libc::c_char,
    mut uri: *const libc::c_char,
) -> *mut libc::c_char {
    let mut len: size_t = 0;
    let mut cnonce: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nonce_count: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut qop: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut response: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut request_digest: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut h_a1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut h_a2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut opaque: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    cnonce = 0 as *mut libc::c_void as *mut libc::c_char;
    nonce_count = 0 as *mut libc::c_void as *mut libc::c_char;
    qop = 0 as *mut libc::c_void as *mut libc::c_char;
    response = 0 as *mut libc::c_void as *mut libc::c_char;
    request_digest = 0 as *mut libc::c_void as *mut libc::c_char;
    h_a1 = 0 as *mut libc::c_void as *mut libc::c_char;
    h_a2 = 0 as *mut libc::c_void as *mut libc::c_char;
    opaque = 0 as *mut libc::c_void as *mut libc::c_char;
    result = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    if chlg as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char
    } else {
        if cred as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
    }
    let mut current_block_49: u64;
    if chlg as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*chlg).qop as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            nonce_count = xstrcat(
                b", nc=\0" as *const u8 as *const libc::c_char,
                ((*cred).nc).as_mut_ptr(),
                0 as *mut libc::c_void,
            );
            cnonce = xstrcat(
                b", cnonce=\"\0" as *const u8 as *const libc::c_char,
                (*cred).cnonce_value,
                b"\"\0" as *const u8 as *const libc::c_char,
                0 as *mut libc::c_void,
            );
            h_a1 = __get_h_a1(
                chlg as *const DCHLG,
                cred,
                (*chlg).nonce as *const libc::c_char,
            );
            if 0 as *mut libc::c_void as libc::c_ulong == h_a1 as libc::c_ulong {
                fprintf(
                    stderr,
                    b"error calling __get_h_a1\n\0" as *const u8 as *const libc::c_char,
                );
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
            tmp___0 = __str_list_contains(
                (*chlg).qop as *const libc::c_char,
                b"auth\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as size_t,
            );
            if tmp___0 as u64 != 0 {
                qop = xstrdup(b", qop=auth\0" as *const u8 as *const libc::c_char);
                tmp = xstrcat(
                    method___0,
                    b":\0" as *const u8 as *const libc::c_char,
                    uri,
                    0 as *mut libc::c_void,
                );
                h_a2 = __get_md5_str(tmp as *const libc::c_char);
                xfree(tmp as *mut libc::c_void);
                tmp = xstrcat(
                    h_a1 as *const libc::c_char,
                    b":\0" as *const u8 as *const libc::c_char,
                    (*chlg).nonce,
                    b":\0" as *const u8 as *const libc::c_char,
                    ((*cred).nc).as_mut_ptr(),
                    b":\0" as *const u8 as *const libc::c_char,
                    (*cred).cnonce_value,
                    b":auth:\0" as *const u8 as *const libc::c_char,
                    h_a2,
                    0 as *mut libc::c_void,
                );
                request_digest = __get_md5_str(tmp as *const libc::c_char);
                xfree(tmp as *mut libc::c_void);
                response = xstrcat(
                    b", response=\"\0" as *const u8 as *const libc::c_char,
                    request_digest,
                    b"\"\0" as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                );
            } else {
                fprintf(
                    stderr,
                    b"error quality of protection not supported: %s\n\0" as *const u8
                        as *const libc::c_char,
                    (*chlg).qop,
                );
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
            current_block_49 = 721385680381463314;
        } else {
            current_block_49 = 1289612236207807559;
        }
    } else {
        current_block_49 = 1289612236207807559;
    }
    match current_block_49 {
        1289612236207807559 => {
            h_a1 = __get_h_a1(
                chlg as *const DCHLG,
                cred,
                b"\0" as *const u8 as *const libc::c_char,
            );
            if 0 as *mut libc::c_void as libc::c_ulong == h_a1 as libc::c_ulong {
                NOTIFY(ERROR, b"__get_h_a1\n\0" as *const u8 as *const libc::c_char);
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
            tmp = xstrcat(
                method___0,
                b":\0" as *const u8 as *const libc::c_char,
                uri,
                0 as *mut libc::c_void,
            );
            h_a2 = __get_md5_str(tmp as *const libc::c_char);
            xfree(tmp as *mut libc::c_void);
            tmp = xstrcat(
                h_a1 as *const libc::c_char,
                b":\0" as *const u8 as *const libc::c_char,
                (*chlg).nonce,
                b":\0" as *const u8 as *const libc::c_char,
                h_a2,
                0 as *mut libc::c_void,
            );
            request_digest = __get_md5_str(tmp as *const libc::c_char);
            xfree(tmp as *mut libc::c_void);
            response = xstrcat(
                b" response=\"\0" as *const u8 as *const libc::c_char,
                request_digest,
                b"\"\0" as *const u8 as *const libc::c_char,
                0 as *mut libc::c_void,
            );
        }
        _ => {}
    }
    if chlg as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*chlg).opaque as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            opaque = xstrcat(
                b", opaque=\"\0" as *const u8 as *const libc::c_char,
                (*chlg).opaque,
                b"\"\0" as *const u8 as *const libc::c_char,
                0 as *mut libc::c_void,
            );
        }
    }
    if !cnonce.is_null() {
        tmp___1 = cnonce as *const libc::c_char;
    } else {
        tmp___1 = b"\0" as *const u8 as *const libc::c_char;
    }
    if !nonce_count.is_null() {
        tmp___2 = nonce_count as *const libc::c_char;
    } else {
        tmp___2 = b"\0" as *const u8 as *const libc::c_char;
    }
    if !qop.is_null() {
        tmp___3 = qop as *const libc::c_char;
    } else {
        tmp___3 = b"\0" as *const u8 as *const libc::c_char;
    }
    if !opaque.is_null() {
        tmp___4 = opaque as *const libc::c_char;
    } else {
        tmp___4 = b"\0" as *const u8 as *const libc::c_char;
    }
    result = xstrcat(
        b"Digest username=\"\0" as *const u8 as *const libc::c_char,
        (*cred).username,
        b"\", realm=\"\0" as *const u8 as *const libc::c_char,
        (*chlg).realm,
        b"\", nonce=\"\0" as *const u8 as *const libc::c_char,
        (*chlg).nonce,
        b"\", uri=\"\0" as *const u8 as *const libc::c_char,
        uri,
        b"\", algorithm=\0" as *const u8 as *const libc::c_char,
        (*chlg).algorithm,
        response,
        tmp___4,
        tmp___3,
        tmp___2,
        tmp___1,
        0 as *mut libc::c_void,
    );
    (*cred).nc_value = ((*cred).nc_value).wrapping_add(1);
    snprintf(
        ((*cred).nc).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong,
        b"%.8x\0" as *const u8 as *const libc::c_char,
        (*cred).nc_value,
    );
    tmp___5 = strcasecmp(
        b"MD5\0" as *const u8 as *const libc::c_char,
        (*chlg).algorithm as *const libc::c_char,
    );
    if 0 as libc::c_int == tmp___5 {
        xfree(h_a1 as *mut libc::c_void);
    }
    xfree(nonce_count as *mut libc::c_void);
    xfree(cnonce as *mut libc::c_void);
    xfree(qop as *mut libc::c_void);
    xfree(response as *mut libc::c_void);
    xfree(request_digest as *mut libc::c_void);
    xfree(h_a2 as *mut libc::c_void);
    xfree(opaque as *mut libc::c_void);
    tmp___6 = strlen(result as *const libc::c_char);
    len = tmp___6.wrapping_add(32 as libc::c_ulong);
    if scheme as libc::c_uint == 4 as libc::c_uint {
        tmp___7 = xmalloc(len);
        (*this).proxy.encode = tmp___7 as *mut libc::c_char;
        memset((*this).proxy.encode as *mut libc::c_void, '\u{0}' as i32, len);
        snprintf(
            (*this).proxy.encode,
            len,
            b"Proxy-Authorization: %s\r\n\0" as *const u8 as *const libc::c_char,
            result,
        );
        xfree(result as *mut libc::c_void);
        return (*this).proxy.encode;
    } else {
        tmp___8 = xmalloc(len);
        (*this).digest.encode = tmp___8 as *mut libc::c_char;
        memset((*this).digest.encode as *mut libc::c_void, '\u{0}' as i32, len);
        snprintf(
            (*this).digest.encode,
            len,
            b"Authorization: %s\r\n\0" as *const u8 as *const libc::c_char,
            result,
        );
        xfree(result as *mut libc::c_void);
        return (*this).digest.encode;
    };
}
pub unsafe extern "C" fn auth_set_digest_header(
    mut this: AUTH,
    mut chlg: *mut *mut DCHLG,
    mut cred: *mut *mut DCRED,
    mut rand___0: *mut libc::c_uint,
    mut realm: *mut libc::c_char,
    mut str: *mut libc::c_char,
) -> BOOLEAN {
    let mut i: size_t = 0;
    let mut tmp: CREDS = 0 as *mut CREDS_T;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: CREDS = 0 as *mut CREDS_T;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: BOOLEAN = boolean_false;
    let mut tmp___8: size_t = 0;
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___3 = array_length((*this).creds);
        if !(i < tmp___3) {
            break;
        }
        tmp___0 = array_get((*this).creds, i as libc::c_int);
        tmp = tmp___0 as CREDS;
        if realm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        tmp___1 = creds_get_realm(tmp);
        tmp___2 = strmatch(tmp___1, realm);
        if tmp___2 as u64 != 0 {
            *chlg = __digest_challenge(str as *const libc::c_char);
            *cred = __digest_credentials(tmp, rand___0);
            if *cred as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                return boolean_false
            } else {
                if *chlg as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    return boolean_false;
                }
            }
            return boolean_true;
        }
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___8 = array_length((*this).creds);
        if !(i < tmp___8) {
            break;
        }
        tmp___5 = array_get((*this).creds, i as libc::c_int);
        tmp___4 = tmp___5 as CREDS;
        tmp___6 = creds_get_realm(tmp___4);
        tmp___7 = strmatch(
            tmp___6,
            b"any\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___7 as u64 != 0 {
            *chlg = __digest_challenge(str as *const libc::c_char);
            *cred = __digest_credentials(tmp___4, rand___0);
            if *cred as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                return boolean_false
            } else {
                if *chlg as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    return boolean_false;
                }
            }
            return boolean_true;
        }
        i = i.wrapping_add(1);
    }
    return boolean_false;
}
pub unsafe extern "C" fn auth_get_proxy_required(mut this: AUTH) -> BOOLEAN {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_false;
    }
    return (*this).proxy.required;
}
pub unsafe extern "C" fn auth_get_proxy_host(mut this: AUTH) -> *mut libc::c_char {
    return (*this).proxy.hostname;
}
pub unsafe extern "C" fn auth_get_proxy_port(mut this: AUTH) -> libc::c_int {
    return (*this).proxy.port;
}
pub unsafe extern "C" fn auth_set_proxy_required(mut this: AUTH, mut required: BOOLEAN) {
    (*this).proxy.required = required;
}
pub unsafe extern "C" fn auth_set_proxy_host(
    mut this: AUTH,
    mut host: *mut libc::c_char,
) {
    (*this).proxy.hostname = xstrdup(host as *const libc::c_char);
    (*this).proxy.required = boolean_true;
}
pub unsafe extern "C" fn auth_set_proxy_port(mut this: AUTH, mut port: libc::c_int) {
    (*this).proxy.port = port;
}
pub unsafe extern "C" fn auth_get_ftp_username(
    mut this: AUTH,
    mut realm: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: size_t = 0;
    let mut tmp: CREDS = 0 as *mut CREDS_T;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: SCHEME = UNSUPPORTED;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: CREDS = 0 as *mut CREDS_T;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: SCHEME = UNSUPPORTED;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: BOOLEAN = boolean_false;
    let mut tmp___12: size_t = 0;
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___5 = array_length((*this).creds);
        if !(i < tmp___5) {
            break;
        }
        tmp___0 = array_get((*this).creds, i as libc::c_int);
        tmp = tmp___0 as CREDS;
        tmp___3 = creds_get_realm(tmp);
        tmp___4 = strmatch(tmp___3, realm);
        if tmp___4 as u64 != 0 {
            tmp___2 = creds_get_scheme(tmp);
            if tmp___2 as libc::c_uint == 3 as libc::c_uint {
                tmp___1 = creds_get_username(tmp);
                return tmp___1;
            }
        }
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___12 = array_length((*this).creds);
        if !(i < tmp___12) {
            break;
        }
        tmp___7 = array_get((*this).creds, i as libc::c_int);
        tmp___6 = tmp___7 as CREDS;
        tmp___10 = creds_get_realm(tmp___6);
        tmp___11 = strmatch(
            tmp___10,
            b"any\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___11 as u64 != 0 {
            tmp___9 = creds_get_scheme(tmp___6);
            if tmp___9 as libc::c_uint == 3 as libc::c_uint {
                tmp___8 = creds_get_username(tmp___6);
                return tmp___8;
            }
        }
        i = i.wrapping_add(1);
    }
    return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
}
pub unsafe extern "C" fn auth_get_ftp_password(
    mut this: AUTH,
    mut realm: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: size_t = 0;
    let mut tmp: CREDS = 0 as *mut CREDS_T;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: SCHEME = UNSUPPORTED;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: CREDS = 0 as *mut CREDS_T;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: SCHEME = UNSUPPORTED;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: BOOLEAN = boolean_false;
    let mut tmp___12: size_t = 0;
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___5 = array_length((*this).creds);
        if !(i < tmp___5) {
            break;
        }
        tmp___0 = array_get((*this).creds, i as libc::c_int);
        tmp = tmp___0 as CREDS;
        tmp___3 = creds_get_realm(tmp);
        tmp___4 = strmatch(tmp___3, realm);
        if tmp___4 as u64 != 0 {
            tmp___2 = creds_get_scheme(tmp);
            if tmp___2 as libc::c_uint == 3 as libc::c_uint {
                tmp___1 = creds_get_password(tmp);
                return tmp___1;
            }
        }
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___12 = array_length((*this).creds);
        if !(i < tmp___12) {
            break;
        }
        tmp___7 = array_get((*this).creds, i as libc::c_int);
        tmp___6 = tmp___7 as CREDS;
        tmp___10 = creds_get_realm(tmp___6);
        tmp___11 = strmatch(
            tmp___10,
            b"any\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___11 as u64 != 0 {
            tmp___9 = creds_get_scheme(tmp___6);
            if tmp___9 as libc::c_uint == 3 as libc::c_uint {
                tmp___8 = creds_get_password(tmp___6);
                return tmp___8;
            }
        }
        i = i.wrapping_add(1);
    }
    return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
}
unsafe extern "C" fn __basic_header(
    mut this: AUTH,
    mut scheme: SCHEME,
    mut creds: CREDS,
) -> BOOLEAN {
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut hdr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut ret: BOOLEAN = boolean_false;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: libc::c_int = 0;
    ret = boolean_true;
    memset(
        buf.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
    );
    pthread_mutex_lock(&mut (*this).lock);
    tmp = creds_get_password(creds);
    tmp___0 = creds_get_username(creds);
    snprintf(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s:%s\0" as *const u8 as *const libc::c_char,
        tmp___0,
        tmp,
    );
    if scheme as libc::c_uint == 4 as libc::c_uint {
        xfree((*this).proxy.encode as *mut libc::c_void);
        tmp___3 = strlen(buf.as_mut_ptr() as *const libc::c_char);
        tmp___4 = base64_encode(
            buf.as_mut_ptr() as *const libc::c_void,
            tmp___3 as libc::c_int,
            &mut hdr,
        );
        if tmp___4 < 0 as libc::c_int {
            ret = boolean_false;
        } else {
            tmp___1 = strlen(hdr as *const libc::c_char);
            len = tmp___1.wrapping_add(32 as libc::c_ulong);
            tmp___2 = xmalloc(len);
            (*this).proxy.encode = tmp___2 as *mut libc::c_char;
            memset((*this).proxy.encode as *mut libc::c_void, '\u{0}' as i32, len);
            snprintf(
                (*this).proxy.encode,
                len,
                b"Proxy-Authorization: Basic %s\r\n\0" as *const u8
                    as *const libc::c_char,
                hdr,
            );
        }
    } else {
        xfree((*this).basic.encode as *mut libc::c_void);
        tmp___7 = strlen(buf.as_mut_ptr() as *const libc::c_char);
        tmp___8 = base64_encode(
            buf.as_mut_ptr() as *const libc::c_void,
            tmp___7 as libc::c_int,
            &mut hdr,
        );
        if tmp___8 < 0 as libc::c_int {
            ret = boolean_false;
        } else {
            tmp___5 = strlen(hdr as *const libc::c_char);
            len = tmp___5.wrapping_add(32 as libc::c_ulong);
            tmp___6 = xmalloc(len);
            (*this).basic.encode = tmp___6 as *mut libc::c_char;
            memset((*this).basic.encode as *mut libc::c_void, '\u{0}' as i32, len);
            snprintf(
                (*this).basic.encode,
                len,
                b"Authorization: Basic %s\r\n\0" as *const u8 as *const libc::c_char,
                hdr,
            );
        }
    }
    pthread_mutex_unlock(&mut (*this).lock);
    return ret;
}
unsafe extern "C" fn __ntlm_header(
    mut this: AUTH,
    mut scheme: SCHEME,
    mut header: *const libc::c_char,
    mut creds: CREDS,
) -> BOOLEAN {
    let mut size: size_t = 0;
    let mut final_0: size_t = 0;
    let mut domstr: *const libc::c_char = 0 as *const libc::c_char;
    let mut srvstr: *const libc::c_char = 0 as *const libc::c_char;
    let mut domlen: size_t = 0;
    let mut tmp: size_t = 0;
    let mut srvlen: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut srvoff: size_t = 0;
    let mut domoff: size_t = 0;
    let mut hdr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: [libc::c_char; 8192] = [0; 8192];
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut size___0: ssize_t = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut lmrespoff: size_t = 0;
    let mut ntrespoff: size_t = 0;
    let mut usroff: size_t = 0;
    let mut lmresp: [libc::c_uchar; 24] = [0; 24];
    let mut ntresp: [libc::c_uchar; 24] = [0; 24];
    let mut usrlen: size_t = 0;
    let mut usr: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: size_t = 0;
    let mut tmp___20: *mut libc::c_void = 0 as *mut libc::c_void;
    size = 0 as libc::c_int as size_t;
    final_0 = 0 as libc::c_int as size_t;
    domstr = b"\0" as *const u8 as *const libc::c_char;
    srvstr = b"\0" as *const u8 as *const libc::c_char;
    tmp = strlen(domstr);
    domlen = tmp;
    tmp___0 = strlen(srvstr);
    srvlen = tmp___0;
    tmp___2 = strncasecmp(
        header,
        b"NTLM\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int as size_t,
    );
    if tmp___2 != 0 {
        return boolean_false;
    }
    tmp___3 = creds_get_username(creds);
    NOTIFY(
        DEBUG,
        b"Parsing NTLM header:  %d, %d, %s, %s\0" as *const u8 as *const libc::c_char,
        (*this).okay as libc::c_uint,
        scheme as libc::c_uint,
        header,
        tmp___3,
    );
    header = header.offset(4 as libc::c_int as isize);
    while *header != 0 {
        tmp___4 = __ctype_b_loc();
        if *(*tmp___4).offset(*header as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int == 0
        {
            break;
        }
        header = header.offset(1);
    }
    if *header != 0 {
        tmp___5 = strlen(header);
        memset(tmp___1.as_mut_ptr() as *mut libc::c_void, '\u{0}' as i32, tmp___5);
        tmp___6 = base64_decode(
            header,
            &mut tmp___1 as *mut [libc::c_char; 8192] as *mut libc::c_void,
        );
        size___0 = tmp___6 as ssize_t;
        if size___0 < 0 as libc::c_long {
            return boolean_false;
        }
        if size___0 >= 48 as libc::c_long {
            memcpy(
                ((*this).ntlm.nonce).as_mut_ptr() as *mut libc::c_void,
                &mut *tmp___1.as_mut_ptr().offset(24 as libc::c_int as isize)
                    as *mut libc::c_char as *const libc::c_void,
                8 as libc::c_int as size_t,
            );
        }
        (*this).ntlm.state = TYPE_2;
    } else {
        if (*this).ntlm.state as libc::c_uint >= 1 as libc::c_uint {
            return boolean_false;
        }
        (*this).ntlm.state = TYPE_1;
    }
    match (*this).ntlm.state as libc::c_uint {
        4 | 0 | 1 => {
            srvoff = 32 as libc::c_int as size_t;
            domoff = srvoff.wrapping_add(srvlen);
            snprintf(
                buf.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"NTLMSSP%c\x01%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%s%s\0"
                    as *const u8 as *const libc::c_char,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 9 as libc::c_int) & 255 as libc::c_int,
                ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 9 as libc::c_int) >> 8 as libc::c_int
                    & 255 as libc::c_int,
                ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 9 as libc::c_int) >> 16 as libc::c_int
                    & 255 as libc::c_int,
                ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 9 as libc::c_int) >> 24 as libc::c_int,
                (domlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (domlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (domlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (domlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (domoff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (domoff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (srvlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (srvlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (srvlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (srvlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (srvoff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (srvoff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                srvstr,
                domstr,
            );
            size = (32 as libc::c_ulong).wrapping_add(srvlen).wrapping_add(domlen);
            tmp___7 = base64_encode(
                buf.as_mut_ptr() as *const libc::c_void,
                size as libc::c_int,
                &mut hdr,
            );
            if tmp___7 < 0 as libc::c_int {
                return boolean_false;
            }
            tmp___8 = strlen(hdr as *const libc::c_char);
            final_0 = tmp___8.wrapping_add(23 as libc::c_ulong);
            tmp___9 = xmalloc(final_0);
            (*this).ntlm.encode = tmp___9 as *mut libc::c_char;
            (*this).ntlm.state = TYPE_2;
            memset((*this).ntlm.encode as *mut libc::c_void, '\u{0}' as i32, final_0);
            snprintf(
                (*this).ntlm.encode,
                final_0,
                b"Authorization: NTLM %s\r\n\0" as *const u8 as *const libc::c_char,
                hdr,
            );
        }
        2 => {
            tmp___10 = creds_get_username(creds);
            tmp___11 = strchr(tmp___10 as *const libc::c_char, '\\' as i32);
            usr = tmp___11 as *const libc::c_char;
            if usr.is_null() {
                tmp___12 = creds_get_username(creds);
                tmp___13 = strchr(tmp___12 as *const libc::c_char, '/' as i32);
                usr = tmp___13 as *const libc::c_char;
            }
            if !usr.is_null() {
                tmp___14 = creds_get_username(creds);
                domstr = tmp___14 as *const libc::c_char;
                domlen = usr.offset_from(domstr) as libc::c_long as size_t;
                usr = usr.offset(1);
            } else {
                tmp___15 = creds_get_username(creds);
                usr = tmp___15 as *const libc::c_char;
            }
            usrlen = strlen(usr);
            tmp___16 = creds_get_password(creds);
            __mkhash(
                tmp___16 as *const libc::c_char,
                &mut *((*this).ntlm.nonce)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize),
                lmresp.as_mut_ptr(),
                ntresp.as_mut_ptr(),
            );
            domoff = 64 as libc::c_int as size_t;
            usroff = domoff.wrapping_add(domlen);
            srvoff = usroff.wrapping_add(usrlen);
            lmrespoff = srvoff.wrapping_add(srvlen);
            ntrespoff = lmrespoff.wrapping_add(24 as libc::c_ulong);
            tmp___17 = snprintf(
                buf.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"NTLMSSP%c\x03%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\xFF\xFF%c%c\x01\x82%c%c\0"
                    as *const u8 as *const libc::c_char,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                24 as libc::c_int,
                (24 as libc::c_int >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                24 as libc::c_int,
                (24 as libc::c_int >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (lmrespoff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (lmrespoff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                24 as libc::c_int,
                (24 as libc::c_int >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                24 as libc::c_int,
                (24 as libc::c_int >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (ntrespoff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (ntrespoff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (domlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (domlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (domlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (domlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (domoff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (domoff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (usrlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (usrlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (usrlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (usrlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (usroff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (usroff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (srvlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (srvlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (srvlen & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (srvlen >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                (srvoff & 255 as libc::c_ulong) as libc::c_char as libc::c_int,
                (srvoff >> 8 as libc::c_int) as libc::c_char as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            );
            size = tmp___17 as size_t;
            size = 64 as libc::c_int as size_t;
            buf[63 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            buf[62 as libc::c_int as usize] = buf[63 as libc::c_int as usize];
            if size.wrapping_add(usrlen).wrapping_add(domlen)
                >= ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong
            {
                return boolean_false;
            }
            memcpy(
                &mut *buf.as_mut_ptr().offset(size as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                domstr as *const libc::c_void,
                domlen,
            );
            size = (size as libc::c_ulong).wrapping_add(domlen) as size_t as size_t;
            memcpy(
                &mut *buf.as_mut_ptr().offset(size as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                usr as *const libc::c_void,
                usrlen,
            );
            size = (size as libc::c_ulong).wrapping_add(usrlen) as size_t as size_t;
            if size
                < (::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                    .wrapping_sub(24 as libc::c_ulong)
            {
                memcpy(
                    &mut *buf.as_mut_ptr().offset(size as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    lmresp.as_mut_ptr() as *const libc::c_void,
                    24 as libc::c_int as size_t,
                );
                size = (size as libc::c_ulong).wrapping_add(24 as libc::c_ulong)
                    as size_t as size_t;
            }
            if size
                < (::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                    .wrapping_sub(24 as libc::c_ulong)
            {
                memcpy(
                    &mut *buf.as_mut_ptr().offset(size as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    ntresp.as_mut_ptr() as *const libc::c_void,
                    24 as libc::c_int as size_t,
                );
                size = (size as libc::c_ulong).wrapping_add(24 as libc::c_ulong)
                    as size_t as size_t;
            }
            buf[56 as libc::c_int
                as usize] = (size & 255 as libc::c_ulong) as libc::c_char;
            buf[57 as libc::c_int as usize] = (size >> 8 as libc::c_int) as libc::c_char;
            tmp___18 = base64_encode(
                buf.as_mut_ptr() as *const libc::c_void,
                size as libc::c_int,
                &mut hdr,
            );
            if tmp___18 < 0 as libc::c_int {
                return boolean_false;
            }
            (*this).ntlm.state = TYPE_3;
            (*this).ntlm.ready = boolean_true;
            tmp___19 = strlen(hdr as *const libc::c_char);
            final_0 = tmp___19.wrapping_add(23 as libc::c_ulong);
            tmp___20 = xrealloc((*this).ntlm.encode as *mut libc::c_void, final_0);
            (*this).ntlm.encode = tmp___20 as *mut libc::c_char;
            memset((*this).ntlm.encode as *mut libc::c_void, '\u{0}' as i32, final_0);
            snprintf(
                (*this).ntlm.encode,
                final_0,
                b"Authorization: NTLM %s\r\n\0" as *const u8 as *const libc::c_char,
                hdr,
            );
        }
        3 => {
            (*this).ntlm.ready = boolean_true;
        }
        _ => {}
    }
    return boolean_true;
}
unsafe extern "C" fn setup_des_key(
    mut key_56: *mut libc::c_uchar,
    mut ks: *mut DES_key_schedule,
) {
    let mut key: DES_cblock = [0; 8];
    key[0 as libc::c_int as usize] = *key_56.offset(0 as libc::c_int as isize);
    key[1 as libc::c_int
        as usize] = ((*key_56.offset(0 as libc::c_int as isize) as libc::c_int)
        << 7 as libc::c_int & 255 as libc::c_int
        | *key_56.offset(1 as libc::c_int as isize) as libc::c_int >> 1 as libc::c_int)
        as libc::c_uchar;
    key[2 as libc::c_int
        as usize] = ((*key_56.offset(1 as libc::c_int as isize) as libc::c_int)
        << 6 as libc::c_int & 255 as libc::c_int
        | *key_56.offset(2 as libc::c_int as isize) as libc::c_int >> 2 as libc::c_int)
        as libc::c_uchar;
    key[3 as libc::c_int
        as usize] = ((*key_56.offset(2 as libc::c_int as isize) as libc::c_int)
        << 5 as libc::c_int & 255 as libc::c_int
        | *key_56.offset(3 as libc::c_int as isize) as libc::c_int >> 3 as libc::c_int)
        as libc::c_uchar;
    key[4 as libc::c_int
        as usize] = ((*key_56.offset(3 as libc::c_int as isize) as libc::c_int)
        << 4 as libc::c_int & 255 as libc::c_int
        | *key_56.offset(4 as libc::c_int as isize) as libc::c_int >> 4 as libc::c_int)
        as libc::c_uchar;
    key[5 as libc::c_int
        as usize] = ((*key_56.offset(4 as libc::c_int as isize) as libc::c_int)
        << 3 as libc::c_int & 255 as libc::c_int
        | *key_56.offset(5 as libc::c_int as isize) as libc::c_int >> 5 as libc::c_int)
        as libc::c_uchar;
    key[6 as libc::c_int
        as usize] = ((*key_56.offset(5 as libc::c_int as isize) as libc::c_int)
        << 2 as libc::c_int & 255 as libc::c_int
        | *key_56.offset(6 as libc::c_int as isize) as libc::c_int >> 6 as libc::c_int)
        as libc::c_uchar;
    key[7 as libc::c_int
        as usize] = ((*key_56.offset(6 as libc::c_int as isize) as libc::c_int)
        << 1 as libc::c_int & 255 as libc::c_int) as libc::c_uchar;
    DES_set_odd_parity(&mut key);
    DES_set_key(&mut key, ks);
}
unsafe extern "C" fn calc_resp(
    mut keys___0: *mut libc::c_uchar,
    mut plaintext: *mut libc::c_uchar,
    mut results: *mut libc::c_uchar,
) {
    let mut ks: DES_key_schedule = DES_key_schedule {
        ks: [__anonunion_ks_909163901 {
            cblock: [0; 8],
        }; 16],
    };
    setup_des_key(keys___0, &mut ks);
    DES_ecb_encrypt(
        plaintext as *mut DES_cblock,
        results as *mut DES_cblock,
        &mut ks,
        1 as libc::c_int,
    );
    setup_des_key(keys___0.offset(7 as libc::c_int as isize), &mut ks);
    DES_ecb_encrypt(
        plaintext as *mut DES_cblock,
        results.offset(8 as libc::c_int as isize) as *mut DES_cblock,
        &mut ks,
        1 as libc::c_int,
    );
    setup_des_key(keys___0.offset(14 as libc::c_int as isize), &mut ks);
    DES_ecb_encrypt(
        plaintext as *mut DES_cblock,
        results.offset(16 as libc::c_int as isize) as *mut DES_cblock,
        &mut ks,
        1 as libc::c_int,
    );
}
static mut magic: [libc::c_uchar; 8] = [
    75 as libc::c_int as libc::c_uchar,
    71 as libc::c_int as libc::c_uchar,
    83 as libc::c_int as libc::c_uchar,
    33 as libc::c_int as libc::c_uchar,
    64 as libc::c_int as libc::c_uchar,
    35 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
];
unsafe extern "C" fn __mkhash(
    mut password: *const libc::c_char,
    mut nonce: *mut libc::c_uchar,
    mut lmresp: *mut libc::c_uchar,
    mut ntresp: *mut libc::c_uchar,
) {
    let mut pw: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut lmbuffer: [libc::c_uchar; 21] = [0; 21];
    let mut ntbuffer: [libc::c_uchar; 21] = [0; 21];
    let mut i: size_t = 0;
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1 = 0 as *mut _;
    let mut __res: libc::c_int = 0;
    let mut tmp___3: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___4: libc::c_int = 0;
    let mut ks: DES_key_schedule = DES_key_schedule {
        ks: [__anonunion_ks_909163901 {
            cblock: [0; 8],
        }; 16],
    };
    let mut MD4___0: MD4_CTX = MD4_CTX {
        A: 0,
        B: 0,
        C: 0,
        D: 0,
        Nl: 0,
        Nh: 0,
        data: [0; 16],
        num: 0,
    };
    tmp = strlen(password);
    len = tmp;
    if len < 7 as libc::c_ulong {
        tmp___0 = 14 as libc::c_int as size_t;
    } else {
        tmp___0 = len.wrapping_mul(2 as libc::c_ulong);
    }
    let mut fresh2 = ::std::vec::from_elem(0, tmp___0 as usize);
    tmp___1 = fresh2.as_mut_ptr();
    pw = tmp___1 as *mut libc::c_uchar;
    if len > 14 as libc::c_ulong {
        len = 14 as libc::c_int as size_t;
    }
    i = 0 as libc::c_int as size_t;
    while i < len {
        if (*password.offset(i as isize) as libc::c_uint)
            .wrapping_sub(97 as libc::c_uint) <= 25 as libc::c_uint
        {
            if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong
                > 1 as libc::c_ulong
            {
                __res = toupper(*password.offset(i as isize) as libc::c_int);
            } else {
                tmp___3 = __ctype_toupper_loc();
                __res = *(*tmp___3)
                    .offset(*password.offset(i as isize) as libc::c_int as isize);
            }
            tmp___4 = __res;
        } else {
            tmp___4 = *password.offset(i as isize) as libc::c_int;
        }
        *pw.offset(i as isize) = tmp___4 as libc::c_uchar;
        i = i.wrapping_add(1);
    }
    while i < 14 as libc::c_ulong {
        *pw.offset(i as isize) = 0 as libc::c_int as libc::c_uchar;
        i = i.wrapping_add(1);
    }
    setup_des_key(pw, &mut ks);
    DES_ecb_encrypt(
        magic.as_ptr() as *mut DES_cblock,
        lmbuffer.as_mut_ptr() as *mut DES_cblock,
        &mut ks,
        1 as libc::c_int,
    );
    setup_des_key(pw.offset(7 as libc::c_int as isize), &mut ks);
    DES_ecb_encrypt(
        magic.as_ptr() as *mut DES_cblock,
        lmbuffer.as_mut_ptr().offset(8 as libc::c_int as isize) as *mut DES_cblock,
        &mut ks,
        1 as libc::c_int,
    );
    memset(
        lmbuffer.as_mut_ptr().offset(16 as libc::c_int as isize) as *mut libc::c_void,
        0 as libc::c_int,
        5 as libc::c_int as size_t,
    );
    calc_resp(lmbuffer.as_mut_ptr(), nonce, lmresp);
    len = strlen(password);
    i = 0 as libc::c_int as size_t;
    while i < len {
        *pw
            .offset(
                (2 as libc::c_ulong).wrapping_mul(i) as isize,
            ) = *password.offset(i as isize) as libc::c_uchar;
        *pw
            .offset(
                (2 as libc::c_ulong).wrapping_mul(i).wrapping_add(1 as libc::c_ulong)
                    as isize,
            ) = 0 as libc::c_int as libc::c_uchar;
        i = i.wrapping_add(1);
    }
    MD4_Init(&mut MD4___0);
    MD4_Update(
        &mut MD4___0,
        pw as *const libc::c_void,
        (2 as libc::c_ulong).wrapping_mul(len),
    );
    MD4_Final(ntbuffer.as_mut_ptr(), &mut MD4___0);
    memset(
        ntbuffer.as_mut_ptr().offset(16 as libc::c_int as isize) as *mut libc::c_void,
        0 as libc::c_int,
        5 as libc::c_int as size_t,
    );
    calc_resp(ntbuffer.as_mut_ptr(), nonce, ntresp);
}
static mut keyparser: [KEYPARSER; 8] = [
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"realm\0" as *const u8 as *const libc::c_char,
            keyval: REALM,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"domain\0" as *const u8 as *const libc::c_char,
            keyval: DOMAIN,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"nonce\0" as *const u8 as *const libc::c_char,
            keyval: NONCE,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"opaque\0" as *const u8 as *const libc::c_char,
            keyval: OPAQUE,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"stale\0" as *const u8 as *const libc::c_char,
            keyval: STALE,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"algorithm\0" as *const u8 as *const libc::c_char,
            keyval: ALGORITHM,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: b"qop\0" as *const u8 as *const libc::c_char,
            keyval: QOP,
        };
        init
    },
    {
        let mut init = __anonstruct_KEYPARSER_335600686 {
            keyname: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            keyval: UNKNOWN,
        };
        init
    },
];
unsafe extern "C" fn __get_keyval(mut key: *const libc::c_char) -> KEY_HEADER_E {
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(keyparser[i as usize].keyname).is_null() {
        tmp = strcasecmp(key, keyparser[i as usize].keyname);
        if tmp == 0 {
            return keyparser[i as usize].keyval;
        }
        i += 1;
    }
    return UNKNOWN;
}
unsafe extern "C" fn __get_random_string(
    mut length: size_t,
    mut randseed: *mut libc::c_uint,
) -> *mut libc::c_char {
    let mut b64_alphabet: [libc::c_uchar; 65] = [0; 65];
    let mut result: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut i: size_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    b64_alphabet[0 as libc::c_int as usize] = '0' as i32 as libc::c_uchar;
    b64_alphabet[1 as libc::c_int as usize] = '1' as i32 as libc::c_uchar;
    b64_alphabet[2 as libc::c_int as usize] = '2' as i32 as libc::c_uchar;
    b64_alphabet[3 as libc::c_int as usize] = '3' as i32 as libc::c_uchar;
    b64_alphabet[4 as libc::c_int as usize] = '4' as i32 as libc::c_uchar;
    b64_alphabet[5 as libc::c_int as usize] = '5' as i32 as libc::c_uchar;
    b64_alphabet[6 as libc::c_int as usize] = '6' as i32 as libc::c_uchar;
    b64_alphabet[7 as libc::c_int as usize] = '7' as i32 as libc::c_uchar;
    b64_alphabet[8 as libc::c_int as usize] = '8' as i32 as libc::c_uchar;
    b64_alphabet[9 as libc::c_int as usize] = '9' as i32 as libc::c_uchar;
    b64_alphabet[10 as libc::c_int as usize] = 'a' as i32 as libc::c_uchar;
    b64_alphabet[11 as libc::c_int as usize] = 'b' as i32 as libc::c_uchar;
    b64_alphabet[12 as libc::c_int as usize] = 'c' as i32 as libc::c_uchar;
    b64_alphabet[13 as libc::c_int as usize] = 'd' as i32 as libc::c_uchar;
    b64_alphabet[14 as libc::c_int as usize] = 'e' as i32 as libc::c_uchar;
    b64_alphabet[15 as libc::c_int as usize] = 'f' as i32 as libc::c_uchar;
    b64_alphabet[16 as libc::c_int as usize] = 'g' as i32 as libc::c_uchar;
    b64_alphabet[17 as libc::c_int as usize] = 'h' as i32 as libc::c_uchar;
    b64_alphabet[18 as libc::c_int as usize] = 'i' as i32 as libc::c_uchar;
    b64_alphabet[19 as libc::c_int as usize] = 'j' as i32 as libc::c_uchar;
    b64_alphabet[20 as libc::c_int as usize] = 'k' as i32 as libc::c_uchar;
    b64_alphabet[21 as libc::c_int as usize] = 'l' as i32 as libc::c_uchar;
    b64_alphabet[22 as libc::c_int as usize] = 'm' as i32 as libc::c_uchar;
    b64_alphabet[23 as libc::c_int as usize] = 'n' as i32 as libc::c_uchar;
    b64_alphabet[24 as libc::c_int as usize] = 'o' as i32 as libc::c_uchar;
    b64_alphabet[25 as libc::c_int as usize] = 'p' as i32 as libc::c_uchar;
    b64_alphabet[26 as libc::c_int as usize] = 'q' as i32 as libc::c_uchar;
    b64_alphabet[27 as libc::c_int as usize] = 'r' as i32 as libc::c_uchar;
    b64_alphabet[28 as libc::c_int as usize] = 's' as i32 as libc::c_uchar;
    b64_alphabet[29 as libc::c_int as usize] = 't' as i32 as libc::c_uchar;
    b64_alphabet[30 as libc::c_int as usize] = 'u' as i32 as libc::c_uchar;
    b64_alphabet[31 as libc::c_int as usize] = 'v' as i32 as libc::c_uchar;
    b64_alphabet[32 as libc::c_int as usize] = 'w' as i32 as libc::c_uchar;
    b64_alphabet[33 as libc::c_int as usize] = 'x' as i32 as libc::c_uchar;
    b64_alphabet[34 as libc::c_int as usize] = 'y' as i32 as libc::c_uchar;
    b64_alphabet[35 as libc::c_int as usize] = 'z' as i32 as libc::c_uchar;
    b64_alphabet[36 as libc::c_int as usize] = 'A' as i32 as libc::c_uchar;
    b64_alphabet[37 as libc::c_int as usize] = 'B' as i32 as libc::c_uchar;
    b64_alphabet[38 as libc::c_int as usize] = 'C' as i32 as libc::c_uchar;
    b64_alphabet[39 as libc::c_int as usize] = 'D' as i32 as libc::c_uchar;
    b64_alphabet[40 as libc::c_int as usize] = 'E' as i32 as libc::c_uchar;
    b64_alphabet[41 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
    b64_alphabet[42 as libc::c_int as usize] = 'G' as i32 as libc::c_uchar;
    b64_alphabet[43 as libc::c_int as usize] = 'H' as i32 as libc::c_uchar;
    b64_alphabet[44 as libc::c_int as usize] = 'I' as i32 as libc::c_uchar;
    b64_alphabet[45 as libc::c_int as usize] = 'J' as i32 as libc::c_uchar;
    b64_alphabet[46 as libc::c_int as usize] = 'K' as i32 as libc::c_uchar;
    b64_alphabet[47 as libc::c_int as usize] = 'L' as i32 as libc::c_uchar;
    b64_alphabet[48 as libc::c_int as usize] = 'M' as i32 as libc::c_uchar;
    b64_alphabet[49 as libc::c_int as usize] = 'N' as i32 as libc::c_uchar;
    b64_alphabet[50 as libc::c_int as usize] = 'O' as i32 as libc::c_uchar;
    b64_alphabet[51 as libc::c_int as usize] = 'P' as i32 as libc::c_uchar;
    b64_alphabet[52 as libc::c_int as usize] = 'Q' as i32 as libc::c_uchar;
    b64_alphabet[53 as libc::c_int as usize] = 'R' as i32 as libc::c_uchar;
    b64_alphabet[54 as libc::c_int as usize] = 'S' as i32 as libc::c_uchar;
    b64_alphabet[55 as libc::c_int as usize] = 'T' as i32 as libc::c_uchar;
    b64_alphabet[56 as libc::c_int as usize] = 'U' as i32 as libc::c_uchar;
    b64_alphabet[57 as libc::c_int as usize] = 'V' as i32 as libc::c_uchar;
    b64_alphabet[58 as libc::c_int as usize] = 'W' as i32 as libc::c_uchar;
    b64_alphabet[59 as libc::c_int as usize] = 'X' as i32 as libc::c_uchar;
    b64_alphabet[60 as libc::c_int as usize] = 'Y' as i32 as libc::c_uchar;
    b64_alphabet[61 as libc::c_int as usize] = 'Z' as i32 as libc::c_uchar;
    b64_alphabet[62 as libc::c_int as usize] = '.' as i32 as libc::c_uchar;
    b64_alphabet[63 as libc::c_int as usize] = '/' as i32 as libc::c_uchar;
    b64_alphabet[64 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_uchar;
    tmp = xmalloc(
        (::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
            .wrapping_mul(length.wrapping_add(1 as libc::c_ulong)),
    );
    result = tmp as *mut libc::c_uchar;
    i = 0 as libc::c_int as size_t;
    while i < length {
        tmp___0 = pthread_rand_np(randseed);
        *result
            .offset(
                i as isize,
            ) = (255.0f64
            * (tmp___0 as libc::c_double
                / (2147483647 as libc::c_int as libc::c_double + 1.0f64))) as libc::c_int
            as libc::c_uchar;
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as size_t;
    while i < length {
        *result
            .offset(
                i as isize,
            ) = b64_alphabet[(*result.offset(i as isize) as libc::c_ulong)
            .wrapping_rem(
                (::std::mem::size_of::<[libc::c_uchar; 65]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong)
                    .wrapping_div(
                        ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
                    ),
            ) as usize];
        i = i.wrapping_add(1);
    }
    *result.offset(length as isize) = '\u{0}' as i32 as libc::c_uchar;
    return result as *mut libc::c_char;
}
unsafe extern "C" fn __digest_credentials(
    mut creds: CREDS,
    mut randseed: *mut libc::c_uint,
) -> *mut DCRED {
    let mut result: *mut DCRED = 0 as *mut DCRED;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = xcalloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<DIGEST_CRED>() as libc::c_ulong,
    );
    result = tmp as *mut DCRED;
    tmp___0 = creds_get_username(creds);
    (*result).username = xstrdup(tmp___0 as *const libc::c_char);
    tmp___1 = creds_get_password(creds);
    (*result).password = xstrdup(tmp___1 as *const libc::c_char);
    (*result).cnonce_value = __get_random_string(16 as libc::c_int as size_t, randseed);
    (*result).nc_value = 1 as libc::c_uint;
    snprintf(
        ((*result).nc).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong,
        b"%.8x\0" as *const u8 as *const libc::c_char,
        (*result).nc_value,
    );
    (*result).h_a1 = 0 as *mut libc::c_void as *mut libc::c_char;
    return result;
}
unsafe extern "C" fn __digest_challenge(
    mut challenge: *const libc::c_char,
) -> *mut DCHLG {
    let mut result: *mut DCHLG = 0 as *mut DCHLG;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut val: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut beg: *const libc::c_char = 0 as *const libc::c_char;
    let mut end: *const libc::c_char = 0 as *const libc::c_char;
    let mut keyval: KEY_HEADER_E = REALM;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___7: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = xcalloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<DIGEST_CHLG>() as libc::c_ulong,
    );
    result = tmp as *mut DCHLG;
    end = challenge;
    beg = end;
    loop {
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*end as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int != 0
        {
            break;
        }
        if *end == 0 {
            break;
        }
        end = end.offset(1);
    }
    tmp___1 = strncasecmp(
        b"Digest\0" as *const u8 as *const libc::c_char,
        beg,
        end.offset_from(beg) as libc::c_long as size_t,
    );
    if tmp___1 != 0 {
        fprintf(
            stderr,
            b"no Digest keyword in challenge [%s]\n\0" as *const u8
                as *const libc::c_char,
            challenge,
        );
        return 0 as *mut libc::c_void as *mut DCHLG;
    }
    beg = end;
    loop {
        tmp___2 = __ctype_b_loc();
        if *(*tmp___2).offset(*beg as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        beg = beg.offset(1);
    }
    while *beg as libc::c_int != 0 as libc::c_int {
        loop {
            tmp___3 = __ctype_b_loc();
            if *(*tmp___3).offset(*beg as libc::c_int as isize) as libc::c_int
                & 8192 as libc::c_int == 0
            {
                break;
            }
            beg = beg.offset(1);
        }
        end = beg;
        while *end as libc::c_int != 61 as libc::c_int {
            if !(*end as libc::c_int != 44 as libc::c_int) {
                break;
            }
            if !(*end as libc::c_int != 0 as libc::c_int) {
                break;
            }
            tmp___4 = __ctype_b_loc();
            if *(*tmp___4).offset(*end as libc::c_int as isize) as libc::c_int
                & 8192 as libc::c_int != 0
            {
                break;
            }
            end = end.offset(1);
        }
        tmp___5 = xmalloc(
            (end.offset(1 as libc::c_int as isize).offset_from(beg) as libc::c_long
                as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
        );
        key = tmp___5 as *mut libc::c_char;
        memcpy(
            key as *mut libc::c_void,
            beg as *const libc::c_void,
            end.offset_from(beg) as libc::c_long as size_t,
        );
        *key
            .offset(
                end.offset_from(beg) as libc::c_long as isize,
            ) = '\u{0}' as i32 as libc::c_char;
        beg = end;
        loop {
            tmp___6 = __ctype_b_loc();
            if *(*tmp___6).offset(*beg as libc::c_int as isize) as libc::c_int
                & 8192 as libc::c_int == 0
            {
                break;
            }
            beg = beg.offset(1);
        }
        val = 0 as *mut libc::c_void as *mut libc::c_char;
        if *beg as libc::c_int == 61 as libc::c_int {
            beg = beg.offset(1);
            loop {
                tmp___7 = __ctype_b_loc();
                if *(*tmp___7).offset(*beg as libc::c_int as isize) as libc::c_int
                    & 8192 as libc::c_int == 0
                {
                    break;
                }
                beg = beg.offset(1);
            }
            if *beg as libc::c_int == 34 as libc::c_int {
                beg = beg.offset(1);
                end = beg;
                while *end as libc::c_int != 34 as libc::c_int {
                    if !(*end as libc::c_int != 0 as libc::c_int) {
                        break;
                    }
                    if *end as libc::c_int == 92 as libc::c_int {
                        if *end.offset(1 as libc::c_int as isize) as libc::c_int
                            != 0 as libc::c_int
                        {
                            end = end.offset(1);
                        }
                    }
                    end = end.offset(1);
                }
                tmp___8 = xmalloc(
                    (end.offset(1 as libc::c_int as isize).offset_from(beg)
                        as libc::c_long as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                        ),
                );
                val = tmp___8 as *mut libc::c_char;
                memcpy(
                    val as *mut libc::c_void,
                    beg as *const libc::c_void,
                    end.offset_from(beg) as libc::c_long as size_t,
                );
                *val
                    .offset(
                        end.offset_from(beg) as libc::c_long as isize,
                    ) = '\u{0}' as i32 as libc::c_char;
                beg = end;
                if *beg as libc::c_int != 0 as libc::c_int {
                    beg = beg.offset(1);
                }
            } else {
                end = beg;
                while *end as libc::c_int != 44 as libc::c_int {
                    if !(*end as libc::c_int != 0 as libc::c_int) {
                        break;
                    }
                    tmp___9 = __ctype_b_loc();
                    if *(*tmp___9).offset(*end as libc::c_int as isize) as libc::c_int
                        & 8192 as libc::c_int != 0
                    {
                        break;
                    }
                    end = end.offset(1);
                }
                tmp___10 = xmalloc(
                    (end.offset(1 as libc::c_int as isize).offset_from(beg)
                        as libc::c_long as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                        ),
                );
                val = tmp___10 as *mut libc::c_char;
                memcpy(
                    val as *mut libc::c_void,
                    beg as *const libc::c_void,
                    end.offset_from(beg) as libc::c_long as size_t,
                );
                *val
                    .offset(
                        end.offset_from(beg) as libc::c_long as isize,
                    ) = '\u{0}' as i32 as libc::c_char;
                beg = end;
            }
        }
        while *beg as libc::c_int != 44 as libc::c_int {
            if !(*beg as libc::c_int != 0 as libc::c_int) {
                break;
            }
            beg = beg.offset(1);
        }
        if *beg as libc::c_int != 0 as libc::c_int {
            beg = beg.offset(1);
        }
        keyval = __get_keyval(key as *const libc::c_char);
        match keyval as libc::c_uint {
            0 => {
                (*result).realm = val;
            }
            1 => {
                (*result).domain = val;
            }
            2 => {
                (*result).nonce = val;
            }
            3 => {
                (*result).opaque = val;
            }
            4 => {
                (*result).stale = val;
            }
            5 => {
                (*result).algorithm = val;
            }
            6 => {
                (*result).qop = val;
            }
            _ => {
                fprintf(
                    stderr,
                    b"unknown key [%s]\n\0" as *const u8 as *const libc::c_char,
                    key,
                );
                xfree(val as *mut libc::c_void);
            }
        }
        xfree(key as *mut libc::c_void);
    }
    return result;
}
unsafe extern "C" fn __get_md5_str(mut buf: *const libc::c_char) -> *mut libc::c_char {
    let mut hex: *const libc::c_char = 0 as *const libc::c_char;
    let mut ctx: md5_ctx = md5_ctx {
        A: 0,
        B: 0,
        C: 0,
        D: 0,
        total: [0; 2],
        buflen: 0,
        buffer: [0; 128],
    };
    let mut hash: [libc::c_uchar; 16] = [0; 16];
    let mut r: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut length: size_t = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    hex = b"0123456789abcdef\0" as *const u8 as *const libc::c_char;
    length = strlen(buf);
    tmp = xmalloc(
        (33 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    result = tmp as *mut libc::c_char;
    md5_init_ctx(&mut ctx);
    md5_process_bytes(buf as *const libc::c_void, length, &mut ctx);
    md5_finish_ctx(&mut ctx, hash.as_mut_ptr() as *mut libc::c_void);
    i = 0 as libc::c_int;
    r = result;
    while i < 16 as libc::c_int {
        tmp___0 = r;
        r = r.offset(1);
        *tmp___0 = *hex
            .offset((hash[i as usize] as libc::c_int >> 4 as libc::c_int) as isize);
        tmp___1 = r;
        r = r.offset(1);
        *tmp___1 = *hex
            .offset((hash[i as usize] as libc::c_int & 15 as libc::c_int) as isize);
        i += 1;
    }
    *r = '\u{0}' as i32 as libc::c_char;
    return result;
}
unsafe extern "C" fn __get_h_a1(
    mut chlg: *const DCHLG,
    mut cred: *mut DCRED,
    mut nonce_value: *const libc::c_char,
) -> *mut libc::c_char {
    let mut h_usrepa: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp___1 = strcasecmp(
        b"MD5\0" as *const u8 as *const libc::c_char,
        (*chlg).algorithm as *const libc::c_char,
    );
    if 0 as libc::c_int == tmp___1 {
        tmp = xstrcat(
            (*cred).username as *const libc::c_char,
            b":\0" as *const u8 as *const libc::c_char,
            (*chlg).realm,
            b":\0" as *const u8 as *const libc::c_char,
            (*cred).password,
            0 as *mut libc::c_void,
        );
        h_usrepa = __get_md5_str(tmp as *const libc::c_char);
        xfree(tmp as *mut libc::c_void);
        result = h_usrepa;
    } else {
        tmp___0 = strcasecmp(
            b"MD5-sess\0" as *const u8 as *const libc::c_char,
            (*chlg).algorithm as *const libc::c_char,
        );
        if 0 as libc::c_int == tmp___0 {
            if 0 as *mut libc::c_void as libc::c_ulong == (*cred).h_a1 as libc::c_ulong {
                tmp = xstrcat(
                    (*cred).username as *const libc::c_char,
                    b":\0" as *const u8 as *const libc::c_char,
                    (*chlg).realm,
                    b":\0" as *const u8 as *const libc::c_char,
                    (*cred).password,
                    0 as *mut libc::c_void,
                );
                h_usrepa = __get_md5_str(tmp as *const libc::c_char);
                xfree(tmp as *mut libc::c_void);
                tmp = xstrcat(
                    h_usrepa as *const libc::c_char,
                    b":\0" as *const u8 as *const libc::c_char,
                    nonce_value,
                    b":\0" as *const u8 as *const libc::c_char,
                    (*cred).cnonce_value,
                    0 as *mut libc::c_void,
                );
                result = __get_md5_str(tmp as *const libc::c_char);
                xfree(tmp as *mut libc::c_void);
                (*cred).h_a1 = result;
            } else {
                return (*cred).h_a1
            }
        } else {
            fprintf(
                stderr,
                b"invalid call to %s algorithm is [%s]\n\0" as *const u8
                    as *const libc::c_char,
                b"__get_h_a1\0" as *const u8 as *const libc::c_char,
                (*chlg).algorithm,
            );
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    return result;
}
unsafe extern "C" fn __str_list_contains(
    mut str: *const libc::c_char,
    mut pattern: *const libc::c_char,
    mut pattern_len: size_t,
) -> BOOLEAN {
    let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    ptr = str;
    loop {
        tmp = strncmp(ptr, pattern, pattern_len);
        if 0 as libc::c_int == tmp {
            if 44 as libc::c_int == *ptr.offset(pattern_len as isize) as libc::c_int {
                return boolean_true
            } else {
                if 0 as libc::c_int == *ptr.offset(pattern_len as isize) as libc::c_int {
                    return boolean_true;
                }
            }
        }
        tmp___0 = strchr(ptr, ',' as i32);
        ptr = tmp___0 as *const libc::c_char;
        if 0 as *mut libc::c_void as libc::c_ulong != ptr as libc::c_ulong {
            ptr = ptr.offset(1);
        }
        if !(0 as *mut libc::c_void as libc::c_ulong != ptr as libc::c_ulong) {
            break;
        }
    }
    return boolean_false;
}
static mut base64: [libc::c_char; 65] = [
    'A' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
unsafe extern "C" fn pos(mut c: libc::c_char) -> libc::c_int {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    p = base64.as_mut_ptr();
    while *p != 0 {
        if *p as libc::c_int == c as libc::c_int {
            return p.offset_from(base64.as_mut_ptr()) as libc::c_long as libc::c_int;
        }
        p = p.offset(1);
    }
    return -(1 as libc::c_int);
}
pub unsafe extern "C" fn base64_encode(
    mut data: *const libc::c_void,
    mut size: libc::c_int,
    mut str: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut q: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    tmp = malloc(
        (size * 4 as libc::c_int / 3 as libc::c_int + 4 as libc::c_int) as size_t,
    );
    s = tmp as *mut libc::c_char;
    p = s;
    if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    q = data as *const libc::c_uchar;
    i = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < size {
        tmp___0 = i;
        i += 1;
        c = *q.offset(tmp___0 as isize) as libc::c_int;
        c *= 256 as libc::c_int;
        if i < size {
            c += *q.offset(i as isize) as libc::c_int;
        }
        i += 1;
        c *= 256 as libc::c_int;
        if i < size {
            c += *q.offset(i as isize) as libc::c_int;
        }
        i += 1;
        *p
            .offset(
                0 as libc::c_int as isize,
            ) = base64[((c & 16515072 as libc::c_int) >> 18 as libc::c_int) as usize];
        *p
            .offset(
                1 as libc::c_int as isize,
            ) = base64[((c & 258048 as libc::c_int) >> 12 as libc::c_int) as usize];
        *p
            .offset(
                2 as libc::c_int as isize,
            ) = base64[((c & 4032 as libc::c_int) >> 6 as libc::c_int) as usize];
        *p.offset(3 as libc::c_int as isize) = base64[(c & 63 as libc::c_int) as usize];
        if i > size {
            *p.offset(3 as libc::c_int as isize) = '=' as i32 as libc::c_char;
        }
        if i > size + 1 as libc::c_int {
            *p.offset(2 as libc::c_int as isize) = '=' as i32 as libc::c_char;
        }
        p = p.offset(4 as libc::c_int as isize);
    }
    *p = 0 as libc::c_int as libc::c_char;
    *str = s;
    tmp___1 = strlen(s as *const libc::c_char);
    return tmp___1 as libc::c_int;
}
pub unsafe extern "C" fn base64_decode(
    mut str: *const libc::c_char,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut q: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut c: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut done: libc::c_int = 0;
    let mut tmp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tmp___0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tmp___1: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    done = 0 as libc::c_int;
    q = data as *mut libc::c_uchar;
    p = str;
    while *p != 0 {
        if done != 0 {
            break;
        }
        x = pos(*p.offset(0 as libc::c_int as isize));
        if x >= 0 as libc::c_int {
            c = x;
            c *= 64 as libc::c_int;
            x = pos(*p.offset(1 as libc::c_int as isize));
            if x >= 0 as libc::c_int {
                c += x;
            } else {
                return -(1 as libc::c_int)
            }
            c *= 64 as libc::c_int;
            if *p.offset(2 as libc::c_int as isize) as libc::c_int == 61 as libc::c_int {
                done += 1;
            } else {
                x = pos(*p.offset(2 as libc::c_int as isize));
                if x >= 0 as libc::c_int {
                    c += x;
                } else {
                    return -(1 as libc::c_int)
                }
            }
            c *= 64 as libc::c_int;
            if *p.offset(3 as libc::c_int as isize) as libc::c_int == 61 as libc::c_int {
                done += 1;
            } else {
                if done != 0 {
                    return -(1 as libc::c_int);
                }
                x = pos(*p.offset(3 as libc::c_int as isize));
                if x >= 0 as libc::c_int {
                    c += x;
                } else {
                    return -(1 as libc::c_int)
                }
            }
            if done < 3 as libc::c_int {
                tmp = q;
                q = q.offset(1);
                *tmp = ((c & 16711680 as libc::c_int) >> 16 as libc::c_int)
                    as libc::c_uchar;
            }
            if done < 2 as libc::c_int {
                tmp___0 = q;
                q = q.offset(1);
                *tmp___0 = ((c & 65280 as libc::c_int) >> 8 as libc::c_int)
                    as libc::c_uchar;
            }
            if done < 1 as libc::c_int {
                tmp___1 = q;
                q = q.offset(1);
                *tmp___1 = (c & 255 as libc::c_int) as libc::c_uchar;
            }
            p = p.offset(4 as libc::c_int as isize);
        } else {
            done = 3 as libc::c_int;
            break;
        }
    }
    return q.offset_from(data as *mut libc::c_uchar) as libc::c_long as libc::c_int;
}
pub static mut __himark: libc::c_float = 0 as libc::c_int as libc::c_float;
pub static mut __lomark: libc::c_float = -(1 as libc::c_int) as libc::c_float;
pub static mut BROWSERSIZE: size_t = ::std::mem::size_of::<BROWSER_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_browser(mut id: libc::c_int) -> BROWSER {
    let mut this: BROWSER = 0 as *mut BROWSER_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    tmp = calloc(BROWSERSIZE, 1 as libc::c_int as size_t);
    this = tmp as BROWSER;
    (*this).id = id;
    (*this).total = 0.0f64 as libc::c_float;
    (*this).available = 0.0f64 as libc::c_float;
    (*this).count = 0.0f64 as libc::c_uint;
    (*this).okay = 0 as libc::c_uint;
    (*this).fail = 0 as libc::c_uint;
    (*this).lowest = -(1 as libc::c_int) as libc::c_float;
    (*this).highest = 0.0f64 as libc::c_float;
    (*this).elapsed = 0.0f64 as libc::c_float;
    (*this).bytes = 0.0f64 as libc::c_ulonglong;
    (*this).urls = 0 as *mut libc::c_void as ARRAY;
    (*this).parts = new_array();
    tmp___0 = urandom();
    (*this).rseed = tmp___0 as libc::c_uint;
    return this;
}
pub unsafe extern "C" fn browser_destroy(mut this: BROWSER) -> BROWSER {
    let mut u: URL = 0 as *mut URL_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*this).parts as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            loop {
                tmp = array_pop((*this).parts);
                u = tmp as URL;
                if !(u as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                    break;
                }
                u = url_destroy(u);
            }
            (*this).parts = array_destroy((*this).parts);
        }
        xfree(this as *mut libc::c_void);
    }
    this = 0 as *mut libc::c_void as BROWSER;
    return this;
}
pub unsafe extern "C" fn browser_get_hits(mut this: BROWSER) -> libc::c_ulong {
    return (*this).hits;
}
pub unsafe extern "C" fn browser_get_bytes(mut this: BROWSER) -> libc::c_ulonglong {
    return (*this).bytes;
}
pub unsafe extern "C" fn browser_get_time(mut this: BROWSER) -> libc::c_float {
    return (*this).time;
}
pub unsafe extern "C" fn browser_get_code(mut this: BROWSER) -> libc::c_uint {
    return (*this).code;
}
pub unsafe extern "C" fn browser_get_okay(mut this: BROWSER) -> libc::c_uint {
    return (*this).okay;
}
pub unsafe extern "C" fn browser_get_fail(mut this: BROWSER) -> libc::c_uint {
    return (*this).fail;
}
pub unsafe extern "C" fn browser_get_himark(mut this: BROWSER) -> libc::c_float {
    return (*this).himark;
}
pub unsafe extern "C" fn browser_get_lomark(mut this: BROWSER) -> libc::c_float {
    return (*this).lomark;
}
pub unsafe extern "C" fn start(mut this: BROWSER) -> *mut libc::c_void {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut max_y: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __cancel_buf: __pthread_unwind_buf_t = __pthread_unwind_buf_t {
        __cancel_jmp_buf: [__anonstruct___cancel_jmp_buf_572769531 {
            __cancel_jmp_buf: [0; 8],
            __mask_was_saved: 0,
        }; 1],
        __pad: [0 as *mut libc::c_void; 4],
    };
    let mut __cancel_routine: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()> = None;
    let mut __cancel_arg: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __not_first_call: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_long = 0;
    let mut tmp___2: URL = 0 as *mut URL_T;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: URL = 0 as *mut URL_T;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: URL = 0 as *mut URL_T;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: BOOLEAN = boolean_false;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut u: URL = 0 as *mut URL_T;
    let mut r: RESPONSE = 0 as *mut RESPONSE_T;
    let mut tmp___12: RESPONSE = 0 as *mut RESPONSE_T;
    let mut tmp___13: BOOLEAN = boolean_false;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: BOOLEAN = boolean_false;
    let mut tmp___16: BOOLEAN = boolean_false;
    let mut tmp___17: SCHEME = UNSUPPORTED;
    let mut tmp___18: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: libc::c_int = 0;
    (*this).conn = 0 as *mut libc::c_void as *mut CONN;
    tmp = xcalloc(
        ::std::mem::size_of::<CONN>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    (*this).conn = tmp as *mut CONN;
    (*(*this).conn).sock = -(1 as libc::c_int);
    (*(*this).conn)
        .page = new_page(b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
    (*(*this).conn).cache = new_cache();
    __cancel_routine = ::std::mem::transmute::<
        *mut libc::c_void,
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    >(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> ()>,
            *mut libc::c_void,
        >(Some(__signal_cleanup as unsafe extern "C" fn() -> ())),
    );
    __cancel_arg = (*this).conn as *mut libc::c_void;
    tmp___0 = __sigsetjmp(
        (__cancel_buf.__cancel_jmp_buf).as_mut_ptr() as *mut libc::c_void
            as *mut __jmp_buf_tag,
        0 as libc::c_int,
    );
    __not_first_call = tmp___0;
    tmp___1 = __not_first_call as libc::c_long;
    if tmp___1 != 0 {
        (Some(__cancel_routine.expect("non-null function pointer")))
            .expect("non-null function pointer")(__cancel_arg);
        __pthread_unwind_next(&mut __cancel_buf);
    }
    __pthread_register_cancel(&mut __cancel_buf);
    pthread_setcanceltype(1 as libc::c_int, &mut (*this).type_0);
    pthread_setcancelstate(0 as libc::c_int, &mut (*this).state);
    if my.login as libc::c_uint == 1 as libc::c_uint {
        tmp___3 = array_next(my.lurl);
        tmp___4 = new_url(tmp___3 as *mut libc::c_char);
        tmp___2 = tmp___4;
        url_set_ID(tmp___2, 0 as libc::c_int);
        __request(this, tmp___2);
    }
    if my.reps == -(1 as libc::c_int) {
        tmp___5 = array_length((*this).urls);
        len = tmp___5 as libc::c_int;
    } else {
        len = my.reps;
    }
    if my.reps == -(1 as libc::c_int) {
        y = 0 as libc::c_int;
    } else {
        y = (*this).id * (my.length / my.cusers);
    }
    tmp___6 = array_length((*this).urls);
    max_y = tmp___6 as libc::c_int;
    x = 0 as libc::c_int;
    while x < len {
        if my.secs > 0 as libc::c_int {
            if my.reps <= 0 as libc::c_int {
                x = 0 as libc::c_int;
            } else if my.reps == 10301062 as libc::c_int {
                x = 0 as libc::c_int;
            } else {
                x = x;
            }
        } else {
            x = x;
        }
        if my.internet as libc::c_uint == 1 as libc::c_uint {
            tmp___7 = pthread_rand_np(&mut (*this).rseed);
            y = (tmp___7 as libc::c_double
                / (2147483647 as libc::c_int as libc::c_double
                    + 1 as libc::c_int as libc::c_double) * my.length as libc::c_double
                + 0.5f64) as libc::c_uint as libc::c_int;
            if y >= my.length {
                y = my.length - 1 as libc::c_int;
            } else {
                y = y;
            }
            if y < 0 as libc::c_int {
                y = 0 as libc::c_int;
            } else {
                y = y;
            }
        } else if y >= max_y {
            y = 0 as libc::c_int;
            if my.expire as u64 != 0 {
                cookies_delete_all(my.cookies);
            }
        }
        if y >= max_y {
            y = 0 as libc::c_int;
        } else if y < 0 as libc::c_int {
            y = 0 as libc::c_int;
        }
        tmp___9 = array_get((*this).urls, y);
        tmp___8 = tmp___9 as URL;
        if tmp___8 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___11 = url_get_hostname(tmp___8);
            if tmp___11 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                (*this).auth.bids.www = 0 as libc::c_int;
                tmp___10 = __request(this, tmp___8);
                ret = tmp___10 as libc::c_int;
                if ret == 0 as libc::c_int {
                    __increment_failures();
                }
            }
        }
        if my.parser as libc::c_uint == 1 as libc::c_uint {
            if (*this).parts as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                loop {
                    tmp___18 = array_pop((*this).parts);
                    u = tmp___18 as URL;
                    if !(u as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                        break;
                    }
                    tmp___17 = url_get_scheme(u);
                    if !(tmp___17 as libc::c_uint == 0 as libc::c_uint) {
                        let mut current_block_110: u64;
                        if my.cache as u64 != 0 {
                            tmp___16 = is_cached((*(*this).conn).cache, u);
                            if tmp___16 as u64 != 0 {
                                tmp___12 = new_response();
                                r = tmp___12;
                                response_set_code(
                                    r,
                                    b"HTTP/1.1 200 OK\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                                response_set_from_cache(r, boolean_true);
                                __display_result(
                                    this,
                                    r,
                                    u,
                                    0 as libc::c_ulong,
                                    0.00f64 as libc::c_float,
                                );
                                r = response_destroy(r);
                                current_block_110 = 6950488995570599823;
                            } else {
                                current_block_110 = 2270410959620882858;
                            }
                        } else {
                            current_block_110 = 2270410959620882858;
                        }
                        match current_block_110 {
                            2270410959620882858 => {
                                (*this).auth.bids.www = 0 as libc::c_int;
                                tmp___14 = url_get_hostname(u);
                                tmp___15 = __no_follow(tmp___14 as *const libc::c_char);
                                if tmp___15 as u64 == 0 {
                                    tmp___13 = __request(this, u);
                                    ret = tmp___13 as libc::c_int;
                                    if ret == 0 as libc::c_int {
                                        __increment_failures();
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    u = url_destroy(u);
                }
            }
        }
        if my.delay >= 1 as libc::c_int as libc::c_float {
            tmp___19 = pthread_rand_np(&mut (*this).rseed);
            pthread_sleep_np(
                (tmp___19 as libc::c_double
                    / (2147483647 as libc::c_int as libc::c_double
                        + 1 as libc::c_int as libc::c_double)
                    * my.delay as libc::c_double + 0.5f64) as libc::c_uint,
            );
        } else if my.delay as libc::c_double >= 0.001f64 {
            tmp___20 = pthread_rand_np(&mut (*this).rseed);
            pthread_usleep_np(
                (tmp___20 as libc::c_double
                    / (2147483647 as libc::c_int as libc::c_double
                        + 1 as libc::c_int as libc::c_double)
                    * my.delay as libc::c_double
                    * 1000000 as libc::c_int as libc::c_double + 0.0005f64)
                    as libc::c_uint as libc::c_ulong,
            );
        }
        if my.failures > 0 as libc::c_int {
            if my.failed >= my.failures {
                break;
            }
        }
        x += 1;
        y += 1;
    }
    __pthread_unregister_cancel(&mut __cancel_buf);
    if (*(*this).conn).sock >= 0 as libc::c_int {
        (*(*this).conn).connection.reuse = 0 as libc::c_int;
        socket_close((*this).conn);
    }
    (*(*this).conn).page = page_destroy((*(*this).conn).page);
    (*(*this).conn).cache = cache_destroy((*(*this).conn).cache);
    xfree((*this).conn as *mut libc::c_void);
    (*this).conn = 0 as *mut libc::c_void as *mut CONN;
    return 0 as *mut libc::c_void;
}
pub unsafe extern "C" fn browser_set_urls(mut this: BROWSER, mut urls: ARRAY) {
    (*this).urls = urls;
}
pub unsafe extern "C" fn browser_set_cookies(mut this: BROWSER, mut cookies: HASH) {
    let mut i: libc::c_int = 0;
    let mut keys___0: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut tmp: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: libc::c_int = 0;
    i = 0 as libc::c_int;
    (*this).cookies = cookies;
    if (*this).cookies as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = hash_get_keys((*this).cookies);
        keys___0 = tmp;
        i = 0 as libc::c_int;
        loop {
            tmp___5 = hash_get_entries((*this).cookies);
            if !(i < tmp___5) {
                break;
            }
            tmp___1 = hash_get((*this).cookies, *keys___0.offset(i as isize));
            tmp___2 = strlen(tmp___1 as *const libc::c_char);
            len = tmp___2 as libc::c_int;
            tmp___3 = xmalloc((len + 2 as libc::c_int) as size_t);
            tmp___0 = tmp___3 as *mut libc::c_char;
            memset(
                tmp___0 as *mut libc::c_void,
                '\u{0}' as i32,
                (len + 2 as libc::c_int) as size_t,
            );
            tmp___4 = hash_get((*this).cookies, *keys___0.offset(i as isize));
            snprintf(
                tmp___0,
                (len + 1 as libc::c_int) as size_t,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___4 as *mut libc::c_char,
            );
            cookies_add(
                my.cookies,
                tmp___0,
                b".\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            xfree(tmp___0 as *mut libc::c_void);
            i += 1;
        }
    }
}
unsafe extern "C" fn __request(mut this: BROWSER, mut U: URL) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: BOOLEAN = boolean_false;
    (*(*this).conn).scheme = url_get_scheme(U);
    match (*(*this).conn).scheme as libc::c_uint {
        3 => {
            tmp = __ftp(this, U);
            return tmp;
        }
        _ => {
            tmp___0 = __http(this, U);
            return tmp___0;
        }
    };
}
unsafe extern "C" fn __http(mut this: BROWSER, mut U: URL) -> BOOLEAN {
    let mut current_block: u64;
    let mut bytes: libc::c_ulong = 0;
    let mut code: libc::c_int = 0;
    let mut okay___0: libc::c_int = 0;
    let mut fail: libc::c_int = 0;
    let mut etime: libc::c_float = 0.;
    let mut start___0: clock_t = 0;
    let mut stop: clock_t = 0;
    let mut t_start: tms = tms {
        tms_utime: 0,
        tms_stime: 0,
        tms_cutime: 0,
        tms_cstime: 0,
    };
    let mut t_stop: tms = tms {
        tms_utime: 0,
        tms_stime: 0,
        tms_cutime: 0,
        tms_cstime: 0,
    };
    let mut resp: RESPONSE = 0 as *mut RESPONSE_T;
    let mut meta: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut keepsake: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut now: time_t = 0;
    let mut tmp: *mut tm = 0 as *mut tm;
    let mut len: size_t = 0;
    let mut fmtime: [libc::c_char; 65] = [0; 65];
    let mut redirect_url: URL = 0 as *mut URL_T;
    let mut tmp___0: *mut tm = 0 as *mut tm;
    let mut tmp___1: SCHEME = UNSUPPORTED;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: BOOLEAN = boolean_false;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: METHOD = 0;
    let mut tmp___6: METHOD = 0;
    let mut tmp___7: METHOD = 0;
    let mut tmp___8: METHOD = 0;
    let mut tmp___9: METHOD = 0;
    let mut tmp___10: ssize_t = 0;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut url: URL = 0 as *mut URL_T;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: URL = 0 as *mut URL_T;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: BOOLEAN = boolean_false;
    let mut tmp___18: size_t = 0;
    let mut tmp___19: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___20: BOOLEAN = boolean_false;
    let mut tmp___21: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___22: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___23: BOOLEAN = boolean_false;
    let mut tmp___24: BOOLEAN = boolean_false;
    let mut tmp___25: size_t = 0;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___28: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___29: BOOLEAN = boolean_false;
    let mut tmp___30: BOOLEAN = boolean_false;
    let mut tmp___31: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___32: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___33: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___34: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___35: BOOLEAN = boolean_false;
    let mut tmp___36: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___37: METHOD = 0;
    let mut tmp___38: size_t = 0;
    let mut tmp___39: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___40: METHOD = 0;
    let mut tmp___41: METHOD = 0;
    let mut tmp___42: METHOD = 0;
    let mut tmp___43: METHOD = 0;
    let mut tmp___44: METHOD = 0;
    let mut tmp___45: BOOLEAN = boolean_false;
    let mut tmp___46: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut b: BOOLEAN = boolean_false;
    let mut tmp___47: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___48: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___49: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___50: TYPE = BASIC;
    let mut tmp___51: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___52: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___53: TYPE = BASIC;
    let mut tmp___54: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___55: TYPE = BASIC;
    let mut tmp___56: BOOLEAN = boolean_false;
    let mut tmp___57: libc::c_int = 0;
    let mut b___0: BOOLEAN = boolean_false;
    let mut tmp___58: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___59: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___60: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___61: TYPE = BASIC;
    let mut tmp___62: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___63: TYPE = BASIC;
    let mut tmp___64: BOOLEAN = boolean_false;
    let mut tmp___65: libc::c_int = 0;
    bytes = 0 as libc::c_ulong;
    meta = 0 as *mut libc::c_void as *mut libc::c_char;
    redirect_url = 0 as *mut libc::c_void as URL;
    page_clear((*(*this).conn).page);
    if my.csv as u64 != 0 {
        now = time(0 as *mut libc::c_void as *mut time_t);
        tmp___0 = localtime_r(
            &mut now as *mut time_t as *const time_t,
            &mut keepsake as *mut tm,
        );
        tmp = tmp___0;
        if !tmp.is_null() {
            len = strftime(
                fmtime.as_mut_ptr(),
                64 as libc::c_int as size_t,
                b"%Y-%m-%d %H:%M:%S\0" as *const u8 as *const libc::c_char,
                tmp as *const tm,
            );
            if len == 0 as libc::c_ulong {
                memset(
                    fmtime.as_mut_ptr() as *mut libc::c_void,
                    '\u{0}' as i32,
                    64 as libc::c_int as size_t,
                );
                snprintf(
                    fmtime.as_mut_ptr(),
                    64 as libc::c_int as size_t,
                    b"n/a\0" as *const u8 as *const libc::c_char,
                );
            }
        } else {
            snprintf(
                fmtime.as_mut_ptr(),
                64 as libc::c_int as size_t,
                b"n/a\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    tmp___1 = url_get_scheme(U);
    if tmp___1 as libc::c_uint == 0 as libc::c_uint {
        if my.verbose as u64 != 0 {
            if my.get as u64 == 0 {
                if my.print as u64 == 0 {
                    NOTIFY(
                        ERROR,
                        b"%s %d %6.2f secs: %7d bytes ==> %s\n\0" as *const u8
                            as *const libc::c_char,
                        b"UNSPPRTD\0" as *const u8 as *const libc::c_char,
                        501 as libc::c_int,
                        0.00f64,
                        0 as libc::c_int,
                        b"PROTOCOL NOT SUPPORTED BY SIEGE\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
        }
        return boolean_false;
    }
    start___0 = times(&mut t_start);
    tmp___2 = __init_connection(this, U);
    if tmp___2 as u64 == 0 {
        return boolean_false;
    }
    tmp___5 = url_get_method(U);
    if tmp___5 as libc::c_uint == 3 as libc::c_uint {
        current_block = 18393406906609771094;
    } else {
        tmp___6 = url_get_method(U);
        if tmp___6 as libc::c_uint == 4 as libc::c_uint {
            current_block = 18393406906609771094;
        } else {
            tmp___7 = url_get_method(U);
            if tmp___7 as libc::c_uint == 9 as libc::c_uint {
                current_block = 18393406906609771094;
            } else {
                tmp___8 = url_get_method(U);
                if tmp___8 as libc::c_uint == 5 as libc::c_uint {
                    current_block = 18393406906609771094;
                } else {
                    tmp___9 = url_get_method(U);
                    if tmp___9 as libc::c_uint == 7 as libc::c_uint {
                        current_block = 18393406906609771094;
                    } else {
                        tmp___4 = http_get((*this).conn, U);
                        if tmp___4 as libc::c_uint == 0 as libc::c_uint {
                            (*(*this).conn).connection.reuse = 0 as libc::c_int;
                            socket_close((*this).conn);
                            return boolean_false;
                        }
                        current_block = 8732226822098929438;
                    }
                }
            }
        }
    }
    match current_block {
        18393406906609771094 => {
            tmp___3 = http_post((*this).conn, U);
            if tmp___3 as libc::c_uint == 0 as libc::c_uint {
                (*(*this).conn).connection.reuse = 0 as libc::c_int;
                socket_close((*this).conn);
                return boolean_false;
            }
        }
        _ => {}
    }
    resp = http_read_headers((*this).conn, U);
    if resp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*(*this).conn).connection.reuse = 0 as libc::c_int;
        socket_close((*this).conn);
        echo(
            b"%s:%d NULL headers\0" as *const u8 as *const libc::c_char,
            b"browser.c\0" as *const u8 as *const libc::c_char,
            496 as libc::c_int,
        );
        return boolean_false;
    }
    code = response_get_code(resp);
    if code == 418 as libc::c_int {
        (*(*this).conn).connection.reuse = 0 as libc::c_int;
        socket_close((*this).conn);
        stop = times(&mut t_stop);
        etime = elapsed_time(stop - start___0);
        (*this).hits = ((*this).hits).wrapping_add(1);
        (*this).time += etime;
        (*this).fail = ((*this).fail).wrapping_add(1);
        __display_result(this, resp, U, 0 as libc::c_ulong, etime);
        resp = response_destroy(resp);
        return boolean_false;
    }
    tmp___10 = http_read((*this).conn, resp);
    bytes = tmp___10 as libc::c_ulong;
    if my.print as u64 != 0 {
        tmp___11 = page_value((*(*this).conn).page);
        printf(b"%s\n\0" as *const u8 as *const libc::c_char, tmp___11);
    }
    if my.parser as libc::c_uint == 1 as libc::c_uint {
        tmp___19 = response_get_content_type(resp);
        tmp___20 = strmatch(
            tmp___19,
            b"text/html\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___20 as u64 != 0 {
            if code < 300 as libc::c_int {
                tmp___12 = page_value((*(*this).conn).page);
                html_parser((*this).parts, U, tmp___12);
                i = 0 as libc::c_int;
                loop {
                    tmp___18 = array_length((*this).parts);
                    if !(i < tmp___18 as libc::c_int) {
                        break;
                    }
                    tmp___13 = array_get((*this).parts, i);
                    url = tmp___13 as URL;
                    tmp___17 = url_is_redirect(url);
                    if tmp___17 as u64 != 0 {
                        tmp___15 = array_remove((*this).parts, i);
                        tmp___14 = tmp___15 as URL;
                        tmp___16 = url_get_absolute(tmp___14);
                        meta = xstrdup(tmp___16 as *const libc::c_char);
                        tmp___14 = url_destroy(tmp___14);
                    }
                    i += 1;
                }
            }
        }
    }
    if my.zero_ok as u64 == 0 {
        if bytes < 1 as libc::c_ulong {
            (*(*this).conn).connection.reuse = 0 as libc::c_int;
            socket_close((*this).conn);
            resp = response_destroy(resp);
            echo(
                b"%s:%d zero bytes back from server\0" as *const u8
                    as *const libc::c_char,
                b"browser.c\0" as *const u8 as *const libc::c_char,
                544 as libc::c_int,
            );
            return boolean_false;
        }
    }
    stop = times(&mut t_stop);
    etime = elapsed_time(stop - start___0);
    okay___0 = response_success(resp);
    fail = response_failure(resp);
    (*this).bytes = ((*this).bytes).wrapping_add(bytes as libc::c_ulonglong);
    (*this).time += etime;
    (*this).code = ((*this).code).wrapping_add(okay___0 as libc::c_uint);
    (*this).fail = ((*this).fail).wrapping_add(fail as libc::c_uint);
    if code == 200 as libc::c_int {
        (*this).okay = ((*this).okay).wrapping_add(1);
    }
    if etime > __himark {
        __himark = etime;
    }
    if __lomark < 0 as libc::c_int as libc::c_float {
        __lomark = etime;
    } else if etime < __lomark {
        __lomark = etime;
    }
    (*this).himark = __himark;
    (*this).lomark = __lomark;
    __display_result(this, resp, U, bytes, etime);
    if my.keepalive as u64 == 0 {
        socket_close((*this).conn);
    }
    match code {
        200 => {
            if meta as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___25 = strlen(meta as *const libc::c_char);
                if tmp___25 > 2 as libc::c_ulong {
                    redirect_url = url_normalize(U, meta);
                    xfree(meta as *mut libc::c_void);
                    meta = 0 as *mut libc::c_void as *mut libc::c_char;
                    page_clear((*(*this).conn).page);
                    tmp___22 = url_get_hostname(redirect_url);
                    tmp___23 = empty(tmp___22 as *const libc::c_char);
                    if tmp___23 as u64 != 0 {
                        tmp___21 = url_get_hostname(U);
                        url_set_hostname(redirect_url, tmp___21);
                    }
                    url_set_redirect(U, boolean_false);
                    url_set_redirect(redirect_url, boolean_false);
                    tmp___24 = __request(this, redirect_url);
                    if tmp___24 as libc::c_uint == 0 as libc::c_uint {
                        redirect_url = url_destroy(redirect_url);
                        return boolean_false;
                    }
                    redirect_url = url_destroy(redirect_url);
                }
            }
        }
        201 => {
            if my.follow as u64 != 0 {
                tmp___31 = response_get_location(resp);
                if tmp___31 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___26 = response_get_location(resp);
                    redirect_url = url_normalize(U, tmp___26);
                    tmp___28 = url_get_hostname(redirect_url);
                    tmp___29 = empty(tmp___28 as *const libc::c_char);
                    if tmp___29 as u64 != 0 {
                        tmp___27 = url_get_hostname(U);
                        url_set_hostname(redirect_url, tmp___27);
                    }
                    tmp___30 = __request(this, redirect_url);
                    if tmp___30 as libc::c_uint == 0 as libc::c_uint {
                        redirect_url = url_destroy(redirect_url);
                        return boolean_false;
                    }
                }
            }
        }
        307 | 303 | 302 | 301 => {
            if my.follow as u64 != 0 {
                tmp___46 = response_get_location(resp);
                if tmp___46 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___32 = response_get_location(resp);
                    redirect_url = url_normalize(U, tmp___32);
                    tmp___34 = url_get_hostname(redirect_url);
                    tmp___35 = empty(tmp___34 as *const libc::c_char);
                    if tmp___35 as u64 != 0 {
                        tmp___33 = url_get_hostname(U);
                        url_set_hostname(redirect_url, tmp___33);
                    }
                    if code == 307 as libc::c_int {
                        tmp___36 = url_get_conttype(U);
                        url_set_conttype(redirect_url, tmp___36);
                        tmp___37 = url_get_method(U);
                        url_set_method(redirect_url, tmp___37);
                        tmp___40 = url_get_method(redirect_url);
                        if tmp___40 as libc::c_uint == 3 as libc::c_uint {
                            tmp___38 = url_get_postlen(U);
                            tmp___39 = url_get_postdata(U);
                            url_set_postdata(redirect_url, tmp___39, tmp___38);
                        } else {
                            tmp___41 = url_get_method(redirect_url);
                            if tmp___41 as libc::c_uint == 4 as libc::c_uint {
                                tmp___38 = url_get_postlen(U);
                                tmp___39 = url_get_postdata(U);
                                url_set_postdata(redirect_url, tmp___39, tmp___38);
                            } else {
                                tmp___42 = url_get_method(redirect_url);
                                if tmp___42 as libc::c_uint == 9 as libc::c_uint {
                                    tmp___38 = url_get_postlen(U);
                                    tmp___39 = url_get_postdata(U);
                                    url_set_postdata(redirect_url, tmp___39, tmp___38);
                                } else {
                                    tmp___43 = url_get_method(U);
                                    if tmp___43 as libc::c_uint == 5 as libc::c_uint {
                                        tmp___38 = url_get_postlen(U);
                                        tmp___39 = url_get_postdata(U);
                                        url_set_postdata(redirect_url, tmp___39, tmp___38);
                                    } else {
                                        tmp___44 = url_get_method(U);
                                        if tmp___44 as libc::c_uint == 7 as libc::c_uint {
                                            tmp___38 = url_get_postlen(U);
                                            tmp___39 = url_get_postdata(U);
                                            url_set_postdata(redirect_url, tmp___39, tmp___38);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    tmp___45 = __request(this, redirect_url);
                    if tmp___45 as libc::c_uint == 0 as libc::c_uint {
                        redirect_url = url_destroy(redirect_url);
                        return boolean_false;
                    }
                }
            }
            redirect_url = url_destroy(redirect_url);
        }
        401 => {
            if (*this).auth.www == 0 as libc::c_int {
                (*this).auth.www = 1 as libc::c_int;
            } else {
                (*this).auth.www = (*this).auth.www;
            }
            tmp___57 = (*this).auth.bids.www;
            (*this).auth.bids.www += 1;
            if tmp___57 < my.bids - 1 as libc::c_int {
                tmp___50 = response_get_www_auth_type(resp);
                if tmp___50 as libc::c_uint == 1 as libc::c_uint {
                    (*this).auth.type_0.www = DIGEST;
                    tmp___47 = response_get_www_auth_challenge(resp);
                    tmp___48 = response_get_www_auth_realm(resp);
                    b = auth_set_digest_header(
                        my.auth,
                        &mut (*this).auth.wchlg,
                        &mut (*this).auth.wcred,
                        &mut (*this).rseed,
                        tmp___48,
                        tmp___47,
                    );
                    if b as libc::c_uint == 0 as libc::c_uint {
                        fprintf(
                            stderr,
                            b"ERROR: Unable to respond to an authorization challenge\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        tmp___49 = response_get_www_auth_realm(resp);
                        fprintf(
                            stderr,
                            b"       in the following realm: '%s'\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___49,
                        );
                        fprintf(
                            stderr,
                            b"       Did you set login credentials in the conf file?\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        resp = response_destroy(resp);
                        return boolean_false;
                    }
                }
                tmp___53 = response_get_www_auth_type(resp);
                if tmp___53 as libc::c_uint == 2 as libc::c_uint {
                    (*this).auth.type_0.www = NTLM;
                    tmp___51 = response_get_www_auth_realm(resp);
                    tmp___52 = response_get_www_auth_challenge(resp);
                    b = auth_set_ntlm_header(my.auth, HTTP, tmp___52, tmp___51);
                }
                tmp___55 = response_get_www_auth_type(resp);
                if tmp___55 as libc::c_uint == 0 as libc::c_uint {
                    (*this).auth.type_0.www = BASIC;
                    tmp___54 = response_get_www_auth_realm(resp);
                    auth_set_basic_header(my.auth, HTTP, tmp___54);
                }
                tmp___56 = __request(this, U);
                if tmp___56 as libc::c_uint == 0 as libc::c_uint {
                    fprintf(
                        stderr,
                        b"ERROR from http_request\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    return boolean_false;
                }
            }
        }
        407 => {
            if (*this).auth.proxy == 0 as libc::c_int {
                (*this).auth.proxy = 1 as libc::c_int;
            } else {
                (*this).auth.proxy = (*this).auth.proxy;
            }
            tmp___65 = (*this).auth.bids.proxy;
            (*this).auth.bids.proxy += 1;
            if tmp___65 < my.bids - 1 as libc::c_int {
                tmp___61 = response_get_proxy_auth_type(resp);
                if tmp___61 as libc::c_uint == 1 as libc::c_uint {
                    (*this).auth.type_0.proxy = DIGEST;
                    tmp___58 = response_get_proxy_auth_challenge(resp);
                    tmp___59 = response_get_proxy_auth_realm(resp);
                    b___0 = auth_set_digest_header(
                        my.auth,
                        &mut (*this).auth.pchlg,
                        &mut (*this).auth.pcred,
                        &mut (*this).rseed,
                        tmp___59,
                        tmp___58,
                    );
                    if b___0 as libc::c_uint == 0 as libc::c_uint {
                        fprintf(
                            stderr,
                            b"ERROR: Unable to respond to a proxy authorization challenge\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        tmp___60 = response_get_proxy_auth_realm(resp);
                        fprintf(
                            stderr,
                            b"       in the following HTTP realm: '%s'\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___60,
                        );
                        fprintf(
                            stderr,
                            b"       Did you set proxy-login credentials in the conf file?\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        resp = response_destroy(resp);
                        return boolean_false;
                    }
                }
                tmp___63 = response_get_proxy_auth_type(resp);
                if tmp___63 as libc::c_uint == 0 as libc::c_uint {
                    (*this).auth.type_0.proxy = BASIC;
                    tmp___62 = response_get_proxy_auth_realm(resp);
                    auth_set_basic_header(my.auth, PROXY, tmp___62);
                }
                tmp___64 = __request(this, U);
                if tmp___64 as libc::c_uint == 0 as libc::c_uint {
                    return boolean_false;
                }
            }
        }
        509 | 508 | 507 | 506 | 505 | 504 | 503 | 502 | 501 | 500 | 408 => {
            return boolean_false;
        }
        _ => {}
    }
    (*this).hits = ((*this).hits).wrapping_add(1);
    resp = response_destroy(resp);
    return boolean_true;
}
unsafe extern "C" fn __ftp(mut this: BROWSER, mut U: URL) -> BOOLEAN {
    let mut pass: libc::c_int = 0;
    let mut fail: libc::c_int = 0;
    let mut code: libc::c_int = 0;
    let mut etime: libc::c_float = 0.;
    let mut D: *mut CONN = 0 as *mut CONN;
    let mut bytes: size_t = 0;
    let mut start___0: clock_t = 0;
    let mut stop: clock_t = 0;
    let mut t_start: tms = tms {
        tms_utime: 0,
        tms_stime: 0,
        tms_cutime: 0,
        tms_cstime: 0,
    };
    let mut t_stop: tms = tms {
        tms_utime: 0,
        tms_stime: 0,
        tms_cutime: 0,
        tms_cstime: 0,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: size_t = 0;
    let mut color: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___18: BOOLEAN = boolean_false;
    let mut tmp___19: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___20: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___21: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___22: BOOLEAN = boolean_false;
    let mut tmp___23: BOOLEAN = boolean_false;
    let mut tmp___24: METHOD = 0;
    let mut tmp___25: METHOD = 0;
    let mut tmp___26: METHOD = 0;
    let mut tmp___27: METHOD = 0;
    let mut tmp___28: METHOD = 0;
    let mut color___0: libc::c_int = 0;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: libc::c_int = 0;
    let mut tmp___31: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___32: *mut libc::c_char = 0 as *mut libc::c_char;
    code = 0 as libc::c_int;
    D = 0 as *mut libc::c_void as *mut CONN;
    bytes = 0 as libc::c_int as size_t;
    tmp = xcalloc(
        ::std::mem::size_of::<CONN>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    D = tmp as *mut CONN;
    (*D).sock = -(1 as libc::c_int);
    tmp___2 = __init_connection(this, U);
    if tmp___2 as u64 == 0 {
        tmp___0 = url_get_port(U);
        tmp___1 = url_get_hostname(U);
        NOTIFY(
            ERROR,
            b"%s:%d connection failed %s:%d\0" as *const u8 as *const libc::c_char,
            b"browser.c\0" as *const u8 as *const libc::c_char,
            765 as libc::c_int,
            tmp___1,
            tmp___0,
        );
        xfree(D as *mut libc::c_void);
        return boolean_false;
    }
    start___0 = times(&mut t_start);
    if (*(*this).conn).sock < 0 as libc::c_int {
        tmp___3 = url_get_port(U);
        tmp___4 = url_get_hostname(U);
        NOTIFY(
            ERROR,
            b"%s:%d connection failed %s:%d\0" as *const u8 as *const libc::c_char,
            b"browser.c\0" as *const u8 as *const libc::c_char,
            775 as libc::c_int,
            tmp___4,
            tmp___3,
        );
        socket_close((*this).conn);
        xfree(D as *mut libc::c_void);
        return boolean_false;
    }
    tmp___7 = url_get_username(U);
    if tmp___7 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___5 = url_get_hostname(U);
        tmp___6 = auth_get_ftp_username(my.auth, tmp___5);
        url_set_username(U, tmp___6);
    } else {
        tmp___8 = url_get_username(U);
        tmp___9 = strlen(tmp___8 as *const libc::c_char);
        if tmp___9 < 1 as libc::c_ulong {
            tmp___5 = url_get_hostname(U);
            tmp___6 = auth_get_ftp_username(my.auth, tmp___5);
            url_set_username(U, tmp___6);
        }
    }
    tmp___12 = url_get_password(U);
    if tmp___12 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___10 = url_get_hostname(U);
        tmp___11 = auth_get_ftp_password(my.auth, tmp___10);
        url_set_password(U, tmp___11);
    } else {
        tmp___13 = url_get_password(U);
        tmp___14 = strlen(tmp___13 as *const libc::c_char);
        if tmp___14 < 1 as libc::c_ulong {
            tmp___10 = url_get_hostname(U);
            tmp___11 = auth_get_ftp_password(my.auth, tmp___10);
            url_set_password(U, tmp___11);
        }
    }
    tmp___18 = ftp_login((*this).conn, U);
    if tmp___18 as libc::c_uint == 0 as libc::c_uint {
        if my.verbose as u64 != 0 {
            tmp___15 = __select_color((*(*this).conn).ftp.code);
            color = tmp___15;
            tmp___16 = url_get_request(U);
            tmp___17 = url_get_method_name(U);
            DISPLAY(
                color,
                b"FTP/%d %6.2f secs: %7lu bytes ==> %-6s %s\0" as *const u8
                    as *const libc::c_char,
                (*(*this).conn).ftp.code,
                0.0f64,
                bytes,
                tmp___17,
                tmp___16,
            );
        }
        xfree(D as *mut libc::c_void);
        (*this).fail = ((*this).fail).wrapping_add(1);
        return boolean_false;
    }
    ftp_pasv((*this).conn);
    if (*(*this).conn).ftp.pasv as libc::c_uint == 1 as libc::c_uint {
        debug(
            b"Connecting to: %s:%d\0" as *const u8 as *const libc::c_char,
            ((*(*this).conn).ftp.host).as_mut_ptr(),
            (*(*this).conn).ftp.port,
        );
        (*D)
            .sock = new_socket(
            D,
            ((*(*this).conn).ftp.host).as_mut_ptr() as *const libc::c_char,
            (*(*this).conn).ftp.port,
        );
        if (*D).sock < 0 as libc::c_int {
            tmp___19 = __errno_location();
            tmp___20 = strerror(*tmp___19);
            tmp___21 = __errno_location();
            debug(
                b"%s:%d connection failed. error %d(%s)\0" as *const u8
                    as *const libc::c_char,
                b"browser.c\0" as *const u8 as *const libc::c_char,
                809 as libc::c_int,
                *tmp___21,
                tmp___20,
            );
            (*this).fail = ((*this).fail).wrapping_add(1);
            socket_close(D);
            xfree(D as *mut libc::c_void);
            return boolean_false;
        }
    }
    tmp___24 = url_get_method(U);
    if tmp___24 as libc::c_uint == 3 as libc::c_uint {
        ftp_stor((*this).conn, U);
        bytes = ftp_put(D, U);
        code = (*(*this).conn).ftp.code;
    } else {
        tmp___25 = url_get_method(U);
        if tmp___25 as libc::c_uint == 4 as libc::c_uint {
            ftp_stor((*this).conn, U);
            bytes = ftp_put(D, U);
            code = (*(*this).conn).ftp.code;
        } else {
            tmp___26 = url_get_method(U);
            if tmp___26 as libc::c_uint == 9 as libc::c_uint {
                ftp_stor((*this).conn, U);
                bytes = ftp_put(D, U);
                code = (*(*this).conn).ftp.code;
            } else {
                tmp___27 = url_get_method(U);
                if tmp___27 as libc::c_uint == 5 as libc::c_uint {
                    ftp_stor((*this).conn, U);
                    bytes = ftp_put(D, U);
                    code = (*(*this).conn).ftp.code;
                } else {
                    tmp___28 = url_get_method(U);
                    if tmp___28 as libc::c_uint == 7 as libc::c_uint {
                        ftp_stor((*this).conn, U);
                        bytes = ftp_put(D, U);
                        code = (*(*this).conn).ftp.code;
                    } else {
                        tmp___23 = ftp_size((*this).conn, U);
                        if tmp___23 as libc::c_uint == 1 as libc::c_uint {
                            tmp___22 = ftp_retr((*this).conn, U);
                            if tmp___22 as libc::c_uint == 1 as libc::c_uint {
                                bytes = ftp_get(D, U, (*(*this).conn).ftp.size);
                            }
                        }
                        code = (*(*this).conn).ftp.code;
                    }
                }
            }
        }
    }
    socket_close(D);
    ftp_quit((*this).conn);
    if bytes == (*(*this).conn).ftp.size {
        pass = 1 as libc::c_int;
    } else {
        pass = 0 as libc::c_int;
    }
    if pass == 0 as libc::c_int {
        fail = 1 as libc::c_int;
    } else {
        fail = 0 as libc::c_int;
    }
    stop = times(&mut t_stop);
    etime = elapsed_time(stop - start___0);
    (*this).bytes = ((*this).bytes).wrapping_add(bytes as libc::c_ulonglong);
    (*this).time += etime;
    (*this).code = ((*this).code).wrapping_add(pass as libc::c_uint);
    (*this).fail = ((*this).fail).wrapping_add(fail as libc::c_uint);
    if etime > __himark {
        __himark = etime;
    }
    if __lomark < 0 as libc::c_int as libc::c_float {
        __lomark = etime;
    } else if etime < __lomark {
        __lomark = etime;
    }
    (*this).himark = __himark;
    (*this).lomark = __lomark;
    if my.verbose as u64 != 0 {
        if my.color as libc::c_uint == 1 as libc::c_uint {
            tmp___29 = __select_color(code);
            tmp___30 = tmp___29;
        } else {
            tmp___30 = -(1 as libc::c_int);
        }
        color___0 = tmp___30;
        tmp___31 = url_get_request(U);
        tmp___32 = url_get_method_name(U);
        DISPLAY(
            color___0,
            b"FTP/%d %6.2f secs: %7lu bytes ==> %-6s %s\0" as *const u8
                as *const libc::c_char,
            code,
            etime as libc::c_double,
            bytes,
            tmp___32,
            tmp___31,
        );
    }
    (*this).hits = ((*this).hits).wrapping_add(1);
    xfree(D as *mut libc::c_void);
    return boolean_true;
}
unsafe extern "C" fn __init_connection(mut this: BROWSER, mut U: URL) -> BOOLEAN {
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: BOOLEAN = boolean_false;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: BOOLEAN = boolean_false;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: BOOLEAN = boolean_false;
    let mut tmp___18: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___19: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___20: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: libc::c_int = 0;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: BOOLEAN = boolean_false;
    let mut tmp___27: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___28: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___29: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___30: BOOLEAN = boolean_false;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___33: BOOLEAN = boolean_false;
    let mut tmp___34: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___35: BOOLEAN = boolean_false;
    let mut tmp___36: SCHEME = UNSUPPORTED;
    (*(*this).conn).pos_ini = 0 as libc::c_int;
    (*(*this).conn).inbuffer = 0 as libc::c_int as size_t;
    (*(*this).conn).content.transfer = 1 as libc::c_int;
    (*(*this).conn).content.length = !(0 as libc::c_long) as size_t;
    if (*(*this).conn).connection.max == 1 as libc::c_int {
        (*(*this).conn).connection.keepalive = 0 as libc::c_int;
    } else {
        (*(*this).conn).connection.keepalive = my.keepalive as libc::c_int;
    }
    if (*(*this).conn).connection.max == 1 as libc::c_int {
        (*(*this).conn).connection.reuse = 0 as libc::c_int;
    } else {
        (*(*this).conn).connection.reuse = my.keepalive as libc::c_int;
    }
    if (*(*this).conn).connection.tested == 0 as libc::c_int {
        (*(*this).conn).connection.tested = 1 as libc::c_int;
    } else {
        (*(*this).conn).connection.tested = (*(*this).conn).connection.tested;
    }
    (*(*this).conn).auth.www = (*this).auth.www;
    (*(*this).conn).auth.wchlg = (*this).auth.wchlg;
    (*(*this).conn).auth.wcred = (*this).auth.wcred;
    (*(*this).conn).auth.proxy = (*this).auth.proxy;
    (*(*this).conn).auth.pchlg = (*this).auth.pchlg;
    (*(*this).conn).auth.pcred = (*this).auth.pcred;
    (*(*this).conn).auth.type_0.www = (*this).auth.type_0.www;
    (*(*this).conn).auth.type_0.proxy = (*this).auth.type_0.proxy;
    memset(
        ((*(*this).conn).buffer).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
    );
    tmp___3 = auth_get_proxy_required(my.auth);
    if tmp___3 as u64 != 0 {
        tmp___0 = auth_get_proxy_port(my.auth);
        tmp___2 = tmp___0;
    } else {
        tmp___1 = url_get_port(U);
        tmp___2 = tmp___1;
    }
    tmp___8 = auth_get_proxy_required(my.auth);
    if tmp___8 as u64 != 0 {
        tmp___5 = auth_get_proxy_host(my.auth);
        tmp___7 = tmp___5;
    } else {
        tmp___6 = url_get_hostname(U);
        tmp___7 = tmp___6;
    }
    debug(
        b"%s:%d attempting connection to %s:%d\0" as *const u8 as *const libc::c_char,
        b"browser.c\0" as *const u8 as *const libc::c_char,
        888 as libc::c_int,
        tmp___7,
        tmp___2,
    );
    let mut current_block_60: u64;
    if (*(*this).conn).connection.reuse == 0 {
        current_block_60 = 17766212408700198119;
    } else if (*(*this).conn).connection.status == 0 as libc::c_int {
        current_block_60 = 17766212408700198119;
    } else {
        current_block_60 = 17728966195399430138;
    }
    match current_block_60 {
        17766212408700198119 => {
            tmp___17 = auth_get_proxy_required(my.auth);
            if tmp___17 as u64 != 0 {
                tmp___9 = auth_get_proxy_port(my.auth);
                tmp___10 = auth_get_proxy_host(my.auth);
                debug(
                    b"%s:%d creating new socket:     %s:%d\0" as *const u8
                        as *const libc::c_char,
                    b"browser.c\0" as *const u8 as *const libc::c_char,
                    897 as libc::c_int,
                    tmp___10,
                    tmp___9,
                );
                tmp___11 = auth_get_proxy_port(my.auth);
                tmp___12 = auth_get_proxy_host(my.auth);
                (*(*this).conn)
                    .sock = new_socket(
                    (*this).conn,
                    tmp___12 as *const libc::c_char,
                    tmp___11,
                );
            } else {
                tmp___13 = url_get_port(U);
                tmp___14 = url_get_hostname(U);
                debug(
                    b"%s:%d creating new socket:     %s:%d\0" as *const u8
                        as *const libc::c_char,
                    b"browser.c\0" as *const u8 as *const libc::c_char,
                    903 as libc::c_int,
                    tmp___14,
                    tmp___13,
                );
                tmp___15 = url_get_port(U);
                tmp___16 = url_get_hostname(U);
                (*(*this).conn)
                    .sock = new_socket(
                    (*this).conn,
                    tmp___16 as *const libc::c_char,
                    tmp___15,
                );
            }
        }
        _ => {}
    }
    if my.keepalive as u64 != 0 {
        (*(*this).conn).connection.reuse = 1 as libc::c_int;
    }
    if (*(*this).conn).sock < 0 as libc::c_int {
        tmp___18 = __errno_location();
        tmp___19 = strerror(*tmp___18);
        tmp___20 = __errno_location();
        debug(
            b"%s:%d connection failed. error %d(%s)\0" as *const u8
                as *const libc::c_char,
            b"browser.c\0" as *const u8 as *const libc::c_char,
            915 as libc::c_int,
            *tmp___20,
            tmp___19,
        );
        socket_close((*this).conn);
        return boolean_false;
    }
    tmp___25 = auth_get_proxy_required(my.auth);
    if tmp___25 as u64 != 0 {
        tmp___22 = auth_get_proxy_port(my.auth);
        tmp___24 = tmp___22;
    } else {
        tmp___23 = url_get_port(U);
        tmp___24 = tmp___23;
    }
    tmp___30 = auth_get_proxy_required(my.auth);
    if tmp___30 as u64 != 0 {
        tmp___27 = auth_get_proxy_host(my.auth);
        tmp___29 = tmp___27;
    } else {
        tmp___28 = url_get_hostname(U);
        tmp___29 = tmp___28;
    }
    debug(
        b"%s:%d good socket connection:  %s:%d\0" as *const u8 as *const libc::c_char,
        b"browser.c\0" as *const u8 as *const libc::c_char,
        923 as libc::c_int,
        tmp___29,
        tmp___24,
    );
    tmp___36 = url_get_scheme(U);
    if tmp___36 as libc::c_uint == 2 as libc::c_uint {
        tmp___33 = auth_get_proxy_required(my.auth);
        if tmp___33 as u64 != 0 {
            tmp___31 = url_get_port(U);
            tmp___32 = url_get_hostname(U);
            https_tunnel_request((*this).conn, tmp___32, tmp___31);
            https_tunnel_response((*this).conn);
        }
        (*(*this).conn).encrypt = boolean_true;
        tmp___34 = url_get_hostname(U);
        tmp___35 = SSL_initialize((*this).conn, tmp___34 as *const libc::c_char);
        if tmp___35 as libc::c_uint == 0 as libc::c_uint {
            return boolean_false;
        }
    }
    return boolean_true;
}
unsafe extern "C" fn __display_result(
    mut this: BROWSER,
    mut resp: RESPONSE,
    mut U: URL,
    mut bytes: libc::c_ulong,
    mut etime: libc::c_float,
) {
    let mut fmtime: [libc::c_char; 65] = [0; 65];
    let mut keepsake: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut now: time_t = 0;
    let mut tmp: *mut tm = 0 as *mut tm;
    let mut len: size_t = 0;
    let mut tmp___0: *mut tm = 0 as *mut tm;
    let mut color: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut date: DATE = 0 as *mut DATE_T;
    let mut tmp___4: DATE = 0 as *mut DATE_T;
    let mut stamp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut cached: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: BOOLEAN = boolean_false;
    let mut tmp___10: BOOLEAN = boolean_false;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___21: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___22: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___23: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___24: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___28: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: *mut libc::c_char = 0 as *mut libc::c_char;
    if my.csv as u64 != 0 {
        now = time(0 as *mut libc::c_void as *mut time_t);
        tmp___0 = localtime_r(
            &mut now as *mut time_t as *const time_t,
            &mut keepsake as *mut tm,
        );
        tmp = tmp___0;
        if !tmp.is_null() {
            len = strftime(
                fmtime.as_mut_ptr(),
                64 as libc::c_int as size_t,
                b"%Y-%m-%d %H:%M:%S\0" as *const u8 as *const libc::c_char,
                tmp as *const tm,
            );
            if len == 0 as libc::c_ulong {
                memset(
                    fmtime.as_mut_ptr() as *mut libc::c_void,
                    '\u{0}' as i32,
                    64 as libc::c_int as size_t,
                );
                snprintf(
                    fmtime.as_mut_ptr(),
                    64 as libc::c_int as size_t,
                    b"n/a\0" as *const u8 as *const libc::c_char,
                );
            }
        } else {
            snprintf(
                fmtime.as_mut_ptr(),
                64 as libc::c_int as size_t,
                b"n/a\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if my.verbose as u64 != 0 {
        if my.get as u64 == 0 {
            if my.print as u64 == 0 {
                if my.debug as u64 == 0 {
                    if my.color as libc::c_uint == 1 as libc::c_uint {
                        tmp___1 = response_get_code(resp);
                        tmp___2 = __select_color(tmp___1);
                        tmp___3 = tmp___2;
                    } else {
                        tmp___3 = -(1 as libc::c_int);
                    }
                    color = tmp___3;
                    tmp___4 = new_date(0 as *mut libc::c_char);
                    date = tmp___4;
                    if my.timestamp as u64 != 0 {
                        tmp___5 = date_stamp(date);
                        tmp___6 = tmp___5 as *const libc::c_char;
                    } else {
                        tmp___6 = b"\0" as *const u8 as *const libc::c_char;
                    }
                    stamp = tmp___6 as *mut libc::c_char;
                    tmp___9 = response_get_from_cache(resp);
                    if tmp___9 as u64 != 0 {
                        tmp___8 = b"(C)\0" as *const u8 as *const libc::c_char;
                    } else {
                        tmp___8 = b"   \0" as *const u8 as *const libc::c_char;
                    }
                    cached = tmp___8 as *mut libc::c_char;
                    if my.color as u64 != 0 {
                        tmp___10 = response_get_from_cache(resp);
                        if tmp___10 as libc::c_uint == 1 as libc::c_uint {
                            color = 2 as libc::c_int;
                        }
                    }
                    if my.csv as u64 != 0 {
                        if my.display as u64 != 0 {
                            tmp___11 = url_get_ID(U);
                            tmp___12 = url_get_display(U);
                            tmp___13 = response_get_code(resp);
                            tmp___14 = response_get_protocol(resp);
                            if my.mark as u64 != 0 {
                                tmp___15 = b",\0" as *const u8 as *const libc::c_char;
                            } else {
                                tmp___15 = b"\0" as *const u8 as *const libc::c_char;
                            }
                            if my.mark as u64 != 0 {
                                tmp___16 = my.markstr as *const libc::c_char;
                            } else {
                                tmp___16 = b"\0" as *const u8 as *const libc::c_char;
                            }
                            DISPLAY(
                                color,
                                b"%s%s%s%4d,%s,%d,%6.2f,%7lu,%s,%d,%s\0" as *const u8
                                    as *const libc::c_char,
                                stamp,
                                tmp___16,
                                tmp___15,
                                (*this).id,
                                tmp___14,
                                tmp___13,
                                etime as libc::c_double,
                                bytes,
                                tmp___12,
                                tmp___11,
                                fmtime.as_mut_ptr(),
                            );
                        } else {
                            tmp___17 = url_get_ID(U);
                            tmp___18 = url_get_display(U);
                            tmp___19 = response_get_code(resp);
                            tmp___20 = response_get_protocol(resp);
                            if my.mark as u64 != 0 {
                                tmp___21 = b",\0" as *const u8 as *const libc::c_char;
                            } else {
                                tmp___21 = b"\0" as *const u8 as *const libc::c_char;
                            }
                            if my.mark as u64 != 0 {
                                tmp___22 = my.markstr as *const libc::c_char;
                            } else {
                                tmp___22 = b"\0" as *const u8 as *const libc::c_char;
                            }
                            DISPLAY(
                                color,
                                b"%s%s%s%s,%d,%6.2f,%7lu,%s,%d,%s\0" as *const u8
                                    as *const libc::c_char,
                                stamp,
                                tmp___22,
                                tmp___21,
                                tmp___20,
                                tmp___19,
                                etime as libc::c_double,
                                bytes,
                                tmp___18,
                                tmp___17,
                                fmtime.as_mut_ptr(),
                            );
                        }
                    } else if my.display as u64 != 0 {
                        tmp___23 = url_get_display(U);
                        tmp___24 = url_get_method_name(U);
                        tmp___25 = response_get_code(resp);
                        tmp___26 = response_get_protocol(resp);
                        DISPLAY(
                            color,
                            b"%4d) %s %d %6.2f secs: %7lu bytes ==> %-4s %s\0"
                                as *const u8 as *const libc::c_char,
                            (*this).id,
                            tmp___26,
                            tmp___25,
                            etime as libc::c_double,
                            bytes,
                            tmp___24,
                            tmp___23,
                        );
                    } else {
                        tmp___27 = url_get_display(U);
                        tmp___28 = url_get_method_name(U);
                        tmp___29 = response_get_code(resp);
                        tmp___30 = response_get_protocol(resp);
                        DISPLAY(
                            color,
                            b"%s%s %d%s %5.2f secs: %7lu bytes ==> %-4s %s\0"
                                as *const u8 as *const libc::c_char,
                            stamp,
                            tmp___30,
                            tmp___29,
                            cached,
                            etime as libc::c_double,
                            bytes,
                            tmp___28,
                            tmp___27,
                        );
                    }
                    date = date_destroy(date);
                }
            }
        }
    }
}
unsafe extern "C" fn __increment_failures() {
    pthread_mutex_lock(&mut my.lock);
    my.failed += 1;
    pthread_mutex_unlock(&mut my.lock);
    pthread_testcancel();
}
unsafe extern "C" fn __no_follow(mut hostname: *const libc::c_char) -> BOOLEAN {
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    i = 0 as libc::c_int;
    while i < (*my.nomap).index {
        tmp = stristr(
            hostname,
            *((*my.nomap).line).offset(i as isize) as *const libc::c_char,
        );
        if tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            return boolean_true;
        }
        i += 1;
    }
    return boolean_false;
}
unsafe extern "C" fn __select_color(mut code: libc::c_int) -> libc::c_int {
    match code {
        226 | 206 | 205 | 204 | 203 | 202 | 201 | 200 | 150 => return 4 as libc::c_int,
        307 | 306 | 305 | 304 | 303 | 302 | 301 | 300 => return 6 as libc::c_int,
        417 | 416 | 415 | 414 | 413 | 412 | 411 | 410 | 409 | 408 | 407 | 406 | 405 | 404
        | 403 | 402 | 401 | 400 => return 5 as libc::c_int,
        _ => return 1 as libc::c_int,
    };
}
unsafe extern "C" fn __signal_cleanup() {}
static mut keys: [*const libc::c_char; 4] = [
    b"ET_\0" as *const u8 as *const libc::c_char,
    b"LM_\0" as *const u8 as *const libc::c_char,
    b"EX_\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
];
pub static mut CACHESIZE: size_t = ::std::mem::size_of::<CACHE_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_cache() -> CACHE {
    let mut this: CACHE = 0 as *mut CACHE_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(CACHESIZE, 1 as libc::c_int as size_t);
    this = tmp as CACHE;
    (*this).cache = new_hash();
    (*this).header = 0 as *mut libc::c_void as *mut libc::c_char;
    hash_set_destroyer(
        (*this).cache,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(
            ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(DATE) -> DATE>,
                *mut libc::c_void,
            >(Some(date_destroy as unsafe extern "C" fn(DATE) -> DATE)),
        ),
    );
    return this;
}
pub unsafe extern "C" fn cache_destroy(mut this: CACHE) -> CACHE {
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*this).cache = hash_destroy((*this).cache);
        free(this as *mut libc::c_void);
        this = 0 as *mut libc::c_void as CACHE;
    }
    return this;
}
pub unsafe extern "C" fn cache_contains(
    mut this: CACHE,
    mut type_0: CTYPE,
    mut U: URL,
) -> BOOLEAN {
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut found: BOOLEAN = boolean_false;
    found = boolean_false;
    if my.cache as u64 == 0 {
        return boolean_false;
    }
    key = __build_key(type_0, U);
    if key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_false;
    }
    found = hash_contains((*this).cache, key);
    free(key as *mut libc::c_void);
    return found;
}
pub unsafe extern "C" fn is_cached(mut this: CACHE, mut U: URL) -> BOOLEAN {
    let mut day: DATE = 0 as *mut DATE_T;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: BOOLEAN = boolean_false;
    day = 0 as *mut libc::c_void as DATE;
    tmp = __build_key(C_EXPIRES, U);
    key = tmp;
    tmp___2 = hash_contains((*this).cache, key);
    if tmp___2 as u64 != 0 {
        tmp___0 = hash_get((*this).cache, key);
        day = tmp___0 as DATE;
        tmp___1 = date_expired(day);
        if tmp___1 as libc::c_uint == 0 as libc::c_uint {
            return boolean_true
        } else {
            hash_remove((*this).cache, key);
            return boolean_false;
        }
    }
    return boolean_false;
}
pub unsafe extern "C" fn cache_add(
    mut this: CACHE,
    mut type_0: CTYPE,
    mut U: URL,
    mut date: *mut libc::c_char,
) {
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: DATE = 0 as *mut DATE_T;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: DATE = 0 as *mut DATE_T;
    let mut tmp___4: DATE = 0 as *mut DATE_T;
    tmp = __build_key(type_0, U);
    key = tmp;
    if key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    if type_0 as libc::c_uint != 2 as libc::c_uint {
        tmp___0 = hash_contains((*this).cache, key);
        if tmp___0 as u64 != 0 {
            hash_remove((*this).cache, key);
        }
    }
    match type_0 as libc::c_uint {
        0 => {
            tmp___1 = new_etag(date);
            hash_nadd((*this).cache, key, tmp___1 as *mut libc::c_void, DATESIZE);
        }
        2 => {
            tmp___2 = hash_contains((*this).cache, key);
            if !(tmp___2 as libc::c_uint == 1 as libc::c_uint) {
                tmp___3 = new_date(date);
                hash_nadd((*this).cache, key, tmp___3 as *mut libc::c_void, DATESIZE);
            }
        }
        _ => {
            tmp___4 = new_date(date);
            hash_nadd((*this).cache, key, tmp___4 as *mut libc::c_void, DATESIZE);
        }
    }
    free(key as *mut libc::c_void);
}
pub unsafe extern "C" fn cache_get(
    mut this: CACHE,
    mut type_0: CTYPE,
    mut U: URL,
) -> DATE {
    let mut date: DATE = 0 as *mut DATE_T;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = __build_key(type_0, U);
    key = tmp;
    if key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as DATE;
    }
    tmp___0 = hash_get((*this).cache, key);
    date = tmp___0 as DATE;
    free(key as *mut libc::c_void);
    return date;
}
pub unsafe extern "C" fn cache_get_header(
    mut this: CACHE,
    mut type_0: CTYPE,
    mut U: URL,
) -> *mut libc::c_char {
    let mut d: DATE = 0 as *mut DATE_T;
    let mut e: DATE = 0 as *mut DATE_T;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut exp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: BOOLEAN = boolean_false;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: BOOLEAN = boolean_false;
    d = 0 as *mut libc::c_void as DATE;
    e = 0 as *mut libc::c_void as DATE;
    key = 0 as *mut libc::c_void as *mut libc::c_char;
    exp = 0 as *mut libc::c_void as *mut libc::c_char;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___0 = cache_contains(this, type_0, U);
    if tmp___0 as u64 == 0 {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    exp = __build_key(C_EXPIRES, U);
    if !exp.is_null() {
        tmp___1 = hash_get((*this).cache, exp);
        e = tmp___1 as DATE;
        free(exp as *mut libc::c_void);
        tmp___2 = date_expired(e);
        if tmp___2 as u64 != 0 {
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    key = __build_key(type_0, U);
    if key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmp___3 = hash_get((*this).cache, key);
    d = tmp___3 as DATE;
    if d as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    memset(
        tmp.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        256 as libc::c_int as size_t,
    );
    match type_0 as libc::c_uint {
        0 => {
            tmp___4 = date_get_etag(d);
            ptr = strdup(tmp___4 as *const libc::c_char);
            tmp___5 = empty(ptr as *const libc::c_char);
            if tmp___5 as u64 != 0 {
                return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
            }
            snprintf(
                tmp.as_mut_ptr(),
                256 as libc::c_int as size_t,
                b"If-None-Match: %s\r\n\0" as *const u8 as *const libc::c_char,
                ptr,
            );
            (*this).header = strdup(tmp.as_mut_ptr() as *const libc::c_char);
            free(ptr as *mut libc::c_void);
            return (*this).header;
        }
        _ => {
            tmp___6 = date_get_rfc850(d);
            ptr = strdup(tmp___6 as *const libc::c_char);
            tmp___7 = empty(ptr as *const libc::c_char);
            if tmp___7 as u64 != 0 {
                return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
            }
            snprintf(
                tmp.as_mut_ptr(),
                256 as libc::c_int as size_t,
                b"If-Modified-Since: %s\r\n\0" as *const u8 as *const libc::c_char,
                ptr,
            );
            (*this).header = strdup(tmp.as_mut_ptr() as *const libc::c_char);
            free(ptr as *mut libc::c_void);
            return (*this).header;
        }
    };
}
unsafe extern "C" fn __build_key(mut type_0: CTYPE, mut U: URL) -> *mut libc::c_char {
    let mut len: libc::c_int = 0;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    len = 0 as libc::c_int;
    key = 0 as *mut libc::c_void as *mut libc::c_char;
    if U as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char
    } else {
        tmp = url_get_request(U);
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return 0 as *mut libc::c_void as *mut libc::c_char
        } else {
            tmp___0 = url_get_request(U);
            tmp___1 = strlen(tmp___0 as *const libc::c_char);
            if tmp___1 < 1 as libc::c_ulong {
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
        }
    }
    tmp___2 = url_get_request(U);
    tmp___3 = strlen(tmp___2 as *const libc::c_char);
    tmp___4 = strlen(keys[type_0 as usize]);
    len = tmp___3.wrapping_add(tmp___4).wrapping_add(1 as libc::c_ulong) as libc::c_int;
    tmp___5 = malloc((len + 1 as libc::c_int) as size_t);
    key = tmp___5 as *mut libc::c_char;
    memset(key as *mut libc::c_void, '\u{0}' as i32, (len + 1 as libc::c_int) as size_t);
    tmp___6 = url_get_request(U);
    snprintf(
        key,
        len as size_t,
        b"%s%s\0" as *const u8 as *const libc::c_char,
        keys[type_0 as usize],
        tmp___6,
    );
    return key;
}
pub static mut COOKIESIZE: size_t = ::std::mem::size_of::<COOKIE_T>() as libc::c_ulong;
static mut months: [*mut libc::c_char; 12] = [
    b"Jan\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Feb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Mar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Apr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"May\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Jun\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Jul\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Aug\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Sep\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Oct\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Nov\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Dec\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
];
pub unsafe extern "C" fn new_cookie(
    mut str: *mut libc::c_char,
    mut host: *mut libc::c_char,
) -> COOKIE {
    let mut this: COOKIE = 0 as *mut COOKIE_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: COOKIE = 0 as *mut COOKIE_T;
    let mut tmp___1: BOOLEAN = boolean_false;
    tmp = calloc(
        ::std::mem::size_of::<COOKIE_T>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    this = tmp as COOKIE;
    (*this).name = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).value = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).domain = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).expires = 0 as libc::c_int as time_t;
    (*this).expstr = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).string = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).session = boolean_true;
    (*this).none = strdup(b"none\0" as *const u8 as *const libc::c_char);
    tmp___1 = __parse_input(this, str, host);
    if tmp___1 as libc::c_uint == 0 as libc::c_uint {
        tmp___0 = cookie_destroy(this);
        return tmp___0;
    }
    return this;
}
pub unsafe extern "C" fn cookie_destroy(mut this: COOKIE) -> COOKIE {
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free((*this).name as *mut libc::c_void);
        free((*this).value as *mut libc::c_void);
        free((*this).domain as *mut libc::c_void);
        free((*this).expstr as *mut libc::c_void);
        free((*this).path as *mut libc::c_void);
        free((*this).none as *mut libc::c_void);
        free((*this).string as *mut libc::c_void);
        free(this as *mut libc::c_void);
    }
    return 0 as *mut libc::c_void as COOKIE;
}
pub unsafe extern "C" fn cookie_set_name(mut this: COOKIE, mut str: *mut libc::c_char) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    len = tmp.wrapping_add(1 as libc::c_ulong);
    tmp___0 = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong).wrapping_mul(len),
    );
    (*this).name = tmp___0 as *mut libc::c_char;
    memset((*this).name as *mut libc::c_void, '\u{0}' as i32, len);
    memcpy((*this).name as *mut libc::c_void, str as *const libc::c_void, len);
}
pub unsafe extern "C" fn cookie_set_value(mut this: COOKIE, mut str: *mut libc::c_char) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    len = tmp.wrapping_add(1 as libc::c_ulong);
    tmp___0 = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong).wrapping_mul(len),
    );
    (*this).value = tmp___0 as *mut libc::c_char;
    memset((*this).value as *mut libc::c_void, '\u{0}' as i32, len);
    memcpy((*this).value as *mut libc::c_void, str as *const libc::c_void, len);
}
pub unsafe extern "C" fn cookie_set_path(mut this: COOKIE, mut str: *mut libc::c_char) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    len = tmp.wrapping_add(1 as libc::c_ulong);
    tmp___0 = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong).wrapping_mul(len),
    );
    (*this).path = tmp___0 as *mut libc::c_char;
    memset((*this).path as *mut libc::c_void, '\u{0}' as i32, len);
    memcpy((*this).path as *mut libc::c_void, str as *const libc::c_void, len);
}
pub unsafe extern "C" fn cookie_set_domain(
    mut this: COOKIE,
    mut str: *mut libc::c_char,
) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    len = tmp.wrapping_add(1 as libc::c_ulong);
    tmp___0 = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong).wrapping_mul(len),
    );
    (*this).domain = tmp___0 as *mut libc::c_char;
    memset((*this).domain as *mut libc::c_void, '\u{0}' as i32, len);
    memcpy((*this).domain as *mut libc::c_void, str as *const libc::c_void, len);
}
pub unsafe extern "C" fn cookie_set_expires(mut this: COOKIE, mut expires: time_t) {
    (*this).expires = expires;
}
pub unsafe extern "C" fn cookie_get_name(mut this: COOKIE) -> *mut libc::c_char {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if (*this).name as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return (*this).none;
        }
    }
    return (*this).name;
}
pub unsafe extern "C" fn cookie_get_value(mut this: COOKIE) -> *mut libc::c_char {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if (*this).value as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return (*this).none;
        }
    }
    return (*this).value;
}
pub unsafe extern "C" fn cookie_get_domain(mut this: COOKIE) -> *mut libc::c_char {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if (*this).domain as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return (*this).none;
        }
    }
    return (*this).domain;
}
pub unsafe extern "C" fn cookie_get_path(mut this: COOKIE) -> *mut libc::c_char {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if (*this).path as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return (*this).none;
        }
    }
    return (*this).path;
}
pub unsafe extern "C" fn cookie_get_expires(mut this: COOKIE) -> time_t {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int) as time_t;
    }
    return (*this).expires;
}
pub unsafe extern "C" fn cookie_get_session(mut this: COOKIE) -> BOOLEAN {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_true;
    }
    return (*this).session;
}
pub unsafe extern "C" fn cookie_expires_string(mut this: COOKIE) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut timeinfo: *mut tm = 0 as *mut tm;
    tmp = realloc(
        (*this).expstr as *mut libc::c_void,
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            .wrapping_mul(128 as libc::c_ulong),
    );
    (*this).expstr = tmp as *mut libc::c_char;
    memset(
        (*this).expstr as *mut libc::c_void,
        '\u{0}' as i32,
        128 as libc::c_int as size_t,
    );
    timeinfo = localtime(&mut (*this).expires as *mut time_t as *const time_t);
    strftime(
        (*this).expstr,
        128 as libc::c_int as size_t,
        b"%a, %d %b %Y %H:%M:%S %z\0" as *const u8 as *const libc::c_char,
        timeinfo as *const tm,
    );
    return (*this).expstr;
}
pub unsafe extern "C" fn cookie_to_string(mut this: COOKIE) -> *mut libc::c_char {
    let mut len: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    len = 4096 as libc::c_int;
    if (*this).name as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char
    } else {
        if (*this).value as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return 0 as *mut libc::c_void as *mut libc::c_char
        } else {
            if (*this).domain as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
            {
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
        }
    }
    tmp = realloc(
        (*this).string as *mut libc::c_void,
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            .wrapping_mul(len as libc::c_ulong),
    );
    (*this).string = tmp as *mut libc::c_char;
    memset((*this).string as *mut libc::c_void, '\u{0}' as i32, len as size_t);
    if (*this).path as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = (*this).path as *const libc::c_char;
    } else {
        tmp___0 = b"/\0" as *const u8 as *const libc::c_char;
    }
    if (*this).domain as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___1 = (*this).domain as *const libc::c_char;
    } else {
        tmp___1 = b"none\0" as *const u8 as *const libc::c_char;
    }
    snprintf(
        (*this).string,
        len as size_t,
        b"%s=%s; domain=%s; path=%s; expires=%lld\0" as *const u8 as *const libc::c_char,
        (*this).name,
        (*this).value,
        tmp___1,
        tmp___0,
        (*this).expires as libc::c_longlong,
    );
    return (*this).string;
}
pub unsafe extern "C" fn strealloc(
    mut old: *mut libc::c_char,
    mut str: *mut libc::c_char,
) -> *mut libc::c_void {
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut newptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    num = tmp.wrapping_add(1 as libc::c_ulong);
    tmp___0 = realloc(
        old as *mut libc::c_void,
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong).wrapping_mul(num),
    );
    newptr = tmp___0 as *mut libc::c_char;
    if !newptr.is_null() {
        memset(
            newptr as *mut libc::c_void,
            '\u{0}' as i32,
            num.wrapping_add(1 as libc::c_ulong),
        );
        memcpy(newptr as *mut libc::c_void, str as *const libc::c_void, num);
    }
    return newptr as *mut libc::c_void;
}
pub unsafe extern "C" fn cookie_reset_value(
    mut this: COOKIE,
    mut value: *mut libc::c_char,
) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strealloc((*this).value, value);
    (*this).value = tmp as *mut libc::c_char;
}
pub unsafe extern "C" fn cookie_clone(mut this: COOKIE, mut that: COOKIE) -> COOKIE {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: time_t = 0;
    tmp = cookie_get_value(that);
    tmp___0 = strealloc((*this).value, tmp);
    (*this).value = tmp___0 as *mut libc::c_char;
    tmp___1 = cookie_get_domain(that);
    tmp___2 = strealloc((*this).domain, tmp___1);
    (*this).domain = tmp___2 as *mut libc::c_char;
    tmp___3 = cookie_get_path(that);
    tmp___4 = strealloc((*this).path, tmp___3);
    (*this).path = tmp___4 as *mut libc::c_char;
    if (*this).expires > 0 as libc::c_long {
        tmp___5 = cookie_get_expires(that);
        (*this).expires = time(tmp___5 as *mut time_t);
    }
    if (*this).session as libc::c_uint == 1 as libc::c_uint {
        (*this).session = cookie_get_session(that);
    }
    return this;
}
unsafe extern "C" fn __parse_input(
    mut this: COOKIE,
    mut str: *mut libc::c_char,
    mut host: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut val: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pos___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut expires: libc::c_int = 0;
    let mut newline: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut gmt: *mut tm = 0 as *mut tm;
    let mut max: libc::c_long = 0;
    let mut now: time_t = 0;
    let mut tmp___3: time_t = 0;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    expires = 0 as libc::c_int;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        printf(
            b"Coookie: Unable to parse header string\0" as *const u8
                as *const libc::c_char,
        );
        return boolean_false;
    }
    while *str != 0 {
        if !(*str as libc::c_int == 32 as libc::c_int) {
            break;
        }
        str = str.offset(1);
    }
    newline = str;
    loop {
        tmp = __parse_pair(&mut newline);
        if !(tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        key = tmp;
        while *tmp != 0 {
            tmp___0 = __ctype_b_loc();
            if *(*tmp___0)
                .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & 8192 as libc::c_int != 0
            {
                break;
            }
            if 61 as libc::c_int == *tmp as libc::c_int {
                break;
            }
            if 58 as libc::c_int == *tmp as libc::c_int {
                break;
            }
            tmp = tmp.offset(1);
        }
        tmp___1 = tmp;
        tmp = tmp.offset(1);
        *tmp___1 = 0 as libc::c_int as libc::c_char;
        loop {
            tmp___2 = __ctype_b_loc();
            if *(*tmp___2)
                .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & 8192 as libc::c_int == 0
            {
                if !(61 as libc::c_int == *tmp as libc::c_int) {
                    if !(58 as libc::c_int == *tmp as libc::c_int) {
                        break;
                    }
                }
            }
            tmp = tmp.offset(1);
        }
        val = tmp;
        while *tmp != 0 {
            tmp = tmp.offset(1);
        }
        tmp___9 = strncasecmp(
            key as *const libc::c_char,
            b"expires\0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as size_t,
        );
        if tmp___9 != 0 {
            tmp___8 = strncasecmp(
                key as *const libc::c_char,
                b"max-age\0" as *const u8 as *const libc::c_char,
                7 as libc::c_int as size_t,
            );
            if tmp___8 != 0 {
                tmp___7 = strncasecmp(
                    key as *const libc::c_char,
                    b"path\0" as *const u8 as *const libc::c_char,
                    4 as libc::c_int as size_t,
                );
                if tmp___7 != 0 {
                    tmp___6 = strncasecmp(
                        key as *const libc::c_char,
                        b"domain\0" as *const u8 as *const libc::c_char,
                        6 as libc::c_int as size_t,
                    );
                    if tmp___6 != 0 {
                        tmp___5 = strncasecmp(
                            key as *const libc::c_char,
                            b"secure\0" as *const u8 as *const libc::c_char,
                            6 as libc::c_int as size_t,
                        );
                        if tmp___5 != 0 {
                            (*this).name = strdup(key as *const libc::c_char);
                            (*this).value = strdup(val as *const libc::c_char);
                        } else {
                            (*this).secure = boolean_true;
                        }
                    } else {
                        cookie_set_domain(this, val);
                    }
                } else {
                    (*this).path = strdup(val as *const libc::c_char);
                }
            } else {
                max = -(1 as libc::c_long);
                tmp___3 = time(0 as *mut libc::c_void as *mut time_t);
                now = tmp___3;
                gmt = gmtime(&mut now as *mut time_t as *const time_t);
                now = mktime(gmt);
                tmp___4 = atof(val as *const libc::c_char);
                max = tmp___4 as libc::c_long;
                if max != -(1 as libc::c_long) {
                    (*this).session = boolean_false;
                }
            }
        } else {
            expires = __parse_time(val as *const libc::c_char);
            if expires != -(1 as libc::c_int) {
                (*this).session = boolean_false;
                (*this).expires = expires as time_t;
            }
        }
    }
    if (*this).expires < 1000 as libc::c_long {
        (*this).session = boolean_true;
    }
    if (*this).domain as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        pos___0 = strchr(host as *const libc::c_char, '.' as i32);
        if pos___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            (*this).domain = xstrdup(b".\0" as *const u8 as *const libc::c_char);
        } else {
            (*this).domain = xstrdup(pos___0 as *const libc::c_char);
        }
    }
    return boolean_true;
}
unsafe extern "C" fn __parse_pair(mut str: *mut *mut libc::c_char) -> *mut libc::c_char {
    let mut okay___0: libc::c_int = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pair: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    okay___0 = 0 as libc::c_int;
    p = *str;
    pair = 0 as *mut libc::c_void as *mut libc::c_char;
    if str.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char
    } else {
        if (*str).is_null() {
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    pair = p;
    if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    while *p as libc::c_int != 0 as libc::c_int {
        if !(*p as libc::c_int != 59 as libc::c_int) {
            break;
        }
        if *p == 0 {
            *str = p;
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if *p as libc::c_int == 61 as libc::c_int {
            okay___0 = 1 as libc::c_int;
        }
        p = p.offset(1);
    }
    tmp = p;
    p = p.offset(1);
    *tmp = '\u{0}' as i32 as libc::c_char;
    *str = p;
    trim(pair);
    if okay___0 != 0 {
        return pair
    } else {
        return 0 as *mut libc::c_void as *mut libc::c_char
    };
}
unsafe extern "C" fn __utc_offset() -> libc::c_int {
    let mut hrs: libc::c_int = 0;
    let mut ptr: *mut tm = 0 as *mut tm;
    let mut zip: time_t = 0;
    zip = 86400 as libc::c_long;
    ptr = localtime(&mut zip as *mut time_t as *const time_t);
    hrs = (*ptr).tm_hour;
    if (*ptr).tm_mday < 2 as libc::c_int {
        hrs -= 24 as libc::c_int;
    }
    return hrs;
}
unsafe extern "C" fn __parse_time(mut str: *const libc::c_char) -> libc::c_int {
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut rv: time_t = 0;
    let mut now: time_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_long = 0;
    let mut tmp___1: libc::c_long = 0;
    let mut tmp___2: libc::c_long = 0;
    let mut tmp___3: libc::c_long = 0;
    let mut tmp___4: libc::c_long = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: libc::c_long = 0;
    let mut tmp___7: libc::c_long = 0;
    let mut tmp___8: libc::c_long = 0;
    let mut tmp___9: libc::c_long = 0;
    let mut tmp___10: libc::c_long = 0;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: size_t = 0;
    let mut tmp___13: libc::c_long = 0;
    let mut tmp___14: libc::c_long = 0;
    let mut tmp___15: libc::c_long = 0;
    let mut tmp___16: libc::c_long = 0;
    let mut tmp___17: libc::c_long = 0;
    let mut tmp___18: libc::c_long = 0;
    let mut tmp___19: libc::c_long = 0;
    let mut tmp___20: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___21: size_t = 0;
    let mut tmp___22: libc::c_long = 0;
    let mut tmp___23: libc::c_long = 0;
    let mut tmp___24: libc::c_long = 0;
    let mut tmp___25: libc::c_long = 0;
    let mut tmp___26: libc::c_long = 0;
    let mut tmp___27: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___30: *mut libc::c_char = 0 as *mut libc::c_char;
    if str.is_null() {
        return 0 as libc::c_int;
    }
    s = strchr(str, ',' as i32);
    if !s.is_null() {
        s = s.offset(1);
        while *s != 0 {
            if !(*s as libc::c_int == 32 as libc::c_int) {
                break;
            }
            s = s.offset(1);
        }
        tmp___11 = strchr(s as *const libc::c_char, '-' as i32);
        if !tmp___11.is_null() {
            tmp = strlen(s as *const libc::c_char);
            if (tmp as libc::c_int) < 18 as libc::c_int {
                return 0 as libc::c_int;
            }
            tmp___0 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_mday = tmp___0 as libc::c_int;
            s = s.offset(1);
            tm.tm_mon = __mkmonth(s, &mut s);
            s = s.offset(1);
            tmp___1 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_year = (tmp___1 - 1900 as libc::c_long) as libc::c_int;
            s = s.offset(1);
            tmp___2 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_hour = tmp___2 as libc::c_int;
            s = s.offset(1);
            tmp___3 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_min = tmp___3 as libc::c_int;
            s = s.offset(1);
            tmp___4 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_sec = tmp___4 as libc::c_int;
        } else {
            tmp___5 = strlen(s as *const libc::c_char);
            if (tmp___5 as libc::c_int) < 20 as libc::c_int {
                return 0 as libc::c_int;
            }
            tmp___6 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_mday = tmp___6 as libc::c_int;
            tm.tm_mon = __mkmonth(s, &mut s);
            tmp___7 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_year = (tmp___7 - 1900 as libc::c_long) as libc::c_int;
            tmp___8 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_hour = tmp___8 as libc::c_int;
            s = s.offset(1);
            tmp___9 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_min = tmp___9 as libc::c_int;
            s = s.offset(1);
            tmp___10 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_sec = tmp___10 as libc::c_int;
        }
    } else {
        tmp___27 = __ctype_b_loc();
        if *(*tmp___27).offset(*str as libc::c_int as isize) as libc::c_int
            & 2048 as libc::c_int != 0
        {
            tmp___20 = strchr(str, 'T' as i32);
            if !tmp___20.is_null() {
                s = str as *mut libc::c_char;
                while *s != 0 {
                    if !(*s as libc::c_int == 32 as libc::c_int) {
                        break;
                    }
                    s = s.offset(1);
                }
                tmp___12 = strlen(s as *const libc::c_char);
                if (tmp___12 as libc::c_int) < 21 as libc::c_int {
                    return 0 as libc::c_int;
                }
                tmp___13 = strtol(
                    s as *const libc::c_char,
                    &mut s as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                tm.tm_year = (tmp___13 - 1900 as libc::c_long) as libc::c_int;
                s = s.offset(1);
                tmp___14 = strtol(
                    s as *const libc::c_char,
                    &mut s as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                tm.tm_mon = tmp___14 as libc::c_int;
                s = s.offset(1);
                tmp___15 = strtol(
                    s as *const libc::c_char,
                    &mut s as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                tm.tm_mday = tmp___15 as libc::c_int;
                s = s.offset(1);
                tmp___16 = strtol(
                    s as *const libc::c_char,
                    &mut s as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                tm.tm_hour = tmp___16 as libc::c_int;
                s = s.offset(1);
                tmp___17 = strtol(
                    s as *const libc::c_char,
                    &mut s as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                tm.tm_min = tmp___17 as libc::c_int;
                s = s.offset(1);
                tmp___18 = strtol(
                    s as *const libc::c_char,
                    &mut s as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                tm.tm_sec = tmp___18 as libc::c_int;
            } else {
                tmp___19 = atol(str);
                return tmp___19 as libc::c_int;
            }
        } else {
            s = str as *mut libc::c_char;
            while *s != 0 {
                if !(*s as libc::c_int != 32 as libc::c_int) {
                    break;
                }
                s = s.offset(1);
            }
            tmp___21 = strlen(s as *const libc::c_char);
            if (tmp___21 as libc::c_int) < 20 as libc::c_int {
                return 0 as libc::c_int;
            }
            tm.tm_mon = __mkmonth(s, &mut s);
            tmp___22 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_mday = tmp___22 as libc::c_int;
            tmp___23 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_hour = tmp___23 as libc::c_int;
            s = s.offset(1);
            tmp___24 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_min = tmp___24 as libc::c_int;
            s = s.offset(1);
            tmp___25 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_sec = tmp___25 as libc::c_int;
            tmp___26 = strtol(
                s as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                10 as libc::c_int,
            );
            tm.tm_year = (tmp___26 - 1900 as libc::c_long) as libc::c_int;
        }
    }
    if tm.tm_sec < 0 as libc::c_int {
        return 0 as libc::c_int
    } else {
        if tm.tm_sec > 59 as libc::c_int {
            return 0 as libc::c_int
        } else {
            if tm.tm_min < 0 as libc::c_int {
                return 0 as libc::c_int
            } else {
                if tm.tm_min > 59 as libc::c_int {
                    return 0 as libc::c_int
                } else {
                    if tm.tm_hour < 0 as libc::c_int {
                        return 0 as libc::c_int
                    } else {
                        if tm.tm_hour > 23 as libc::c_int {
                            return 0 as libc::c_int
                        } else {
                            if tm.tm_mday < 1 as libc::c_int {
                                return 0 as libc::c_int
                            } else {
                                if tm.tm_mday > 31 as libc::c_int {
                                    return 0 as libc::c_int
                                } else {
                                    if tm.tm_mon < 0 as libc::c_int {
                                        return 0 as libc::c_int
                                    } else {
                                        if tm.tm_mon > 11 as libc::c_int {
                                            return 0 as libc::c_int;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    tm.tm_isdst = -(1 as libc::c_int);
    rv = mktime(&mut tm);
    tmp___29 = strstr(str, b" GMT\0" as *const u8 as *const libc::c_char);
    if tmp___29.is_null() {
        tmp___30 = strstr(str, b" UTC\0" as *const u8 as *const libc::c_char);
        if tmp___30.is_null() {
            tmp___28 = __utc_offset();
            rv += (tmp___28 * 3600 as libc::c_int) as time_t;
        }
    }
    if rv == -(1 as libc::c_long) {
        return rv as libc::c_int;
    }
    now = time(0 as *mut libc::c_void as *mut time_t);
    if rv - now < 0 as libc::c_long {
        return 0 as libc::c_int;
    }
    return rv as libc::c_int;
}
unsafe extern "C" fn __mkmonth(
    mut s: *mut libc::c_char,
    mut ends: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut i: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    ptr = s;
    loop {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*ptr as libc::c_int as isize) as libc::c_int
            & 1024 as libc::c_int != 0
        {
            break;
        }
        ptr = ptr.offset(1);
    }
    if *ptr != 0 {
        *ends = ptr.offset(3 as libc::c_int as isize);
        i = 0 as libc::c_int;
        while i < 12 as libc::c_int {
            tmp___0 = strncasecmp(
                months[i as usize] as *const libc::c_char,
                ptr as *const libc::c_char,
                3 as libc::c_int as size_t,
            );
            if tmp___0 == 0 {
                return i;
            }
            i += 1;
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn new_cookies() -> COOKIES {
    let mut len: libc::c_int = 0;
    let mut this: COOKIES = 0 as *mut COOKIES_T;
    let mut name: [libc::c_char; 20] = [0; 20];
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    name[0 as libc::c_int as usize] = '/' as i32 as libc::c_char;
    name[1 as libc::c_int as usize] = '.' as i32 as libc::c_char;
    name[2 as libc::c_int as usize] = 's' as i32 as libc::c_char;
    name[3 as libc::c_int as usize] = 'i' as i32 as libc::c_char;
    name[4 as libc::c_int as usize] = 'e' as i32 as libc::c_char;
    name[5 as libc::c_int as usize] = 'g' as i32 as libc::c_char;
    name[6 as libc::c_int as usize] = 'e' as i32 as libc::c_char;
    name[7 as libc::c_int as usize] = '/' as i32 as libc::c_char;
    name[8 as libc::c_int as usize] = 'c' as i32 as libc::c_char;
    name[9 as libc::c_int as usize] = 'o' as i32 as libc::c_char;
    name[10 as libc::c_int as usize] = 'o' as i32 as libc::c_char;
    name[11 as libc::c_int as usize] = 'k' as i32 as libc::c_char;
    name[12 as libc::c_int as usize] = 'i' as i32 as libc::c_char;
    name[13 as libc::c_int as usize] = 'e' as i32 as libc::c_char;
    name[14 as libc::c_int as usize] = 's' as i32 as libc::c_char;
    name[15 as libc::c_int as usize] = '.' as i32 as libc::c_char;
    name[16 as libc::c_int as usize] = 't' as i32 as libc::c_char;
    name[17 as libc::c_int as usize] = 'x' as i32 as libc::c_char;
    name[18 as libc::c_int as usize] = 't' as i32 as libc::c_char;
    name[19 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = calloc(
        ::std::mem::size_of::<COOKIES_T>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    this = tmp as COOKIES;
    (*this).size = 0 as libc::c_int as size_t;
    tmp___0 = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    p = tmp___0;
    if !p.is_null() {
        tmp___1 = strlen(p as *const libc::c_char);
        len = tmp___1 as libc::c_int;
    } else {
        len = 60 as libc::c_int;
    }
    tmp___2 = strlen(name.as_mut_ptr() as *const libc::c_char);
    len = (len as size_t).wrapping_add(tmp___2.wrapping_add(1 as libc::c_ulong))
        as libc::c_int;
    tmp___3 = xmalloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            .wrapping_mul(len as libc::c_ulong),
    );
    (*this).file = tmp___3 as *mut libc::c_char;
    memset((*this).file as *mut libc::c_void, '\u{0}' as i32, len as size_t);
    tmp___4 = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    snprintf(
        (*this).file,
        len as size_t,
        b"%s%s\0" as *const u8 as *const libc::c_char,
        tmp___4,
        name.as_mut_ptr(),
    );
    return this;
}
pub unsafe extern "C" fn cookies_destroy(mut this: COOKIES) -> COOKIES {
    let mut cur: *mut NODE = 0 as *mut NODE;
    cur = 0 as *mut libc::c_void as *mut NODE;
    __save_cookies(this);
    cur = (*this).head;
    while !cur.is_null() {
        cur = __delete_node(cur);
    }
    xfree((*this).file as *mut libc::c_void);
    free(this as *mut libc::c_void);
    return 0 as *mut libc::c_void as COOKIES;
}
pub unsafe extern "C" fn cookies_add(
    mut this: COOKIES,
    mut str: *mut libc::c_char,
    mut host: *mut libc::c_char,
) -> BOOLEAN {
    let mut id: size_t = 0;
    let mut tmp: pthread_t = 0;
    let mut hlen: libc::c_int = 0;
    let mut dlen: libc::c_int = 0;
    let mut cur: *mut NODE = 0 as *mut NODE;
    let mut pre: *mut NODE = 0 as *mut NODE;
    let mut new: *mut NODE = 0 as *mut NODE;
    let mut found: BOOLEAN = boolean_false;
    let mut valid___0: BOOLEAN = boolean_false;
    let mut oreo: COOKIE = 0 as *mut COOKIE_T;
    let mut tmp___0: COOKIE = 0 as *mut COOKIE_T;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut domainptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = pthread_self();
    id = tmp;
    hlen = 0 as libc::c_int;
    dlen = 0 as libc::c_int;
    cur = 0 as *mut libc::c_void as *mut NODE;
    pre = 0 as *mut libc::c_void as *mut NODE;
    new = 0 as *mut libc::c_void as *mut NODE;
    found = boolean_false;
    valid___0 = boolean_false;
    tmp___0 = new_cookie(str, host);
    oreo = tmp___0;
    if oreo as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_false;
    }
    tmp___1 = cookie_get_name(oreo);
    if tmp___1 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_false
    } else {
        tmp___2 = cookie_get_value(oreo);
        if tmp___2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return boolean_false;
        }
    }
    pre = (*this).head;
    cur = pre;
    while cur as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___3 = cookie_get_domain((*cur).cookie);
        domainptr = tmp___3 as *const libc::c_char;
        if *domainptr as libc::c_int == 46 as libc::c_int {
            domainptr = domainptr.offset(1);
        }
        if !host.is_null() {
            tmp___4 = strlen(host as *const libc::c_char);
            hlen = tmp___4 as libc::c_int;
        } else {
            hlen = 0 as libc::c_int;
        }
        if !domainptr.is_null() {
            tmp___5 = strlen(domainptr);
            dlen = tmp___5 as libc::c_int;
        } else {
            dlen = 0 as libc::c_int;
        }
        tmp___6 = strcasecmp(host as *const libc::c_char, domainptr);
        if tmp___6 == 0 {
            valid___0 = boolean_true;
        }
        if valid___0 as u64 == 0 {
            if dlen < hlen {
                tmp___7 = strcasecmp(
                    host.offset((hlen - dlen) as isize) as *const libc::c_char,
                    domainptr,
                );
                if tmp___7 == 0 {
                    valid___0 = boolean_true;
                }
            }
        }
        if valid___0 as u64 != 0 {
            if (*cur).threadID == id {
                tmp___9 = cookie_get_name(oreo);
                tmp___10 = cookie_get_name((*cur).cookie);
                tmp___11 = strcasecmp(
                    tmp___10 as *const libc::c_char,
                    tmp___9 as *const libc::c_char,
                );
                if tmp___11 == 0 {
                    tmp___8 = cookie_get_value(oreo);
                    cookie_reset_value((*cur).cookie, tmp___8);
                    oreo = cookie_destroy(oreo);
                    found = boolean_true;
                    break;
                }
            }
        }
        pre = cur;
        cur = (*cur).next;
    }
    if found as u64 == 0 {
        tmp___12 = malloc(::std::mem::size_of::<NODE>() as libc::c_ulong);
        new = tmp___12 as *mut NODE;
        (*new).threadID = id;
        (*new).cookie = oreo;
        (*new).next = cur;
        if cur as libc::c_ulong == (*this).head as libc::c_ulong {
            (*this).head = new;
        } else {
            (*pre).next = new;
        }
    }
    return boolean_true;
}
pub unsafe extern "C" fn cookies_delete(
    mut this: COOKIES,
    mut str: *mut libc::c_char,
) -> BOOLEAN {
    let mut cur: *mut NODE = 0 as *mut NODE;
    let mut pre: *mut NODE = 0 as *mut NODE;
    let mut ret: BOOLEAN = boolean_false;
    let mut id: pthread_t = 0;
    let mut tmp: pthread_t = 0;
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    ret = boolean_false;
    tmp = pthread_self();
    id = tmp;
    pre = (*this).head;
    cur = pre;
    while cur as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*cur).threadID == id {
            tmp___0 = cookie_get_name((*cur).cookie);
            name = tmp___0;
            tmp___1 = strcasecmp(
                name as *const libc::c_char,
                str as *const libc::c_char,
            );
            if tmp___1 == 0 {
                (*cur).cookie = cookie_destroy((*cur).cookie);
                (*pre).next = (*cur).next;
                if cur as libc::c_ulong == (*this).head as libc::c_ulong {
                    (*this).head = (*cur).next;
                    pre = (*this).head;
                } else {
                    (*pre).next = (*cur).next;
                }
                ret = boolean_true;
                break;
            }
        }
        pre = cur;
        cur = (*cur).next;
    }
    return ret;
}
pub unsafe extern "C" fn cookies_delete_all(mut this: COOKIES) -> BOOLEAN {
    let mut cur: *mut NODE = 0 as *mut NODE;
    let mut pre: *mut NODE = 0 as *mut NODE;
    let mut id: pthread_t = 0;
    let mut tmp: pthread_t = 0;
    tmp = pthread_self();
    id = tmp;
    pre = (*this).head;
    cur = pre;
    while cur as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*cur).threadID == id {
            (*cur).cookie = cookie_destroy((*cur).cookie);
            (*pre).next = (*cur).next;
            if cur as libc::c_ulong == (*this).head as libc::c_ulong {
                (*this).head = (*cur).next;
                pre = (*this).head;
            } else {
                (*pre).next = (*cur).next;
            }
        }
        pre = cur;
        cur = (*cur).next;
    }
    return boolean_true;
}
pub unsafe extern "C" fn cookies_header(
    mut this: COOKIES,
    mut host: *mut libc::c_char,
    mut newton: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut current_block: u64;
    let mut dlen: libc::c_int = 0;
    let mut hlen: libc::c_int = 0;
    let mut pre: *mut NODE = 0 as *mut NODE;
    let mut cur: *mut NODE = 0 as *mut NODE;
    let mut tmp: time_t = 0;
    let mut now: time_t = 0;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut oreo: [libc::c_char; 81920] = [0; 81920];
    let mut id: size_t = 0;
    let mut tmp___0: pthread_t = 0;
    let mut tmp___1: size_t = 0;
    let mut domainptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: time_t = 0;
    let mut tmp___6: BOOLEAN = boolean_false;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: size_t = 0;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___16: time_t = 0;
    let mut tmp___17: BOOLEAN = boolean_false;
    let mut tmp___18: size_t = 0;
    let mut tmp___19: size_t = 0;
    let mut tmp___20: size_t = 0;
    let mut tmp___21: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___22: size_t = 0;
    let mut tmp___23: size_t = 0;
    let mut tmp___24: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: size_t = 0;
    tmp___0 = pthread_self();
    id = tmp___0;
    memset(
        oreo.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 81920]>() as libc::c_ulong,
    );
    tmp___1 = strlen(host as *const libc::c_char);
    hlen = tmp___1 as libc::c_int;
    tmp = time(0 as *mut libc::c_void as *mut time_t);
    gmtime_r(&mut tmp as *mut time_t as *const time_t, &mut tm as *mut tm);
    tm.tm_isdst = -(1 as libc::c_int);
    now = mktime(&mut tm);
    pre = (*this).head;
    cur = pre;
    while cur as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = cookie_get_domain((*cur).cookie);
        domainptr = tmp___2 as *const libc::c_char;
        if *domainptr as libc::c_int == 46 as libc::c_int {
            domainptr = domainptr.offset(1);
        }
        if !domainptr.is_null() {
            tmp___3 = strlen(domainptr);
            dlen = tmp___3 as libc::c_int;
        } else {
            dlen = 0 as libc::c_int;
        }
        if (*cur).threadID == id {
            tmp___14 = strcasecmp(domainptr, host as *const libc::c_char);
            if tmp___14 == 0 {
                tmp___5 = cookie_get_expires((*cur).cookie);
                if tmp___5 <= now {
                    tmp___6 = cookie_get_session((*cur).cookie);
                    if tmp___6 as libc::c_uint != 1 as libc::c_uint {
                        tmp___4 = cookie_get_name((*cur).cookie);
                        cookies_delete(this, tmp___4);
                        current_block = 9247403761687879134;
                    } else {
                        current_block = 8845338526596852646;
                    }
                } else {
                    current_block = 8845338526596852646;
                }
                match current_block {
                    9247403761687879134 => {}
                    _ => {
                        tmp___8 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                        if tmp___8 > 0 as libc::c_ulong {
                            tmp___7 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                            strncat(
                                oreo.as_mut_ptr(),
                                b";\0" as *const u8 as *const libc::c_char,
                                (::std::mem::size_of::<[libc::c_char; 81920]>()
                                    as libc::c_ulong)
                                    .wrapping_sub(10 as libc::c_ulong)
                                    .wrapping_sub(tmp___7),
                            );
                        }
                        tmp___9 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                        tmp___10 = cookie_get_name((*cur).cookie);
                        strncat(
                            oreo.as_mut_ptr(),
                            tmp___10 as *const libc::c_char,
                            (::std::mem::size_of::<[libc::c_char; 81920]>()
                                as libc::c_ulong)
                                .wrapping_sub(10 as libc::c_ulong)
                                .wrapping_sub(tmp___9),
                        );
                        tmp___11 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                        strncat(
                            oreo.as_mut_ptr(),
                            b"=\0" as *const u8 as *const libc::c_char,
                            (::std::mem::size_of::<[libc::c_char; 81920]>()
                                as libc::c_ulong)
                                .wrapping_sub(10 as libc::c_ulong)
                                .wrapping_sub(tmp___11),
                        );
                        tmp___12 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                        tmp___13 = cookie_get_value((*cur).cookie);
                        strncat(
                            oreo.as_mut_ptr(),
                            tmp___13 as *const libc::c_char,
                            (::std::mem::size_of::<[libc::c_char; 81920]>()
                                as libc::c_ulong)
                                .wrapping_sub(10 as libc::c_ulong)
                                .wrapping_sub(tmp___12),
                        );
                        current_block = 1345366029464561491;
                    }
                }
            } else {
                current_block = 1345366029464561491;
            }
            match current_block {
                9247403761687879134 => {}
                _ => {
                    if dlen < hlen {
                        tmp___25 = strcasecmp(
                            host.offset((hlen - dlen) as isize) as *const libc::c_char,
                            domainptr,
                        );
                        if tmp___25 == 0 {
                            tmp___16 = cookie_get_expires((*cur).cookie);
                            if tmp___16 <= now {
                                tmp___17 = cookie_get_session((*cur).cookie);
                                if tmp___17 as libc::c_uint != 1 as libc::c_uint {
                                    tmp___15 = cookie_get_name((*cur).cookie);
                                    cookies_delete(this, tmp___15);
                                    current_block = 9247403761687879134;
                                } else {
                                    current_block = 2290177392965769716;
                                }
                            } else {
                                current_block = 2290177392965769716;
                            }
                            match current_block {
                                9247403761687879134 => {}
                                _ => {
                                    tmp___19 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                                    if tmp___19 > 0 as libc::c_ulong {
                                        tmp___18 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                                        strncat(
                                            oreo.as_mut_ptr(),
                                            b";\0" as *const u8 as *const libc::c_char,
                                            (::std::mem::size_of::<[libc::c_char; 81920]>()
                                                as libc::c_ulong)
                                                .wrapping_sub(10 as libc::c_ulong)
                                                .wrapping_sub(tmp___18),
                                        );
                                    }
                                    tmp___20 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                                    tmp___21 = cookie_get_name((*cur).cookie);
                                    strncat(
                                        oreo.as_mut_ptr(),
                                        tmp___21 as *const libc::c_char,
                                        (::std::mem::size_of::<[libc::c_char; 81920]>()
                                            as libc::c_ulong)
                                            .wrapping_sub(10 as libc::c_ulong)
                                            .wrapping_sub(tmp___20),
                                    );
                                    tmp___22 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                                    strncat(
                                        oreo.as_mut_ptr(),
                                        b"=\0" as *const u8 as *const libc::c_char,
                                        (::std::mem::size_of::<[libc::c_char; 81920]>()
                                            as libc::c_ulong)
                                            .wrapping_sub(10 as libc::c_ulong)
                                            .wrapping_sub(tmp___22),
                                    );
                                    tmp___23 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
                                    tmp___24 = cookie_get_value((*cur).cookie);
                                    strncat(
                                        oreo.as_mut_ptr(),
                                        tmp___24 as *const libc::c_char,
                                        (::std::mem::size_of::<[libc::c_char; 81920]>()
                                            as libc::c_ulong)
                                            .wrapping_sub(10 as libc::c_ulong)
                                            .wrapping_sub(tmp___23),
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
        pre = cur;
        cur = (*cur).next;
    }
    tmp___26 = strlen(oreo.as_mut_ptr() as *const libc::c_char);
    if tmp___26 > 0 as libc::c_ulong {
        strncpy(
            newton,
            b"Cookie: \0" as *const u8 as *const libc::c_char,
            8 as libc::c_int as size_t,
        );
        strncat(
            newton,
            oreo.as_mut_ptr() as *const libc::c_char,
            4096 as libc::c_int as size_t,
        );
        strncat(
            newton,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int as size_t,
        );
    }
    return newton;
}
pub unsafe extern "C" fn cookies_list(mut this: COOKIES) {
    let mut cur: *mut NODE = 0 as *mut NODE;
    let mut pre: *mut NODE = 0 as *mut NODE;
    let mut tmp: COOKIE = 0 as *mut COOKIE_T;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    cur = 0 as *mut libc::c_void as *mut NODE;
    pre = 0 as *mut libc::c_void as *mut NODE;
    pre = (*this).head;
    cur = pre;
    while cur as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*cur).cookie;
        if !(tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            tmp___0 = cookie_expires_string(tmp);
            tmp___1 = cookie_get_value(tmp);
            tmp___2 = cookie_get_name(tmp);
            printf(
                b"%lld: NAME: %s\n   VALUE: %s\n   Expires: %s\n\0" as *const u8
                    as *const libc::c_char,
                (*cur).threadID as libc::c_longlong,
                tmp___2,
                tmp___1,
                tmp___0,
            );
        }
        pre = cur;
        cur = (*cur).next;
    }
}
unsafe extern "C" fn __delete_node(mut node: *mut NODE) -> *mut NODE {
    let mut tmp: *mut NODE = 0 as *mut NODE;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut NODE;
    }
    tmp = (*node).next;
    (*node).cookie = cookie_destroy((*node).cookie);
    free(node as *mut libc::c_void);
    node = tmp;
    return node;
}
unsafe extern "C" fn __strip(mut str: *mut libc::c_char) {
    let mut ch: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = strstr(str as *const libc::c_char, b"#\0" as *const u8 as *const libc::c_char);
    ch = tmp;
    if !ch.is_null() {
        *ch = '\u{0}' as i32 as libc::c_char;
    }
    tmp___0 = strstr(
        str as *const libc::c_char,
        b"\n\0" as *const u8 as *const libc::c_char,
    );
    ch = tmp___0;
    if !ch.is_null() {
        *ch = '\u{0}' as i32 as libc::c_char;
    }
}
pub unsafe extern "C" fn load_cookies(mut this: COOKIES) -> HASH {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut n: libc::c_int = 0;
    let mut HOH: HASH = 0 as *mut HASH_T;
    let mut IDX: HASH = 0 as *mut HASH_T;
    let mut len: size_t = 0;
    let mut tmp: BOOLEAN = boolean_false;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut num: libc::c_int = 0;
    let mut pair: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut tmp___1: [libc::c_char; 1024] = [0; 1024];
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: HASH = 0 as *mut HASH_T;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    n = -(1 as libc::c_int);
    len = 4096 as libc::c_int as size_t;
    let vla = len as usize;
    let mut line: Vec::<libc::c_char> = ::std::vec::from_elem(0, vla);
    tmp = __exists((*this).file);
    if tmp as u64 == 0 {
        return 0 as *mut libc::c_void as HASH;
    }
    fp = fopen(
        (*this).file as *const libc::c_char,
        b"r\0" as *const u8 as *const libc::c_char,
    );
    if fp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as HASH;
    }
    HOH = new_hash();
    IDX = new_hash();
    memset(line.as_mut_ptr() as *mut libc::c_void, '\u{0}' as i32, len);
    loop {
        tmp___8 = fgets(line.as_mut_ptr(), len as libc::c_int, fp);
        if !(tmp___8 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        tmp___0 = strchr(line.as_mut_ptr() as *const libc::c_char, '\n' as i32);
        p = tmp___0;
        if !p.is_null() {
            *p = '\u{0}' as i32 as libc::c_char;
        } else {
            i = fgetc(fp);
            if i != -(1 as libc::c_int) {
                loop {
                    i = fgetc(fp);
                    if !(i != -(1 as libc::c_int)) {
                        break;
                    }
                    if !(i != 10 as libc::c_int) {
                        break;
                    }
                }
                *line
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            }
        }
        __strip(line.as_mut_ptr());
        chomp(line.as_mut_ptr());
        tmp___7 = strlen(line.as_mut_ptr() as *const libc::c_char);
        if tmp___7 > 1 as libc::c_ulong {
            num = 2 as libc::c_int;
            pair = split('|' as i32 as libc::c_char, line.as_mut_ptr(), &mut num);
            trim(*pair.offset(0 as libc::c_int as isize));
            trim(*pair.offset(1 as libc::c_int as isize));
            if *pair.offset(0 as libc::c_int as isize) as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                if *pair.offset(1 as libc::c_int as isize) as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    tmp___2 = hash_get(IDX, *pair.offset(0 as libc::c_int as isize));
                    if tmp___2 as libc::c_ulong
                        == 0 as *mut libc::c_void as libc::c_ulong
                    {
                        n += 1;
                        memset(
                            tmp___1.as_mut_ptr() as *mut libc::c_void,
                            '\u{0}' as i32,
                            1024 as libc::c_int as size_t,
                        );
                        snprintf(
                            tmp___1.as_mut_ptr(),
                            1024 as libc::c_int as size_t,
                            b"%d\0" as *const u8 as *const libc::c_char,
                            n,
                        );
                        hash_add(
                            IDX,
                            *pair.offset(0 as libc::c_int as isize),
                            tmp___1.as_mut_ptr() as *mut libc::c_void,
                        );
                    }
                    tmp___4 = hash_get(IDX, *pair.offset(0 as libc::c_int as isize));
                    tmp___5 = hash_get(HOH, tmp___4 as *mut libc::c_char);
                    tmp___3 = tmp___5 as HASH;
                    if tmp___3 as libc::c_ulong
                        == 0 as *mut libc::c_void as libc::c_ulong
                    {
                        tmp___3 = new_hash();
                        hash_add(
                            tmp___3,
                            *pair.offset(1 as libc::c_int as isize),
                            *pair.offset(1 as libc::c_int as isize) as *mut libc::c_void,
                        );
                        tmp___6 = hash_get(IDX, *pair.offset(0 as libc::c_int as isize));
                        hash_nadd(
                            HOH,
                            tmp___6 as *mut libc::c_char,
                            tmp___3 as *mut libc::c_void,
                            HASHSIZE,
                        );
                    } else {
                        hash_add(
                            tmp___3,
                            *pair.offset(1 as libc::c_int as isize),
                            *pair.offset(1 as libc::c_int as isize) as *mut libc::c_void,
                        );
                    }
                }
            }
            split_free(pair, num);
        }
        memset(line.as_mut_ptr() as *mut libc::c_void, '\u{0}' as i32, len);
    }
    fclose(fp);
    hash_destroy(IDX);
    return HOH;
}
unsafe extern "C" fn __save_cookies(mut this: COOKIES) -> BOOLEAN {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut line: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut now: time_t = 0;
    let mut cur: *mut NODE = 0 as *mut NODE;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: COOKIE = 0 as *mut COOKIE_T;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: BOOLEAN = boolean_false;
    let mut tmp___4: time_t = 0;
    len = 4120 as libc::c_int as size_t;
    cur = 0 as *mut libc::c_void as *mut NODE;
    now = time(0 as *mut libc::c_void as *mut time_t);
    fp = fopen(
        (*this).file as *const libc::c_char,
        b"w\0" as *const u8 as *const libc::c_char,
    );
    if fp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        fprintf(
            stderr,
            b"ERROR: Unable to open cookies file: %s\n\0" as *const u8
                as *const libc::c_char,
            (*this).file,
        );
        return boolean_false;
    }
    fputs(b"#\n\0" as *const u8 as *const libc::c_char, fp);
    fputs(
        b"# Siege cookies file. You may edit this file to add cookies\n\0" as *const u8
            as *const libc::c_char,
        fp,
    );
    fputs(
        b"# manually but comments and formatting will be removed.    \n\0" as *const u8
            as *const libc::c_char,
        fp,
    );
    fputs(
        b"# All cookies that expire in the future will be preserved. \n\0" as *const u8
            as *const libc::c_char,
        fp,
    );
    fputs(
        b"# ---------------------------------------------------------\n\0" as *const u8
            as *const libc::c_char,
        fp,
    );
    tmp = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong).wrapping_mul(len),
    );
    line = tmp as *mut libc::c_char;
    cur = (*this).head;
    while cur as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = (*cur).cookie;
        if tmp___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = cookie_get_session(tmp___0);
            if tmp___3 as libc::c_uint != 1 as libc::c_uint {
                tmp___4 = cookie_get_expires((*cur).cookie);
                if tmp___4 >= now {
                    memset(line as *mut libc::c_void, '\u{0}' as i32, len);
                    tmp___2 = cookie_to_string(tmp___0);
                    if tmp___2 as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        tmp___1 = cookie_to_string(tmp___0);
                        snprintf(
                            line,
                            len,
                            b"%ld | %s\n\0" as *const u8 as *const libc::c_char,
                            (*cur).threadID,
                            tmp___1,
                        );
                    }
                    fputs(line as *const libc::c_char, fp);
                }
            }
        }
        cur = (*cur).next;
    }
    free(line as *mut libc::c_void);
    fclose(fp);
    return boolean_true;
}
unsafe extern "C" fn __exists(mut file: *mut libc::c_char) -> BOOLEAN {
    let mut fd: libc::c_int = 0;
    fd = open(file as *const libc::c_char, 0 as libc::c_int);
    if fd < 0 as libc::c_int {
        return boolean_false
    } else {
        close(fd);
        return boolean_true;
    };
}
pub unsafe extern "C" fn parse(mut str: *mut libc::c_char) {
    let mut ch: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sl: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    str = trim(str);
    if *str.offset(0 as libc::c_int as isize) as libc::c_int == 35 as libc::c_int {
        *str.offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    }
    sp = strchr(str as *const libc::c_char, ' ' as i32);
    sl = strchr(str as *const libc::c_char, '/' as i32);
    if sl as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if sp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp = strstr(
                str as *const libc::c_char,
                b"#\0" as *const u8 as *const libc::c_char,
            );
            ch = tmp;
            if !ch.is_null() {
                *ch = '\u{0}' as i32 as libc::c_char;
            }
        }
    }
    tmp___0 = strstr(
        str as *const libc::c_char,
        b"\n\0" as *const u8 as *const libc::c_char,
    );
    ch = tmp___0;
    if !ch.is_null() {
        *ch = '\u{0}' as i32 as libc::c_char;
    }
    trim(str);
}
pub unsafe extern "C" fn count(
    mut s: *mut libc::c_char,
    mut c: libc::c_char,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if *s as libc::c_int == 0 as libc::c_int {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp = count(s.offset(1 as libc::c_int as isize), c);
        tmp___0 = tmp + (*s as libc::c_int == c as libc::c_int) as libc::c_int;
    }
    return tmp___0;
}
pub unsafe extern "C" fn read_cfg_file(
    mut l: *mut LINES,
    mut filename: *mut libc::c_char,
) -> libc::c_int {
    let mut file: *mut FILE = 0 as *mut FILE;
    let mut H: HASH = 0 as *mut HASH_T;
    let mut line: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut option: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut num: libc::c_int = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut r: libc::c_int = 0;
    let mut cnt: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: BOOLEAN = boolean_false;
    let mut tmp___14: size_t = 0;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    if l.is_null() {
        printf(b"Structure not initialized!\n\0" as *const u8 as *const libc::c_char);
        return -(1 as libc::c_int);
    }
    file = fopen(
        filename as *const libc::c_char,
        b"r\0" as *const u8 as *const libc::c_char,
    );
    if file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            WARNING,
            b"unable to open file: %s\0" as *const u8 as *const libc::c_char,
            filename,
        );
        display_help();
        exit(1 as libc::c_int);
    }
    tmp = xmalloc(40000 as libc::c_int as size_t);
    line = tmp as *mut libc::c_char;
    memset(line as *mut libc::c_void, '\u{0}' as i32, 40000 as libc::c_int as size_t);
    H = new_hash();
    (*l).index = 0 as libc::c_int;
    loop {
        tmp___15 = fgets(line, 40000 as libc::c_int, file);
        if !(tmp___15 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        tmp___0 = strchr(line as *const libc::c_char, '\n' as i32);
        p = tmp___0;
        if !p.is_null() {
            *p = '\u{0}' as i32 as libc::c_char;
        } else {
            num = fgetc(file);
            if num != -(1 as libc::c_int) {
                loop {
                    num = fgetc(file);
                    if !(num != -(1 as libc::c_int)) {
                        break;
                    }
                    if !(num != 10 as libc::c_int) {
                        break;
                    }
                }
                *line.offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            }
        }
        parse(line);
        chomp(line);
        tmp___14 = strlen(line as *const libc::c_char);
        if !(tmp___14 == 0 as libc::c_ulong) {
            tmp___13 = is_variable_line(line);
            if tmp___13 as u64 != 0 {
                tmp___1 = line;
                option = tmp___1;
                while *tmp___1 != 0 {
                    tmp___2 = __ctype_b_loc();
                    if *(*tmp___2)
                        .offset(
                            *tmp___1 as libc::c_int as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int & 8192 as libc::c_int != 0
                    {
                        break;
                    }
                    if 61 as libc::c_int == *tmp___1 as libc::c_int {
                        break;
                    }
                    if 58 as libc::c_int == *tmp___1 as libc::c_int {
                        break;
                    }
                    tmp___1 = tmp___1.offset(1);
                }
                tmp___3 = tmp___1;
                tmp___1 = tmp___1.offset(1);
                *tmp___3 = 0 as libc::c_int as libc::c_char;
                loop {
                    tmp___4 = __ctype_b_loc();
                    if *(*tmp___4)
                        .offset(
                            *tmp___1 as libc::c_int as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int & 8192 as libc::c_int == 0
                    {
                        if !(61 as libc::c_int == *tmp___1 as libc::c_int) {
                            if !(58 as libc::c_int == *tmp___1 as libc::c_int) {
                                break;
                            }
                        }
                    }
                    tmp___1 = tmp___1.offset(1);
                }
                value = tmp___1;
                while *tmp___1 != 0 {
                    tmp___1 = tmp___1.offset(1);
                }
                tmp___5 = tmp___1;
                tmp___1 = tmp___1.offset(1);
                *tmp___5 = 0 as libc::c_int as libc::c_char;
                hash_add(H, option, value as *mut libc::c_void);
            } else {
                tmp___7 = xstrdup(line as *const libc::c_char);
                tmp___6 = tmp___7;
                r = 0 as libc::c_int;
                cnt = 0 as libc::c_int;
                tmp___8 = count(tmp___6, '$' as i32 as libc::c_char);
                cnt += tmp___8;
                loop {
                    tmp___10 = strstr(
                        tmp___6 as *const libc::c_char,
                        b"$\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___10.is_null() {
                        break;
                    }
                    tmp___9 = strstr(
                        tmp___6 as *const libc::c_char,
                        b"\\$\0" as *const u8 as *const libc::c_char,
                    );
                    if !tmp___9.is_null() {
                        tmp___6 = escape(tmp___6);
                    } else {
                        tmp___6 = evaluate(H, tmp___6);
                    }
                    r += 1;
                    if r == cnt {
                        break;
                    }
                }
                tmp___11 = realloc(
                    (*l).line as *mut libc::c_void,
                    (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                        .wrapping_mul(((*l).index + 1 as libc::c_int) as libc::c_ulong),
                );
                (*l).line = tmp___11 as *mut *mut libc::c_char;
                tmp___12 = strdup(tmp___6 as *const libc::c_char);
                let ref mut fresh3 = *((*l).line).offset((*l).index as isize);
                *fresh3 = tmp___12;
                (*l).index += 1;
                free(tmp___6 as *mut libc::c_void);
            }
        }
        memset(
            line as *mut libc::c_void,
            0 as libc::c_int,
            40000 as libc::c_int as size_t,
        );
    }
    fclose(file);
    xfree(line as *mut libc::c_void);
    hash_destroy(H);
    return (*l).index;
}
pub unsafe extern "C" fn read_cmd_line(
    mut l: *mut LINES,
    mut url: *mut libc::c_char,
) -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut head: [libc::c_char; 40000] = [0; 40000];
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    x = 0 as libc::c_int;
    if l.is_null() {
        printf(b"Structure not initialized!\n\0" as *const u8 as *const libc::c_char);
        return -(1 as libc::c_int);
    }
    (*l).index = 0 as libc::c_int;
    while x < 4 as libc::c_int {
        snprintf(
            head.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 40000]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            url,
        );
        parse(head.as_mut_ptr());
        chomp(head.as_mut_ptr());
        tmp___1 = strlen(head.as_mut_ptr() as *const libc::c_char);
        if !(tmp___1 == 0 as libc::c_ulong) {
            tmp = realloc(
                (*l).line as *mut libc::c_void,
                (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                    .wrapping_mul(((*l).index + 1 as libc::c_int) as libc::c_ulong),
            );
            (*l).line = tmp as *mut *mut libc::c_char;
            tmp___0 = strdup(head.as_mut_ptr() as *const libc::c_char);
            let ref mut fresh4 = *((*l).line).offset((*l).index as isize);
            *fresh4 = tmp___0;
            (*l).index += 1;
        }
        x += 1;
    }
    return (*l).index;
}
pub unsafe extern "C" fn is_variable_line(mut line: *mut libc::c_char) -> BOOLEAN {
    let mut pos___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut x: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut c: libc::c_char = 0;
    pos___0 = strstr(
        line as *const libc::c_char,
        b"=\0" as *const u8 as *const libc::c_char,
    );
    if pos___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        x = line;
        while (x as libc::c_ulong) < pos___0 as libc::c_ulong {
            c = *x;
            let mut current_block_7: u64;
            if (c as libc::c_int) < 97 as libc::c_int {
                current_block_7 = 9324245760887984334;
            } else if c as libc::c_int > 122 as libc::c_int {
                current_block_7 = 9324245760887984334;
            } else {
                current_block_7 = 15976848397966268834;
            }
            match current_block_7 {
                9324245760887984334 => {
                    let mut current_block_6: u64;
                    if (c as libc::c_int) < 65 as libc::c_int {
                        current_block_6 = 9524016524212660055;
                    } else if c as libc::c_int > 90 as libc::c_int {
                        current_block_6 = 9524016524212660055;
                    } else {
                        current_block_6 = 7976072742316086414;
                    }
                    match current_block_6 {
                        9524016524212660055 => {
                            let mut current_block_5: u64;
                            if (c as libc::c_int) < 48 as libc::c_int {
                                current_block_5 = 5398758646876306677;
                            } else if c as libc::c_int > 57 as libc::c_int {
                                current_block_5 = 5398758646876306677;
                            } else {
                                current_block_5 = 12800627514080957624;
                            }
                            match current_block_5 {
                                5398758646876306677 => {
                                    if c as libc::c_int != 95 as libc::c_int {
                                        return boolean_false;
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            x = x.offset(1);
        }
    } else {
        return boolean_false
    }
    return boolean_true;
}
pub static mut CREDSIZE: size_t = ::std::mem::size_of::<CREDS_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_creds(
    mut scheme: SCHEME,
    mut str: *mut libc::c_char,
) -> CREDS {
    let mut this: CREDS = 0 as *mut CREDS_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        ::std::mem::size_of::<CREDS_T>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    this = tmp as CREDS;
    (*this).scheme = scheme;
    (*this).username = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).password = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).realm = 0 as *mut libc::c_void as *mut libc::c_char;
    __parse_input___0(this, str);
    return this;
}
pub unsafe extern "C" fn creds_destroy(mut this: CREDS) -> CREDS {
    xfree((*this).username as *mut libc::c_void);
    xfree((*this).password as *mut libc::c_void);
    xfree((*this).realm as *mut libc::c_void);
    xfree(this as *mut libc::c_void);
    return 0 as *mut libc::c_void as CREDS;
}
pub unsafe extern "C" fn creds_get_scheme(mut this: CREDS) -> SCHEME {
    return (*this).scheme;
}
pub unsafe extern "C" fn creds_get_username(mut this: CREDS) -> *mut libc::c_char {
    return (*this).username;
}
pub unsafe extern "C" fn creds_get_password(mut this: CREDS) -> *mut libc::c_char {
    return (*this).password;
}
pub unsafe extern "C" fn creds_get_realm(mut this: CREDS) -> *mut libc::c_char {
    return (*this).realm;
}
pub unsafe extern "C" fn creds_set_username(
    mut this: CREDS,
    mut username: *mut libc::c_char,
) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(username as *const libc::c_char);
    len = tmp;
    tmp___0 = malloc(len.wrapping_add(1 as libc::c_ulong));
    (*this).username = tmp___0 as *mut libc::c_char;
    memset(
        (*this).username as *mut libc::c_void,
        '\u{0}' as i32,
        len.wrapping_add(1 as libc::c_ulong),
    );
    memcpy((*this).username as *mut libc::c_void, username as *const libc::c_void, len);
}
pub unsafe extern "C" fn creds_set_password(
    mut this: CREDS,
    mut password: *mut libc::c_char,
) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(password as *const libc::c_char);
    len = tmp;
    tmp___0 = malloc(len.wrapping_add(1 as libc::c_ulong));
    (*this).password = tmp___0 as *mut libc::c_char;
    memset(
        (*this).password as *mut libc::c_void,
        '\u{0}' as i32,
        len.wrapping_add(1 as libc::c_ulong),
    );
    memcpy((*this).password as *mut libc::c_void, password as *const libc::c_void, len);
}
pub unsafe extern "C" fn creds_set_realm(mut this: CREDS, mut realm: *mut libc::c_char) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(realm as *const libc::c_char);
    len = tmp;
    tmp___0 = malloc(len.wrapping_add(1 as libc::c_ulong));
    (*this).realm = tmp___0 as *mut libc::c_char;
    memset(
        (*this).realm as *mut libc::c_void,
        '\u{0}' as i32,
        len.wrapping_add(1 as libc::c_ulong),
    );
    memcpy((*this).realm as *mut libc::c_void, realm as *const libc::c_void, len);
}
unsafe extern "C" fn __parse_input___0(mut this: CREDS, mut str: *mut libc::c_char) {
    let mut usr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pwd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rlm: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut any: [libc::c_char; 5] = [0; 5];
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    any[0 as libc::c_int as usize] = 'a' as i32 as libc::c_char;
    any[1 as libc::c_int as usize] = 'n' as i32 as libc::c_char;
    any[2 as libc::c_int as usize] = 'y' as i32 as libc::c_char;
    any[3 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    any[4 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = str;
    usr = tmp;
    while *tmp != 0 {
        if !(*tmp as libc::c_int != 58 as libc::c_int) {
            break;
        }
        if !(*tmp as libc::c_int != 0 as libc::c_int) {
            break;
        }
        tmp = tmp.offset(1);
    }
    tmp___0 = tmp;
    tmp = tmp.offset(1);
    *tmp___0 = 0 as libc::c_int as libc::c_char;
    pwd = tmp;
    while *tmp != 0 {
        if !(*tmp as libc::c_int != 58 as libc::c_int) {
            break;
        }
        if !(*tmp as libc::c_int != 0 as libc::c_int) {
            break;
        }
        tmp = tmp.offset(1);
    }
    if 0 as libc::c_int != *tmp as libc::c_int {
        tmp___1 = tmp;
        tmp = tmp.offset(1);
        *tmp___1 = 0 as libc::c_int as libc::c_char;
        rlm = tmp;
    } else {
        rlm = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    creds_set_username(this, usr);
    creds_set_password(this, pwd);
    if rlm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = any.as_mut_ptr();
    } else {
        tmp___2 = rlm;
    }
    creds_set_realm(this, tmp___2);
}
pub unsafe extern "C" fn new_crew(
    mut size: libc::c_int,
    mut maxsize: libc::c_int,
    mut block: BOOLEAN,
) -> CREW {
    let mut x: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut this: CREW = 0 as *mut CREW_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut pthread_t = 0 as *mut pthread_t;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    tmp = calloc(
        ::std::mem::size_of::<CREW_T>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    this = tmp as CREW;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as CREW;
    }
    tmp___1 = malloc(
        (::std::mem::size_of::<pthread_t>() as libc::c_ulong)
            .wrapping_mul(size as libc::c_ulong),
    );
    tmp___0 = tmp___1 as *mut pthread_t;
    (*this).threads = tmp___0;
    if tmp___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as CREW;
    }
    (*this).size = size;
    (*this).maxsize = maxsize;
    (*this).cursize = 0 as libc::c_int;
    (*this).total = 0 as libc::c_int;
    (*this).block = block;
    (*this).head = 0 as *mut libc::c_void as *mut WORK;
    (*this).tail = 0 as *mut libc::c_void as *mut WORK;
    (*this).closed = boolean_false;
    (*this).shutdown = boolean_false;
    c = pthread_mutex_init(
        &mut (*this).lock,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    if c != 0 as libc::c_int {
        return 0 as *mut libc::c_void as CREW;
    }
    c = pthread_cond_init(
        &mut (*this).not_empty as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    if c != 0 as libc::c_int {
        return 0 as *mut libc::c_void as CREW;
    }
    c = pthread_cond_init(
        &mut (*this).not_full as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    if c != 0 as libc::c_int {
        return 0 as *mut libc::c_void as CREW;
    }
    c = pthread_cond_init(
        &mut (*this).empty as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    if c != 0 as libc::c_int {
        return 0 as *mut libc::c_void as CREW;
    }
    x = 0 as libc::c_int;
    while x != size {
        c = pthread_create(
            ((*this).threads).offset(x as isize),
            0 as *mut libc::c_void as *const pthread_attr_t,
            Some(
                crew_thread
                    as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
            ),
            this as *mut libc::c_void,
        );
        if c != 0 as libc::c_int {
            tmp___2 = __errno_location();
            match *tmp___2 {
                22 => {
                    NOTIFY(
                        ERROR,
                        b"Error creating additional threads %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"crew.c\0" as *const u8 as *const libc::c_char,
                        86 as libc::c_int,
                    );
                }
                1 => {
                    NOTIFY(
                        ERROR,
                        b"Inadequate permission to create pool %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"crew.c\0" as *const u8 as *const libc::c_char,
                        87 as libc::c_int,
                    );
                }
                11 => {
                    NOTIFY(
                        ERROR,
                        b"Inadequate resources to create pool %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"crew.c\0" as *const u8 as *const libc::c_char,
                        88 as libc::c_int,
                    );
                }
                12 => {
                    NOTIFY(
                        ERROR,
                        b"Exceeded thread limit for this system %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"crew.c\0" as *const u8 as *const libc::c_char,
                        89 as libc::c_int,
                    );
                }
                _ => {
                    NOTIFY(
                        ERROR,
                        b"Unknown error building thread pool %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"crew.c\0" as *const u8 as *const libc::c_char,
                        90 as libc::c_int,
                    );
                }
            }
            return 0 as *mut libc::c_void as CREW;
        }
        x += 1;
    }
    return this;
}
unsafe extern "C" fn crew_thread(mut crew: *mut libc::c_void) -> *mut libc::c_void {
    let mut c: libc::c_int = 0;
    let mut workptr: *mut WORK = 0 as *mut WORK;
    let mut this: CREW = 0 as *mut CREW_T;
    let mut tmp: *mut WORK = 0 as *mut WORK;
    this = crew as CREW;
    loop {
        c = pthread_mutex_lock(&mut (*this).lock);
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"mutex lock\0" as *const u8 as *const libc::c_char);
        }
        while (*this).cursize == 0 as libc::c_int {
            if (*this).shutdown as u64 != 0 {
                break;
            }
            c = pthread_cond_wait(
                &mut (*this).not_empty as *mut pthread_cond_t,
                &mut (*this).lock as *mut pthread_mutex_t,
            );
            if c != 0 as libc::c_int {
                NOTIFY(FATAL, b"pthread wait\0" as *const u8 as *const libc::c_char);
            }
        }
        if (*this).shutdown as libc::c_uint == 1 as libc::c_uint {
            c = pthread_mutex_unlock(&mut (*this).lock);
            if c != 0 as libc::c_int {
                NOTIFY(FATAL, b"mutex unlock\0" as *const u8 as *const libc::c_char);
            }
            pthread_exit(0 as *mut libc::c_void);
        }
        workptr = (*this).head;
        (*this).cursize -= 1;
        if (*this).cursize == 0 as libc::c_int {
            tmp = 0 as *mut libc::c_void as *mut WORK;
            (*this).tail = tmp;
            (*this).head = tmp;
        } else {
            (*this).head = (*workptr).next;
        }
        if (*this).block as u64 != 0 {
            if (*this).cursize == (*this).maxsize - 1 as libc::c_int {
                c = pthread_cond_broadcast(&mut (*this).not_full);
                if c != 0 as libc::c_int {
                    NOTIFY(
                        FATAL,
                        b"pthread broadcast\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        }
        if (*this).cursize == 0 as libc::c_int {
            c = pthread_cond_signal(&mut (*this).empty);
            if c != 0 as libc::c_int {
                NOTIFY(FATAL, b"pthread signal\0" as *const u8 as *const libc::c_char);
            }
        }
        c = pthread_mutex_unlock(&mut (*this).lock);
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"pthread unlock\0" as *const u8 as *const libc::c_char);
        }
        ::std::mem::transmute::<
            _,
            fn(_),
        >(
            (Some(((*workptr).routine).expect("non-null function pointer")))
                .expect("non-null function pointer"),
        )((*workptr).arg);
        xfree(workptr as *mut libc::c_void);
    };
}
pub unsafe extern "C" fn crew_add(
    mut crew: CREW,
    mut routine: Option::<unsafe extern "C" fn() -> ()>,
    mut arg: *mut libc::c_void,
) -> BOOLEAN {
    let mut c: libc::c_int = 0;
    let mut workptr: *mut WORK = 0 as *mut WORK;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut WORK = 0 as *mut WORK;
    c = pthread_mutex_lock(&mut (*crew).lock);
    if c != 0 as libc::c_int {
        NOTIFY(FATAL, b"pthread lock\0" as *const u8 as *const libc::c_char);
    }
    if (*crew).cursize == (*crew).maxsize {
        if (*crew).block as u64 == 0 {
            c = pthread_mutex_unlock(&mut (*crew).lock);
            if c != 0 as libc::c_int {
                NOTIFY(FATAL, b"pthread unlock\0" as *const u8 as *const libc::c_char);
            }
            return boolean_false;
        }
    }
    while (*crew).cursize == (*crew).maxsize {
        if (*crew).shutdown as u64 != 0 {
            break;
        }
        if (*crew).closed as u64 != 0 {
            break;
        }
        c = pthread_cond_wait(
            &mut (*crew).not_full as *mut pthread_cond_t,
            &mut (*crew).lock as *mut pthread_mutex_t,
        );
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"pthread wait\0" as *const u8 as *const libc::c_char);
        }
    }
    's_141: {
        if !((*crew).shutdown as u64 != 0) {
            if !((*crew).closed as u64 != 0) {
                break 's_141;
            }
        }
        c = pthread_mutex_unlock(&mut (*crew).lock);
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"pthread unlock\0" as *const u8 as *const libc::c_char);
        }
        return boolean_false;
    }
    tmp = malloc(::std::mem::size_of::<WORK>() as libc::c_ulong);
    workptr = tmp as *mut WORK;
    if workptr as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(FATAL, b"out of memory\0" as *const u8 as *const libc::c_char);
    }
    (*workptr).routine = routine;
    (*workptr).arg = arg;
    (*workptr).next = 0 as *mut libc::c_void as *mut work;
    if (*crew).cursize == 0 as libc::c_int {
        tmp___0 = workptr;
        (*crew).head = tmp___0;
        (*crew).tail = tmp___0;
        c = pthread_cond_broadcast(&mut (*crew).not_empty);
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"pthread signal\0" as *const u8 as *const libc::c_char);
        }
    } else {
        (*(*crew).tail).next = workptr;
        (*crew).tail = workptr;
    }
    (*crew).cursize += 1;
    (*crew).total += 1;
    c = pthread_mutex_unlock(&mut (*crew).lock);
    if c != 0 as libc::c_int {
        NOTIFY(FATAL, b"pthread unlock\0" as *const u8 as *const libc::c_char);
    }
    return boolean_true;
}
pub unsafe extern "C" fn crew_cancel(mut this: CREW) -> BOOLEAN {
    let mut x: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    size = (*this).size;
    crew_set_shutdown(this, boolean_true);
    x = 0 as libc::c_int;
    while x < size {
        pthread_cancel(*((*this).threads).offset(x as isize));
        x += 1;
    }
    return boolean_true;
}
pub unsafe extern "C" fn crew_join(
    mut crew: CREW,
    mut finish: BOOLEAN,
    mut payload: *mut *mut libc::c_void,
) -> BOOLEAN {
    let mut x: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut ts: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut tp: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    c = pthread_mutex_lock(&mut (*crew).lock);
    if c != 0 as libc::c_int {
        NOTIFY(FATAL, b"pthread lock\0" as *const u8 as *const libc::c_char);
    }
    's_59: {
        if !((*crew).closed as u64 != 0) {
            if !((*crew).shutdown as u64 != 0) {
                break 's_59;
            }
        }
        c = pthread_mutex_unlock(&mut (*crew).lock);
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"pthread unlock\0" as *const u8 as *const libc::c_char);
        }
        return boolean_false;
    }
    (*crew).closed = boolean_true;
    if finish as libc::c_uint == 1 as libc::c_uint {
        while (*crew).cursize != 0 as libc::c_int {
            if (*crew).shutdown as u64 != 0 {
                break;
            }
            rc = gettimeofday(&mut tp as *mut timeval, 0 as *mut libc::c_void);
            if rc != 0 as libc::c_int {
                perror(b"gettimeofday\0" as *const u8 as *const libc::c_char);
            }
            ts.tv_sec = tp.tv_sec + 60 as libc::c_long;
            ts.tv_nsec = tp.tv_usec * 1000 as libc::c_long;
            rc = pthread_cond_timedwait(
                &mut (*crew).empty as *mut pthread_cond_t,
                &mut (*crew).lock as *mut pthread_mutex_t,
                &mut ts as *mut timespec as *const timespec,
            );
            if rc == 110 as libc::c_int {
                pthread_mutex_unlock(&mut (*crew).lock);
            }
            if rc != 0 as libc::c_int {
                NOTIFY(FATAL, b"pthread wait\0" as *const u8 as *const libc::c_char);
            }
        }
    }
    (*crew).shutdown = boolean_true;
    c = pthread_mutex_unlock(&mut (*crew).lock);
    if c != 0 as libc::c_int {
        NOTIFY(FATAL, b"pthread_mutex_unlock\0" as *const u8 as *const libc::c_char);
    }
    c = pthread_cond_broadcast(&mut (*crew).not_empty);
    if c != 0 as libc::c_int {
        NOTIFY(FATAL, b"pthread broadcast\0" as *const u8 as *const libc::c_char);
    }
    c = pthread_cond_broadcast(&mut (*crew).not_full);
    if c != 0 as libc::c_int {
        NOTIFY(FATAL, b"pthread broadcast\0" as *const u8 as *const libc::c_char);
    }
    x = 0 as libc::c_int;
    while x < (*crew).size {
        c = pthread_join(*((*crew).threads).offset(x as isize), payload);
        if c != 0 as libc::c_int {
            NOTIFY(FATAL, b"pthread_join\0" as *const u8 as *const libc::c_char);
        }
        x += 1;
    }
    return boolean_true;
}
pub unsafe extern "C" fn crew_destroy(mut crew: CREW) {
    let mut workptr: *mut WORK = 0 as *mut WORK;
    xfree((*crew).threads as *mut libc::c_void);
    while (*crew).head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        workptr = (*crew).head;
        (*crew).head = (*(*crew).head).next;
        xfree(workptr as *mut libc::c_void);
    }
    xfree(crew as *mut libc::c_void);
}
pub unsafe extern "C" fn crew_set_shutdown(mut this: CREW, mut shutdown___0: BOOLEAN) {
    (*this).shutdown = shutdown___0;
    pthread_cond_broadcast(&mut (*this).not_empty);
    pthread_cond_broadcast(&mut (*this).not_full);
    pthread_cond_broadcast(&mut (*this).empty);
}
pub unsafe extern "C" fn crew_get_size(mut this: CREW) -> libc::c_int {
    return (*this).size;
}
pub unsafe extern "C" fn crew_get_total(mut this: CREW) -> libc::c_int {
    return (*this).total;
}
pub unsafe extern "C" fn crew_get_shutdown(mut this: CREW) -> BOOLEAN {
    return (*this).shutdown;
}
pub unsafe extern "C" fn new_data() -> DATA {
    let mut this: DATA = 0 as *mut DATA_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        ::std::mem::size_of::<DATA_T>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    );
    this = tmp as DATA;
    (*this).total = 0.0f64 as libc::c_float;
    (*this).available = 0.0f64 as libc::c_float;
    (*this).count = 0.0f64 as libc::c_uint;
    (*this).okay = 0 as libc::c_uint;
    (*this).fail = 0.0f64 as libc::c_uint;
    (*this).lowest = -(1 as libc::c_int) as libc::c_float;
    (*this).highest = 0.0f64 as libc::c_float;
    (*this).elapsed = 0.0f64 as libc::c_float;
    (*this).bytes = 0.0f64 as libc::c_ulonglong;
    return this;
}
pub unsafe extern "C" fn data_destroy(mut this: DATA) -> DATA {
    xfree(this as *mut libc::c_void);
    return 0 as *mut libc::c_void as DATA;
}
pub unsafe extern "C" fn data_increment_bytes(mut this: DATA, mut bytes: libc::c_ulong) {
    (*this).bytes = ((*this).bytes).wrapping_add(bytes as libc::c_ulonglong);
}
pub unsafe extern "C" fn data_increment_count(
    mut this: DATA,
    mut count___0: libc::c_ulong,
) {
    (*this)
        .count = ((*this).count as libc::c_ulong).wrapping_add(count___0)
        as libc::c_uint;
}
pub unsafe extern "C" fn data_increment_total(mut this: DATA, mut total: libc::c_float) {
    (*this).total += total;
}
pub unsafe extern "C" fn data_increment_code(mut this: DATA, mut code: libc::c_int) {
    (*this).code = ((*this).code).wrapping_add(code as libc::c_uint);
}
pub unsafe extern "C" fn data_increment_fail(mut this: DATA, mut fail: libc::c_int) {
    (*this).fail = ((*this).fail).wrapping_add(fail as libc::c_uint);
}
pub unsafe extern "C" fn data_increment_okay(mut this: DATA, mut okay___0: libc::c_int) {
    (*this).okay = ((*this).okay).wrapping_add(okay___0 as libc::c_uint);
}
pub unsafe extern "C" fn data_set_start(mut this: DATA) {
    (*this).start = times(&mut (*this).t_start);
}
pub unsafe extern "C" fn data_set_stop(mut this: DATA) {
    (*this).stop = times(&mut (*this).t_stop);
}
pub unsafe extern "C" fn data_set_highest(mut this: DATA, mut highest: libc::c_float) {
    if (*this).highest < highest {
        (*this).highest = highest;
    }
}
pub unsafe extern "C" fn data_set_lowest(mut this: DATA, mut lowest: libc::c_float) {
    if (*this).lowest <= 0 as libc::c_int as libc::c_float {
        (*this).lowest = lowest;
    } else if (*this).lowest > lowest {
        (*this).lowest = lowest;
    }
}
pub unsafe extern "C" fn data_get_count(mut this: DATA) -> libc::c_uint {
    return (*this).count;
}
pub unsafe extern "C" fn data_get_code(mut this: DATA) -> libc::c_uint {
    return (*this).code;
}
pub unsafe extern "C" fn data_get_fail(mut this: DATA) -> libc::c_uint {
    return (*this).fail;
}
pub unsafe extern "C" fn data_get_okay(mut this: DATA) -> libc::c_uint {
    return (*this).okay;
}
pub unsafe extern "C" fn data_get_total(mut this: DATA) -> libc::c_float {
    return (*this).total;
}
pub unsafe extern "C" fn data_get_bytes(mut this: DATA) -> libc::c_float {
    return (*this).bytes as libc::c_float;
}
pub unsafe extern "C" fn data_get_highest(mut this: DATA) -> libc::c_float {
    return (*this).highest;
}
pub unsafe extern "C" fn data_get_lowest(mut this: DATA) -> libc::c_float {
    if (*this).code != 0 {
        return (*this).lowest
    } else {
        return (*this).code as libc::c_float
    };
}
pub unsafe extern "C" fn data_get_megabytes(mut this: DATA) -> libc::c_float {
    return ((*this).bytes as libc::c_float as libc::c_double / (1024.0f64 * 1024.0f64))
        as libc::c_float;
}
pub unsafe extern "C" fn data_get_elapsed(mut this: DATA) -> libc::c_float {
    let mut tps: libc::c_long = 0;
    let mut time___0: clock_t = 0;
    time___0 = (*this).stop - (*this).start;
    tps = sysconf(2 as libc::c_int);
    (*this).elapsed = time___0 as libc::c_float / tps as libc::c_float;
    return (*this).elapsed;
}
pub unsafe extern "C" fn data_get_availability(mut this: DATA) -> libc::c_float {
    if (*this).count == 0 as libc::c_uint {
        (*this).available = 0 as libc::c_int as libc::c_float;
    } else {
        (*this)
            .available = ((*this).count)
            .wrapping_div(((*this).count).wrapping_add((*this).fail))
            .wrapping_mul(100 as libc::c_uint) as libc::c_float;
    }
    return (*this).available;
}
pub unsafe extern "C" fn data_get_response_time(mut this: DATA) -> libc::c_float {
    if (*this).total == 0 as libc::c_int as libc::c_float {
        return 0 as libc::c_int as libc::c_float
    } else {
        if (*this).count == 0 as libc::c_uint {
            return 0 as libc::c_int as libc::c_float;
        }
    }
    return (*this).total / (*this).count as libc::c_float;
}
pub unsafe extern "C" fn data_get_transaction_rate(mut this: DATA) -> libc::c_float {
    if (*this).count == 0 as libc::c_uint {
        return 0 as libc::c_int as libc::c_float
    } else {
        if (*this).elapsed == 0 as libc::c_int as libc::c_float {
            return 0 as libc::c_int as libc::c_float;
        }
    }
    return (*this).count as libc::c_float / (*this).elapsed;
}
pub unsafe extern "C" fn data_get_throughput(mut this: DATA) -> libc::c_float {
    if (*this).elapsed == 0 as libc::c_int as libc::c_float {
        return 0 as libc::c_int as libc::c_float;
    }
    return ((*this).bytes as libc::c_double
        / ((*this).elapsed as libc::c_double * 1024.0f64 * 1024.0f64)) as libc::c_float;
}
pub unsafe extern "C" fn data_get_concurrency(mut this: DATA) -> libc::c_float {
    if (*this).elapsed == 0 as libc::c_int as libc::c_float {
        return 0 as libc::c_int as libc::c_float;
    }
    return (*this).total / (*this).elapsed;
}
pub static mut wday: [*const libc::c_char; 7] = [
    b"Mon\0" as *const u8 as *const libc::c_char,
    b"Tue\0" as *const u8 as *const libc::c_char,
    b"Wed\0" as *const u8 as *const libc::c_char,
    b"Thu\0" as *const u8 as *const libc::c_char,
    b"Fri\0" as *const u8 as *const libc::c_char,
    b"Sat\0" as *const u8 as *const libc::c_char,
    b"Sun\0" as *const u8 as *const libc::c_char,
];
pub static mut weekday: [*const libc::c_char; 7] = [
    b"Sunday\0" as *const u8 as *const libc::c_char,
    b"Monday\0" as *const u8 as *const libc::c_char,
    b"Tuesday\0" as *const u8 as *const libc::c_char,
    b"Wednesday\0" as *const u8 as *const libc::c_char,
    b"Thursday\0" as *const u8 as *const libc::c_char,
    b"Friday\0" as *const u8 as *const libc::c_char,
    b"Saturday\0" as *const u8 as *const libc::c_char,
];
pub static mut month: [*const libc::c_char; 12] = [
    b"Jan\0" as *const u8 as *const libc::c_char,
    b"Feb\0" as *const u8 as *const libc::c_char,
    b"Mar\0" as *const u8 as *const libc::c_char,
    b"Apr\0" as *const u8 as *const libc::c_char,
    b"May\0" as *const u8 as *const libc::c_char,
    b"Jun\0" as *const u8 as *const libc::c_char,
    b"Jul\0" as *const u8 as *const libc::c_char,
    b"Aug\0" as *const u8 as *const libc::c_char,
    b"Sep\0" as *const u8 as *const libc::c_char,
    b"Oct\0" as *const u8 as *const libc::c_char,
    b"Nov\0" as *const u8 as *const libc::c_char,
    b"Dec\0" as *const u8 as *const libc::c_char,
];
static mut tz: [tzinfo; 43] = [
    {
        let mut init = tzinfo {
            name: b"GMT\0" as *const u8 as *const libc::c_char,
            offset: 0 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"UTC\0" as *const u8 as *const libc::c_char,
            offset: 0 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"WET\0" as *const u8 as *const libc::c_char,
            offset: 0 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"BST\0" as *const u8 as *const libc::c_char,
            offset: -(60 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"WAT\0" as *const u8 as *const libc::c_char,
            offset: 60 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"AST\0" as *const u8 as *const libc::c_char,
            offset: 240 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"ADT\0" as *const u8 as *const libc::c_char,
            offset: 180 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"EST\0" as *const u8 as *const libc::c_char,
            offset: 300 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"EDT\0" as *const u8 as *const libc::c_char,
            offset: 240 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"CST\0" as *const u8 as *const libc::c_char,
            offset: 360 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"CDT\0" as *const u8 as *const libc::c_char,
            offset: 300 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"MST\0" as *const u8 as *const libc::c_char,
            offset: 420 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"MDT\0" as *const u8 as *const libc::c_char,
            offset: 360 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"PST\0" as *const u8 as *const libc::c_char,
            offset: 480 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"PDT\0" as *const u8 as *const libc::c_char,
            offset: 420 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"YST\0" as *const u8 as *const libc::c_char,
            offset: 540 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"YDT\0" as *const u8 as *const libc::c_char,
            offset: 480 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"HST\0" as *const u8 as *const libc::c_char,
            offset: 600 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"HDT\0" as *const u8 as *const libc::c_char,
            offset: 540 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"CAT\0" as *const u8 as *const libc::c_char,
            offset: 600 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"AHST\0" as *const u8 as *const libc::c_char,
            offset: 600 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"NT\0" as *const u8 as *const libc::c_char,
            offset: 660 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"IDLW\0" as *const u8 as *const libc::c_char,
            offset: 720 as libc::c_int,
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"CET\0" as *const u8 as *const libc::c_char,
            offset: -(60 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"MET\0" as *const u8 as *const libc::c_char,
            offset: -(60 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"MEWT\0" as *const u8 as *const libc::c_char,
            offset: -(60 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"MEST\0" as *const u8 as *const libc::c_char,
            offset: -(120 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"CEST\0" as *const u8 as *const libc::c_char,
            offset: -(120 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"MESZ\0" as *const u8 as *const libc::c_char,
            offset: -(120 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"FWT\0" as *const u8 as *const libc::c_char,
            offset: -(60 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"FST\0" as *const u8 as *const libc::c_char,
            offset: -(120 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"EET\0" as *const u8 as *const libc::c_char,
            offset: -(120 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"WAST\0" as *const u8 as *const libc::c_char,
            offset: -(420 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"WADT\0" as *const u8 as *const libc::c_char,
            offset: -(480 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"CCT\0" as *const u8 as *const libc::c_char,
            offset: -(480 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"JST\0" as *const u8 as *const libc::c_char,
            offset: -(540 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"EAST\0" as *const u8 as *const libc::c_char,
            offset: -(600 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"EADT\0" as *const u8 as *const libc::c_char,
            offset: -(660 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"GST\0" as *const u8 as *const libc::c_char,
            offset: -(600 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"NZT\0" as *const u8 as *const libc::c_char,
            offset: -(720 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"NZST\0" as *const u8 as *const libc::c_char,
            offset: -(720 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"NZDT\0" as *const u8 as *const libc::c_char,
            offset: -(780 as libc::c_int),
        };
        init
    },
    {
        let mut init = tzinfo {
            name: b"IDLE\0" as *const u8 as *const libc::c_char,
            offset: -(720 as libc::c_int),
        };
        init
    },
];
pub static mut DATESIZE: size_t = ::std::mem::size_of::<DATE_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_date(mut date: *mut libc::c_char) -> DATE {
    let mut now: time_t = 0;
    let mut this: DATE = 0 as *mut DATE_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(DATESIZE, 1 as libc::c_int as size_t);
    this = tmp as DATE;
    (*this).tm = 0 as *mut libc::c_void as *mut tm;
    (*this).etag = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___0 = malloc(64 as libc::c_int as size_t);
    (*this).date = tmp___0 as *mut libc::c_char;
    tmp___1 = malloc(64 as libc::c_int as size_t);
    (*this).head = tmp___1 as *mut libc::c_char;
    memset(
        (*this).date as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    memset(
        (*this).head as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    if date as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        now = time(0 as *mut libc::c_void as *mut time_t);
        (*this)
            .tm = gmtime_r(
            &mut now as *mut time_t as *const time_t,
            &mut (*this).safe as *mut tm,
        );
    } else {
        now = __strtotime(date as *const libc::c_char);
        (*this)
            .tm = gmtime_r(
            &mut now as *mut time_t as *const time_t,
            &mut (*this).safe as *mut tm,
        );
    }
    return this;
}
pub unsafe extern "C" fn new_etag(mut etag: *mut libc::c_char) -> DATE {
    let mut this: DATE = 0 as *mut DATE_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(DATESIZE, 1 as libc::c_int as size_t);
    this = tmp as DATE;
    (*this).tm = 0 as *mut libc::c_void as *mut tm;
    (*this).date = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).etag = 0 as *mut libc::c_void as *mut libc::c_char;
    if etag as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*this).etag = xstrdup(etag as *const libc::c_char);
    }
    return this;
}
pub unsafe extern "C" fn date_destroy(mut this: DATE) -> DATE {
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free((*this).date as *mut libc::c_void);
        free((*this).head as *mut libc::c_void);
        free((*this).etag as *mut libc::c_void);
        free(this as *mut libc::c_void);
        this = 0 as *mut libc::c_void as DATE;
    }
    return this;
}
pub unsafe extern "C" fn date_get_etag(mut this: DATE) -> *mut libc::c_char {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if (*this).etag as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp = b"\0" as *const u8 as *const libc::c_char;
    } else {
        tmp = (*this).etag as *const libc::c_char;
    }
    return tmp as *mut libc::c_char;
}
pub unsafe extern "C" fn date_get_rfc850(mut this: DATE) -> *mut libc::c_char {
    memset(
        (*this).date as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    if (*this).tm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char
    } else {
        if (*(*this).tm).tm_year == 0 as libc::c_int {
            return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
    }
    snprintf(
        (*this).date,
        64 as libc::c_int as size_t,
        b"%s, %d %s %d %d:%d:%d GMT\0" as *const u8 as *const libc::c_char,
        wday[(*(*this).tm).tm_wday as usize],
        (*(*this).tm).tm_mday,
        month[(*(*this).tm).tm_mon as usize],
        (*(*this).tm).tm_year,
        (*(*this).tm).tm_hour,
        (*(*this).tm).tm_min,
        (*(*this).tm).tm_sec,
    );
    return (*this).date;
}
pub unsafe extern "C" fn date_expired(mut this: DATE) -> BOOLEAN {
    let mut res: libc::c_long = 0;
    let mut now: time_t = 0;
    let mut gmt: *mut tm = 0 as *mut tm;
    let mut then: time_t = 0;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_int = 0;
    res = 0 as libc::c_long;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_true
    } else {
        if (*this).tm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return boolean_true;
        }
    }
    now = time(0 as *mut libc::c_void as *mut time_t);
    gmt = gmtime(&mut now as *mut time_t as *const time_t);
    then = mktime((*this).tm);
    now = mktime(gmt);
    tmp = difftime(then, now);
    res = tmp as libc::c_long;
    if res < 0 as libc::c_long {
        tmp___0 = 1 as libc::c_int;
    } else {
        tmp___0 = 0 as libc::c_int;
    }
    return tmp___0 as BOOLEAN;
}
pub unsafe extern "C" fn date_to_string(mut this: DATE) -> *mut libc::c_char {
    if (*this).etag as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        return (*this).etag;
    }
    memset(
        (*this).date as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    setlocale(2 as libc::c_int, b"C\0" as *const u8 as *const libc::c_char);
    strftime(
        (*this).date,
        64 as libc::c_int as size_t,
        b"%a, %F %T \0" as *const u8 as *const libc::c_char,
        (*this).tm as *const tm,
    );
    return (*this).date;
}
pub unsafe extern "C" fn mylocaltime(mut tm: *mut tm) -> time_t {
    let mut epoch: time_t = 0;
    let mut offset: time_t = 0;
    let mut tmp: *mut tm = 0 as *mut tm;
    let mut tmp___0: time_t = 0;
    let mut local: time_t = 0;
    let mut tmp___1: time_t = 0;
    let mut tmp___2: libc::c_double = 0.;
    epoch = 0 as libc::c_int as time_t;
    tmp = localtime(&mut epoch as *mut time_t as *const time_t);
    tmp___0 = mktime(tmp);
    offset = tmp___0;
    tmp___1 = mktime(tm);
    local = tmp___1;
    tmp___2 = difftime(local, offset);
    return tmp___2 as time_t;
}
pub unsafe extern "C" fn date_stamp(mut this: DATE) -> *mut libc::c_char {
    let mut tmp: *mut tm = 0 as *mut tm;
    let mut time___0: time_t = 0;
    time___0 = mylocaltime((*this).tm);
    tmp = localtime(&mut time___0 as *mut time_t as *const time_t);
    memset(
        (*this).date as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    strftime(
        (*this).date,
        64 as libc::c_int as size_t,
        b"[%a, %F %T] \0" as *const u8 as *const libc::c_char,
        tmp as *const tm,
    );
    return (*this).date;
}
pub unsafe extern "C" fn date_adjust(
    mut tvalue: time_t,
    mut secs: libc::c_int,
) -> time_t {
    let mut tp: *mut tm = 0 as *mut tm;
    let mut ret: time_t = 0;
    ret = (tvalue != -(1 as libc::c_long)) as libc::c_int as time_t;
    if ret != 0 {
        tp = localtime(&mut tvalue as *mut time_t as *const time_t);
        if secs > 2147483647 as libc::c_int - (*tp).tm_sec {
            ret = -(1 as libc::c_int) as time_t;
        } else {
            (*tp).tm_sec += secs;
            ret = mktime(tp);
        }
    }
    return ret;
}
unsafe extern "C" fn __checkday(
    mut check: *mut libc::c_char,
    mut len: size_t,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut what: *const *const libc::c_char = 0 as *const *const libc::c_char;
    let mut found: BOOLEAN = boolean_false;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: libc::c_int = 0;
    found = boolean_false;
    if len > 3 as libc::c_ulong {
        what = &*weekday.as_ptr().offset(0 as libc::c_int as isize)
            as *const *const libc::c_char;
    } else {
        what = &*wday.as_ptr().offset(0 as libc::c_int as isize)
            as *const *const libc::c_char;
    }
    i = 0 as libc::c_int;
    while i < 7 as libc::c_int {
        tmp = strmatch(
            check,
            *what.offset(0 as libc::c_int as isize) as *mut libc::c_char,
        );
        if tmp as u64 != 0 {
            found = boolean_true;
            break;
        } else {
            what = what.offset(1);
            i += 1;
        }
    }
    if found as u64 != 0 {
        tmp___0 = i;
    } else {
        tmp___0 = -(1 as libc::c_int);
    }
    return tmp___0;
}
unsafe extern "C" fn __checkmonth(mut check: *mut libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut what: *const *const libc::c_char = 0 as *const *const libc::c_char;
    let mut found: BOOLEAN = boolean_false;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: libc::c_int = 0;
    found = boolean_false;
    what = &*month.as_ptr().offset(0 as libc::c_int as isize)
        as *const *const libc::c_char;
    i = 0 as libc::c_int;
    while i < 12 as libc::c_int {
        tmp = strmatch(
            check,
            *what.offset(0 as libc::c_int as isize) as *mut libc::c_char,
        );
        if tmp as u64 != 0 {
            found = boolean_true;
            break;
        } else {
            what = what.offset(1);
            i += 1;
        }
    }
    if found as u64 != 0 {
        tmp___0 = i;
    } else {
        tmp___0 = -(1 as libc::c_int);
    }
    return tmp___0;
}
unsafe extern "C" fn __checktz(mut check: *mut libc::c_char) -> libc::c_int {
    let mut i: libc::c_uint = 0;
    let mut what: *const tzinfo = 0 as *const tzinfo;
    let mut found: BOOLEAN = boolean_false;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: libc::c_int = 0;
    found = boolean_false;
    what = tz.as_ptr();
    i = 0 as libc::c_uint;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[tzinfo; 43]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<tzinfo>() as libc::c_ulong)
    {
        tmp = strmatch(check, (*what).name as *mut libc::c_char);
        if tmp as u64 != 0 {
            found = boolean_true;
            break;
        } else {
            what = what.offset(1);
            i = i.wrapping_add(1);
        }
    }
    if found as u64 != 0 {
        tmp___0 = (*what).offset * 60 as libc::c_int;
    } else {
        tmp___0 = -(1 as libc::c_int);
    }
    return tmp___0;
}
unsafe extern "C" fn skip(mut date: *mut *const libc::c_char) {
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    while **date != 0 {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(**date as libc::c_uchar as libc::c_int as isize) as libc::c_int
            & 8 as libc::c_int != 0
        {
            break;
        }
        *date = (*date).offset(1);
    }
}
unsafe extern "C" fn __strtotime(mut string: *const libc::c_char) -> time_t {
    let mut sec: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut hour: libc::c_int = 0;
    let mut mday: libc::c_int = 0;
    let mut mon: libc::c_int = 0;
    let mut year: libc::c_int = 0;
    let mut wday___0: libc::c_int = 0;
    let mut tzoff: libc::c_int = 0;
    let mut part: libc::c_int = 0;
    let mut t: time_t = 0;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut date: *const libc::c_char = 0 as *const libc::c_char;
    let mut indate: *const libc::c_char = 0 as *const libc::c_char;
    let mut dignext: assume = DATE_MDAY;
    let mut found: BOOLEAN = boolean_false;
    let mut buf: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut len: size_t = 0;
    let mut val: libc::c_int = 0;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_long = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut gmt: *mut tm = 0 as *mut tm;
    let mut delta: libc::c_long = 0;
    let mut t2: time_t = 0;
    let mut keeptime2: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp___4: *mut tm = 0 as *mut tm;
    let mut tmp___5: libc::c_int = 0;
    sec = -(1 as libc::c_int);
    min = -(1 as libc::c_int);
    hour = -(1 as libc::c_int);
    mday = -(1 as libc::c_int);
    mon = -(1 as libc::c_int);
    year = -(1 as libc::c_int);
    wday___0 = -(1 as libc::c_int);
    tzoff = -(1 as libc::c_int);
    part = 0 as libc::c_int;
    t = 0 as libc::c_int as time_t;
    indate = string;
    dignext = DATE_MDAY;
    found = boolean_false;
    if !string.is_null() {
        if *string == 0 {
            return 0 as libc::c_int as time_t;
        }
    } else {
        return 0 as libc::c_int as time_t
    }
    date = string;
    while *date != 0 {
        if !(part < 6 as libc::c_int) {
            break;
        }
        found = boolean_false;
        skip(&mut date);
        tmp___3 = __ctype_b_loc();
        if *(*tmp___3).offset(*date as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & 1024 as libc::c_int != 0
        {
            buf[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                buf[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            sscanf(
                date,
                b"%31[A-Za-z]\0" as *const u8 as *const libc::c_char,
                buf.as_mut_ptr(),
            );
            len = strlen(buf.as_mut_ptr() as *const libc::c_char);
            if wday___0 == -(1 as libc::c_int) {
                wday___0 = __checkday(buf.as_mut_ptr(), len);
                if wday___0 != -(1 as libc::c_int) {
                    found = boolean_true;
                }
            }
            if found as u64 == 0 {
                if mon == -(1 as libc::c_int) {
                    mon = __checkmonth(buf.as_mut_ptr());
                    if mon != -(1 as libc::c_int) {
                        found = boolean_true;
                    }
                }
            }
            if found as u64 == 0 {
                if tzoff == -(1 as libc::c_int) {
                    tzoff = __checktz(buf.as_mut_ptr());
                    if tzoff != -(1 as libc::c_int) {
                        found = boolean_true;
                    }
                }
            }
            if found as u64 == 0 {
                return -(1 as libc::c_int) as time_t;
            }
            date = date.offset(len as isize);
        } else {
            tmp___2 = __ctype_b_loc();
            if *(*tmp___2).offset(*date as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & 2048 as libc::c_int != 0
            {
                let mut current_block_124: u64;
                if sec == -(1 as libc::c_int) {
                    tmp___1 = sscanf(
                        date,
                        b"%02d:%02d:%02d\0" as *const u8 as *const libc::c_char,
                        &mut hour as *mut libc::c_int,
                        &mut min as *mut libc::c_int,
                        &mut sec as *mut libc::c_int,
                    );
                    if 3 as libc::c_int == tmp___1 {
                        date = date.offset(8 as libc::c_int as isize);
                        found = boolean_true;
                        current_block_124 = 8533724845731836612;
                    } else {
                        current_block_124 = 7401675882708445790;
                    }
                } else {
                    current_block_124 = 7401675882708445790;
                }
                match current_block_124 {
                    7401675882708445790 => {
                        tmp___0 = strtol(
                            date,
                            &mut end as *mut *mut libc::c_char,
                            10 as libc::c_int,
                        );
                        val = tmp___0 as libc::c_int;
                        if tzoff == -(1 as libc::c_int) {
                            if end.offset_from(date as *mut libc::c_char) as libc::c_long
                                == 4 as libc::c_long
                            {
                                if val < 1300 as libc::c_int {
                                    if (indate as libc::c_ulong) < date as libc::c_ulong {
                                        let mut current_block_72: u64;
                                        if *date.offset(-(1 as libc::c_int) as isize) as libc::c_int
                                            == 43 as libc::c_int
                                        {
                                            current_block_72 = 8392554719829874290;
                                        } else if *date.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int == 45 as libc::c_int
                                            {
                                            current_block_72 = 8392554719829874290;
                                        } else {
                                            current_block_72 = 7318352876044315808;
                                        }
                                        match current_block_72 {
                                            8392554719829874290 => {
                                                found = boolean_true;
                                                tzoff = (val / 100 as libc::c_int * 60 as libc::c_int
                                                    + val % 100 as libc::c_int) * 60 as libc::c_int;
                                                if *date.offset(-(1 as libc::c_int) as isize) as libc::c_int
                                                    == 43 as libc::c_int
                                                {
                                                    tzoff = -tzoff;
                                                } else {
                                                    tzoff = tzoff;
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        if end.offset_from(date as *mut libc::c_char) as libc::c_long
                            == 8 as libc::c_long
                        {
                            if year == -(1 as libc::c_int) {
                                if mon == -(1 as libc::c_int) {
                                    if mday == -(1 as libc::c_int) {
                                        found = boolean_true;
                                        year = val / 10000 as libc::c_int;
                                        mon = val % 10000 as libc::c_int / 100 as libc::c_int
                                            - 1 as libc::c_int;
                                        mday = val % 100 as libc::c_int;
                                    }
                                }
                            }
                        }
                        if found as u64 == 0 {
                            if dignext as libc::c_uint == 0 as libc::c_uint {
                                if mday == -(1 as libc::c_int) {
                                    if val > 0 as libc::c_int {
                                        if val < 32 as libc::c_int {
                                            mday = val;
                                            found = boolean_true;
                                        }
                                    }
                                    dignext = DATE_YEAR;
                                }
                            }
                        }
                        if found as u64 == 0 {
                            if dignext as libc::c_uint == 1 as libc::c_uint {
                                if year == -(1 as libc::c_int) {
                                    year = val;
                                    found = boolean_true;
                                    if year > 1970 as libc::c_int {
                                        year -= 1900 as libc::c_int;
                                    }
                                    if mday == -(1 as libc::c_int) {
                                        dignext = DATE_MDAY;
                                    }
                                }
                            }
                        }
                        if found as u64 == 0 {
                            return -(1 as libc::c_int) as time_t;
                        }
                        date = end as *const libc::c_char;
                    }
                    _ => {}
                }
            }
        }
        part += 1;
    }
    if -(1 as libc::c_int) == sec {
        hour = 0 as libc::c_int;
        min = hour;
        sec = min;
    }
    if -(1 as libc::c_int) == mday {
        return -(1 as libc::c_int) as time_t
    } else {
        if -(1 as libc::c_int) == mon {
            return -(1 as libc::c_int) as time_t
        } else {
            if -(1 as libc::c_int) == year {
                return -(1 as libc::c_int) as time_t;
            }
        }
    }
    if year > 2037 as libc::c_int {
        return 2147483647 as libc::c_int as time_t;
    }
    tm.tm_sec = sec;
    tm.tm_min = min;
    tm.tm_hour = hour;
    tm.tm_mday = mday;
    tm.tm_mon = mon;
    tm.tm_year = year;
    tm.tm_wday = 0 as libc::c_int;
    tm.tm_yday = 0 as libc::c_int;
    tm.tm_isdst = 0 as libc::c_int;
    t = mktime(&mut tm);
    if -(1 as libc::c_int) != t as libc::c_int {
        tmp___4 = gmtime_r(
            &mut t as *mut time_t as *const time_t,
            &mut keeptime2 as *mut tm,
        );
        gmt = tmp___4;
        if gmt.is_null() {
            return -(1 as libc::c_int) as time_t;
        }
        t2 = mktime(gmt);
        if tzoff != -(1 as libc::c_int) {
            tmp___5 = tzoff;
        } else {
            tmp___5 = 0 as libc::c_int;
        }
        delta = tmp___5 as time_t + (t - t2);
        if delta > 0 as libc::c_long {
            if t + delta < t {
                return -(1 as libc::c_int) as time_t;
            }
        }
        t += delta;
    }
    return t;
}
pub unsafe extern "C" fn escape(mut buf: *mut libc::c_char) -> *mut libc::c_char {
    let mut i: size_t = 0;
    let mut len: size_t = 0;
    let mut res: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fin: [libc::c_char; 40000] = [0; 40000];
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    i = 0 as libc::c_int as size_t;
    tmp = xrealloc(
        buf as *mut libc::c_void,
        (40000 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    res = tmp as *mut libc::c_char;
    if res as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        buf = res;
    }
    len = strlen(buf as *const libc::c_char);
    while i < len {
        if !(*buf.offset(i as isize) as libc::c_int != 92 as libc::c_int) {
            break;
        }
        i = i.wrapping_add(1);
    }
    while i < len {
        *buf
            .offset(
                i as isize,
            ) = *buf.offset(i.wrapping_add(1 as libc::c_ulong) as isize);
        i = i.wrapping_add(1);
    }
    *buf.offset(len as isize) = '\u{0}' as i32 as libc::c_char;
    strncpy(fin.as_mut_ptr(), buf as *const libc::c_char, len);
    memset(
        res as *mut libc::c_void,
        '\u{0}' as i32,
        (40000 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    tmp___0 = strlen(fin.as_mut_ptr() as *const libc::c_char);
    strncpy(res, fin.as_mut_ptr() as *const libc::c_char, tmp___0);
    return res;
}
pub unsafe extern "C" fn evaluate(
    mut hash: HASH,
    mut buf: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut x: libc::c_int = 0;
    let mut ENV: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut final_0: [libc::c_char; 40000] = [0; 40000];
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut string: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut scan: *const libc::c_char = 0 as *const libc::c_char;
    let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: size_t = 0;
    x = 0 as libc::c_int;
    ENV = 0 as libc::c_int;
    len = 0 as libc::c_int;
    tmp = xrealloc(
        buf as *mut libc::c_void,
        (40000 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    result = tmp as *mut libc::c_char;
    if result as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        buf = result;
    }
    tmp___0 = strchr(buf as *const libc::c_char, '$' as i32);
    scan = tmp___0.offset(1 as libc::c_int as isize) as *const libc::c_char;
    tmp___1 = strlen(buf as *const libc::c_char);
    tmp___2 = strlen(scan);
    len = tmp___1.wrapping_sub(tmp___2).wrapping_sub(1 as libc::c_ulong) as libc::c_int;
    if *scan.offset(0 as libc::c_int as isize) as libc::c_int == 123 as libc::c_int {
        scan = scan.offset(1);
    } else if *scan.offset(0 as libc::c_int as isize) as libc::c_int == 40 as libc::c_int
        {
        scan = scan.offset(1);
    }
    ptr = scan as *mut libc::c_char;
    while *scan != 0 {
        if !(*scan as libc::c_int != 125 as libc::c_int) {
            break;
        }
        if !(*scan as libc::c_int != 41 as libc::c_int) {
            break;
        }
        if !(*scan as libc::c_int != 47 as libc::c_int) {
            break;
        }
        scan = scan.offset(1);
        x += 1;
    }
    if *scan.offset(0 as libc::c_int as isize) as libc::c_int == 125 as libc::c_int {
        scan = scan.offset(1);
    } else if *scan.offset(0 as libc::c_int as isize) as libc::c_int == 41 as libc::c_int
        {
        scan = scan.offset(1);
    }
    string = substring(ptr, 0 as libc::c_int, x);
    tmp___4 = hash_contains(hash, string);
    if tmp___4 as libc::c_uint == 0 as libc::c_uint {
        tmp___3 = getenv(string as *const libc::c_char);
        if tmp___3 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            ENV = 1 as libc::c_int;
        } else {
            string = 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    memset(
        final_0.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 40000]>() as libc::c_ulong,
    );
    strncpy(final_0.as_mut_ptr(), buf as *const libc::c_char, len as size_t);
    if string as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if ENV == 0 as libc::c_int {
            tmp___5 = hash_get(hash, string);
            tmp___7 = tmp___5 as *mut libc::c_char;
        } else {
            tmp___6 = getenv(string as *const libc::c_char);
            tmp___7 = tmp___6;
        }
        strcat(final_0.as_mut_ptr(), tmp___7 as *const libc::c_char);
    }
    strcat(final_0.as_mut_ptr(), scan);
    memset(
        result as *mut libc::c_void,
        '\u{0}' as i32,
        (40000 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    tmp___8 = strlen(final_0.as_mut_ptr() as *const libc::c_char);
    strncpy(result, final_0.as_mut_ptr() as *const libc::c_char, tmp___8);
    xfree(string as *mut libc::c_void);
    return result;
}
pub unsafe extern "C" fn ftp_login(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut code: libc::c_int = 0;
    let mut tmp: [libc::c_char; 128] = [0; 128];
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: BOOLEAN = boolean_false;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: BOOLEAN = boolean_false;
    code = 120 as libc::c_int;
    code = __response(C);
    tmp___0 = okay(code);
    if tmp___0 as u64 == 0 {
        NOTIFY(
            ERROR,
            b"FTP: Server responded: %d\0" as *const u8 as *const libc::c_char,
            code,
        );
        return boolean_false;
    }
    tmp___4 = url_get_username(U);
    if tmp___4 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___3 = b"anonymous\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___2 = url_get_username(U);
        tmp___3 = tmp___2 as *const libc::c_char;
    }
    snprintf(
        tmp.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        tmp___3,
    );
    code = __request___0(
        C,
        b"USER %s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp.as_mut_ptr(),
    );
    if code != 331 as libc::c_int {
        tmp___5 = okay(code);
        if tmp___5 as u64 != 0 {
            return boolean_true;
        }
    }
    memset(
        tmp.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
    );
    tmp___9 = url_get_password(U);
    if tmp___9 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___8 = b"siege@joedog.org\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___7 = url_get_password(U);
        tmp___8 = tmp___7 as *const libc::c_char;
    }
    snprintf(
        tmp.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        tmp___8,
    );
    code = __request___0(
        C,
        b"PASS %s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp.as_mut_ptr(),
    );
    tmp___10 = __in_range(code, 200 as libc::c_int, 299 as libc::c_int);
    return tmp___10;
}
pub unsafe extern "C" fn ftp_pasv(mut C: *mut CONN) -> BOOLEAN {
    let mut i: libc::c_int = 0;
    let mut code: libc::c_int = 0;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut addr: [libc::c_uchar; 6] = [0; 6];
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    code = __request___0(
        C,
        b"PASV\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp = okay(code);
    if tmp as u64 == 0 {
        return boolean_false;
    }
    ptr = ((*C).chkbuf).as_mut_ptr();
    ptr = ptr.offset(4 as libc::c_int as isize);
    while *ptr != 0 {
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*ptr as libc::c_int as isize) as libc::c_int
            & 2048 as libc::c_int != 0
        {
            break;
        }
        ptr = ptr.offset(1);
    }
    if *ptr == 0 {
        return boolean_false;
    }
    i = 0 as libc::c_int;
    while i < 6 as libc::c_int {
        addr[i as usize] = 0 as libc::c_int as libc::c_uchar;
        loop {
            tmp___1 = __ctype_b_loc();
            if *(*tmp___1).offset(*ptr as libc::c_int as isize) as libc::c_int
                & 2048 as libc::c_int == 0
            {
                break;
            }
            addr[i
                as usize] = (*ptr as libc::c_int - 48 as libc::c_int
                + 10 as libc::c_int * addr[i as usize] as libc::c_int) as libc::c_uchar;
            ptr = ptr.offset(1);
        }
        if *ptr as libc::c_int == 44 as libc::c_int {
            ptr = ptr.offset(1);
        } else if i < 5 as libc::c_int {
            return boolean_false
        }
        i += 1;
    }
    snprintf(
        ((*C).ftp.host).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"%d.%d.%d.%d\0" as *const u8 as *const libc::c_char,
        addr[0 as libc::c_int as usize] as libc::c_int,
        addr[1 as libc::c_int as usize] as libc::c_int,
        addr[2 as libc::c_int as usize] as libc::c_int,
        addr[3 as libc::c_int as usize] as libc::c_int,
    );
    (*C)
        .ftp
        .port = ((addr[4 as libc::c_int as usize] as libc::c_int) << 8 as libc::c_int)
        + addr[5 as libc::c_int as usize] as libc::c_int;
    return boolean_true;
}
pub unsafe extern "C" fn ftp_cwd(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut code: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: BOOLEAN = boolean_false;
    tmp = url_get_path(U);
    code = __request___0(
        C,
        b"CWD %s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp,
    );
    tmp___0 = okay(code);
    return tmp___0;
}
pub unsafe extern "C" fn ftp_ascii(mut C: *mut CONN) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    (*C)
        .ftp
        .code = __request___0(
        C,
        b"TYPE A\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp = okay((*C).ftp.code);
    return tmp;
}
pub unsafe extern "C" fn ftp_binary(mut C: *mut CONN) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    (*C)
        .ftp
        .code = __request___0(
        C,
        b"TYPE I\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp = okay((*C).ftp.code);
    return tmp;
}
pub unsafe extern "C" fn ftp_quit(mut C: *mut CONN) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    (*C)
        .ftp
        .code = __request___0(
        C,
        b"QUIT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp = okay((*C).ftp.code);
    return tmp;
}
pub unsafe extern "C" fn ftp_size(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut size: libc::c_int = 0;
    let mut resp: libc::c_int = 0;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: BOOLEAN = boolean_false;
    tmp = ftp_binary(C);
    if tmp as libc::c_uint != 1 as libc::c_uint {
        return boolean_false;
    }
    tmp___0 = url_get_file(U);
    tmp___1 = url_get_path(U);
    (*C)
        .ftp
        .code = __request___0(
        C,
        b"SIZE %s%s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___1,
        tmp___0,
    );
    tmp___3 = okay((*C).ftp.code);
    if tmp___3 as u64 != 0 {
        tmp___2 = sscanf(
            ((*C).chkbuf).as_mut_ptr() as *const libc::c_char,
            b"%d %d\0" as *const u8 as *const libc::c_char,
            &mut resp as *mut libc::c_int,
            &mut size as *mut libc::c_int,
        );
        if tmp___2 == 2 as libc::c_int {
            (*C).ftp.size = size as size_t;
            return boolean_true;
        } else {
            return boolean_false
        }
    } else {
        return boolean_false
    };
}
pub unsafe extern "C" fn ftp_stor(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut len: size_t = 0;
    let mut file: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut id: size_t = 0;
    let mut tmp: pthread_t = 0;
    let mut num: libc::c_int = 0;
    let mut parts: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: BOOLEAN = boolean_false;
    tmp = pthread_self();
    id = tmp;
    num = 2 as libc::c_int;
    if (id as libc::c_double) < 0.0f64 {
        id = id.wrapping_neg();
    }
    tmp___0 = url_get_file(U);
    tmp___1 = strlen(tmp___0 as *const libc::c_char);
    len = tmp___1.wrapping_add(17 as libc::c_ulong);
    tmp___2 = url_get_file(U);
    parts = split('.' as i32 as libc::c_char, tmp___2, &mut num);
    tmp___3 = xmalloc(len);
    file = tmp___3 as *mut libc::c_char;
    memset(file as *mut libc::c_void, '\u{0}' as i32, len);
    if *parts.offset(1 as libc::c_int as isize) as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___4 = b"\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___4 = *parts.offset(1 as libc::c_int as isize) as *const libc::c_char;
    }
    snprintf(
        file,
        len,
        b"%s-%zu.%s\0" as *const u8 as *const libc::c_char,
        *parts.offset(0 as libc::c_int as isize),
        id,
        tmp___4,
    );
    if my.unique as u64 != 0 {
        (*C)
            .ftp
            .code = __request___0(
            C,
            b"STOR %s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            file,
        );
    } else {
        tmp___5 = url_get_file(U);
        (*C)
            .ftp
            .code = __request___0(
            C,
            b"STOR %s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tmp___5,
        );
    }
    xfree(file as *mut libc::c_void);
    split_free(parts, num);
    tmp___6 = okay((*C).ftp.code);
    return tmp___6;
}
pub unsafe extern "C" fn ftp_retr(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: BOOLEAN = boolean_false;
    tmp = url_get_file(U);
    tmp___0 = url_get_path(U);
    (*C)
        .ftp
        .code = __request___0(
        C,
        b"RETR %s%s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___0,
        tmp,
    );
    tmp___1 = okay((*C).ftp.code);
    return tmp___1;
}
pub unsafe extern "C" fn ftp_put(mut D: *mut CONN, mut U: URL) -> size_t {
    let mut n: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: size_t = 0;
    tmp = url_get_postlen(U);
    tmp___0 = url_get_postdata(U);
    tmp___1 = socket_write(D, tmp___0 as *const libc::c_void, tmp);
    n = tmp___1 as size_t;
    tmp___2 = url_get_postlen(U);
    if n != tmp___2 {
        NOTIFY(
            ERROR,
            b"HTTP: unable to write to socket.\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int) as size_t;
    }
    tmp___3 = url_get_postlen(U);
    return tmp___3;
}
pub unsafe extern "C" fn ftp_get(
    mut D: *mut CONN,
    mut U: URL,
    mut size: size_t,
) -> size_t {
    let mut n: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut bytes: size_t = 0;
    let mut file: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: ssize_t = 0;
    bytes = 0 as libc::c_int as size_t;
    tmp = xmalloc(size);
    file = tmp as *mut libc::c_char;
    memset(file as *mut libc::c_void, '\u{0}' as i32, size);
    loop {
        tmp___0 = socket_read(
            D,
            &mut c as *mut libc::c_char as *mut libc::c_void,
            1 as libc::c_int as size_t,
        );
        n = tmp___0 as libc::c_int;
        if n == 0 as libc::c_int {
            break;
        }
        *file.offset(bytes as isize) = c;
        bytes = (bytes as libc::c_ulong).wrapping_add(n as size_t) as size_t as size_t;
        if !(bytes < size) {
            break;
        }
    }
    if my.get as u64 != 0 {
        write_file(U, file, size);
    }
    xfree(file as *mut libc::c_void);
    return bytes;
}
pub unsafe extern "C" fn ftp_list(
    mut C: *mut CONN,
    mut D: *mut CONN,
    mut U: URL,
) -> BOOLEAN {
    let mut n: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut bytes: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: ssize_t = 0;
    tmp___3 = url_get_file(U);
    if tmp___3 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = url_get_path(U);
        tmp___2 = tmp___0;
    } else {
        tmp___1 = url_get_file(U);
        tmp___2 = tmp___1;
    }
    (*C)
        .ftp
        .code = __request___0(
        C,
        b"LIST %s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___2,
    );
    if (*C).ftp.code == 150 as libc::c_int {
        if (*D).sock < 1 as libc::c_int {
            NOTIFY(
                ERROR,
                b"unable to read from socket: %s:%d\0" as *const u8
                    as *const libc::c_char,
                ((*C).ftp.host).as_mut_ptr(),
                (*C).ftp.port,
            );
            return boolean_false;
        }
        loop {
            tmp___4 = socket_read(
                D,
                &mut c as *mut libc::c_char as *mut libc::c_void,
                1 as libc::c_int as size_t,
            );
            n = tmp___4 as libc::c_int;
            if n == 0 as libc::c_int {
                break;
            }
            if my.verbose as u64 != 0 {
                printf(b"%c\0" as *const u8 as *const libc::c_char, c as libc::c_int);
            }
            bytes += n;
        }
    }
    return boolean_true;
}
unsafe extern "C" fn __request___0(
    mut C: *mut CONN,
    mut fmt: *mut libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut code: libc::c_int = 0;
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut cmd: [libc::c_char; 1032] = [0; 1032];
    let mut len: size_t = 0;
    let mut n: size_t = 0;
    let mut ap: ::std::ffi::VaListImpl;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    code = 0 as libc::c_int;
    memset(
        buf.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
    );
    memset(
        cmd.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 1032]>() as libc::c_ulong,
    );
    ap = args.clone();
    vsnprintf(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        fmt as *const libc::c_char,
        ap.as_va_list(),
    );
    tmp = snprintf(
        cmd.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1032]>() as libc::c_ulong,
        b"%s\r\n\0" as *const u8 as *const libc::c_char,
        buf.as_mut_ptr(),
    );
    len = tmp as size_t;
    tmp___0 = socket_write(C, cmd.as_mut_ptr() as *const libc::c_void, len);
    n = tmp___0 as size_t;
    if n != len {
        NOTIFY(
            ERROR,
            b"FTP: unable to write to socket.\0" as *const u8 as *const libc::c_char,
        );
        code = 500 as libc::c_int;
    }
    tmp___1 = chomp(cmd.as_mut_ptr());
    debug(tmp___1 as *const libc::c_char);
    if code == 500 as libc::c_int {
        (*C).ftp.code = 500 as libc::c_int;
        return (*C).ftp.code;
    } else {
        (*C).ftp.code = __response(C);
        return (*C).ftp.code;
    };
}
unsafe extern "C" fn __response(mut C: *mut CONN) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut code: libc::c_int = 0;
    let mut cont: BOOLEAN = boolean_false;
    let mut x: libc::c_int = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    code = 120 as libc::c_int;
    cont = boolean_true;
    while cont as u64 != 0 {
        loop {
            x = 0 as libc::c_int;
            memset(
                ((*C).chkbuf).as_mut_ptr() as *mut libc::c_void,
                '\u{0}' as i32,
                ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            );
            loop {
                tmp = socket_read(
                    C,
                    &mut c as *mut libc::c_char as *mut libc::c_void,
                    1 as libc::c_int as size_t,
                );
                n = tmp as libc::c_int;
                if !(n == 1 as libc::c_int) {
                    break;
                }
                echo(b"%c\0" as *const u8 as *const libc::c_char, c as libc::c_int);
                (*C).chkbuf[x as usize] = c;
                if (*C).chkbuf[x as usize] as libc::c_int == 10 as libc::c_int {
                    break;
                }
                x += 1;
            }
            tmp___0 = __ctype_b_loc();
            if !(*(*tmp___0)
                .offset((*C).chkbuf[0 as libc::c_int as usize] as libc::c_int as isize)
                as libc::c_int & 2048 as libc::c_int != 0)
            {
                continue;
            }
            if (*C).chkbuf[3 as libc::c_int as usize] as libc::c_int != 45 as libc::c_int
            {
                break;
            }
        }
        code = __response_code(((*C).chkbuf).as_mut_ptr() as *const libc::c_char);
        if (*C).chkbuf[3 as libc::c_int as usize] as libc::c_int == 32 as libc::c_int {
            cont = boolean_false;
        }
    }
    if code > 499 as libc::c_int {
        if my.quiet as u64 == 0 {
            tmp___1 = chomp(((*C).chkbuf).as_mut_ptr());
            printf(b"%s\n\0" as *const u8 as *const libc::c_char, tmp___1);
        }
    }
    return code;
}
unsafe extern "C" fn __response_code(mut buf: *const libc::c_char) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut code: [libc::c_char; 4] = [0; 4];
    memset(
        code.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong,
    );
    strncpy(code.as_mut_ptr(), buf, 3 as libc::c_int as size_t);
    code[3 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    ret = atoi(code.as_mut_ptr() as *const libc::c_char);
    return ret;
}
unsafe extern "C" fn __in_range(
    mut code: libc::c_int,
    mut lower: libc::c_int,
    mut upper: libc::c_int,
) -> BOOLEAN {
    let mut tmp: libc::c_int = 0;
    if code >= lower {
        if code <= upper {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as BOOLEAN;
}
pub unsafe extern "C" fn spin_doctor(mut crew: CREW) {
    let mut x: libc::c_long = 0;
    let mut h: [libc::c_char; 4] = [0; 4];
    let mut tmp: libc::c_int = 0;
    h[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
    h[1 as libc::c_int as usize] = '\\' as i32 as libc::c_char;
    h[2 as libc::c_int as usize] = '|' as i32 as libc::c_char;
    h[3 as libc::c_int as usize] = '/' as i32 as libc::c_char;
    if my.spinner as libc::c_uint == 0 as libc::c_uint {
        return;
    }
    x = 0 as libc::c_long;
    loop {
        tmp = crew_get_total(crew);
        if !(tmp > 1 as libc::c_int) {
            if !(x < 55 as libc::c_long) {
                break;
            }
        }
        fflush(stderr);
        fprintf(
            stderr,
            b"%c\0" as *const u8 as *const libc::c_char,
            h[(x % 4 as libc::c_long) as usize] as libc::c_int,
        );
        pthread_usleep_np(20000 as libc::c_ulong);
        fprintf(stderr, b"\x08\0" as *const u8 as *const libc::c_char);
        x += 1;
    };
}
pub unsafe extern "C" fn sig_handler(mut crew: CREW) {
    let mut gotsig: libc::c_int = 0;
    let mut sigs: sigset_t = sigset_t { __val: [0; 16] };
    gotsig = 0 as libc::c_int;
    sigemptyset(&mut sigs);
    sigaddset(&mut sigs, 1 as libc::c_int);
    sigaddset(&mut sigs, 2 as libc::c_int);
    sigaddset(&mut sigs, 15 as libc::c_int);
    sigprocmask(
        0 as libc::c_int,
        &mut sigs as *mut sigset_t as *const sigset_t,
        0 as *mut libc::c_void as *mut sigset_t,
    );
    sigwait(
        &mut sigs as *mut sigset_t as *const sigset_t,
        &mut gotsig as *mut libc::c_int,
    );
    my.verbose = boolean_false;
    if my.quiet as u64 == 0 {
        fprintf(
            stderr,
            b"\nLifting the server siege...\0" as *const u8 as *const libc::c_char,
        );
    }
    crew_cancel(crew);
    pthread_usleep_np(501125 as libc::c_ulong);
    pthread_exit(0 as *mut libc::c_void);
}
pub static mut HASHSIZE: size_t = ::std::mem::size_of::<HASH_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_hash() -> HASH {
    let mut this: HASH = 0 as *mut HASH_T;
    let mut size: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    size = 10240 as libc::c_int;
    tmp = calloc(HASHSIZE, 1 as libc::c_int as size_t);
    this = tmp as HASH;
    (*this).size = size;
    (*this).entries = 0 as libc::c_int;
    (*this).index = 0 as libc::c_int;
    while (*this).size < size {
        (*this).size <<= 1 as libc::c_int;
    }
    tmp___0 = calloc(
        ((*this).size as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<*mut NODE___0>() as libc::c_ulong),
        1 as libc::c_int as size_t,
    );
    (*this).table = tmp___0 as *mut *mut NODE___0;
    (*this)
        .free = ::std::mem::transmute::<
        *mut libc::c_void,
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    >(0 as *mut libc::c_void);
    return this;
}
pub unsafe extern "C" fn hash_size(mut this: HASH) -> libc::c_int {
    return (*this).entries;
}
pub unsafe extern "C" fn hash_reset(mut this: HASH, mut size: ssize_t) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    (*this).size = 2 as libc::c_int;
    (*this).entries = 0 as libc::c_int;
    while ((*this).size as ssize_t) < size {
        (*this).size <<= 1 as libc::c_int;
    }
    tmp = calloc(
        ((*this).size as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<*mut NODE___0>() as libc::c_ulong),
        1 as libc::c_int as size_t,
    );
    (*this).table = tmp as *mut *mut NODE___0;
}
pub unsafe extern "C" fn hash_add(
    mut this: HASH,
    mut key: *mut libc::c_char,
    mut val: *mut libc::c_void,
) {
    let mut len: size_t = 0;
    let mut tmp: BOOLEAN = boolean_false;
    len = 0 as libc::c_int as size_t;
    tmp = __lookup(this, key);
    if tmp as libc::c_uint == 1 as libc::c_uint {
        return;
    }
    len = strlen(val as *const libc::c_char);
    hash_nadd(this, key, val, len);
}
pub unsafe extern "C" fn hash_nadd(
    mut this: HASH,
    mut key: *mut libc::c_char,
    mut val: *mut libc::c_void,
    mut len: size_t,
) {
    let mut x: libc::c_int = 0;
    let mut node: *mut NODE___0 = 0 as *mut NODE___0;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = __lookup(this, key);
    if tmp as libc::c_uint == 1 as libc::c_uint {
        return;
    }
    if (*this).entries >= (*this).size / 4 as libc::c_int {
        __resize(this);
    }
    tmp___0 = __genkey((*this).size, key);
    x = tmp___0 as libc::c_int;
    tmp___1 = xmalloc(::std::mem::size_of::<NODE___0>() as libc::c_ulong);
    node = tmp___1 as *mut NODE___0;
    (*node).key = strdup(key as *const libc::c_char);
    (*node).val = xmalloc(len.wrapping_add(1 as libc::c_ulong));
    memset((*node).val, '\u{0}' as i32, len.wrapping_add(1 as libc::c_ulong));
    memcpy((*node).val, val as *const libc::c_void, len);
    (*node).next = *((*this).table).offset(x as isize);
    let ref mut fresh5 = *((*this).table).offset(x as isize);
    *fresh5 = node;
    (*this).entries += 1;
}
pub unsafe extern "C" fn hash_get(
    mut this: HASH,
    mut key: *mut libc::c_char,
) -> *mut libc::c_void {
    let mut x: libc::c_int = 0;
    let mut node: *mut NODE___0 = 0 as *mut NODE___0;
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = __genkey((*this).size, key);
    x = tmp as libc::c_int;
    node = *((*this).table).offset(x as isize);
    while node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = strcmp((*node).key as *const libc::c_char, key as *const libc::c_char);
        if tmp___0 == 0 {
            return (*node).val;
        }
        node = (*node).next;
    }
    return 0 as *mut libc::c_void;
}
pub unsafe extern "C" fn hash_remove(mut this: HASH, mut key: *mut libc::c_char) {
    let mut x: libc::c_int = 0;
    let mut n1: *mut NODE___0 = 0 as *mut NODE___0;
    let mut n2: *mut NODE___0 = 0 as *mut NODE___0;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: libc::c_uint = 0;
    x = 0 as libc::c_int;
    n1 = 0 as *mut libc::c_void as *mut NODE___0;
    n2 = 0 as *mut libc::c_void as *mut NODE___0;
    tmp = __lookup(this, key);
    if tmp as libc::c_uint == 0 as libc::c_uint {
        return;
    }
    if ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        libc::c_ulong,
    >((*this).free) == 0 as *mut libc::c_void as libc::c_ulong
    {
        (*this).free = Some(free as unsafe extern "C" fn(*mut libc::c_void) -> ());
    }
    tmp___0 = __genkey((*this).size, key);
    x = tmp___0 as libc::c_int;
    n1 = *((*this).table).offset(x as isize);
    while n1 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        n2 = (*n1).next;
        if (*n1).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            xfree((*n1).key as *mut libc::c_void);
            (*this).entries -= 1;
        }
        if (*n1).val as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            (Some(((*this).free).expect("non-null function pointer")))
                .expect("non-null function pointer")((*n1).val);
        }
        xfree(n1 as *mut libc::c_void);
        n1 = n2;
    }
    let ref mut fresh6 = *((*this).table).offset(x as isize);
    *fresh6 = 0 as *mut libc::c_void as *mut NODE___0;
}
pub unsafe extern "C" fn hash_remover(
    mut this: HASH,
    mut key: *mut libc::c_char,
    mut m: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    (*this).free = m;
    hash_remove(this, key);
}
pub unsafe extern "C" fn hash_set_destroyer(
    mut this: HASH,
    mut m: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    (*this).free = m;
}
pub unsafe extern "C" fn hash_contains(
    mut this: HASH,
    mut key: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    tmp = __lookup(this, key);
    return tmp;
}
pub unsafe extern "C" fn hash_get_keys(mut this: HASH) -> *mut *mut libc::c_char {
    let mut x: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut node: *mut NODE___0 = 0 as *mut NODE___0;
    let mut keys___0: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut len: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    i = 0 as libc::c_int;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut *mut libc::c_char
    } else {
        if (*this).entries == 0 as libc::c_int {
            return 0 as *mut libc::c_void as *mut *mut libc::c_char;
        }
    }
    tmp = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            .wrapping_mul((*this).entries as libc::c_ulong),
    );
    keys___0 = tmp as *mut *mut libc::c_char;
    x = 0 as libc::c_int;
    while x < (*this).size {
        node = *((*this).table).offset(x as isize);
        while node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = strlen((*node).key as *const libc::c_char);
            len = tmp___0.wrapping_add(1 as libc::c_ulong);
            tmp___1 = malloc(len);
            let ref mut fresh7 = *keys___0.offset(i as isize);
            *fresh7 = tmp___1 as *mut libc::c_char;
            memset(
                *keys___0.offset(i as isize) as *mut libc::c_void,
                '\u{0}' as i32,
                len,
            );
            tmp___2 = strlen((*node).key as *const libc::c_char);
            memcpy(
                *keys___0.offset(i as isize) as *mut libc::c_void,
                (*node).key as *const libc::c_void,
                tmp___2,
            );
            i += 1;
            node = (*node).next;
        }
        x += 1;
    }
    return keys___0;
}
pub unsafe extern "C" fn hash_free_keys(
    mut this: HASH,
    mut keys___0: *mut *mut libc::c_char,
) {
    let mut x: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    x = 0 as libc::c_int;
    while x < (*this).entries {
        if *keys___0.offset(x as isize) as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp = *keys___0.offset(x as isize);
            xfree(tmp as *mut libc::c_void);
        }
        x += 1;
    }
    xfree(keys___0 as *mut libc::c_void);
}
pub unsafe extern "C" fn hash_destroy(mut this: HASH) -> HASH {
    let mut x: libc::c_int = 0;
    let mut t1: *mut NODE___0 = 0 as *mut NODE___0;
    let mut t2: *mut NODE___0 = 0 as *mut NODE___0;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return this;
    }
    if ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        libc::c_ulong,
    >((*this).free) == 0 as *mut libc::c_void as libc::c_ulong
    {
        (*this).free = Some(free as unsafe extern "C" fn(*mut libc::c_void) -> ());
    }
    x = 0 as libc::c_int;
    while x < (*this).size {
        t1 = *((*this).table).offset(x as isize);
        while t1 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            t2 = (*t1).next;
            if (*t1).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                xfree((*t1).key as *mut libc::c_void);
            }
            if (*t1).val as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                (Some(((*this).free).expect("non-null function pointer")))
                    .expect("non-null function pointer")((*t1).val);
            }
            xfree(t1 as *mut libc::c_void);
            t1 = t2;
        }
        let ref mut fresh8 = *((*this).table).offset(x as isize);
        *fresh8 = 0 as *mut libc::c_void as *mut NODE___0;
        x += 1;
    }
    if (*this).table as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        xfree((*this).table as *mut libc::c_void);
        memset(
            this as *mut libc::c_void,
            '\u{0}' as i32,
            ::std::mem::size_of::<HASH_T>() as libc::c_ulong,
        );
    }
    xfree(this as *mut libc::c_void);
    return 0 as *mut libc::c_void as HASH;
}
pub unsafe extern "C" fn hash_destroyer(
    mut this: HASH,
    mut m: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) -> HASH {
    let mut tmp: HASH = 0 as *mut HASH_T;
    (*this).free = m;
    tmp = hash_destroy(this);
    return tmp;
}
pub unsafe extern "C" fn hash_get_entries(mut this: HASH) -> libc::c_int {
    return (*this).entries;
}
unsafe extern "C" fn __resize(mut this: HASH) {
    let mut tmp: *mut NODE___0 = 0 as *mut NODE___0;
    let mut last_node: *mut NODE___0 = 0 as *mut NODE___0;
    let mut last_table: *mut *mut NODE___0 = 0 as *mut *mut NODE___0;
    let mut x: libc::c_int = 0;
    let mut hash: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut tmp___0: libc::c_uint = 0;
    size = (*this).size;
    last_table = (*this).table;
    hash_reset(this, (size * 2 as libc::c_int) as ssize_t);
    x = 0 as libc::c_int;
    while x < size {
        last_node = *last_table.offset(x as isize);
        while last_node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp = last_node;
            last_node = (*last_node).next;
            tmp___0 = __genkey((*this).size, (*tmp).key);
            hash = tmp___0 as libc::c_int;
            (*tmp).next = *((*this).table).offset(hash as isize);
            let ref mut fresh9 = *((*this).table).offset(hash as isize);
            *fresh9 = tmp;
            (*this).entries += 1;
        }
        x += 1;
    }
}
unsafe extern "C" fn fnv_32_buf(
    mut buf: *mut libc::c_void,
    mut len: size_t,
    mut hval: libc::c_uint,
) -> libc::c_uint {
    let mut bp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut be: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tmp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    bp = buf as *mut libc::c_uchar;
    be = bp.offset(len as isize);
    while (bp as libc::c_ulong) < be as libc::c_ulong {
        tmp = bp;
        bp = bp.offset(1);
        hval ^= *tmp as u_int32_t;
        hval = hval
            .wrapping_add(
                (hval << 1 as libc::c_int)
                    .wrapping_add(hval << 4 as libc::c_int)
                    .wrapping_add(hval << 7 as libc::c_int)
                    .wrapping_add(hval << 8 as libc::c_int)
                    .wrapping_add(hval << 24 as libc::c_int),
            );
    }
    return hval;
}
unsafe extern "C" fn __genkey(
    mut size: libc::c_int,
    mut str: *mut libc::c_char,
) -> libc::c_uint {
    let mut hash: libc::c_uint = 0;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp: size_t = 0;
    data = str as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    hash = fnv_32_buf(data, tmp, 2166136261 as libc::c_uint);
    hash = hash.wrapping_rem(size as libc::c_uint);
    return hash;
}
unsafe extern "C" fn __lookup(mut this: HASH, mut key: *mut libc::c_char) -> BOOLEAN {
    let mut x: libc::c_int = 0;
    let mut node: *mut NODE___0 = 0 as *mut NODE___0;
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: libc::c_int = 0;
    if key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_false;
    }
    tmp = __genkey((*this).size, key);
    x = tmp as libc::c_int;
    node = *((*this).table).offset(x as isize);
    while node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = strcmp((*node).key as *const libc::c_char, key as *const libc::c_char);
        if tmp___0 == 0 {
            return boolean_true;
        }
        node = (*node).next;
    }
    return boolean_false;
}
pub static mut __mutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
    __data: {
        let mut init = __pthread_mutex_s {
            __lock: 0 as libc::c_int,
            __count: 0 as libc::c_uint,
            __owner: 0 as libc::c_int,
            __nusers: 0 as libc::c_uint,
            __kind: 0 as libc::c_int,
            __spins: 0 as libc::c_int as libc::c_short,
            __elision: 0 as libc::c_int as libc::c_short,
            __list: {
                let mut init = __pthread_internal_list {
                    __prev: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                };
                init
            },
        };
        init
    },
};
pub static mut __cond: pthread_cond_t = __anonunion_pthread_cond_t_951761805 {
    __data: {
        let mut init = __pthread_cond_s {
            __annonCompField1: __anonunion____missing_field_name_236290450 {
                __wseq: 0 as libc::c_ulonglong,
            },
            __annonCompField2: __anonunion____missing_field_name_958857992 {
                __g1_start: 0 as libc::c_ulonglong,
            },
            __g_refs: [0 as libc::c_uint, 0 as libc::c_uint],
            __g_size: [0 as libc::c_uint, 0 as libc::c_uint],
            __g1_orig_size: 0 as libc::c_uint,
            __wrefs: 0 as libc::c_uint,
            __g_signals: [0 as libc::c_uint, 0 as libc::c_uint],
        };
        init
    },
};
pub unsafe extern "C" fn https_tunnel_request(
    mut C: *mut CONN,
    mut host: *mut libc::c_char,
    mut port: libc::c_int,
) -> BOOLEAN {
    let mut rlen: size_t = 0;
    let mut n: size_t = 0;
    let mut request: [libc::c_char; 256] = [0; 256];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: BOOLEAN = boolean_false;
    if (*C).encrypt as libc::c_uint == 1 as libc::c_uint {
        tmp___0 = auth_get_proxy_required(my.auth);
        if tmp___0 as u64 != 0 {
            snprintf(
                request.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"CONNECT %s:%d HTTP/1.0\r\nUser-agent: Proxy-User\r\n\r\n\0"
                    as *const u8 as *const libc::c_char,
                host,
                port,
            );
            rlen = strlen(request.as_mut_ptr() as *const libc::c_char);
            echo(b"%s\0" as *const u8 as *const libc::c_char, request.as_mut_ptr());
            (*C).encrypt = boolean_false;
            tmp = socket_write(C, request.as_mut_ptr() as *const libc::c_void, rlen);
            n = tmp as size_t;
            if n != rlen {
                NOTIFY(
                    ERROR,
                    b"HTTP: unable to write to socket.\0" as *const u8
                        as *const libc::c_char,
                );
                return boolean_false;
            }
        } else {
            return boolean_false
        }
    } else {
        return boolean_false
    }
    return boolean_true;
}
pub unsafe extern "C" fn https_tunnel_response(mut C: *mut CONN) -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut line: [libc::c_char; 256] = [0; 256];
    let mut code: libc::c_int = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: libc::c_int = 0;
    code = 100 as libc::c_int;
    loop {
        x = 0 as libc::c_int;
        memset(
            &mut line as *mut [libc::c_char; 256] as *mut libc::c_void,
            '\u{0}' as i32,
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        );
        loop {
            tmp = read(
                (*C).sock,
                &mut c as *mut libc::c_char as *mut libc::c_void,
                1 as libc::c_int as size_t,
            );
            n = tmp as libc::c_int;
            if !(n == 1 as libc::c_int) {
                break;
            }
            line[x as usize] = c;
            echo(b"%c\0" as *const u8 as *const libc::c_char, c as libc::c_int);
            if line[0 as libc::c_int as usize] as libc::c_int == 10 as libc::c_int {
                return code
            } else {
                if line[1 as libc::c_int as usize] as libc::c_int == 10 as libc::c_int {
                    return code;
                }
            }
            if line[x as usize] as libc::c_int == 10 as libc::c_int {
                break;
            }
            x += 1;
        }
        line[x as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"http\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
        if tmp___0 == 0 as libc::c_int {
            code = atoi(
                line.as_mut_ptr().offset(9 as libc::c_int as isize)
                    as *const libc::c_char,
            );
        }
    };
}
pub unsafe extern "C" fn http_get(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut current_block: u64;
    let mut rlen: size_t = 0;
    let mut mlen: size_t = 0;
    let mut protocol: [libc::c_char; 16] = [0; 16];
    let mut keepalive: [libc::c_char; 16] = [0; 16];
    let mut hoststr: [libc::c_char; 512] = [0; 512];
    let mut authwww: [libc::c_char; 512] = [0; 512];
    let mut authpxy: [libc::c_char; 512] = [0; 512];
    let mut accept___0: [libc::c_char; 14] = [0; 14];
    let mut encoding: [libc::c_char; 512] = [0; 512];
    let mut request: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut portstr: [libc::c_char; 16] = [0; 16];
    let mut fullpath: [libc::c_char; 8192] = [0; 8192];
    let mut cookie: [libc::c_char; 4104] = [0; 4104];
    let mut ifnon: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ifmod: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___20: libc::c_int = 0;
    let mut tmp___21: SCHEME = UNSUPPORTED;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: SCHEME = UNSUPPORTED;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: size_t = 0;
    let mut tmp___28: size_t = 0;
    let mut tmp___29: size_t = 0;
    let mut tmp___30: size_t = 0;
    let mut tmp___31: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___32: size_t = 0;
    let mut tmp___33: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___34: size_t = 0;
    let mut tmp___35: size_t = 0;
    let mut tmp___36: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___37: size_t = 0;
    let mut tmp___38: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___39: size_t = 0;
    let mut tmp___41: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___42: libc::c_int = 0;
    let mut tmp___43: size_t = 0;
    let mut tmp___44: size_t = 0;
    let mut tmp___45: size_t = 0;
    let mut tmp___46: size_t = 0;
    let mut tmp___47: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___49: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___50: libc::c_int = 0;
    let mut tmp___51: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___52: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___54: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___55: size_t = 0;
    let mut tmp___56: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___57: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___58: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___59: libc::c_int = 0;
    let mut tmp___60: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___61: libc::c_int = 0;
    accept___0[0 as libc::c_int as usize] = 'A' as i32 as libc::c_char;
    accept___0[1 as libc::c_int as usize] = 'c' as i32 as libc::c_char;
    accept___0[2 as libc::c_int as usize] = 'c' as i32 as libc::c_char;
    accept___0[3 as libc::c_int as usize] = 'e' as i32 as libc::c_char;
    accept___0[4 as libc::c_int as usize] = 'p' as i32 as libc::c_char;
    accept___0[5 as libc::c_int as usize] = 't' as i32 as libc::c_char;
    accept___0[6 as libc::c_int as usize] = ':' as i32 as libc::c_char;
    accept___0[7 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    accept___0[8 as libc::c_int as usize] = '*' as i32 as libc::c_char;
    accept___0[9 as libc::c_int as usize] = '/' as i32 as libc::c_char;
    accept___0[10 as libc::c_int as usize] = '*' as i32 as libc::c_char;
    accept___0[11 as libc::c_int as usize] = '\r' as i32 as libc::c_char;
    accept___0[12 as libc::c_int as usize] = '\n' as i32 as libc::c_char;
    accept___0[13 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    ifnon = 0 as *mut libc::c_void as *mut libc::c_char;
    ifmod = 0 as *mut libc::c_void as *mut libc::c_char;
    memset(
        hoststr.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
    );
    memset(
        cookie.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 4104]>() as libc::c_ulong,
    );
    memset(
        portstr.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    ifnon = cache_get_header((*C).cache, C_ETAG, U);
    ifmod = cache_get_header((*C).cache, C_LAST, U);
    tmp___4 = auth_get_proxy_required(my.auth);
    if tmp___4 as u64 != 0 {
        tmp = url_get_request(U);
        tmp___0 = url_get_port(U);
        tmp___1 = url_get_hostname(U);
        if (*C).encrypt as libc::c_uint == 0 as libc::c_uint {
            tmp___2 = b"http\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___2 = b"https\0" as *const u8 as *const libc::c_char;
        }
        sprintf(
            fullpath.as_mut_ptr(),
            b"%s://%s:%d%s\0" as *const u8 as *const libc::c_char,
            tmp___2,
            tmp___1,
            tmp___0,
            tmp,
        );
    } else {
        tmp___3 = url_get_request(U);
        sprintf(
            fullpath.as_mut_ptr(),
            b"%s\0" as *const u8 as *const libc::c_char,
            tmp___3,
        );
    }
    tmp___6 = url_get_port(U);
    let mut current_block_50: u64;
    if tmp___6 == 80 as libc::c_int {
        if (*C).encrypt as libc::c_uint == 0 as libc::c_uint {
            portstr[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            current_block_50 = 4216521074440650966;
        } else {
            current_block_50 = 2144008619253247284;
        }
    } else {
        current_block_50 = 2144008619253247284;
    }
    match current_block_50 {
        2144008619253247284 => {
            tmp___7 = url_get_port(U);
            if tmp___7 == 443 as libc::c_int {
                if (*C).encrypt as libc::c_uint == 0 as libc::c_uint {
                    portstr[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
                } else {
                    tmp___5 = url_get_port(U);
                    snprintf(
                        portstr.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
                        b":%d\0" as *const u8 as *const libc::c_char,
                        tmp___5,
                    );
                }
            } else {
                tmp___5 = url_get_port(U);
                snprintf(
                    portstr.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
                    b":%d\0" as *const u8 as *const libc::c_char,
                    tmp___5,
                );
            }
        }
        _ => {}
    }
    if my.protocol == 0 as libc::c_int {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
        );
    } else if my.get as libc::c_uint == 1 as libc::c_uint {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
        );
    } else if my.print as libc::c_uint == 1 as libc::c_uint {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
        );
    } else {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.1\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*C).connection.keepalive == 1 as libc::c_int {
        snprintf(
            keepalive.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"keep-alive\0" as *const u8 as *const libc::c_char,
        );
    } else {
        snprintf(
            keepalive.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"close\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___8 = url_get_hostname(U);
    cookies_header(my.cookies, tmp___8, cookie.as_mut_ptr());
    if (*C).auth.www != 0 {
        if (*C).auth.type_0.www as libc::c_uint == 1 as libc::c_uint {
            tmp___9 = url_get_method_name(U);
            tmp___10 = auth_get_digest_header(
                my.auth,
                HTTP,
                (*C).auth.wchlg,
                (*C).auth.wcred,
                tmp___9 as *const libc::c_char,
                fullpath.as_mut_ptr() as *const libc::c_char,
            );
            snprintf(
                authwww.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___10,
            );
        } else if (*C).auth.type_0.www as libc::c_uint == 2 as libc::c_uint {
            tmp___11 = auth_get_ntlm_header(my.auth, HTTP);
            snprintf(
                authwww.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___11,
            );
        } else {
            tmp___12 = auth_get_basic_header(my.auth, HTTP);
            snprintf(
                authwww.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___12,
            );
        }
    }
    if (*C).auth.proxy != 0 {
        if (*C).auth.type_0.proxy as libc::c_uint == 1 as libc::c_uint {
            tmp___13 = url_get_method_name(U);
            tmp___14 = auth_get_digest_header(
                my.auth,
                PROXY,
                (*C).auth.pchlg,
                (*C).auth.pcred,
                tmp___13 as *const libc::c_char,
                fullpath.as_mut_ptr() as *const libc::c_char,
            );
            snprintf(
                authpxy.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___14,
            );
        } else {
            tmp___15 = auth_get_basic_header(my.auth, PROXY);
            snprintf(
                authpxy.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___15,
            );
        }
    }
    tmp___25 = strncasestr(
        (my.extra).as_mut_ptr() as *const libc::c_char,
        b"host:\0" as *const u8 as *const libc::c_char,
        ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong,
    );
    if tmp___25 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___21 = url_get_scheme(U);
        let mut current_block_119: u64;
        if tmp___21 as libc::c_uint == 1 as libc::c_uint {
            tmp___22 = url_get_port(U);
            if tmp___22 != 80 as libc::c_int {
                tmp___16 = url_get_port(U);
                tmp___17 = url_get_hostname(U);
                tmp___18 = snprintf(
                    hoststr.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                    b"Host: %s:%d\r\n\0" as *const u8 as *const libc::c_char,
                    tmp___17,
                    tmp___16,
                );
                rlen = tmp___18 as size_t;
                current_block_119 = 7728257318064351663;
            } else {
                current_block_119 = 2115059989954276174;
            }
        } else {
            current_block_119 = 2115059989954276174;
        }
        match current_block_119 {
            2115059989954276174 => {
                tmp___23 = url_get_scheme(U);
                if tmp___23 as libc::c_uint == 2 as libc::c_uint {
                    tmp___24 = url_get_port(U);
                    if tmp___24 != 443 as libc::c_int {
                        tmp___16 = url_get_port(U);
                        tmp___17 = url_get_hostname(U);
                        tmp___18 = snprintf(
                            hoststr.as_mut_ptr(),
                            ::std::mem::size_of::<[libc::c_char; 512]>()
                                as libc::c_ulong,
                            b"Host: %s:%d\r\n\0" as *const u8 as *const libc::c_char,
                            tmp___17,
                            tmp___16,
                        );
                        rlen = tmp___18 as size_t;
                    } else {
                        tmp___19 = url_get_hostname(U);
                        tmp___20 = snprintf(
                            hoststr.as_mut_ptr(),
                            ::std::mem::size_of::<[libc::c_char; 512]>()
                                as libc::c_ulong,
                            b"Host: %s\r\n\0" as *const u8 as *const libc::c_char,
                            tmp___19,
                        );
                        rlen = tmp___20 as size_t;
                    }
                } else {
                    tmp___19 = url_get_hostname(U);
                    tmp___20 = snprintf(
                        hoststr.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                        b"Host: %s\r\n\0" as *const u8 as *const libc::c_char,
                        tmp___19,
                    );
                    rlen = tmp___20 as size_t;
                }
            }
            _ => {}
        }
    }
    tmp___26 = url_get_method_name(U);
    tmp___27 = strlen(tmp___26 as *const libc::c_char);
    tmp___28 = strlen(fullpath.as_mut_ptr() as *const libc::c_char);
    tmp___29 = strlen(protocol.as_mut_ptr() as *const libc::c_char);
    tmp___30 = strlen(hoststr.as_mut_ptr() as *const libc::c_char);
    if (*C).auth.www == 1 as libc::c_int {
        tmp___31 = authwww.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___31 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___32 = strlen(tmp___31);
    if (*C).auth.proxy == 1 as libc::c_int {
        tmp___33 = authpxy.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___33 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___34 = strlen(tmp___33);
    tmp___35 = strlen(cookie.as_mut_ptr() as *const libc::c_char);
    if ifmod as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___36 = ifmod as *const libc::c_char;
    } else {
        tmp___36 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___37 = strlen(tmp___36);
    if ifnon as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___38 = ifnon as *const libc::c_char;
    } else {
        tmp___38 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___39 = strlen(tmp___38);
    tmp___42 = strncasecmp(
        (my.extra).as_mut_ptr() as *const libc::c_char,
        b"Accept:\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as size_t,
    );
    if tmp___42 == 0 as libc::c_int {
        tmp___41 = b"\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___41 = accept___0.as_mut_ptr() as *const libc::c_char;
    }
    tmp___43 = strlen(tmp___41);
    tmp___44 = strlen((my.uagent).as_mut_ptr() as *const libc::c_char);
    tmp___45 = strlen((my.extra).as_mut_ptr() as *const libc::c_char);
    tmp___46 = strlen(keepalive.as_mut_ptr() as *const libc::c_char);
    mlen = tmp___27
        .wrapping_add(tmp___28)
        .wrapping_add(tmp___29)
        .wrapping_add(tmp___30)
        .wrapping_add(tmp___32)
        .wrapping_add(tmp___34)
        .wrapping_add(tmp___35)
        .wrapping_add(tmp___37)
        .wrapping_add(tmp___39)
        .wrapping_add(tmp___43)
        .wrapping_add(::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong)
        .wrapping_add(tmp___44)
        .wrapping_add(tmp___45)
        .wrapping_add(tmp___46)
        .wrapping_add(128 as libc::c_ulong);
    tmp___47 = xmalloc(mlen);
    request = tmp___47 as *mut libc::c_char;
    memset(request as *mut libc::c_void, '\u{0}' as i32, mlen);
    memset(
        encoding.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
    );
    if my.get as u64 == 0 {
        snprintf(
            encoding.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"Accept-Encoding: %s\r\n\0" as *const u8 as *const libc::c_char,
            (my.encoding).as_mut_ptr(),
        );
    } else if my.print as u64 == 0 {
        snprintf(
            encoding.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"Accept-Encoding: %s\r\n\0" as *const u8 as *const libc::c_char,
            (my.encoding).as_mut_ptr(),
        );
    }
    tmp___50 = strncasecmp(
        (my.extra).as_mut_ptr() as *const libc::c_char,
        b"Accept:\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as size_t,
    );
    if tmp___50 == 0 as libc::c_int {
        tmp___49 = b"\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___49 = accept___0.as_mut_ptr() as *const libc::c_char;
    }
    if ifnon as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___51 = ifnon as *const libc::c_char;
    } else {
        tmp___51 = b"\0" as *const u8 as *const libc::c_char;
    }
    if ifmod as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___52 = ifmod as *const libc::c_char;
    } else {
        tmp___52 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___55 = strlen(cookie.as_mut_ptr() as *const libc::c_char);
    if tmp___55 > 8 as libc::c_ulong {
        tmp___54 = cookie.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___54 = b"\0" as *const u8 as *const libc::c_char;
    }
    if (*C).auth.proxy == 1 as libc::c_int {
        tmp___56 = authpxy.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___56 = b"\0" as *const u8 as *const libc::c_char;
    }
    if (*C).auth.www == 1 as libc::c_int {
        tmp___57 = authwww.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___57 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___58 = url_get_method_name(U);
    tmp___59 = snprintf(
        request,
        mlen,
        b"%s %s %s\r\n%s%s%s%s%s%s%s%sUser-Agent: %s\r\n%sConnection: %s\r\n\r\n\0"
            as *const u8 as *const libc::c_char,
        tmp___58,
        fullpath.as_mut_ptr(),
        protocol.as_mut_ptr(),
        hoststr.as_mut_ptr(),
        tmp___57,
        tmp___56,
        tmp___54,
        tmp___52,
        tmp___51,
        tmp___49,
        encoding.as_mut_ptr(),
        (my.uagent).as_mut_ptr(),
        (my.extra).as_mut_ptr(),
        keepalive.as_mut_ptr(),
    );
    rlen = tmp___59 as size_t;
    if my.debug as u64 != 0 {
        current_block = 16414345147833781046;
    } else if my.get as u64 != 0 {
        current_block = 16414345147833781046;
    } else if my.print as u64 != 0 {
        current_block = 16414345147833781046;
    } else {
        current_block = 4755552050407867010;
    }
    match current_block {
        16414345147833781046 => {
            if my.quiet as u64 == 0 {
                printf(b"%s\n\0" as *const u8 as *const libc::c_char, request);
                fflush(stdout);
            }
        }
        _ => {}
    }
    if rlen == 0 as libc::c_ulong {
        tmp___60 = url_get_method_name(U);
        NOTIFY(
            FATAL,
            b"HTTP %s: request buffer overrun!\0" as *const u8 as *const libc::c_char,
            tmp___60,
        );
    } else if rlen > mlen {
        tmp___60 = url_get_method_name(U);
        NOTIFY(
            FATAL,
            b"HTTP %s: request buffer overrun!\0" as *const u8 as *const libc::c_char,
            tmp___60,
        );
    }
    tmp___61 = socket_write(C, request as *const libc::c_void, rlen);
    if tmp___61 < 0 as libc::c_int {
        xfree(ifmod as *mut libc::c_void);
        xfree(ifnon as *mut libc::c_void);
        return boolean_false;
    }
    xfree(ifmod as *mut libc::c_void);
    xfree(ifnon as *mut libc::c_void);
    xfree(request as *mut libc::c_void);
    return boolean_true;
}
pub unsafe extern "C" fn http_post(mut C: *mut CONN, mut U: URL) -> BOOLEAN {
    let mut rlen: size_t = 0;
    let mut mlen: size_t = 0;
    let mut hoststr: [libc::c_char; 128] = [0; 128];
    let mut authwww: [libc::c_char; 128] = [0; 128];
    let mut authpxy: [libc::c_char; 128] = [0; 128];
    let mut accept___0: [libc::c_char; 14] = [0; 14];
    let mut encoding: [libc::c_char; 512] = [0; 512];
    let mut request: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut portstr: [libc::c_char; 16] = [0; 16];
    let mut protocol: [libc::c_char; 16] = [0; 16];
    let mut keepalive: [libc::c_char; 16] = [0; 16];
    let mut cookie: [libc::c_char; 4096] = [0; 4096];
    let mut fullpath: [libc::c_char; 8192] = [0; 8192];
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___20: libc::c_int = 0;
    let mut tmp___21: SCHEME = UNSUPPORTED;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: SCHEME = UNSUPPORTED;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: size_t = 0;
    let mut tmp___28: size_t = 0;
    let mut tmp___29: size_t = 0;
    let mut tmp___30: size_t = 0;
    let mut tmp___31: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___32: size_t = 0;
    let mut tmp___33: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___34: size_t = 0;
    let mut tmp___35: size_t = 0;
    let mut tmp___37: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___38: libc::c_int = 0;
    let mut tmp___39: size_t = 0;
    let mut tmp___40: size_t = 0;
    let mut tmp___41: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___42: size_t = 0;
    let mut tmp___43: size_t = 0;
    let mut tmp___44: size_t = 0;
    let mut tmp___45: size_t = 0;
    let mut tmp___46: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___47: size_t = 0;
    let mut tmp___48: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___50: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___51: libc::c_int = 0;
    let mut tmp___53: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___54: size_t = 0;
    let mut tmp___55: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___56: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___57: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___58: libc::c_int = 0;
    let mut tmp___59: size_t = 0;
    let mut tmp___60: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___61: size_t = 0;
    let mut tmp___62: size_t = 0;
    let mut tmp___63: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___64: libc::c_int = 0;
    accept___0[0 as libc::c_int as usize] = 'A' as i32 as libc::c_char;
    accept___0[1 as libc::c_int as usize] = 'c' as i32 as libc::c_char;
    accept___0[2 as libc::c_int as usize] = 'c' as i32 as libc::c_char;
    accept___0[3 as libc::c_int as usize] = 'e' as i32 as libc::c_char;
    accept___0[4 as libc::c_int as usize] = 'p' as i32 as libc::c_char;
    accept___0[5 as libc::c_int as usize] = 't' as i32 as libc::c_char;
    accept___0[6 as libc::c_int as usize] = ':' as i32 as libc::c_char;
    accept___0[7 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
    accept___0[8 as libc::c_int as usize] = '*' as i32 as libc::c_char;
    accept___0[9 as libc::c_int as usize] = '/' as i32 as libc::c_char;
    accept___0[10 as libc::c_int as usize] = '*' as i32 as libc::c_char;
    accept___0[11 as libc::c_int as usize] = '\r' as i32 as libc::c_char;
    accept___0[12 as libc::c_int as usize] = '\n' as i32 as libc::c_char;
    accept___0[13 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    memset(
        hoststr.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
    );
    memset(
        cookie.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        4096 as libc::c_int as size_t,
    );
    memset(
        portstr.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    memset(
        protocol.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    memset(
        keepalive.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    tmp___4 = auth_get_proxy_required(my.auth);
    if tmp___4 as u64 != 0 {
        tmp = url_get_request(U);
        tmp___0 = url_get_port(U);
        tmp___1 = url_get_hostname(U);
        if (*C).encrypt as libc::c_uint == 0 as libc::c_uint {
            tmp___2 = b"http\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___2 = b"https\0" as *const u8 as *const libc::c_char;
        }
        sprintf(
            fullpath.as_mut_ptr(),
            b"%s://%s:%d%s\0" as *const u8 as *const libc::c_char,
            tmp___2,
            tmp___1,
            tmp___0,
            tmp,
        );
    } else {
        tmp___3 = url_get_request(U);
        sprintf(
            fullpath.as_mut_ptr(),
            b"%s\0" as *const u8 as *const libc::c_char,
            tmp___3,
        );
    }
    tmp___6 = url_get_port(U);
    let mut current_block_48: u64;
    if tmp___6 == 80 as libc::c_int {
        if (*C).encrypt as libc::c_uint == 0 as libc::c_uint {
            portstr[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            current_block_48 = 16779030619667747692;
        } else {
            current_block_48 = 15280727578987400477;
        }
    } else {
        current_block_48 = 15280727578987400477;
    }
    match current_block_48 {
        15280727578987400477 => {
            tmp___7 = url_get_port(U);
            if tmp___7 == 443 as libc::c_int {
                if (*C).encrypt as libc::c_uint == 1 as libc::c_uint {
                    portstr[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
                } else {
                    tmp___5 = url_get_port(U);
                    snprintf(
                        portstr.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
                        b":%d\0" as *const u8 as *const libc::c_char,
                        tmp___5,
                    );
                }
            } else {
                tmp___5 = url_get_port(U);
                snprintf(
                    portstr.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
                    b":%d\0" as *const u8 as *const libc::c_char,
                    tmp___5,
                );
            }
        }
        _ => {}
    }
    if my.protocol == 0 as libc::c_int {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
        );
    } else if my.get as libc::c_uint == 1 as libc::c_uint {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
        );
    } else if my.print as libc::c_uint == 1 as libc::c_uint {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
        );
    } else {
        snprintf(
            protocol.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"HTTP/1.1\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*C).connection.keepalive == 1 as libc::c_int {
        snprintf(
            keepalive.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"keep-alive\0" as *const u8 as *const libc::c_char,
        );
    } else {
        snprintf(
            keepalive.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            b"close\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___8 = url_get_hostname(U);
    cookies_header(my.cookies, tmp___8, cookie.as_mut_ptr());
    if (*C).auth.www != 0 {
        if (*C).auth.type_0.www as libc::c_uint == 1 as libc::c_uint {
            tmp___9 = url_get_method_name(U);
            tmp___10 = auth_get_digest_header(
                my.auth,
                HTTP,
                (*C).auth.wchlg,
                (*C).auth.wcred,
                tmp___9 as *const libc::c_char,
                fullpath.as_mut_ptr() as *const libc::c_char,
            );
            snprintf(
                authwww.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___10,
            );
        } else if (*C).auth.type_0.www as libc::c_uint == 2 as libc::c_uint {
            tmp___11 = auth_get_ntlm_header(my.auth, HTTP);
            snprintf(
                authwww.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___11,
            );
        } else {
            tmp___12 = auth_get_basic_header(my.auth, HTTP);
            snprintf(
                authwww.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___12,
            );
        }
    }
    if (*C).auth.proxy != 0 {
        if (*C).auth.type_0.proxy as libc::c_uint == 1 as libc::c_uint {
            tmp___13 = url_get_method_name(U);
            tmp___14 = auth_get_digest_header(
                my.auth,
                HTTP,
                (*C).auth.pchlg,
                (*C).auth.pcred,
                tmp___13 as *const libc::c_char,
                fullpath.as_mut_ptr() as *const libc::c_char,
            );
            snprintf(
                authpxy.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___14,
            );
        } else {
            tmp___15 = auth_get_basic_header(my.auth, PROXY);
            snprintf(
                authpxy.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                tmp___15,
            );
        }
    }
    tmp___25 = strncasestr(
        (my.extra).as_mut_ptr() as *const libc::c_char,
        b"host:\0" as *const u8 as *const libc::c_char,
        ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong,
    );
    if tmp___25 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___21 = url_get_scheme(U);
        let mut current_block_117: u64;
        if tmp___21 as libc::c_uint == 1 as libc::c_uint {
            tmp___22 = url_get_port(U);
            if tmp___22 != 80 as libc::c_int {
                tmp___16 = url_get_port(U);
                tmp___17 = url_get_hostname(U);
                tmp___18 = snprintf(
                    hoststr.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                    b"Host: %s:%d\r\n\0" as *const u8 as *const libc::c_char,
                    tmp___17,
                    tmp___16,
                );
                rlen = tmp___18 as size_t;
                current_block_117 = 12696043255897098083;
            } else {
                current_block_117 = 11192672719465813013;
            }
        } else {
            current_block_117 = 11192672719465813013;
        }
        match current_block_117 {
            11192672719465813013 => {
                tmp___23 = url_get_scheme(U);
                if tmp___23 as libc::c_uint == 2 as libc::c_uint {
                    tmp___24 = url_get_port(U);
                    if tmp___24 != 443 as libc::c_int {
                        tmp___16 = url_get_port(U);
                        tmp___17 = url_get_hostname(U);
                        tmp___18 = snprintf(
                            hoststr.as_mut_ptr(),
                            ::std::mem::size_of::<[libc::c_char; 128]>()
                                as libc::c_ulong,
                            b"Host: %s:%d\r\n\0" as *const u8 as *const libc::c_char,
                            tmp___17,
                            tmp___16,
                        );
                        rlen = tmp___18 as size_t;
                    } else {
                        tmp___19 = url_get_hostname(U);
                        tmp___20 = snprintf(
                            hoststr.as_mut_ptr(),
                            ::std::mem::size_of::<[libc::c_char; 128]>()
                                as libc::c_ulong,
                            b"Host: %s\r\n\0" as *const u8 as *const libc::c_char,
                            tmp___19,
                        );
                        rlen = tmp___20 as size_t;
                    }
                } else {
                    tmp___19 = url_get_hostname(U);
                    tmp___20 = snprintf(
                        hoststr.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                        b"Host: %s\r\n\0" as *const u8 as *const libc::c_char,
                        tmp___19,
                    );
                    rlen = tmp___20 as size_t;
                }
            }
            _ => {}
        }
    }
    tmp___26 = url_get_method_name(U);
    tmp___27 = strlen(tmp___26 as *const libc::c_char);
    tmp___28 = strlen(fullpath.as_mut_ptr() as *const libc::c_char);
    tmp___29 = strlen(protocol.as_mut_ptr() as *const libc::c_char);
    tmp___30 = strlen(hoststr.as_mut_ptr() as *const libc::c_char);
    if (*C).auth.www == 1 as libc::c_int {
        tmp___31 = authwww.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___31 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___32 = strlen(tmp___31);
    if (*C).auth.proxy == 1 as libc::c_int {
        tmp___33 = authpxy.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___33 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___34 = strlen(tmp___33);
    tmp___35 = strlen(cookie.as_mut_ptr() as *const libc::c_char);
    tmp___38 = strncasecmp(
        (my.extra).as_mut_ptr() as *const libc::c_char,
        b"Accept:\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as size_t,
    );
    if tmp___38 == 0 as libc::c_int {
        tmp___37 = b"\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___37 = accept___0.as_mut_ptr() as *const libc::c_char;
    }
    tmp___39 = strlen(tmp___37);
    tmp___40 = strlen((my.uagent).as_mut_ptr() as *const libc::c_char);
    tmp___41 = url_get_conttype(U);
    tmp___42 = strlen(tmp___41 as *const libc::c_char);
    tmp___43 = strlen((my.extra).as_mut_ptr() as *const libc::c_char);
    tmp___44 = strlen(keepalive.as_mut_ptr() as *const libc::c_char);
    tmp___45 = url_get_postlen(U);
    mlen = tmp___27
        .wrapping_add(tmp___28)
        .wrapping_add(tmp___29)
        .wrapping_add(tmp___30)
        .wrapping_add(tmp___32)
        .wrapping_add(tmp___34)
        .wrapping_add(tmp___35)
        .wrapping_add(tmp___39)
        .wrapping_add(::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong)
        .wrapping_add(tmp___40)
        .wrapping_add(tmp___42)
        .wrapping_add(tmp___43)
        .wrapping_add(tmp___44)
        .wrapping_add(tmp___45)
        .wrapping_add(128 as libc::c_ulong);
    tmp___46 = xmalloc(mlen);
    request = tmp___46 as *mut libc::c_char;
    memset(request as *mut libc::c_void, '\u{0}' as i32, mlen);
    memset(
        encoding.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
    );
    if my.get as u64 == 0 {
        snprintf(
            encoding.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"Accept-Encoding: %s\r\n\0" as *const u8 as *const libc::c_char,
            (my.encoding).as_mut_ptr(),
        );
    } else if my.print as u64 == 0 {
        snprintf(
            encoding.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"Accept-Encoding: %s\r\n\0" as *const u8 as *const libc::c_char,
            (my.encoding).as_mut_ptr(),
        );
    }
    tmp___47 = url_get_postlen(U);
    tmp___48 = url_get_conttype(U);
    tmp___51 = strncasecmp(
        (my.extra).as_mut_ptr() as *const libc::c_char,
        b"Accept:\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as size_t,
    );
    if tmp___51 == 0 as libc::c_int {
        tmp___50 = b"\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___50 = accept___0.as_mut_ptr() as *const libc::c_char;
    }
    tmp___54 = strlen(cookie.as_mut_ptr() as *const libc::c_char);
    if tmp___54 > 8 as libc::c_ulong {
        tmp___53 = cookie.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___53 = b"\0" as *const u8 as *const libc::c_char;
    }
    if (*C).auth.proxy == 1 as libc::c_int {
        tmp___55 = authpxy.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___55 = b"\0" as *const u8 as *const libc::c_char;
    }
    if (*C).auth.www == 1 as libc::c_int {
        tmp___56 = authwww.as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___56 = b"\0" as *const u8 as *const libc::c_char;
    }
    tmp___57 = url_get_method_name(U);
    tmp___58 = snprintf(
        request,
        mlen,
        b"%s %s %s\r\n%s%s%s%s%s%sUser-Agent: %s\r\n%sConnection: %s\r\nContent-Type: %s\r\nContent-Length: %ld\r\n\r\n\0"
            as *const u8 as *const libc::c_char,
        tmp___57,
        fullpath.as_mut_ptr(),
        protocol.as_mut_ptr(),
        hoststr.as_mut_ptr(),
        tmp___56,
        tmp___55,
        tmp___53,
        tmp___50,
        encoding.as_mut_ptr(),
        (my.uagent).as_mut_ptr(),
        (my.extra).as_mut_ptr(),
        keepalive.as_mut_ptr(),
        tmp___48,
        tmp___47 as libc::c_long,
    );
    rlen = tmp___58 as size_t;
    if rlen < mlen {
        tmp___59 = url_get_postlen(U);
        tmp___60 = url_get_postdata(U);
        memcpy(
            request.offset(rlen as isize) as *mut libc::c_void,
            tmp___60 as *const libc::c_void,
            tmp___59,
        );
        tmp___61 = url_get_postlen(U);
        *request
            .offset(
                rlen.wrapping_add(tmp___61) as isize,
            ) = 0 as libc::c_int as libc::c_char;
    }
    tmp___62 = url_get_postlen(U);
    rlen = (rlen as libc::c_ulong).wrapping_add(tmp___62) as size_t as size_t;
    if my.get as u64 != 0 {
        printf(b"%s\n\n\0" as *const u8 as *const libc::c_char, request);
    } else if my.debug as u64 != 0 {
        printf(b"%s\n\n\0" as *const u8 as *const libc::c_char, request);
    } else if my.print as u64 != 0 {
        printf(b"%s\n\n\0" as *const u8 as *const libc::c_char, request);
    }
    if rlen == 0 as libc::c_ulong {
        tmp___63 = url_get_method_name(U);
        NOTIFY(
            FATAL,
            b"HTTP %s: request buffer overrun! Unable to continue...\0" as *const u8
                as *const libc::c_char,
            tmp___63,
        );
    } else if rlen > mlen {
        tmp___63 = url_get_method_name(U);
        NOTIFY(
            FATAL,
            b"HTTP %s: request buffer overrun! Unable to continue...\0" as *const u8
                as *const libc::c_char,
            tmp___63,
        );
    }
    tmp___64 = socket_write(C, request as *const libc::c_void, rlen);
    if tmp___64 < 0 as libc::c_int {
        return boolean_false;
    }
    xfree(request as *mut libc::c_void);
    return boolean_true;
}
pub unsafe extern "C" fn http_read_headers(mut C: *mut CONN, mut U: URL) -> RESPONSE {
    let mut x: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut line: [libc::c_char; 4096] = [0; 4096];
    let mut resp: RESPONSE = 0 as *mut RESPONSE_T;
    let mut tmp: RESPONSE = 0 as *mut RESPONSE_T;
    let mut tmp___0: ssize_t = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: [libc::c_char; 4096] = [0; 4096];
    let mut tmp___10: size_t = 0;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: size_t = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: size_t = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: BOOLEAN = boolean_false;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: size_t = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: size_t = 0;
    let mut tmp___21: libc::c_int = 0;
    let mut date: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut tmp___22: size_t = 0;
    let mut tmp___23: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___24: size_t = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut etag: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len___0: size_t = 0;
    let mut tmp___26: size_t = 0;
    let mut tmp___27: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___28: size_t = 0;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: size_t = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: size_t = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: size_t = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut expires: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len___1: size_t = 0;
    let mut tmp___36: size_t = 0;
    let mut tmp___37: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___38: size_t = 0;
    let mut tmp___39: libc::c_int = 0;
    let mut tmp___40: libc::c_int = 0;
    tmp = new_response();
    resp = tmp;
    loop {
        x = 0 as libc::c_int;
        loop {
            tmp___0 = socket_read(
                C,
                &mut c as *mut libc::c_char as *mut libc::c_void,
                1 as libc::c_int as size_t,
            );
            n = tmp___0 as libc::c_int;
            if !(n == 1 as libc::c_int) {
                break;
            }
            if x < 4095 as libc::c_int {
                line[x as usize] = c;
            } else {
                line[x as usize] = '\n' as i32 as libc::c_char;
            }
            echo(b"%c\0" as *const u8 as *const libc::c_char, c as libc::c_int);
            if x <= 1 as libc::c_int {
                if line[x as usize] as libc::c_int == 10 as libc::c_int {
                    return resp;
                }
            }
            if line[x as usize] as libc::c_int == 10 as libc::c_int {
                break;
            }
            x += 1;
        }
        line[x as usize] = '\u{0}' as i32 as libc::c_char;
        if x > 0 as libc::c_int {
            if line[(x - 1 as libc::c_int) as usize] as libc::c_int == 13 as libc::c_int
            {
                line[(x - 1 as libc::c_int) as usize] = '\u{0}' as i32 as libc::c_char;
            }
        }
        tmp___1 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"http\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
        if tmp___1 == 0 as libc::c_int {
            response_set_code(resp, line.as_mut_ptr());
        }
        tmp___2 = strlen(b"content-type\0" as *const u8 as *const libc::c_char);
        tmp___3 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"content-type\0" as *const u8 as *const libc::c_char,
            tmp___2,
        );
        if tmp___3 == 0 as libc::c_int {
            response_set_content_type(resp, line.as_mut_ptr());
        }
        tmp___4 = strlen(b"content-encoding\0" as *const u8 as *const libc::c_char);
        tmp___5 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"content-encoding\0" as *const u8 as *const libc::c_char,
            tmp___4,
        );
        if tmp___5 == 0 as libc::c_int {
            response_set_content_encoding(resp, line.as_mut_ptr());
        }
        tmp___7 = strlen(b"content-length\0" as *const u8 as *const libc::c_char);
        tmp___8 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"content-length\0" as *const u8 as *const libc::c_char,
            tmp___7,
        );
        if tmp___8 == 0 as libc::c_int {
            response_set_content_length(resp, line.as_mut_ptr());
            tmp___6 = atoi(
                line.as_mut_ptr().offset(16 as libc::c_int as isize)
                    as *const libc::c_char,
            );
            (*C).content.length = tmp___6 as size_t;
        }
        tmp___12 = strlen(b"set-cookie\0" as *const u8 as *const libc::c_char);
        tmp___13 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"set-cookie\0" as *const u8 as *const libc::c_char,
            tmp___12,
        );
        if tmp___13 == 0 as libc::c_int {
            if !(my.cookies).is_null() {
                memset(
                    tmp___9.as_mut_ptr() as *mut libc::c_void,
                    '\u{0}' as i32,
                    4096 as libc::c_int as size_t,
                );
                tmp___10 = strlen(line.as_mut_ptr() as *const libc::c_char);
                strncpy(
                    tmp___9.as_mut_ptr(),
                    line.as_mut_ptr().offset(12 as libc::c_int as isize)
                        as *const libc::c_char,
                    tmp___10,
                );
                tmp___11 = url_get_hostname(U);
                cookies_add(my.cookies, tmp___9.as_mut_ptr(), tmp___11);
            }
        }
        tmp___14 = strlen(b"connection\0" as *const u8 as *const libc::c_char);
        tmp___15 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"connection\0" as *const u8 as *const libc::c_char,
            tmp___14,
        );
        if tmp___15 == 0 as libc::c_int {
            response_set_connection(resp, line.as_mut_ptr());
        }
        tmp___17 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"keep-alive: \0" as *const u8 as *const libc::c_char,
            12 as libc::c_int as size_t,
        );
        if tmp___17 == 0 as libc::c_int {
            tmp___16 = response_set_keepalive(resp, line.as_mut_ptr());
            if tmp___16 as libc::c_uint == 1 as libc::c_uint {
                (*C).connection.timeout = response_get_keepalive_timeout(resp);
                (*C).connection.max = response_get_keepalive_max(resp);
            }
        }
        tmp___18 = strlen(b"location\0" as *const u8 as *const libc::c_char);
        tmp___19 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"location\0" as *const u8 as *const libc::c_char,
            tmp___18,
        );
        if tmp___19 == 0 as libc::c_int {
            response_set_location(resp, line.as_mut_ptr());
        }
        tmp___20 = strlen(b"content-location\0" as *const u8 as *const libc::c_char);
        tmp___21 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"content-location\0" as *const u8 as *const libc::c_char,
            tmp___20,
        );
        if tmp___21 == 0 as libc::c_int {
            response_set_location(resp, line.as_mut_ptr());
        }
        tmp___24 = strlen(b"last-modified\0" as *const u8 as *const libc::c_char);
        tmp___25 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"last-modified\0" as *const u8 as *const libc::c_char,
            tmp___24,
        );
        if tmp___25 == 0 as libc::c_int {
            response_set_last_modified(resp, line.as_mut_ptr());
            tmp___22 = strlen(line.as_mut_ptr() as *const libc::c_char);
            len = tmp___22;
            if my.cache as u64 != 0 {
                tmp___23 = xmalloc(len);
                date = tmp___23 as *mut libc::c_char;
                memcpy(
                    date as *mut libc::c_void,
                    line.as_mut_ptr().offset(15 as libc::c_int as isize)
                        as *const libc::c_void,
                    len.wrapping_sub(14 as libc::c_ulong),
                );
                cache_add((*C).cache, C_LAST, U, date);
                xfree(date as *mut libc::c_void);
            }
        }
        tmp___28 = strlen(b"etag\0" as *const u8 as *const libc::c_char);
        tmp___29 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"etag\0" as *const u8 as *const libc::c_char,
            tmp___28,
        );
        if tmp___29 == 0 as libc::c_int {
            tmp___26 = strlen(line.as_mut_ptr() as *const libc::c_char);
            len___0 = tmp___26;
            if my.cache as u64 != 0 {
                tmp___27 = xmalloc(len___0);
                etag = tmp___27 as *mut libc::c_char;
                memset(etag as *mut libc::c_void, '\u{0}' as i32, len___0);
                memcpy(
                    etag as *mut libc::c_void,
                    line.as_mut_ptr().offset(6 as libc::c_int as isize)
                        as *const libc::c_void,
                    len___0.wrapping_sub(5 as libc::c_ulong),
                );
                cache_add((*C).cache, C_ETAG, U, etag);
                xfree(etag as *mut libc::c_void);
            }
        }
        tmp___30 = strlen(b"www-authenticate\0" as *const u8 as *const libc::c_char);
        tmp___31 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"www-authenticate\0" as *const u8 as *const libc::c_char,
            tmp___30,
        );
        if tmp___31 == 0 as libc::c_int {
            response_set_www_authenticate(resp, line.as_mut_ptr());
        }
        tmp___32 = strlen(b"proxy-authenticate\0" as *const u8 as *const libc::c_char);
        tmp___33 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"proxy-authenticate\0" as *const u8 as *const libc::c_char,
            tmp___32,
        );
        if tmp___33 == 0 as libc::c_int {
            response_set_proxy_authenticate(resp, line.as_mut_ptr());
        }
        tmp___34 = strlen(b"transfer-encoding\0" as *const u8 as *const libc::c_char);
        tmp___35 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"transfer-encoding\0" as *const u8 as *const libc::c_char,
            tmp___34,
        );
        if tmp___35 == 0 as libc::c_int {
            response_set_transfer_encoding(resp, line.as_mut_ptr());
        }
        tmp___38 = strlen(b"expires\0" as *const u8 as *const libc::c_char);
        tmp___39 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"expires\0" as *const u8 as *const libc::c_char,
            tmp___38,
        );
        if tmp___39 == 0 as libc::c_int {
            tmp___36 = strlen(line.as_mut_ptr() as *const libc::c_char);
            len___1 = tmp___36;
            if my.cache as u64 != 0 {
                tmp___37 = xmalloc(len___1);
                expires = tmp___37 as *mut libc::c_char;
                memset(expires as *mut libc::c_void, '\u{0}' as i32, len___1);
                memcpy(
                    expires as *mut libc::c_void,
                    line.as_mut_ptr().offset(9 as libc::c_int as isize)
                        as *const libc::c_void,
                    len___1.wrapping_sub(8 as libc::c_ulong),
                );
                cache_add((*C).cache, C_EXPIRES, U, expires);
                xfree(expires as *mut libc::c_void);
            }
        }
        tmp___40 = strncasecmp(
            line.as_mut_ptr() as *const libc::c_char,
            b"cache-control: \0" as *const u8 as *const libc::c_char,
            15 as libc::c_int as size_t,
        );
        if n <= 0 as libc::c_int {
            echo(
                b"read error: %s:%d\0" as *const u8 as *const libc::c_char,
                b"http.c\0" as *const u8 as *const libc::c_char,
                543 as libc::c_int,
            );
            resp = response_destroy(resp);
            return resp;
        }
    };
}
pub unsafe extern "C" fn http_chunk_size(mut C: *mut CONN) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut length: size_t = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    memset(
        ((*C).chkbuf).as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
    );
    tmp = socket_readline(
        C,
        ((*C).chkbuf).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
    );
    n = tmp as libc::c_int;
    if n < 1 as libc::c_int {
        NOTIFY(
            WARNING,
            b"HTTP: unable to determine chunk size\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if (*C).chkbuf[0 as libc::c_int as usize] as libc::c_int == 10 as libc::c_int {
        return -(1 as libc::c_int)
    } else {
        tmp___0 = strlen(((*C).chkbuf).as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_ulong {
            return -(1 as libc::c_int)
        } else {
            if (*C).chkbuf[0 as libc::c_int as usize] as libc::c_int == 13 as libc::c_int
            {
                return -(1 as libc::c_int);
            }
        }
    }
    tmp___1 = __errno_location();
    *tmp___1 = 0 as libc::c_int;
    tmp___2 = __ctype_b_loc();
    if *(*tmp___2)
        .offset(
            (*C).chkbuf[0 as libc::c_int as usize] as libc::c_uint as libc::c_int
                as isize,
        ) as libc::c_int & 4096 as libc::c_int == 0
    {
        return -(1 as libc::c_int);
    }
    length = strtoul(
        ((*C).chkbuf).as_mut_ptr() as *const libc::c_char,
        &mut end as *mut *mut libc::c_char,
        16 as libc::c_int,
    );
    tmp___3 = __errno_location();
    if *tmp___3 == 34 as libc::c_int {
        NOTIFY(
            WARNING,
            b"HTTP: invalid chunk line %s\n\0" as *const u8 as *const libc::c_char,
            ((*C).chkbuf).as_mut_ptr(),
        );
        return 0 as libc::c_int;
    } else if end as libc::c_ulong == ((*C).chkbuf).as_mut_ptr() as libc::c_ulong {
        NOTIFY(
            WARNING,
            b"HTTP: invalid chunk line %s\n\0" as *const u8 as *const libc::c_char,
            ((*C).chkbuf).as_mut_ptr(),
        );
        return 0 as libc::c_int;
    } else {
        return length as libc::c_int
    };
}
pub unsafe extern "C" fn http_read(mut C: *mut CONN, mut resp: RESPONSE) -> ssize_t {
    let mut n: libc::c_int = 0;
    let mut chunk: libc::c_int = 0;
    let mut bytes: size_t = 0;
    let mut length: size_t = 0;
    let mut dest: [libc::c_char; 393216] = [0; 393216];
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut size: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: ssize_t = 0;
    let mut r: libc::c_int = 0;
    let mut done: BOOLEAN = boolean_false;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut remaining_in_chunk: libc::c_int = 0;
    let mut space_in_buf: libc::c_int = 0;
    let mut to_read: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: ssize_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: ssize_t = 0;
    let mut tmp___8: HTTP_TE = 0 as HTTP_TE;
    let mut tmp___9: HTTP_CE = 0 as HTTP_CE;
    let mut tmp___10: HTTP_CE = 0 as HTTP_CE;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: size_t = 0;
    let mut tmp___13: size_t = 0;
    n = 0 as libc::c_int;
    chunk = 0 as libc::c_int;
    bytes = 0 as libc::c_int as size_t;
    length = 0 as libc::c_int as size_t;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    size = 65536 as libc::c_int as size_t;
    if C as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            FATAL,
            b"Connection is NULL! Unable to proceed\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as libc::c_int as ssize_t;
    }
    if (*C).content.length == 0 as libc::c_ulong {
        return 0 as libc::c_int as ssize_t
    } else {
        if (*C).content.length == 0xffffffffffffffff as libc::c_ulong {
            (*C).content.length = 0 as libc::c_int as size_t;
        }
    }
    memset(
        dest.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 393216]>() as libc::c_ulong,
    );
    if (*C).content.length > 0 as libc::c_ulong {
        length = (*C).content.length;
        tmp___0 = xmalloc(length.wrapping_add(1 as libc::c_ulong));
        ptr = tmp___0 as *mut libc::c_char;
        memset(
            ptr as *mut libc::c_void,
            '\u{0}' as i32,
            length.wrapping_add(1 as libc::c_ulong),
        );
        loop {
            tmp___1 = socket_read(C, ptr as *mut libc::c_void, length);
            n = tmp___1 as libc::c_int;
            if n == 0 as libc::c_int {
                break;
            }
            bytes = (bytes as libc::c_ulong).wrapping_add(n as size_t) as size_t
                as size_t;
            if !(bytes < length) {
                break;
            }
        }
    } else {
        let mut current_block_71: u64;
        if my.chunked as u64 != 0 {
            tmp___8 = response_get_transfer_encoding(resp);
            if tmp___8 as libc::c_uint == 2 as libc::c_uint {
                r = 0 as libc::c_int;
                bytes = 0 as libc::c_int as size_t;
                done = boolean_false;
                tmp___2 = xmalloc(size);
                ptr = tmp___2 as *mut libc::c_char;
                memset(ptr as *mut libc::c_void, '\u{0}' as i32, size);
                loop {
                    chunk = http_chunk_size(C);
                    if chunk == 0 as libc::c_int {
                        socket_readline(
                            C,
                            ((*C).chkbuf).as_mut_ptr(),
                            ::std::mem::size_of::<[libc::c_char; 1024]>()
                                as libc::c_ulong,
                        );
                        break;
                    } else {
                        if chunk < 0 as libc::c_int {
                            chunk = 0 as libc::c_int;
                        } else {
                            while n < chunk {
                                remaining_in_chunk = chunk - n;
                                space_in_buf = size.wrapping_sub(bytes) as libc::c_int;
                                if remaining_in_chunk < space_in_buf {
                                    tmp___3 = remaining_in_chunk;
                                } else {
                                    tmp___3 = space_in_buf;
                                }
                                to_read = tmp___3;
                                tmp___4 = socket_read(
                                    C,
                                    ptr.offset(bytes as isize) as *mut libc::c_void,
                                    to_read as size_t,
                                );
                                r = tmp___4 as libc::c_int;
                                bytes = (bytes as libc::c_ulong).wrapping_add(r as size_t)
                                    as size_t as size_t;
                                if r <= 0 as libc::c_int {
                                    done = boolean_true;
                                    break;
                                } else {
                                    n += r;
                                    if bytes >= size {
                                        tmp___5 = realloc(
                                            ptr as *mut libc::c_void,
                                            size.wrapping_mul(2 as libc::c_ulong),
                                        );
                                        tmp = tmp___5 as *mut libc::c_char;
                                        if tmp as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            free(ptr as *mut libc::c_void);
                                            return -(1 as libc::c_int) as ssize_t;
                                        }
                                        ptr = tmp;
                                        size = (size as libc::c_ulong)
                                            .wrapping_mul(2 as libc::c_ulong) as size_t as size_t;
                                    }
                                }
                            }
                            n = 0 as libc::c_int;
                        }
                        if done as u64 != 0 {
                            break;
                        }
                    }
                }
                *ptr.offset(bytes as isize) = '\u{0}' as i32 as libc::c_char;
                current_block_71 = 5658374378798827547;
            } else {
                current_block_71 = 12803926935927206828;
            }
        } else {
            current_block_71 = 12803926935927206828;
        }
        match current_block_71 {
            12803926935927206828 => {
                tmp___6 = xmalloc(size);
                ptr = tmp___6 as *mut libc::c_char;
                memset(ptr as *mut libc::c_void, '\u{0}' as i32, size);
                loop {
                    tmp___7 = socket_read(C, ptr as *mut libc::c_void, size);
                    n = tmp___7 as libc::c_int;
                    bytes = (bytes as libc::c_ulong).wrapping_add(n as size_t) as size_t
                        as size_t;
                    if n <= 0 as libc::c_int {
                        break;
                    }
                }
            }
            _ => {}
        }
    }
    tmp___9 = response_get_content_encoding(resp);
    if tmp___9 as libc::c_uint == 4 as libc::c_uint {
        __gzip_inflate(
            47 as libc::c_int,
            ptr as *const libc::c_char,
            bytes as libc::c_int,
            dest.as_mut_ptr() as *const libc::c_char,
            ::std::mem::size_of::<[libc::c_char; 393216]>() as libc::c_ulong
                as libc::c_int,
        );
    }
    tmp___10 = response_get_content_encoding(resp);
    if tmp___10 as libc::c_uint == 2 as libc::c_uint {
        __gzip_inflate(
            -(15 as libc::c_int),
            ptr as *const libc::c_char,
            bytes as libc::c_int,
            dest.as_mut_ptr() as *const libc::c_char,
            ::std::mem::size_of::<[libc::c_char; 393216]>() as libc::c_ulong
                as libc::c_int,
        );
    }
    tmp___13 = strlen(dest.as_mut_ptr() as *const libc::c_char);
    if tmp___13 > 0 as libc::c_ulong {
        tmp___11 = strlen(dest.as_mut_ptr() as *const libc::c_char);
        page_concat(
            (*C).page,
            dest.as_mut_ptr() as *const libc::c_char,
            tmp___11 as libc::c_int,
        );
    } else {
        tmp___12 = strlen(ptr as *const libc::c_char);
        page_concat((*C).page, ptr as *const libc::c_char, tmp___12 as libc::c_int);
    }
    xfree(ptr as *mut libc::c_void);
    echo(b"\n\0" as *const u8 as *const libc::c_char);
    return bytes as ssize_t;
}
unsafe extern "C" fn __gzip_inflate(
    mut window: libc::c_int,
    mut src: *const libc::c_char,
    mut srcLen: libc::c_int,
    mut dst: *const libc::c_char,
    mut dstLen: libc::c_int,
) -> libc::c_int {
    let mut err: libc::c_int = 0;
    let mut strm: z_stream = z_stream {
        next_in: 0 as *mut Bytef,
        avail_in: 0,
        total_in: 0,
        next_out: 0 as *mut Bytef,
        avail_out: 0,
        total_out: 0,
        msg: 0 as *mut libc::c_char,
        state: 0 as *mut internal_state,
        zalloc: None,
        zfree: None,
        opaque: 0 as *mut libc::c_void,
        data_type: 0,
        adler: 0,
        reserved: 0,
    };
    let mut ret: libc::c_int = 0;
    err = -(1 as libc::c_int);
    ret = -(1 as libc::c_int);
    strm.zalloc = None;
    strm.zfree = None;
    strm.opaque = 0 as voidpf;
    strm.avail_in = srcLen as uInt;
    strm.avail_out = dstLen as uInt;
    strm.next_in = src as *mut Bytef;
    strm.next_out = dst as *mut Bytef;
    err = inflateInit2_(
        &mut strm,
        window,
        b"1.2.11\0" as *const u8 as *const libc::c_char,
        ::std::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
    );
    if err == 0 as libc::c_int {
        err = inflate(&mut strm, 4 as libc::c_int);
        if err == 1 as libc::c_int {
            ret = strm.total_out as libc::c_int;
        } else {
            inflateEnd(&mut strm);
            return err;
        }
    } else {
        inflateEnd(&mut strm);
        return err;
    }
    inflateEnd(&mut strm);
    return ret;
}
#[inline]
unsafe extern "C" fn stat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __xstat(1 as libc::c_int, __path, __statbuf);
    return tmp;
}
pub unsafe extern "C" fn init_config() -> libc::c_int {
    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dir: [libc::c_char; 256] = [0; 256];
    let mut res: libc::c_int = 0;
    let mut buf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut needed: BOOLEAN = boolean_false;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ret: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: size_t = 0;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: size_t = 0;
    let mut tmp___13: size_t = 0;
    needed = boolean_false;
    memset(
        dir.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
    );
    tmp = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    snprintf(
        dir.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s/.siege\0" as *const u8 as *const libc::c_char,
        tmp,
    );
    tmp___1 = stat(dir.as_mut_ptr() as *const libc::c_char, &mut buf as *mut stat);
    let mut current_block_13: u64;
    if tmp___1 < 0 as libc::c_int {
        tmp___2 = __errno_location();
        if 2 as libc::c_int == *tmp___2 {
            needed = boolean_true;
            current_block_13 = 15089075282327824602;
        } else {
            current_block_13 = 11486310875869720181;
        }
    } else {
        current_block_13 = 11486310875869720181;
    }
    match current_block_13 {
        11486310875869720181 => {
            if !(buf.st_mode & 61440 as libc::c_uint == 16384 as libc::c_uint) {
                tmp___0 = unlink(dir.as_mut_ptr() as *const libc::c_char);
                if tmp___0 == 0 as libc::c_int {
                    needed = boolean_true;
                }
            }
        }
        _ => {}
    }
    while needed as u64 != 0 {
        mkdir(dir.as_mut_ptr() as *const libc::c_char, 488 as libc::c_int as __mode_t);
        ret = system(b"siege.config\0" as *const u8 as *const libc::c_char);
        if ((ret & 127 as libc::c_int) + 1 as libc::c_int) as libc::c_schar
            as libc::c_int >> 1 as libc::c_int > 0 as libc::c_int
        {
            if ret & 127 as libc::c_int == 2 as libc::c_int {
                break;
            }
            if ret & 127 as libc::c_int == 3 as libc::c_int {
                break;
            }
        }
        needed = boolean_false;
    }
    tmp___6 = strcmp(
        (my.rc).as_mut_ptr() as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
    );
    if tmp___6 == 0 as libc::c_int {
        e = getenv(b"SIEGERC\0" as *const u8 as *const libc::c_char);
        if e as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            snprintf(
                (my.rc).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"%s\0" as *const u8 as *const libc::c_char,
                e,
            );
        } else {
            tmp___3 = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
            snprintf(
                (my.rc).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"%s/.siege/siege.conf\0" as *const u8 as *const libc::c_char,
                tmp___3,
            );
            tmp___4 = stat(
                (my.rc).as_mut_ptr() as *const libc::c_char,
                &mut buf as *mut stat,
            );
            if tmp___4 < 0 as libc::c_int {
                tmp___5 = __errno_location();
                if *tmp___5 == 2 as libc::c_int {
                    snprintf(
                        (my.rc).as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        b"/usr/local/etc/siegerc\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        }
    }
    my.debug = boolean_false;
    my.quiet = boolean_false;
    my.color = boolean_true;
    my.internet = boolean_false;
    my.config = boolean_false;
    my.csv = boolean_false;
    my.fullurl = boolean_false;
    my.escape = boolean_true;
    my.parser = boolean_false;
    my.secs = -(1 as libc::c_int);
    my.limit = 255 as libc::c_int;
    my.reps = 10301062 as libc::c_int;
    my.bids = 5 as libc::c_int;
    my.login = boolean_false;
    my.failures = 1024 as libc::c_int;
    my.failed = 0 as libc::c_int;
    my.auth = new_auth();
    auth_set_proxy_required(my.auth, boolean_false);
    auth_set_proxy_port(my.auth, 3128 as libc::c_int);
    my.timeout = 30 as libc::c_int;
    my.timestamp = boolean_false;
    my.chunked = boolean_false;
    my.unique = boolean_true;
    my.json_output = boolean_false;
    my.extra[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    my.follow = boolean_true;
    my.zero_ok = boolean_true;
    my.signaled = 0 as libc::c_int;
    my.ssl_timeout = 300 as libc::c_int;
    my.ssl_cert = 0 as *mut libc::c_void as *mut libc::c_char;
    my.ssl_key = 0 as *mut libc::c_void as *mut libc::c_char;
    my.ssl_ciphers = 0 as *mut libc::c_void as *mut libc::c_char;
    my.lurl = new_array();
    my.cookies = new_cookies();
    tmp___7 = xcalloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<LINES>() as libc::c_ulong,
    );
    my.nomap = tmp___7 as *mut LINES;
    (*my.nomap).index = 0 as libc::c_int;
    (*my.nomap).line = 0 as *mut libc::c_void as *mut *mut libc::c_char;
    res = pthread_mutex_init(
        &mut my.lock,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    if res != 0 as libc::c_int {
        NOTIFY(FATAL, b"unable to initiate lock\0" as *const u8 as *const libc::c_char);
    }
    res = pthread_cond_init(
        &mut my.cond as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    if res != 0 as libc::c_int {
        NOTIFY(
            FATAL,
            b"unable to initiate condition\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___8 = load_conf((my.rc).as_mut_ptr());
    if tmp___8 < 0 as libc::c_int {
        fprintf(
            stderr,
            b"**************************************************\n\0" as *const u8
                as *const libc::c_char,
        );
        fprintf(
            stderr,
            b"siege: could not open %s\n\0" as *const u8 as *const libc::c_char,
            (my.rc).as_mut_ptr(),
        );
        fprintf(
            stderr,
            b"run 'siege.config' to generate a new config file\n\0" as *const u8
                as *const libc::c_char,
        );
        fprintf(
            stderr,
            b"**************************************************\n\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    tmp___9 = strlen((my.file).as_mut_ptr() as *const libc::c_char);
    if tmp___9 < 1 as libc::c_ulong {
        snprintf(
            (my.file).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            b"/usr/local/etc/urls.txt\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___10 = strlen((my.uagent).as_mut_ptr() as *const libc::c_char);
    if tmp___10 < 1 as libc::c_ulong {
        snprintf(
            (my.uagent).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b"Mozilla/5.0 (%s) Siege/%s\0" as *const u8 as *const libc::c_char,
            b"pc-x86_64-linux-gnu\0" as *const u8 as *const libc::c_char,
            version_string,
        );
    }
    tmp___11 = strlen((my.conttype).as_mut_ptr() as *const libc::c_char);
    if tmp___11 < 1 as libc::c_ulong {
        snprintf(
            (my.conttype).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b"application/x-www-form-urlencoded\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___12 = strlen((my.encoding).as_mut_ptr() as *const libc::c_char);
    if tmp___12 < 1 as libc::c_ulong {
        snprintf(
            (my.encoding).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b"*\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___13 = strlen((my.logfile).as_mut_ptr() as *const libc::c_char);
    if tmp___13 < 1 as libc::c_ulong {
        snprintf(
            (my.logfile).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            b"/usr/local/var/log/siege.log\0" as *const u8 as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn show_config(mut EXIT: libc::c_int) -> libc::c_int {
    let mut method___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: BOOLEAN = boolean_false;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___15: size_t = 0;
    let mut tmp___17: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___18: size_t = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___21: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___22: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___23: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___24: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___25: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___26: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___27: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___28: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    match my.method as libc::c_uint {
        2 => {
            method___0 = strdup(b"GET\0" as *const u8 as *const libc::c_char);
        }
        _ => {
            method___0 = strdup(b"HEAD\0" as *const u8 as *const libc::c_char);
        }
    }
    printf(b"CURRENT  SIEGE  CONFIGURATION\n\0" as *const u8 as *const libc::c_char);
    printf(b"%s\n\0" as *const u8 as *const libc::c_char, (my.uagent).as_mut_ptr());
    printf(
        b"Edit the resource file to change the settings.\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"----------------------------------------------\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"version:                        %s\n\0" as *const u8 as *const libc::c_char,
        version_string,
    );
    if my.verbose as u64 != 0 {
        tmp = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"verbose:                        %s\n\0" as *const u8 as *const libc::c_char,
        tmp,
    );
    if my.color as u64 != 0 {
        tmp___0 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"color:                          %s\n\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    if my.quiet as u64 != 0 {
        tmp___1 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___1 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"quiet:                          %s\n\0" as *const u8 as *const libc::c_char,
        tmp___1,
    );
    if my.debug as u64 != 0 {
        tmp___2 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___2 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"debug:                          %s\n\0" as *const u8 as *const libc::c_char,
        tmp___2,
    );
    if my.protocol != 0 {
        tmp___3 = b"HTTP/1.1\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___3 = b"HTTP/1.0\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"protocol:                       %s\n\0" as *const u8 as *const libc::c_char,
        tmp___3,
    );
    if my.parser as u64 != 0 {
        tmp___4 = b"enabled\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___4 = b"disabled\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"HTML parser:                    %s\n\0" as *const u8 as *const libc::c_char,
        tmp___4,
    );
    printf(
        b"get method:                     %s\n\0" as *const u8 as *const libc::c_char,
        method___0,
    );
    tmp___7 = auth_get_proxy_required(my.auth);
    if tmp___7 as u64 != 0 {
        tmp___5 = auth_get_proxy_host(my.auth);
        printf(
            b"proxy-host:                     %s\n\0" as *const u8
                as *const libc::c_char,
            tmp___5,
        );
        tmp___6 = auth_get_proxy_port(my.auth);
        printf(
            b"proxy-port:                     %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___6,
        );
    }
    if my.keepalive as u64 != 0 {
        tmp___8 = b"keep-alive\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___8 = b"close\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"connection:                     %s\n\0" as *const u8 as *const libc::c_char,
        tmp___8,
    );
    printf(
        b"concurrent users:               %d\n\0" as *const u8 as *const libc::c_char,
        my.cusers,
    );
    if my.secs > 0 as libc::c_int {
        printf(
            b"time to run:                    %d seconds\n\0" as *const u8
                as *const libc::c_char,
            my.secs,
        );
    } else {
        printf(
            b"time to run:                    n/a\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    if my.reps > 0 as libc::c_int {
        if my.reps != 10301062 as libc::c_int {
            printf(
                b"repetitions:                    %d\n\0" as *const u8
                    as *const libc::c_char,
                my.reps,
            );
        } else {
            printf(
                b"repetitions:                    n/a\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else {
        printf(
            b"repetitions:                    n/a\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    printf(
        b"socket timeout:                 %d\n\0" as *const u8 as *const libc::c_char,
        my.timeout,
    );
    if my.cache as libc::c_uint == 1 as libc::c_uint {
        tmp___9 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___9 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"cache enabled:                  %s\n\0" as *const u8 as *const libc::c_char,
        tmp___9,
    );
    printf(
        b"accept-encoding:                %s\n\0" as *const u8 as *const libc::c_char,
        (my.encoding).as_mut_ptr(),
    );
    if my.delay > 1 as libc::c_int as libc::c_float {
        tmp___10 = b"s\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___10 = b"\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"delay:                          %.3f sec%s\n\0" as *const u8
            as *const libc::c_char,
        my.delay as libc::c_double,
        tmp___10,
    );
    if my.internet as u64 != 0 {
        tmp___11 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___11 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"internet simulation:            %s\n\0" as *const u8 as *const libc::c_char,
        tmp___11,
    );
    if my.bench as u64 != 0 {
        tmp___12 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___12 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"benchmark mode:                 %s\n\0" as *const u8 as *const libc::c_char,
        tmp___12,
    );
    printf(
        b"failures until abort:           %d\n\0" as *const u8 as *const libc::c_char,
        my.failures,
    );
    if my.url as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___14 = b"none\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___15 = strlen(my.url as *const libc::c_char);
        if tmp___15 < 2 as libc::c_ulong {
            tmp___14 = b"none\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___14 = my.url as *const libc::c_char;
        }
    }
    printf(
        b"named URL:                      %s\n\0" as *const u8 as *const libc::c_char,
        tmp___14,
    );
    tmp___18 = strlen((my.file).as_mut_ptr() as *const libc::c_char);
    if tmp___18 > 1 as libc::c_ulong {
        tmp___17 = (my.file).as_mut_ptr() as *const libc::c_char;
    } else {
        tmp___17 = b"/usr/local/etc/urls.txt\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"URLs file:                      %s\n\0" as *const u8 as *const libc::c_char,
        tmp___17,
    );
    if my.limit < 1 as libc::c_int {
        tmp___19 = 255 as libc::c_int;
    } else {
        tmp___19 = my.limit;
    }
    printf(
        b"thread limit:                   %d\n\0" as *const u8 as *const libc::c_char,
        tmp___19,
    );
    if my.logging as u64 != 0 {
        tmp___20 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___20 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"logging:                        %s\n\0" as *const u8 as *const libc::c_char,
        tmp___20,
    );
    if (my.logfile).as_mut_ptr() as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___21 = b"/usr/local/var/log/siege.log\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___21 = (my.logfile).as_mut_ptr() as *const libc::c_char;
    }
    printf(
        b"log file:                       %s\n\0" as *const u8 as *const libc::c_char,
        tmp___21,
    );
    printf(
        b"resource file:                  %s\n\0" as *const u8 as *const libc::c_char,
        (my.rc).as_mut_ptr(),
    );
    if my.timestamp as u64 != 0 {
        tmp___22 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___22 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"timestamped output:             %s\n\0" as *const u8 as *const libc::c_char,
        tmp___22,
    );
    if my.csv as u64 != 0 {
        tmp___23 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___23 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"comma separated output:         %s\n\0" as *const u8 as *const libc::c_char,
        tmp___23,
    );
    if my.follow as u64 != 0 {
        tmp___24 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___24 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"allow redirects:                %s\n\0" as *const u8 as *const libc::c_char,
        tmp___24,
    );
    if my.zero_ok as u64 != 0 {
        tmp___25 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___25 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"allow zero byte data:           %s\n\0" as *const u8 as *const libc::c_char,
        tmp___25,
    );
    if my.chunked as u64 != 0 {
        tmp___26 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___26 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"allow chunked encoding:         %s\n\0" as *const u8 as *const libc::c_char,
        tmp___26,
    );
    if my.unique as u64 != 0 {
        tmp___27 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___27 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"upload unique files:            %s\n\0" as *const u8 as *const libc::c_char,
        tmp___27,
    );
    if my.json_output as u64 != 0 {
        tmp___28 = b"true\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___28 = b"false\0" as *const u8 as *const libc::c_char;
    }
    printf(
        b"json output:                    %s\n\0" as *const u8 as *const libc::c_char,
        tmp___28,
    );
    if my.parser as libc::c_uint == 1 as libc::c_uint {
        if (*my.nomap).index > 0 as libc::c_int {
            printf(b"no-follow:\n\0" as *const u8 as *const libc::c_char);
            i = 0 as libc::c_int;
            while i < (*my.nomap).index {
                printf(
                    b" - %s\n\0" as *const u8 as *const libc::c_char,
                    *((*my.nomap).line).offset(i as isize),
                );
                i += 1;
            }
        }
    }
    printf(b"proxy auth:                     \0" as *const u8 as *const libc::c_char);
    auth_display(my.auth, PROXY);
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    printf(b"www auth:                       \0" as *const u8 as *const libc::c_char);
    auth_display(my.auth, HTTP);
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    xfree(method___0 as *mut libc::c_void);
    my.auth = auth_destroy(my.auth);
    my.lurl = array_destroy(my.lurl);
    my.cookies = cookies_destroy(my.cookies);
    if EXIT != 0 {
        exit(0 as libc::c_int);
    } else {
        return 0 as libc::c_int
    };
}
pub unsafe extern "C" fn readline(
    mut s: *mut *mut libc::c_char,
    mut fp: *mut FILE,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut txt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut lop: BOOLEAN = boolean_false;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: libc::c_int = 0;
    len = 0 as libc::c_int;
    size = 0 as libc::c_int;
    tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    txt = 0 as *mut libc::c_void as *mut libc::c_char;
    lop = boolean_true;
    tmp___0 = xmalloc(1024 as libc::c_int as size_t);
    ptr = tmp___0 as *mut libc::c_char;
    size = 1024 as libc::c_int;
    loop {
        c = fgetc(fp);
        if !(c != -(1 as libc::c_int)) {
            break;
        }
        if !(c != 10 as libc::c_int) {
            break;
        }
        if len >= size {
            tmp___1 = realloc(
                ptr as *mut libc::c_void,
                (size + 1024 as libc::c_int) as size_t,
            );
            tmp = tmp___1 as *mut libc::c_char;
            if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                free(ptr as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            ptr = tmp;
            size += 1024 as libc::c_int;
        }
        tmp___2 = len;
        len += 1;
        *ptr.offset(tmp___2 as isize) = c as libc::c_char;
    }
    if len == 0 as libc::c_int {
        if c == -(1 as libc::c_int) {
            free(ptr as *mut libc::c_void);
            return -(1 as libc::c_int);
        } else {
            *ptr.offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            *s = ptr;
            return 0 as libc::c_int;
        }
    }
    if len + 1 as libc::c_int != size {
        tmp___3 = realloc(ptr as *mut libc::c_void, (len + 1 as libc::c_int) as size_t);
        tmp = tmp___3 as *mut libc::c_char;
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            free(ptr as *mut libc::c_void);
            return -(1 as libc::c_int);
        }
        ptr = tmp;
    }
    *ptr.offset(len as isize) = '\u{0}' as i32 as libc::c_char;
    txt = strdup(ptr as *const libc::c_char);
    trim(txt);
    tmp___4 = strncmp(
        txt as *const libc::c_char,
        b"login\0" as *const u8 as *const libc::c_char,
        5 as libc::c_int as size_t,
    );
    if tmp___4 == 0 as libc::c_int {
        lop = boolean_false;
    }
    xfree(txt as *mut libc::c_void);
    i = 0 as libc::c_int;
    while *ptr.offset(i as isize) as libc::c_int != 0 as libc::c_int {
        if *ptr.offset(i as isize) as libc::c_int == 35 as libc::c_int {
            if lop as libc::c_uint == 1 as libc::c_uint {
                *ptr.offset(i as isize) = '\u{0}' as i32 as libc::c_char;
            }
        }
        i += 1;
    }
    *s = ptr;
    return len;
}
pub unsafe extern "C" fn load_conf(mut filename: *mut libc::c_char) -> libc::c_int {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut H: HASH = 0 as *mut HASH_T;
    let mut line: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut option: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut optionptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zlib: BOOLEAN = boolean_false;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: BOOLEAN = boolean_false;
    let mut tmp___8: BOOLEAN = boolean_false;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: size_t = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_double = 0.;
    let mut tmp___20: libc::c_int = 0;
    let mut tmp___21: libc::c_int = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: libc::c_int = 0;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: BOOLEAN = boolean_false;
    let mut compress: BOOLEAN = boolean_false;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___28: CREDS = 0 as *mut CREDS_T;
    let mut tmp___29: BOOLEAN = boolean_false;
    let mut tmp___30: libc::c_int = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: CREDS = 0 as *mut CREDS_T;
    let mut tmp___35: CREDS = 0 as *mut CREDS_T;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: libc::c_int = 0;
    let mut tmp___38: libc::c_int = 0;
    let mut tmp___39: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___40: size_t = 0;
    let mut tmp___41: size_t = 0;
    let mut tmp___42: libc::c_int = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: libc::c_int = 0;
    let mut tmp___45: libc::c_int = 0;
    let mut tmp___46: libc::c_int = 0;
    let mut tmp___47: BOOLEAN = boolean_false;
    let mut tmp___48: BOOLEAN = boolean_false;
    let mut tmp___49: BOOLEAN = boolean_false;
    let mut tmp___50: BOOLEAN = boolean_false;
    let mut tmp___51: BOOLEAN = boolean_false;
    let mut tmp___52: BOOLEAN = boolean_false;
    let mut tmp___53: BOOLEAN = boolean_false;
    let mut tmp___54: BOOLEAN = boolean_false;
    let mut tmp___55: BOOLEAN = boolean_false;
    let mut tmp___56: BOOLEAN = boolean_false;
    let mut tmp___57: BOOLEAN = boolean_false;
    let mut tmp___58: BOOLEAN = boolean_false;
    let mut tmp___59: BOOLEAN = boolean_false;
    let mut tmp___60: BOOLEAN = boolean_false;
    let mut tmp___61: BOOLEAN = boolean_false;
    let mut tmp___62: BOOLEAN = boolean_false;
    let mut tmp___63: BOOLEAN = boolean_false;
    let mut tmp___64: BOOLEAN = boolean_false;
    let mut tmp___65: BOOLEAN = boolean_false;
    let mut tmp___66: BOOLEAN = boolean_false;
    let mut tmp___67: BOOLEAN = boolean_false;
    let mut tmp___68: libc::c_int = 0;
    let mut tmp___69: BOOLEAN = boolean_false;
    let mut tmp___70: BOOLEAN = boolean_false;
    let mut tmp___71: BOOLEAN = boolean_false;
    let mut tmp___72: BOOLEAN = boolean_false;
    let mut tmp___73: BOOLEAN = boolean_false;
    let mut tmp___74: BOOLEAN = boolean_false;
    let mut tmp___75: BOOLEAN = boolean_false;
    let mut tmp___76: BOOLEAN = boolean_false;
    let mut tmp___77: BOOLEAN = boolean_false;
    let mut tmp___78: BOOLEAN = boolean_false;
    let mut tmp___79: BOOLEAN = boolean_false;
    let mut tmp___80: BOOLEAN = boolean_false;
    let mut tmp___81: BOOLEAN = boolean_false;
    let mut tmp___82: BOOLEAN = boolean_false;
    let mut tmp___83: BOOLEAN = boolean_false;
    let mut tmp___84: BOOLEAN = boolean_false;
    let mut tmp___85: BOOLEAN = boolean_false;
    let mut tmp___86: BOOLEAN = boolean_false;
    let mut tmp___87: BOOLEAN = boolean_false;
    let mut tmp___88: BOOLEAN = boolean_false;
    let mut tmp___89: BOOLEAN = boolean_false;
    let mut tmp___90: BOOLEAN = boolean_false;
    let mut tmp___91: BOOLEAN = boolean_false;
    let mut tmp___92: BOOLEAN = boolean_false;
    let mut tmp___93: BOOLEAN = boolean_false;
    let mut tmp___94: BOOLEAN = boolean_false;
    let mut tmp___95: BOOLEAN = boolean_false;
    let mut tmp___96: libc::c_int = 0;
    zlib = boolean_true;
    fp = fopen(
        filename as *const libc::c_char,
        b"r\0" as *const u8 as *const libc::c_char,
    );
    if fp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    H = new_hash();
    loop {
        tmp___96 = readline(&mut line, fp);
        if !(tmp___96 != -(1 as libc::c_int)) {
            break;
        }
        tmp = line;
        line = trim(line);
        if *line as libc::c_int == 35 as libc::c_int {
            free(line as *mut libc::c_void);
        } else if *line as libc::c_int == 0 as libc::c_int {
            free(line as *mut libc::c_void);
        } else {
            tmp___0 = strlen(line as *const libc::c_char);
            if tmp___0 < 1 as libc::c_ulong {
                free(line as *mut libc::c_void);
            } else {
                option = xstrdup(line as *const libc::c_char);
                optionptr = option;
                while *optionptr != 0 {
                    tmp___1 = __ctype_b_loc();
                    if *(*tmp___1)
                        .offset(
                            *optionptr as libc::c_int as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int & 8192 as libc::c_int != 0
                    {
                        break;
                    }
                    if 61 as libc::c_int == *optionptr as libc::c_int {
                        break;
                    }
                    if 58 as libc::c_int == *optionptr as libc::c_int {
                        break;
                    }
                    optionptr = optionptr.offset(1);
                }
                tmp___2 = optionptr;
                optionptr = optionptr.offset(1);
                *tmp___2 = '\u{0}' as i32 as libc::c_char;
                loop {
                    tmp___3 = __ctype_b_loc();
                    if *(*tmp___3)
                        .offset(
                            *optionptr as libc::c_int as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int & 8192 as libc::c_int == 0
                    {
                        if !(61 as libc::c_int == *optionptr as libc::c_int) {
                            if !(58 as libc::c_int == *optionptr as libc::c_int) {
                                break;
                            }
                        }
                    }
                    optionptr = optionptr.offset(1);
                }
                value = xstrdup(optionptr as *const libc::c_char);
                while *line != 0 {
                    line = line.offset(1);
                }
                loop {
                    tmp___4 = strstr(
                        option as *const libc::c_char,
                        b"$\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___4.is_null() {
                        break;
                    }
                    option = evaluate(H, option);
                }
                loop {
                    tmp___5 = strstr(
                        value as *const libc::c_char,
                        b"$\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___5.is_null() {
                        break;
                    }
                    value = evaluate(H, value);
                }
                tmp___95 = strmatch(
                    option,
                    b"verbose\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if tmp___95 as u64 != 0 {
                    tmp___6 = strncasecmp(
                        value as *const libc::c_char,
                        b"true\0" as *const u8 as *const libc::c_char,
                        4 as libc::c_int as size_t,
                    );
                    if tmp___6 != 0 {
                        my.verbose = boolean_false;
                    } else {
                        my.verbose = boolean_true;
                    }
                } else {
                    tmp___94 = strmatch(
                        option,
                        b"color\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    if tmp___94 as u64 != 0 {
                        tmp___7 = strmatch(
                            value,
                            b"false\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        if tmp___7 as u64 != 0 {
                            my.color = boolean_false;
                        } else {
                            tmp___8 = strmatch(
                                value,
                                b"off\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            if tmp___8 as u64 != 0 {
                                my.color = boolean_false;
                            } else {
                                my.color = boolean_true;
                            }
                        }
                    } else {
                        tmp___93 = strmatch(
                            option,
                            b"quiet\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        if tmp___93 as u64 != 0 {
                            tmp___9 = strncasecmp(
                                value as *const libc::c_char,
                                b"true\0" as *const u8 as *const libc::c_char,
                                4 as libc::c_int as size_t,
                            );
                            if tmp___9 != 0 {
                                my.quiet = boolean_false;
                            } else {
                                my.quiet = boolean_true;
                            }
                        } else {
                            tmp___92 = strmatch(
                                option,
                                b"parser\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            if tmp___92 as u64 != 0 {
                                tmp___10 = strncasecmp(
                                    value as *const libc::c_char,
                                    b"true\0" as *const u8 as *const libc::c_char,
                                    4 as libc::c_int as size_t,
                                );
                                if tmp___10 != 0 {
                                    my.parser = boolean_false;
                                } else {
                                    my.parser = boolean_true;
                                }
                            } else {
                                tmp___91 = strmatch(
                                    option,
                                    b"nofollow\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                                if tmp___91 as u64 != 0 {
                                    if !value.is_null() {
                                        tmp___13 = strlen(value as *const libc::c_char);
                                        if tmp___13 > 3 as libc::c_ulong {
                                            tmp___11 = realloc(
                                                (*my.nomap).line as *mut libc::c_void,
                                                (::std::mem::size_of::<*mut libc::c_char>()
                                                    as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ((*my.nomap).index + 1 as libc::c_int) as libc::c_ulong,
                                                    ),
                                            );
                                            (*my.nomap).line = tmp___11 as *mut *mut libc::c_char;
                                            tmp___12 = strdup(value as *const libc::c_char);
                                            let ref mut fresh10 = *((*my.nomap).line)
                                                .offset((*my.nomap).index as isize);
                                            *fresh10 = tmp___12;
                                            (*my.nomap).index += 1;
                                        }
                                    }
                                } else {
                                    tmp___90 = strmatch(
                                        option,
                                        b"csv\0" as *const u8 as *const libc::c_char
                                            as *mut libc::c_char,
                                    );
                                    if tmp___90 as u64 != 0 {
                                        tmp___14 = strncasecmp(
                                            value as *const libc::c_char,
                                            b"true\0" as *const u8 as *const libc::c_char,
                                            4 as libc::c_int as size_t,
                                        );
                                        if tmp___14 != 0 {
                                            my.csv = boolean_false;
                                        } else {
                                            my.csv = boolean_true;
                                        }
                                    } else {
                                        tmp___89 = strmatch(
                                            option,
                                            b"fullurl\0" as *const u8 as *const libc::c_char
                                                as *mut libc::c_char,
                                        );
                                        if tmp___89 as u64 != 0 {
                                            tmp___15 = strncasecmp(
                                                value as *const libc::c_char,
                                                b"true\0" as *const u8 as *const libc::c_char,
                                                4 as libc::c_int as size_t,
                                            );
                                            if tmp___15 != 0 {
                                                my.fullurl = boolean_false;
                                            } else {
                                                my.fullurl = boolean_true;
                                            }
                                        } else {
                                            tmp___88 = strmatch(
                                                option,
                                                b"display-id\0" as *const u8 as *const libc::c_char
                                                    as *mut libc::c_char,
                                            );
                                            if tmp___88 as u64 != 0 {
                                                tmp___16 = strncasecmp(
                                                    value as *const libc::c_char,
                                                    b"true\0" as *const u8 as *const libc::c_char,
                                                    4 as libc::c_int as size_t,
                                                );
                                                if tmp___16 != 0 {
                                                    my.display = boolean_false;
                                                } else {
                                                    my.display = boolean_true;
                                                }
                                            } else {
                                                tmp___87 = strmatch(
                                                    option,
                                                    b"logging\0" as *const u8 as *const libc::c_char
                                                        as *mut libc::c_char,
                                                );
                                                if tmp___87 as u64 != 0 {
                                                    tmp___17 = strncasecmp(
                                                        value as *const libc::c_char,
                                                        b"true\0" as *const u8 as *const libc::c_char,
                                                        4 as libc::c_int as size_t,
                                                    );
                                                    if tmp___17 != 0 {
                                                        my.logging = boolean_false;
                                                    } else {
                                                        my.logging = boolean_true;
                                                    }
                                                } else {
                                                    tmp___86 = strmatch(
                                                        option,
                                                        b"show-logfile\0" as *const u8 as *const libc::c_char
                                                            as *mut libc::c_char,
                                                    );
                                                    if tmp___86 as u64 != 0 {
                                                        tmp___18 = strncasecmp(
                                                            value as *const libc::c_char,
                                                            b"true\0" as *const u8 as *const libc::c_char,
                                                            4 as libc::c_int as size_t,
                                                        );
                                                        if tmp___18 != 0 {
                                                            my.shlog = boolean_false;
                                                        } else {
                                                            my.shlog = boolean_true;
                                                        }
                                                    } else {
                                                        tmp___85 = strmatch(
                                                            option,
                                                            b"logfile\0" as *const u8 as *const libc::c_char
                                                                as *mut libc::c_char,
                                                        );
                                                        if tmp___85 as u64 != 0 {
                                                            strncpy(
                                                                (my.logfile).as_mut_ptr(),
                                                                value as *const libc::c_char,
                                                                ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                    as libc::c_ulong,
                                                            );
                                                        } else {
                                                            tmp___84 = strmatch(
                                                                option,
                                                                b"concurrent\0" as *const u8 as *const libc::c_char
                                                                    as *mut libc::c_char,
                                                            );
                                                            if tmp___84 as u64 != 0 {
                                                                if value as libc::c_ulong
                                                                    != 0 as *mut libc::c_void as libc::c_ulong
                                                                {
                                                                    my.cusers = atoi(value as *const libc::c_char);
                                                                } else {
                                                                    my.cusers = 10 as libc::c_int;
                                                                }
                                                            } else {
                                                                tmp___83 = strmatch(
                                                                    option,
                                                                    b"reps\0" as *const u8 as *const libc::c_char
                                                                        as *mut libc::c_char,
                                                                );
                                                                if tmp___83 as u64 != 0 {
                                                                    if value as libc::c_ulong
                                                                        != 0 as *mut libc::c_void as libc::c_ulong
                                                                    {
                                                                        my.reps = atoi(value as *const libc::c_char);
                                                                    } else {
                                                                        my.reps = 5 as libc::c_int;
                                                                    }
                                                                } else {
                                                                    tmp___82 = strmatch(
                                                                        option,
                                                                        b"limit\0" as *const u8 as *const libc::c_char
                                                                            as *mut libc::c_char,
                                                                    );
                                                                    if tmp___82 as u64 != 0 {
                                                                        if value as libc::c_ulong
                                                                            != 0 as *mut libc::c_void as libc::c_ulong
                                                                        {
                                                                            my.limit = atoi(value as *const libc::c_char);
                                                                        } else {
                                                                            my.limit = 255 as libc::c_int;
                                                                        }
                                                                    } else {
                                                                        tmp___81 = strmatch(
                                                                            option,
                                                                            b"time\0" as *const u8 as *const libc::c_char
                                                                                as *mut libc::c_char,
                                                                        );
                                                                        if tmp___81 as u64 != 0 {
                                                                            parse_time(value);
                                                                        } else {
                                                                            tmp___80 = strmatch(
                                                                                option,
                                                                                b"delay\0" as *const u8 as *const libc::c_char
                                                                                    as *mut libc::c_char,
                                                                            );
                                                                            if tmp___80 as u64 != 0 {
                                                                                if value as libc::c_ulong
                                                                                    != 0 as *mut libc::c_void as libc::c_ulong
                                                                                {
                                                                                    tmp___19 = atof(value as *const libc::c_char);
                                                                                    my.delay = tmp___19 as libc::c_float;
                                                                                } else {
                                                                                    my.delay = 1 as libc::c_int as libc::c_float;
                                                                                }
                                                                            } else {
                                                                                tmp___79 = strmatch(
                                                                                    option,
                                                                                    b"timeout\0" as *const u8 as *const libc::c_char
                                                                                        as *mut libc::c_char,
                                                                                );
                                                                                if tmp___79 as u64 != 0 {
                                                                                    if value as libc::c_ulong
                                                                                        != 0 as *mut libc::c_void as libc::c_ulong
                                                                                    {
                                                                                        my.timeout = atoi(value as *const libc::c_char);
                                                                                    } else {
                                                                                        my.timeout = 15 as libc::c_int;
                                                                                    }
                                                                                } else {
                                                                                    tmp___78 = strmatch(
                                                                                        option,
                                                                                        b"timestamp\0" as *const u8 as *const libc::c_char
                                                                                            as *mut libc::c_char,
                                                                                    );
                                                                                    if tmp___78 as u64 != 0 {
                                                                                        tmp___20 = strncasecmp(
                                                                                            value as *const libc::c_char,
                                                                                            b"true\0" as *const u8 as *const libc::c_char,
                                                                                            4 as libc::c_int as size_t,
                                                                                        );
                                                                                        if tmp___20 != 0 {
                                                                                            my.timestamp = boolean_false;
                                                                                        } else {
                                                                                            my.timestamp = boolean_true;
                                                                                        }
                                                                                    } else {
                                                                                        tmp___77 = strmatch(
                                                                                            option,
                                                                                            b"internet\0" as *const u8 as *const libc::c_char
                                                                                                as *mut libc::c_char,
                                                                                        );
                                                                                        if tmp___77 as u64 != 0 {
                                                                                            tmp___21 = strncasecmp(
                                                                                                value as *const libc::c_char,
                                                                                                b"true\0" as *const u8 as *const libc::c_char,
                                                                                                4 as libc::c_int as size_t,
                                                                                            );
                                                                                            if tmp___21 != 0 {
                                                                                                my.internet = boolean_false;
                                                                                            } else {
                                                                                                my.internet = boolean_true;
                                                                                            }
                                                                                        } else {
                                                                                            tmp___76 = strmatch(
                                                                                                option,
                                                                                                b"benchmark\0" as *const u8 as *const libc::c_char
                                                                                                    as *mut libc::c_char,
                                                                                            );
                                                                                            if tmp___76 as u64 != 0 {
                                                                                                tmp___22 = strncasecmp(
                                                                                                    value as *const libc::c_char,
                                                                                                    b"true\0" as *const u8 as *const libc::c_char,
                                                                                                    4 as libc::c_int as size_t,
                                                                                                );
                                                                                                if tmp___22 != 0 {
                                                                                                    my.bench = boolean_false;
                                                                                                } else {
                                                                                                    my.bench = boolean_true;
                                                                                                }
                                                                                            } else {
                                                                                                tmp___75 = strmatch(
                                                                                                    option,
                                                                                                    b"cache\0" as *const u8 as *const libc::c_char
                                                                                                        as *mut libc::c_char,
                                                                                                );
                                                                                                if tmp___75 as u64 != 0 {
                                                                                                    tmp___23 = strncasecmp(
                                                                                                        value as *const libc::c_char,
                                                                                                        b"true\0" as *const u8 as *const libc::c_char,
                                                                                                        4 as libc::c_int as size_t,
                                                                                                    );
                                                                                                    if tmp___23 != 0 {
                                                                                                        my.cache = boolean_false;
                                                                                                    } else {
                                                                                                        my.cache = boolean_true;
                                                                                                    }
                                                                                                } else {
                                                                                                    tmp___74 = strmatch(
                                                                                                        option,
                                                                                                        b"debug\0" as *const u8 as *const libc::c_char
                                                                                                            as *mut libc::c_char,
                                                                                                    );
                                                                                                    if tmp___74 as u64 != 0 {
                                                                                                        tmp___24 = strncasecmp(
                                                                                                            value as *const libc::c_char,
                                                                                                            b"true\0" as *const u8 as *const libc::c_char,
                                                                                                            4 as libc::c_int as size_t,
                                                                                                        );
                                                                                                        if tmp___24 != 0 {
                                                                                                            my.debug = boolean_false;
                                                                                                        } else {
                                                                                                            my.debug = boolean_true;
                                                                                                        }
                                                                                                    } else {
                                                                                                        tmp___73 = strmatch(
                                                                                                            option,
                                                                                                            b"gmethod\0" as *const u8 as *const libc::c_char
                                                                                                                as *mut libc::c_char,
                                                                                                        );
                                                                                                        if tmp___73 as u64 != 0 {
                                                                                                            tmp___25 = strmatch(
                                                                                                                value,
                                                                                                                b"GET\0" as *const u8 as *const libc::c_char
                                                                                                                    as *mut libc::c_char,
                                                                                                            );
                                                                                                            if tmp___25 as u64 != 0 {
                                                                                                                my.method = 2 as libc::c_int;
                                                                                                            } else {
                                                                                                                my.method = 1 as libc::c_int;
                                                                                                            }
                                                                                                        } else {
                                                                                                            tmp___72 = strmatch(
                                                                                                                option,
                                                                                                                b"file\0" as *const u8 as *const libc::c_char
                                                                                                                    as *mut libc::c_char,
                                                                                                            );
                                                                                                            if tmp___72 as u64 != 0 {
                                                                                                                memset(
                                                                                                                    (my.file).as_mut_ptr() as *mut libc::c_void,
                                                                                                                    0 as libc::c_int,
                                                                                                                    ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                                                                        as libc::c_ulong,
                                                                                                                );
                                                                                                                strncpy(
                                                                                                                    (my.file).as_mut_ptr(),
                                                                                                                    value as *const libc::c_char,
                                                                                                                    ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                                                                        as libc::c_ulong,
                                                                                                                );
                                                                                                            } else {
                                                                                                                tmp___71 = strmatch(
                                                                                                                    option,
                                                                                                                    b"url\0" as *const u8 as *const libc::c_char
                                                                                                                        as *mut libc::c_char,
                                                                                                                );
                                                                                                                if tmp___71 as u64 != 0 {
                                                                                                                    my.url = stralloc(value);
                                                                                                                } else {
                                                                                                                    tmp___70 = strmatch(
                                                                                                                        option,
                                                                                                                        b"user-agent\0" as *const u8 as *const libc::c_char
                                                                                                                            as *mut libc::c_char,
                                                                                                                    );
                                                                                                                    if tmp___70 as u64 != 0 {
                                                                                                                        strncpy(
                                                                                                                            (my.uagent).as_mut_ptr(),
                                                                                                                            value as *const libc::c_char,
                                                                                                                            ::std::mem::size_of::<[libc::c_char; 256]>()
                                                                                                                                as libc::c_ulong,
                                                                                                                        );
                                                                                                                    } else {
                                                                                                                        tmp___69 = strmatch(
                                                                                                                            option,
                                                                                                                            b"accept-encoding\0" as *const u8 as *const libc::c_char
                                                                                                                                as *mut libc::c_char,
                                                                                                                        );
                                                                                                                        if tmp___69 as u64 != 0 {
                                                                                                                            compress = boolean_false;
                                                                                                                            tmp___26 = strstr(
                                                                                                                                value as *const libc::c_char,
                                                                                                                                b"gzip\0" as *const u8 as *const libc::c_char,
                                                                                                                            );
                                                                                                                            if tmp___26 as libc::c_ulong
                                                                                                                                != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                            {
                                                                                                                                compress = boolean_true;
                                                                                                                            } else {
                                                                                                                                tmp___27 = strstr(
                                                                                                                                    value as *const libc::c_char,
                                                                                                                                    b"compress\0" as *const u8 as *const libc::c_char,
                                                                                                                                );
                                                                                                                                if tmp___27 as libc::c_ulong
                                                                                                                                    != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                                {
                                                                                                                                    compress = boolean_true;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            if compress as libc::c_uint == 1 as libc::c_uint {
                                                                                                                                if zlib as libc::c_uint == 0 as libc::c_uint {
                                                                                                                                    NOTIFY(
                                                                                                                                        WARNING,
                                                                                                                                        b"Zip encoding disabled; siege requires zlib support to enable it\0"
                                                                                                                                            as *const u8 as *const libc::c_char,
                                                                                                                                    );
                                                                                                                                } else {
                                                                                                                                    strncpy(
                                                                                                                                        (my.encoding).as_mut_ptr(),
                                                                                                                                        value as *const libc::c_char,
                                                                                                                                        ::std::mem::size_of::<[libc::c_char; 256]>()
                                                                                                                                            as libc::c_ulong,
                                                                                                                                    );
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                strncpy(
                                                                                                                                    (my.encoding).as_mut_ptr(),
                                                                                                                                    value as *const libc::c_char,
                                                                                                                                    ::std::mem::size_of::<[libc::c_char; 256]>()
                                                                                                                                        as libc::c_ulong,
                                                                                                                                );
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            tmp___68 = strncasecmp(
                                                                                                                                option as *const libc::c_char,
                                                                                                                                b"login\0" as *const u8 as *const libc::c_char,
                                                                                                                                5 as libc::c_int as size_t,
                                                                                                                            );
                                                                                                                            if tmp___68 != 0 {
                                                                                                                                tmp___67 = strmatch(
                                                                                                                                    option,
                                                                                                                                    b"attempts\0" as *const u8 as *const libc::c_char
                                                                                                                                        as *mut libc::c_char,
                                                                                                                                );
                                                                                                                                if tmp___67 as u64 != 0 {
                                                                                                                                    if value as libc::c_ulong
                                                                                                                                        != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                                    {
                                                                                                                                        my.bids = atoi(value as *const libc::c_char);
                                                                                                                                    } else {
                                                                                                                                        my.bids = 3 as libc::c_int;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    tmp___66 = strmatch(
                                                                                                                                        option,
                                                                                                                                        b"connection\0" as *const u8 as *const libc::c_char
                                                                                                                                            as *mut libc::c_char,
                                                                                                                                    );
                                                                                                                                    if tmp___66 as u64 != 0 {
                                                                                                                                        tmp___30 = strncasecmp(
                                                                                                                                            value as *const libc::c_char,
                                                                                                                                            b"keep-alive\0" as *const u8 as *const libc::c_char,
                                                                                                                                            10 as libc::c_int as size_t,
                                                                                                                                        );
                                                                                                                                        if tmp___30 != 0 {
                                                                                                                                            my.keepalive = boolean_false;
                                                                                                                                        } else {
                                                                                                                                            my.keepalive = boolean_true;
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        tmp___65 = strmatch(
                                                                                                                                            option,
                                                                                                                                            b"protocol\0" as *const u8 as *const libc::c_char
                                                                                                                                                as *mut libc::c_char,
                                                                                                                                        );
                                                                                                                                        if tmp___65 as u64 != 0 {
                                                                                                                                            tmp___31 = strncasecmp(
                                                                                                                                                value as *const libc::c_char,
                                                                                                                                                b"HTTP/1.1\0" as *const u8 as *const libc::c_char,
                                                                                                                                                8 as libc::c_int as size_t,
                                                                                                                                            );
                                                                                                                                            if tmp___31 != 0 {
                                                                                                                                                my.protocol = 0 as libc::c_int;
                                                                                                                                            } else {
                                                                                                                                                my.protocol = 1 as libc::c_int;
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            tmp___64 = strmatch(
                                                                                                                                                option,
                                                                                                                                                b"proxy-host\0" as *const u8 as *const libc::c_char
                                                                                                                                                    as *mut libc::c_char,
                                                                                                                                            );
                                                                                                                                            if tmp___64 as u64 != 0 {
                                                                                                                                                tmp___32 = trim(value);
                                                                                                                                                auth_set_proxy_host(my.auth, tmp___32);
                                                                                                                                            } else {
                                                                                                                                                tmp___63 = strmatch(
                                                                                                                                                    option,
                                                                                                                                                    b"proxy-port\0" as *const u8 as *const libc::c_char
                                                                                                                                                        as *mut libc::c_char,
                                                                                                                                                );
                                                                                                                                                if tmp___63 as u64 != 0 {
                                                                                                                                                    if value as libc::c_ulong
                                                                                                                                                        != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                                                    {
                                                                                                                                                        tmp___33 = atoi(value as *const libc::c_char);
                                                                                                                                                        auth_set_proxy_port(my.auth, tmp___33);
                                                                                                                                                    } else {
                                                                                                                                                        auth_set_proxy_port(my.auth, 3128 as libc::c_int);
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    tmp___62 = strmatch(
                                                                                                                                                        option,
                                                                                                                                                        b"ftp-login\0" as *const u8 as *const libc::c_char
                                                                                                                                                            as *mut libc::c_char,
                                                                                                                                                    );
                                                                                                                                                    if tmp___62 as u64 != 0 {
                                                                                                                                                        tmp___34 = new_creds(FTP, value);
                                                                                                                                                        auth_add(my.auth, tmp___34);
                                                                                                                                                    } else {
                                                                                                                                                        tmp___61 = strmatch(
                                                                                                                                                            option,
                                                                                                                                                            b"proxy-login\0" as *const u8 as *const libc::c_char
                                                                                                                                                                as *mut libc::c_char,
                                                                                                                                                        );
                                                                                                                                                        if tmp___61 as u64 != 0 {
                                                                                                                                                            tmp___35 = new_creds(PROXY, value);
                                                                                                                                                            auth_add(my.auth, tmp___35);
                                                                                                                                                        } else {
                                                                                                                                                            tmp___60 = strmatch(
                                                                                                                                                                option,
                                                                                                                                                                b"failures\0" as *const u8 as *const libc::c_char
                                                                                                                                                                    as *mut libc::c_char,
                                                                                                                                                            );
                                                                                                                                                            if tmp___60 as u64 != 0 {
                                                                                                                                                                if value as libc::c_ulong
                                                                                                                                                                    != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                                                                {
                                                                                                                                                                    my.failures = atoi(value as *const libc::c_char);
                                                                                                                                                                } else {
                                                                                                                                                                    my.failures = 30 as libc::c_int;
                                                                                                                                                                }
                                                                                                                                                            } else {
                                                                                                                                                                tmp___59 = strmatch(
                                                                                                                                                                    option,
                                                                                                                                                                    b"chunked\0" as *const u8 as *const libc::c_char
                                                                                                                                                                        as *mut libc::c_char,
                                                                                                                                                                );
                                                                                                                                                                if tmp___59 as u64 != 0 {
                                                                                                                                                                    tmp___36 = strncasecmp(
                                                                                                                                                                        value as *const libc::c_char,
                                                                                                                                                                        b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                        4 as libc::c_int as size_t,
                                                                                                                                                                    );
                                                                                                                                                                    if tmp___36 != 0 {
                                                                                                                                                                        my.chunked = boolean_false;
                                                                                                                                                                    } else {
                                                                                                                                                                        my.chunked = boolean_true;
                                                                                                                                                                    }
                                                                                                                                                                } else {
                                                                                                                                                                    tmp___58 = strmatch(
                                                                                                                                                                        option,
                                                                                                                                                                        b"unique\0" as *const u8 as *const libc::c_char
                                                                                                                                                                            as *mut libc::c_char,
                                                                                                                                                                    );
                                                                                                                                                                    if tmp___58 as u64 != 0 {
                                                                                                                                                                        tmp___37 = strncasecmp(
                                                                                                                                                                            value as *const libc::c_char,
                                                                                                                                                                            b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                            4 as libc::c_int as size_t,
                                                                                                                                                                        );
                                                                                                                                                                        if tmp___37 != 0 {
                                                                                                                                                                            my.unique = boolean_false;
                                                                                                                                                                        } else {
                                                                                                                                                                            my.unique = boolean_true;
                                                                                                                                                                        }
                                                                                                                                                                    } else {
                                                                                                                                                                        tmp___57 = strmatch(
                                                                                                                                                                            option,
                                                                                                                                                                            b"json_output\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                as *mut libc::c_char,
                                                                                                                                                                        );
                                                                                                                                                                        if tmp___57 as u64 != 0 {
                                                                                                                                                                            tmp___38 = strncasecmp(
                                                                                                                                                                                value as *const libc::c_char,
                                                                                                                                                                                b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                4 as libc::c_int as size_t,
                                                                                                                                                                            );
                                                                                                                                                                            if tmp___38 != 0 {
                                                                                                                                                                                my.json_output = boolean_false;
                                                                                                                                                                            } else {
                                                                                                                                                                                my.json_output = boolean_true;
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                            tmp___56 = strmatch(
                                                                                                                                                                                option,
                                                                                                                                                                                b"header\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                    as *mut libc::c_char,
                                                                                                                                                                            );
                                                                                                                                                                            if tmp___56 as u64 != 0 {
                                                                                                                                                                                tmp___39 = strchr(value as *const libc::c_char, ':' as i32);
                                                                                                                                                                                if tmp___39.is_null() {
                                                                                                                                                                                    NOTIFY(
                                                                                                                                                                                        FATAL,
                                                                                                                                                                                        b"no ':' in http-header\0" as *const u8
                                                                                                                                                                                            as *const libc::c_char,
                                                                                                                                                                                    );
                                                                                                                                                                                }
                                                                                                                                                                                tmp___40 = strlen(value as *const libc::c_char);
                                                                                                                                                                                tmp___41 = strlen(
                                                                                                                                                                                    (my.extra).as_mut_ptr() as *const libc::c_char,
                                                                                                                                                                                );
                                                                                                                                                                                if tmp___40
                                                                                                                                                                                    .wrapping_add(tmp___41)
                                                                                                                                                                                    .wrapping_add(3 as libc::c_ulong) > 512 as libc::c_ulong
                                                                                                                                                                                {
                                                                                                                                                                                    NOTIFY(
                                                                                                                                                                                        FATAL,
                                                                                                                                                                                        b"too many headers\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                    );
                                                                                                                                                                                }
                                                                                                                                                                                strcat(
                                                                                                                                                                                    (my.extra).as_mut_ptr(),
                                                                                                                                                                                    value as *const libc::c_char,
                                                                                                                                                                                );
                                                                                                                                                                                strcat(
                                                                                                                                                                                    (my.extra).as_mut_ptr(),
                                                                                                                                                                                    b"\r\n\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                );
                                                                                                                                                                            } else {
                                                                                                                                                                                tmp___55 = strmatch(
                                                                                                                                                                                    option,
                                                                                                                                                                                    b"expire-session\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                        as *mut libc::c_char,
                                                                                                                                                                                );
                                                                                                                                                                                if tmp___55 as u64 != 0 {
                                                                                                                                                                                    tmp___42 = strncasecmp(
                                                                                                                                                                                        value as *const libc::c_char,
                                                                                                                                                                                        b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                        4 as libc::c_int as size_t,
                                                                                                                                                                                    );
                                                                                                                                                                                    if tmp___42 != 0 {
                                                                                                                                                                                        my.expire = boolean_false;
                                                                                                                                                                                    } else {
                                                                                                                                                                                        my.expire = boolean_true;
                                                                                                                                                                                    }
                                                                                                                                                                                } else {
                                                                                                                                                                                    tmp___54 = strmatch(
                                                                                                                                                                                        option,
                                                                                                                                                                                        b"follow-location\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                            as *mut libc::c_char,
                                                                                                                                                                                    );
                                                                                                                                                                                    if tmp___54 as u64 != 0 {
                                                                                                                                                                                        tmp___43 = strncasecmp(
                                                                                                                                                                                            value as *const libc::c_char,
                                                                                                                                                                                            b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                            4 as libc::c_int as size_t,
                                                                                                                                                                                        );
                                                                                                                                                                                        if tmp___43 != 0 {
                                                                                                                                                                                            my.follow = boolean_false;
                                                                                                                                                                                        } else {
                                                                                                                                                                                            my.follow = boolean_true;
                                                                                                                                                                                        }
                                                                                                                                                                                    } else {
                                                                                                                                                                                        tmp___53 = strmatch(
                                                                                                                                                                                            option,
                                                                                                                                                                                            b"url-escaping\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                as *mut libc::c_char,
                                                                                                                                                                                        );
                                                                                                                                                                                        if tmp___53 as u64 != 0 {
                                                                                                                                                                                            tmp___44 = strncasecmp(
                                                                                                                                                                                                value as *const libc::c_char,
                                                                                                                                                                                                b"false\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                                5 as libc::c_int as size_t,
                                                                                                                                                                                            );
                                                                                                                                                                                            if tmp___44 != 0 {
                                                                                                                                                                                                my.escape = boolean_true;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                my.escape = boolean_false;
                                                                                                                                                                                            }
                                                                                                                                                                                        } else {
                                                                                                                                                                                            tmp___52 = strmatch(
                                                                                                                                                                                                option,
                                                                                                                                                                                                b"zero-data-ok\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                    as *mut libc::c_char,
                                                                                                                                                                                            );
                                                                                                                                                                                            if tmp___52 as u64 != 0 {
                                                                                                                                                                                                tmp___45 = strncasecmp(
                                                                                                                                                                                                    value as *const libc::c_char,
                                                                                                                                                                                                    b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                                    4 as libc::c_int as size_t,
                                                                                                                                                                                                );
                                                                                                                                                                                                if tmp___45 != 0 {
                                                                                                                                                                                                    my.zero_ok = boolean_false;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    my.zero_ok = boolean_true;
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                tmp___51 = strmatch(
                                                                                                                                                                                                    option,
                                                                                                                                                                                                    b"ssl-cert\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                        as *mut libc::c_char,
                                                                                                                                                                                                );
                                                                                                                                                                                                if tmp___51 as u64 != 0 {
                                                                                                                                                                                                    my.ssl_cert = stralloc(value);
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    tmp___50 = strmatch(
                                                                                                                                                                                                        option,
                                                                                                                                                                                                        b"ssl-key\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                            as *mut libc::c_char,
                                                                                                                                                                                                    );
                                                                                                                                                                                                    if tmp___50 as u64 != 0 {
                                                                                                                                                                                                        my.ssl_key = stralloc(value);
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        tmp___49 = strmatch(
                                                                                                                                                                                                            option,
                                                                                                                                                                                                            b"ssl-timeout\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                                as *mut libc::c_char,
                                                                                                                                                                                                        );
                                                                                                                                                                                                        if tmp___49 as u64 != 0 {
                                                                                                                                                                                                            if value as libc::c_ulong
                                                                                                                                                                                                                != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                                                                                                            {
                                                                                                                                                                                                                my.ssl_timeout = atoi(value as *const libc::c_char);
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                my.ssl_timeout = 15 as libc::c_int;
                                                                                                                                                                                                            }
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                            tmp___48 = strmatch(
                                                                                                                                                                                                                option,
                                                                                                                                                                                                                b"ssl-ciphers\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                                    as *mut libc::c_char,
                                                                                                                                                                                                            );
                                                                                                                                                                                                            if tmp___48 as u64 != 0 {
                                                                                                                                                                                                                my.ssl_ciphers = stralloc(value);
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                tmp___47 = strmatch(
                                                                                                                                                                                                                    option,
                                                                                                                                                                                                                    b"spinner\0" as *const u8 as *const libc::c_char
                                                                                                                                                                                                                        as *mut libc::c_char,
                                                                                                                                                                                                                );
                                                                                                                                                                                                                if tmp___47 as u64 != 0 {
                                                                                                                                                                                                                    tmp___46 = strncasecmp(
                                                                                                                                                                                                                        value as *const libc::c_char,
                                                                                                                                                                                                                        b"true\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                                                        4 as libc::c_int as size_t,
                                                                                                                                                                                                                    );
                                                                                                                                                                                                                    if tmp___46 != 0 {
                                                                                                                                                                                                                        my.spinner = boolean_false;
                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                        my.spinner = boolean_true;
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                    hash_add(H, option, value as *mut libc::c_void);
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                tmp___29 = strmatch(
                                                                                                                                    option,
                                                                                                                                    b"login-url\0" as *const u8 as *const libc::c_char
                                                                                                                                        as *mut libc::c_char,
                                                                                                                                );
                                                                                                                                if tmp___29 as u64 != 0 {
                                                                                                                                    my.login = boolean_true;
                                                                                                                                    array_push(my.lurl, value as *mut libc::c_void);
                                                                                                                                } else {
                                                                                                                                    tmp___28 = new_creds(HTTP, value);
                                                                                                                                    auth_add(my.auth, tmp___28);
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                xfree(tmp as *mut libc::c_void);
                xfree(value as *mut libc::c_void);
                xfree(option as *mut libc::c_void);
            }
        }
    }
    H = hash_destroy(H);
    fclose(fp);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn ds_module_check() {
    if my.bench as u64 != 0 {
        my.delay = 0 as libc::c_int as libc::c_float;
    }
    if my.secs > 0 as libc::c_int {
        if my.reps > 0 as libc::c_int {
            if my.reps != 10301062 as libc::c_int {
                NOTIFY(
                    ERROR,
                    b"CONFIG conflict: selected time and repetition based testing\0"
                        as *const u8 as *const libc::c_char,
                );
                fprintf(
                    stderr,
                    b"defaulting to time-based testing: %d seconds\n\0" as *const u8
                        as *const libc::c_char,
                    my.secs,
                );
                my.reps = 10301062 as libc::c_int;
            }
        }
    }
    if my.cusers <= 0 as libc::c_int {
        my.cusers = 1 as libc::c_int;
    }
    if my.get as u64 != 0 {
        my.cusers = 1 as libc::c_int;
        my.reps = 1 as libc::c_int;
        my.logging = boolean_false;
        my.bench = boolean_true;
    }
    if my.json_output as u64 != 0 {
        my.quiet = boolean_true;
    }
    if my.quiet as u64 != 0 {
        my.verbose = boolean_false;
        my.debug = boolean_false;
    }
}
static mut tmap: [ContentType; 168] = [
    {
        let mut init = ContentType {
            ext: b"default\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"application/x-www-form-urlencoded\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ai\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/postscript\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"aif\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-aiff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"aifc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-aiff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"aiff\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-aiff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"asc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"au\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/basic\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"avi\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/x-msvideo\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"bcpio\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-bcpio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"bin\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"c\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"cc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ccad\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/clariscad\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"cdf\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-netcdf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"class\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"cpio\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-cpio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"cpt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/mac-compactpro\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"csh\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-csh\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"css\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/css\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"csv\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/csv\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dcr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-director\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dir\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-director\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dms\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"doc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/msword\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"drw\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/drafting\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dvi\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-dvi\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dwg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/acad\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dxf\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/dxf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"dxr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-director\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"eps\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/postscript\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"etx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/x-setext\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"exe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ez\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/andrew-inset\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"f\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"f90\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"fli\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/x-fli\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"gif\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/gif\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"gtar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-gtar\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"gz\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-gzip\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"h\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"hdf\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-hdf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"hh\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"hqx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/mac-binhex40\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"htm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/html\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"html\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/html\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ice\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"x-conference/x-cooltalk\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ico\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-icon\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ief\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/ief\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"iges\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/iges\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"igs\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/iges\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ips\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-ipscript\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ipx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-ipix\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"jpe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/jpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"jpeg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/jpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"jpg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/jpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"js\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-javascript\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"json\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/json\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"kar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/midi\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"latex\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-latex\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"lha\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"lsp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-lisp\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"lzh\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"m\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"man\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-troff-man\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"md\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/x-markdown\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"me\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-troff-me\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mesh\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/mesh\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/midi\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"midi\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/midi\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mif\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vnd.mif\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mime\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"www/mime\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mov\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/quicktime\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"movie\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/x-sgi-movie\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mp2\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/mpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mp3\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/mpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mpe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/mpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mpeg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/mpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mpg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/mpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"mpga\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/mpeg\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ms\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-troff-ms\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"msh\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/mesh\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"nc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-netcdf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"oda\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/oda\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pbm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-portable-bitmap\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pdb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"chemical/x-pdb\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pdf\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/pdf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pgm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-portable-graymap\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pgn\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-chess-pgn\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"png\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/png\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pnm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-portable-anymap\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pot\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/mspowerpoint\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ppm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-portable-pixmap\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pps\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/mspowerpoint\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ppt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/mspowerpoint\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ppz\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/mspowerpoint\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"pre\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-freelance\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"proto\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-protobuf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"prt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/pro_eng\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ps\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/postscript\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"qt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/quicktime\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ra\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-realaudio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ram\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-pn-realaudio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ras\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/cmu-raster\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"rgb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-rgb\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"rm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-pn-realaudio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"roff\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-troff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"rpm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-pn-realaudio-plugin\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"rtf\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"text/rtf\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"rtx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"text/richtext\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"scm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-lotusscreencam\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"set\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/set\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sgm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/sgml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sgml\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/sgml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sh\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-sh\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"shar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-shar\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"silo\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/mesh\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sit\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-stuffit\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"skd\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-koan\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"skm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-koan\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"skp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-koan\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"skt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-koan\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"smi\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/smil\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"smil\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/smil\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"snd\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/basic\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sol\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/solids\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"spl\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-futuresplash\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"src\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-wais-source\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"step\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/STEP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"stl\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/SLA\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"stp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/STEP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sv4cpio\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-sv4cpio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"sv4crc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-sv4crc\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"svg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"image/svg+xml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"swf\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-shockwave-flash\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"t\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-troff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-tar\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tcl\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-tcl\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tex\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-tex\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"texi\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-texinfo\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"texinfo\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-texinfo\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tif\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/tiff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tiff\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/tiff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-troff\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tsi\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/TSP-audio\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tsp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/dsptype\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"tsv\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/tab-separated-values\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"txt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/plain\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"unv\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/i-deas\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"ustar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-ustar\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"vcd\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/x-cdlink\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"vda\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vda\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"viv\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/vnd.vivo\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"vivo\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"video/vnd.vivo\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"vrml\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/vrml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"wav\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"audio/x-wav\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"wrl\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"model/vrml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xbm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-xbitmap\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xlc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vnd.ms-excel\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xll\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vnd.ms-excel\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xlm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vnd.ms-excel\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xls\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vnd.ms-excel\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xlw\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/vnd.ms-excel\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xml\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"text/xml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xpm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-xpixmap\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xwd\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"image/x-xwindowdump\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"xyz\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"chemical/x-pdb\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"yml\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_true,
            type_0: b"application/x-yaml\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
    {
        let mut init = ContentType {
            ext: b"zip\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ascii: boolean_false,
            type_0: b"application/zip\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        };
        init
    },
];
pub unsafe extern "C" fn get_file_extension(
    mut file: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut dot: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = strrchr(file as *const libc::c_char, '.' as i32);
    dot = tmp;
    if dot.is_null() {
        return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char
    } else {
        if dot as libc::c_ulong == file as libc::c_ulong {
            return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
    }
    return dot.offset(1 as libc::c_int as isize);
}
pub unsafe extern "C" fn get_content_type(
    mut file: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut ext: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: BOOLEAN = boolean_false;
    ext = get_file_extension(file);
    i = 0 as libc::c_int;
    while i
        < ::std::mem::size_of::<[ContentType; 168]>() as libc::c_ulong as libc::c_int
            / ::std::mem::size_of::<ContentType>() as libc::c_ulong as libc::c_int
    {
        tmp = strmatch(ext, tmap[i as usize].ext);
        if tmp as u64 != 0 {
            return tmap[i as usize].type_0;
        }
        i += 1;
    }
    return tmap[0 as libc::c_int as usize].type_0;
}
pub unsafe extern "C" fn is_ascii(mut file: *mut libc::c_char) -> BOOLEAN {
    let mut i: libc::c_int = 0;
    let mut ext: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: BOOLEAN = boolean_false;
    ext = get_file_extension(file);
    i = 0 as libc::c_int;
    while i
        < ::std::mem::size_of::<[ContentType; 168]>() as libc::c_ulong as libc::c_int
            / ::std::mem::size_of::<ContentType>() as libc::c_ulong as libc::c_int
    {
        tmp = strmatch(ext, tmap[i as usize].ext);
        if tmp as u64 != 0 {
            return tmap[i as usize].ascii;
        }
        i += 1;
    }
    return tmap[0 as libc::c_int as usize].ascii;
}
pub unsafe extern "C" fn load_file(mut U: URL, mut file: *mut libc::c_char) {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut len: size_t = 0;
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut filename: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut mode: [libc::c_char; 8] = [0; 8];
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: libc::c_long = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: BOOLEAN = boolean_false;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: BOOLEAN = boolean_false;
    filename = trim(file);
    memset(
        mode.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
    );
    tmp___1 = is_ascii(filename);
    if tmp___1 as u64 != 0 {
        tmp___0 = b"r\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = b"rb\0" as *const u8 as *const libc::c_char;
    }
    snprintf(
        mode.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    fp = fopen(
        filename as *const libc::c_char,
        mode.as_mut_ptr() as *const libc::c_char,
    );
    if fp.is_null() {
        NOTIFY(
            ERROR,
            b"unable to open file: %s\0" as *const u8 as *const libc::c_char,
            filename,
        );
        return;
    }
    fseek(fp, 0 as libc::c_long, 2 as libc::c_int);
    tmp___2 = ftell(fp);
    len = tmp___2 as size_t;
    fseek(fp, 0 as libc::c_long, 0 as libc::c_int);
    tmp___3 = xmalloc(len.wrapping_add(1 as libc::c_ulong));
    buf = tmp___3 as *mut libc::c_char;
    tmp___5 = fread(buf as *mut libc::c_void, 1 as libc::c_int as size_t, len, fp);
    if tmp___5 == len {
        tmp___4 = is_ascii(filename);
        if tmp___4 as u64 != 0 {
            *buf.offset(len as isize) = '\u{0}' as i32 as libc::c_char;
            trim(buf);
            len = strlen(buf as *const libc::c_char);
        }
    } else {
        NOTIFY(
            ERROR,
            b"unable to read file: %s\0" as *const u8 as *const libc::c_char,
            filename,
        );
    }
    fclose(fp);
    if len > 0 as libc::c_ulong {
        tmp___7 = empty((my.conttype).as_mut_ptr() as *const libc::c_char);
        if tmp___7 as u64 != 0 {
            tmp___6 = get_content_type(filename);
            url_set_conttype(U, tmp___6);
        } else {
            url_set_conttype(U, (my.conttype).as_mut_ptr());
        }
        url_set_postdata(U, buf, len);
    }
    xfree(buf as *mut libc::c_void);
}
pub unsafe extern "C" fn write_file(
    mut U: URL,
    mut buf: *mut libc::c_char,
    mut len: size_t,
) {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut mode: [libc::c_char; 8] = [0; 8];
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    memset(
        mode.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
    );
    tmp___1 = url_get_file(U);
    if !tmp___1.is_null() {
        tmp___0 = b"w\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = b"wb\0" as *const u8 as *const libc::c_char;
    }
    snprintf(
        mode.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    tmp___2 = url_get_file(U);
    fp = fopen(tmp___2 as *const libc::c_char, mode.as_mut_ptr() as *const libc::c_char);
    if !fp.is_null() {
        fwrite(buf as *const libc::c_void, len, 1 as libc::c_int as size_t, fp);
    } else {
        NOTIFY(ERROR, b"unable to write to file\0" as *const u8 as *const libc::c_char);
    }
    fclose(fp);
}
pub unsafe extern "C" fn log_transaction(mut D: DATA) {
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: libc::c_float = 0.;
    let mut tmp___1: libc::c_float = 0.;
    let mut tmp___2: libc::c_float = 0.;
    let mut tmp___3: libc::c_uint = 0;
    tmp = data_get_code(D);
    tmp___0 = data_get_total(D);
    tmp___1 = data_get_megabytes(D);
    tmp___2 = data_get_elapsed(D);
    tmp___3 = data_get_count(D);
    write_to_log(
        tmp___3 as libc::c_int,
        tmp___2,
        tmp___1 as libc::c_int,
        tmp___0,
        tmp as libc::c_int,
        my.failed,
    );
}
pub unsafe extern "C" fn write_to_log(
    mut count___0: libc::c_int,
    mut elapsed: libc::c_float,
    mut bytes: libc::c_int,
    mut ttime: libc::c_float,
    mut code: libc::c_int,
    mut failed: libc::c_int,
) {
    let mut fd: libc::c_int = 0;
    let mut entry: [libc::c_char; 512] = [0; 512];
    let mut keepsake: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: *mut tm = 0 as *mut tm;
    let mut now: time_t = 0;
    let mut len: size_t = 0;
    let mut date: [libc::c_char; 65] = [0; 65];
    let mut tmp___0: *mut tm = 0 as *mut tm;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: BOOLEAN = boolean_false;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: ssize_t = 0;
    let mut tmp___6: *mut libc::c_int = 0 as *mut libc::c_int;
    len = 0 as libc::c_int as size_t;
    now = time(0 as *mut libc::c_void as *mut time_t);
    tmp___0 = localtime_r(
        &mut now as *mut time_t as *const time_t,
        &mut keepsake as *mut tm,
    );
    tmp = tmp___0;
    setlocale(2 as libc::c_int, b"C\0" as *const u8 as *const libc::c_char);
    len = strftime(
        date.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 65]>() as libc::c_ulong,
        b"%Y-%m-%d %H:%M:%S\0" as *const u8 as *const libc::c_char,
        tmp as *const tm,
    );
    if my.shlog as u64 != 0 {
        printf(
            b"LOG FILE: %s\n\0" as *const u8 as *const libc::c_char,
            (my.logfile).as_mut_ptr(),
        );
        printf(
            b"You can disable this log file notification by editing\n\0" as *const u8
                as *const libc::c_char,
        );
        tmp___1 = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
        printf(b"%s/.siege/siege.conf \0" as *const u8 as *const libc::c_char, tmp___1);
        puts(
            b"and changing 'show-logfile' to false.\0" as *const u8
                as *const libc::c_char,
        );
    }
    tmp___3 = file_exists((my.logfile).as_mut_ptr());
    if tmp___3 as u64 == 0 {
        tmp___2 = create_logfile((my.logfile).as_mut_ptr() as *const libc::c_char);
        if tmp___2 as u64 == 0 {
            NOTIFY(
                ERROR,
                b"unable to create log file: %s\0" as *const u8 as *const libc::c_char,
                (my.logfile).as_mut_ptr(),
            );
            return;
        }
    }
    snprintf(
        entry.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
        b"%s,%7d,%11.2f,%12u,%11.2f,%12.2f,%12.2f,%12.2f,%8d,%8d\n\0" as *const u8
            as *const libc::c_char,
        date.as_mut_ptr(),
        count___0,
        elapsed as libc::c_double,
        bytes,
        (ttime / count___0 as libc::c_float) as libc::c_double,
        (count___0 as libc::c_float / elapsed) as libc::c_double,
        (bytes as libc::c_float / elapsed) as libc::c_double,
        (ttime / elapsed) as libc::c_double,
        code,
        failed,
    );
    fd = open(
        (my.logfile).as_mut_ptr() as *const libc::c_char,
        1025 as libc::c_int,
        420 as libc::c_int,
    );
    if fd < 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"Unable to open file: %s\0" as *const u8 as *const libc::c_char,
            (my.logfile).as_mut_ptr(),
        );
        return;
    }
    tmp___4 = strlen(entry.as_mut_ptr() as *const libc::c_char);
    tmp___5 = write(fd, entry.as_mut_ptr() as *const libc::c_void, tmp___4);
    len = tmp___5 as size_t;
    if len == 4294967295 as libc::c_ulong {
        tmp___6 = __errno_location();
        match *tmp___6 {
            9 => {
                NOTIFY(
                    ERROR,
                    b"Unable to write to log file (bad file descriptor): %s\0"
                        as *const u8 as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
            4 => {
                NOTIFY(
                    ERROR,
                    b"Unable to write to log file (system interrupt): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
            _ => {
                NOTIFY(
                    ERROR,
                    b"Unable to write to log file (unknown error): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
        }
    }
    close(fd);
}
pub unsafe extern "C" fn mark_log_file(mut message: *mut libc::c_char) {
    let mut fd: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut entry: [libc::c_char; 512] = [0; 512];
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: ssize_t = 0;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    tmp___0 = file_exists((my.logfile).as_mut_ptr());
    if tmp___0 as u64 == 0 {
        tmp = create_logfile((my.logfile).as_mut_ptr() as *const libc::c_char);
        if tmp as u64 == 0 {
            NOTIFY(
                ERROR,
                b"unable to create log file: %s\0" as *const u8 as *const libc::c_char,
                (my.logfile).as_mut_ptr(),
            );
            return;
        }
    }
    snprintf(
        entry.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
        b"**** %s ****\n\0" as *const u8 as *const libc::c_char,
        message,
    );
    fd = open(
        (my.logfile).as_mut_ptr() as *const libc::c_char,
        1025 as libc::c_int,
        420 as libc::c_int,
    );
    if fd < 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"Unable to write to file: %s\0" as *const u8 as *const libc::c_char,
            (my.logfile).as_mut_ptr(),
        );
    }
    tmp___1 = strlen(entry.as_mut_ptr() as *const libc::c_char);
    tmp___2 = write(fd, entry.as_mut_ptr() as *const libc::c_void, tmp___1);
    len = tmp___2 as size_t;
    if len == 4294967295 as libc::c_ulong {
        tmp___3 = __errno_location();
        match *tmp___3 {
            9 => {
                NOTIFY(
                    ERROR,
                    b"Unable to mark log file (bad file descriptor): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
            4 => {
                NOTIFY(
                    ERROR,
                    b"Unable to mark log file (system interrupt): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
            _ => {
                NOTIFY(
                    ERROR,
                    b"Unable to mark log file (unknown error): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
        }
    }
    close(fd);
}
pub unsafe extern "C" fn file_exists(mut file: *mut libc::c_char) -> BOOLEAN {
    let mut fd: libc::c_int = 0;
    fd = open(file as *const libc::c_char, 0 as libc::c_int);
    if fd < 0 as libc::c_int {
        close(fd);
        return boolean_false;
    } else {
        close(fd);
        return boolean_true;
    };
}
pub unsafe extern "C" fn create_logfile(mut file: *const libc::c_char) -> BOOLEAN {
    let mut fd: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut ret: BOOLEAN = boolean_false;
    let mut head: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: ssize_t = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    len = 0 as libc::c_int as size_t;
    ret = boolean_true;
    head = b"      Date & Time,  Trans,  Elap Time,  Data Trans,  Resp Time,  Trans Rate,  Throughput,  Concurrent,    OKAY,   Failed\n\0"
        as *const u8 as *const libc::c_char as *mut libc::c_char;
    fd = open(file, 65 as libc::c_int, 420 as libc::c_int);
    if fd < 0 as libc::c_int {
        return boolean_false;
    }
    tmp = strlen(head as *const libc::c_char);
    tmp___0 = write(fd, head as *const libc::c_void, tmp);
    len = tmp___0 as size_t;
    if len == 4294967295 as libc::c_ulong {
        ret = boolean_false;
        tmp___1 = __errno_location();
        match *tmp___1 {
            9 => {
                NOTIFY(
                    ERROR,
                    b"Unable to create log file (bad file descriptor): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
            4 => {
                NOTIFY(
                    ERROR,
                    b"Unable to create log file (system interrupt): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
            _ => {
                NOTIFY(
                    ERROR,
                    b"Unable to create log file (unknown error): %s\0" as *const u8
                        as *const libc::c_char,
                    (my.logfile).as_mut_ptr(),
                );
            }
        }
    }
    close(fd);
    return ret;
}
pub static mut my: CONFIG = CONFIG {
    logging: boolean_false,
    shlog: boolean_false,
    limit: 0,
    url: 0 as *const libc::c_char as *mut libc::c_char,
    logfile: [0; 128],
    verbose: boolean_false,
    quiet: boolean_false,
    parser: boolean_false,
    csv: boolean_false,
    fullurl: boolean_false,
    display: boolean_false,
    config: boolean_false,
    color: boolean_false,
    cusers: 0,
    delay: 0.,
    timeout: 0,
    bench: boolean_false,
    internet: boolean_false,
    timestamp: boolean_false,
    time: 0,
    secs: 0,
    reps: 0,
    file: [0; 128],
    length: 0,
    nomap: 0 as *const LINES as *mut LINES,
    debug: boolean_false,
    chunked: boolean_false,
    unique: boolean_false,
    get: boolean_false,
    print: boolean_false,
    mark: boolean_false,
    markstr: 0 as *const libc::c_char as *mut libc::c_char,
    protocol: 0,
    cookies: 0 as *const COOKIES_T as *mut COOKIES_T,
    uagent: [0; 256],
    encoding: [0; 256],
    conttype: [0; 256],
    bids: 0,
    auth: 0 as *const AUTH_T as *mut AUTH_T,
    keepalive: boolean_false,
    signaled: 0,
    extra: [0; 2048],
    login: boolean_false,
    loginurl: 0 as *const libc::c_char as *mut libc::c_char,
    lurl: 0 as *const ARRAY_T as *mut ARRAY_T,
    failures: 0,
    failed: 0,
    escape: boolean_false,
    expire: boolean_false,
    follow: boolean_false,
    zero_ok: boolean_false,
    spinner: boolean_false,
    cache: boolean_false,
    rc: [0; 256],
    ssl_timeout: 0,
    ssl_cert: 0 as *const libc::c_char as *mut libc::c_char,
    ssl_key: 0 as *const libc::c_char as *mut libc::c_char,
    ssl_ciphers: 0 as *const libc::c_char as *mut libc::c_char,
    method: 0,
    json_output: boolean_false,
    cond: __anonunion_pthread_cond_t_951761805 {
        __data: __pthread_cond_s {
            __annonCompField1: __anonunion____missing_field_name_236290450 {
                __wseq: 0,
            },
            __annonCompField2: __anonunion____missing_field_name_958857992 {
                __g1_start: 0,
            },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
    lock: __anonunion_pthread_mutex_t_335460617 {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list
                    as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list
                    as *mut __pthread_internal_list,
            },
        },
    },
};
static mut long_options: [option; 25] = [
    {
        let mut init = option {
            name: b"version\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'V' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"help\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'h' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"verbose\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'v' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"quiet\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'q' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"config\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'C' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"debug\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'D' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"get\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'g' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"print\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'p' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"concurrent\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'c' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"no-parser\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'N' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"no-follow\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'F' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"internet\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'i' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"benchmark\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'b' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"reps\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'r' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"time\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 't' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"delay\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'd' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"log\0" as *const u8 as *const libc::c_char,
            has_arg: 2 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'l' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"file\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'f' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"rc\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'R' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"mark\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'm' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"header\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'H' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"user-agent\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'A' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"content-type\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'T' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"json-output\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_void as *mut libc::c_void as *mut libc::c_int,
            val: 'j' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: 0 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 0 as libc::c_int,
        };
        init
    },
];
pub unsafe extern "C" fn display_version(mut b: BOOLEAN) {
    let mut name: [libc::c_char; 128] = [0; 128];
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    memset(
        name.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
    );
    tmp = strlen(program_name);
    strncpy(name.as_mut_ptr(), program_name, tmp);
    if my.debug as u64 != 0 {
        tmp___0 = strlen(name.as_mut_ptr() as *const libc::c_char);
        tmp___1 = uppercase(name.as_mut_ptr(), tmp___0);
        fprintf(
            stderr,
            b"%s %s: debugging enabled\n\n%s\n\0" as *const u8 as *const libc::c_char,
            tmp___1,
            version_string,
            copyright,
        );
    } else if b as libc::c_uint == 1 as libc::c_uint {
        tmp___2 = strlen(name.as_mut_ptr() as *const libc::c_char);
        tmp___3 = uppercase(name.as_mut_ptr(), tmp___2);
        fprintf(
            stderr,
            b"%s %s\n\n%s\n\0" as *const u8 as *const libc::c_char,
            tmp___3,
            version_string,
            copyright,
        );
        exit(0 as libc::c_int);
    } else {
        tmp___4 = strlen(name.as_mut_ptr() as *const libc::c_char);
        tmp___5 = uppercase(name.as_mut_ptr(), tmp___4);
        fprintf(
            stderr,
            b"%s %s\n\0" as *const u8 as *const libc::c_char,
            tmp___5,
            version_string,
        );
    };
}
pub unsafe extern "C" fn display_help() {
    display_version(boolean_false);
    printf(b"Usage: %s [options]\n\0" as *const u8 as *const libc::c_char, program_name);
    printf(
        b"       %s [options] URL\n\0" as *const u8 as *const libc::c_char,
        program_name,
    );
    printf(b"       %s -g URL\n\0" as *const u8 as *const libc::c_char, program_name);
    printf(b"Options:\n\0" as *const u8 as *const libc::c_char);
    puts(
        b"  -V, --version             VERSION, prints the version number.\0" as *const u8
            as *const libc::c_char,
    );
    puts(
        b"  -h, --help                HELP, prints this section.\0" as *const u8
            as *const libc::c_char,
    );
    puts(
        b"  -C, --config              CONFIGURATION, show the current config.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -v, --verbose             VERBOSE, prints notification to screen.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -q, --quiet               QUIET turns verbose off and suppresses output.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -g, --get                 GET, pull down HTTP headers and display the\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"                            transaction. Great for application debugging.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -p, --print               PRINT, like GET only it prints the entire page.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -c, --concurrent=NUM      CONCURRENT users, default is 10\0" as *const u8
            as *const libc::c_char,
    );
    puts(
        b"  -r, --reps=NUM            REPS, number of times to run the test.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -t, --time=NUMm           TIMED testing where \"m\" is modifier S, M, or H\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"                            ex: --time=1H, one hour test.\0" as *const u8
            as *const libc::c_char,
    );
    puts(
        b"  -d, --delay=NUM           Time DELAY, random delay before each request\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -b, --benchmark           BENCHMARK: no delays between requests.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -i, --internet            INTERNET user simulation, hits URLs randomly.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -f, --file=FILE           FILE, select a specific URLS FILE.\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"  -R, --rc=FILE             RC, specify an %src file\n\0" as *const u8
            as *const libc::c_char,
        program_name,
    );
    puts(
        b"  -l, --log[=FILE]          LOG to FILE. If FILE is not specified, the\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"                            default is used: PREFIX/var/%s.log\n\0"
            as *const u8 as *const libc::c_char,
        program_name,
    );
    puts(
        b"  -m, --mark=\"text\"         MARK, mark the log file with a string.\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"                            between .001 and NUM. (NOT COUNTED IN STATS)\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -H, --header=\"text\"       Add a header to request (can be many)\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"  -A, --user-agent=\"text\"   Sets User-Agent in request\0" as *const u8
            as *const libc::c_char,
    );
    puts(
        b"  -T, --content-type=\"text\" Sets Content-Type in request\0" as *const u8
            as *const libc::c_char,
    );
    puts(
        b"  -j, --json-output         JSON OUTPUT, print final stats to stdout as JSON\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"      --no-parser           NO PARSER, turn off the HTML page parser\0"
            as *const u8 as *const libc::c_char,
    );
    puts(
        b"      --no-follow           NO FOLLOW, do not follow HTTP redirects\0"
            as *const u8 as *const libc::c_char,
    );
    puts(b"\0" as *const u8 as *const libc::c_char);
    puts(copyright);
    exit(0 as libc::c_int);
}
pub unsafe extern "C" fn parse_rc_cmdline(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) {
    let mut a: libc::c_int = 0;
    a = 0 as libc::c_int;
    strcpy((my.rc).as_mut_ptr(), b"\0" as *const u8 as *const libc::c_char);
    while a > -(1 as libc::c_int) {
        a = getopt_long(
            argc,
            argv as *const *mut libc::c_char,
            b"VhvqCDNFpgl::ibr:t:f:d:c:m:H:R:A:T:j\0" as *const u8
                as *const libc::c_char,
            long_options.as_mut_ptr() as *const option,
            0 as *mut libc::c_int,
        );
        if a == 82 as libc::c_int {
            strcpy((my.rc).as_mut_ptr(), optarg as *const libc::c_char);
            a = -(1 as libc::c_int);
        }
    }
    optind = 0 as libc::c_int;
}
pub unsafe extern "C" fn parse_cmdline(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) {
    let mut c: libc::c_int = 0;
    let mut nargs: libc::c_int = 0;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: size_t = 0;
    c = 0 as libc::c_int;
    loop {
        c = getopt_long(
            argc,
            argv as *const *mut libc::c_char,
            b"VhvqCDNFpgl::ibr:t:f:d:c:m:H:R:A:T:j\0" as *const u8
                as *const libc::c_char,
            long_options.as_mut_ptr() as *const option,
            0 as *mut libc::c_int,
        );
        if !(c != -(1 as libc::c_int)) {
            break;
        }
        match c {
            86 => {
                display_version(boolean_true);
            }
            104 => {
                display_help();
                exit(0 as libc::c_int);
            }
            68 => {
                my.debug = boolean_true;
            }
            67 => {
                my.config = boolean_true;
                my.get = boolean_false;
            }
            99 => {
                my.cusers = atoi(optarg as *const libc::c_char);
            }
            105 => {
                my.internet = boolean_true;
            }
            98 => {
                my.bench = boolean_true;
            }
            100 => {
                tmp = atof(optarg as *const libc::c_char);
                my.delay = tmp as libc::c_float;
                if my.delay < 0 as libc::c_int as libc::c_float {
                    my.delay = 0 as libc::c_int as libc::c_float;
                }
            }
            103 => {
                my.get = boolean_true;
            }
            112 => {
                my.print = boolean_true;
                my.cusers = 1 as libc::c_int;
                my.reps = 1 as libc::c_int;
            }
            108 => {
                my.logging = boolean_true;
                if !optarg.is_null() {
                    tmp___0 = strlen(optarg as *const libc::c_char);
                    my.logfile[tmp___0 as usize] = '\u{0}' as i32 as libc::c_char;
                    tmp___1 = strlen(optarg as *const libc::c_char);
                    strncpy(
                        (my.logfile).as_mut_ptr(),
                        optarg as *const libc::c_char,
                        tmp___1,
                    );
                }
            }
            109 => {
                my.mark = boolean_true;
                my.markstr = optarg;
                my.logging = boolean_true;
            }
            113 => {
                my.quiet = boolean_true;
            }
            118 => {
                my.verbose = boolean_true;
            }
            114 => {
                tmp___2 = strmatch(
                    optarg,
                    b"once\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if tmp___2 as u64 != 0 {
                    my.reps = -(1 as libc::c_int);
                } else {
                    my.reps = atoi(optarg as *const libc::c_char);
                }
            }
            116 => {
                parse_time(optarg);
            }
            102 => {
                memset(
                    (my.file).as_mut_ptr() as *mut libc::c_void,
                    0 as libc::c_int,
                    ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                );
                if !(optarg as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong)
                {
                    tmp___3 = strlen(optarg as *const libc::c_char);
                    strncpy(
                        (my.file).as_mut_ptr(),
                        optarg as *const libc::c_char,
                        tmp___3,
                    );
                }
            }
            65 => {
                strncpy(
                    (my.uagent).as_mut_ptr(),
                    optarg as *const libc::c_char,
                    255 as libc::c_int as size_t,
                );
            }
            84 => {
                strncpy(
                    (my.conttype).as_mut_ptr(),
                    optarg as *const libc::c_char,
                    255 as libc::c_int as size_t,
                );
            }
            78 => {
                my.parser = boolean_false;
            }
            70 => {
                my.follow = boolean_false;
            }
            72 => {
                tmp___4 = strchr(optarg as *const libc::c_char, ':' as i32);
                if tmp___4.is_null() {
                    NOTIFY(
                        FATAL,
                        b"no ':' in http-header\0" as *const u8 as *const libc::c_char,
                    );
                }
                tmp___5 = strlen(optarg as *const libc::c_char);
                tmp___6 = strlen((my.extra).as_mut_ptr() as *const libc::c_char);
                if tmp___5.wrapping_add(tmp___6).wrapping_add(3 as libc::c_ulong)
                    > 2048 as libc::c_ulong
                {
                    NOTIFY(
                        FATAL,
                        b"header is too large\0" as *const u8 as *const libc::c_char,
                    );
                }
                strcat((my.extra).as_mut_ptr(), optarg as *const libc::c_char);
                strcat(
                    (my.extra).as_mut_ptr(),
                    b"\r\n\0" as *const u8 as *const libc::c_char,
                );
            }
            106 => {
                my.json_output = boolean_true;
            }
            82 | _ => {}
        }
    }
    nargs = argc - optind;
    if nargs != 0 {
        my
            .url = xstrdup(
            *argv.offset((argc - 1 as libc::c_int) as isize) as *const libc::c_char,
        );
    }
    if my.get as u64 != 0 {
        if my.url as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            puts(
                b"ERROR: -g/--get requires a commandline URL\0" as *const u8
                    as *const libc::c_char,
            );
            exit(1 as libc::c_int);
        }
    }
}
unsafe extern "C" fn __signal_setup() {
    let mut sigs: sigset_t = sigset_t { __val: [0; 16] };
    sigemptyset(&mut sigs);
    sigaddset(&mut sigs, 1 as libc::c_int);
    sigaddset(&mut sigs, 2 as libc::c_int);
    sigaddset(&mut sigs, 14 as libc::c_int);
    sigaddset(&mut sigs, 15 as libc::c_int);
    sigaddset(&mut sigs, 13 as libc::c_int);
    sigprocmask(
        0 as libc::c_int,
        &mut sigs as *mut sigset_t as *const sigset_t,
        0 as *mut libc::c_void as *mut sigset_t,
    );
}
unsafe extern "C" fn __config_setup(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    memset(
        &mut my as *mut CONFIG as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<CONFIG>() as libc::c_ulong,
    );
    parse_rc_cmdline(argc, argv);
    tmp = init_config();
    if tmp < 0 as libc::c_int {
        exit(1 as libc::c_int);
    }
    parse_cmdline(argc, argv);
    ds_module_check();
    if my.config as u64 != 0 {
        show_config(1 as libc::c_int);
    }
    if my.cusers > my.limit {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        printf(
            b"================================================================\n\0"
                as *const u8 as *const libc::c_char,
        );
        if my.limit > 999 as libc::c_int {
            tmp___0 = b" \0" as *const u8 as *const libc::c_char;
        } else {
            tmp___0 = b"  \0" as *const u8 as *const libc::c_char;
        }
        printf(
            b"WARNING: The number of users is capped at %d.%sTo increase this\n\0"
                as *const u8 as *const libc::c_char,
            my.limit,
            tmp___0,
        );
        printf(
            b"         limit, search your .siegerc file for 'limit' and change\n\0"
                as *const u8 as *const libc::c_char,
        );
        printf(
            b"         its value. Make sure you read the instructions there...\n\0"
                as *const u8 as *const libc::c_char,
        );
        printf(
            b"================================================================\n\0"
                as *const u8 as *const libc::c_char,
        );
        sleep(10 as libc::c_uint);
        my.cusers = my.limit;
    }
}
unsafe extern "C" fn __urls_setup() -> *mut LINES {
    let mut lines: *mut LINES = 0 as *mut LINES;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = xcalloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<LINES>() as libc::c_ulong,
    );
    lines = tmp as *mut LINES;
    (*lines).index = 0 as libc::c_int;
    (*lines).line = 0 as *mut libc::c_void as *mut *mut libc::c_char;
    if my.url as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        my.length = 1 as libc::c_int;
    } else {
        my.length = read_cfg_file(lines, (my.file).as_mut_ptr());
    }
    if my.length == 0 as libc::c_int {
        display_help();
    }
    return lines;
}
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut result: libc::c_int = 0;
    let mut status: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut lines: *mut LINES = 0 as *mut LINES;
    let mut crew: CREW = 0 as *mut CREW_T;
    let mut data: DATA = 0 as *mut DATA_T;
    let mut cookies: HASH = 0 as *mut HASH_T;
    let mut urls: ARRAY = 0 as *mut ARRAY_T;
    let mut tmp: ARRAY = 0 as *mut ARRAY_T;
    let mut browsers: ARRAY = 0 as *mut ARRAY_T;
    let mut tmp___0: ARRAY = 0 as *mut ARRAY_T;
    let mut cease: pthread_t = 0;
    let mut timer: pthread_t = 0;
    let mut scope_attr: pthread_attr_t = pthread_attr_t { __size: [0; 56] };
    let mut tmp___1: URL = 0 as *mut URL_T;
    let mut tmp___2: URL = 0 as *mut URL_T;
    let mut tmp___3: METHOD = 0;
    let mut tmp___4: METHOD = 0;
    let mut tmp___5: URL = 0 as *mut URL_T;
    let mut tmp___6: URL = 0 as *mut URL_T;
    let mut tmp___7: [libc::c_char; 4096] = [0; 4096];
    let mut B: BROWSER = 0 as *mut BROWSER_T;
    let mut tmp___8: BROWSER = 0 as *mut BROWSER_T;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut n_urls: libc::c_int = 0;
    let mut tmp___11: size_t = 0;
    let mut per_user: libc::c_int = 0;
    let mut remainder: libc::c_int = 0;
    let mut begin_url: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut end_url: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut url_slice: ARRAY = 0 as *mut ARRAY_T;
    let mut tmp___14: ARRAY = 0 as *mut ARRAY_T;
    let mut u: URL = 0 as *mut URL_T;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___18: size_t = 0;
    let mut B___0: BROWSER = 0 as *mut BROWSER_T;
    let mut tmp___19: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___20: BOOLEAN = boolean_false;
    let mut tmp___21: BOOLEAN = boolean_false;
    let mut B___1: BROWSER = 0 as *mut BROWSER_T;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___23: libc::c_ulong = 0;
    let mut tmp___24: libc::c_ulonglong = 0;
    let mut tmp___25: libc::c_float = 0.;
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: libc::c_uint = 0;
    let mut tmp___28: libc::c_uint = 0;
    let mut tmp___29: libc::c_float = 0.;
    let mut tmp___30: libc::c_float = 0.;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: libc::c_uint = 0;
    let mut tmp___39: libc::c_uint = 0;
    let mut tmp___40: libc::c_uint = 0;
    let mut tmp___41: libc::c_double = 0.;
    let mut tmp___42: libc::c_uint = 0;
    let mut tmp___43: libc::c_float = 0.;
    let mut tmp___44: libc::c_float = 0.;
    let mut tmp___45: libc::c_float = 0.;
    let mut tmp___46: libc::c_float = 0.;
    let mut tmp___47: libc::c_float = 0.;
    let mut tmp___48: libc::c_float = 0.;
    let mut tmp___49: libc::c_uint = 0;
    let mut tmp___50: libc::c_uint = 0;
    let mut tmp___51: libc::c_float = 0.;
    let mut tmp___52: libc::c_float = 0.;
    let mut tmp___53: libc::c_uint = 0;
    let mut availability: libc::c_double = 0.;
    let mut tmp___54: libc::c_uint = 0;
    let mut tmp___55: libc::c_uint = 0;
    let mut tmp___56: libc::c_uint = 0;
    let mut tmp___57: libc::c_float = 0.;
    let mut tmp___58: libc::c_float = 0.;
    let mut tmp___59: libc::c_float = 0.;
    let mut tmp___60: libc::c_float = 0.;
    let mut tmp___61: libc::c_float = 0.;
    let mut tmp___62: libc::c_float = 0.;
    let mut tmp___63: libc::c_uint = 0;
    let mut tmp___64: libc::c_uint = 0;
    let mut tmp___65: libc::c_float = 0.;
    let mut tmp___66: libc::c_float = 0.;
    result = 0 as libc::c_int;
    status = 0 as *mut libc::c_void;
    lines = 0 as *mut libc::c_void as *mut LINES;
    crew = 0 as *mut libc::c_void as CREW;
    data = 0 as *mut libc::c_void as DATA;
    cookies = 0 as *mut libc::c_void as HASH;
    tmp = new_array();
    urls = tmp;
    tmp___0 = new_array();
    browsers = tmp___0;
    __signal_setup();
    __config_setup(argc, argv);
    lines = __urls_setup();
    pthread_attr_init(&mut scope_attr);
    pthread_attr_setscope(&mut scope_attr, 0 as libc::c_int);
    SSL_thread_setup();
    if my.url as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = new_url(my.url);
        tmp___1 = tmp___2;
        url_set_ID(tmp___1, 0 as libc::c_int);
        if my.get as u64 != 0 {
            tmp___3 = url_get_method(tmp___1);
            if tmp___3 as libc::c_uint != 3 as libc::c_uint {
                tmp___4 = url_get_method(tmp___1);
                if tmp___4 as libc::c_uint != 4 as libc::c_uint {
                    url_set_method(tmp___1, my.method);
                }
            }
        }
        array_npush(urls, tmp___1 as *mut libc::c_void, URLSIZE);
    } else {
        i = 0 as libc::c_int;
        while i < my.length {
            tmp___6 = new_url(*((*lines).line).offset(i as isize));
            tmp___5 = tmp___6;
            url_set_ID(tmp___5, i);
            array_npush(urls, tmp___5 as *mut libc::c_void, URLSIZE);
            i += 1;
        }
    }
    cookies = load_cookies(my.cookies);
    i = 0 as libc::c_int;
    while i < my.cusers {
        tmp___8 = new_browser(i);
        B = tmp___8;
        memset(
            tmp___7.as_mut_ptr() as *mut libc::c_void,
            '\u{0}' as i32,
            ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
        );
        snprintf(
            tmp___7.as_mut_ptr(),
            4096 as libc::c_int as size_t,
            b"%d\0" as *const u8 as *const libc::c_char,
            i,
        );
        if cookies as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___10 = hash_get(cookies, tmp___7.as_mut_ptr());
            if tmp___10 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___9 = hash_get(cookies, tmp___7.as_mut_ptr());
                browser_set_cookies(B, tmp___9 as HASH);
            }
        }
        if my.reps > 0 as libc::c_int {
            browser_set_urls(B, urls);
        } else {
            tmp___11 = array_length(urls);
            n_urls = tmp___11 as libc::c_int;
            per_user = n_urls / my.cusers;
            remainder = n_urls % my.cusers;
            if i < remainder {
                tmp___12 = i;
            } else {
                tmp___12 = remainder;
            }
            begin_url = i * per_user + tmp___12;
            if i < remainder {
                tmp___13 = i + 1 as libc::c_int;
            } else {
                tmp___13 = remainder;
            }
            end_url = (i + 1 as libc::c_int) * per_user + tmp___13;
            tmp___14 = new_array();
            url_slice = tmp___14;
            j = begin_url;
            while j < end_url {
                if !(j < n_urls) {
                    break;
                }
                tmp___15 = array_get(urls, j);
                u = tmp___15 as URL;
                if u as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___16 = url_get_hostname(u);
                    if tmp___16 as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        tmp___17 = url_get_hostname(u);
                        tmp___18 = strlen(tmp___17 as *const libc::c_char);
                        if tmp___18 > 1 as libc::c_ulong {
                            array_npush(url_slice, u as *mut libc::c_void, URLSIZE);
                        }
                    }
                }
                j += 1;
            }
            browser_set_urls(B, url_slice);
        }
        array_npush(browsers, B as *mut libc::c_void, BROWSERSIZE);
        i += 1;
    }
    crew = new_crew(my.cusers, my.cusers, boolean_false);
    if crew as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            FATAL,
            b"unable to allocate memory for %d simulated browser\0" as *const u8
                as *const libc::c_char,
            my.cusers,
        );
    }
    result = pthread_create(
        &mut cease as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
        >(
            ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(CREW) -> ()>,
                *mut libc::c_void,
            >(Some(sig_handler as unsafe extern "C" fn(CREW) -> ())),
        ),
        crew as *mut libc::c_void,
    );
    if result < 0 as libc::c_int {
        NOTIFY(
            FATAL,
            b"failed to create handler: %d\n\0" as *const u8 as *const libc::c_char,
            result,
        );
    }
    if my.secs > 0 as libc::c_int {
        result = pthread_create(
            &mut timer as *mut pthread_t,
            0 as *mut libc::c_void as *const pthread_attr_t,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
            >(
                ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(pthread_t) -> ()>,
                    *mut libc::c_void,
                >(Some(siege_timer as unsafe extern "C" fn(pthread_t) -> ())),
            ),
            cease as *mut libc::c_void,
        );
        if result < 0 as libc::c_int {
            NOTIFY(
                FATAL,
                b"failed to create handler: %d\n\0" as *const u8 as *const libc::c_char,
                result,
            );
        }
    }
    if my.get as u64 == 0 {
        if my.quiet as u64 == 0 {
            fprintf(stderr, b"** \0" as *const u8 as *const libc::c_char);
            display_version(boolean_false);
            fprintf(
                stderr,
                b"** Preparing %d concurrent users for battle.\n\0" as *const u8
                    as *const libc::c_char,
                my.cusers,
            );
            fprintf(
                stderr,
                b"The server is now under siege...\0" as *const u8 as *const libc::c_char,
            );
            if my.verbose as u64 != 0 {
                fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
            }
        }
    }
    data = new_data();
    data_set_start(data);
    i = 0 as libc::c_int;
    while i < my.cusers {
        tmp___21 = crew_get_shutdown(crew);
        if !(tmp___21 as libc::c_uint != 1 as libc::c_uint) {
            break;
        }
        tmp___19 = array_get(browsers, i);
        B___0 = tmp___19 as BROWSER;
        tmp___20 = crew_add(
            crew,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> ()>,
            >(
                ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(BROWSER) -> *mut libc::c_void>,
                    *mut libc::c_void,
                >(Some(start as unsafe extern "C" fn(BROWSER) -> *mut libc::c_void)),
            ),
            B___0 as *mut libc::c_void,
        );
        result = tmp___20 as libc::c_int;
        if result == 0 as libc::c_int {
            my.verbose = boolean_false;
            fprintf(
                stderr,
                b"Unable to spawn additional threads; you may need to\n\0" as *const u8
                    as *const libc::c_char,
            );
            fprintf(
                stderr,
                b"upgrade your libraries or tune your system in order\n\0" as *const u8
                    as *const libc::c_char,
            );
            fprintf(
                stderr,
                b"to exceed %d users.\n\0" as *const u8 as *const libc::c_char,
                my.cusers,
            );
            NOTIFY(
                FATAL,
                b"system resources exhausted\0" as *const u8 as *const libc::c_char,
            );
        }
        i += 1;
    }
    crew_join(crew, boolean_true, &mut status);
    data_set_stop(data);
    SSL_thread_cleanup();
    i = 0 as libc::c_int;
    loop {
        tmp___35 = crew_get_total(crew);
        if tmp___35 > my.cusers {
            tmp___34 = my.cusers;
        } else {
            tmp___36 = crew_get_total(crew);
            if tmp___36 == 0 as libc::c_int {
                tmp___34 = my.cusers;
            } else {
                tmp___33 = crew_get_total(crew);
                tmp___34 = tmp___33;
            }
        }
        if !(i < tmp___34) {
            break;
        }
        tmp___22 = array_get(browsers, i);
        B___1 = tmp___22 as BROWSER;
        tmp___23 = browser_get_hits(B___1);
        data_increment_count(data, tmp___23);
        tmp___24 = browser_get_bytes(B___1);
        data_increment_bytes(data, tmp___24 as libc::c_ulong);
        tmp___25 = browser_get_time(B___1);
        data_increment_total(data, tmp___25);
        tmp___26 = browser_get_code(B___1);
        data_increment_code(data, tmp___26 as libc::c_int);
        tmp___27 = browser_get_okay(B___1);
        data_increment_okay(data, tmp___27 as libc::c_int);
        tmp___28 = browser_get_fail(B___1);
        data_increment_fail(data, tmp___28 as libc::c_int);
        tmp___29 = browser_get_himark(B___1);
        data_set_highest(data, tmp___29);
        tmp___30 = browser_get_lomark(B___1);
        data_set_lowest(data, tmp___30);
        i += 1;
    }
    crew_destroy(crew);
    pthread_usleep_np(10000 as libc::c_ulong);
    if my.quiet as u64 == 0 {
        if my.failures > 0 as libc::c_int {
            if my.failed >= my.failures {
                fprintf(
                    stderr,
                    b"%s aborted due to excessive socket failure; you\n\0" as *const u8
                        as *const libc::c_char,
                    program_name,
                );
                fprintf(
                    stderr,
                    b"can change the failure threshold in $HOME/.%src\n\0" as *const u8
                        as *const libc::c_char,
                    program_name,
                );
            }
        }
        tmp___37 = data_get_count(data);
        fprintf(
            stderr,
            b"\nTransactions:\t\t%12u hits\n\0" as *const u8 as *const libc::c_char,
            tmp___37,
        );
        tmp___42 = data_get_count(data);
        if tmp___42 == 0 as libc::c_uint {
            tmp___41 = 0 as libc::c_int as libc::c_double;
        } else {
            tmp___39 = data_get_count(data);
            tmp___40 = data_get_count(data);
            tmp___41 = tmp___39 as libc::c_double
                / tmp___40.wrapping_add(my.failed as libc::c_uint) as libc::c_double
                * 100 as libc::c_int as libc::c_double;
        }
        fprintf(
            stderr,
            b"Availability:\t\t%12.2f %%\n\0" as *const u8 as *const libc::c_char,
            tmp___41,
        );
        tmp___43 = data_get_elapsed(data);
        fprintf(
            stderr,
            b"Elapsed time:\t\t%12.2f secs\n\0" as *const u8 as *const libc::c_char,
            tmp___43 as libc::c_double,
        );
        tmp___44 = data_get_megabytes(data);
        fprintf(
            stderr,
            b"Data transferred:\t%12.2f MB\n\0" as *const u8 as *const libc::c_char,
            tmp___44 as libc::c_double,
        );
        tmp___45 = data_get_response_time(data);
        fprintf(
            stderr,
            b"Response time:\t\t%12.2f secs\n\0" as *const u8 as *const libc::c_char,
            tmp___45 as libc::c_double,
        );
        tmp___46 = data_get_transaction_rate(data);
        fprintf(
            stderr,
            b"Transaction rate:\t%12.2f trans/sec\n\0" as *const u8
                as *const libc::c_char,
            tmp___46 as libc::c_double,
        );
        tmp___47 = data_get_throughput(data);
        fprintf(
            stderr,
            b"Throughput:\t\t%12.2f MB/sec\n\0" as *const u8 as *const libc::c_char,
            tmp___47 as libc::c_double,
        );
        tmp___48 = data_get_concurrency(data);
        fprintf(
            stderr,
            b"Concurrency:\t\t%12.2f\n\0" as *const u8 as *const libc::c_char,
            tmp___48 as libc::c_double,
        );
        tmp___49 = data_get_code(data);
        fprintf(
            stderr,
            b"Successful transactions:%12u\n\0" as *const u8 as *const libc::c_char,
            tmp___49,
        );
        if my.debug as u64 != 0 {
            tmp___50 = data_get_okay(data);
            fprintf(
                stderr,
                b"HTTP OK received:\t%12u\n\0" as *const u8 as *const libc::c_char,
                tmp___50,
            );
        }
        fprintf(
            stderr,
            b"Failed transactions:\t%12u\n\0" as *const u8 as *const libc::c_char,
            my.failed,
        );
        tmp___51 = data_get_highest(data);
        fprintf(
            stderr,
            b"Longest transaction:\t%12.2f\n\0" as *const u8 as *const libc::c_char,
            tmp___51 as libc::c_double,
        );
        tmp___52 = data_get_lowest(data);
        fprintf(
            stderr,
            b"Shortest transaction:\t%12.2f\n\0" as *const u8 as *const libc::c_char,
            tmp___52 as libc::c_double,
        );
        fprintf(stderr, b" \n\0" as *const u8 as *const libc::c_char);
    }
    if my.json_output as u64 != 0 {
        fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
        printf(b"{\n\0" as *const u8 as *const libc::c_char);
        tmp___53 = data_get_count(data);
        printf(
            b"\t\"transactions\":\t\t\t%12u,\n\0" as *const u8 as *const libc::c_char,
            tmp___53,
        );
        tmp___56 = data_get_count(data);
        if tmp___56 == 0 as libc::c_uint {
            availability = 0 as libc::c_int as libc::c_double;
        } else {
            tmp___54 = data_get_count(data);
            tmp___55 = data_get_count(data);
            availability = tmp___54 as libc::c_double
                / tmp___55.wrapping_add(my.failed as libc::c_uint) as libc::c_double
                * 100 as libc::c_int as libc::c_double;
        }
        printf(
            b"\t\"availability\":\t\t\t%12.2f,\n\0" as *const u8 as *const libc::c_char,
            availability,
        );
        tmp___57 = data_get_elapsed(data);
        printf(
            b"\t\"elapsed_time\":\t\t\t%12.2f,\n\0" as *const u8 as *const libc::c_char,
            tmp___57 as libc::c_double,
        );
        tmp___58 = data_get_megabytes(data);
        printf(
            b"\t\"data_transferred\":\t\t%12.2f,\n\0" as *const u8
                as *const libc::c_char,
            tmp___58 as libc::c_double,
        );
        tmp___59 = data_get_response_time(data);
        printf(
            b"\t\"response_time\":\t\t%12.2f,\n\0" as *const u8 as *const libc::c_char,
            tmp___59 as libc::c_double,
        );
        tmp___60 = data_get_transaction_rate(data);
        printf(
            b"\t\"transaction_rate\":\t\t%12.2f,\n\0" as *const u8
                as *const libc::c_char,
            tmp___60 as libc::c_double,
        );
        tmp___61 = data_get_throughput(data);
        printf(
            b"\t\"throughput\":\t\t\t%12.2f,\n\0" as *const u8 as *const libc::c_char,
            tmp___61 as libc::c_double,
        );
        tmp___62 = data_get_concurrency(data);
        printf(
            b"\t\"concurrency\":\t\t\t%12.2f,\n\0" as *const u8 as *const libc::c_char,
            tmp___62 as libc::c_double,
        );
        tmp___63 = data_get_code(data);
        printf(
            b"\t\"successful_transactions\":\t%12u,\n\0" as *const u8
                as *const libc::c_char,
            tmp___63,
        );
        if my.debug as u64 != 0 {
            tmp___64 = data_get_okay(data);
            printf(
                b"\t\"http_ok_received\":\t\t%12u,\n\0" as *const u8
                    as *const libc::c_char,
                tmp___64,
            );
        }
        printf(
            b"\t\"failed_transactions\":\t\t%12u,\n\0" as *const u8
                as *const libc::c_char,
            my.failed,
        );
        tmp___65 = data_get_highest(data);
        printf(
            b"\t\"longest_transaction\":\t\t%12.2f,\n\0" as *const u8
                as *const libc::c_char,
            tmp___65 as libc::c_double,
        );
        tmp___66 = data_get_lowest(data);
        printf(
            b"\t\"shortest_transaction\":\t\t%12.2f\n\0" as *const u8
                as *const libc::c_char,
            tmp___66 as libc::c_double,
        );
        puts(b"}\0" as *const u8 as *const libc::c_char);
    }
    if my.mark as u64 != 0 {
        mark_log_file(my.markstr);
    }
    if my.logging as u64 != 0 {
        log_transaction(data);
        if my.failures > 0 as libc::c_int {
            if my.failed >= my.failures {
                mark_log_file(
                    b"siege aborted due to excessive socket failure.\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                );
            }
        }
    }
    data = data_destroy(data);
    urls = array_destroyer(
        urls,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(
            ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(URL) -> URL>,
                *mut libc::c_void,
            >(Some(url_destroy as unsafe extern "C" fn(URL) -> URL)),
        ),
    );
    browsers = array_destroyer(
        browsers,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(
            ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(BROWSER) -> BROWSER>,
                *mut libc::c_void,
            >(Some(browser_destroy as unsafe extern "C" fn(BROWSER) -> BROWSER)),
        ),
    );
    cookies = hash_destroy(cookies);
    my.cookies = cookies_destroy(my.cookies);
    if my.url as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        i = 0 as libc::c_int;
        while i < my.length {
            xfree(*((*lines).line).offset(i as isize) as *mut libc::c_void);
            i += 1;
        }
        xfree((*lines).line as *mut libc::c_void);
        xfree(lines as *mut libc::c_void);
    } else {
        xfree((*lines).line as *mut libc::c_void);
        xfree(lines as *mut libc::c_void);
    }
    exit(0 as libc::c_int);
}
static mut fillbuf: [libc::c_uchar; 64] = [
    128 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
];
pub unsafe extern "C" fn md5_init_ctx(mut ctx: *mut md5_ctx) {
    let mut tmp: md5_uint32 = 0;
    (*ctx).A = 1732584193 as libc::c_int as md5_uint32;
    (*ctx).B = 4023233417 as libc::c_uint;
    (*ctx).C = 2562383102 as libc::c_uint;
    (*ctx).D = 271733878 as libc::c_int as md5_uint32;
    tmp = 0 as libc::c_int as md5_uint32;
    (*ctx).total[1 as libc::c_int as usize] = tmp;
    (*ctx).total[0 as libc::c_int as usize] = tmp;
    (*ctx).buflen = 0 as libc::c_int as md5_uint32;
}
pub unsafe extern "C" fn md5_read_ctx(
    mut ctx: *const md5_ctx,
    mut resbuf: *mut libc::c_void,
) -> *mut libc::c_void {
    let mut buffer: [md5_uint32; 4] = [0; 4];
    buffer[0 as libc::c_int as usize] = (*ctx).A;
    buffer[1 as libc::c_int as usize] = (*ctx).B;
    buffer[2 as libc::c_int as usize] = (*ctx).C;
    buffer[3 as libc::c_int as usize] = (*ctx).D;
    memcpy(
        resbuf,
        buffer.as_mut_ptr() as *const libc::c_void,
        16 as libc::c_int as size_t,
    );
    return resbuf;
}
pub unsafe extern "C" fn md5_finish_ctx(
    mut ctx: *mut md5_ctx,
    mut resbuf: *mut libc::c_void,
) -> *mut libc::c_void {
    let mut bytes: md5_uint32 = 0;
    let mut swap_bytes: md5_uint32 = 0;
    let mut pad: size_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    bytes = (*ctx).buflen;
    (*ctx)
        .total[0 as libc::c_int
        as usize] = ((*ctx).total[0 as libc::c_int as usize] as libc::c_uint)
        .wrapping_add(bytes) as md5_uint32 as md5_uint32;
    if (*ctx).total[0 as libc::c_int as usize] < bytes {
        (*ctx)
            .total[1 as libc::c_int
            as usize] = ((*ctx).total[1 as libc::c_int as usize]).wrapping_add(1);
    }
    if bytes >= 56 as libc::c_uint {
        pad = (120 as libc::c_uint).wrapping_sub(bytes) as size_t;
    } else {
        pad = (56 as libc::c_uint).wrapping_sub(bytes) as size_t;
    }
    memcpy(
        &mut *((*ctx).buffer).as_mut_ptr().offset(bytes as isize) as *mut libc::c_char
            as *mut libc::c_void,
        fillbuf.as_ptr() as *const libc::c_void,
        pad,
    );
    swap_bytes = (*ctx).total[0 as libc::c_int as usize] << 3 as libc::c_int;
    memcpy(
        &mut *((*ctx).buffer)
            .as_mut_ptr()
            .offset((bytes as size_t).wrapping_add(pad) as isize) as *mut libc::c_char
            as *mut libc::c_void,
        &mut swap_bytes as *mut md5_uint32 as *const libc::c_void,
        ::std::mem::size_of::<md5_uint32>() as libc::c_ulong,
    );
    swap_bytes = (*ctx).total[1 as libc::c_int as usize] << 3 as libc::c_int
        | (*ctx).total[0 as libc::c_int as usize] >> 29 as libc::c_int;
    memcpy(
        &mut *((*ctx).buffer)
            .as_mut_ptr()
            .offset(
                (bytes as size_t).wrapping_add(pad).wrapping_add(4 as libc::c_ulong)
                    as isize,
            ) as *mut libc::c_char as *mut libc::c_void,
        &mut swap_bytes as *mut md5_uint32 as *const libc::c_void,
        ::std::mem::size_of::<md5_uint32>() as libc::c_ulong,
    );
    md5_process_block(
        ((*ctx).buffer).as_mut_ptr() as *const libc::c_void,
        (bytes as size_t).wrapping_add(pad).wrapping_add(8 as libc::c_ulong),
        ctx,
    );
    tmp = md5_read_ctx(ctx as *const md5_ctx, resbuf);
    return tmp;
}
pub unsafe extern "C" fn md5_stream(
    mut stream: *mut FILE,
    mut resblock: *mut libc::c_void,
) -> libc::c_int {
    let mut ctx: md5_ctx = md5_ctx {
        A: 0,
        B: 0,
        C: 0,
        D: 0,
        total: [0; 2],
        buflen: 0,
        buffer: [0; 128],
    };
    let mut buffer: [libc::c_char; 4168] = [0; 4168];
    let mut sum: size_t = 0;
    let mut n: size_t = 0;
    let mut tmp: libc::c_int = 0;
    md5_init_ctx(&mut ctx);
    loop {
        sum = 0 as libc::c_int as size_t;
        loop {
            n = fread(
                buffer.as_mut_ptr().offset(sum as isize) as *mut libc::c_void,
                1 as libc::c_int as size_t,
                (4096 as libc::c_ulong).wrapping_sub(sum),
                stream,
            );
            sum = (sum as libc::c_ulong).wrapping_add(n) as size_t as size_t;
            if !(sum < 4096 as libc::c_ulong) {
                break;
            }
            if !(n != 0 as libc::c_ulong) {
                break;
            }
        }
        if n == 0 as libc::c_ulong {
            tmp = ferror(stream);
            if tmp != 0 {
                return 1 as libc::c_int;
            }
        }
        if n == 0 as libc::c_ulong {
            break;
        }
        md5_process_block(
            buffer.as_mut_ptr() as *const libc::c_void,
            4096 as libc::c_int as size_t,
            &mut ctx,
        );
    }
    if sum > 0 as libc::c_ulong {
        md5_process_bytes(buffer.as_mut_ptr() as *const libc::c_void, sum, &mut ctx);
    }
    md5_finish_ctx(&mut ctx, resblock);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn md5_buffer(
    mut buffer: *const libc::c_char,
    mut len: size_t,
    mut resblock: *mut libc::c_void,
) -> *mut libc::c_void {
    let mut ctx: md5_ctx = md5_ctx {
        A: 0,
        B: 0,
        C: 0,
        D: 0,
        total: [0; 2],
        buflen: 0,
        buffer: [0; 128],
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    md5_init_ctx(&mut ctx);
    md5_process_bytes(buffer as *const libc::c_void, len, &mut ctx);
    tmp = md5_finish_ctx(&mut ctx, resblock);
    return tmp;
}
pub unsafe extern "C" fn md5_process_bytes(
    mut buffer: *const libc::c_void,
    mut len: size_t,
    mut ctx: *mut md5_ctx,
) {
    let mut left_over: size_t = 0;
    let mut add: size_t = 0;
    let mut tmp: size_t = 0;
    if (*ctx).buflen != 0 as libc::c_uint {
        left_over = (*ctx).buflen as size_t;
        if (128 as libc::c_ulong).wrapping_sub(left_over) > len {
            tmp = len;
        } else {
            tmp = (128 as libc::c_ulong).wrapping_sub(left_over);
        }
        add = tmp;
        memcpy(
            &mut *((*ctx).buffer).as_mut_ptr().offset(left_over as isize)
                as *mut libc::c_char as *mut libc::c_void,
            buffer,
            add,
        );
        (*ctx).buflen = ((*ctx).buflen as size_t).wrapping_add(add) as md5_uint32;
        if left_over.wrapping_add(add) > 64 as libc::c_ulong {
            md5_process_block(
                ((*ctx).buffer).as_mut_ptr() as *const libc::c_void,
                left_over.wrapping_add(add) & 0xffffffffffffffc0 as libc::c_ulong,
                ctx,
            );
            memcpy(
                ((*ctx).buffer).as_mut_ptr() as *mut libc::c_void,
                &mut *((*ctx).buffer)
                    .as_mut_ptr()
                    .offset(
                        (left_over.wrapping_add(add)
                            & 0xffffffffffffffc0 as libc::c_ulong) as isize,
                    ) as *mut libc::c_char as *const libc::c_void,
                left_over.wrapping_add(add) & 63 as libc::c_ulong,
            );
            (*ctx)
                .buflen = (left_over.wrapping_add(add) & 63 as libc::c_ulong)
                as md5_uint32;
        }
        buffer = (buffer as *const libc::c_char).offset(add as isize)
            as *const libc::c_void;
        len = (len as libc::c_ulong).wrapping_sub(add) as size_t as size_t;
    }
    if len > 64 as libc::c_ulong {
        if (buffer as md5_uintptr)
            .wrapping_rem(::std::mem::align_of::<md5_uint32>() as libc::c_ulong)
            != 0 as libc::c_ulong
        {
            while len > 64 as libc::c_ulong {
                memcpy(
                    ((*ctx).buffer).as_mut_ptr() as *mut libc::c_void,
                    buffer,
                    64 as libc::c_int as size_t,
                );
                md5_process_block(
                    ((*ctx).buffer).as_mut_ptr() as *const libc::c_void,
                    64 as libc::c_int as size_t,
                    ctx,
                );
                buffer = (buffer as *const libc::c_char)
                    .offset(64 as libc::c_int as isize) as *const libc::c_void;
                len = (len as libc::c_ulong).wrapping_sub(64 as libc::c_ulong) as size_t
                    as size_t;
            }
        } else {
            md5_process_block(buffer, len & 0xffffffffffffffc0 as libc::c_ulong, ctx);
            buffer = (buffer as *const libc::c_char)
                .offset((len & 0xffffffffffffffc0 as libc::c_ulong) as isize)
                as *const libc::c_void;
            len &= 63 as libc::c_ulong;
        }
    }
    if len > 0 as libc::c_ulong {
        memcpy(((*ctx).buffer).as_mut_ptr() as *mut libc::c_void, buffer, len);
        (*ctx).buflen = len as md5_uint32;
    }
}
pub unsafe extern "C" fn md5_process_block(
    mut buffer: *const libc::c_void,
    mut len: size_t,
    mut ctx: *mut md5_ctx,
) {
    let mut correct_words: [md5_uint32; 16] = [0; 16];
    let mut words: *const md5_uint32 = 0 as *const md5_uint32;
    let mut nwords: size_t = 0;
    let mut endp: *const md5_uint32 = 0 as *const md5_uint32;
    let mut A: md5_uint32 = 0;
    let mut B: md5_uint32 = 0;
    let mut C: md5_uint32 = 0;
    let mut D: md5_uint32 = 0;
    let mut cwp: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut A_save: md5_uint32 = 0;
    let mut B_save: md5_uint32 = 0;
    let mut C_save: md5_uint32 = 0;
    let mut D_save: md5_uint32 = 0;
    let mut tmp: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___0: md5_uint32 = 0;
    let mut tmp___1: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___2: md5_uint32 = 0;
    let mut tmp___3: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___4: md5_uint32 = 0;
    let mut tmp___5: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___6: md5_uint32 = 0;
    let mut tmp___7: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___8: md5_uint32 = 0;
    let mut tmp___9: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___10: md5_uint32 = 0;
    let mut tmp___11: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___12: md5_uint32 = 0;
    let mut tmp___13: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___14: md5_uint32 = 0;
    let mut tmp___15: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___16: md5_uint32 = 0;
    let mut tmp___17: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___18: md5_uint32 = 0;
    let mut tmp___19: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___20: md5_uint32 = 0;
    let mut tmp___21: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___22: md5_uint32 = 0;
    let mut tmp___23: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___24: md5_uint32 = 0;
    let mut tmp___25: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___26: md5_uint32 = 0;
    let mut tmp___27: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___28: md5_uint32 = 0;
    let mut tmp___29: *mut md5_uint32 = 0 as *mut md5_uint32;
    let mut tmp___30: md5_uint32 = 0;
    words = buffer as *const md5_uint32;
    nwords = len.wrapping_div(::std::mem::size_of::<md5_uint32>() as libc::c_ulong);
    endp = words.offset(nwords as isize);
    A = (*ctx).A;
    B = (*ctx).B;
    C = (*ctx).C;
    D = (*ctx).D;
    (*ctx)
        .total[0 as libc::c_int
        as usize] = ((*ctx).total[0 as libc::c_int as usize] as size_t).wrapping_add(len)
        as md5_uint32;
    (*ctx)
        .total[1 as libc::c_int
        as usize] = ((*ctx).total[1 as libc::c_int as usize] as size_t)
        .wrapping_add(
            (len >> 31 as libc::c_int >> 1 as libc::c_int)
                .wrapping_add(
                    (((*ctx).total[0 as libc::c_int as usize] as size_t) < len)
                        as libc::c_int as size_t,
                ),
        ) as md5_uint32;
    while (words as libc::c_ulong) < endp as libc::c_ulong {
        cwp = correct_words.as_mut_ptr();
        A_save = A;
        B_save = B;
        C_save = C;
        D_save = D;
        tmp = cwp;
        cwp = cwp.offset(1);
        tmp___0 = *words;
        *tmp = tmp___0;
        A = (A as libc::c_uint)
            .wrapping_add(
                (D ^ B & (C ^ D))
                    .wrapping_add(tmp___0)
                    .wrapping_add(3614090360 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        A = A << 7 as libc::c_int | A >> 25 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        tmp___1 = cwp;
        cwp = cwp.offset(1);
        tmp___2 = *words;
        *tmp___1 = tmp___2;
        D = (D as libc::c_uint)
            .wrapping_add(
                (C ^ A & (B ^ C))
                    .wrapping_add(tmp___2)
                    .wrapping_add(3905402710 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        D = D << 12 as libc::c_int | D >> 20 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        tmp___3 = cwp;
        cwp = cwp.offset(1);
        tmp___4 = *words;
        *tmp___3 = tmp___4;
        C = (C as libc::c_uint)
            .wrapping_add(
                (B ^ D & (A ^ B))
                    .wrapping_add(tmp___4)
                    .wrapping_add(606105819 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        C = C << 17 as libc::c_int | C >> 15 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        tmp___5 = cwp;
        cwp = cwp.offset(1);
        tmp___6 = *words;
        *tmp___5 = tmp___6;
        B = (B as libc::c_uint)
            .wrapping_add(
                (A ^ C & (D ^ A))
                    .wrapping_add(tmp___6)
                    .wrapping_add(3250441966 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        B = B << 22 as libc::c_int | B >> 10 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        tmp___7 = cwp;
        cwp = cwp.offset(1);
        tmp___8 = *words;
        *tmp___7 = tmp___8;
        A = (A as libc::c_uint)
            .wrapping_add(
                (D ^ B & (C ^ D))
                    .wrapping_add(tmp___8)
                    .wrapping_add(4118548399 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        A = A << 7 as libc::c_int | A >> 25 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        tmp___9 = cwp;
        cwp = cwp.offset(1);
        tmp___10 = *words;
        *tmp___9 = tmp___10;
        D = (D as libc::c_uint)
            .wrapping_add(
                (C ^ A & (B ^ C))
                    .wrapping_add(tmp___10)
                    .wrapping_add(1200080426 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        D = D << 12 as libc::c_int | D >> 20 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        tmp___11 = cwp;
        cwp = cwp.offset(1);
        tmp___12 = *words;
        *tmp___11 = tmp___12;
        C = (C as libc::c_uint)
            .wrapping_add(
                (B ^ D & (A ^ B))
                    .wrapping_add(tmp___12)
                    .wrapping_add(2821735955 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        C = C << 17 as libc::c_int | C >> 15 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        tmp___13 = cwp;
        cwp = cwp.offset(1);
        tmp___14 = *words;
        *tmp___13 = tmp___14;
        B = (B as libc::c_uint)
            .wrapping_add(
                (A ^ C & (D ^ A))
                    .wrapping_add(tmp___14)
                    .wrapping_add(4249261313 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        B = B << 22 as libc::c_int | B >> 10 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        tmp___15 = cwp;
        cwp = cwp.offset(1);
        tmp___16 = *words;
        *tmp___15 = tmp___16;
        A = (A as libc::c_uint)
            .wrapping_add(
                (D ^ B & (C ^ D))
                    .wrapping_add(tmp___16)
                    .wrapping_add(1770035416 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        A = A << 7 as libc::c_int | A >> 25 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        tmp___17 = cwp;
        cwp = cwp.offset(1);
        tmp___18 = *words;
        *tmp___17 = tmp___18;
        D = (D as libc::c_uint)
            .wrapping_add(
                (C ^ A & (B ^ C))
                    .wrapping_add(tmp___18)
                    .wrapping_add(2336552879 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        D = D << 12 as libc::c_int | D >> 20 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        tmp___19 = cwp;
        cwp = cwp.offset(1);
        tmp___20 = *words;
        *tmp___19 = tmp___20;
        C = (C as libc::c_uint)
            .wrapping_add(
                (B ^ D & (A ^ B))
                    .wrapping_add(tmp___20)
                    .wrapping_add(4294925233 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        C = C << 17 as libc::c_int | C >> 15 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        tmp___21 = cwp;
        cwp = cwp.offset(1);
        tmp___22 = *words;
        *tmp___21 = tmp___22;
        B = (B as libc::c_uint)
            .wrapping_add(
                (A ^ C & (D ^ A))
                    .wrapping_add(tmp___22)
                    .wrapping_add(2304563134 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        B = B << 22 as libc::c_int | B >> 10 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        tmp___23 = cwp;
        cwp = cwp.offset(1);
        tmp___24 = *words;
        *tmp___23 = tmp___24;
        A = (A as libc::c_uint)
            .wrapping_add(
                (D ^ B & (C ^ D))
                    .wrapping_add(tmp___24)
                    .wrapping_add(1804603682 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        A = A << 7 as libc::c_int | A >> 25 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        tmp___25 = cwp;
        cwp = cwp.offset(1);
        tmp___26 = *words;
        *tmp___25 = tmp___26;
        D = (D as libc::c_uint)
            .wrapping_add(
                (C ^ A & (B ^ C))
                    .wrapping_add(tmp___26)
                    .wrapping_add(4254626195 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        D = D << 12 as libc::c_int | D >> 20 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        tmp___27 = cwp;
        cwp = cwp.offset(1);
        tmp___28 = *words;
        *tmp___27 = tmp___28;
        C = (C as libc::c_uint)
            .wrapping_add(
                (B ^ D & (A ^ B))
                    .wrapping_add(tmp___28)
                    .wrapping_add(2792965006 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        C = C << 17 as libc::c_int | C >> 15 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        tmp___29 = cwp;
        cwp = cwp.offset(1);
        tmp___30 = *words;
        *tmp___29 = tmp___30;
        B = (B as libc::c_uint)
            .wrapping_add(
                (A ^ C & (D ^ A))
                    .wrapping_add(tmp___30)
                    .wrapping_add(1236535329 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        words = words.offset(1);
        B = B << 22 as libc::c_int | B >> 10 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ D & (B ^ C))
                    .wrapping_add(correct_words[1 as libc::c_int as usize])
                    .wrapping_add(4129170786 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 5 as libc::c_int | A >> 27 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ C & (A ^ B))
                    .wrapping_add(correct_words[6 as libc::c_int as usize])
                    .wrapping_add(3225465664 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 9 as libc::c_int | D >> 23 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ B & (D ^ A))
                    .wrapping_add(correct_words[11 as libc::c_int as usize])
                    .wrapping_add(643717713 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 14 as libc::c_int | C >> 18 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ A & (C ^ D))
                    .wrapping_add(correct_words[0 as libc::c_int as usize])
                    .wrapping_add(3921069994 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 20 as libc::c_int | B >> 12 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ D & (B ^ C))
                    .wrapping_add(correct_words[5 as libc::c_int as usize])
                    .wrapping_add(3593408605 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 5 as libc::c_int | A >> 27 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ C & (A ^ B))
                    .wrapping_add(correct_words[10 as libc::c_int as usize])
                    .wrapping_add(38016083 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 9 as libc::c_int | D >> 23 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ B & (D ^ A))
                    .wrapping_add(correct_words[15 as libc::c_int as usize])
                    .wrapping_add(3634488961 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 14 as libc::c_int | C >> 18 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ A & (C ^ D))
                    .wrapping_add(correct_words[4 as libc::c_int as usize])
                    .wrapping_add(3889429448 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 20 as libc::c_int | B >> 12 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ D & (B ^ C))
                    .wrapping_add(correct_words[9 as libc::c_int as usize])
                    .wrapping_add(568446438 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 5 as libc::c_int | A >> 27 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ C & (A ^ B))
                    .wrapping_add(correct_words[14 as libc::c_int as usize])
                    .wrapping_add(3275163606 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 9 as libc::c_int | D >> 23 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ B & (D ^ A))
                    .wrapping_add(correct_words[3 as libc::c_int as usize])
                    .wrapping_add(4107603335 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 14 as libc::c_int | C >> 18 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ A & (C ^ D))
                    .wrapping_add(correct_words[8 as libc::c_int as usize])
                    .wrapping_add(1163531501 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 20 as libc::c_int | B >> 12 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ D & (B ^ C))
                    .wrapping_add(correct_words[13 as libc::c_int as usize])
                    .wrapping_add(2850285829 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 5 as libc::c_int | A >> 27 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ C & (A ^ B))
                    .wrapping_add(correct_words[2 as libc::c_int as usize])
                    .wrapping_add(4243563512 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 9 as libc::c_int | D >> 23 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ B & (D ^ A))
                    .wrapping_add(correct_words[7 as libc::c_int as usize])
                    .wrapping_add(1735328473 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 14 as libc::c_int | C >> 18 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ A & (C ^ D))
                    .wrapping_add(correct_words[12 as libc::c_int as usize])
                    .wrapping_add(2368359562 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 20 as libc::c_int | B >> 12 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (B ^ C ^ D)
                    .wrapping_add(correct_words[5 as libc::c_int as usize])
                    .wrapping_add(4294588738 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 4 as libc::c_int | A >> 28 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (A ^ B ^ C)
                    .wrapping_add(correct_words[8 as libc::c_int as usize])
                    .wrapping_add(2272392833 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 11 as libc::c_int | D >> 21 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (D ^ A ^ B)
                    .wrapping_add(correct_words[11 as libc::c_int as usize])
                    .wrapping_add(1839030562 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 16 as libc::c_int | C >> 16 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (C ^ D ^ A)
                    .wrapping_add(correct_words[14 as libc::c_int as usize])
                    .wrapping_add(4259657740 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 23 as libc::c_int | B >> 9 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (B ^ C ^ D)
                    .wrapping_add(correct_words[1 as libc::c_int as usize])
                    .wrapping_add(2763975236 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 4 as libc::c_int | A >> 28 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (A ^ B ^ C)
                    .wrapping_add(correct_words[4 as libc::c_int as usize])
                    .wrapping_add(1272893353 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 11 as libc::c_int | D >> 21 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (D ^ A ^ B)
                    .wrapping_add(correct_words[7 as libc::c_int as usize])
                    .wrapping_add(4139469664 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 16 as libc::c_int | C >> 16 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (C ^ D ^ A)
                    .wrapping_add(correct_words[10 as libc::c_int as usize])
                    .wrapping_add(3200236656 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 23 as libc::c_int | B >> 9 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (B ^ C ^ D)
                    .wrapping_add(correct_words[13 as libc::c_int as usize])
                    .wrapping_add(681279174 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 4 as libc::c_int | A >> 28 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (A ^ B ^ C)
                    .wrapping_add(correct_words[0 as libc::c_int as usize])
                    .wrapping_add(3936430074 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 11 as libc::c_int | D >> 21 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (D ^ A ^ B)
                    .wrapping_add(correct_words[3 as libc::c_int as usize])
                    .wrapping_add(3572445317 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 16 as libc::c_int | C >> 16 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (C ^ D ^ A)
                    .wrapping_add(correct_words[6 as libc::c_int as usize])
                    .wrapping_add(76029189 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 23 as libc::c_int | B >> 9 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (B ^ C ^ D)
                    .wrapping_add(correct_words[9 as libc::c_int as usize])
                    .wrapping_add(3654602809 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 4 as libc::c_int | A >> 28 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (A ^ B ^ C)
                    .wrapping_add(correct_words[12 as libc::c_int as usize])
                    .wrapping_add(3873151461 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 11 as libc::c_int | D >> 21 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (D ^ A ^ B)
                    .wrapping_add(correct_words[15 as libc::c_int as usize])
                    .wrapping_add(530742520 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 16 as libc::c_int | C >> 16 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (C ^ D ^ A)
                    .wrapping_add(correct_words[2 as libc::c_int as usize])
                    .wrapping_add(3299628645 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 23 as libc::c_int | B >> 9 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ (B | !D))
                    .wrapping_add(correct_words[0 as libc::c_int as usize])
                    .wrapping_add(4096336452 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 6 as libc::c_int | A >> 26 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ (A | !C))
                    .wrapping_add(correct_words[7 as libc::c_int as usize])
                    .wrapping_add(1126891415 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 10 as libc::c_int | D >> 22 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ (D | !B))
                    .wrapping_add(correct_words[14 as libc::c_int as usize])
                    .wrapping_add(2878612391 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 15 as libc::c_int | C >> 17 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ (C | !A))
                    .wrapping_add(correct_words[5 as libc::c_int as usize])
                    .wrapping_add(4237533241 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 21 as libc::c_int | B >> 11 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ (B | !D))
                    .wrapping_add(correct_words[12 as libc::c_int as usize])
                    .wrapping_add(1700485571 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 6 as libc::c_int | A >> 26 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ (A | !C))
                    .wrapping_add(correct_words[3 as libc::c_int as usize])
                    .wrapping_add(2399980690 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 10 as libc::c_int | D >> 22 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ (D | !B))
                    .wrapping_add(correct_words[10 as libc::c_int as usize])
                    .wrapping_add(4293915773 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 15 as libc::c_int | C >> 17 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ (C | !A))
                    .wrapping_add(correct_words[1 as libc::c_int as usize])
                    .wrapping_add(2240044497 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 21 as libc::c_int | B >> 11 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ (B | !D))
                    .wrapping_add(correct_words[8 as libc::c_int as usize])
                    .wrapping_add(1873313359 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 6 as libc::c_int | A >> 26 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ (A | !C))
                    .wrapping_add(correct_words[15 as libc::c_int as usize])
                    .wrapping_add(4264355552 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 10 as libc::c_int | D >> 22 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ (D | !B))
                    .wrapping_add(correct_words[6 as libc::c_int as usize])
                    .wrapping_add(2734768916 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 15 as libc::c_int | C >> 17 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ (C | !A))
                    .wrapping_add(correct_words[13 as libc::c_int as usize])
                    .wrapping_add(1309151649 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 21 as libc::c_int | B >> 11 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint)
            .wrapping_add(
                (C ^ (B | !D))
                    .wrapping_add(correct_words[4 as libc::c_int as usize])
                    .wrapping_add(4149444226 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        A = A << 6 as libc::c_int | A >> 26 as libc::c_int;
        A = (A as libc::c_uint).wrapping_add(B) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint)
            .wrapping_add(
                (B ^ (A | !C))
                    .wrapping_add(correct_words[11 as libc::c_int as usize])
                    .wrapping_add(3174756917 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        D = D << 10 as libc::c_int | D >> 22 as libc::c_int;
        D = (D as libc::c_uint).wrapping_add(A) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint)
            .wrapping_add(
                (A ^ (D | !B))
                    .wrapping_add(correct_words[2 as libc::c_int as usize])
                    .wrapping_add(718787259 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        C = C << 15 as libc::c_int | C >> 17 as libc::c_int;
        C = (C as libc::c_uint).wrapping_add(D) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint)
            .wrapping_add(
                (D ^ (C | !A))
                    .wrapping_add(correct_words[9 as libc::c_int as usize])
                    .wrapping_add(3951481745 as libc::c_uint),
            ) as md5_uint32 as md5_uint32;
        B = B << 21 as libc::c_int | B >> 11 as libc::c_int;
        B = (B as libc::c_uint).wrapping_add(C) as md5_uint32 as md5_uint32;
        A = (A as libc::c_uint).wrapping_add(A_save) as md5_uint32 as md5_uint32;
        B = (B as libc::c_uint).wrapping_add(B_save) as md5_uint32 as md5_uint32;
        C = (C as libc::c_uint).wrapping_add(C_save) as md5_uint32 as md5_uint32;
        D = (D as libc::c_uint).wrapping_add(D_save) as md5_uint32 as md5_uint32;
    }
    (*ctx).A = A;
    (*ctx).B = B;
    (*ctx).C = C;
    (*ctx).D = D;
}
pub unsafe extern "C" fn xstrdup(mut str: *const libc::c_char) -> *mut libc::c_char {
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    if str.is_null() {
        NOTIFY(ERROR, b"string has no value!\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    ret = strdup(str);
    if ret as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            FATAL,
            b"xstrdup: unable to allocate additional memory\0" as *const u8
                as *const libc::c_char,
        );
    }
    return ret;
}
pub unsafe extern "C" fn xstrcat(
    mut arg1: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut argptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut resptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut valist: ::std::ffi::VaListImpl;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    len = 0 as libc::c_int as size_t;
    valist = args.clone();
    argptr = arg1;
    while argptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = strlen(argptr);
        len = (len as libc::c_ulong).wrapping_add(tmp___0) as size_t as size_t;
        tmp = valist.arg::<*mut libc::c_char>();
        argptr = tmp;
    }
    tmp___1 = xmalloc(len.wrapping_add(1 as libc::c_ulong));
    result = tmp___1 as *mut libc::c_char;
    resptr = result;
    valist = args.clone();
    argptr = arg1;
    while argptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        len = strlen(argptr);
        memcpy(resptr as *mut libc::c_void, argptr as *const libc::c_void, len);
        resptr = resptr.offset(len as isize);
        tmp___2 = valist.arg::<*mut libc::c_char>();
        argptr = tmp___2;
    }
    *resptr = '\u{0}' as i32 as libc::c_char;
    return result;
}
pub unsafe extern "C" fn xrealloc(
    mut ptr: *mut libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ptr.is_null() {
        tmp = realloc(ptr, size);
    } else {
        tmp = malloc(size);
    }
    if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            FATAL,
            b"Memory exhausted; unable to continue.\0" as *const u8
                as *const libc::c_char,
        );
    }
    return tmp;
}
pub unsafe extern "C" fn xmalloc(mut size: size_t) -> *mut libc::c_void {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp___0 = malloc(size);
    tmp = tmp___0;
    if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            FATAL,
            b"Unable to allocate additional memory.\0" as *const u8
                as *const libc::c_char,
        );
    }
    return tmp;
}
pub unsafe extern "C" fn xcalloc(
    mut num: size_t,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp___0 = xmalloc(num.wrapping_mul(size));
    tmp = tmp___0;
    memset(tmp, 0 as libc::c_int, num.wrapping_mul(size));
    return tmp;
}
pub unsafe extern "C" fn xfree(mut ptr: *mut libc::c_void) {
    if ptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free(ptr);
        ptr = 0 as *mut libc::c_void;
    }
}
pub unsafe extern "C" fn OPENLOG(mut program: *mut libc::c_char) {
    openlog(
        program as *const libc::c_char,
        1 as libc::c_int,
        (3 as libc::c_int) << 3 as libc::c_int,
    );
}
pub unsafe extern "C" fn CLOSELOG() {
    closelog();
}
unsafe extern "C" fn __message(
    mut M: METHOD,
    mut L: LEVEL,
    mut fmt: *const libc::c_char,
    mut ap: ::std::ffi::VaList,
) {
    let mut buf: [libc::c_char; 40000] = [0; 40000];
    let mut msg: [libc::c_char; 41024] = [0; 41024];
    let mut level: LEVEL = DEBUG;
    let mut pmode: [libc::c_char; 64] = [0; 64];
    let mut lmode: [libc::c_char; 64] = [0; 64];
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    level = WARNING;
    memset(
        lmode.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    memset(
        pmode.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        64 as libc::c_int as size_t,
    );
    vsprintf(buf.as_mut_ptr(), fmt, ap.as_va_list());
    tmp___1 = __errno_location();
    if *tmp___1 == 0 as libc::c_int {
        snprintf(
            msg.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 41024]>() as libc::c_ulong,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            buf.as_mut_ptr(),
        );
    } else {
        tmp___2 = __errno_location();
        if *tmp___2 == 38 as libc::c_int {
            snprintf(
                msg.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 41024]>() as libc::c_ulong,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                buf.as_mut_ptr(),
            );
        } else if L as libc::c_uint == 0 as libc::c_uint {
            snprintf(
                msg.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 41024]>() as libc::c_ulong,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                buf.as_mut_ptr(),
            );
        } else {
            tmp = __errno_location();
            tmp___0 = strerror(*tmp);
            snprintf(
                msg.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 41024]>() as libc::c_ulong,
                b"%s: %s\n\0" as *const u8 as *const libc::c_char,
                buf.as_mut_ptr(),
                tmp___0,
            );
        }
    }
    match L as libc::c_uint {
        0 => {
            sprintf(
                pmode.as_mut_ptr(),
                b"[%c[%d;%dmdebug%c[%dm]\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                1 as libc::c_int,
                34 as libc::c_int,
                27 as libc::c_int,
                0 as libc::c_int,
            );
            strcpy(lmode.as_mut_ptr(), b"[debug]\0" as *const u8 as *const libc::c_char);
            level = 4 as LEVEL;
        }
        1 => {
            sprintf(
                pmode.as_mut_ptr(),
                b"[%c[%d;%dmalert%c[%dm]\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                1 as libc::c_int,
                32 as libc::c_int,
                27 as libc::c_int,
                0 as libc::c_int,
            );
            strcpy(
                lmode.as_mut_ptr(),
                b"[alert] \0" as *const u8 as *const libc::c_char,
            );
            level = 4 as LEVEL;
        }
        2 => {
            sprintf(
                pmode.as_mut_ptr(),
                b"[%c[%d;%dmerror%c[%dm]\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                1 as libc::c_int,
                33 as libc::c_int,
                27 as libc::c_int,
                0 as libc::c_int,
            );
            strcpy(lmode.as_mut_ptr(), b"[error]\0" as *const u8 as *const libc::c_char);
            level = FATAL;
        }
        3 => {
            sprintf(
                pmode.as_mut_ptr(),
                b"[%c[%d;%dmfatal%c[%dm]\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                1 as libc::c_int,
                31 as libc::c_int,
                27 as libc::c_int,
                0 as libc::c_int,
            );
            strcpy(lmode.as_mut_ptr(), b"[fatal]\0" as *const u8 as *const libc::c_char);
            level = ERROR;
        }
        _ => {}
    }
    if M as libc::c_uint == 1 as libc::c_uint {
        syslog(
            level as libc::c_int,
            b"%s %s\0" as *const u8 as *const libc::c_char,
            lmode.as_mut_ptr(),
            msg.as_mut_ptr(),
        );
    } else {
        fflush(stdout);
        fprintf(
            stderr,
            b"%s %s\0" as *const u8 as *const libc::c_char,
            pmode.as_mut_ptr(),
            msg.as_mut_ptr(),
        );
    }
    if L as libc::c_uint == 3 as libc::c_uint {
        exit(1 as libc::c_int);
    }
}
pub unsafe extern "C" fn SYSLOG(
    mut L: LEVEL,
    mut fmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    __message(1 as libc::c_int, L, fmt, ap.as_va_list());
}
pub unsafe extern "C" fn NOTIFY(
    mut L: LEVEL,
    mut fmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    __message(2 as libc::c_int, L, fmt, ap.as_va_list());
}
pub unsafe extern "C" fn __display(
    mut color: libc::c_int,
    mut fmt: *const libc::c_char,
    mut ap: ::std::ffi::VaList,
) {
    let mut buf: [libc::c_char; 40000] = [0; 40000];
    let mut msg: [libc::c_char; 41024] = [0; 41024];
    vsprintf(buf.as_mut_ptr(), fmt, ap.as_va_list());
    if color == -(1 as libc::c_int) {
        snprintf(
            msg.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 41024]>() as libc::c_ulong,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            buf.as_mut_ptr(),
        );
    } else {
        snprintf(
            msg.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 41024]>() as libc::c_ulong,
            b"%c[%d;%dm%s%c[%dm\n\0" as *const u8 as *const libc::c_char,
            27 as libc::c_int,
            0 as libc::c_int,
            color + 30 as libc::c_int,
            buf.as_mut_ptr(),
            27 as libc::c_int,
            0 as libc::c_int,
        );
    }
    printf(b"%s\0" as *const u8 as *const libc::c_char, msg.as_mut_ptr());
}
pub unsafe extern "C" fn DISPLAY(
    mut color: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    __display(color, fmt, ap.as_va_list());
}
pub static mut PAGESIZE: size_t = ::std::mem::size_of::<PAGE_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_page(mut str: *mut libc::c_char) -> PAGE {
    let mut this: PAGE = 0 as *mut PAGE_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(1 as libc::c_int as size_t, PAGESIZE);
    this = tmp as PAGE;
    (*this).len = strlen(str as *const libc::c_char);
    (*this).size = ((*this).len).wrapping_add(24576 as libc::c_ulong);
    tmp___0 = calloc(1 as libc::c_int as size_t, (*this).size);
    (*this).buf = tmp___0 as *mut libc::c_char;
    memcpy((*this).buf as *mut libc::c_void, str as *const libc::c_void, (*this).len);
    return this;
}
pub unsafe extern "C" fn page_destroy(mut this: PAGE) -> PAGE {
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*this).len = 0 as libc::c_int as size_t;
        (*this).size = 0 as libc::c_int as size_t;
        free((*this).buf as *mut libc::c_void);
        free(this as *mut libc::c_void);
    }
    return this;
}
pub unsafe extern "C" fn page_length(mut this: PAGE) -> size_t {
    return (*this).len;
}
pub unsafe extern "C" fn page_size(mut this: PAGE) -> size_t {
    return (*this).size;
}
pub unsafe extern "C" fn page_concat(
    mut this: PAGE,
    mut str: *const libc::c_char,
    len: libc::c_int,
) {
    let mut tmp: size_t = 0;
    if this.is_null() {
        return
    } else {
        if str.is_null() {
            return
        } else {
            tmp = strlen(str);
            if tmp < 1 as libc::c_ulong {
                return
            } else {
                if len < 0 as libc::c_int {
                    return;
                }
            }
        }
    }
    if ((*this).len).wrapping_add(len as size_t) > (*this).size {
        __expand(this, len + 1 as libc::c_int);
    }
    memcpy(
        ((*this).buf).offset((*this).len as isize) as *mut libc::c_void,
        str as *const libc::c_void,
        len as size_t,
    );
    (*this)
        .len = ((*this).len as libc::c_ulong).wrapping_add(len as size_t) as size_t
        as size_t;
    *((*this).buf)
        .offset(
            ((*this).len).wrapping_add(1 as libc::c_ulong) as isize,
        ) = '\u{0}' as i32 as libc::c_char;
}
pub unsafe extern "C" fn page_clear(mut this: PAGE) {
    if this.is_null() {
        return;
    }
    (*this).len = 0 as libc::c_int as size_t;
    memset((*this).buf as *mut libc::c_void, '\u{0}' as i32, (*this).size);
}
pub unsafe extern "C" fn page_value(mut this: PAGE) -> *mut libc::c_char {
    return (*this).buf;
}
pub unsafe extern "C" fn __expand(mut this: PAGE, len: libc::c_int) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if this.is_null() {
        return
    } else {
        if len < 0 as libc::c_int {
            return;
        }
    }
    (*this)
        .size = ((*this).size as libc::c_ulong).wrapping_add(len as size_t) as size_t
        as size_t;
    tmp = realloc((*this).buf as *mut libc::c_void, (*this).size);
    (*this).buf = tmp as *mut libc::c_char;
    memset(
        ((*this).buf).offset(((*this).size).wrapping_sub(len as size_t) as isize)
            as *mut libc::c_void,
        '\u{0}' as i32,
        len as size_t,
    );
}
pub unsafe extern "C" fn html_parser(
    mut array: ARRAY,
    mut base: URL,
    mut page: *mut libc::c_char,
) -> BOOLEAN {
    let mut str: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp: [libc::c_char; 4096] = [0; 4096];
    let mut tmp___0: size_t = 0;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: BOOLEAN = boolean_false;
    memset(
        tmp.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        4096 as libc::c_int as size_t,
    );
    str = __xstrip(
        page as *const libc::c_char,
        b"\\\0" as *const u8 as *const libc::c_char,
    );
    ptr = str;
    if page as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return boolean_false;
    }
    tmp___0 = strlen(page as *const libc::c_char);
    if tmp___0 < 1 as libc::c_ulong {
        return boolean_false;
    }
    while *ptr as libc::c_int != 0 as libc::c_int {
        if *ptr as libc::c_int == 60 as libc::c_int {
            ptr = ptr.offset(1);
            tmp___2 = startswith(
                b"!--\0" as *const u8 as *const libc::c_char,
                ptr as *const libc::c_char,
            );
            if tmp___2 as libc::c_uint == 1 as libc::c_uint {
                ptr = ptr.offset(3 as libc::c_int as isize);
                while *ptr as libc::c_int != 0 as libc::c_int {
                    tmp___1 = startswith(
                        b"-->\0" as *const u8 as *const libc::c_char,
                        ptr as *const libc::c_char,
                    );
                    if tmp___1 as libc::c_uint == 1 as libc::c_uint {
                        ptr = ptr.offset(3 as libc::c_int as isize);
                        break;
                    } else {
                        ptr = ptr.offset(1);
                    }
                }
            } else {
                i = 0 as libc::c_int;
                memset(
                    tmp.as_mut_ptr() as *mut libc::c_void,
                    '\u{0}' as i32,
                    ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
                );
                while *ptr as libc::c_int != 0 as libc::c_int {
                    if !(*ptr as libc::c_int != 62 as libc::c_int) {
                        break;
                    }
                    if !(i < 4095 as libc::c_int) {
                        break;
                    }
                    tmp[i as usize] = *ptr;
                    i += 1;
                    ptr = ptr.offset(1);
                }
                __parse_control(array, base, tmp.as_mut_ptr());
            }
        }
        ptr = ptr.offset(1);
    }
    xfree(str as *mut libc::c_void);
    return boolean_true;
}
unsafe extern "C" fn __add_url(mut array: ARRAY, mut U: URL) {
    let mut i: libc::c_int = 0;
    let mut found: BOOLEAN = boolean_false;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut url: URL = 0 as *mut URL_T;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: BOOLEAN = boolean_false;
    let mut tmp___6: size_t = 0;
    i = 0 as libc::c_int;
    found = boolean_false;
    if U as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return
    } else {
        tmp = url_get_hostname(U);
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return
        } else {
            tmp___0 = url_get_hostname(U);
            tmp___1 = strlen(tmp___0 as *const libc::c_char);
            if tmp___1 < 2 as libc::c_ulong {
                return;
            }
        }
    }
    if array as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        i = 0 as libc::c_int;
        loop {
            tmp___6 = array_length(array);
            if !(i < tmp___6 as libc::c_int) {
                break;
            }
            tmp___2 = array_get(array, i);
            url = tmp___2 as URL;
            tmp___3 = url_get_absolute(url);
            tmp___4 = url_get_absolute(U);
            tmp___5 = strmatch(tmp___4, tmp___3);
            if tmp___5 as u64 != 0 {
                found = boolean_true;
            }
            i += 1;
        }
    }
    if found as u64 == 0 {
        array_npush(array, U as *mut libc::c_void, URLSIZE);
    }
}
unsafe extern "C" fn __parse_control(
    mut array: ARRAY,
    mut base: URL,
    mut html: *mut libc::c_char,
) {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aid: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: [libc::c_char; 4096] = [0; 4096];
    let mut top: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut debug___0: BOOLEAN = boolean_false;
    let mut U: URL = 0 as *mut URL_T;
    let mut tmp___0: URL = 0 as *mut URL_T;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut U___0: URL = 0 as *mut URL_T;
    let mut tmp___6: URL = 0 as *mut URL_T;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: BOOLEAN = boolean_false;
    let mut U___1: URL = 0 as *mut URL_T;
    let mut tmp___10: URL = 0 as *mut URL_T;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: size_t = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut okay___0: BOOLEAN = boolean_false;
    let mut buf: [libc::c_char; 2048] = [0; 2048];
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: size_t = 0;
    let mut tmp___21: libc::c_int = 0;
    let mut U___2: URL = 0 as *mut URL_T;
    let mut tmp___22: URL = 0 as *mut URL_T;
    let mut tmp___23: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___24: BOOLEAN = boolean_false;
    let mut U___3: URL = 0 as *mut URL_T;
    let mut tmp___25: URL = 0 as *mut URL_T;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut U___4: URL = 0 as *mut URL_T;
    let mut tmp___29: URL = 0 as *mut URL_T;
    let mut tmp___30: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___31: BOOLEAN = boolean_false;
    let mut tmp___32: libc::c_int = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: libc::c_int = 0;
    let mut tmp___38: libc::c_int = 0;
    let mut tmp___39: libc::c_int = 0;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    debug___0 = boolean_false;
    top = strtok_r(
        html,
        b" =\0" as *const u8 as *const libc::c_char,
        &mut aid as *mut *mut libc::c_char,
    );
    ptr = top;
    while ptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___39 = strncasecmp(
            ptr as *const libc::c_char,
            b"href\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
        if tmp___39 == 0 as libc::c_int {
            ptr = strtok_r(
                0 as *mut libc::c_void as *mut libc::c_char,
                b" =\"'\0" as *const u8 as *const libc::c_char,
                &mut aid as *mut *mut libc::c_char,
            );
            if ptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                memset(
                    tmp.as_mut_ptr() as *mut libc::c_void,
                    '\u{0}' as i32,
                    4096 as libc::c_int as size_t,
                );
                strncpy(
                    tmp.as_mut_ptr(),
                    ptr as *const libc::c_char,
                    4095 as libc::c_int as size_t,
                );
            }
        } else {
            tmp___38 = strncasecmp(
                ptr as *const libc::c_char,
                b"meta\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as size_t,
            );
            if tmp___38 == 0 as libc::c_int {
                ptr = strtok_r(
                    0 as *mut libc::c_void as *mut libc::c_char,
                    b" =\0" as *const u8 as *const libc::c_char,
                    &mut aid as *mut *mut libc::c_char,
                );
                while ptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___3 = strncasecmp(
                        ptr as *const libc::c_char,
                        b"content\0" as *const u8 as *const libc::c_char,
                        7 as libc::c_int as size_t,
                    );
                    if tmp___3 == 0 as libc::c_int {
                        ptr = strtok_r(
                            0 as *mut libc::c_void as *mut libc::c_char,
                            b" =\0" as *const u8 as *const libc::c_char,
                            &mut aid as *mut *mut libc::c_char,
                        );
                        while ptr as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            tmp___2 = __strcasestr(
                                ptr as *const libc::c_char,
                                b"url\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___2 as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                ptr = strtok_r(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    b" \"'\0" as *const u8 as *const libc::c_char,
                                    &mut aid as *mut *mut libc::c_char,
                                );
                                if ptr as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___0 = url_normalize(base, ptr);
                                    U = tmp___0;
                                    url_set_redirect(U, boolean_true);
                                    if debug___0 as u64 != 0 {
                                        tmp___1 = url_get_absolute(U);
                                        printf(
                                            b"1.) Adding: %s\n\0" as *const u8 as *const libc::c_char,
                                            tmp___1,
                                        );
                                    }
                                    __add_url(array, U);
                                }
                            }
                            ptr = strtok_r(
                                0 as *mut libc::c_void as *mut libc::c_char,
                                b" =\0" as *const u8 as *const libc::c_char,
                                &mut aid as *mut *mut libc::c_char,
                            );
                        }
                    }
                    ptr = strtok_r(
                        0 as *mut libc::c_void as *mut libc::c_char,
                        b" =\0" as *const u8 as *const libc::c_char,
                        &mut aid as *mut *mut libc::c_char,
                    );
                }
            } else {
                tmp___37 = strncasecmp(
                    ptr as *const libc::c_char,
                    b"img\0" as *const u8 as *const libc::c_char,
                    3 as libc::c_int as size_t,
                );
                if tmp___37 == 0 as libc::c_int {
                    ptr = strtok_r(
                        0 as *mut libc::c_void as *mut libc::c_char,
                        b" =\0" as *const u8 as *const libc::c_char,
                        &mut aid as *mut *mut libc::c_char,
                    );
                    if ptr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                        if aid as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            tmp___4 = strncasecmp(
                                aid as *const libc::c_char,
                                b"\"\"\0" as *const u8 as *const libc::c_char,
                                2 as libc::c_int as size_t,
                            );
                            if tmp___4 == 0 {
                                continue;
                            }
                            tmp___15 = strncasecmp(
                                ptr as *const libc::c_char,
                                b"src\0" as *const u8 as *const libc::c_char,
                                3 as libc::c_int as size_t,
                            );
                            if tmp___15 != 0 {
                                ptr = strtok_r(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    b" =\0" as *const u8 as *const libc::c_char,
                                    &mut aid as *mut *mut libc::c_char,
                                );
                                while ptr as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    if ptr as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = strncasecmp(
                                            ptr as *const libc::c_char,
                                            b"src\0" as *const u8 as *const libc::c_char,
                                            3 as libc::c_int as size_t,
                                        );
                                        if tmp___14 == 0 as libc::c_int {
                                            ptr = strtok_r(
                                                0 as *mut libc::c_void as *mut libc::c_char,
                                                b" \"'\0" as *const u8 as *const libc::c_char,
                                                &mut aid as *mut *mut libc::c_char,
                                            );
                                            if ptr as libc::c_ulong
                                                != 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___12 = strlen(ptr as *const libc::c_char);
                                                if tmp___12 > 1 as libc::c_ulong {
                                                    tmp___13 = strncasecmp(
                                                        ptr as *const libc::c_char,
                                                        b"data:image\0" as *const u8 as *const libc::c_char,
                                                        10 as libc::c_int as size_t,
                                                    );
                                                    if tmp___13 != 0 {
                                                        tmp___10 = url_normalize(base, ptr);
                                                        U___1 = tmp___10;
                                                        if debug___0 as u64 != 0 {
                                                            tmp___11 = url_get_absolute(U___1);
                                                            printf(
                                                                b"3.) Adding: %s\n\0" as *const u8 as *const libc::c_char,
                                                                tmp___11,
                                                            );
                                                        }
                                                        __add_url(array, U___1);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    ptr = strtok_r(
                                        0 as *mut libc::c_void as *mut libc::c_char,
                                        b" =\0" as *const u8 as *const libc::c_char,
                                        &mut aid as *mut *mut libc::c_char,
                                    );
                                }
                            } else {
                                ptr = strtok_r(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    b" \"'\0" as *const u8 as *const libc::c_char,
                                    &mut aid as *mut *mut libc::c_char,
                                );
                                if ptr as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___5 = strncasecmp(
                                        ptr as *const libc::c_char,
                                        b"data:image\0" as *const u8 as *const libc::c_char,
                                        10 as libc::c_int as size_t,
                                    );
                                    if tmp___5 == 0 {
                                        continue;
                                    }
                                    tmp___6 = url_normalize(base, ptr);
                                    U___0 = tmp___6;
                                    if debug___0 as u64 != 0 {
                                        tmp___7 = url_get_absolute(U___0);
                                        printf(
                                            b"2.) Adding: %s\n\0" as *const u8 as *const libc::c_char,
                                            tmp___7,
                                        );
                                    }
                                    tmp___8 = url_get_absolute(U___0);
                                    tmp___9 = endswith(
                                        b"+\0" as *const u8 as *const libc::c_char,
                                        tmp___8 as *const libc::c_char,
                                    );
                                    if tmp___9 as u64 == 0 {
                                        __add_url(array, U___0);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    tmp___36 = strncasecmp(
                        ptr as *const libc::c_char,
                        b"link\0" as *const u8 as *const libc::c_char,
                        4 as libc::c_int as size_t,
                    );
                    if tmp___36 == 0 as libc::c_int {
                        okay___0 = boolean_false;
                        ptr = strtok_r(
                            0 as *mut libc::c_void as *mut libc::c_char,
                            b" =\0" as *const u8 as *const libc::c_char,
                            &mut aid as *mut *mut libc::c_char,
                        );
                        while ptr as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            let mut current_block_107: u64;
                            tmp___19 = strncasecmp(
                                ptr as *const libc::c_char,
                                b"rel\0" as *const u8 as *const libc::c_char,
                                3 as libc::c_int as size_t,
                            );
                            if tmp___19 == 0 as libc::c_int {
                                ptr = strtok_r(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    b" =\"'\0" as *const u8 as *const libc::c_char,
                                    &mut aid as *mut *mut libc::c_char,
                                );
                                if ptr as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    current_block_107 = 1333417132255980780;
                                } else {
                                    tmp___16 = strncasecmp(
                                        ptr as *const libc::c_char,
                                        b"stylesheet\0" as *const u8 as *const libc::c_char,
                                        10 as libc::c_int as size_t,
                                    );
                                    if tmp___16 == 0 as libc::c_int {
                                        okay___0 = boolean_true;
                                    }
                                    tmp___17 = strncasecmp(
                                        ptr as *const libc::c_char,
                                        b"next\0" as *const u8 as *const libc::c_char,
                                        4 as libc::c_int as size_t,
                                    );
                                    if tmp___17 == 0 as libc::c_int {
                                        okay___0 = boolean_false;
                                    }
                                    tmp___18 = strncasecmp(
                                        ptr as *const libc::c_char,
                                        b"alternate\0" as *const u8 as *const libc::c_char,
                                        9 as libc::c_int as size_t,
                                    );
                                    if tmp___18 == 0 as libc::c_int {
                                        okay___0 = boolean_false;
                                    }
                                    current_block_107 = 12065775993741208975;
                                }
                            } else {
                                current_block_107 = 12065775993741208975;
                            }
                            match current_block_107 {
                                12065775993741208975 => {
                                    tmp___21 = strncasecmp(
                                        ptr as *const libc::c_char,
                                        b"href\0" as *const u8 as *const libc::c_char,
                                        4 as libc::c_int as size_t,
                                    );
                                    if tmp___21 == 0 as libc::c_int {
                                        ptr = strtok_r(
                                            0 as *mut libc::c_void as *mut libc::c_char,
                                            b" \"'\0" as *const u8 as *const libc::c_char,
                                            &mut aid as *mut *mut libc::c_char,
                                        );
                                        if ptr as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            memset(
                                                buf.as_mut_ptr() as *mut libc::c_void,
                                                '\u{0}' as i32,
                                                ::std::mem::size_of::<[libc::c_char; 2048]>()
                                                    as libc::c_ulong,
                                            );
                                            tmp___20 = strlen(ptr as *const libc::c_char);
                                            strncpy(
                                                buf.as_mut_ptr(),
                                                ptr as *const libc::c_char,
                                                tmp___20,
                                            );
                                        }
                                    }
                                }
                                _ => {}
                            }
                            ptr = strtok_r(
                                0 as *mut libc::c_void as *mut libc::c_char,
                                b" =\0" as *const u8 as *const libc::c_char,
                                &mut aid as *mut *mut libc::c_char,
                            );
                        }
                        if okay___0 as u64 != 0 {
                            tmp___22 = url_normalize(base, buf.as_mut_ptr());
                            U___2 = tmp___22;
                            if debug___0 as u64 != 0 {
                                tmp___23 = url_get_absolute(U___2);
                                printf(
                                    b"4.) Adding: %s\n\0" as *const u8 as *const libc::c_char,
                                    tmp___23,
                                );
                            }
                            __add_url(array, U___2);
                        }
                    } else {
                        tmp___35 = strncasecmp(
                            ptr as *const libc::c_char,
                            b"script\0" as *const u8 as *const libc::c_char,
                            6 as libc::c_int as size_t,
                        );
                        if tmp___35 == 0 as libc::c_int {
                            ptr = strtok_r(
                                0 as *mut libc::c_void as *mut libc::c_char,
                                b" =\0" as *const u8 as *const libc::c_char,
                                &mut aid as *mut *mut libc::c_char,
                            );
                            while ptr as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___27 = strncasecmp(
                                    ptr as *const libc::c_char,
                                    b"src\0" as *const u8 as *const libc::c_char,
                                    3 as libc::c_int as size_t,
                                );
                                if tmp___27 == 0 as libc::c_int {
                                    ptr = strtok_r(
                                        0 as *mut libc::c_void as *mut libc::c_char,
                                        b" \"'\0" as *const u8 as *const libc::c_char,
                                        &mut aid as *mut *mut libc::c_char,
                                    );
                                    if ptr as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___24 = startswith(
                                            b"+\0" as *const u8 as *const libc::c_char,
                                            ptr as *const libc::c_char,
                                        );
                                        if !(tmp___24 as u64 != 0) {
                                            memset(
                                                tmp.as_mut_ptr() as *mut libc::c_void,
                                                0 as libc::c_int,
                                                4096 as libc::c_int as size_t,
                                            );
                                            strncpy(
                                                tmp.as_mut_ptr(),
                                                ptr as *const libc::c_char,
                                                4095 as libc::c_int as size_t,
                                            );
                                            tmp___25 = url_normalize(base, tmp.as_mut_ptr());
                                            U___3 = tmp___25;
                                            if debug___0 as u64 != 0 {
                                                tmp___26 = url_get_absolute(U___3);
                                                printf(
                                                    b"5.) Adding: %s\n\0" as *const u8 as *const libc::c_char,
                                                    tmp___26,
                                                );
                                            }
                                            __add_url(array, U___3);
                                        }
                                    }
                                }
                                ptr = strtok_r(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    b" =\0" as *const u8 as *const libc::c_char,
                                    &mut aid as *mut *mut libc::c_char,
                                );
                            }
                        } else {
                            tmp___34 = strncasecmp(
                                ptr as *const libc::c_char,
                                b"location.href\0" as *const u8 as *const libc::c_char,
                                13 as libc::c_int as size_t,
                            );
                            if tmp___34 == 0 as libc::c_int {
                                ptr = strtok_r(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    b" =\"'\0" as *const u8 as *const libc::c_char,
                                    &mut aid as *mut *mut libc::c_char,
                                );
                                if ptr as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    memset(
                                        tmp.as_mut_ptr() as *mut libc::c_void,
                                        '\u{0}' as i32,
                                        4096 as libc::c_int as size_t,
                                    );
                                    strncpy(
                                        tmp.as_mut_ptr(),
                                        ptr as *const libc::c_char,
                                        4095 as libc::c_int as size_t,
                                    );
                                }
                            } else {
                                tmp___33 = strncasecmp(
                                    ptr as *const libc::c_char,
                                    b"frame\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int as size_t,
                                );
                                if tmp___33 == 0 as libc::c_int {
                                    ptr = strtok_r(
                                        0 as *mut libc::c_void as *mut libc::c_char,
                                        b" =\0" as *const u8 as *const libc::c_char,
                                        &mut aid as *mut *mut libc::c_char,
                                    );
                                    while ptr as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___28 = strncasecmp(
                                            ptr as *const libc::c_char,
                                            b"src\0" as *const u8 as *const libc::c_char,
                                            3 as libc::c_int as size_t,
                                        );
                                        if tmp___28 == 0 as libc::c_int {
                                            ptr = strtok_r(
                                                0 as *mut libc::c_void as *mut libc::c_char,
                                                b" =\"'\0" as *const u8 as *const libc::c_char,
                                                &mut aid as *mut *mut libc::c_char,
                                            );
                                            if ptr as libc::c_ulong
                                                != 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                memset(
                                                    tmp.as_mut_ptr() as *mut libc::c_void,
                                                    '\u{0}' as i32,
                                                    4096 as libc::c_int as size_t,
                                                );
                                                strncpy(
                                                    tmp.as_mut_ptr(),
                                                    ptr as *const libc::c_char,
                                                    4095 as libc::c_int as size_t,
                                                );
                                            }
                                        }
                                        ptr = strtok_r(
                                            0 as *mut libc::c_void as *mut libc::c_char,
                                            b" =\0" as *const u8 as *const libc::c_char,
                                            &mut aid as *mut *mut libc::c_char,
                                        );
                                    }
                                } else {
                                    tmp___32 = strncasecmp(
                                        ptr as *const libc::c_char,
                                        b"background\0" as *const u8 as *const libc::c_char,
                                        10 as libc::c_int as size_t,
                                    );
                                    if tmp___32 == 0 as libc::c_int {
                                        ptr = strtok_r(
                                            0 as *mut libc::c_void as *mut libc::c_char,
                                            b" \"'\0" as *const u8 as *const libc::c_char,
                                            &mut aid as *mut *mut libc::c_char,
                                        );
                                        if ptr as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___31 = strmatch(
                                                b"body\0" as *const u8 as *const libc::c_char
                                                    as *mut libc::c_char,
                                                top,
                                            );
                                            if tmp___31 as u64 != 0 {
                                                memset(
                                                    tmp.as_mut_ptr() as *mut libc::c_void,
                                                    0 as libc::c_int,
                                                    4096 as libc::c_int as size_t,
                                                );
                                                strncpy(
                                                    tmp.as_mut_ptr(),
                                                    ptr as *const libc::c_char,
                                                    4095 as libc::c_int as size_t,
                                                );
                                                tmp___29 = url_normalize(base, tmp.as_mut_ptr());
                                                U___4 = tmp___29;
                                                if debug___0 as u64 != 0 {
                                                    tmp___30 = url_get_absolute(U___4);
                                                    printf(
                                                        b"6.) Adding: %s\n\0" as *const u8 as *const libc::c_char,
                                                        tmp___30,
                                                    );
                                                }
                                                __add_url(array, U___4);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        ptr = strtok_r(
            0 as *mut libc::c_void as *mut libc::c_char,
            b" =\0" as *const u8 as *const libc::c_char,
            &mut aid as *mut *mut libc::c_char,
        );
    }
}
unsafe extern "C" fn __strcasestr(
    mut s: *const libc::c_char,
    mut find: *const libc::c_char,
) -> *mut libc::c_char {
    let mut c: libc::c_char = 0;
    let mut sc: libc::c_char = 0;
    let mut len: size_t = 0;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut __res___0: libc::c_int = 0;
    let mut tmp___3: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    tmp___5 = find;
    find = find.offset(1);
    c = *tmp___5;
    if c as libc::c_int != 0 as libc::c_int {
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = tolower(c as libc::c_uchar as libc::c_int);
        } else {
            tmp___0 = __ctype_tolower_loc();
            __res = *(*tmp___0).offset(c as libc::c_uchar as libc::c_int as isize);
        }
        c = __res as libc::c_char;
        len = strlen(find);
        loop {
            loop {
                tmp___1 = s;
                s = s.offset(1);
                sc = *tmp___1;
                if sc as libc::c_int == 0 as libc::c_int {
                    return 0 as *mut libc::c_void as *mut libc::c_char;
                }
                if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                    > 1 as libc::c_ulong
                {
                    __res___0 = tolower(sc as libc::c_uchar as libc::c_int);
                } else {
                    tmp___3 = __ctype_tolower_loc();
                    __res___0 = *(*tmp___3)
                        .offset(sc as libc::c_uchar as libc::c_int as isize);
                }
                if !(__res___0 as libc::c_char as libc::c_int != c as libc::c_int) {
                    break;
                }
            }
            tmp___4 = strncasecmp(s, find, len);
            if !(tmp___4 != 0 as libc::c_int) {
                break;
            }
        }
        s = s.offset(-1);
    }
    return s as *mut libc::c_char;
}
unsafe extern "C" fn __xstrip(
    mut str: *const libc::c_char,
    mut pat: *const libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut tbl: [libc::c_int; 128] = [0; 128];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    i = 0 as libc::c_int;
    tbl[0 as libc::c_int as usize] = 0 as libc::c_int;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 128 as libc::c_uint) {
        tbl[tmp as usize] = 0 as libc::c_int;
        tmp = tmp.wrapping_add(1);
    }
    while *pat as libc::c_int != 0 as libc::c_int {
        tmp___0 = pat;
        pat = pat.offset(1);
        tbl[*tmp___0 as libc::c_int as usize] = 1 as libc::c_int;
    }
    tmp___1 = strlen(str);
    tmp___2 = xmalloc(tmp___1.wrapping_add(1 as libc::c_ulong));
    ret = tmp___2 as *mut libc::c_char;
    loop {
        if tbl[*str as libc::c_int as usize] == 0 {
            tmp___3 = i;
            i += 1;
            *ret.offset(tmp___3 as isize) = *str;
        }
        tmp___4 = str;
        str = str.offset(1);
        if !(*tmp___4 as libc::c_int != 0 as libc::c_int) {
            break;
        }
    }
    tmp___5 = xrealloc(ret as *mut libc::c_void, i as size_t);
    return tmp___5 as *mut libc::c_char;
}
pub unsafe extern "C" fn chomp(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    if *str != 0 {
        tmp___0 = strlen(str as *const libc::c_char);
        if *str.offset(tmp___0.wrapping_sub(1 as libc::c_ulong) as isize) as libc::c_int
            == 10 as libc::c_int
        {
            tmp = strlen(str as *const libc::c_char);
            *str
                .offset(
                    tmp.wrapping_sub(1 as libc::c_ulong) as isize,
                ) = 0 as libc::c_int as libc::c_char;
        }
    }
    return str;
}
pub unsafe extern "C" fn rtrim(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    ptr = str;
    while *ptr != 0 {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*ptr as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        ptr = ptr.offset(1);
    }
    tmp___0 = strlen(str as *const libc::c_char);
    len = tmp___0 as libc::c_int;
    ptr = str.offset(len as isize).offset(-(1 as libc::c_int as isize));
    while ptr as libc::c_ulong >= str as libc::c_ulong {
        tmp___1 = __ctype_b_loc();
        if *(*tmp___1).offset(*ptr as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        ptr = ptr.offset(-1);
    }
    *ptr.offset(1 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return str;
}
pub unsafe extern "C" fn ltrim(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: size_t = 0;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    ptr = str;
    while *ptr != 0 {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*ptr as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        ptr = ptr.offset(1);
    }
    tmp___0 = strlen(ptr as *const libc::c_char);
    len = tmp___0 as libc::c_int;
    memmove(
        str as *mut libc::c_void,
        ptr as *const libc::c_void,
        (len + 1 as libc::c_int) as size_t,
    );
    return str;
}
pub unsafe extern "C" fn trim(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    ptr = rtrim(str);
    str = ltrim(ptr);
    return str;
}
pub unsafe extern "C" fn valid(mut s: *const libc::c_char) -> libc::c_int {
    let mut flag: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    flag = 0 as libc::c_int;
    i = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i <= 255 as libc::c_int {
        if flag != 0 {
            tmp = 1 as libc::c_int;
        } else if *s.offset(i as isize) as libc::c_int == 0 as libc::c_int {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
        flag = tmp;
        i += 1;
    }
    if flag != 0 { return 1 as libc::c_int } else { return 0 as libc::c_int };
}
pub unsafe extern "C" fn empty(mut s: *const libc::c_char) -> BOOLEAN {
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    if s.is_null() {
        return boolean_true;
    }
    tmp = strlen(s);
    if tmp < 1 as libc::c_ulong {
        return boolean_true;
    }
    loop {
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*s as libc::c_uchar as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        s = s.offset(1);
    }
    return (*s as libc::c_int == 0 as libc::c_int) as libc::c_int as BOOLEAN;
}
pub unsafe extern "C" fn word_count(
    mut pattern: libc::c_char,
    mut s: *mut libc::c_char,
) -> libc::c_int {
    let mut in_word_flag: libc::c_int = 0;
    let mut count___0: libc::c_int = 0;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    in_word_flag = 0 as libc::c_int;
    count___0 = 0 as libc::c_int;
    ptr = s;
    while *ptr != 0 {
        if *ptr as libc::c_int != pattern as libc::c_int {
            if in_word_flag == 0 as libc::c_int {
                count___0 += 1;
            }
            in_word_flag = 1 as libc::c_int;
        } else {
            in_word_flag = 0 as libc::c_int;
        }
        ptr = ptr.offset(1);
    }
    return count___0;
}
pub unsafe extern "C" fn split(
    mut pattern: libc::c_char,
    mut s: *mut libc::c_char,
    mut n_words: *mut libc::c_int,
) -> *mut *mut libc::c_char {
    let mut words: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut str0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut str1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut len: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    *n_words = word_count(pattern, s);
    if *n_words == 0 as libc::c_int {
        return 0 as *mut libc::c_void as *mut *mut libc::c_char;
    }
    tmp = xmalloc(
        (*n_words as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
    );
    words = tmp as *mut *mut libc::c_char;
    if words.is_null() {
        return 0 as *mut libc::c_void as *mut *mut libc::c_char;
    }
    str0 = s;
    i = 0 as libc::c_int;
    while *str0 != 0 {
        str1 = strchr(str0 as *const libc::c_char, pattern as libc::c_int);
        if str1 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            len = str1.offset_from(str0) as libc::c_long as size_t;
        } else {
            len = strlen(str0 as *const libc::c_char);
        }
        if len == 0 as libc::c_ulong {
            i -= 1;
        } else {
            tmp___0 = xmalloc(4096 as libc::c_int as size_t);
            let ref mut fresh11 = *words.offset(i as isize);
            *fresh11 = tmp___0 as *mut libc::c_char;
            memset(
                *words.offset(i as isize) as *mut libc::c_void,
                '\u{0}' as i32,
                4096 as libc::c_int as size_t,
            );
            memcpy(
                *words.offset(i as isize) as *mut libc::c_void,
                str0 as *const libc::c_void,
                4096 as libc::c_int as size_t,
            );
            *(*words.offset(i as isize))
                .offset(len as isize) = '\u{0}' as i32 as libc::c_char;
        }
        if !(str1 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        str1 = str1.offset(1);
        str0 = str1;
        i += 1;
    }
    return words;
}
pub unsafe extern "C" fn split_free(
    mut split___0: *mut *mut libc::c_char,
    mut length: libc::c_int,
) {
    let mut x: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    x = 0 as libc::c_int;
    while x < length {
        if *split___0.offset(x as isize) as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp = *split___0.offset(x as isize);
            xfree(tmp as *mut libc::c_void);
        }
        x += 1;
    }
    free(split___0 as *mut libc::c_void);
}
pub static mut RESPONSESIZE: size_t = ::std::mem::size_of::<RESPONSE_T>()
    as libc::c_ulong;
pub unsafe extern "C" fn new_response() -> RESPONSE {
    let mut this: RESPONSE = 0 as *mut RESPONSE_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = xcalloc(RESPONSESIZE, 1 as libc::c_int as size_t);
    this = tmp as RESPONSE;
    (*this).headers = new_hash();
    (*this).auth.realm.www = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).auth.challenge.www = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).auth.realm.proxy = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).auth.challenge.www = 0 as *mut libc::c_void as *mut libc::c_char;
    return this;
}
pub unsafe extern "C" fn response_destroy(mut this: RESPONSE) -> RESPONSE {
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*this).headers = hash_destroy((*this).headers);
        xfree((*this).auth.realm.www as *mut libc::c_void);
        xfree((*this).auth.challenge.www as *mut libc::c_void);
        xfree((*this).auth.realm.proxy as *mut libc::c_void);
        xfree((*this).auth.challenge.proxy as *mut libc::c_void);
        xfree(this as *mut libc::c_void);
        this = 0 as *mut libc::c_void as RESPONSE;
    }
    return this;
}
pub unsafe extern "C" fn response_set_code(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut arr: [libc::c_char; 32] = [0; 32];
    let mut num: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = line;
    tmp___1 = strncasecmp(
        line as *const libc::c_char,
        b"http\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int as size_t,
    );
    if tmp___1 == 0 as libc::c_int {
        tmp___0 = atoi(tmp.offset(9 as libc::c_int as isize) as *const libc::c_char);
        num = tmp___0;
        if num > 1 as libc::c_int {
            memset(
                arr.as_mut_ptr() as *mut libc::c_void,
                '\u{0}' as i32,
                ::std::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            );
            strncpy(
                arr.as_mut_ptr(),
                line as *const libc::c_char,
                8 as libc::c_int as size_t,
            );
            hash_add(
                (*this).headers,
                b"protocol\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                arr.as_mut_ptr() as *mut libc::c_void,
            );
            hash_add(
                (*this).headers,
                b"response-code\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                line.offset(9 as libc::c_int as isize) as *mut libc::c_void,
            );
            return boolean_true;
        }
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_code(mut this: RESPONSE) -> libc::c_int {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_int = 0;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 418 as libc::c_int
    } else {
        if (*this).headers as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return 418 as libc::c_int
        } else {
            tmp = hash_get(
                (*this).headers,
                b"response-code\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            if tmp as *mut libc::c_char as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                return 418 as libc::c_int;
            }
        }
    }
    tmp___0 = hash_get(
        (*this).headers,
        b"response-code\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp___1 = atoi(tmp___0 as *mut libc::c_char as *const libc::c_char);
    return tmp___1;
}
pub unsafe extern "C" fn response_get_protocol(mut this: RESPONSE) -> *mut libc::c_char {
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp___2 = hash_get(
        (*this).headers,
        b"protocol\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if tmp___2 as *mut libc::c_char as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___1 = b"HTTP/1.1\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = hash_get(
            (*this).headers,
            b"protocol\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp___1 = tmp___0 as *mut libc::c_char as *const libc::c_char;
    }
    return tmp___1 as *mut libc::c_char;
}
pub unsafe extern "C" fn response_success(mut this: RESPONSE) -> libc::c_int {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut code: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = hash_get(
        (*this).headers,
        b"response-code\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if tmp as *mut libc::c_char as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        return 0 as libc::c_int;
    }
    tmp___0 = hash_get(
        (*this).headers,
        b"response-code\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp___1 = atoi(tmp___0 as *mut libc::c_char as *const libc::c_char);
    code = tmp___1;
    if code < 400 as libc::c_int {
        tmp___2 = 1 as libc::c_int;
    } else if code == 401 as libc::c_int {
        tmp___2 = 1 as libc::c_int;
    } else if code == 407 as libc::c_int {
        tmp___2 = 1 as libc::c_int;
    } else {
        tmp___2 = 0 as libc::c_int;
    }
    return tmp___2;
}
pub unsafe extern "C" fn response_failure(mut this: RESPONSE) -> libc::c_int {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut code: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = hash_get(
        (*this).headers,
        b"response-code\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if tmp as *mut libc::c_char as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        return 1 as libc::c_int;
    }
    tmp___0 = hash_get(
        (*this).headers,
        b"response-code\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    tmp___1 = atoi(tmp___0 as *mut libc::c_char as *const libc::c_char);
    code = tmp___1;
    if code >= 400 as libc::c_int {
        if code != 401 as libc::c_int {
            if code != 407 as libc::c_int {
                tmp___2 = 1 as libc::c_int;
            } else {
                tmp___2 = 0 as libc::c_int;
            }
        } else {
            tmp___2 = 0 as libc::c_int;
        }
    } else {
        tmp___2 = 0 as libc::c_int;
    }
    return tmp___2;
}
pub unsafe extern "C" fn response_set_from_cache(
    mut this: RESPONSE,
    mut cached: BOOLEAN,
) {
    (*this).cached = cached;
}
pub unsafe extern "C" fn response_get_from_cache(mut this: RESPONSE) -> BOOLEAN {
    return (*this).cached;
}
pub unsafe extern "C" fn response_set_content_type(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut type_0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut set: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aid: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: BOOLEAN = boolean_false;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    type_0 = 0 as *mut libc::c_void as *mut libc::c_char;
    set = 0 as *mut libc::c_void as *mut libc::c_char;
    aid = 0 as *mut libc::c_void as *mut libc::c_char;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    res = boolean_false;
    tmp___2 = strstr(
        line as *const libc::c_char,
        b";\0" as *const u8 as *const libc::c_char,
    );
    if tmp___2 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = strlen(b"content-type\0" as *const u8 as *const libc::c_char);
        ptr = line.offset(tmp.wrapping_add(2 as libc::c_ulong) as isize);
        type_0 = strtok_r(
            ptr,
            b";\0" as *const u8 as *const libc::c_char,
            &mut aid as *mut *mut libc::c_char,
        );
        if type_0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            hash_add(
                (*this).headers,
                b"content-type\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                type_0 as *mut libc::c_void,
            );
            res = boolean_true;
        }
        set = stristr(
            aid as *const libc::c_char,
            b"charset=\0" as *const u8 as *const libc::c_char,
        );
        if !set.is_null() {
            tmp___0 = strlen(set as *const libc::c_char);
            if tmp___0 > 8 as libc::c_ulong {
                hash_add(
                    (*this).headers,
                    b"charset\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    set.offset(8 as libc::c_int as isize) as *mut libc::c_void,
                );
            }
        }
    } else {
        tmp___1 = strlen(b"content-type\0" as *const u8 as *const libc::c_char);
        hash_add(
            (*this).headers,
            b"content-type\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            line.offset(tmp___1.wrapping_add(2 as libc::c_ulong) as isize)
                as *mut libc::c_void,
        );
        res = boolean_true;
    }
    return res;
}
pub unsafe extern "C" fn response_get_content_type(
    mut this: RESPONSE,
) -> *mut libc::c_char {
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp___2 = hash_get(
        (*this).headers,
        b"content-type\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if tmp___2 as *mut libc::c_char as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___1 = b"unknown\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = hash_get(
            (*this).headers,
            b"content-type\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp___1 = tmp___0 as *mut libc::c_char as *const libc::c_char;
    }
    return tmp___1 as *mut libc::c_char;
}
pub unsafe extern "C" fn response_get_charset(mut this: RESPONSE) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = hash_get(
        (*this).headers,
        b"charset\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if tmp as *mut libc::c_char as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        hash_add(
            (*this).headers,
            b"charset\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"iso-8859-1\0" as *const u8 as *const libc::c_char as *mut libc::c_void,
        );
    }
    tmp___0 = hash_get(
        (*this).headers,
        b"charset\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    return tmp___0 as *mut libc::c_char;
}
pub unsafe extern "C" fn response_set_content_length(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut num: libc::c_int = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: libc::c_int = 0;
    tmp = line;
    tmp___3 = strlen(b"content-length\0" as *const u8 as *const libc::c_char);
    tmp___4 = strncasecmp(
        line as *const libc::c_char,
        b"content-length\0" as *const u8 as *const libc::c_char,
        tmp___3,
    );
    if tmp___4 == 0 as libc::c_int {
        tmp___0 = strlen(b"content-length\0" as *const u8 as *const libc::c_char);
        tmp___1 = atoi(
            tmp.offset(tmp___0.wrapping_add(2 as libc::c_ulong) as isize)
                as *const libc::c_char,
        );
        num = tmp___1;
        if num > 1 as libc::c_int {
            tmp___2 = strlen(b"content-length\0" as *const u8 as *const libc::c_char);
            hash_add(
                (*this).headers,
                b"content-length\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                line.offset(tmp___2.wrapping_add(2 as libc::c_ulong) as isize)
                    as *mut libc::c_void,
            );
            return boolean_true;
        }
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_content_length(mut this: RESPONSE) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __int_value(
        this,
        b"content-length\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        0 as libc::c_int,
    );
    return tmp;
}
pub unsafe extern "C" fn response_set_content_encoding(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: [libc::c_char; 128] = [0; 128];
    let mut tmp___0: size_t = 0;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: libc::c_int = 0;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___3 = strlen(b"content-encoding\0" as *const u8 as *const libc::c_char);
    tmp___4 = strncasecmp(
        line as *const libc::c_char,
        b"content-encoding\0" as *const u8 as *const libc::c_char,
        tmp___3,
    );
    if tmp___4 == 0 as libc::c_int {
        memset(
            tmp.as_mut_ptr() as *mut libc::c_void,
            '\u{0}' as i32,
            ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        );
        tmp___0 = strlen(b"content-encoding\0" as *const u8 as *const libc::c_char);
        ptr = line.offset(tmp___0.wrapping_add(2 as libc::c_ulong) as isize);
        tmp___1 = strmatch(
            ptr,
            b"gzip\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___1 as u64 != 0 {
            snprintf(
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int,
            );
            hash_add(
                (*this).headers,
                b"content-encoding\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                tmp.as_mut_ptr() as *mut libc::c_void,
            );
            return boolean_true;
        }
        tmp___2 = strmatch(
            ptr,
            b"deflate\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___2 as u64 != 0 {
            snprintf(
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
            hash_add(
                (*this).headers,
                b"content-encoding\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                tmp.as_mut_ptr() as *mut libc::c_void,
            );
            return boolean_true;
        }
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_content_encoding(mut this: RESPONSE) -> HTTP_CE {
    let mut tmp: libc::c_int = 0;
    tmp = __int_value(
        this,
        b"content-encoding\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        0 as libc::c_int,
    );
    return tmp as HTTP_CE;
}
pub unsafe extern "C" fn response_set_transfer_encoding(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: [libc::c_char; 128] = [0; 128];
    let mut tmp___0: size_t = 0;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: BOOLEAN = boolean_false;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: libc::c_int = 0;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___3 = strlen(b"transfer-encoding\0" as *const u8 as *const libc::c_char);
    tmp___4 = strncasecmp(
        line as *const libc::c_char,
        b"transfer-encoding\0" as *const u8 as *const libc::c_char,
        tmp___3,
    );
    if tmp___4 == 0 as libc::c_int {
        memset(
            tmp.as_mut_ptr() as *mut libc::c_void,
            '\u{0}' as i32,
            ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        );
        tmp___0 = strlen(b"transfer-encoding\0" as *const u8 as *const libc::c_char);
        ptr = line.offset(tmp___0.wrapping_add(2 as libc::c_ulong) as isize);
        ptr = trim(ptr);
        tmp___2 = strmatch(
            ptr,
            b"chunked\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___2 as u64 != 0 {
            snprintf(
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
        } else {
            tmp___1 = strmatch(
                ptr,
                b"trailer\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if tmp___1 as u64 != 0 {
                snprintf(
                    tmp.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                    b"%d\0" as *const u8 as *const libc::c_char,
                    4 as libc::c_int,
                );
            } else {
                snprintf(
                    tmp.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                    b"%d\0" as *const u8 as *const libc::c_char,
                    1 as libc::c_int,
                );
            }
        }
        hash_add(
            (*this).headers,
            b"transfer-encoding\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            tmp.as_mut_ptr() as *mut libc::c_void,
        );
        return boolean_true;
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_transfer_encoding(mut this: RESPONSE) -> HTTP_TE {
    let mut tmp: libc::c_int = 0;
    tmp = __int_value(
        this,
        b"transfer-encoding\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        1 as libc::c_int,
    );
    return tmp as HTTP_TE;
}
pub unsafe extern "C" fn response_set_location(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut len: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: BOOLEAN = boolean_false;
    len = 0 as libc::c_int;
    tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___2 = strlen(b"location\0" as *const u8 as *const libc::c_char);
    tmp___3 = strncasecmp(
        line as *const libc::c_char,
        b"location\0" as *const u8 as *const libc::c_char,
        tmp___2,
    );
    if tmp___3 == 0 as libc::c_int {
        tmp___0 = strlen(line as *const libc::c_char);
        len = tmp___0 as libc::c_int;
        tmp___1 = xmalloc(len as size_t);
        tmp = tmp___1 as *mut libc::c_char;
        memset(tmp as *mut libc::c_void, '\u{0}' as i32, len as size_t);
        memmove(
            tmp as *mut libc::c_void,
            line.offset(10 as libc::c_int as isize) as *const libc::c_void,
            (len - 9 as libc::c_int) as size_t,
        );
        *tmp.offset((len - 10 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
        hash_add(
            (*this).headers,
            b"location\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tmp as *mut libc::c_void,
        );
        hash_add(
            (*this).headers,
            b"redirect\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"true\0" as *const u8 as *const libc::c_char as *mut libc::c_void,
        );
        xfree(tmp as *mut libc::c_void);
    }
    tmp___6 = strlen(b"content-location\0" as *const u8 as *const libc::c_char);
    tmp___7 = strncasecmp(
        line as *const libc::c_char,
        b"content-location\0" as *const u8 as *const libc::c_char,
        tmp___6,
    );
    if tmp___7 == 0 as libc::c_int {
        tmp___4 = strlen(line as *const libc::c_char);
        len = tmp___4 as libc::c_int;
        tmp___5 = xmalloc(len as size_t);
        tmp = tmp___5 as *mut libc::c_char;
        memset(tmp as *mut libc::c_void, '\u{0}' as i32, len as size_t);
        memmove(
            tmp as *mut libc::c_void,
            line.offset(18 as libc::c_int as isize) as *const libc::c_void,
            (len - 17 as libc::c_int) as size_t,
        );
        *tmp.offset((len - 18 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
        hash_add(
            (*this).headers,
            b"location\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tmp as *mut libc::c_void,
        );
        hash_add(
            (*this).headers,
            b"redirect\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"true\0" as *const u8 as *const libc::c_char as *mut libc::c_void,
        );
        xfree(tmp as *mut libc::c_void);
    }
    tmp___8 = __boolean_value(
        this,
        b"redirect\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        boolean_false,
    );
    return tmp___8;
}
pub unsafe extern "C" fn response_get_location(mut this: RESPONSE) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = hash_get(
        (*this).headers,
        b"location\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    return tmp as *mut libc::c_char;
}
pub unsafe extern "C" fn response_get_redirect(mut this: RESPONSE) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    tmp = __boolean_value(
        this,
        b"redirect\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        boolean_false,
    );
    return tmp;
}
pub unsafe extern "C" fn response_set_connection(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: [libc::c_char; 128] = [0; 128];
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp___1 = strlen(b"connection\0" as *const u8 as *const libc::c_char);
    tmp___2 = strncasecmp(
        line as *const libc::c_char,
        b"connection\0" as *const u8 as *const libc::c_char,
        tmp___1,
    );
    if tmp___2 == 0 as libc::c_int {
        memset(
            tmp.as_mut_ptr() as *mut libc::c_void,
            '\u{0}' as i32,
            128 as libc::c_int as size_t,
        );
        tmp___0 = strncasecmp(
            line.offset(12 as libc::c_int as isize) as *const libc::c_char,
            b"keep-alive\0" as *const u8 as *const libc::c_char,
            10 as libc::c_int as size_t,
        );
        if tmp___0 == 0 as libc::c_int {
            snprintf(
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
        } else {
            snprintf(
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
            );
        }
        hash_add(
            (*this).headers,
            b"connection\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tmp.as_mut_ptr() as *mut libc::c_void,
        );
        return boolean_true;
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_connection(mut this: RESPONSE) -> HTTP_CONN {
    let mut tmp: libc::c_int = 0;
    tmp = __int_value(
        this,
        b"connection\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        1 as libc::c_int,
    );
    return tmp as HTTP_CONN;
}
pub unsafe extern "C" fn response_set_keepalive(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut option: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut newline: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: BOOLEAN = boolean_false;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut num: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut num___0: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    tmp = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    option = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    value = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    newline = line;
    res = boolean_false;
    loop {
        tmp = __parse_pair___0(&mut newline);
        if !(tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        option = tmp;
        while *tmp != 0 {
            tmp___0 = __ctype_b_loc();
            if *(*tmp___0)
                .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & 8192 as libc::c_int != 0
            {
                break;
            }
            if 61 as libc::c_int == *tmp as libc::c_int {
                break;
            }
            if 58 as libc::c_int == *tmp as libc::c_int {
                break;
            }
            tmp = tmp.offset(1);
        }
        tmp___1 = tmp;
        tmp = tmp.offset(1);
        *tmp___1 = 0 as libc::c_int as libc::c_char;
        loop {
            tmp___2 = __ctype_b_loc();
            if *(*tmp___2)
                .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & 8192 as libc::c_int == 0
            {
                if !(61 as libc::c_int == *tmp as libc::c_int) {
                    if !(58 as libc::c_int == *tmp as libc::c_int) {
                        break;
                    }
                }
            }
            tmp = tmp.offset(1);
        }
        value = tmp;
        while *tmp != 0 {
            tmp = tmp.offset(1);
        }
        tmp___4 = strncasecmp(
            option as *const libc::c_char,
            b"timeout\0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as size_t,
        );
        if tmp___4 == 0 {
            if value as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                hash_add(
                    (*this).headers,
                    b"keepalive-timeout\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"15\0" as *const u8 as *const libc::c_char as *mut libc::c_void,
                );
            } else {
                tmp___3 = atoi(value as *const libc::c_char);
                num = tmp___3;
                if num > 0 as libc::c_int {
                    hash_add(
                        (*this).headers,
                        b"keepalive-timeout\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        value as *mut libc::c_void,
                    );
                }
            }
            res = boolean_true;
        }
        tmp___6 = strncasecmp(
            option as *const libc::c_char,
            b"max\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int as size_t,
        );
        if tmp___6 == 0 {
            if value as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                hash_add(
                    (*this).headers,
                    b"keepalive-max\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"15\0" as *const u8 as *const libc::c_char as *mut libc::c_void,
                );
            } else {
                tmp___5 = atoi(value as *const libc::c_char);
                num___0 = tmp___5;
                if num___0 > 0 as libc::c_int {
                    hash_add(
                        (*this).headers,
                        b"keepalive-max\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        value as *mut libc::c_void,
                    );
                }
            }
            res = boolean_true;
        }
    }
    return res;
}
pub unsafe extern "C" fn response_get_keepalive_timeout(
    mut this: RESPONSE,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __int_value(
        this,
        b"keepalive-timeout\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        15 as libc::c_int,
    );
    return tmp;
}
pub unsafe extern "C" fn response_get_keepalive_max(mut this: RESPONSE) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __int_value(
        this,
        b"keepalive-max\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        5 as libc::c_int,
    );
    return tmp;
}
pub unsafe extern "C" fn response_set_last_modified(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut len: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    len = 0 as libc::c_int;
    tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___2 = strlen(b"last-modified\0" as *const u8 as *const libc::c_char);
    tmp___3 = strncasecmp(
        line as *const libc::c_char,
        b"last-modified\0" as *const u8 as *const libc::c_char,
        tmp___2,
    );
    if tmp___3 == 0 as libc::c_int {
        tmp___0 = strlen(line as *const libc::c_char);
        len = tmp___0 as libc::c_int;
        tmp___1 = xmalloc(len as size_t);
        tmp = tmp___1 as *mut libc::c_char;
        memset(tmp as *mut libc::c_void, '\u{0}' as i32, len as size_t);
        memcpy(
            tmp as *mut libc::c_void,
            line.offset(15 as libc::c_int as isize) as *const libc::c_void,
            (len - 14 as libc::c_int) as size_t,
        );
        *tmp.offset((len - 15 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
        hash_add(
            (*this).headers,
            b"last-modified\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tmp as *mut libc::c_void,
        );
        xfree(tmp as *mut libc::c_void);
        return boolean_true;
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_last_modified(
    mut this: RESPONSE,
) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = hash_get(
        (*this).headers,
        b"last-modified\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    return tmp as *mut libc::c_char;
}
pub unsafe extern "C" fn response_set_etag(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut len: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: libc::c_int = 0;
    len = 0 as libc::c_int;
    tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___3 = strlen(b"etag\0" as *const u8 as *const libc::c_char);
    tmp___4 = strncasecmp(
        line as *const libc::c_char,
        b"etag\0" as *const u8 as *const libc::c_char,
        tmp___3,
    );
    if tmp___4 == 0 as libc::c_int {
        tmp___0 = strlen(line as *const libc::c_char);
        len = tmp___0 as libc::c_int;
        tmp___1 = xmalloc(len as size_t);
        tmp = tmp___1 as *mut libc::c_char;
        memset(tmp as *mut libc::c_void, '\u{0}' as i32, len as size_t);
        memcpy(
            tmp as *mut libc::c_void,
            line.offset(6 as libc::c_int as isize) as *const libc::c_void,
            (len - 5 as libc::c_int) as size_t,
        );
        *tmp.offset((len - 6 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
        tmp___2 = __dequote(tmp);
        hash_add(
            (*this).headers,
            b"etag\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tmp___2 as *mut libc::c_void,
        );
        xfree(tmp as *mut libc::c_void);
        return boolean_true;
    }
    return boolean_false;
}
pub unsafe extern "C" fn response_get_etag(mut this: RESPONSE) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = hash_get(
        (*this).headers,
        b"etag\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    return tmp as *mut libc::c_char;
}
pub unsafe extern "C" fn response_set_www_authenticate(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut option: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut newline: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: libc::c_int = 0;
    tmp = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    option = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    value = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    newline = line;
    tmp___7 = strlen(b"www-authenticate\0" as *const u8 as *const libc::c_char);
    tmp___8 = strncasecmp(
        line as *const libc::c_char,
        b"www-authenticate\0" as *const u8 as *const libc::c_char,
        tmp___7,
    );
    if tmp___8 == 0 as libc::c_int {
        tmp___1 = strncasecmp(
            line.offset(18 as libc::c_int as isize) as *const libc::c_char,
            b"digest\0" as *const u8 as *const libc::c_char,
            6 as libc::c_int as size_t,
        );
        if tmp___1 == 0 as libc::c_int {
            newline = newline.offset(24 as libc::c_int as isize);
            (*this).auth.type_0.www = DIGEST;
            (*this)
                .auth
                .challenge
                .www = xstrdup(
                line.offset(18 as libc::c_int as isize) as *const libc::c_char,
            );
        } else {
            tmp___0 = strncasecmp(
                line.offset(18 as libc::c_int as isize) as *const libc::c_char,
                b"ntlm\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as size_t,
            );
            if tmp___0 == 0 as libc::c_int {
                newline = newline.offset(22 as libc::c_int as isize);
                (*this).auth.type_0.www = NTLM;
                (*this)
                    .auth
                    .challenge
                    .www = xstrdup(
                    line.offset(18 as libc::c_int as isize) as *const libc::c_char,
                );
            } else if (*this).auth.type_0.www as libc::c_uint != 1 as libc::c_uint {
                if (*this).auth.type_0.www as libc::c_uint != 2 as libc::c_uint {
                    newline = newline.offset(23 as libc::c_int as isize);
                    (*this).auth.type_0.www = BASIC;
                }
            }
        }
        loop {
            tmp = __parse_pair___0(&mut newline);
            if !(tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                break;
            }
            option = tmp;
            while *tmp != 0 {
                tmp___2 = __ctype_b_loc();
                if *(*tmp___2)
                    .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int & 8192 as libc::c_int != 0
                {
                    break;
                }
                if 61 as libc::c_int == *tmp as libc::c_int {
                    break;
                }
                if 58 as libc::c_int == *tmp as libc::c_int {
                    break;
                }
                tmp = tmp.offset(1);
            }
            tmp___3 = tmp;
            tmp = tmp.offset(1);
            *tmp___3 = '\u{0}' as i32 as libc::c_char;
            loop {
                tmp___4 = __ctype_b_loc();
                if *(*tmp___4)
                    .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int & 8192 as libc::c_int == 0
                {
                    if !(61 as libc::c_int == *tmp as libc::c_int) {
                        if !(58 as libc::c_int == *tmp as libc::c_int) {
                            break;
                        }
                    }
                }
                tmp = tmp.offset(1);
            }
            value = tmp;
            while *tmp != 0 {
                tmp = tmp.offset(1);
            }
            tmp___6 = strncasecmp(
                option as *const libc::c_char,
                b"realm\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int as size_t,
            );
            if tmp___6 == 0 {
                if value as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___5 = __dequote(value);
                    (*this).auth.realm.www = xstrdup(tmp___5 as *const libc::c_char);
                } else {
                    (*this)
                        .auth
                        .realm
                        .www = xstrdup(b"\0" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    return boolean_true;
}
pub unsafe extern "C" fn response_get_www_auth_type(mut this: RESPONSE) -> TYPE {
    return (*this).auth.type_0.www;
}
pub unsafe extern "C" fn response_get_www_auth_challenge(
    mut this: RESPONSE,
) -> *mut libc::c_char {
    return (*this).auth.challenge.www;
}
pub unsafe extern "C" fn response_get_www_auth_realm(
    mut this: RESPONSE,
) -> *mut libc::c_char {
    return (*this).auth.realm.www;
}
pub unsafe extern "C" fn response_set_proxy_authenticate(
    mut this: RESPONSE,
    mut line: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut option: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut newline: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: libc::c_int = 0;
    tmp = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    option = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    value = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    newline = line;
    tmp___6 = strlen(b"proxy-authenticate\0" as *const u8 as *const libc::c_char);
    tmp___7 = strncasecmp(
        line as *const libc::c_char,
        b"proxy-authenticate\0" as *const u8 as *const libc::c_char,
        tmp___6,
    );
    if tmp___7 == 0 as libc::c_int {
        tmp___0 = strncasecmp(
            line.offset(20 as libc::c_int as isize) as *const libc::c_char,
            b"digest\0" as *const u8 as *const libc::c_char,
            6 as libc::c_int as size_t,
        );
        if tmp___0 == 0 as libc::c_int {
            newline = newline.offset(26 as libc::c_int as isize);
            (*this).auth.type_0.proxy = DIGEST;
            (*this)
                .auth
                .challenge
                .proxy = xstrdup(
                line.offset(20 as libc::c_int as isize) as *const libc::c_char,
            );
        } else {
            newline = newline.offset(25 as libc::c_int as isize);
            (*this).auth.type_0.proxy = BASIC;
        }
        loop {
            tmp = __parse_pair___0(&mut newline);
            if !(tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                break;
            }
            option = tmp;
            while *tmp != 0 {
                tmp___1 = __ctype_b_loc();
                if *(*tmp___1)
                    .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int & 8192 as libc::c_int != 0
                {
                    break;
                }
                if 61 as libc::c_int == *tmp as libc::c_int {
                    break;
                }
                if 58 as libc::c_int == *tmp as libc::c_int {
                    break;
                }
                tmp = tmp.offset(1);
            }
            tmp___2 = tmp;
            tmp = tmp.offset(1);
            *tmp___2 = '\u{0}' as i32 as libc::c_char;
            loop {
                tmp___3 = __ctype_b_loc();
                if *(*tmp___3)
                    .offset(*tmp as libc::c_int as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int & 8192 as libc::c_int == 0
                {
                    if !(61 as libc::c_int == *tmp as libc::c_int) {
                        if !(58 as libc::c_int == *tmp as libc::c_int) {
                            break;
                        }
                    }
                }
                tmp = tmp.offset(1);
            }
            value = tmp;
            while *tmp != 0 {
                tmp = tmp.offset(1);
            }
            tmp___5 = strncasecmp(
                option as *const libc::c_char,
                b"realm\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int as size_t,
            );
            if tmp___5 == 0 {
                if value as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___4 = __dequote(value);
                    (*this).auth.realm.proxy = xstrdup(tmp___4 as *const libc::c_char);
                } else {
                    (*this)
                        .auth
                        .realm
                        .proxy = xstrdup(b"\0" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    return boolean_true;
}
pub unsafe extern "C" fn response_get_proxy_auth_type(mut this: RESPONSE) -> TYPE {
    return (*this).auth.type_0.proxy;
}
pub unsafe extern "C" fn response_get_proxy_auth_challenge(
    mut this: RESPONSE,
) -> *mut libc::c_char {
    return (*this).auth.challenge.proxy;
}
pub unsafe extern "C" fn response_get_proxy_auth_realm(
    mut this: RESPONSE,
) -> *mut libc::c_char {
    return (*this).auth.realm.proxy;
}
unsafe extern "C" fn __int_value(
    mut this: RESPONSE,
    mut key: *mut libc::c_char,
    mut def: libc::c_int,
) -> libc::c_int {
    let mut num: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_int = 0;
    num = -(1 as libc::c_int);
    tmp___0 = hash_get((*this).headers, key);
    if tmp___0 as *mut libc::c_char as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp = hash_get((*this).headers, key);
        num = atoi(tmp as *mut libc::c_char as *const libc::c_char);
    }
    if num > 0 as libc::c_int {
        tmp___1 = num;
    } else {
        tmp___1 = def;
    }
    return tmp___1;
}
unsafe extern "C" fn __boolean_value(
    mut this: RESPONSE,
    mut key: *mut libc::c_char,
    mut def: BOOLEAN,
) -> BOOLEAN {
    let mut res: BOOLEAN = boolean_false;
    let mut b: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: BOOLEAN = boolean_false;
    res = def;
    tmp = hash_get((*this).headers, key);
    b = tmp as *mut libc::c_char;
    if b as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        res = def;
    } else {
        tmp___1 = strmatch(
            b,
            b"true\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if tmp___1 as u64 != 0 {
            res = boolean_true;
        } else {
            tmp___0 = strmatch(
                b,
                b"false\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if tmp___0 as u64 != 0 {
                res = boolean_false;
            } else {
                res = def;
            }
        }
    }
    return res;
}
unsafe extern "C" fn __parse_pair___0(
    mut str: *mut *mut libc::c_char,
) -> *mut libc::c_char {
    let mut okay___0: libc::c_int = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pair: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    okay___0 = 0 as libc::c_int;
    p = *str;
    pair = 0 as *mut libc::c_void as *mut libc::c_char;
    if str.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char
    } else {
        if (*str).is_null() {
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    while *p != 0 {
        if !(*p as libc::c_int != 32 as libc::c_int) {
            break;
        }
        p = p.offset(1);
    }
    tmp = p;
    p = p.offset(1);
    *tmp = 0 as libc::c_int as libc::c_char;
    if *p == 0 {
        *str = p;
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    pair = p;
    while *p != 0 {
        if !(*p as libc::c_int != 59 as libc::c_int) {
            break;
        }
        if !(*p as libc::c_int != 44 as libc::c_int) {
            break;
        }
        if *p == 0 {
            *str = p;
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if *p as libc::c_int == 61 as libc::c_int {
            okay___0 = 1 as libc::c_int;
        }
        p = p.offset(1);
    }
    tmp___0 = p;
    p = p.offset(1);
    *tmp___0 = 0 as libc::c_int as libc::c_char;
    *str = p;
    if okay___0 != 0 {
        tmp___1 = pair;
    } else {
        tmp___1 = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    return tmp___1;
}
unsafe extern "C" fn __rquote(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut tmp: size_t = 0;
    tmp = strlen(str as *const libc::c_char);
    len = tmp as libc::c_int;
    ptr = str.offset(len as isize).offset(-(1 as libc::c_int as isize));
    while ptr as libc::c_ulong >= str as libc::c_ulong {
        if !(*ptr as libc::c_int == 34 as libc::c_int) {
            if !(*ptr as libc::c_int == 39 as libc::c_int) {
                break;
            }
        }
        ptr = ptr.offset(-1);
    }
    *ptr.offset(1 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return str;
}
unsafe extern "C" fn __lquote(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut tmp: size_t = 0;
    ptr = str;
    while *ptr != 0 {
        if !(*ptr as libc::c_int == 34 as libc::c_int) {
            if !(*ptr as libc::c_int == 39 as libc::c_int) {
                break;
            }
        }
        ptr = ptr.offset(1);
    }
    tmp = strlen(ptr as *const libc::c_char);
    len = tmp as libc::c_int;
    memmove(
        str as *mut libc::c_void,
        ptr as *const libc::c_void,
        (len + 1 as libc::c_int) as size_t,
    );
    return str;
}
unsafe extern "C" fn __dequote(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    ptr = __rquote(str);
    str = __lquote(ptr);
    return str;
}
pub unsafe extern "C" fn new_socket(
    mut C: *mut CONN,
    mut hostparam: *const libc::c_char,
    mut portparam: libc::c_int,
) -> libc::c_int {
    let mut conn: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut addrlen: libc::c_int = 0;
    let mut s_addr: *mut sockaddr = 0 as *mut sockaddr;
    let mut hn: [libc::c_char; 512] = [0; 512];
    let mut port: libc::c_int = 0;
    let mut domain: libc::c_int = 0;
    let mut port_str: [libc::c_char; 10] = [0; 10];
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut addr_res: *mut addrinfo = 0 as *mut addrinfo;
    let mut r: *mut addrinfo = 0 as *mut addrinfo;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___6: pthread_t = 0;
    let mut tmp___7: pthread_t = 0;
    let mut tmp___8: pthread_t = 0;
    let mut tmp___9: pthread_t = 0;
    let mut tmp___10: pthread_t = 0;
    let mut tmp___11: pthread_t = 0;
    let mut tmp___12: pthread_t = 0;
    let mut tmp___13: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___14: BOOLEAN = boolean_false;
    let mut tmp___15: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___16: libc::c_int = 0;
    if hostparam as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        NOTIFY(
            ERROR,
            b"Unable to resolve host %s:%d\0" as *const u8 as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            118 as libc::c_int,
        );
        return -(1 as libc::c_int);
    }
    if (*C).scheme as libc::c_uint == 2 as libc::c_uint {
        (*C).encrypt = boolean_true;
    } else {
        (*C).encrypt = boolean_false;
    }
    (*C).state = UNDEF;
    (*C).ftp.pasv = boolean_true;
    (*C).ftp.size = 0 as libc::c_int as size_t;
    memset(
        hn.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
    );
    tmp___0 = auth_get_proxy_required(my.auth);
    if tmp___0 as u64 != 0 {
        tmp = auth_get_proxy_host(my.auth);
        snprintf(
            hn.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            tmp,
        );
        port = auth_get_proxy_port(my.auth);
    } else {
        snprintf(
            hn.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            hostparam,
        );
        port = portparam;
    }
    __hostname_strip(hn.as_mut_ptr(), 512 as libc::c_int);
    if port < 1 as libc::c_int {
        NOTIFY(
            ERROR,
            b"invalid port number %d in %s:%d\0" as *const u8 as *const libc::c_char,
            port,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            142 as libc::c_int,
        );
        return -(1 as libc::c_int);
    } else {
        if port > 65535 as libc::c_int {
            NOTIFY(
                ERROR,
                b"invalid port number %d in %s:%d\0" as *const u8 as *const libc::c_char,
                port,
                b"sock.c\0" as *const u8 as *const libc::c_char,
                142 as libc::c_int,
            );
            return -(1 as libc::c_int);
        }
    }
    snprintf(
        port_str.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong,
        b"%d\0" as *const u8 as *const libc::c_char,
        port,
    );
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_family = 0 as libc::c_int;
    hints.ai_socktype = 1 as libc::c_int;
    hints.ai_protocol = 6 as libc::c_int;
    res = getaddrinfo(
        hn.as_mut_ptr() as *const libc::c_char,
        port_str.as_mut_ptr() as *const libc::c_char,
        &mut hints as *mut addrinfo as *const addrinfo,
        &mut addr_res as *mut *mut addrinfo,
    );
    if res != 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"Address resolution failed at %s:%d with the following error:\0"
                as *const u8 as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            158 as libc::c_int,
        );
        tmp___1 = gai_strerror(res);
        NOTIFY(ERROR, b"%s\0" as *const u8 as *const libc::c_char, tmp___1);
        return -(1 as libc::c_int);
    }
    s_addr = (*addr_res).ai_addr;
    addrlen = (*addr_res).ai_addrlen as libc::c_int;
    domain = (*addr_res).ai_family;
    tmp___2 = __socket_create(C, domain);
    if tmp___2 < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    conn = connect((*C).sock, s_addr as *const sockaddr, addrlen as socklen_t);
    pthread_testcancel();
    if conn < 0 as libc::c_int {
        tmp___4 = __errno_location();
        if *tmp___4 != 115 as libc::c_int {
            addr_res = (*addr_res).ai_next;
            r = addr_res;
            while !r.is_null() {
                socket_close(C);
                tmp___3 = __socket_create(C, domain);
                if tmp___3 < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                conn = connect(
                    (*C).sock,
                    s_addr as *const sockaddr,
                    addrlen as socklen_t,
                );
                pthread_testcancel();
                if conn == 0 as libc::c_int {
                    break;
                }
                r = (*r).ai_next;
            }
        }
    }
    if conn < 0 as libc::c_int {
        tmp___15 = __errno_location();
        if *tmp___15 != 115 as libc::c_int {
            tmp___5 = __errno_location();
            match *tmp___5 {
                13 => {
                    tmp___6 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d EACCES\0" as *const u8 as *const libc::c_char,
                        tmp___6,
                    );
                }
                99 => {
                    tmp___7 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d address is unavailable.\0" as *const u8
                            as *const libc::c_char,
                        tmp___7,
                    );
                }
                110 => {
                    tmp___8 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d connection timed out.\0" as *const u8
                            as *const libc::c_char,
                        tmp___8,
                    );
                }
                111 => {
                    tmp___9 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d connection refused.\0" as *const u8
                            as *const libc::c_char,
                        tmp___9,
                    );
                }
                101 => {
                    tmp___10 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d network is unreachable.\0" as *const u8
                            as *const libc::c_char,
                        tmp___10,
                    );
                }
                106 => {
                    tmp___11 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d already connected.\0" as *const u8
                            as *const libc::c_char,
                        tmp___11,
                    );
                }
                _ => {
                    tmp___12 = pthread_self();
                    NOTIFY(
                        ERROR,
                        b"socket: %d unknown network error.\0" as *const u8
                            as *const libc::c_char,
                        tmp___12,
                    );
                }
            }
            socket_close(C);
            return -(1 as libc::c_int);
        }
    }
    tmp___14 = __socket_check(C, READ);
    if tmp___14 as libc::c_uint == 0 as libc::c_uint {
        pthread_testcancel();
        NOTIFY(
            WARNING,
            b"socket: read check timed out(%d) %s:%d\0" as *const u8
                as *const libc::c_char,
            my.timeout,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            273 as libc::c_int,
        );
        socket_close(C);
        return -(1 as libc::c_int);
    } else {
        res = connect((*C).sock, s_addr as *const sockaddr, addrlen as socklen_t);
        if res < 0 as libc::c_int {
            tmp___13 = __errno_location();
            if *tmp___13 != 106 as libc::c_int {
                NOTIFY(
                    ERROR,
                    b"socket: unable to connect %s:%d\0" as *const u8
                        as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    282 as libc::c_int,
                );
                socket_close(C);
                return -(1 as libc::c_int);
            }
        }
        (*C).status = S_READING;
    }
    tmp___16 = __socket_block((*C).sock, boolean_true);
    if tmp___16 < 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"socket: unable to set socket to non-blocking %s:%d\0" as *const u8
                as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            291 as libc::c_int,
        );
        return -(1 as libc::c_int);
    }
    (*C).connection.status = 1 as libc::c_int;
    return (*C).sock;
}
unsafe extern "C" fn __socket_check(mut C: *mut CONN, mut mode: SDSET) -> BOOLEAN {
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: BOOLEAN = boolean_false;
    if (*C).sock >= 1024 as libc::c_int {
        tmp = __socket_poll(C, mode);
        return tmp;
    } else {
        tmp___0 = __socket_select(C, mode);
        return tmp___0;
    };
}
unsafe extern "C" fn __socket_poll(mut C: *mut CONN, mut mode: SDSET) -> BOOLEAN {
    let mut res: libc::c_int = 0;
    let mut timo: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___1: libc::c_int = 0;
    if my.timeout != 0 {
        tmp = my.timeout * 1000 as libc::c_int;
    } else {
        tmp = 15000 as libc::c_int;
    }
    timo = tmp;
    __socket_block((*C).sock, boolean_false);
    (*C).pfd[0 as libc::c_int as usize].fd = (*C).sock + 1 as libc::c_int;
    (*C)
        .pfd[0 as libc::c_int as usize]
        .events = ((*C).pfd[0 as libc::c_int as usize].events as libc::c_int
        | 1 as libc::c_int) as libc::c_short;
    loop {
        res = poll(((*C).pfd).as_mut_ptr(), 1 as libc::c_int as nfds_t, timo);
        pthread_testcancel();
        if res < 0 as libc::c_int {
            puts(b"LESS THAN ZERO!\0" as *const u8 as *const libc::c_char);
        }
        if !(res < 0 as libc::c_int) {
            break;
        }
    }
    if res == 0 as libc::c_int {
        tmp___0 = __errno_location();
        *tmp___0 = 110 as libc::c_int;
    }
    if res <= 0 as libc::c_int {
        (*C).state = UNDEF;
        if my.timeout != 0 {
            tmp___1 = my.timeout;
        } else {
            tmp___1 = 15 as libc::c_int;
        }
        NOTIFY(
            WARNING,
            b"socket: polled(%d) and discovered it's not ready %s:%d\0" as *const u8
                as *const libc::c_char,
            tmp___1,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            343 as libc::c_int,
        );
        return boolean_false;
    } else {
        (*C).state = mode;
        return boolean_true;
    };
}
unsafe extern "C" fn __socket_select(mut C: *mut CONN, mut mode: SDSET) -> BOOLEAN {
    let mut timeout: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut res: libc::c_int = 0;
    let mut rs: fd_set = fd_set { fds_bits: [0; 16] };
    let mut ws: fd_set = fd_set { fds_bits: [0; 16] };
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut __d0___0: libc::c_int = 0;
    let mut __d1___0: libc::c_int = 0;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    memset(
        &mut timeout as *mut timeval as *mut libc::c_void,
        '\u{0}' as i32,
        ::std::mem::size_of::<timeval>() as libc::c_ulong,
    );
    if my.timeout > 0 as libc::c_int {
        timeout.tv_sec = my.timeout as __time_t;
    } else {
        timeout.tv_sec = 30 as libc::c_int as __time_t;
    }
    timeout.tv_usec = 0 as libc::c_int as __suseconds_t;
    if (*C).sock < 0 as libc::c_int {
        return boolean_false
    } else {
        if (*C).sock >= 1024 as libc::c_int {
            return boolean_false;
        }
    }
    loop {
        let fresh12 = &mut __d0;
        let fresh13;
        let fresh14 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh15 = &mut __d1;
        let fresh16;
        let fresh17 = &mut *(rs.fds_bits).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh12, fresh14) => fresh13,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh15, fresh17) =>
            fresh16, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh12, fresh14, fresh13);
        c2rust_asm_casts::AsmCast::cast_out(fresh15, fresh17, fresh16);
        let fresh18 = &mut __d0___0;
        let fresh19;
        let fresh20 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh21 = &mut __d1___0;
        let fresh22;
        let fresh23 = &mut *(ws.fds_bits).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh18, fresh20) => fresh19,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh21, fresh23) =>
            fresh22, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh18, fresh20, fresh19);
        c2rust_asm_casts::AsmCast::cast_out(fresh21, fresh23, fresh22);
        rs
            .fds_bits[((*C).sock
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << (*C).sock
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        ws
            .fds_bits[((*C).sock
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << (*C).sock
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        res = select(
            (*C).sock + 1 as libc::c_int,
            &mut rs as *mut fd_set,
            &mut ws as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut timeout as *mut timeval,
        );
        pthread_testcancel();
        if !(res < 0 as libc::c_int) {
            break;
        }
        tmp = __errno_location();
        if !(*tmp == 4 as libc::c_int) {
            break;
        }
    }
    if res == 0 as libc::c_int {
        tmp___0 = __errno_location();
        *tmp___0 = 110 as libc::c_int;
    }
    if res <= 0 as libc::c_int {
        (*C).state = UNDEF;
        NOTIFY(
            WARNING,
            b"socket: select and discovered it's not ready %s:%d\0" as *const u8
                as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            384 as libc::c_int,
        );
        return boolean_false;
    } else {
        (*C).state = mode;
        return boolean_true;
    };
}
unsafe extern "C" fn __socket_create(
    mut C: *mut CONN,
    mut domain: libc::c_int,
) -> libc::c_int {
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut opt: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    tmp___0 = socket(domain, 1 as libc::c_int, 0 as libc::c_int);
    (*C).sock = tmp___0;
    if tmp___0 < 0 as libc::c_int {
        tmp = __errno_location();
        match *tmp {
            93 => {
                NOTIFY(
                    ERROR,
                    b"unsupported protocol %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    401 as libc::c_int,
                );
            }
            24 => {
                NOTIFY(
                    ERROR,
                    b"descriptor table full %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    402 as libc::c_int,
                );
            }
            23 => {
                NOTIFY(
                    ERROR,
                    b"file table full %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    403 as libc::c_int,
                );
            }
            13 => {
                NOTIFY(
                    ERROR,
                    b"permission denied %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    404 as libc::c_int,
                );
            }
            105 => {
                NOTIFY(
                    ERROR,
                    b"insufficient buffer %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    405 as libc::c_int,
                );
            }
            _ => {
                NOTIFY(
                    ERROR,
                    b"unknown socket error %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    406 as libc::c_int,
                );
            }
        }
        socket_close(C);
        return -(1 as libc::c_int);
    }
    tmp___1 = fcntl((*C).sock, 2 as libc::c_int, 2048 as libc::c_int);
    if tmp___1 < 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"unable to set close control %s:%d\0" as *const u8 as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            410 as libc::c_int,
        );
    }
    if (*C).connection.keepalive != 0 {
        opt = 1 as libc::c_int;
        tmp___3 = setsockopt(
            (*C).sock,
            1 as libc::c_int,
            9 as libc::c_int,
            &mut opt as *mut libc::c_int as *mut libc::c_char as *const libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
        );
        if tmp___3 < 0 as libc::c_int {
            tmp___2 = __errno_location();
            match *tmp___2 {
                9 => {
                    NOTIFY(
                        ERROR,
                        b"invalid descriptor %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        417 as libc::c_int,
                    );
                }
                88 => {
                    NOTIFY(
                        ERROR,
                        b"not a socket %s:%d\0" as *const u8 as *const libc::c_char,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        418 as libc::c_int,
                    );
                }
                92 => {
                    NOTIFY(
                        ERROR,
                        b"not a protocol option %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        419 as libc::c_int,
                    );
                }
                14 => {
                    NOTIFY(
                        ERROR,
                        b"setsockopt unknown %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        420 as libc::c_int,
                    );
                }
                _ => {
                    NOTIFY(
                        ERROR,
                        b"unknown sockopt error %s:%d\0" as *const u8
                            as *const libc::c_char,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        421 as libc::c_int,
                    );
                }
            }
            socket_close(C);
            return -(1 as libc::c_int);
        }
    }
    tmp___4 = __socket_block((*C).sock, boolean_false);
    if tmp___4 < 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"socket: unable to set socket to non-blocking %s:%d\0" as *const u8
                as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            427 as libc::c_int,
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn __hostname_strip(mut hn: *mut libc::c_char, mut len: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut tmp: BOOLEAN = boolean_false;
    tmp = startswith(
        b"[\0" as *const u8 as *const libc::c_char,
        hn as *const libc::c_char,
    );
    if tmp as u64 != 0 {
        memmove(
            hn as *mut libc::c_void,
            hn.offset(1 as libc::c_int as isize) as *const libc::c_void,
            (len - 1 as libc::c_int) as size_t,
        );
        i = 0 as libc::c_int;
        while *hn.offset(i as isize) != 0 {
            if !(*hn.offset(i as isize) as libc::c_int != 93 as libc::c_int) {
                break;
            }
            i += 1;
        }
        if *hn.offset(i as isize) as libc::c_int == 93 as libc::c_int {
            memmove(
                hn.offset(i as isize) as *mut libc::c_void,
                hn.offset(i as isize).offset(1 as libc::c_int as isize)
                    as *const libc::c_void,
                (len - i - 1 as libc::c_int) as size_t,
            );
        }
    }
}
unsafe extern "C" fn __socket_block(
    mut sock: libc::c_int,
    mut block: BOOLEAN,
) -> libc::c_int {
    let mut flags: libc::c_int = 0;
    let mut retval: libc::c_int = 0;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    if sock == -(1 as libc::c_int) {
        return sock;
    }
    flags = fcntl(sock, 3 as libc::c_int, 0 as libc::c_int);
    if flags < 0 as libc::c_int {
        tmp = __errno_location();
        match *tmp {
            13 => {
                NOTIFY(
                    ERROR,
                    b"EACCES %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    478 as libc::c_int,
                );
            }
            9 => {
                NOTIFY(
                    ERROR,
                    b"bad file descriptor %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    479 as libc::c_int,
                );
            }
            11 => {
                NOTIFY(
                    ERROR,
                    b"address is unavailable %s:%d\0" as *const u8
                        as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    480 as libc::c_int,
                );
            }
            _ => {
                NOTIFY(
                    ERROR,
                    b"unknown network error %s:%d\0" as *const u8 as *const libc::c_char,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    481 as libc::c_int,
                );
            }
        }
        return -(1 as libc::c_int);
    }
    if block as u64 != 0 {
        flags &= -(2049 as libc::c_int);
    } else {
        flags |= 2048 as libc::c_int;
        flags |= 2048 as libc::c_int;
    }
    retval = fcntl(sock, 4 as libc::c_int, flags);
    if retval < 0 as libc::c_int {
        NOTIFY(
            ERROR,
            b"unable to set fcntl flags %s:%d\0" as *const u8 as *const libc::c_char,
            b"sock.c\0" as *const u8 as *const libc::c_char,
            496 as libc::c_int,
        );
        return -(1 as libc::c_int);
    }
    return retval;
}
unsafe extern "C" fn __socket_write(
    mut sock: libc::c_int,
    mut vbuf: *const libc::c_void,
    mut len: size_t,
) -> ssize_t {
    let mut n: size_t = 0;
    let mut w: ssize_t = 0;
    let mut buf: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    buf = vbuf as *const libc::c_char;
    n = len;
    while n > 0 as libc::c_ulong {
        w = write(sock, buf as *const libc::c_void, n);
        if w <= 0 as libc::c_long {
            tmp = __errno_location();
            if *tmp == 4 as libc::c_int {
                w = 0 as libc::c_int as ssize_t;
            } else {
                return -(1 as libc::c_int) as ssize_t
            }
        }
        n = (n as libc::c_ulong).wrapping_sub(w as size_t) as size_t as size_t;
        buf = buf.offset(w as isize);
    }
    return len as ssize_t;
}
unsafe extern "C" fn __ssl_socket_write(
    mut C: *mut CONN,
    mut vbuf: *const libc::c_void,
    mut len: size_t,
) -> ssize_t {
    let mut n: size_t = 0;
    let mut w: ssize_t = 0;
    let mut buf: *const libc::c_char = 0 as *const libc::c_char;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    buf = vbuf as *const libc::c_char;
    n = len;
    while n > 0 as libc::c_ulong {
        tmp = SSL_write((*C).ssl, buf as *const libc::c_void, n as libc::c_int);
        w = tmp as ssize_t;
        if w <= 0 as libc::c_long {
            if w < 0 as libc::c_long {
                err = SSL_get_error((*C).ssl as *const SSL, w as libc::c_int);
                match err {
                    3 | 2 => {
                        NOTIFY(
                            DEBUG,
                            b"SSL_write non-critical error %d\0" as *const u8
                                as *const libc::c_char,
                            err,
                        );
                        return 0 as libc::c_int as ssize_t;
                    }
                    5 => {
                        NOTIFY(
                            ERROR,
                            b"SSL_write() failed (syscall)\0" as *const u8
                                as *const libc::c_char,
                        );
                        return -(1 as libc::c_int) as ssize_t;
                    }
                    1 => return -(1 as libc::c_int) as ssize_t,
                    _ => {}
                }
            }
            NOTIFY(ERROR, b"SSL_write() failed.\0" as *const u8 as *const libc::c_char);
            return -(1 as libc::c_int) as ssize_t;
        }
        n = (n as libc::c_ulong).wrapping_sub(w as size_t) as size_t as size_t;
        buf = buf.offset(w as isize);
    }
    return len as ssize_t;
}
pub unsafe extern "C" fn socket_read(
    mut C: *mut CONN,
    mut vbuf: *mut libc::c_void,
    mut len: size_t,
) -> ssize_t {
    let mut type_0: libc::c_int = 0;
    let mut n: size_t = 0;
    let mut r: ssize_t = 0;
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ret_eof: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: BOOLEAN = boolean_false;
    let mut lidos: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: BOOLEAN = boolean_false;
    let mut tmp___8: ssize_t = 0;
    let mut tmp___9: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___10: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___11: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_int = 0 as *mut libc::c_int;
    ret_eof = 0 as libc::c_int;
    pthread_setcanceltype(0 as libc::c_int, &mut type_0);
    buf = vbuf as *mut libc::c_char;
    n = len;
    if (*C).encrypt as libc::c_uint == 1 as libc::c_uint {
        while n > 0 as libc::c_ulong {
            tmp___0 = __socket_check(C, READ);
            if tmp___0 as libc::c_uint == 0 as libc::c_uint {
                if my.timeout != 0 {
                    tmp = my.timeout;
                } else {
                    tmp = 15 as libc::c_int;
                }
                NOTIFY(
                    WARNING,
                    b"socket: read check timed out(%d) %s:%d\0" as *const u8
                        as *const libc::c_char,
                    tmp,
                    b"sock.c\0" as *const u8 as *const libc::c_char,
                    595 as libc::c_int,
                );
                return -(1 as libc::c_int) as ssize_t;
            }
            tmp___1 = SSL_read((*C).ssl, buf as *mut libc::c_void, n as libc::c_int);
            r = tmp___1 as ssize_t;
            if r < 0 as libc::c_long {
                tmp___2 = __errno_location();
                if *tmp___2 == 4 as libc::c_int {
                    r = 0 as libc::c_int as ssize_t;
                } else {
                    tmp___3 = SSL_get_error((*C).ssl as *const SSL, r as libc::c_int);
                    if tmp___3 == 2 as libc::c_int {
                        r = 0 as libc::c_int as ssize_t;
                    } else {
                        return -(1 as libc::c_int) as ssize_t
                    }
                }
            } else if r == 0 as libc::c_long {
                break;
            }
            n = (n as libc::c_ulong).wrapping_sub(r as size_t) as size_t as size_t;
            buf = buf.offset(r as isize);
        }
    } else {
        while n > 0 as libc::c_ulong {
            if (*C).inbuffer < len {
                tmp___5 = __socket_check(C, READ);
                if tmp___5 as libc::c_uint == 0 as libc::c_uint {
                    if my.timeout != 0 {
                        tmp___4 = my.timeout;
                    } else {
                        tmp___4 = 15 as libc::c_int;
                    }
                    NOTIFY(
                        WARNING,
                        b"socket: read check timed out(%d) %s:%d\0" as *const u8
                            as *const libc::c_char,
                        tmp___4,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        614 as libc::c_int,
                    );
                    return -(1 as libc::c_int) as ssize_t;
                }
            }
            if (*C).inbuffer < n {
                memmove(
                    ((*C).buffer).as_mut_ptr() as *mut libc::c_void,
                    &mut *((*C).buffer).as_mut_ptr().offset((*C).pos_ini as isize)
                        as *mut libc::c_char as *const libc::c_void,
                    (*C).inbuffer,
                );
                (*C).pos_ini = 0 as libc::c_int;
                tmp___7 = __socket_check(C, READ);
                if tmp___7 as libc::c_uint == 0 as libc::c_uint {
                    if my.timeout != 0 {
                        tmp___6 = my.timeout;
                    } else {
                        tmp___6 = 15 as libc::c_int;
                    }
                    NOTIFY(
                        WARNING,
                        b"socket: read check timed out(%d) %s:%d\0" as *const u8
                            as *const libc::c_char,
                        tmp___6,
                        b"sock.c\0" as *const u8 as *const libc::c_char,
                        623 as libc::c_int,
                    );
                    return -(1 as libc::c_int) as ssize_t;
                }
                tmp___8 = read(
                    (*C).sock,
                    &mut *((*C).buffer).as_mut_ptr().offset((*C).inbuffer as isize)
                        as *mut libc::c_char as *mut libc::c_void,
                    (::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong)
                        .wrapping_sub((*C).inbuffer),
                );
                lidos = tmp___8 as libc::c_int;
                if lidos == 0 as libc::c_int {
                    ret_eof = 1 as libc::c_int;
                }
                if lidos < 0 as libc::c_int {
                    tmp___9 = __errno_location();
                    if *tmp___9 == 4 as libc::c_int {
                        lidos = 0 as libc::c_int;
                    } else {
                        tmp___10 = __errno_location();
                        if *tmp___10 == 11 as libc::c_int {
                            lidos = 0 as libc::c_int;
                        }
                    }
                    tmp___13 = __errno_location();
                    if *tmp___13 == 32 as libc::c_int {
                        return 0 as libc::c_int as ssize_t
                    } else {
                        tmp___11 = __errno_location();
                        tmp___12 = strerror(*tmp___11);
                        NOTIFY(
                            ERROR,
                            b"socket: read error %s %s:%d\0" as *const u8
                                as *const libc::c_char,
                            tmp___12,
                            b"sock.c\0" as *const u8 as *const libc::c_char,
                            635 as libc::c_int,
                        );
                        return 0 as libc::c_int as ssize_t;
                    }
                }
                (*C)
                    .inbuffer = ((*C).inbuffer as libc::c_ulong)
                    .wrapping_add(lidos as size_t) as size_t as size_t;
            }
            if (*C).inbuffer >= n {
                r = n as ssize_t;
            } else {
                r = (*C).inbuffer as ssize_t;
            }
            if r == 0 as libc::c_long {
                break;
            }
            memmove(
                buf as *mut libc::c_void,
                &mut *((*C).buffer).as_mut_ptr().offset((*C).pos_ini as isize)
                    as *mut libc::c_char as *const libc::c_void,
                r as size_t,
            );
            (*C).pos_ini = ((*C).pos_ini as ssize_t + r) as libc::c_int;
            (*C)
                .inbuffer = ((*C).inbuffer as libc::c_ulong).wrapping_sub(r as size_t)
                as size_t as size_t;
            n = (n as libc::c_ulong).wrapping_sub(r as size_t) as size_t as size_t;
            buf = buf.offset(r as isize);
            if ret_eof != 0 {
                break;
            }
        }
    }
    pthread_setcanceltype(type_0, 0 as *mut libc::c_void as *mut libc::c_int);
    pthread_testcancel();
    return len.wrapping_sub(n) as ssize_t;
}
pub unsafe extern "C" fn socket_readline(
    mut C: *mut CONN,
    mut ptr: *mut libc::c_char,
    mut maxlen: size_t,
) -> ssize_t {
    let mut type_0: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: ssize_t = 0;
    len = maxlen as libc::c_int;
    pthread_setcanceltype(0 as libc::c_int, &mut type_0);
    n = 1 as libc::c_int;
    while n < len {
        tmp___0 = socket_read(
            C,
            &mut c as *mut libc::c_char as *mut libc::c_void,
            1 as libc::c_int as size_t,
        );
        res = tmp___0 as libc::c_int;
        if res == 1 as libc::c_int {
            tmp = ptr;
            ptr = ptr.offset(1);
            *tmp = c;
            if c as libc::c_int == 10 as libc::c_int {
                break;
            }
            n += 1;
        } else if res == 0 as libc::c_int {
            if !(n == 1 as libc::c_int) {
                break;
            }
            return 0 as libc::c_int as ssize_t;
        } else {
            return -(1 as libc::c_int) as ssize_t
        }
    }
    *ptr = 0 as libc::c_int as libc::c_char;
    pthread_setcanceltype(type_0, 0 as *mut libc::c_void as *mut libc::c_int);
    pthread_testcancel();
    return n as ssize_t;
}
pub unsafe extern "C" fn socket_write(
    mut C: *mut CONN,
    mut buf: *const libc::c_void,
    mut len: size_t,
) -> libc::c_int {
    let mut type_0: libc::c_int = 0;
    let mut bytes: size_t = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: ssize_t = 0;
    pthread_setcanceltype(0 as libc::c_int, &mut type_0);
    if (*C).encrypt as libc::c_uint == 1 as libc::c_uint {
        loop {
            tmp = __ssl_socket_write(C, buf, len);
            bytes = tmp as size_t;
            if bytes != len {
                if !(bytes == 0 as libc::c_ulong) {
                    return -(1 as libc::c_int);
                }
            }
            if !(bytes == 0 as libc::c_ulong) {
                break;
            }
        }
    } else {
        tmp___0 = __socket_write((*C).sock, buf, len);
        bytes = tmp___0 as size_t;
        if bytes != len {
            NOTIFY(
                ERROR,
                b"unable to write to socket %s:%d\0" as *const u8 as *const libc::c_char,
                b"sock.c\0" as *const u8 as *const libc::c_char,
                733 as libc::c_int,
            );
            return -(1 as libc::c_int);
        }
    }
    pthread_setcanceltype(type_0, 0 as *mut libc::c_void as *mut libc::c_int);
    pthread_testcancel();
    return bytes as libc::c_int;
}
pub unsafe extern "C" fn socket_close(mut C: *mut CONN) {
    let mut type_0: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut tries: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    ret = 0 as libc::c_int;
    tries = 0 as libc::c_int;
    if C as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    pthread_setcanceltype(0 as libc::c_int, &mut type_0);
    if (*C).encrypt as libc::c_uint == 1 as libc::c_uint {
        let mut current_block_21: u64;
        if (*C).connection.reuse == 0 {
            current_block_21 = 8573305270997575572;
        } else if (*C).connection.max == 1 as libc::c_int {
            current_block_21 = 8573305270997575572;
        } else {
            current_block_21 = 15768484401365413375;
        }
        match current_block_21 {
            8573305270997575572 => {
                if (*C).ssl as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    loop {
                        ret = SSL_get_shutdown((*C).ssl as *const SSL);
                        if ret < 0 as libc::c_int {
                            NOTIFY(
                                WARNING,
                                b"socket: SSL Socket closed by server: %s:%d\0" as *const u8
                                    as *const libc::c_char,
                                b"sock.c\0" as *const u8 as *const libc::c_char,
                                769 as libc::c_int,
                            );
                            break;
                        } else {
                            ret = SSL_shutdown((*C).ssl);
                            if ret == 1 as libc::c_int {
                                break;
                            }
                            tries += 1;
                            if !(tries < 5 as libc::c_int) {
                                break;
                            }
                        }
                    }
                }
                SSL_free((*C).ssl);
                (*C).ssl = 0 as *mut libc::c_void as *mut SSL;
                SSL_CTX_free((*C).ctx);
                (*C).ctx = 0 as *mut libc::c_void as *mut SSL_CTX;
                close((*C).sock);
                (*C).sock = -(1 as libc::c_int);
                (*C).connection.status = 0 as libc::c_int;
                (*C).connection.max = 0 as libc::c_int;
                (*C).connection.tested = 0 as libc::c_int;
            }
            _ => {}
        }
    } else {
        let mut current_block_43: u64;
        if (*C).connection.reuse == 0 as libc::c_int {
            current_block_43 = 11649682180990430521;
        } else if (*C).connection.max == 1 as libc::c_int {
            current_block_43 = 11649682180990430521;
        } else {
            current_block_43 = 3938820862080741272;
        }
        match current_block_43 {
            11649682180990430521 => {
                if (*C).sock != -(1 as libc::c_int) {
                    tmp = __socket_block((*C).sock, boolean_false);
                    if tmp < 0 as libc::c_int {
                        NOTIFY(
                            ERROR,
                            b"unable to set to non-blocking %s:%d\0" as *const u8
                                as *const libc::c_char,
                            b"sock.c\0" as *const u8 as *const libc::c_char,
                            795 as libc::c_int,
                        );
                    }
                    if (*C).connection.status > 1 as libc::c_int {
                        ret = shutdown((*C).sock, 2 as libc::c_int);
                        if ret < 0 as libc::c_int {
                            NOTIFY(
                                ERROR,
                                b"unable to shutdown the socket %s:%d\0" as *const u8
                                    as *const libc::c_char,
                                b"sock.c\0" as *const u8 as *const libc::c_char,
                                797 as libc::c_int,
                            );
                        }
                    }
                    ret = close((*C).sock);
                    if ret < 0 as libc::c_int {
                        NOTIFY(
                            ERROR,
                            b"unable to close the socket %s:%d\0" as *const u8
                                as *const libc::c_char,
                            b"sock.c\0" as *const u8 as *const libc::c_char,
                            799 as libc::c_int,
                        );
                    }
                }
                (*C).sock = -(1 as libc::c_int);
                (*C).connection.status = 0 as libc::c_int;
                (*C).connection.max = 0 as libc::c_int;
                (*C).connection.tested = 0 as libc::c_int;
            }
            _ => {}
        }
    }
    C = 0 as *mut libc::c_void as *mut CONN;
    pthread_setcanceltype(type_0, 0 as *mut libc::c_void as *mut libc::c_int);
    pthread_testcancel();
}
static mut lock_cs: *mut pthread_mutex_t = 0 as *const pthread_mutex_t
    as *mut pthread_mutex_t;
static mut lock_count: *mut libc::c_long = 0 as *const libc::c_long as *mut libc::c_long;
pub unsafe extern "C" fn SSL_initialize(
    mut C: *mut CONN,
    mut servername: *const libc::c_char,
) -> BOOLEAN {
    let mut i: libc::c_int = 0;
    let mut serr: libc::c_int = 0;
    let mut tmp: *const SSL_METHOD = 0 as *const SSL_METHOD;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_ulong = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    if !((*C).ssl).is_null() {
        return boolean_true;
    }
    (*C).ssl = 0 as *mut libc::c_void as *mut SSL;
    (*C).ctx = 0 as *mut libc::c_void as *mut SSL_CTX;
    (*C).method = 0 as *mut libc::c_void as *const SSL_METHOD;
    (*C).cert = 0 as *mut libc::c_void as *mut X509;
    if (my.ssl_key).is_null() {
        if !(my.ssl_cert).is_null() {
            my.ssl_key = my.ssl_cert;
        }
    }
    if (my.ssl_ciphers).is_null() {
        my
            .ssl_ciphers = stralloc(
            b"ALL:!COMPLEMENTOFDEFAULT:!eNULL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
    }
    tmp = TLS_client_method();
    (*C).method = tmp as *mut SSL_METHOD as *const SSL_METHOD;
    if (*C).method as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        SSL_error_stack();
        return boolean_false;
    }
    (*C).ctx = SSL_CTX_new((*C).method);
    if (*C).ctx as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        SSL_error_stack();
        return boolean_false;
    }
    SSL_CTX_ctrl((*C).ctx, 33 as libc::c_int, 3 as libc::c_long, 0 as *mut libc::c_void);
    SSL_CTX_set_options((*C).ctx, 33554432 as libc::c_ulong);
    SSL_CTX_ctrl((*C).ctx, 44 as libc::c_int, 3 as libc::c_long, 0 as *mut libc::c_void);
    SSL_CTX_set_timeout((*C).ctx, my.ssl_timeout as libc::c_long);
    if !(my.ssl_ciphers).is_null() {
        tmp___0 = SSL_CTX_set_cipher_list(
            (*C).ctx,
            my.ssl_ciphers as *const libc::c_char,
        );
        if tmp___0 == 0 {
            NOTIFY(
                ERROR,
                b"SSL_CTX_set_cipher_list\0" as *const u8 as *const libc::c_char,
            );
            return boolean_false;
        }
    }
    if !(my.ssl_cert).is_null() {
        tmp___1 = SSL_CTX_use_certificate_chain_file(
            (*C).ctx,
            my.ssl_cert as *const libc::c_char,
        );
        if tmp___1 == 0 {
            SSL_error_stack();
            NOTIFY(
                ERROR,
                b"Error reading certificate file: %s\0" as *const u8
                    as *const libc::c_char,
                my.ssl_cert,
            );
        }
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            tmp___2 = SSL_CTX_use_PrivateKey_file(
                (*C).ctx,
                my.ssl_key as *const libc::c_char,
                1 as libc::c_int,
            );
            if tmp___2 != 0 {
                break;
            }
            if i < 2 as libc::c_int {
                tmp___3 = ERR_peek_error();
                if (tmp___3 & 4095 as libc::c_ulong) as libc::c_int == 100 as libc::c_int
                {
                    SSL_error_stack();
                    NOTIFY(
                        WARNING,
                        b"Wrong pass phrase: retrying\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            i += 1;
        }
        tmp___4 = SSL_CTX_check_private_key((*C).ctx as *const SSL_CTX);
        if tmp___4 == 0 {
            NOTIFY(
                ERROR,
                b"Private key does not match the certificate\0" as *const u8
                    as *const libc::c_char,
            );
            return boolean_false;
        }
    }
    (*C).ssl = SSL_new((*C).ctx);
    SSL_ctrl(
        (*C).ssl,
        55 as libc::c_int,
        0 as libc::c_long,
        servername as *mut libc::c_char as *mut libc::c_void,
    );
    if (*C).ssl as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        SSL_error_stack();
        return boolean_false;
    }
    SSL_set_fd((*C).ssl, (*C).sock);
    serr = SSL_connect((*C).ssl);
    if serr != 1 as libc::c_int {
        SSL_error_stack();
        tmp___5 = SSL_get_error((*C).ssl as *const SSL, serr);
        NOTIFY(
            ERROR,
            b"Failed to make an SSL connection: %d\0" as *const u8
                as *const libc::c_char,
            tmp___5,
        );
        return boolean_false;
    }
    return boolean_true;
}
pub unsafe extern "C" fn SSL_thread_setup() {
    let mut x: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    OPENSSL_init_ssl(
        0 as libc::c_int as uint64_t,
        0 as *mut libc::c_void as *const OPENSSL_INIT_SETTINGS,
    );
    OPENSSL_init_ssl(
        2097154 as libc::c_long as uint64_t,
        0 as *mut libc::c_void as *const OPENSSL_INIT_SETTINGS,
    );
    tmp = CRYPTO_malloc(
        ::std::mem::size_of::<pthread_mutex_t>() as libc::c_ulong,
        b"ssl.c\0" as *const u8 as *const libc::c_char,
        192 as libc::c_int,
    );
    lock_cs = tmp as *mut pthread_mutex_t;
    tmp___0 = CRYPTO_malloc(
        ::std::mem::size_of::<libc::c_long>() as libc::c_ulong,
        b"ssl.c\0" as *const u8 as *const libc::c_char,
        195 as libc::c_int,
    );
    lock_count = tmp___0 as *mut libc::c_long;
    x = 0 as libc::c_int;
    while x < 1 as libc::c_int {
        *lock_count.offset(x as isize) = 0 as libc::c_long;
        pthread_mutex_init(
            lock_cs.offset(x as isize),
            0 as *mut libc::c_void as *const pthread_mutexattr_t,
        );
        x += 1;
    }
}
pub unsafe extern "C" fn SSL_thread_cleanup() {
    let mut x: libc::c_int = 0;
    xfree(my.ssl_ciphers as *mut libc::c_void);
    x = 0 as libc::c_int;
    while x < 1 as libc::c_int {
        pthread_mutex_destroy(lock_cs.offset(x as isize));
        x += 1;
    }
    if lock_cs as libc::c_ulong
        != 0 as *mut libc::c_void as *mut pthread_mutex_t as libc::c_ulong
    {
        CRYPTO_free(
            lock_cs as *mut libc::c_void,
            b"ssl.c\0" as *const u8 as *const libc::c_char,
            217 as libc::c_int,
        );
        lock_cs = 0 as *mut libc::c_void as *mut pthread_mutex_t;
    }
    if lock_count as libc::c_ulong
        != 0 as *mut libc::c_void as *mut libc::c_long as libc::c_ulong
    {
        CRYPTO_free(
            lock_count as *mut libc::c_void,
            b"ssl.c\0" as *const u8 as *const libc::c_char,
            221 as libc::c_int,
        );
        lock_count = 0 as *mut libc::c_void as *mut libc::c_long;
    }
    ERR_remove_state(0 as libc::c_ulong);
    ERR_remove_thread_state(0 as *mut libc::c_void);
}
pub unsafe extern "C" fn SSL_pthreads_thread_id() -> libc::c_ulong {
    let mut ret: libc::c_ulong = 0;
    let mut tmp: pthread_t = 0;
    tmp = pthread_self();
    ret = tmp;
    return ret;
}
unsafe extern "C" fn SSL_error_stack() {
    let mut err: libc::c_ulong = 0;
    let mut string: [libc::c_char; 120] = [0; 120];
    err = ERR_get_error();
    if err == 0 {
        return;
    }
    SSL_error_stack();
    ERR_error_string(err, string.as_mut_ptr());
    NOTIFY(
        ERROR,
        b"stack: %lX : %s\0" as *const u8 as *const libc::c_char,
        err,
        string.as_mut_ptr(),
    );
}
pub unsafe extern "C" fn stralloc(mut str: *mut libc::c_char) -> *mut libc::c_char {
    let mut retval: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(str as *const libc::c_char);
    tmp___0 = calloc(tmp.wrapping_add(1 as libc::c_ulong), 1 as libc::c_int as size_t);
    retval = tmp___0 as *mut libc::c_char;
    if retval.is_null() {
        NOTIFY(
            FATAL,
            b"Fatal memory allocation error\0" as *const u8 as *const libc::c_char,
        );
    }
    strcpy(retval, str as *const libc::c_char);
    return retval;
}
pub unsafe extern "C" fn siege_timer(mut handler: pthread_t) {
    let mut err: libc::c_int = 0;
    let mut now: time_t = 0;
    let mut timeout: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut timer_mutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list
                    as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list
                    as *mut __pthread_internal_list,
            },
        },
    };
    let mut timer_cond: pthread_cond_t = __anonunion_pthread_cond_t_951761805 {
        __data: __pthread_cond_s {
            __annonCompField1: __anonunion____missing_field_name_236290450 {
                __wseq: 0,
            },
            __annonCompField2: __anonunion____missing_field_name_958857992 {
                __g1_start: 0,
            },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    };
    let mut tmp: time_t = 0;
    timer_mutex.__data.__lock = 0 as libc::c_int;
    timer_mutex.__data.__count = 0 as libc::c_uint;
    timer_mutex.__data.__owner = 0 as libc::c_int;
    timer_mutex.__data.__nusers = 0 as libc::c_uint;
    timer_mutex.__data.__kind = 0 as libc::c_int;
    timer_mutex.__data.__spins = 0 as libc::c_int as libc::c_short;
    timer_mutex.__data.__elision = 0 as libc::c_int as libc::c_short;
    timer_mutex.__data.__list.__prev = 0 as *mut __pthread_internal_list;
    timer_mutex.__data.__list.__next = 0 as *mut __pthread_internal_list;
    timer_cond.__data.__annonCompField1.__wseq = 0 as libc::c_ulonglong;
    timer_cond.__data.__annonCompField2.__g1_start = 0 as libc::c_ulonglong;
    timer_cond.__data.__g_refs[0 as libc::c_int as usize] = 0 as libc::c_uint;
    timer_cond.__data.__g_refs[1 as libc::c_int as usize] = 0 as libc::c_uint;
    timer_cond.__data.__g_size[0 as libc::c_int as usize] = 0 as libc::c_uint;
    timer_cond.__data.__g_size[1 as libc::c_int as usize] = 0 as libc::c_uint;
    timer_cond.__data.__g1_orig_size = 0 as libc::c_uint;
    timer_cond.__data.__wrefs = 0 as libc::c_uint;
    timer_cond.__data.__g_signals[0 as libc::c_int as usize] = 0 as libc::c_uint;
    timer_cond.__data.__g_signals[1 as libc::c_int as usize] = 0 as libc::c_uint;
    tmp = time(&mut now);
    if tmp < 0 as libc::c_long {
        NOTIFY(
            FATAL,
            b"unable to set the siege timer!\0" as *const u8 as *const libc::c_char,
        );
    }
    timeout.tv_sec = now + my.secs as time_t;
    timeout.tv_nsec = 0 as libc::c_int as __syscall_slong_t;
    pthread_mutex_lock(&mut timer_mutex);
    loop {
        err = pthread_cond_timedwait(
            &mut timer_cond as *mut pthread_cond_t,
            &mut timer_mutex as *mut pthread_mutex_t,
            &mut timeout as *mut timespec as *const timespec,
        );
        if !(err == 110 as libc::c_int) {
            continue;
        }
        if my.debug as u64 != 0 {
            printf(b"TIMED OUT!!\n\0" as *const u8 as *const libc::c_char);
            fflush(stdout);
        }
        my.verbose = boolean_false;
        pthread_kill(handler, 15 as libc::c_int);
        break;
    }
    pthread_mutex_unlock(&mut timer_mutex);
}
pub static mut URLSIZE: size_t = ::std::mem::size_of::<URL_T>() as libc::c_ulong;
pub unsafe extern "C" fn new_url(mut str: *mut libc::c_char) -> URL {
    let mut this: URL = 0 as *mut URL_T;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = xmalloc(URLSIZE);
    this = tmp as URL;
    (*this).ID = 0 as libc::c_int;
    (*this).scheme = HTTP;
    (*this).hasparams = boolean_false;
    (*this).params = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).redir = boolean_false;
    (*this).method = 2 as libc::c_int;
    (*this).username = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).password = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).hostname = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).port = 80 as libc::c_int;
    (*this).path = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).file = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).params = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).hasparams = boolean_false;
    (*this).query = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).frag = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).request = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).postlen = 0 as libc::c_int as size_t;
    (*this).postdata = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).posttemp = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).conttype = 0 as *mut libc::c_void as *mut libc::c_char;
    (*this).cached = boolean_false;
    (*this).redir = boolean_false;
    __url_parse(this, str);
    return this;
}
pub unsafe extern "C" fn url_destroy(mut this: URL) -> URL {
    if this as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        xfree((*this).url as *mut libc::c_void);
        xfree((*this).username as *mut libc::c_void);
        xfree((*this).password as *mut libc::c_void);
        xfree((*this).hostname as *mut libc::c_void);
        if (*this).path as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if *((*this).path).offset(0 as libc::c_int as isize) as libc::c_int
                != 0 as libc::c_int
            {
                xfree((*this).path as *mut libc::c_void);
            }
        }
        xfree((*this).file as *mut libc::c_void);
        xfree((*this).query as *mut libc::c_void);
        xfree((*this).frag as *mut libc::c_void);
        xfree((*this).request as *mut libc::c_void);
        xfree((*this).conttype as *mut libc::c_void);
        xfree((*this).postdata as *mut libc::c_void);
        xfree((*this).posttemp as *mut libc::c_void);
        if (*this).hasparams as libc::c_uint == 1 as libc::c_uint {
            xfree((*this).params as *mut libc::c_void);
        }
        xfree(this as *mut libc::c_void);
    }
    return 0 as *mut libc::c_void as URL;
}
pub unsafe extern "C" fn url_set_ID(mut this: URL, mut ID: libc::c_int) {
    (*this).ID = ID;
}
pub unsafe extern "C" fn url_set_scheme(mut this: URL, mut scheme: SCHEME) {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut str: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    (*this).scheme = scheme;
    tmp___0 = url_get_scheme_name(this);
    str = strdup(tmp___0 as *const libc::c_char);
    if (*this).url as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = xstrdup((*this).url as *const libc::c_char);
        tmp___1 = strncasecmp(
            tmp as *const libc::c_char,
            b"http:\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int as size_t,
        );
        if tmp___1 == 0 {
            n = 7 as libc::c_int;
        }
        tmp___2 = strncasecmp(
            tmp as *const libc::c_char,
            b"https:\0" as *const u8 as *const libc::c_char,
            6 as libc::c_int as size_t,
        );
        if tmp___2 == 0 {
            n = 8 as libc::c_int;
        }
        tmp___3 = strncasecmp(
            tmp as *const libc::c_char,
            b"ftp:\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
        if tmp___3 == 0 {
            n = 6 as libc::c_int;
        }
        tmp___4 = strlen(tmp as *const libc::c_char);
        len = tmp___4 as libc::c_int;
        memmove(
            tmp as *mut libc::c_void,
            tmp.offset(n as isize) as *const libc::c_void,
            (len - n + 1 as libc::c_int) as size_t,
        );
        xfree((*this).url as *mut libc::c_void);
        tmp___5 = strlen(tmp as *const libc::c_char);
        tmp___6 = strlen(str as *const libc::c_char);
        len = tmp___5.wrapping_add(tmp___6).wrapping_add(4 as libc::c_ulong)
            as libc::c_int;
        tmp___7 = xmalloc(len as size_t);
        (*this).url = tmp___7 as *mut libc::c_char;
        memset((*this).url as *mut libc::c_void, '\u{0}' as i32, len as size_t);
        snprintf(
            (*this).url,
            len as size_t,
            b"%s://%s\0" as *const u8 as *const libc::c_char,
            str,
            tmp,
        );
        xfree(tmp as *mut libc::c_void);
        xfree(str as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn url_set_hostname(
    mut this: URL,
    mut hostname: *mut libc::c_char,
) {
    let mut len: size_t = 0;
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = empty(hostname as *const libc::c_char);
    if tmp as u64 != 0 {
        return;
    }
    xfree((*this).hostname as *mut libc::c_void);
    tmp___0 = strlen(hostname as *const libc::c_char);
    len = tmp___0.wrapping_add(1 as libc::c_ulong);
    tmp___1 = xmalloc(len);
    (*this).hostname = tmp___1 as *mut libc::c_char;
    memset((*this).hostname as *mut libc::c_void, '\u{0}' as i32, len);
    strncpy((*this).hostname, hostname as *const libc::c_char, len);
}
pub unsafe extern "C" fn url_set_redirect(mut this: URL, mut redir: BOOLEAN) {
    (*this).redir = redir;
}
pub unsafe extern "C" fn url_set_conttype(mut this: URL, mut type_0: *mut libc::c_char) {
    (*this).conttype = xstrdup(type_0 as *const libc::c_char);
}
pub unsafe extern "C" fn url_set_method(mut this: URL, mut method___0: METHOD) {
    (*this).method = method___0;
}
pub unsafe extern "C" fn url_set_postdata(
    mut this: URL,
    mut postdata: *mut libc::c_char,
    mut postlen: size_t,
) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    (*this).postlen = postlen;
    tmp = xmalloc(((*this).postlen).wrapping_add(1 as libc::c_ulong));
    (*this).postdata = tmp as *mut libc::c_char;
    memcpy(
        (*this).postdata as *mut libc::c_void,
        postdata as *const libc::c_void,
        (*this).postlen,
    );
    *((*this).postdata)
        .offset((*this).postlen as isize) = '\u{0}' as i32 as libc::c_char;
}
pub unsafe extern "C" fn url_get_ID(mut this: URL) -> libc::c_int {
    return (*this).ID;
}
pub unsafe extern "C" fn url_get_absolute(mut this: URL) -> *mut libc::c_char {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if this as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp = b"NULL\0" as *const u8 as *const libc::c_char;
    } else {
        tmp = (*this).url as *const libc::c_char;
    }
    return tmp as *mut libc::c_char;
}
pub unsafe extern "C" fn url_get_scheme(mut this: URL) -> SCHEME {
    return (*this).scheme;
}
pub unsafe extern "C" fn url_get_display(mut this: URL) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    if my.fullurl as u64 != 0 {
        tmp = url_get_absolute(this);
        return tmp;
    }
    if (*this).method as libc::c_uint == 2 as libc::c_uint {
        tmp___0 = url_get_request(this);
        return tmp___0;
    }
    tmp___1 = url_get_absolute(this);
    return tmp___1;
}
pub unsafe extern "C" fn url_get_scheme_name(mut this: URL) -> *mut libc::c_char {
    match (*this).scheme as libc::c_uint {
        1 => return b"http\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        2 => return b"https\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        3 => return b"ftp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        4 => return b"proxy\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        _ => {
            return b"unsupported\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
    };
}
pub unsafe extern "C" fn url_get_username(mut this: URL) -> *mut libc::c_char {
    return (*this).username;
}
pub unsafe extern "C" fn url_get_password(mut this: URL) -> *mut libc::c_char {
    return (*this).password;
}
pub unsafe extern "C" fn url_get_hostname(mut this: URL) -> *mut libc::c_char {
    return (*this).hostname;
}
pub unsafe extern "C" fn url_get_port(mut this: URL) -> libc::c_int {
    return (*this).port;
}
pub unsafe extern "C" fn url_get_path(mut this: URL) -> *mut libc::c_char {
    return (*this).path;
}
pub unsafe extern "C" fn url_get_file(mut this: URL) -> *mut libc::c_char {
    return (*this).file;
}
pub unsafe extern "C" fn url_get_request(mut this: URL) -> *mut libc::c_char {
    return (*this).request;
}
pub unsafe extern "C" fn url_get_parameters(mut this: URL) -> *mut libc::c_char {
    return (*this).params;
}
pub unsafe extern "C" fn url_get_query(mut this: URL) -> *mut libc::c_char {
    return (*this).query;
}
pub unsafe extern "C" fn url_get_fragment(mut this: URL) -> *mut libc::c_char {
    return (*this).frag;
}
pub unsafe extern "C" fn url_get_postlen(mut this: URL) -> size_t {
    return (*this).postlen;
}
pub unsafe extern "C" fn url_get_postdata(mut this: URL) -> *mut libc::c_char {
    return (*this).postdata;
}
pub unsafe extern "C" fn url_get_posttemp(mut this: URL) -> *mut libc::c_char {
    return (*this).posttemp;
}
pub unsafe extern "C" fn url_get_conttype(mut this: URL) -> *mut libc::c_char {
    let mut tmp: BOOLEAN = boolean_false;
    if (*this).conttype as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp = empty((my.conttype).as_mut_ptr() as *const libc::c_char);
        if tmp as u64 != 0 {
            (*this)
                .conttype = xstrdup(
                b"application/x-www-form-urlencoded\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            (*this)
                .conttype = xstrdup((my.conttype).as_mut_ptr() as *const libc::c_char);
        }
    }
    return (*this).conttype;
}
pub unsafe extern "C" fn url_get_method(mut this: URL) -> METHOD {
    return (*this).method;
}
pub unsafe extern "C" fn url_get_method_name(mut this: URL) -> *mut libc::c_char {
    match (*this).method as libc::c_uint {
        3 => return b"POST\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        9 => return b"PATCH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        4 => return b"PUT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        5 => return b"DELETE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        7 => return b"OPTIONS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        1 => return b"HEAD\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        _ => return b"GET\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    };
}
pub unsafe extern "C" fn url_is_redirect(mut this: URL) -> BOOLEAN {
    return (*this).redir;
}
pub unsafe extern "C" fn url_set_username(
    mut this: URL,
    mut username: *mut libc::c_char,
) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(username as *const libc::c_char);
    len = tmp;
    tmp___0 = malloc(len.wrapping_add(1 as libc::c_ulong));
    (*this).username = tmp___0 as *mut libc::c_char;
    memset(
        (*this).username as *mut libc::c_void,
        '\u{0}' as i32,
        len.wrapping_add(1 as libc::c_ulong),
    );
    memcpy((*this).username as *mut libc::c_void, username as *const libc::c_void, len);
}
pub unsafe extern "C" fn url_set_password(
    mut this: URL,
    mut password: *mut libc::c_char,
) {
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(password as *const libc::c_char);
    len = tmp;
    tmp___0 = malloc(len.wrapping_add(1 as libc::c_ulong));
    (*this).password = tmp___0 as *mut libc::c_char;
    memset(
        (*this).password as *mut libc::c_void,
        '\u{0}' as i32,
        len.wrapping_add(1 as libc::c_ulong),
    );
    memcpy((*this).password as *mut libc::c_void, password as *const libc::c_void, len);
}
pub unsafe extern "C" fn url_dump(mut this: URL) {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    printf(b"URL ID:    %d\n\0" as *const u8 as *const libc::c_char, (*this).ID);
    printf(b"Abolute:   %s\n\0" as *const u8 as *const libc::c_char, (*this).url);
    tmp = url_get_scheme_name(this);
    printf(b"Scheme:    %s\n\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = url_get_method_name(this);
    printf(b"Method:    %s\n\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = url_get_username(this);
    printf(b"Username:  %s\n\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = url_get_password(this);
    printf(b"Password:  %s\n\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = url_get_hostname(this);
    printf(b"Hostname:  %s\n\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = url_get_port(this);
    printf(b"Port:      %d\n\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = url_get_path(this);
    printf(b"Path:      %s\n\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = url_get_file(this);
    printf(b"File:      %s\n\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = url_get_request(this);
    printf(b"Request:   %s\n\0" as *const u8 as *const libc::c_char, tmp___7);
    if (*this).hasparams as libc::c_uint == 1 as libc::c_uint {
        tmp___8 = url_get_parameters(this);
        printf(b"Params:   %s\n\0" as *const u8 as *const libc::c_char, tmp___8);
    }
    tmp___9 = url_get_query(this);
    printf(b"Query:     %s\n\0" as *const u8 as *const libc::c_char, tmp___9);
    tmp___10 = url_get_fragment(this);
    printf(b"Fragment:  %s\n\0" as *const u8 as *const libc::c_char, tmp___10);
    tmp___11 = url_get_postlen(this);
    printf(
        b"Post Len:  %d\n\0" as *const u8 as *const libc::c_char,
        tmp___11 as libc::c_int,
    );
    tmp___12 = url_get_postdata(this);
    printf(b"Post Data: %s\n\0" as *const u8 as *const libc::c_char, tmp___12);
    tmp___13 = url_get_conttype(this);
    printf(b"Cont Type: %s\n\0" as *const u8 as *const libc::c_char, tmp___13);
}
pub unsafe extern "C" fn url_normalize(
    mut req: URL,
    mut location: *mut libc::c_char,
) -> URL {
    let mut ret: URL = 0 as *mut URL_T;
    let mut url: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: SCHEME = UNSUPPORTED;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: SCHEME = UNSUPPORTED;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: size_t = 0;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___19: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___20: size_t = 0;
    let mut tmp___21: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___22: size_t = 0;
    let mut tmp___23: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___30: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___31: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___32: BOOLEAN = boolean_false;
    let mut tmp___33: SCHEME = UNSUPPORTED;
    __url_replace(
        location,
        b"&amp;\0" as *const u8 as *const libc::c_char,
        b"&\0" as *const u8 as *const libc::c_char,
    );
    __url_replace(
        location,
        b"&#038;\0" as *const u8 as *const libc::c_char,
        b"&\0" as *const u8 as *const libc::c_char,
    );
    tmp = url_get_absolute(req);
    tmp___0 = strlen(tmp as *const libc::c_char);
    tmp___1 = strlen(location as *const libc::c_char);
    len = tmp___0.wrapping_add(tmp___1).wrapping_add(32 as libc::c_ulong);
    tmp___2 = stristr(
        location as *const libc::c_char,
        b"data:image/gif\0" as *const u8 as *const libc::c_char,
    );
    if !tmp___2.is_null() {
        return 0 as *mut libc::c_void as URL;
    }
    tmp___5 = stristr(
        location as *const libc::c_char,
        b"://\0" as *const u8 as *const libc::c_char,
    );
    if !tmp___5.is_null() {
        ret = new_url(location);
        tmp___3 = url_get_hostname(ret);
        tmp___4 = strlen(tmp___3 as *const libc::c_char);
        if tmp___4 > 1 as libc::c_ulong {
            return ret;
        }
    }
    if *location.offset(0 as libc::c_int as isize) as libc::c_int != 47 as libc::c_int {
        if *location.offset(0 as libc::c_int as isize) as libc::c_int
            != 46 as libc::c_int
        {
            tmp___9 = strchr(location as *const libc::c_char, '.' as i32);
            if tmp___9 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___10 = strchr(location as *const libc::c_char, '/' as i32);
                if tmp___10 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    ret = new_url(location);
                    tmp___6 = url_get_scheme(req);
                    url_set_scheme(ret, tmp___6);
                    tmp___7 = url_get_hostname(ret);
                    tmp___8 = strchr(tmp___7 as *const libc::c_char, '.' as i32);
                    if tmp___8 as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        return ret;
                    }
                }
            }
        }
    }
    tmp___14 = strstr(
        location as *const libc::c_char,
        b"localhost\0" as *const u8 as *const libc::c_char,
    );
    if tmp___14 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        ret = new_url(location);
        tmp___11 = url_get_scheme(req);
        url_set_scheme(ret, tmp___11);
        tmp___12 = url_get_hostname(ret);
        tmp___13 = strlen(tmp___12 as *const libc::c_char);
        if tmp___13 == 9 as libc::c_ulong {
            return ret;
        }
    }
    tmp___15 = malloc(len);
    url = tmp___15 as *mut libc::c_char;
    memset(url as *mut libc::c_void, '\u{0}' as i32, len);
    if *location.offset(0 as libc::c_int as isize) as libc::c_int == 47 as libc::c_int {
        tmp___20 = strlen(location as *const libc::c_char);
        if tmp___20 > 1 as libc::c_ulong {
            if *location.offset(1 as libc::c_int as isize) as libc::c_int
                == 47 as libc::c_int
            {
                tmp___16 = url_get_scheme_name(req);
                snprintf(
                    url,
                    len,
                    b"%s:%s\0" as *const u8 as *const libc::c_char,
                    tmp___16,
                    location,
                );
            } else {
                tmp___17 = url_get_port(req);
                tmp___18 = url_get_hostname(req);
                tmp___19 = url_get_scheme_name(req);
                snprintf(
                    url,
                    len,
                    b"%s://%s:%d%s\0" as *const u8 as *const libc::c_char,
                    tmp___19,
                    tmp___18,
                    tmp___17,
                    location,
                );
            }
        } else {
            tmp___17 = url_get_port(req);
            tmp___18 = url_get_hostname(req);
            tmp___19 = url_get_scheme_name(req);
            snprintf(
                url,
                len,
                b"%s://%s:%d%s\0" as *const u8 as *const libc::c_char,
                tmp___19,
                tmp___18,
                tmp___17,
                location,
            );
        }
    } else {
        tmp___31 = url_get_path(req);
        tmp___32 = endswith(
            b"/\0" as *const u8 as *const libc::c_char,
            tmp___31 as *const libc::c_char,
        );
        if tmp___32 as libc::c_uint == 1 as libc::c_uint {
            if *location.offset(0 as libc::c_int as isize) as libc::c_int
                == 46 as libc::c_int
            {
                tmp___22 = strlen(location as *const libc::c_char);
                if tmp___22 > 1 as libc::c_ulong {
                    tmp___21 = location.offset(2 as libc::c_int as isize);
                } else {
                    tmp___21 = location;
                }
            } else {
                tmp___21 = location;
            }
            tmp___23 = url_get_path(req);
            tmp___24 = url_get_port(req);
            tmp___25 = url_get_hostname(req);
            tmp___26 = url_get_scheme_name(req);
            snprintf(
                url,
                len,
                b"%s://%s:%d%s%s\0" as *const u8 as *const libc::c_char,
                tmp___26,
                tmp___25,
                tmp___24,
                tmp___23,
                tmp___21,
            );
        } else {
            tmp___27 = url_get_path(req);
            tmp___28 = url_get_port(req);
            tmp___29 = url_get_hostname(req);
            tmp___30 = url_get_scheme_name(req);
            snprintf(
                url,
                len,
                b"%s://%s:%d%s/%s\0" as *const u8 as *const libc::c_char,
                tmp___30,
                tmp___29,
                tmp___28,
                tmp___27,
                location,
            );
        }
    }
    ret = new_url(url);
    tmp___33 = url_get_scheme(req);
    url_set_scheme(ret, tmp___33);
    free(url as *mut libc::c_void);
    return ret;
}
pub unsafe extern "C" fn url_normalize_string(
    mut req: URL,
    mut location: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut t: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut u: URL = 0 as *mut URL_T;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    u = url_normalize(req, location);
    tmp = url_get_absolute(u);
    t = strdup(tmp as *const libc::c_char);
    u = url_destroy(u);
    return t;
}
unsafe extern "C" fn __url_parse(mut this: URL, mut url: *mut libc::c_char) {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut esc: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut post: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: BOOLEAN = boolean_false;
    ptr = 0 as *mut libc::c_void as *mut libc::c_char;
    esc = 0 as *mut libc::c_void as *mut libc::c_char;
    esc = __url_escape(url as *const libc::c_char);
    if my.escape as u64 != 0 {
        ptr = __url_set_absolute(this, esc);
    } else {
        ptr = __url_set_absolute(this, url);
    }
    ptr = __url_set_scheme(this, ptr);
    post = strstr(
        (*this).url as *const libc::c_char,
        b" POST\0" as *const u8 as *const libc::c_char,
    );
    if post.is_null() {
        post = strstr(
            (*this).url as *const libc::c_char,
            b" PUT\0" as *const u8 as *const libc::c_char,
        );
    }
    if post.is_null() {
        post = strstr(
            (*this).url as *const libc::c_char,
            b" PATCH\0" as *const u8 as *const libc::c_char,
        );
    }
    if post.is_null() {
        post = strstr(
            (*this).url as *const libc::c_char,
            b" OPTIONS\0" as *const u8 as *const libc::c_char,
        );
    }
    if post.is_null() {
        post = strstr(
            (*this).url as *const libc::c_char,
            b" DELETE\0" as *const u8 as *const libc::c_char,
        );
    }
    if post as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = strncasecmp(
            post as *const libc::c_char,
            b" PUT\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
        if tmp___2 != 0 {
            tmp___1 = strncasecmp(
                post as *const libc::c_char,
                b" POST\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int as size_t,
            );
            if tmp___1 != 0 {
                tmp___0 = strncasecmp(
                    post as *const libc::c_char,
                    b" DELETE\0" as *const u8 as *const libc::c_char,
                    7 as libc::c_int as size_t,
                );
                if tmp___0 != 0 {
                    tmp = strncasecmp(
                        post as *const libc::c_char,
                        b" OPTIONS\0" as *const u8 as *const libc::c_char,
                        8 as libc::c_int as size_t,
                    );
                    if tmp != 0 {
                        (*this).method = 9 as libc::c_int;
                        *post = '\u{0}' as i32 as libc::c_char;
                        post = post.offset(6 as libc::c_int as isize);
                    } else {
                        (*this).method = 7 as libc::c_int;
                        *post = '\u{0}' as i32 as libc::c_char;
                        post = post.offset(8 as libc::c_int as isize);
                    }
                } else {
                    (*this).method = 5 as libc::c_int;
                    *post = '\u{0}' as i32 as libc::c_char;
                    post = post.offset(7 as libc::c_int as isize);
                }
            } else {
                (*this).method = 3 as libc::c_int;
                *post = '\u{0}' as i32 as libc::c_char;
                post = post.offset(5 as libc::c_int as isize);
            }
        } else {
            (*this).method = 4 as libc::c_int;
            *post = '\u{0}' as i32 as libc::c_char;
            post = post.offset(4 as libc::c_int as isize);
        }
        __parse_post_data(this, post);
    } else {
        (*this).method = 2 as libc::c_int;
        (*this).postdata = 0 as *mut libc::c_void as *mut libc::c_char;
        (*this).posttemp = 0 as *mut libc::c_void as *mut libc::c_char;
        (*this).postlen = 0 as libc::c_int as size_t;
    }
    tmp___3 = __url_has_credentials(ptr);
    if tmp___3 as u64 != 0 {
        ptr = __url_set_username(this, ptr);
        ptr = __url_set_password(this, ptr);
    }
    ptr = __url_set_hostname(this, ptr);
    ptr = __url_set_port(this, ptr);
    ptr = __url_set_path(this, ptr);
    ptr = __url_set_file(this, ptr);
    ptr = __url_set_parameters(this, ptr);
    ptr = __url_set_query(this, ptr);
    ptr = __url_set_fragment(this, ptr);
}
unsafe extern "C" fn __parse_post_data(mut this: URL, mut datap: *mut libc::c_char) {
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: BOOLEAN = boolean_false;
    loop {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*datap as libc::c_uint as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        datap = datap.offset(1);
    }
    if *datap as libc::c_int == 60 as libc::c_int {
        datap = datap.offset(1);
        load_file(this, datap);
        datap = __url_set_path(this, datap);
        datap = __url_set_file(this, datap);
        return;
    } else {
        (*this).postdata = xstrdup(datap as *const libc::c_char);
        (*this).postlen = strlen((*this).postdata as *const libc::c_char);
        tmp___0 = empty((my.conttype).as_mut_ptr() as *const libc::c_char);
        if tmp___0 as u64 != 0 {
            (*this)
                .conttype = xstrdup(
                b"application/x-www-form-urlencoded\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            (*this)
                .conttype = xstrdup((my.conttype).as_mut_ptr() as *const libc::c_char);
        }
        return;
    };
}
unsafe extern "C" fn __url_set_absolute(
    mut this: URL,
    mut url: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut n: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut slash: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut scheme: [libc::c_char; 16] = [0; 16];
    let mut tmp: BOOLEAN = boolean_false;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: BOOLEAN = boolean_false;
    tmp = empty(url as *const libc::c_char);
    if tmp as u64 != 0 {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    memset(
        scheme.as_mut_ptr() as *mut libc::c_void,
        '\u{0}' as i32,
        16 as libc::c_int as size_t,
    );
    tmp___0 = strncasecmp(
        url as *const libc::c_char,
        b"http:\0" as *const u8 as *const libc::c_char,
        5 as libc::c_int as size_t,
    );
    if tmp___0 == 0 {
        n = 7 as libc::c_int;
        strncpy(
            scheme.as_mut_ptr(),
            b"http\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
    }
    tmp___1 = strncasecmp(
        url as *const libc::c_char,
        b"https:\0" as *const u8 as *const libc::c_char,
        6 as libc::c_int as size_t,
    );
    if tmp___1 == 0 {
        n = 8 as libc::c_int;
        strncpy(
            scheme.as_mut_ptr(),
            b"https\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int as size_t,
        );
    }
    tmp___2 = strncasecmp(
        url as *const libc::c_char,
        b"ftp:\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int as size_t,
    );
    if tmp___2 == 0 {
        n = 6 as libc::c_int;
        strncpy(
            scheme.as_mut_ptr(),
            b"ftp\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int as size_t,
        );
    }
    tmp___3 = strlen(scheme.as_mut_ptr() as *const libc::c_char);
    if tmp___3 < 3 as libc::c_ulong {
        n = 7 as libc::c_int;
        strncpy(
            scheme.as_mut_ptr(),
            b"http\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int as size_t,
        );
    }
    tmp___4 = strlen(url as *const libc::c_char);
    len = tmp___4.wrapping_add(5 as libc::c_ulong);
    tmp___7 = __url_has_scheme(url);
    if tmp___7 as u64 != 0 {
        tmp___6 = xmalloc(len);
        (*this).url = tmp___6 as *mut libc::c_char;
        memset((*this).url as *mut libc::c_void, '\u{0}' as i32, len);
        snprintf((*this).url, len, b"%s\0" as *const u8 as *const libc::c_char, url);
    } else {
        tmp___5 = xmalloc(len.wrapping_add(n as size_t));
        (*this).url = tmp___5 as *mut libc::c_char;
        memset(
            (*this).url as *mut libc::c_void,
            '\u{0}' as i32,
            len.wrapping_add(n as size_t),
        );
        slash = strstr(
            url as *const libc::c_char,
            b"/\0" as *const u8 as *const libc::c_char,
        );
        if !slash.is_null() {
            snprintf(
                (*this).url,
                len.wrapping_add(n as size_t),
                b"%s://%s\0" as *const u8 as *const libc::c_char,
                scheme.as_mut_ptr(),
                url,
            );
        } else {
            snprintf(
                (*this).url,
                len.wrapping_add(n as size_t),
                b"%s://%s/\0" as *const u8 as *const libc::c_char,
                scheme.as_mut_ptr(),
                url,
            );
        }
    }
    return (*this).url;
}
unsafe extern "C" fn __url_has_scheme(mut url: *mut libc::c_char) -> BOOLEAN {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    p = url as *const libc::c_char;
    if *p == 0 {
        return boolean_false
    } else {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*p as libc::c_int as isize) as libc::c_int & 8 as libc::c_int
            == 0
        {
            if !(*p as libc::c_int == 45 as libc::c_int) {
                if !(*p as libc::c_int == 43 as libc::c_int) {
                    return boolean_false;
                }
            }
        }
    }
    p = p.offset(1);
    while *p != 0 {
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*p as libc::c_int as isize) as libc::c_int
            & 8 as libc::c_int == 0
        {
            if !(*p as libc::c_int == 45 as libc::c_int) {
                if !(*p as libc::c_int == 43 as libc::c_int) {
                    break;
                }
            }
        }
        p = p.offset(1);
    }
    return (*p as libc::c_int == 58 as libc::c_int) as libc::c_int as BOOLEAN;
}
unsafe extern "C" fn __url_has_credentials(mut url: *mut libc::c_char) -> BOOLEAN {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = strpbrk(
        url as *const libc::c_char,
        b"@/?#;\0" as *const u8 as *const libc::c_char,
    );
    p = tmp as *const libc::c_char;
    if p.is_null() {
        return boolean_false
    } else {
        if *p as libc::c_int != 64 as libc::c_int {
            return boolean_false;
        }
    }
    return boolean_true;
}
unsafe extern "C" fn __url_default_port(mut this: URL) -> libc::c_int {
    match (*this).scheme as libc::c_uint {
        3 => return 21 as libc::c_int,
        1 => return 80 as libc::c_int,
        2 => return 443 as libc::c_int,
        _ => return 80 as libc::c_int,
    };
}
unsafe extern "C" fn __url_set_scheme(
    mut this: URL,
    mut url: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strncasecmp(
        (*this).url as *const libc::c_char,
        b"http:\0" as *const u8 as *const libc::c_char,
        5 as libc::c_int as size_t,
    );
    if tmp == 0 {
        (*this).scheme = HTTP;
        return url.offset(7 as libc::c_int as isize);
    }
    tmp___0 = strncasecmp(
        (*this).url as *const libc::c_char,
        b"https:\0" as *const u8 as *const libc::c_char,
        6 as libc::c_int as size_t,
    );
    if tmp___0 == 0 {
        (*this).scheme = HTTPS;
        return url.offset(8 as libc::c_int as isize);
    }
    tmp___1 = strncasecmp(
        (*this).url as *const libc::c_char,
        b"ftp:\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int as size_t,
    );
    if tmp___1 == 0 {
        (*this).scheme = FTP;
        return url.offset(6 as libc::c_int as isize);
    }
    (*this).scheme = UNSUPPORTED;
    return url;
}
unsafe extern "C" fn __url_set_username(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut a: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    a = strchr(str as *const libc::c_char, '@' as i32);
    s = strchr(str as *const libc::c_char, '/' as i32);
    if a.is_null() {
        return str
    } else {
        if !s.is_null() {
            if a as libc::c_ulong >= s as libc::c_ulong {
                return str;
            }
        }
    }
    i = 0 as libc::c_int;
    while *str.offset(i as isize) != 0 {
        if !(*str.offset(i as isize) as libc::c_int != 58 as libc::c_int) {
            break;
        }
        if !(*str.offset(i as isize) as libc::c_int != 64 as libc::c_int) {
            break;
        }
        if !(*str.offset(i as isize) as libc::c_int != 47 as libc::c_int) {
            break;
        }
        i += 1;
    }
    if *str.offset(i as isize) as libc::c_int != 64 as libc::c_int {
        if *str.offset(i as isize) as libc::c_int != 58 as libc::c_int {
            return str;
        }
    }
    tmp = malloc((i + 1 as libc::c_int) as size_t);
    (*this).username = tmp as *mut libc::c_char;
    memcpy(
        (*this).username as *mut libc::c_void,
        str as *const libc::c_void,
        (i + 1 as libc::c_int) as size_t,
    );
    *((*this).username).offset(i as isize) = '\u{0}' as i32 as libc::c_char;
    str = str.offset((i + 1 as libc::c_int) as isize);
    return str;
}
unsafe extern "C" fn __url_set_password(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut a: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    a = strchr(str as *const libc::c_char, '@' as i32);
    s = strchr(str as *const libc::c_char, '/' as i32);
    if a.is_null() {
        return str
    } else {
        if !s.is_null() {
            if a as libc::c_ulong >= s as libc::c_ulong {
                return str;
            }
        }
    }
    i = 0 as libc::c_int;
    while *str.offset(i as isize) as libc::c_int != 64 as libc::c_int {
        i += 1;
    }
    tmp = xmalloc((i + 1 as libc::c_int) as size_t);
    (*this).password = tmp as *mut libc::c_char;
    memcpy(
        (*this).password as *mut libc::c_void,
        str as *const libc::c_void,
        i as size_t,
    );
    *((*this).password).offset(i as isize) = '\u{0}' as i32 as libc::c_char;
    str = str.offset((i + 1 as libc::c_int) as isize);
    return str;
}
unsafe extern "C" fn __url_set_hostname(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: BOOLEAN = boolean_false;
    let mut tmp___1: BOOLEAN = boolean_false;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp___0 = startswith(
        b"//\0" as *const u8 as *const libc::c_char,
        str as *const libc::c_char,
    );
    if tmp___0 as u64 != 0 {
        n = 2 as libc::c_int;
        tmp = strlen(str as *const libc::c_char);
        len = tmp as libc::c_int;
        memmove(
            str as *mut libc::c_void,
            str.offset(n as isize) as *const libc::c_void,
            (len - n + 1 as libc::c_int) as size_t,
        );
    }
    tmp___1 = startswith(
        b"[\0" as *const u8 as *const libc::c_char,
        str as *const libc::c_char,
    );
    if tmp___1 as u64 != 0 {
        i = 0 as libc::c_int;
        while *str.offset(i as isize) != 0 {
            if !(*str.offset(i as isize) as libc::c_int != 93 as libc::c_int) {
                break;
            }
            i += 1;
        }
        if *str.offset(i as isize) as libc::c_int == 93 as libc::c_int {
            i += 1;
        }
    } else {
        i = 0 as libc::c_int;
        while *str.offset(i as isize) != 0 {
            if !(*str.offset(i as isize) as libc::c_int != 47 as libc::c_int) {
                break;
            }
            if !(*str.offset(i as isize) as libc::c_int != 35 as libc::c_int) {
                break;
            }
            if !(*str.offset(i as isize) as libc::c_int != 58 as libc::c_int) {
                break;
            }
            i += 1;
        }
    }
    tmp___2 = xmalloc((i + 1 as libc::c_int) as size_t);
    (*this).hostname = tmp___2 as *mut libc::c_char;
    memset(
        (*this).hostname as *mut libc::c_void,
        '\u{0}' as i32,
        (i + 1 as libc::c_int) as size_t,
    );
    memcpy(
        (*this).hostname as *mut libc::c_void,
        str as *const libc::c_void,
        i as size_t,
    );
    if *str.offset(i as isize) as libc::c_int == 58 as libc::c_int {
        str = str.offset((i + 1 as libc::c_int) as isize);
    } else {
        str = str.offset(i as isize);
    }
    return str;
}
unsafe extern "C" fn __url_set_port(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut portstr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    (*this).port = __url_default_port(this);
    i = 0 as libc::c_int;
    loop {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*str.offset(i as isize) as libc::c_int as isize) as libc::c_int
            & 2048 as libc::c_int == 0
        {
            break;
        }
        i += 1;
    }
    if i == 0 as libc::c_int {
        return str;
    }
    tmp___0 = malloc((i + 1 as libc::c_int) as size_t);
    portstr = tmp___0 as *mut libc::c_char;
    memcpy(
        portstr as *mut libc::c_void,
        str as *const libc::c_void,
        (i + 1 as libc::c_int) as size_t,
    );
    *portstr.offset(i as isize) = '\u{0}' as i32 as libc::c_char;
    (*this).port = atoi(portstr as *const libc::c_char);
    xfree(portstr as *mut libc::c_void);
    str = str.offset(i as isize);
    return str;
}
unsafe extern "C" fn __url_set_path(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut c: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: size_t = 0;
    if str as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if *str.offset(0 as libc::c_int as isize) as libc::c_int == 35 as libc::c_int {
            (*this).request = xstrdup(b"/\0" as *const u8 as *const libc::c_char);
            return str;
        }
    }
    (*this).request = xstrdup(str as *const libc::c_char);
    tmp = strstr(
        (*this).request as *const libc::c_char,
        b"#\0" as *const u8 as *const libc::c_char,
    );
    c = tmp;
    if !c.is_null() {
        *c = '\u{0}' as i32 as libc::c_char;
    }
    tmp___0 = strlen(str as *const libc::c_char);
    i = tmp___0 as libc::c_int;
    while i > 0 as libc::c_int {
        if !(*str.offset(i as isize) as libc::c_int != 47 as libc::c_int) {
            break;
        }
        i -= 1;
    }
    j = 0 as libc::c_int;
    while *str.offset(j as isize) != 0 {
        if !(*str.offset(j as isize) as libc::c_int != 35 as libc::c_int) {
            break;
        }
        tmp___1 = __ctype_b_loc();
        if *(*tmp___1).offset(*str.offset(j as isize) as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int != 0
        {
            break;
        }
        j += 1;
    }
    if *str.offset(i as isize) as libc::c_int != 47 as libc::c_int {
        if (*this).scheme as libc::c_uint == 3 as libc::c_uint {
            (*this)
                .path = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        } else {
            tmp___2 = xmalloc(2 as libc::c_int as size_t);
            (*this).path = tmp___2 as *mut libc::c_char;
            tmp___3 = xmalloc(2 as libc::c_int as size_t);
            (*this).request = tmp___3 as *mut libc::c_char;
            strncpy(
                (*this).path,
                b"/\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int as size_t,
            );
            strncpy(
                (*this).request,
                b"/\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int as size_t,
            );
            *((*this).path)
                .offset(1 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            *((*this).request)
                .offset(1 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        tmp___4 = xmalloc((i + 2 as libc::c_int) as size_t);
        (*this).path = tmp___4 as *mut libc::c_char;
        memcpy(
            (*this).path as *mut libc::c_void,
            str as *const libc::c_void,
            (i + 1 as libc::c_int) as size_t,
        );
        *((*this).path).offset(i as isize) = '/' as i32 as libc::c_char;
        *((*this).path)
            .offset((i + 1 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
        if (*this).scheme as libc::c_uint == 3 as libc::c_uint {
            if *((*this).path).offset(0 as libc::c_int as isize) as libc::c_int
                == 47 as libc::c_int
            {
                tmp___5 = strlen((*this).path as *const libc::c_char);
                memmove(
                    (*this).path as *mut libc::c_void,
                    ((*this).path).offset(1 as libc::c_int as isize)
                        as *const libc::c_void,
                    tmp___5,
                );
            }
        }
    }
    trim((*this).request);
    str = str.offset((i + 1 as libc::c_int) as isize);
    return str;
}
unsafe extern "C" fn __url_set_file(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if (*this).file as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = strlen((*this).file as *const libc::c_char);
        if tmp > 1 as libc::c_ulong {
            return str;
        }
    }
    i = 0 as libc::c_int;
    while *str.offset(i as isize) != 0 {
        if !(*str.offset(i as isize) as libc::c_int != 59 as libc::c_int) {
            break;
        }
        if !(*str.offset(i as isize) as libc::c_int != 63 as libc::c_int) {
            break;
        }
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*str.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int != 0
        {
            break;
        }
        i += 1;
    }
    tmp___1 = xmalloc((i + 1 as libc::c_int) as size_t);
    (*this).file = tmp___1 as *mut libc::c_char;
    memset(
        (*this).file as *mut libc::c_void,
        '\u{0}' as i32,
        (i + 1 as libc::c_int) as size_t,
    );
    memcpy((*this).file as *mut libc::c_void, str as *const libc::c_void, i as size_t);
    trim((*this).file);
    if *str.offset(i as isize) as libc::c_int == 59 as libc::c_int {
        (*this).hasparams = boolean_true;
        str = str.offset((i + 1 as libc::c_int) as isize);
    } else if *str.offset(i as isize) as libc::c_int == 63 as libc::c_int {
        str = str.offset((i + 1 as libc::c_int) as isize);
    } else {
        str = str.offset(i as isize);
    }
    return str;
}
unsafe extern "C" fn __url_set_parameters(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if (*this).params as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = strlen((*this).params as *const libc::c_char);
        if tmp > 1 as libc::c_ulong {
            return str;
        }
    }
    if (*this).hasparams as libc::c_uint == 0 as libc::c_uint {
        (*this).params = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        return str;
    }
    i = 0 as libc::c_int;
    while *str.offset(i as isize) != 0 {
        if !(*str.offset(i as isize) as libc::c_int != 63 as libc::c_int) {
            break;
        }
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*str.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int != 0
        {
            break;
        }
        i += 1;
    }
    tmp___1 = xmalloc((i + 1 as libc::c_int) as size_t);
    (*this).params = tmp___1 as *mut libc::c_char;
    memset(
        (*this).params as *mut libc::c_void,
        '\u{0}' as i32,
        (i + 1 as libc::c_int) as size_t,
    );
    memcpy((*this).params as *mut libc::c_void, str as *const libc::c_void, i as size_t);
    if *str.offset(i as isize) as libc::c_int == 63 as libc::c_int {
        str = str.offset((i + 1 as libc::c_int) as isize);
    } else {
        str = str.offset(i as isize);
    }
    return str;
}
unsafe extern "C" fn __url_set_query(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*this).query = xstrcat(b"\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if (*this).query as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = strlen((*this).query as *const libc::c_char);
        if tmp > 1 as libc::c_ulong {
            return str;
        }
    }
    i = 0 as libc::c_int;
    while *str.offset(i as isize) != 0 {
        if !(*str.offset(i as isize) as libc::c_int != 35 as libc::c_int) {
            break;
        }
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*str.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int != 0
        {
            break;
        }
        i += 1;
    }
    tmp___1 = xmalloc((i + 1 as libc::c_int) as size_t);
    (*this).query = tmp___1 as *mut libc::c_char;
    memset(
        (*this).query as *mut libc::c_void,
        '\u{0}' as i32,
        (i + 1 as libc::c_int) as size_t,
    );
    memcpy((*this).query as *mut libc::c_void, str as *const libc::c_void, i as size_t);
    if *str.offset(i as isize) as libc::c_int == 35 as libc::c_int {
        str = str.offset((i + 1 as libc::c_int) as isize);
    } else {
        str = str.offset(i as isize);
    }
    return str;
}
unsafe extern "C" fn __url_set_fragment(
    mut this: URL,
    mut str: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if (*this).frag as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = strlen((*this).frag as *const libc::c_char);
        if tmp > 1 as libc::c_ulong {
            return str;
        }
    }
    i = 0 as libc::c_int;
    while *str.offset(i as isize) != 0 {
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*str.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int != 0
        {
            break;
        }
        i += 1;
    }
    tmp___1 = xmalloc((i + 1 as libc::c_int) as size_t);
    (*this).frag = tmp___1 as *mut libc::c_char;
    memcpy((*this).frag as *mut libc::c_void, str as *const libc::c_void, i as size_t);
    str = str.offset((i + 1 as libc::c_int) as isize);
    return str;
}
static mut urlchr_table: [libc::c_uchar; 256] = [
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
];
#[inline]
unsafe extern "C" fn decide_copy_method(mut p: *const libc::c_char) -> copy_method {
    let mut preempt: libc::c_char = 0;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___1: libc::c_int = 0;
    let mut __res___0: libc::c_int = 0;
    let mut tmp___3: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___4: libc::c_int = 0;
    if *p as libc::c_int == 37 as libc::c_int {
        if (((*p.offset(1 as libc::c_int as isize) as libc::c_uint)
            .wrapping_sub(48 as libc::c_uint) & 255 as libc::c_uint)
            .wrapping_mul(18 as libc::c_uint)
            .wrapping_div(17 as libc::c_uint)
            .wrapping_mul(52 as libc::c_uint)
            .wrapping_div(51 as libc::c_uint)
            .wrapping_mul(58 as libc::c_uint)
            .wrapping_div(114 as libc::c_uint)
            .wrapping_mul(13 as libc::c_uint)
            .wrapping_div(11 as libc::c_uint)
            .wrapping_mul(14 as libc::c_uint)
            .wrapping_div(13 as libc::c_uint)
            .wrapping_mul(35 as libc::c_uint)
            .wrapping_add(35 as libc::c_uint)
            .wrapping_div(36 as libc::c_uint)
            .wrapping_mul(35 as libc::c_uint)
            .wrapping_div(33 as libc::c_uint)
            .wrapping_mul(34 as libc::c_uint)
            .wrapping_div(33 as libc::c_uint)
            .wrapping_mul(35 as libc::c_uint)
            .wrapping_div(170 as libc::c_uint) ^ 4 as libc::c_uint)
            .wrapping_sub(3 as libc::c_uint) & 255 as libc::c_uint ^ 1 as libc::c_uint
            <= 2 as libc::c_uint
        {
            if (((*p.offset(2 as libc::c_int as isize) as libc::c_uint)
                .wrapping_sub(48 as libc::c_uint) & 255 as libc::c_uint)
                .wrapping_mul(18 as libc::c_uint)
                .wrapping_div(17 as libc::c_uint)
                .wrapping_mul(52 as libc::c_uint)
                .wrapping_div(51 as libc::c_uint)
                .wrapping_mul(58 as libc::c_uint)
                .wrapping_div(114 as libc::c_uint)
                .wrapping_mul(13 as libc::c_uint)
                .wrapping_div(11 as libc::c_uint)
                .wrapping_mul(14 as libc::c_uint)
                .wrapping_div(13 as libc::c_uint)
                .wrapping_mul(35 as libc::c_uint)
                .wrapping_add(35 as libc::c_uint)
                .wrapping_div(36 as libc::c_uint)
                .wrapping_mul(35 as libc::c_uint)
                .wrapping_div(33 as libc::c_uint)
                .wrapping_mul(34 as libc::c_uint)
                .wrapping_div(33 as libc::c_uint)
                .wrapping_mul(35 as libc::c_uint)
                .wrapping_div(170 as libc::c_uint) ^ 4 as libc::c_uint)
                .wrapping_sub(3 as libc::c_uint) & 255 as libc::c_uint
                ^ 1 as libc::c_uint <= 2 as libc::c_uint
            {
                if (*p.offset(1 as libc::c_int as isize) as libc::c_int)
                    < 65 as libc::c_int
                {
                    tmp___1 = *p.offset(1 as libc::c_int as isize) as libc::c_int
                        - 48 as libc::c_int;
                } else {
                    if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong
                        > 1 as libc::c_ulong
                    {
                        __res = toupper(
                            *p.offset(1 as libc::c_int as isize) as libc::c_int,
                        );
                    } else {
                        tmp___0 = __ctype_toupper_loc();
                        __res = *(*tmp___0)
                            .offset(
                                *p.offset(1 as libc::c_int as isize) as libc::c_int as isize,
                            );
                    }
                    tmp___1 = __res - 65 as libc::c_int + 10 as libc::c_int;
                }
                if (*p.offset(2 as libc::c_int as isize) as libc::c_int)
                    < 65 as libc::c_int
                {
                    tmp___4 = *p.offset(2 as libc::c_int as isize) as libc::c_int
                        - 48 as libc::c_int;
                } else {
                    if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong
                        > 1 as libc::c_ulong
                    {
                        __res___0 = toupper(
                            *p.offset(2 as libc::c_int as isize) as libc::c_int,
                        );
                    } else {
                        tmp___3 = __ctype_toupper_loc();
                        __res___0 = *(*tmp___3)
                            .offset(
                                *p.offset(2 as libc::c_int as isize) as libc::c_int as isize,
                            );
                    }
                    tmp___4 = __res___0 - 65 as libc::c_int + 10 as libc::c_int;
                }
                preempt = ((tmp___1 << 4 as libc::c_int) + tmp___4) as libc::c_char;
                if urlchr_table[preempt as libc::c_uchar as usize] as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    return CM_PASSTHROUGH
                } else if urlchr_table[preempt as libc::c_uchar as usize] as libc::c_int
                        & 1 as libc::c_int != 0
                    {
                    return CM_PASSTHROUGH
                } else {
                    return CM_DECODE
                }
            } else {
                return CM_ENCODE
            }
        } else {
            return CM_ENCODE
        }
    } else if urlchr_table[*p as libc::c_uchar as usize] as libc::c_int
            & 2 as libc::c_int != 0
        {
        if urlchr_table[*p as libc::c_uchar as usize] as libc::c_int & 1 as libc::c_int
            == 0
        {
            return CM_ENCODE
        } else {
            return CM_PASSTHROUGH
        }
    } else {
        return CM_PASSTHROUGH
    };
}
static mut methods: [*const libc::c_char; 9] = [
    b" GET\0" as *const u8 as *const libc::c_char,
    b" HEAD\0" as *const u8 as *const libc::c_char,
    b" POST\0" as *const u8 as *const libc::c_char,
    b" PUT\0" as *const u8 as *const libc::c_char,
    b" TRACE\0" as *const u8 as *const libc::c_char,
    b" DELETE\0" as *const u8 as *const libc::c_char,
    b" OPTIONS\0" as *const u8 as *const libc::c_char,
    b" CONNECT\0" as *const u8 as *const libc::c_char,
    b" PATCH\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn __url_has_method(mut url: *const libc::c_char) -> METHOD {
    let mut i: libc::c_uint = 0;
    let mut r: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    i = 0 as libc::c_uint;
    r = 0 as *mut libc::c_void as *const libc::c_char;
    i = 0 as libc::c_uint;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[*const libc::c_char; 9]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
    {
        tmp = strstr(url, methods[i as usize]);
        r = tmp as *const libc::c_char;
        if r as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            return i as METHOD;
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn __url_escape(mut s: *const libc::c_char) -> *mut libc::c_char {
    let mut p1: *const libc::c_char = 0 as *const libc::c_char;
    let mut newstr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut oldlen: libc::c_int = 0;
    let mut newlen: libc::c_int = 0;
    let mut host_len: libc::c_int = 0;
    let mut path_start: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut host_start: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut encode_count: libc::c_int = 0;
    let mut decode_count: libc::c_int = 0;
    let mut tmp: METHOD = 0;
    let mut tmp___0: copy_method = CM_DECODE;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: copy_method = CM_DECODE;
    let mut c: libc::c_uchar = 0;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __res: libc::c_int = 0;
    let mut tmp___9: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___10: libc::c_int = 0;
    let mut __res___0: libc::c_int = 0;
    let mut tmp___12: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    encode_count = 0 as libc::c_int;
    decode_count = 0 as libc::c_int;
    tmp = __url_has_method(s);
    if tmp as libc::c_uint != 0 as libc::c_uint {
        return s as *mut libc::c_char;
    }
    host_start = strstr(s, b"//\0" as *const u8 as *const libc::c_char);
    if !host_start.is_null() {
        host_start = host_start.offset(2 as libc::c_int as isize);
    } else {
        host_start = s as *mut libc::c_char;
    }
    path_start = strstr(
        host_start as *const libc::c_char,
        b"/\0" as *const u8 as *const libc::c_char,
    );
    if !path_start.is_null() {
        path_start = path_start.offset(1);
    } else {
        return s as *mut libc::c_char
    }
    p1 = path_start as *const libc::c_char;
    while *p1 != 0 {
        tmp___0 = decide_copy_method(p1);
        match tmp___0 as libc::c_uint {
            1 => {
                encode_count += 1;
            }
            0 => {
                decode_count += 1;
            }
            2 | _ => {}
        }
        p1 = p1.offset(1);
    }
    if encode_count == 0 {
        if decode_count == 0 {
            return s as *mut libc::c_char;
        }
    }
    oldlen = p1.offset_from(s) as libc::c_long as libc::c_int;
    host_len = path_start.offset_from(s as *mut libc::c_char) as libc::c_long
        as libc::c_int;
    newlen = oldlen + 2 as libc::c_int * (encode_count - decode_count);
    tmp___1 = xmalloc((newlen + 1 as libc::c_int) as size_t);
    newstr = tmp___1 as *mut libc::c_char;
    memcpy(newstr as *mut libc::c_void, s as *const libc::c_void, host_len as size_t);
    p1 = path_start as *const libc::c_char;
    p2 = newstr.offset(host_len as isize);
    while *p1 != 0 {
        tmp___2 = decide_copy_method(p1);
        match tmp___2 as libc::c_uint {
            1 => {
                tmp___3 = p1;
                p1 = p1.offset(1);
                c = *tmp___3 as libc::c_uchar;
                tmp___4 = p2;
                p2 = p2.offset(1);
                *tmp___4 = '%' as i32 as libc::c_char;
                tmp___5 = p2;
                p2 = p2.offset(1);
                *tmp___5 = *(b"0123456789ABCDEF\0" as *const u8 as *const libc::c_char)
                    .offset((c as libc::c_int >> 4 as libc::c_int) as isize);
                tmp___6 = p2;
                p2 = p2.offset(1);
                *tmp___6 = *(b"0123456789ABCDEF\0" as *const u8 as *const libc::c_char)
                    .offset((c as libc::c_int & 15 as libc::c_int) as isize);
            }
            0 => {
                tmp___7 = p2;
                p2 = p2.offset(1);
                if (*p1.offset(1 as libc::c_int as isize) as libc::c_int)
                    < 65 as libc::c_int
                {
                    tmp___10 = *p1.offset(1 as libc::c_int as isize) as libc::c_int
                        - 48 as libc::c_int;
                } else {
                    if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong
                        > 1 as libc::c_ulong
                    {
                        __res = toupper(
                            *p1.offset(1 as libc::c_int as isize) as libc::c_int,
                        );
                    } else {
                        tmp___9 = __ctype_toupper_loc();
                        __res = *(*tmp___9)
                            .offset(
                                *p1.offset(1 as libc::c_int as isize) as libc::c_int
                                    as isize,
                            );
                    }
                    tmp___10 = __res - 65 as libc::c_int + 10 as libc::c_int;
                }
                if (*p1.offset(2 as libc::c_int as isize) as libc::c_int)
                    < 65 as libc::c_int
                {
                    tmp___13 = *p1.offset(2 as libc::c_int as isize) as libc::c_int
                        - 48 as libc::c_int;
                } else {
                    if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong
                        > 1 as libc::c_ulong
                    {
                        __res___0 = toupper(
                            *p1.offset(2 as libc::c_int as isize) as libc::c_int,
                        );
                    } else {
                        tmp___12 = __ctype_toupper_loc();
                        __res___0 = *(*tmp___12)
                            .offset(
                                *p1.offset(2 as libc::c_int as isize) as libc::c_int
                                    as isize,
                            );
                    }
                    tmp___13 = __res___0 - 65 as libc::c_int + 10 as libc::c_int;
                }
                *tmp___7 = ((tmp___10 << 4 as libc::c_int) + tmp___13) as libc::c_char;
                p1 = p1.offset(3 as libc::c_int as isize);
            }
            2 => {
                tmp___14 = p2;
                p2 = p2.offset(1);
                tmp___15 = p1;
                p1 = p1.offset(1);
                *tmp___14 = *tmp___15;
            }
            _ => {}
        }
    }
    *p2 = '\u{0}' as i32 as libc::c_char;
    return newstr;
}
unsafe extern "C" fn __url_replace(
    mut url: *mut libc::c_char,
    mut needle: *const libc::c_char,
    mut replacement: *const libc::c_char,
) {
    let mut buf: [libc::c_char; 4096] = [0; 4096];
    let mut tmp: libc::c_uint = 0;
    let mut ins: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut str: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut nlen: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut rlen: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: size_t = 0;
    buf[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 4096 as libc::c_uint) {
        buf[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    ins = &mut *buf.as_mut_ptr().offset(0 as libc::c_int as isize) as *mut libc::c_char;
    str = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___0 = url as *const libc::c_char;
    tmp___1 = strlen(needle);
    nlen = tmp___1;
    tmp___2 = strlen(replacement);
    rlen = tmp___2;
    loop {
        tmp___3 = strstr(tmp___0, needle);
        p = tmp___3 as *const libc::c_char;
        if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            strcpy(ins, tmp___0);
            break;
        } else {
            memcpy(
                ins as *mut libc::c_void,
                tmp___0 as *const libc::c_void,
                p.offset_from(tmp___0) as libc::c_long as size_t,
            );
            ins = ins.offset(p.offset_from(tmp___0) as libc::c_long as isize);
            memcpy(ins as *mut libc::c_void, replacement as *const libc::c_void, rlen);
            ins = ins.offset(rlen as isize);
            tmp___0 = p.offset(nlen as isize);
        }
    }
    tmp___8 = strlen(buf.as_mut_ptr() as *const libc::c_char);
    tmp___9 = strlen(url as *const libc::c_char);
    if tmp___8 > tmp___9 {
        tmp___4 = strlen(buf.as_mut_ptr() as *const libc::c_char);
        tmp___5 = realloc(
            url as *mut libc::c_void,
            tmp___4.wrapping_add(1 as libc::c_ulong),
        );
        str = tmp___5 as *mut libc::c_char;
        if str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return;
        }
        url = str;
        tmp___6 = strlen(buf.as_mut_ptr() as *const libc::c_char);
        memset(
            url as *mut libc::c_void,
            '\u{0}' as i32,
            tmp___6.wrapping_add(1 as libc::c_ulong),
        );
    } else {
        tmp___7 = strlen(url as *const libc::c_char);
        memset(url as *mut libc::c_void, '\u{0}' as i32, tmp___7);
    }
    tmp___10 = strlen(buf.as_mut_ptr() as *const libc::c_char);
    strncpy(url, buf.as_mut_ptr() as *const libc::c_char, tmp___10);
}
pub unsafe extern "C" fn parse_time(mut p: *mut libc::c_char) {
    let mut x: size_t = 0;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __res: libc::c_int = 0;
    let mut tmp___2: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___3: size_t = 0;
    x = 0 as libc::c_int as size_t;
    my.secs = 0 as libc::c_int;
    my.time = my.secs;
    loop {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*p.offset(x as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & 2048 as libc::c_int == 0
        {
            break;
        }
        x = x.wrapping_add(1);
    }
    if x == 0 as libc::c_ulong {
        return;
    }
    tmp___0 = substring(p, 0 as libc::c_int, x as libc::c_int);
    my.time = atoi(tmp___0 as *const libc::c_char);
    loop {
        tmp___3 = strlen(p as *const libc::c_char);
        if !(x < tmp___3) {
            break;
        }
        if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = tolower(*p.offset(x as isize) as libc::c_int);
        } else {
            tmp___2 = __ctype_tolower_loc();
            __res = *(*tmp___2).offset(*p.offset(x as isize) as libc::c_int as isize);
        }
        match __res {
            115 => {
                my.secs = my.time;
                my.time = 1 as libc::c_int;
                return;
            }
            109 => {
                my.secs = my.time * 60 as libc::c_int;
                my.time = 1 as libc::c_int;
                return;
            }
            104 => {
                my.secs = my.time * 3600 as libc::c_int;
                my.time = 1 as libc::c_int;
                return;
            }
            _ => {}
        }
        x = x.wrapping_add(1);
    }
    if my.time > 0 as libc::c_int {
        if my.secs <= 0 as libc::c_int {
            my.secs = my.time * 60 as libc::c_int;
        }
    }
}
pub unsafe extern "C" fn substring(
    mut str: *mut libc::c_char,
    mut start___0: libc::c_int,
    mut len: libc::c_int,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    if len < 1 as libc::c_int {
        return 0 as *mut libc::c_void as *mut libc::c_char
    } else {
        if start___0 < 0 as libc::c_int {
            return 0 as *mut libc::c_void as *mut libc::c_char
        } else {
            tmp = strlen(str as *const libc::c_char);
            if start___0 > tmp as libc::c_int {
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
        }
    }
    tmp___1 = strlen(str as *const libc::c_char);
    if start___0 + len > tmp___1 as libc::c_int {
        tmp___0 = strlen(str as *const libc::c_char);
        len = tmp___0.wrapping_sub(start___0 as size_t) as libc::c_int;
    }
    tmp___2 = xmalloc((len + 1 as libc::c_int) as size_t);
    ret = tmp___2 as *mut libc::c_char;
    res = ret;
    ptr = str;
    end = str;
    i = 0 as libc::c_int;
    while i < start___0 {
        i += 1;
        ptr = ptr.offset(1);
    }
    i = 0 as libc::c_int;
    while i < start___0 + len {
        i += 1;
        end = end.offset(1);
    }
    while (ptr as libc::c_ulong) < end as libc::c_ulong {
        tmp___3 = res;
        res = res.offset(1);
        tmp___4 = ptr;
        ptr = ptr.offset(1);
        *tmp___3 = *tmp___4;
    }
    *res = 0 as libc::c_int as libc::c_char;
    return ret;
}
pub unsafe extern "C" fn okay(mut code: libc::c_int) -> BOOLEAN {
    let mut tmp: libc::c_int = 0;
    if code >= 100 as libc::c_int {
        if code <= 299 as libc::c_int {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as BOOLEAN;
}
pub unsafe extern "C" fn strmatch(
    mut option: *mut libc::c_char,
    mut param: *mut libc::c_char,
) -> BOOLEAN {
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: size_t = 0;
    tmp = strlen(param as *const libc::c_char);
    tmp___0 = strncasecmp(
        option as *const libc::c_char,
        param as *const libc::c_char,
        tmp,
    );
    if tmp___0 != 0 {
        return boolean_false
    } else {
        tmp___1 = strlen(option as *const libc::c_char);
        tmp___2 = strlen(param as *const libc::c_char);
        if tmp___1 == tmp___2 { return boolean_true } else { return boolean_false }
    };
}
pub unsafe extern "C" fn startswith(
    mut pre: *const libc::c_char,
    mut str: *const libc::c_char,
) -> BOOLEAN {
    let mut lenpre: size_t = 0;
    let mut tmp: size_t = 0;
    let mut lenstr: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = strlen(pre);
    lenpre = tmp;
    tmp___0 = strlen(str);
    lenstr = tmp___0;
    if lenstr < lenpre {
        tmp___2 = 0 as libc::c_int;
    } else {
        tmp___1 = strncmp(pre, str, lenpre);
        tmp___2 = (tmp___1 == 0 as libc::c_int) as libc::c_int;
    }
    return tmp___2 as BOOLEAN;
}
pub unsafe extern "C" fn endswith(
    mut suffix: *const libc::c_char,
    mut str: *const libc::c_char,
) -> BOOLEAN {
    let mut lenstr: size_t = 0;
    let mut tmp: size_t = 0;
    let mut lensuffix: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    if str.is_null() {
        return boolean_false
    } else {
        if suffix.is_null() {
            return boolean_false;
        }
    }
    tmp = strlen(str);
    lenstr = tmp;
    tmp___0 = strlen(suffix);
    lensuffix = tmp___0;
    if lensuffix > lenstr {
        return boolean_false;
    }
    tmp___1 = strncmp(
        str.offset(lenstr as isize).offset(-(lensuffix as isize)),
        suffix,
        lensuffix,
    );
    return (tmp___1 == 0 as libc::c_int) as libc::c_int as BOOLEAN;
}
pub unsafe extern "C" fn uppercase(
    mut s: *mut libc::c_char,
    mut len: size_t,
) -> *mut libc::c_char {
    let mut c: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut e: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    c = s as *mut libc::c_uchar;
    e = c.offset(len as isize);
    while (c as libc::c_ulong) < e as libc::c_ulong {
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = toupper(*c as libc::c_int);
        } else {
            tmp___0 = __ctype_toupper_loc();
            __res = *(*tmp___0).offset(*c as libc::c_int as isize);
        }
        *c = __res as libc::c_uchar;
        c = c.offset(1);
    }
    return s;
}
pub unsafe extern "C" fn lowercase(
    mut s: *mut libc::c_char,
    mut len: size_t,
) -> *mut libc::c_char {
    let mut c: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut e: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    c = s as *mut libc::c_uchar;
    e = c.offset(len as isize);
    while (c as libc::c_ulong) < e as libc::c_ulong {
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = tolower(*c as libc::c_int);
        } else {
            tmp___0 = __ctype_tolower_loc();
            __res = *(*tmp___0).offset(*c as libc::c_int as isize);
        }
        *c = __res as libc::c_uchar;
        c = c.offset(1);
    }
    return s;
}
pub unsafe extern "C" fn stristr(
    mut haystack: *const libc::c_char,
    mut needle: *const libc::c_char,
) -> *mut libc::c_char {
    let mut h: *const libc::c_char = 0 as *const libc::c_char;
    let mut n: *const libc::c_char = 0 as *const libc::c_char;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut __res___0: libc::c_int = 0;
    let mut tmp___2: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        h = haystack;
        n = needle;
        loop {
            if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                > 1 as libc::c_ulong
            {
                __res = tolower(*h as libc::c_uchar as libc::c_int);
            } else {
                tmp___0 = __ctype_tolower_loc();
                __res = *(*tmp___0).offset(*h as libc::c_uchar as libc::c_int as isize);
            }
            if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                > 1 as libc::c_ulong
            {
                __res___0 = tolower(*n as libc::c_uchar as libc::c_int);
            } else {
                tmp___2 = __ctype_tolower_loc();
                __res___0 = *(*tmp___2)
                    .offset(*n as libc::c_uchar as libc::c_int as isize);
            }
            if !(__res == __res___0) {
                break;
            }
            if *n == 0 {
                break;
            }
            h = h.offset(1);
            n = n.offset(1);
        }
        if *n as libc::c_int == 0 as libc::c_int {
            return haystack as *mut libc::c_char;
        }
        tmp___3 = haystack;
        haystack = haystack.offset(1);
        if *tmp___3 == 0 {
            break;
        }
    }
    return 0 as *mut libc::c_void as *mut libc::c_char;
}
pub unsafe extern "C" fn pthread_sleep_np(mut secs: libc::c_uint) {
    sleep(secs);
}
pub unsafe extern "C" fn pthread_usleep_np(mut usec: libc::c_ulong) {
    usleep(usec as __useconds_t);
}
pub unsafe extern "C" fn elapsed_time(mut time___0: clock_t) -> libc::c_float {
    let mut tps: libc::c_long = 0;
    let mut tmp: libc::c_long = 0;
    tmp = sysconf(2 as libc::c_int);
    tps = tmp;
    return time___0 as libc::c_float / tps as libc::c_float;
}
pub unsafe extern "C" fn echo(mut fmt: *const libc::c_char, mut args: ...) {
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut ap: ::std::ffi::VaListImpl;
    let mut tmp: size_t = 0;
    if my.quiet as u64 != 0 {
        return;
    }
    if my.get as u64 != 0 {
        ap = args.clone();
        vsnprintf(
            buf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            fmt,
            ap.as_va_list(),
        );
        printf(b"%s\0" as *const u8 as *const libc::c_char, buf.as_mut_ptr());
        fflush(stdout);
        return;
    }
    if my.debug as u64 != 0 {
        ap = args.clone();
        vsnprintf(
            buf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            fmt,
            ap.as_va_list(),
        );
        tmp = strlen(buf.as_mut_ptr() as *const libc::c_char);
        if tmp == 1 as libc::c_ulong {
            printf(b"%s\0" as *const u8 as *const libc::c_char, buf.as_mut_ptr());
        } else {
            NOTIFY(DEBUG, buf.as_mut_ptr() as *const libc::c_char);
        }
    }
}
pub unsafe extern "C" fn debug(mut fmt: *const libc::c_char, mut args: ...) {
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut ap: ::std::ffi::VaListImpl;
    let mut tmp: size_t = 0;
    if my.quiet as u64 != 0 {
        return;
    }
    if my.debug as u64 != 0 {
        ap = args.clone();
        vsnprintf(
            buf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            fmt,
            ap.as_va_list(),
        );
        tmp = strlen(buf.as_mut_ptr() as *const libc::c_char);
        if tmp == 1 as libc::c_ulong {
            printf(b"%s\0" as *const u8 as *const libc::c_char, buf.as_mut_ptr());
        } else {
            NOTIFY(DEBUG, buf.as_mut_ptr() as *const libc::c_char);
        }
    }
}
pub unsafe extern "C" fn pthread_rand_np(mut ctx: *mut libc::c_uint) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = rand_r(ctx);
    return tmp;
}
pub unsafe extern "C" fn urandom() -> libc::c_int {
    let mut rand___0: libc::c_int = 0;
    let mut fd: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut tmp: ssize_t = 0;
    rand___0 = -(1 as libc::c_int);
    fd = open(b"/dev/urandom\0" as *const u8 as *const libc::c_char, 0 as libc::c_int);
    if fd >= 0 as libc::c_int {
        tmp = read(
            fd,
            &mut rand___0 as *mut libc::c_int as *mut libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
        );
        len = tmp as libc::c_int;
        if len == -(1 as libc::c_int) {
            fprintf(
                stderr,
                b"ERROR: failed to open /dev/urandom\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        close(fd);
    }
    return rand___0;
}
pub unsafe extern "C" fn strnlen(
    mut str: *const libc::c_char,
    mut len: size_t,
) -> size_t {
    let mut end: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    tmp = memchr(str as *const libc::c_void, '\u{0}' as i32, len);
    end = tmp as *const libc::c_char;
    if end as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = end.offset_from(str) as libc::c_long as size_t;
    } else {
        tmp___0 = len;
    }
    return tmp___0;
}
pub unsafe extern "C" fn strncasestr(
    mut str1: *const libc::c_char,
    mut str2: *const libc::c_char,
    mut len: size_t,
) -> *const libc::c_char {
    let mut str1_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut str2_len: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut i: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strnlen(str1, len);
    str1_len = tmp;
    tmp___0 = strlen(str2);
    str2_len = tmp___0;
    if str1_len < 1 as libc::c_ulong {
        return 0 as *mut libc::c_void as *const libc::c_char
    } else {
        if str2_len < 1 as libc::c_ulong {
            return 0 as *mut libc::c_void as *const libc::c_char;
        }
    }
    i = 0 as libc::c_int as size_t;
    while i < str1_len.wrapping_sub(str2_len).wrapping_add(1 as libc::c_ulong) {
        tmp___1 = strncasecmp(str1, str2, str2_len);
        if tmp___1 == 0 as libc::c_int {
            return str1;
        }
        str1 = str1.offset(1);
        i = i.wrapping_add(1);
    }
    return 0 as *mut libc::c_void as *const libc::c_char;
}
pub static mut version_string: *const libc::c_char = b"4.1.1\0" as *const u8
    as *const libc::c_char;
pub static mut program_name: *const libc::c_char = b"siege\0" as *const u8
    as *const libc::c_char;
pub static mut author_name: *const libc::c_char = b"Jeffrey Fulmer, et al.\0"
    as *const u8 as *const libc::c_char;
pub static mut email_address: *const libc::c_char = b"jeff@joedog.org\0" as *const u8
    as *const libc::c_char;
pub static mut years: *const libc::c_char = b"1999-2021\0" as *const u8
    as *const libc::c_char;
pub static mut copyright: *const libc::c_char = b"Copyright (C) 2021 by Jeffrey Fulmer, et al.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.\n\0"
    as *const u8 as *const libc::c_char;
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
