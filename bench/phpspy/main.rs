use ::libc;
use ::c2rust_bitfields;
use ::c2rust_asm_casts;
use c2rust_asm_casts::AsmCastTrait;
use std::arch::asm;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type re_dfa_t;
    fn __errno_location() -> *mut libc::c_int;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    static mut optarg: *mut libc::c_char;
    static mut optind: libc::c_int;
    fn getopt_long(
        ___argc: libc::c_int,
        ___argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
        __longopts: *const option,
        __longind: *mut libc::c_int,
    ) -> libc::c_int;
    fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> libc::c_int;
    fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
    fn sigaction(
        __sig: libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> libc::c_int;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn asprintf(
        __ptr: *mut *mut libc::c_char,
        __fmt: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn perror(__s: *const libc::c_char);
    fn fileno(__stream: *mut FILE) -> libc::c_int;
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    fn strtoull(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulonglong;
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strtok(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn ptrace(__request: __ptrace_request, _: ...) -> libc::c_long;
    fn __fxstat(
        __ver: libc::c_int,
        __fildes: libc::c_int,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn process_vm_readv(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: libc::c_ulong,
        __rvec: *const iovec,
        __riovcnt: libc::c_ulong,
        __flags: libc::c_ulong,
    ) -> ssize_t;
    fn waitpid(
        __pid: __pid_t,
        __stat_loc: *mut libc::c_int,
        __options: libc::c_int,
    ) -> __pid_t;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;
    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;
    fn execvp(
        __file: *const libc::c_char,
        __argv: *const *mut libc::c_char,
    ) -> libc::c_int;
    fn getpid() -> __pid_t;
    fn fork() -> __pid_t;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn ioctl(__fd: libc::c_int, __request: libc::c_ulong, _: ...) -> libc::c_int;
    fn tcgetattr(__fd: libc::c_int, __termios_p: *mut termios) -> libc::c_int;
    fn tcsetattr(
        __fd: libc::c_int,
        __optional_actions: libc::c_int,
        __termios_p: *const termios,
    ) -> libc::c_int;
    fn cfmakeraw(__termios_p: *mut termios);
    fn wcwidth(__c: wchar_t) -> libc::c_int;
    fn regcomp(
        __preg: *mut regex_t,
        __pattern: *const libc::c_char,
        __cflags: libc::c_int,
    ) -> libc::c_int;
    fn regfree(__preg: *mut regex_t);
    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option::<
            unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
    fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
    fn sigfillset(__set: *mut sigset_t) -> libc::c_int;
    fn sigprocmask(
        __how: libc::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn alarm(__seconds: libc::c_uint) -> libc::c_uint;
    fn kill(__pid: __pid_t, __sig: libc::c_int) -> libc::c_int;
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: Option::<
            unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
        >,
    );
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
    fn gettimeofday(__tv: *mut timeval, __tz: *mut libc::c_void) -> libc::c_int;
    fn dup(__fd: libc::c_int) -> libc::c_int;
    fn regexec(
        __preg: *const regex_t,
        __String: *const libc::c_char,
        __nmatch: size_t,
        __pmatch: *mut regmatch_t,
        __eflags: libc::c_int,
    ) -> libc::c_int;
    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
    fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __clock_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __clockid_t = libc::c_int;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type size_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iovec {
    pub iov_base: *mut libc::c_void,
    pub iov_len: size_t,
}
pub type pid_t = __pid_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct option {
    pub name: *const libc::c_char,
    pub has_arg: libc::c_int,
    pub flag: *mut libc::c_int,
    pub val: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type clockid_t = __clockid_t;
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___sigset_t_991265788 {
    pub __val: [libc::c_ulong; 16],
}
pub type __sigset_t = __anonstruct___sigset_t_991265788;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
}
pub type __sigval_t = sigval;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__kill_244518854 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__timer_490064738 {
    pub si_tid: libc::c_int,
    pub si_overrun: libc::c_int,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__rt_619254530 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigchld_284671705 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__addr_bnd_5259977 {
    pub _lower: *mut libc::c_void,
    pub _upper: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion__bounds_814482283 {
    pub _addr_bnd: __anonstruct__addr_bnd_5259977,
    pub _pkey: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigfault_168944780 {
    pub si_addr: *mut libc::c_void,
    pub si_addr_lsb: libc::c_short,
    pub _bounds: __anonunion__bounds_814482283,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigpoll_386613454 {
    pub si_band: libc::c_long,
    pub si_fd: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigsys_44812255 {
    pub _call_addr: *mut libc::c_void,
    pub _syscall: libc::c_int,
    pub _arch: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion__sifields_339798158 {
    pub _pad: [libc::c_int; 28],
    pub _kill: __anonstruct__kill_244518854,
    pub _timer: __anonstruct__timer_490064738,
    pub _rt: __anonstruct__rt_619254530,
    pub _sigchld: __anonstruct__sigchld_284671705,
    pub _sigfault: __anonstruct__sigfault_168944780,
    pub _sigpoll: __anonstruct__sigpoll_386613454,
    pub _sigsys: __anonstruct__sigsys_44812255,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_siginfo_t_201813247 {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub __pad0: libc::c_int,
    pub _sifields: __anonunion__sifields_339798158,
}
pub type siginfo_t = __anonstruct_siginfo_t_201813247;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion___sigaction_handler_363639592 {
    pub sa_handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    pub sa_sigaction: Option::<
        unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigaction {
    pub __sigaction_handler: __anonunion___sigaction_handler_363639592,
    pub sa_mask: __sigset_t,
    pub sa_flags: libc::c_int,
    pub sa_restorer: Option::<unsafe extern "C" fn() -> ()>,
}
pub type __gnuc_va_list = __builtin_va_list;
pub type ptrdiff_t = libc::c_long;
pub type wchar_t = libc::c_int;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type va_list___0 = __gnuc_va_list;
pub type ssize_t = __ssize_t;
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_fd_set_356711149 {
    pub fds_bits: [__fd_mask; 16],
}
pub type fd_set = __anonstruct_fd_set_356711149;
pub type __ptrace_request = libc::c_uint;
pub const PTRACE_GET_SYSCALL_INFO: __ptrace_request = 16910;
pub const PTRACE_SECCOMP_GET_METADATA: __ptrace_request = 16909;
pub const PTRACE_SECCOMP_GET_FILTER: __ptrace_request = 16908;
pub const PTRACE_SETSIGMASK: __ptrace_request = 16907;
pub const PTRACE_GETSIGMASK: __ptrace_request = 16906;
pub const PTRACE_PEEKSIGINFO: __ptrace_request = 16905;
pub const PTRACE_LISTEN: __ptrace_request = 16904;
pub const PTRACE_INTERRUPT: __ptrace_request = 16903;
pub const PTRACE_SEIZE: __ptrace_request = 16902;
pub const PTRACE_SETREGSET: __ptrace_request = 16901;
pub const PTRACE_GETREGSET: __ptrace_request = 16900;
pub const PTRACE_SETSIGINFO: __ptrace_request = 16899;
pub const PTRACE_GETSIGINFO: __ptrace_request = 16898;
pub const PTRACE_GETEVENTMSG: __ptrace_request = 16897;
pub const PTRACE_SETOPTIONS: __ptrace_request = 16896;
pub const PTRACE_SINGLEBLOCK: __ptrace_request = 33;
pub const PTRACE_SYSEMU_SINGLESTEP: __ptrace_request = 32;
pub const PTRACE_SYSEMU: __ptrace_request = 31;
pub const PTRACE_ARCH_PRCTL: __ptrace_request = 30;
pub const PTRACE_SET_THREAD_AREA: __ptrace_request = 26;
pub const PTRACE_GET_THREAD_AREA: __ptrace_request = 25;
pub const PTRACE_SYSCALL: __ptrace_request = 24;
pub const PTRACE_SETFPXREGS: __ptrace_request = 19;
pub const PTRACE_GETFPXREGS: __ptrace_request = 18;
pub const PTRACE_DETACH: __ptrace_request = 17;
pub const PTRACE_ATTACH: __ptrace_request = 16;
pub const PTRACE_SETFPREGS: __ptrace_request = 15;
pub const PTRACE_GETFPREGS: __ptrace_request = 14;
pub const PTRACE_SETREGS: __ptrace_request = 13;
pub const PTRACE_GETREGS: __ptrace_request = 12;
pub const PTRACE_SINGLESTEP: __ptrace_request = 9;
pub const PTRACE_KILL: __ptrace_request = 8;
pub const PTRACE_CONT: __ptrace_request = 7;
pub const PTRACE_POKEUSER: __ptrace_request = 6;
pub const PTRACE_POKEDATA: __ptrace_request = 5;
pub const PTRACE_POKETEXT: __ptrace_request = 4;
pub const PTRACE_PEEKUSER: __ptrace_request = 3;
pub const PTRACE_PEEKDATA: __ptrace_request = 2;
pub const PTRACE_PEEKTEXT: __ptrace_request = 1;
pub const PTRACE_TRACEME: __ptrace_request = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct winsize {
    pub ws_row: libc::c_ushort,
    pub ws_col: libc::c_ushort,
    pub ws_xpixel: libc::c_ushort,
    pub ws_ypixel: libc::c_ushort,
}
pub type cc_t = libc::c_uchar;
pub type speed_t = libc::c_uint;
pub type tcflag_t = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
pub type uintattr_t = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tb_cell {
    pub ch: uint32_t,
    pub fg: uintattr_t,
    pub bg: uintattr_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tb_event {
    pub type_0: uint8_t,
    pub mod_0: uint8_t,
    pub key: uint16_t,
    pub ch: uint32_t,
    pub w: int32_t,
    pub h: int32_t,
    pub x: int32_t,
    pub y: int32_t,
}
pub type __re_long_size_t = libc::c_ulong;
pub type reg_syntax_t = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct re_pattern_buffer {
    pub buffer: *mut re_dfa_t,
    pub allocated: __re_long_size_t,
    pub used: __re_long_size_t,
    pub syntax: reg_syntax_t,
    pub fastmap: *mut libc::c_char,
    pub translate: *mut libc::c_uchar,
    pub re_nsub: size_t,
    #[bitfield(name = "can_be_null", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "regs_allocated", ty = "libc::c_uint", bits = "1..=2")]
    #[bitfield(name = "fastmap_accurate", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "no_sub", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "not_bol", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "not_eol", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "newline_anchor", ty = "libc::c_uint", bits = "7..=7")]
    pub can_be_null_regs_allocated_fastmap_accurate_no_sub_not_bol_not_eol_newline_anchor: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
pub type regex_t = re_pattern_buffer;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_70 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_70,
    pub pad1: [uint8_t; 140],
    pub current_execute_data: *mut zend_execute_data_70,
}
pub type zend_execute_data_70 = _zend_execute_data_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_70 {
    pub opline: *mut zend_op_70,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_70,
    pub pad1: [uint8_t; 24],
    pub prev_execute_data: *mut zend_execute_data_70,
    pub symbol_table: *mut zend_array_70,
}
pub type zend_array_70 = _zend_array_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_70 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_70,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_70 = _Bucket_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_70 {
    pub val: zval_70,
    pub h: uint64_t,
    pub key: *mut zend_string_70,
}
pub type zend_string_70 = _zend_string_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_70 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_70 = _zval_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_70 {
    pub value: zend_value_70,
    pub u1: __anonunion_u1_468731550,
    pub u2: __anonunion_u2_346947711,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_346947711 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_468731550 {
    pub v: __anonstruct_v_569059773,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_569059773 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_70 = _zend_value_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_70 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_70,
    pub arr: *mut zend_array_70,
}
pub type zend_function_70 = _zend_function_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_70 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_869165211,
    pub op_array: zend_op_array_70,
}
pub type zend_op_array_70 = _zend_op_array_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_70 {
    pub pad0: [uint8_t; 72],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 4],
    pub vars: *mut *mut zend_string_70,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_70,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_869165211 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_70,
    pub scope: *mut zend_class_entry_70,
}
pub type zend_class_entry_70 = _zend_class_entry_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_70 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_70,
}
pub type zend_op_70 = _zend_op_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_70 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_70 = _zend_executor_globals_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_70 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_70 = _sapi_request_info_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_70 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_70,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_70 = _sapi_globals_struct_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_70 {
    pub mm_heap: *mut zend_mm_heap_70,
}
pub type zend_mm_heap_70 = _zend_mm_heap_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_70 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_70 = _zend_alloc_globals_70;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_71 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_71,
    pub pad1: [uint8_t; 140],
    pub current_execute_data: *mut zend_execute_data_71,
}
pub type zend_execute_data_71 = _zend_execute_data_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_71 {
    pub opline: *mut zend_op_71,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_71,
    pub pad1: [uint8_t; 16],
    pub prev_execute_data: *mut zend_execute_data_71,
    pub symbol_table: *mut zend_array_71,
}
pub type zend_array_71 = _zend_array_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_71 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_71,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_71 = _Bucket_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_71 {
    pub val: zval_71,
    pub h: uint64_t,
    pub key: *mut zend_string_71,
}
pub type zend_string_71 = _zend_string_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_71 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_71 = _zval_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_71 {
    pub value: zend_value_71,
    pub u1: __anonunion_u1_382201446,
    pub u2: __anonunion_u2_569059775,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_569059775 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_382201446 {
    pub v: __anonstruct_v_569059774,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_569059774 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_71 = _zend_value_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_71 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_71,
    pub arr: *mut zend_array_71,
}
pub type zend_function_71 = _zend_function_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_71 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_568689746,
    pub op_array: zend_op_array_71,
}
pub type zend_op_array_71 = _zend_op_array_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_71 {
    pub pad0: [uint8_t; 72],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 4],
    pub vars: *mut *mut zend_string_71,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_71,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_568689746 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_71,
    pub scope: *mut zend_class_entry_71,
}
pub type zend_class_entry_71 = _zend_class_entry_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_71 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_71,
}
pub type zend_op_71 = _zend_op_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_71 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_71 = _zend_executor_globals_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_71 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_71 = _sapi_request_info_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_71 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_71,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_71 = _sapi_globals_struct_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_71 {
    pub mm_heap: *mut zend_mm_heap_71,
}
pub type zend_mm_heap_71 = _zend_mm_heap_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_71 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_71 = _zend_alloc_globals_71;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_72 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_72,
    pub pad1: [uint8_t; 140],
    pub current_execute_data: *mut zend_execute_data_72,
}
pub type zend_execute_data_72 = _zend_execute_data_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_72 {
    pub opline: *mut zend_op_72,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_72,
    pub pad1: [uint8_t; 16],
    pub prev_execute_data: *mut zend_execute_data_72,
    pub symbol_table: *mut zend_array_72,
}
pub type zend_array_72 = _zend_array_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_72 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_72,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_72 = _Bucket_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_72 {
    pub val: zval_72,
    pub h: uint64_t,
    pub key: *mut zend_string_72,
}
pub type zend_string_72 = _zend_string_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_72 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_72 = _zval_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_72 {
    pub value: zend_value_72,
    pub u1: __anonunion_u1_787548746,
    pub u2: __anonunion_u2_997371365,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_997371365 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_787548746 {
    pub v: __anonstruct_v_997371364,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_997371364 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_72 = _zend_value_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_72 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_72,
    pub arr: *mut zend_array_72,
}
pub type zend_function_72 = _zend_function_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_72 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_997371363,
    pub op_array: zend_op_array_72,
}
pub type zend_op_array_72 = _zend_op_array_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_72 {
    pub pad0: [uint8_t; 72],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 4],
    pub vars: *mut *mut zend_string_72,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_72,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_997371363 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_72,
    pub scope: *mut zend_class_entry_72,
}
pub type zend_class_entry_72 = _zend_class_entry_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_72 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_72,
}
pub type zend_op_72 = _zend_op_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_72 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_72 = _zend_executor_globals_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_72 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_72 = _sapi_request_info_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_72 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_72,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_72 = _sapi_globals_struct_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_72 {
    pub mm_heap: *mut zend_mm_heap_72,
}
pub type zend_mm_heap_72 = _zend_mm_heap_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_72 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_72 = _zend_alloc_globals_72;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_73 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_73,
    pub pad1: [uint8_t; 148],
    pub current_execute_data: *mut zend_execute_data_73,
}
pub type zend_execute_data_73 = _zend_execute_data_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_73 {
    pub opline: *mut zend_op_73,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_73,
    pub pad1: [uint8_t; 16],
    pub prev_execute_data: *mut zend_execute_data_73,
    pub symbol_table: *mut zend_array_73,
}
pub type zend_array_73 = _zend_array_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_73 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_73,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_73 = _Bucket_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_73 {
    pub val: zval_73,
    pub h: uint64_t,
    pub key: *mut zend_string_73,
}
pub type zend_string_73 = _zend_string_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_73 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_73 = _zval_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_73 {
    pub value: zend_value_73,
    pub u1: __anonunion_u1_488409722,
    pub u2: __anonunion_u2_997371367,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_997371367 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_488409722 {
    pub v: __anonstruct_v_997371366,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_997371366 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_73 = _zend_value_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_73 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_73,
    pub arr: *mut zend_array_73,
}
pub type zend_function_73 = _zend_function_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_73 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_503990880,
    pub op_array: zend_op_array_73,
}
pub type zend_op_array_73 = _zend_op_array_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_73 {
    pub pad0: [uint8_t; 52],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 32],
    pub vars: *mut *mut zend_string_73,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_73,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_503990880 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_73,
    pub scope: *mut zend_class_entry_73,
}
pub type zend_class_entry_73 = _zend_class_entry_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_73 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_73,
}
pub type zend_op_73 = _zend_op_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_73 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_73 = _zend_executor_globals_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_73 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_73 = _sapi_request_info_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_73 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_73,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_73 = _sapi_globals_struct_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_73 {
    pub mm_heap: *mut zend_mm_heap_73,
}
pub type zend_mm_heap_73 = _zend_mm_heap_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_73 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_73 = _zend_alloc_globals_73;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_74 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_74,
    pub pad1: [uint8_t; 148],
    pub current_execute_data: *mut zend_execute_data_74,
}
pub type zend_execute_data_74 = _zend_execute_data_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_74 {
    pub opline: *mut zend_op_74,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_74,
    pub pad1: [uint8_t; 16],
    pub prev_execute_data: *mut zend_execute_data_74,
    pub symbol_table: *mut zend_array_74,
}
pub type zend_array_74 = _zend_array_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_74 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_74,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_74 = _Bucket_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_74 {
    pub val: zval_74,
    pub h: uint64_t,
    pub key: *mut zend_string_74,
}
pub type zend_string_74 = _zend_string_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_74 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_74 = _zval_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_74 {
    pub value: zend_value_74,
    pub u1: __anonunion_u1_609040281,
    pub u2: __anonunion_u2_997371369,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_997371369 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_609040281 {
    pub v: __anonstruct_v_997371368,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_997371368 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_74 = _zend_value_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_74 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_74,
    pub arr: *mut zend_array_74,
}
pub type zend_function_74 = _zend_function_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_74 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_199519939,
    pub op_array: zend_op_array_74,
}
pub type zend_op_array_74 = _zend_op_array_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_74 {
    pub pad0: [uint8_t; 52],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 40],
    pub vars: *mut *mut zend_string_74,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_74,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_199519939 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_74,
    pub scope: *mut zend_class_entry_74,
}
pub type zend_class_entry_74 = _zend_class_entry_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_74 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_74,
}
pub type zend_op_74 = _zend_op_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_74 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_74 = _zend_executor_globals_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_74 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_74 = _sapi_request_info_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_74 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_74,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_74 = _sapi_globals_struct_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_74 {
    pub mm_heap: *mut zend_mm_heap_74,
}
pub type zend_mm_heap_74 = _zend_mm_heap_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_74 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_74 = _zend_alloc_globals_74;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_80 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_80,
    pub pad1: [uint8_t; 148],
    pub current_execute_data: *mut zend_execute_data_80,
}
pub type zend_execute_data_80 = _zend_execute_data_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_80 {
    pub opline: *mut zend_op_80,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_80,
    pub pad1: [uint8_t; 16],
    pub prev_execute_data: *mut zend_execute_data_80,
    pub symbol_table: *mut zend_array_80,
}
pub type zend_array_80 = _zend_array_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_80 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_80,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_80 = _Bucket_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_80 {
    pub val: zval_80,
    pub h: uint64_t,
    pub key: *mut zend_string_80,
}
pub type zend_string_80 = _zend_string_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_80 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_80 = _zval_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_80 {
    pub value: zend_value_80,
    pub u1: __anonunion_u1_920790402,
    pub u2: __anonunion_u2_997371371,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_997371371 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_920790402 {
    pub v: __anonstruct_v_997371370,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_997371370 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_80 = _zend_value_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_80 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_80,
    pub arr: *mut zend_array_80,
}
pub type zend_function_80 = _zend_function_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_80 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_655473623,
    pub op_array: zend_op_array_80,
}
pub type zend_op_array_80 = _zend_op_array_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_80 {
    pub pad0: [uint8_t; 60],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 40],
    pub vars: *mut *mut zend_string_80,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_80,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_655473623 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_80,
    pub scope: *mut zend_class_entry_80,
}
pub type zend_class_entry_80 = _zend_class_entry_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_80 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_80,
}
pub type zend_op_80 = _zend_op_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_80 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_80 = _zend_executor_globals_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_80 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_80 = _sapi_request_info_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_80 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_80,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_80 = _sapi_globals_struct_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_80 {
    pub mm_heap: *mut zend_mm_heap_80,
}
pub type zend_mm_heap_80 = _zend_mm_heap_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_80 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_80 = _zend_alloc_globals_80;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_executor_globals_81 {
    pub pad0: [uint8_t; 304],
    pub symbol_table: zend_array_81,
    pub pad1: [uint8_t; 148],
    pub current_execute_data: *mut zend_execute_data_81,
}
pub type zend_execute_data_81 = _zend_execute_data_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_execute_data_81 {
    pub opline: *mut zend_op_81,
    pub pad0: [uint8_t; 16],
    pub func: *mut zend_function_81,
    pub pad1: [uint8_t; 16],
    pub prev_execute_data: *mut zend_execute_data_81,
    pub symbol_table: *mut zend_array_81,
}
pub type zend_array_81 = _zend_array_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_array_81 {
    pub pad0: [uint8_t; 12],
    pub nTableMask: uint32_t,
    pub arData: *mut Bucket_81,
    pub nNumUsed: uint32_t,
    pub nNumOfElements: uint32_t,
    pub nTableSize: uint32_t,
}
pub type Bucket_81 = _Bucket_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _Bucket_81 {
    pub val: zval_81,
    pub h: uint64_t,
    pub key: *mut zend_string_81,
}
pub type zend_string_81 = _zend_string_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_string_81 {
    pub pad0: [uint8_t; 16],
    pub len: size_t,
    pub val: [libc::c_char; 1],
}
pub type zval_81 = _zval_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zval_81 {
    pub value: zend_value_81,
    pub u1: __anonunion_u1_671508906,
    pub u2: __anonunion_u2_997371373,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u2_997371373 {
    pub next: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u1_671508906 {
    pub v: __anonstruct_v_997371372,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_v_997371372 {
    pub type_0: uint8_t,
    pub pad0: [uint8_t; 3],
}
pub type zend_value_81 = _zend_value_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_value_81 {
    pub lval: libc::c_long,
    pub dval: libc::c_double,
    pub str_0: *mut zend_string_81,
    pub arr: *mut zend_array_81,
}
pub type zend_function_81 = _zend_function_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union _zend_function_81 {
    pub type_0: uint8_t,
    pub common: __anonstruct_common_762800949,
    pub op_array: zend_op_array_81,
}
pub type zend_op_array_81 = _zend_op_array_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_array_81 {
    pub pad0: [uint8_t; 60],
    pub last_var: libc::c_int,
    pub pad1: [uint8_t; 40],
    pub vars: *mut *mut zend_string_81,
    pub pad2: [uint8_t; 32],
    pub filename: *mut zend_string_81,
    pub line_start: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_common_762800949 {
    pub pad0: [uint8_t; 8],
    pub function_name: *mut zend_string_81,
    pub scope: *mut zend_class_entry_81,
}
pub type zend_class_entry_81 = _zend_class_entry_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_class_entry_81 {
    pub pad0: [uint8_t; 8],
    pub name: *mut zend_string_81,
}
pub type zend_op_81 = _zend_op_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_op_81 {
    pub pad0: [uint8_t; 24],
    pub lineno: uint32_t,
}
pub type zend_executor_globals_81 = _zend_executor_globals_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_request_info_81 {
    pub pad0: [uint8_t; 8],
    pub query_string: *mut libc::c_char,
    pub cookie_data: *mut libc::c_char,
    pub pad1: [uint8_t; 8],
    pub path_translated: *mut libc::c_char,
    pub request_uri: *mut libc::c_char,
}
pub type sapi_request_info_81 = _sapi_request_info_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _sapi_globals_struct_81 {
    pub pad0: [uint8_t; 8],
    pub request_info: sapi_request_info_81,
    pub pad1: [uint8_t; 384],
    pub global_request_time: libc::c_double,
}
pub type sapi_globals_struct_81 = _sapi_globals_struct_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_alloc_globals_81 {
    pub mm_heap: *mut zend_mm_heap_81,
}
pub type zend_mm_heap_81 = _zend_mm_heap_81;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_mm_heap_81 {
    pub pad0: [uint8_t; 16],
    pub size: size_t,
    pub peak: size_t,
}
pub type zend_alloc_globals_81 = _zend_alloc_globals_81;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_hash_handle {
    pub tbl: *mut UT_hash_table,
    pub prev: *mut libc::c_void,
    pub next: *mut libc::c_void,
    pub hh_prev: *mut UT_hash_handle,
    pub hh_next: *mut UT_hash_handle,
    pub key: *mut libc::c_void,
    pub keylen: libc::c_uint,
    pub hashv: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_hash_table {
    pub buckets: *mut UT_hash_bucket,
    pub num_buckets: libc::c_uint,
    pub log2_num_buckets: libc::c_uint,
    pub num_items: libc::c_uint,
    pub tail: *mut UT_hash_handle,
    pub hho: ptrdiff_t,
    pub ideal_chain_maxlen: libc::c_uint,
    pub nonideal_items: libc::c_uint,
    pub ineff_expands: libc::c_uint,
    pub noexpand: libc::c_uint,
    pub signature: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_hash_bucket {
    pub hh_head: *mut UT_hash_handle,
    pub count: libc::c_uint,
    pub expand_mult: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct varpeek_var_s {
    pub name: [libc::c_char; 256],
    pub hh: UT_hash_handle,
}
pub type varpeek_var_t = varpeek_var_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct varpeek_entry_s {
    pub filename_lineno: [libc::c_char; 256],
    pub varmap: *mut varpeek_var_t,
    pub hh: UT_hash_handle,
}
pub type varpeek_entry_t = varpeek_entry_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct glopeek_entry_s {
    pub key: [libc::c_char; 256],
    pub gloname: [libc::c_char; 256],
    pub varname: [libc::c_char; 256],
    pub hh: UT_hash_handle,
}
pub type glopeek_entry_t = glopeek_entry_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_loc_s {
    pub func: [libc::c_char; 256],
    pub class: [libc::c_char; 256],
    pub file: [libc::c_char; 256],
    pub func_len: size_t,
    pub class_len: size_t,
    pub file_len: size_t,
    pub lineno: libc::c_int,
}
pub type trace_loc_t = trace_loc_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_frame_s {
    pub loc: trace_loc_t,
    pub depth: libc::c_int,
}
pub type trace_frame_t = trace_frame_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_request_s {
    pub uri: [libc::c_char; 256],
    pub path: [libc::c_char; 256],
    pub qstring: [libc::c_char; 256],
    pub cookie: [libc::c_char; 256],
    pub ts: libc::c_double,
}
pub type trace_request_t = trace_request_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_mem_s {
    pub size: size_t,
    pub peak: size_t,
}
pub type trace_mem_t = trace_mem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_varpeek_s {
    pub entry: *mut varpeek_entry_t,
    pub var: *mut varpeek_var_t,
    pub zval_str: *mut libc::c_char,
}
pub type trace_varpeek_t = trace_varpeek_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_glopeek_s {
    pub gentry: *mut glopeek_entry_t,
    pub zval_str: *mut libc::c_char,
}
pub type trace_glopeek_t = trace_glopeek_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_target_s {
    pub pid: pid_t,
    pub executor_globals_addr: uint64_t,
    pub sapi_globals_addr: uint64_t,
    pub alloc_globals_addr: uint64_t,
    pub basic_functions_module_addr: uint64_t,
}
pub type trace_target_t = trace_target_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_event_441004094 {
    pub frame: trace_frame_t,
    pub request: trace_request_t,
    pub mem: trace_mem_t,
    pub varpeek: trace_varpeek_t,
    pub glopeek: trace_glopeek_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trace_context_s {
    pub target: trace_target_t,
    pub event: __anonstruct_event_441004094,
    pub event_udata: *mut libc::c_void,
    pub event_handler: Option::<
        unsafe extern "C" fn(*mut trace_context_s, libc::c_int) -> libc::c_int,
    >,
    pub buf: [libc::c_char; 256],
    pub buf_len: size_t,
}
pub type trace_context_t = trace_context_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct addr_memo_s {
    pub php_bin_path: [libc::c_char; 256],
    pub php_bin_path_root: [libc::c_char; 256],
    pub php_base_addr: uint64_t,
}
pub type addr_memo_t = addr_memo_s;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct _zend_module_entry {
    pub pad0: [uint8_t; 88],
    pub version: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bytebuf_t {
    pub buf: *mut libc::c_char,
    pub len: size_t,
    pub cap: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cellbuf_t {
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub cells: *mut tb_cell,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cap_trie_t {
    pub c: libc::c_char,
    pub children: *mut cap_trie_t,
    pub nchildren: size_t,
    pub is_leaf: libc::c_int,
    pub key: uint16_t,
    pub mod_0: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tb_global_t {
    pub ttyfd: libc::c_int,
    pub rfd: libc::c_int,
    pub wfd: libc::c_int,
    pub ttyfd_open: libc::c_int,
    pub resize_pipefd: [libc::c_int; 2],
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub cursor_x: libc::c_int,
    pub cursor_y: libc::c_int,
    pub last_x: libc::c_int,
    pub last_y: libc::c_int,
    pub fg: uintattr_t,
    pub bg: uintattr_t,
    pub last_fg: uintattr_t,
    pub last_bg: uintattr_t,
    pub input_mode: libc::c_int,
    pub output_mode: libc::c_int,
    pub terminfo: *mut libc::c_char,
    pub nterminfo: size_t,
    pub caps: [*const libc::c_char; 36],
    pub cap_trie: cap_trie_t,
    pub in_0: bytebuf_t,
    pub out: bytebuf_t,
    pub back: cellbuf_t,
    pub front: cellbuf_t,
    pub orig_tios: termios,
    pub has_orig_tios: libc::c_int,
    pub last_errno: libc::c_int,
    pub initialized: libc::c_int,
    pub fn_extract_esc_pre: Option::<
        unsafe extern "C" fn(*mut tb_event, *mut size_t) -> libc::c_int,
    >,
    pub fn_extract_esc_post: Option::<
        unsafe extern "C" fn(*mut tb_event, *mut size_t) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_builtin_terms_737686262 {
    pub name: *const libc::c_char,
    pub caps: *mut *const libc::c_char,
    pub alias: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_builtin_mod_caps_1052271791 {
    pub cap: *const libc::c_char,
    pub key: uint16_t,
    pub mod_0: uint8_t,
}
pub type type_0 = libc::c_uint;
pub const TYPE_MAX: type_0 = 3;
pub const TYPE_1015: type_0 = 2;
pub const TYPE_1006: type_0 = 1;
pub const TYPE_VT200: type_0 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___wseq32_112954846 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_419419941 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __anonstruct___wseq32_112954846,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___g1_start32_349613680 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_349613679 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __anonstruct___g1_start32_349613680,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __annonCompField1: __anonunion____missing_field_name_419419941,
    pub __annonCompField2: __anonunion____missing_field_name_349613679,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_condattr_t_488594145 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_condattr_t = __anonunion_pthread_condattr_t_488594145;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_cond_t_951761805 {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type pthread_cond_t = __anonunion_pthread_cond_t_951761805;
pub type sigset_t = __sigset_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct func_entry_s {
    pub func: [libc::c_char; 256],
    pub count_excl: libc::c_ulong,
    pub count_incl: libc::c_ulong,
    pub total_count_excl: libc::c_ulong,
    pub total_count_incl: libc::c_ulong,
    pub percent_excl: libc::c_float,
    pub hh: UT_hash_handle,
}
pub type func_entry_t = func_entry_s;
pub type regoff_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_regmatch_t_1035675074 {
    pub rm_so: regoff_t,
    pub rm_eo: regoff_t,
}
pub type regmatch_t = __anonstruct_regmatch_t_1035675074;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct event_handler_fout_udata_s {
    pub fd: libc::c_int,
    pub buf: *mut libc::c_char,
    pub cur: *mut libc::c_char,
    pub buf_size: size_t,
    pub rem: size_t,
}
pub type event_handler_fout_udata_t = event_handler_fout_udata_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_callgrind_callee_t_105864190 {
    pub loc_str: [libc::c_char; 256],
    pub loc: trace_loc_t,
    pub inclusive: uint64_t,
    pub count: uint64_t,
    pub hh: UT_hash_handle,
}
pub type callgrind_callee_t = __anonstruct_callgrind_callee_t_105864190;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_callgrind_caller_t_89571561 {
    pub loc_str: [libc::c_char; 256],
    pub loc: trace_loc_t,
    pub exclusive: uint64_t,
    pub callees: *mut callgrind_callee_t,
    pub hh: UT_hash_handle,
}
pub type callgrind_caller_t = __anonstruct_callgrind_caller_t_89571561;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_callgrind_udata_t_855107567 {
    pub self_0: [trace_loc_t; 128],
    pub prev: [trace_loc_t; 128],
    pub self_str: [[libc::c_char; 256]; 128],
    pub prev_str: [[libc::c_char; 256]; 128],
    pub self_len: libc::c_int,
    pub prev_len: libc::c_int,
    pub fout: *mut FILE,
    pub callers: *mut callgrind_caller_t,
}
pub type callgrind_udata_t = __anonstruct_callgrind_udata_t_855107567;
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp as libc::c_int;
}
#[inline]
unsafe extern "C" fn fstat(
    mut __fd: libc::c_int,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __fxstat(1 as libc::c_int, __fd, __statbuf);
    return tmp;
}
static mut global: tb_global_t = {
    let mut init = tb_global_t {
        ttyfd: 0 as libc::c_int,
        rfd: 0 as libc::c_int,
        wfd: 0 as libc::c_int,
        ttyfd_open: 0 as libc::c_int,
        resize_pipefd: [0 as libc::c_int, 0 as libc::c_int],
        width: 0 as libc::c_int,
        height: 0 as libc::c_int,
        cursor_x: 0 as libc::c_int,
        cursor_y: 0 as libc::c_int,
        last_x: 0 as libc::c_int,
        last_y: 0 as libc::c_int,
        fg: 0 as libc::c_int as libc::c_ushort,
        bg: 0 as libc::c_int as libc::c_ushort,
        last_fg: 0 as libc::c_int as libc::c_ushort,
        last_bg: 0 as libc::c_int as libc::c_ushort,
        input_mode: 0 as libc::c_int,
        output_mode: 0 as libc::c_int,
        terminfo: 0 as *const libc::c_char as *mut libc::c_char,
        nterminfo: 0 as libc::c_ulong,
        caps: [
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
            0 as *const libc::c_char,
        ],
        cap_trie: {
            let mut init = cap_trie_t {
                c: 0 as libc::c_int as libc::c_char,
                children: 0 as *const cap_trie_t as *mut cap_trie_t,
                nchildren: 0 as libc::c_ulong,
                is_leaf: 0 as libc::c_int,
                key: 0 as libc::c_int as libc::c_ushort,
                mod_0: 0 as libc::c_int as libc::c_uchar,
            };
            init
        },
        in_0: {
            let mut init = bytebuf_t {
                buf: 0 as *const libc::c_char as *mut libc::c_char,
                len: 0 as libc::c_ulong,
                cap: 0 as libc::c_ulong,
            };
            init
        },
        out: {
            let mut init = bytebuf_t {
                buf: 0 as *const libc::c_char as *mut libc::c_char,
                len: 0 as libc::c_ulong,
                cap: 0 as libc::c_ulong,
            };
            init
        },
        back: {
            let mut init = cellbuf_t {
                width: 0 as libc::c_int,
                height: 0 as libc::c_int,
                cells: 0 as *const tb_cell as *mut tb_cell,
            };
            init
        },
        front: {
            let mut init = cellbuf_t {
                width: 0 as libc::c_int,
                height: 0 as libc::c_int,
                cells: 0 as *const tb_cell as *mut tb_cell,
            };
            init
        },
        orig_tios: {
            let mut init = termios {
                c_iflag: 0 as libc::c_uint,
                c_oflag: 0 as libc::c_uint,
                c_cflag: 0 as libc::c_uint,
                c_lflag: 0 as libc::c_uint,
                c_line: 0 as libc::c_int as libc::c_uchar,
                c_cc: [
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                    0 as libc::c_int as libc::c_uchar,
                ],
                c_ispeed: 0 as libc::c_uint,
                c_ospeed: 0 as libc::c_uint,
            };
            init
        },
        has_orig_tios: 0 as libc::c_int,
        last_errno: 0 as libc::c_int,
        initialized: 0 as libc::c_int,
        fn_extract_esc_pre: None,
        fn_extract_esc_post: None,
    };
    init
};
static mut terminfo_cap_indexes: [int16_t; 36] = [
    66 as libc::c_int as int16_t,
    68 as libc::c_int as int16_t,
    69 as libc::c_int as int16_t,
    70 as libc::c_int as int16_t,
    71 as libc::c_int as int16_t,
    72 as libc::c_int as int16_t,
    73 as libc::c_int as int16_t,
    74 as libc::c_int as int16_t,
    75 as libc::c_int as int16_t,
    67 as libc::c_int as int16_t,
    216 as libc::c_int as int16_t,
    217 as libc::c_int as int16_t,
    77 as libc::c_int as int16_t,
    59 as libc::c_int as int16_t,
    76 as libc::c_int as int16_t,
    164 as libc::c_int as int16_t,
    82 as libc::c_int as int16_t,
    81 as libc::c_int as int16_t,
    87 as libc::c_int as int16_t,
    61 as libc::c_int as int16_t,
    79 as libc::c_int as int16_t,
    83 as libc::c_int as int16_t,
    148 as libc::c_int as int16_t,
    28 as libc::c_int as int16_t,
    40 as libc::c_int as int16_t,
    16 as libc::c_int as int16_t,
    13 as libc::c_int as int16_t,
    5 as libc::c_int as int16_t,
    39 as libc::c_int as int16_t,
    36 as libc::c_int as int16_t,
    27 as libc::c_int as int16_t,
    26 as libc::c_int as int16_t,
    311 as libc::c_int as int16_t,
    34 as libc::c_int as int16_t,
    89 as libc::c_int as int16_t,
    88 as libc::c_int as int16_t,
];
static mut xterm_caps: [*const libc::c_char; 36] = [
    b"\x1BOP\0" as *const u8 as *const libc::c_char,
    b"\x1BOQ\0" as *const u8 as *const libc::c_char,
    b"\x1BOR\0" as *const u8 as *const libc::c_char,
    b"\x1BOS\0" as *const u8 as *const libc::c_char,
    b"\x1B[15~\0" as *const u8 as *const libc::c_char,
    b"\x1B[17~\0" as *const u8 as *const libc::c_char,
    b"\x1B[18~\0" as *const u8 as *const libc::c_char,
    b"\x1B[19~\0" as *const u8 as *const libc::c_char,
    b"\x1B[20~\0" as *const u8 as *const libc::c_char,
    b"\x1B[21~\0" as *const u8 as *const libc::c_char,
    b"\x1B[23~\0" as *const u8 as *const libc::c_char,
    b"\x1B[24~\0" as *const u8 as *const libc::c_char,
    b"\x1B[2~\0" as *const u8 as *const libc::c_char,
    b"\x1B[3~\0" as *const u8 as *const libc::c_char,
    b"\x1BOH\0" as *const u8 as *const libc::c_char,
    b"\x1BOF\0" as *const u8 as *const libc::c_char,
    b"\x1B[5~\0" as *const u8 as *const libc::c_char,
    b"\x1B[6~\0" as *const u8 as *const libc::c_char,
    b"\x1BOA\0" as *const u8 as *const libc::c_char,
    b"\x1BOB\0" as *const u8 as *const libc::c_char,
    b"\x1BOD\0" as *const u8 as *const libc::c_char,
    b"\x1BOC\0" as *const u8 as *const libc::c_char,
    b"\x1B[Z\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1049h\x1B[22;0;0t\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1049l\x1B[23;0;0t\0" as *const u8 as *const libc::c_char,
    b"\x1B[?12l\x1B[?25h\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25l\0" as *const u8 as *const libc::c_char,
    b"\x1B[H\x1B[2J\0" as *const u8 as *const libc::c_char,
    b"\x1B(B\x1B[m\0" as *const u8 as *const libc::c_char,
    b"\x1B[4m\0" as *const u8 as *const libc::c_char,
    b"\x1B[1m\0" as *const u8 as *const libc::c_char,
    b"\x1B[5m\0" as *const u8 as *const libc::c_char,
    b"\x1B[3m\0" as *const u8 as *const libc::c_char,
    b"\x1B[7m\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1h\x1B=\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1l\x1B>\0" as *const u8 as *const libc::c_char,
];
static mut linux_caps: [*const libc::c_char; 36] = [
    b"\x1B[[A\0" as *const u8 as *const libc::c_char,
    b"\x1B[[B\0" as *const u8 as *const libc::c_char,
    b"\x1B[[C\0" as *const u8 as *const libc::c_char,
    b"\x1B[[D\0" as *const u8 as *const libc::c_char,
    b"\x1B[[E\0" as *const u8 as *const libc::c_char,
    b"\x1B[17~\0" as *const u8 as *const libc::c_char,
    b"\x1B[18~\0" as *const u8 as *const libc::c_char,
    b"\x1B[19~\0" as *const u8 as *const libc::c_char,
    b"\x1B[20~\0" as *const u8 as *const libc::c_char,
    b"\x1B[21~\0" as *const u8 as *const libc::c_char,
    b"\x1B[23~\0" as *const u8 as *const libc::c_char,
    b"\x1B[24~\0" as *const u8 as *const libc::c_char,
    b"\x1B[2~\0" as *const u8 as *const libc::c_char,
    b"\x1B[3~\0" as *const u8 as *const libc::c_char,
    b"\x1B[1~\0" as *const u8 as *const libc::c_char,
    b"\x1B[4~\0" as *const u8 as *const libc::c_char,
    b"\x1B[5~\0" as *const u8 as *const libc::c_char,
    b"\x1B[6~\0" as *const u8 as *const libc::c_char,
    b"\x1B[A\0" as *const u8 as *const libc::c_char,
    b"\x1B[B\0" as *const u8 as *const libc::c_char,
    b"\x1B[D\0" as *const u8 as *const libc::c_char,
    b"\x1B[C\0" as *const u8 as *const libc::c_char,
    b"\x1B[Z\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25h\x1B[?0c\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25l\x1B[?1c\0" as *const u8 as *const libc::c_char,
    b"\x1B[H\x1B[J\0" as *const u8 as *const libc::c_char,
    b"\x1B[m\x0F\0" as *const u8 as *const libc::c_char,
    b"\x1B[4m\0" as *const u8 as *const libc::c_char,
    b"\x1B[1m\0" as *const u8 as *const libc::c_char,
    b"\x1B[5m\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\x1B[7m\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
];
static mut screen_caps: [*const libc::c_char; 36] = [
    b"\x1BOP\0" as *const u8 as *const libc::c_char,
    b"\x1BOQ\0" as *const u8 as *const libc::c_char,
    b"\x1BOR\0" as *const u8 as *const libc::c_char,
    b"\x1BOS\0" as *const u8 as *const libc::c_char,
    b"\x1B[15~\0" as *const u8 as *const libc::c_char,
    b"\x1B[17~\0" as *const u8 as *const libc::c_char,
    b"\x1B[18~\0" as *const u8 as *const libc::c_char,
    b"\x1B[19~\0" as *const u8 as *const libc::c_char,
    b"\x1B[20~\0" as *const u8 as *const libc::c_char,
    b"\x1B[21~\0" as *const u8 as *const libc::c_char,
    b"\x1B[23~\0" as *const u8 as *const libc::c_char,
    b"\x1B[24~\0" as *const u8 as *const libc::c_char,
    b"\x1B[2~\0" as *const u8 as *const libc::c_char,
    b"\x1B[3~\0" as *const u8 as *const libc::c_char,
    b"\x1B[1~\0" as *const u8 as *const libc::c_char,
    b"\x1B[4~\0" as *const u8 as *const libc::c_char,
    b"\x1B[5~\0" as *const u8 as *const libc::c_char,
    b"\x1B[6~\0" as *const u8 as *const libc::c_char,
    b"\x1BOA\0" as *const u8 as *const libc::c_char,
    b"\x1BOB\0" as *const u8 as *const libc::c_char,
    b"\x1BOD\0" as *const u8 as *const libc::c_char,
    b"\x1BOC\0" as *const u8 as *const libc::c_char,
    b"\x1B[Z\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1049h\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1049l\0" as *const u8 as *const libc::c_char,
    b"\x1B[34h\x1B[?25h\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25l\0" as *const u8 as *const libc::c_char,
    b"\x1B[H\x1B[J\0" as *const u8 as *const libc::c_char,
    b"\x1B[m\x0F\0" as *const u8 as *const libc::c_char,
    b"\x1B[4m\0" as *const u8 as *const libc::c_char,
    b"\x1B[1m\0" as *const u8 as *const libc::c_char,
    b"\x1B[5m\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\x1B[7m\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1h\x1B=\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1l\x1B>\0" as *const u8 as *const libc::c_char,
];
static mut rxvt_256color_caps: [*const libc::c_char; 36] = [
    b"\x1B[11~\0" as *const u8 as *const libc::c_char,
    b"\x1B[12~\0" as *const u8 as *const libc::c_char,
    b"\x1B[13~\0" as *const u8 as *const libc::c_char,
    b"\x1B[14~\0" as *const u8 as *const libc::c_char,
    b"\x1B[15~\0" as *const u8 as *const libc::c_char,
    b"\x1B[17~\0" as *const u8 as *const libc::c_char,
    b"\x1B[18~\0" as *const u8 as *const libc::c_char,
    b"\x1B[19~\0" as *const u8 as *const libc::c_char,
    b"\x1B[20~\0" as *const u8 as *const libc::c_char,
    b"\x1B[21~\0" as *const u8 as *const libc::c_char,
    b"\x1B[23~\0" as *const u8 as *const libc::c_char,
    b"\x1B[24~\0" as *const u8 as *const libc::c_char,
    b"\x1B[2~\0" as *const u8 as *const libc::c_char,
    b"\x1B[3~\0" as *const u8 as *const libc::c_char,
    b"\x1B[7~\0" as *const u8 as *const libc::c_char,
    b"\x1B[8~\0" as *const u8 as *const libc::c_char,
    b"\x1B[5~\0" as *const u8 as *const libc::c_char,
    b"\x1B[6~\0" as *const u8 as *const libc::c_char,
    b"\x1B[A\0" as *const u8 as *const libc::c_char,
    b"\x1B[B\0" as *const u8 as *const libc::c_char,
    b"\x1B[D\0" as *const u8 as *const libc::c_char,
    b"\x1B[C\0" as *const u8 as *const libc::c_char,
    b"\x1B[Z\0" as *const u8 as *const libc::c_char,
    b"\x1B7\x1B[?47h\0" as *const u8 as *const libc::c_char,
    b"\x1B[2J\x1B[?47l\x1B8\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25h\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25l\0" as *const u8 as *const libc::c_char,
    b"\x1B[H\x1B[2J\0" as *const u8 as *const libc::c_char,
    b"\x1B[m\x0F\0" as *const u8 as *const libc::c_char,
    b"\x1B[4m\0" as *const u8 as *const libc::c_char,
    b"\x1B[1m\0" as *const u8 as *const libc::c_char,
    b"\x1B[5m\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\x1B[7m\0" as *const u8 as *const libc::c_char,
    b"\x1B=\0" as *const u8 as *const libc::c_char,
    b"\x1B>\0" as *const u8 as *const libc::c_char,
];
static mut rxvt_unicode_caps: [*const libc::c_char; 36] = [
    b"\x1B[11~\0" as *const u8 as *const libc::c_char,
    b"\x1B[12~\0" as *const u8 as *const libc::c_char,
    b"\x1B[13~\0" as *const u8 as *const libc::c_char,
    b"\x1B[14~\0" as *const u8 as *const libc::c_char,
    b"\x1B[15~\0" as *const u8 as *const libc::c_char,
    b"\x1B[17~\0" as *const u8 as *const libc::c_char,
    b"\x1B[18~\0" as *const u8 as *const libc::c_char,
    b"\x1B[19~\0" as *const u8 as *const libc::c_char,
    b"\x1B[20~\0" as *const u8 as *const libc::c_char,
    b"\x1B[21~\0" as *const u8 as *const libc::c_char,
    b"\x1B[23~\0" as *const u8 as *const libc::c_char,
    b"\x1B[24~\0" as *const u8 as *const libc::c_char,
    b"\x1B[2~\0" as *const u8 as *const libc::c_char,
    b"\x1B[3~\0" as *const u8 as *const libc::c_char,
    b"\x1B[7~\0" as *const u8 as *const libc::c_char,
    b"\x1B[8~\0" as *const u8 as *const libc::c_char,
    b"\x1B[5~\0" as *const u8 as *const libc::c_char,
    b"\x1B[6~\0" as *const u8 as *const libc::c_char,
    b"\x1B[A\0" as *const u8 as *const libc::c_char,
    b"\x1B[B\0" as *const u8 as *const libc::c_char,
    b"\x1B[D\0" as *const u8 as *const libc::c_char,
    b"\x1B[C\0" as *const u8 as *const libc::c_char,
    b"\x1B[Z\0" as *const u8 as *const libc::c_char,
    b"\x1B[?1049h\0" as *const u8 as *const libc::c_char,
    b"\x1B[r\x1B[?1049l\0" as *const u8 as *const libc::c_char,
    b"\x1B[?12l\x1B[?25h\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25l\0" as *const u8 as *const libc::c_char,
    b"\x1B[H\x1B[2J\0" as *const u8 as *const libc::c_char,
    b"\x1B[m\x1B(B\0" as *const u8 as *const libc::c_char,
    b"\x1B[4m\0" as *const u8 as *const libc::c_char,
    b"\x1B[1m\0" as *const u8 as *const libc::c_char,
    b"\x1B[5m\0" as *const u8 as *const libc::c_char,
    b"\x1B[3m\0" as *const u8 as *const libc::c_char,
    b"\x1B[7m\0" as *const u8 as *const libc::c_char,
    b"\x1B=\0" as *const u8 as *const libc::c_char,
    b"\x1B>\0" as *const u8 as *const libc::c_char,
];
static mut eterm_caps: [*const libc::c_char; 36] = [
    b"\x1B[11~\0" as *const u8 as *const libc::c_char,
    b"\x1B[12~\0" as *const u8 as *const libc::c_char,
    b"\x1B[13~\0" as *const u8 as *const libc::c_char,
    b"\x1B[14~\0" as *const u8 as *const libc::c_char,
    b"\x1B[15~\0" as *const u8 as *const libc::c_char,
    b"\x1B[17~\0" as *const u8 as *const libc::c_char,
    b"\x1B[18~\0" as *const u8 as *const libc::c_char,
    b"\x1B[19~\0" as *const u8 as *const libc::c_char,
    b"\x1B[20~\0" as *const u8 as *const libc::c_char,
    b"\x1B[21~\0" as *const u8 as *const libc::c_char,
    b"\x1B[23~\0" as *const u8 as *const libc::c_char,
    b"\x1B[24~\0" as *const u8 as *const libc::c_char,
    b"\x1B[2~\0" as *const u8 as *const libc::c_char,
    b"\x1B[3~\0" as *const u8 as *const libc::c_char,
    b"\x1B[7~\0" as *const u8 as *const libc::c_char,
    b"\x1B[8~\0" as *const u8 as *const libc::c_char,
    b"\x1B[5~\0" as *const u8 as *const libc::c_char,
    b"\x1B[6~\0" as *const u8 as *const libc::c_char,
    b"\x1B[A\0" as *const u8 as *const libc::c_char,
    b"\x1B[B\0" as *const u8 as *const libc::c_char,
    b"\x1B[D\0" as *const u8 as *const libc::c_char,
    b"\x1B[C\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\x1B7\x1B[?47h\0" as *const u8 as *const libc::c_char,
    b"\x1B[2J\x1B[?47l\x1B8\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25h\0" as *const u8 as *const libc::c_char,
    b"\x1B[?25l\0" as *const u8 as *const libc::c_char,
    b"\x1B[H\x1B[2J\0" as *const u8 as *const libc::c_char,
    b"\x1B[m\x0F\0" as *const u8 as *const libc::c_char,
    b"\x1B[4m\0" as *const u8 as *const libc::c_char,
    b"\x1B[1m\0" as *const u8 as *const libc::c_char,
    b"\x1B[5m\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\x1B[7m\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
];
static mut builtin_terms: [__anonstruct_builtin_terms_737686262; 7] = unsafe {
    [
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: b"xterm\0" as *const u8 as *const libc::c_char,
                caps: xterm_caps.as_ptr() as *mut _,
                alias: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: b"linux\0" as *const u8 as *const libc::c_char,
                caps: linux_caps.as_ptr() as *mut _,
                alias: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: b"screen\0" as *const u8 as *const libc::c_char,
                caps: screen_caps.as_ptr() as *mut _,
                alias: b"tmux\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: b"rxvt-256color\0" as *const u8 as *const libc::c_char,
                caps: rxvt_256color_caps.as_ptr() as *mut _,
                alias: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: b"rxvt-unicode\0" as *const u8 as *const libc::c_char,
                caps: rxvt_unicode_caps.as_ptr() as *mut _,
                alias: b"rxvt\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: b"Eterm\0" as *const u8 as *const libc::c_char,
                caps: eterm_caps.as_ptr() as *mut _,
                alias: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = __anonstruct_builtin_terms_737686262 {
                name: 0 as *const libc::c_void as *mut libc::c_void
                    as *const libc::c_char,
                caps: 0 as *const libc::c_void as *mut libc::c_void
                    as *mut *const libc::c_char,
                alias: 0 as *const libc::c_void as *mut libc::c_void
                    as *const libc::c_char,
            };
            init
        },
    ]
};
static mut builtin_mod_caps: [__anonstruct_builtin_mod_caps_1052271791; 313] = [
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8H\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8F\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;2~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;3~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;4~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;5~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;6~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;7~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2;8~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;2~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;3~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;4~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;5~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;6~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;7~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3;8~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;2~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;3~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;4~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;5~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;6~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;7~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5;8~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;2~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;3~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;4~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;5~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;6~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;7~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6;8~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8P\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8Q\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8R\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;2S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;3S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;4S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;5S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;6S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;7S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[1;8S\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;2~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;3~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;4~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;5~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;6~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;7~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15;8~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;2~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;3~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;4~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;5~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;6~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;7~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17;8~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;2~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;3~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;4~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;5~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;6~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;7~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18;8~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;2~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;3~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;4~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;5~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;6~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;7~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19;8~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;2~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;3~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;4~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;5~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;6~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;7~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20;8~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;2~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;3~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;4~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;5~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;6~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;7~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21;8~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;2~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;3~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;4~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;5~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;6~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;7~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23;8~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;2~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;3~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;4~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;5~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;6~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;7~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24;8~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[a\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[a\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOa\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOa\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[b\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[b\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOb\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOb\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[c\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[c\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOc\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOc\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[d\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[d\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOd\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOd\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[7$\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[7~\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[7$\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[7^\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[7@\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[7^\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[7@\0" as *const u8 as *const libc::c_char,
            key: 65521 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[8~\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[8$\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[8^\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[8^\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[8@\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[8@\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[8$\0" as *const u8 as *const libc::c_char,
            key: 65520 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[2~\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[2$\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2^\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[2^\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[2@\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2@\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[2$\0" as *const u8 as *const libc::c_char,
            key: 65523 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[3~\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[3$\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3^\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[3^\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[3@\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3@\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[3$\0" as *const u8 as *const libc::c_char,
            key: 65522 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[5~\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[5$\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5^\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[5^\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[5@\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5@\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[5$\0" as *const u8 as *const libc::c_char,
            key: 65519 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[6~\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[6$\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6^\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[6^\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[6@\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6@\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[6$\0" as *const u8 as *const libc::c_char,
            key: 65518 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[11~\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[23~\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[11^\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[11^\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[23^\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23^\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23~\0" as *const u8 as *const libc::c_char,
            key: 65535 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[12~\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[24~\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[12^\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[12^\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[24^\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24^\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24~\0" as *const u8 as *const libc::c_char,
            key: 65534 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[13~\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[25~\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[13^\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[13^\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[25^\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[25^\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[25~\0" as *const u8 as *const libc::c_char,
            key: 65533 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[14~\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[26~\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[14^\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[14^\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[26^\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[26^\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[26~\0" as *const u8 as *const libc::c_char,
            key: 65532 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[15~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[28~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[15^\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[15^\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[28^\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[28^\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[28~\0" as *const u8 as *const libc::c_char,
            key: 65531 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[17~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[29~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[17^\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[17^\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[29^\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[29^\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[29~\0" as *const u8 as *const libc::c_char,
            key: 65530 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[18~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[31~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[18^\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[18^\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[31^\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[31^\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[31~\0" as *const u8 as *const libc::c_char,
            key: 65529 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[19~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[32~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[19^\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[19^\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[32^\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[32^\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[32~\0" as *const u8 as *const libc::c_char,
            key: 65528 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[20~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[33~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[20^\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[20^\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[33^\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[33^\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[33~\0" as *const u8 as *const libc::c_char,
            key: 65527 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[21~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[34~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[21^\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[21^\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[34^\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[34^\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[34~\0" as *const u8 as *const libc::c_char,
            key: 65526 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[23~\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[23$\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23^\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[23^\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[23@\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23@\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[23$\0" as *const u8 as *const libc::c_char,
            key: 65525 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[24~\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 1 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[24$\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 5 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24^\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[24^\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1B[24@\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 7 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24@\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 6 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[24$\0" as *const u8 as *const libc::c_char,
            key: 65524 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[A\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[B\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[C\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B[D\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOA\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOA\0" as *const u8 as *const libc::c_char,
            key: 65517 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOB\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOB\0" as *const u8 as *const libc::c_char,
            key: 65516 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOC\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOC\0" as *const u8 as *const libc::c_char,
            key: 65514 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1BOD\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: b"\x1B\x1BOD\0" as *const u8 as *const libc::c_char,
            key: 65515 as libc::c_int as uint16_t,
            mod_0: 3 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = __anonstruct_builtin_mod_caps_1052271791 {
            cap: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            key: 0 as libc::c_int as uint16_t,
            mod_0: 0 as libc::c_int as uint8_t,
        };
        init
    },
];
static mut utf8_length: [libc::c_uchar; 256] = [
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
];
static mut utf8_mask: [libc::c_uchar; 6] = [
    127 as libc::c_int as libc::c_uchar,
    31 as libc::c_int as libc::c_uchar,
    15 as libc::c_int as libc::c_uchar,
    7 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
];
pub unsafe extern "C" fn tb_init() -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = tb_init_file(b"/dev/tty\0" as *const u8 as *const libc::c_char);
    return tmp;
}
pub unsafe extern "C" fn tb_init_file(mut path: *const libc::c_char) -> libc::c_int {
    let mut ttyfd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___1: libc::c_int = 0;
    if global.initialized != 0 {
        return -(3 as libc::c_int);
    }
    tmp = open(path, 2 as libc::c_int);
    ttyfd = tmp;
    if ttyfd < 0 as libc::c_int {
        tmp___0 = __errno_location();
        global.last_errno = *tmp___0;
        return -(4 as libc::c_int);
    }
    global.ttyfd_open = 1 as libc::c_int;
    tmp___1 = tb_init_fd(ttyfd);
    return tmp___1;
}
pub unsafe extern "C" fn tb_init_fd(mut ttyfd: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = tb_init_rwfd(ttyfd, ttyfd);
    return tmp;
}
pub unsafe extern "C" fn tb_init_rwfd(
    mut rfd: libc::c_int,
    mut wfd: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tb_reset();
    if rfd == wfd {
        tmp___0 = isatty(rfd);
        if tmp___0 != 0 {
            global.ttyfd = rfd;
        } else {
            global.ttyfd = -(1 as libc::c_int);
        }
    } else {
        global.ttyfd = -(1 as libc::c_int);
    }
    global.rfd = rfd;
    global.wfd = wfd;
    rv = init_term_attrs();
    if !(rv != 0 as libc::c_int) {
        rv = init_term_caps();
        if !(rv != 0 as libc::c_int) {
            rv = init_cap_trie();
            if !(rv != 0 as libc::c_int) {
                rv = init_resize_handler();
                if !(rv != 0 as libc::c_int) {
                    rv = send_init_escape_codes();
                    if !(rv != 0 as libc::c_int) {
                        rv = send_clear();
                        if !(rv != 0 as libc::c_int) {
                            rv = update_term_size();
                            if !(rv != 0 as libc::c_int) {
                                rv = init_cellbuf();
                                if !(rv != 0 as libc::c_int) {
                                    global.initialized = 1 as libc::c_int;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if rv != 0 as libc::c_int {
        tb_deinit();
    }
    return rv;
}
pub unsafe extern "C" fn tb_shutdown() -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    tb_deinit();
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_width() -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    return global.width;
}
pub unsafe extern "C" fn tb_height() -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    return global.height;
}
pub unsafe extern "C" fn tb_clear() -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    tmp = cellbuf_clear(&mut global.back);
    return tmp;
}
pub unsafe extern "C" fn tb_set_clear_attrs(
    mut fg: uintattr_t,
    mut bg: uintattr_t,
) -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    global.fg = fg;
    global.bg = bg;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_present() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut back: *mut tb_cell = 0 as *mut tb_cell;
    let mut front: *mut tb_cell = 0 as *mut tb_cell;
    let mut w: libc::c_int = 0;
    let mut front_wide: *mut tb_cell = 0 as *mut tb_cell;
    let mut tmp: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    global.last_x = -(1 as libc::c_int);
    global.last_y = -(1 as libc::c_int);
    y = 0 as libc::c_int;
    while y < global.front.height {
        x = 0 as libc::c_int;
        while x < global.front.width {
            rv = cellbuf_get(&mut global.back, x, y, &mut back);
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = cellbuf_get(&mut global.front, x, y, &mut front);
            if rv != 0 as libc::c_int {
                return rv;
            }
            w = wcwidth((*back).ch as wchar_t);
            if w < 1 as libc::c_int {
                w = 1 as libc::c_int;
            }
            tmp = cell_cmp(back, front);
            if tmp != 0 as libc::c_int {
                cell_copy(front, back);
                send_attr((*back).fg, (*back).bg);
                let mut current_block_40: u64;
                if w > 1 as libc::c_int {
                    if x >= global.front.width - (w - 1 as libc::c_int) {
                        i = x;
                        while i < global.front.width {
                            send_char(i, y, ' ' as i32 as uint32_t);
                            i += 1;
                        }
                        current_block_40 = 14832935472441733737;
                    } else {
                        current_block_40 = 1852800580797418886;
                    }
                } else {
                    current_block_40 = 1852800580797418886;
                }
                match current_block_40 {
                    1852800580797418886 => {
                        send_char(x, y, (*back).ch);
                        i = 1 as libc::c_int;
                        while i < w {
                            rv = cellbuf_get(
                                &mut global.front,
                                x + i,
                                y,
                                &mut front_wide,
                            );
                            if rv != 0 as libc::c_int {
                                return rv;
                            }
                            rv = cell_set(
                                front_wide,
                                0 as *mut uint32_t,
                                1 as libc::c_int as size_t,
                                (*back).fg,
                                (*back).bg,
                            );
                            if rv != 0 as libc::c_int {
                                return rv;
                            }
                            i += 1;
                        }
                    }
                    _ => {}
                }
            }
            x += w;
        }
        y += 1;
    }
    rv = send_cursor_if(global.cursor_x, global.cursor_y);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_flush(&mut global.out, global.wfd);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_set_cursor(
    mut cx: libc::c_int,
    mut cy: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    if cx < 0 as libc::c_int {
        cx = 0 as libc::c_int;
    }
    if cy < 0 as libc::c_int {
        cy = 0 as libc::c_int;
    }
    if global.cursor_x == -(1 as libc::c_int) {
        rv = bytebuf_puts(&mut global.out, global.caps[25 as libc::c_int as usize]);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    rv = send_cursor_if(cx, cy);
    if rv != 0 as libc::c_int {
        return rv;
    }
    global.cursor_x = cx;
    global.cursor_y = cy;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_hide_cursor() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    if global.cursor_x >= 0 as libc::c_int {
        rv = bytebuf_puts(&mut global.out, global.caps[26 as libc::c_int as usize]);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    global.cursor_x = -(1 as libc::c_int);
    global.cursor_y = -(1 as libc::c_int);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_set_cell(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut ch: uint32_t,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    tmp = tb_set_cell_ex(x, y, &mut ch, 1 as libc::c_int as size_t, fg, bg);
    return tmp;
}
pub unsafe extern "C" fn tb_set_cell_ex(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut ch: *mut uint32_t,
    mut nch: size_t,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut cell: *mut tb_cell = 0 as *mut tb_cell;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    rv = cellbuf_get(&mut global.back, x, y, &mut cell);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cell_set(cell, ch, nch, fg, bg);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_extend_cell(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut ch: uint32_t,
) -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    return -(1 as libc::c_int);
}
pub unsafe extern "C" fn tb_set_input_mode(mut mode: libc::c_int) -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    if mode == 0 as libc::c_int {
        return global.input_mode;
    }
    if mode & 3 as libc::c_int == 0 as libc::c_int {
        mode |= 1 as libc::c_int;
    }
    if mode & 3 as libc::c_int == 3 as libc::c_int {
        mode &= -(3 as libc::c_int);
    }
    if mode & 4 as libc::c_int != 0 {
        bytebuf_puts(
            &mut global.out,
            b"\x1B[?1000h\x1B[?1002h\x1B[?1015h\x1B[?1006h\0" as *const u8
                as *const libc::c_char,
        );
        bytebuf_flush(&mut global.out, global.wfd);
    } else {
        bytebuf_puts(
            &mut global.out,
            b"\x1B[?1006l\x1B[?1015l\x1B[?1002l\x1B[?1000l\0" as *const u8
                as *const libc::c_char,
        );
        bytebuf_flush(&mut global.out, global.wfd);
    }
    global.input_mode = mode;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_set_output_mode(mut mode: libc::c_int) -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    match mode {
        0 => return global.output_mode,
        4 | 3 | 2 | 1 => {
            global.output_mode = mode;
            return 0 as libc::c_int;
        }
        _ => {}
    }
    return -(1 as libc::c_int);
}
pub unsafe extern "C" fn tb_peek_event(
    mut event: *mut tb_event,
    mut timeout_ms: libc::c_int,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    tmp = wait_event(event, timeout_ms);
    return tmp;
}
pub unsafe extern "C" fn tb_poll_event(mut event: *mut tb_event) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    tmp = wait_event(event, -(1 as libc::c_int));
    return tmp;
}
pub unsafe extern "C" fn tb_get_fds(
    mut ttyfd: *mut libc::c_int,
    mut resizefd: *mut libc::c_int,
) -> libc::c_int {
    if global.initialized == 0 {
        return -(8 as libc::c_int);
    }
    *ttyfd = global.rfd;
    *resizefd = global.resize_pipefd[0 as libc::c_int as usize];
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_print(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
    mut str: *const libc::c_char,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = tb_print_ex(x, y, fg, bg, 0 as *mut libc::c_void as *mut size_t, str);
    return tmp;
}
pub unsafe extern "C" fn tb_print_ex(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
    mut out_w: *mut size_t,
    mut str: *const libc::c_char,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut uni: uint32_t = 0;
    let mut w: libc::c_int = 0;
    let mut ix: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    ix = x;
    if !out_w.is_null() {
        *out_w = 0 as libc::c_int as size_t;
    }
    while *str != 0 {
        tmp = tb_utf8_char_to_unicode(&mut uni, str);
        str = str.offset(tmp as isize);
        w = wcwidth(uni as wchar_t);
        if w < 0 as libc::c_int {
            w = 1 as libc::c_int;
        }
        let mut current_block_18: u64;
        if w == 0 as libc::c_int {
            if x > ix {
                rv = tb_extend_cell(x - 1 as libc::c_int, y, uni);
                if rv != 0 as libc::c_int {
                    return rv;
                }
                current_block_18 = 13797916685926291137;
            } else {
                current_block_18 = 14161790689539625060;
            }
        } else {
            current_block_18 = 14161790689539625060;
        }
        match current_block_18 {
            14161790689539625060 => {
                rv = tb_set_cell(x, y, uni, fg, bg);
                if rv != 0 as libc::c_int {
                    return rv;
                }
            }
            _ => {}
        }
        x += w;
        if !out_w.is_null() {
            *out_w = (*out_w as libc::c_ulong).wrapping_add(w as size_t) as size_t
                as size_t;
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_printf(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut vl: ::std::ffi::VaListImpl;
    vl = args.clone();
    rv = tb_printf_inner(
        x,
        y,
        fg,
        bg,
        0 as *mut libc::c_void as *mut size_t,
        fmt,
        vl.as_va_list(),
    );
    return rv;
}
pub unsafe extern "C" fn tb_printf_ex(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
    mut out_w: *mut size_t,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut vl: ::std::ffi::VaListImpl;
    vl = args.clone();
    rv = tb_printf_inner(x, y, fg, bg, out_w, fmt, vl.as_va_list());
    return rv;
}
pub unsafe extern "C" fn tb_send(
    mut buf___0: *const libc::c_char,
    mut nbuf: size_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = bytebuf_nputs(&mut global.out, buf___0, nbuf);
    return tmp;
}
pub unsafe extern "C" fn tb_sendf(
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut buf___0: [libc::c_char; 4096] = [0; 4096];
    let mut vl: ::std::ffi::VaListImpl;
    let mut tmp: libc::c_int = 0;
    vl = args.clone();
    rv = vsnprintf(
        buf___0.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
        fmt,
        vl.as_va_list(),
    );
    if rv < 0 as libc::c_int {
        return -(1 as libc::c_int)
    } else {
        if rv
            >= ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                as libc::c_int
        {
            return -(1 as libc::c_int);
        }
    }
    tmp = tb_send(buf___0.as_mut_ptr() as *const libc::c_char, rv as size_t);
    return tmp;
}
pub unsafe extern "C" fn tb_set_func(
    mut fn_type: libc::c_int,
    mut fn_0: Option::<unsafe extern "C" fn(*mut tb_event, *mut size_t) -> libc::c_int>,
) -> libc::c_int {
    match fn_type {
        0 => {
            global.fn_extract_esc_pre = fn_0;
            return 0 as libc::c_int;
        }
        1 => {
            global.fn_extract_esc_post = fn_0;
            return 0 as libc::c_int;
        }
        _ => {}
    }
    return -(1 as libc::c_int);
}
pub unsafe extern "C" fn tb_cell_buffer() -> *mut tb_cell {
    if global.initialized == 0 {
        return 0 as *mut libc::c_void as *mut tb_cell;
    }
    return global.back.cells;
}
pub unsafe extern "C" fn tb_utf8_char_length(mut c: libc::c_char) -> libc::c_int {
    return utf8_length[c as libc::c_uchar as usize] as libc::c_int;
}
pub unsafe extern "C" fn tb_utf8_char_to_unicode(
    mut out: *mut uint32_t,
    mut c: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut len: libc::c_uchar = 0;
    let mut tmp: libc::c_int = 0;
    let mut mask: libc::c_uchar = 0;
    let mut result: uint32_t = 0;
    if *c as libc::c_int == 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    tmp = tb_utf8_char_length(*c);
    len = tmp as libc::c_uchar;
    mask = utf8_mask[(len as libc::c_int - 1 as libc::c_int) as usize];
    result = (*c.offset(0 as libc::c_int as isize) as libc::c_int & mask as libc::c_int)
        as uint32_t;
    i = 1 as libc::c_int;
    while i < len as libc::c_int {
        result <<= 6 as libc::c_int;
        result
            |= (*c.offset(i as isize) as libc::c_int & 63 as libc::c_int)
                as libc::c_uint;
        i += 1;
    }
    *out = result;
    return len as libc::c_int;
}
pub unsafe extern "C" fn tb_utf8_unicode_to_char(
    mut out: *mut libc::c_char,
    mut c: uint32_t,
) -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut first: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    len = 0 as libc::c_int;
    if c < 128 as libc::c_uint {
        first = 0 as libc::c_int;
        len = 1 as libc::c_int;
    } else if c < 2048 as libc::c_uint {
        first = 192 as libc::c_int;
        len = 2 as libc::c_int;
    } else if c < 65536 as libc::c_uint {
        first = 224 as libc::c_int;
        len = 3 as libc::c_int;
    } else if c < 2097152 as libc::c_uint {
        first = 240 as libc::c_int;
        len = 4 as libc::c_int;
    } else if c < 67108864 as libc::c_uint {
        first = 248 as libc::c_int;
        len = 5 as libc::c_int;
    } else {
        first = 252 as libc::c_int;
        len = 6 as libc::c_int;
    }
    i = len - 1 as libc::c_int;
    while i > 0 as libc::c_int {
        *out
            .offset(
                i as isize,
            ) = (c & 63 as libc::c_uint | 128 as libc::c_uint) as libc::c_char;
        c >>= 6 as libc::c_int;
        i -= 1;
    }
    *out.offset(0 as libc::c_int as isize) = (c | first as libc::c_uint) as libc::c_char;
    return len;
}
pub unsafe extern "C" fn tb_last_errno() -> libc::c_int {
    return global.last_errno;
}
pub unsafe extern "C" fn tb_strerror(mut err: libc::c_int) -> *const libc::c_char {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    match err {
        0 => return b"Success\0" as *const u8 as *const libc::c_char,
        -2 => return b"Not enough input\0" as *const u8 as *const libc::c_char,
        -3 => return b"Termbox initialized already\0" as *const u8 as *const libc::c_char,
        -5 => return b"Out of memory\0" as *const u8 as *const libc::c_char,
        -6 => return b"No event\0" as *const u8 as *const libc::c_char,
        -7 => return b"No TERM in environment\0" as *const u8 as *const libc::c_char,
        -8 => return b"Termbox not initialized\0" as *const u8 as *const libc::c_char,
        -9 => return b"Out of bounds\0" as *const u8 as *const libc::c_char,
        -17 => return b"Unsupported terminal\0" as *const u8 as *const libc::c_char,
        -22 => return b"Termcaps collision\0" as *const u8 as *const libc::c_char,
        -21 => {
            return b"Terminal width/height not received by sscanf() after resize\0"
                as *const u8 as *const libc::c_char;
        }
        _ => {
            tmp = strerror(global.last_errno);
            return tmp as *const libc::c_char;
        }
    };
}
pub unsafe extern "C" fn tb_has_truecolor() -> libc::c_int {
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn tb_has_egc() -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn tb_reset() -> libc::c_int {
    let mut ttyfd_open: libc::c_int = 0;
    ttyfd_open = global.ttyfd_open;
    memset(
        &mut global as *mut tb_global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<tb_global_t>() as libc::c_ulong,
    );
    global.ttyfd = -(1 as libc::c_int);
    global.rfd = -(1 as libc::c_int);
    global.wfd = -(1 as libc::c_int);
    global.ttyfd_open = ttyfd_open;
    global.resize_pipefd[0 as libc::c_int as usize] = -(1 as libc::c_int);
    global.resize_pipefd[1 as libc::c_int as usize] = -(1 as libc::c_int);
    global.width = -(1 as libc::c_int);
    global.height = -(1 as libc::c_int);
    global.cursor_x = -(1 as libc::c_int);
    global.cursor_y = -(1 as libc::c_int);
    global.last_x = -(1 as libc::c_int);
    global.last_y = -(1 as libc::c_int);
    global.fg = 0 as libc::c_int as uintattr_t;
    global.bg = 0 as libc::c_int as uintattr_t;
    global.last_fg = !(global.fg as libc::c_int) as uintattr_t;
    global.last_bg = !(global.bg as libc::c_int) as uintattr_t;
    global.input_mode = 1 as libc::c_int;
    global.output_mode = 1 as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn init_term_attrs() -> libc::c_int {
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_int = 0;
    let mut tios: termios = termios {
        c_iflag: 0,
        c_oflag: 0,
        c_cflag: 0,
        c_lflag: 0,
        c_line: 0,
        c_cc: [0; 32],
        c_ispeed: 0,
        c_ospeed: 0,
    };
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: libc::c_int = 0;
    if global.ttyfd < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    tmp___0 = tcgetattr(global.ttyfd, &mut global.orig_tios);
    if tmp___0 != 0 as libc::c_int {
        tmp = __errno_location();
        global.last_errno = *tmp;
        return -(15 as libc::c_int);
    }
    memcpy(
        &mut tios as *mut termios as *mut libc::c_void,
        &mut global.orig_tios as *mut termios as *const libc::c_void,
        ::std::mem::size_of::<termios>() as libc::c_ulong,
    );
    global.has_orig_tios = 1 as libc::c_int;
    cfmakeraw(&mut tios);
    tios.c_cc[6 as libc::c_int as usize] = 1 as libc::c_int as cc_t;
    tios.c_cc[5 as libc::c_int as usize] = 0 as libc::c_int as cc_t;
    tmp___2 = tcsetattr(
        global.ttyfd,
        2 as libc::c_int,
        &mut tios as *mut termios as *const termios,
    );
    if tmp___2 != 0 as libc::c_int {
        tmp___1 = __errno_location();
        global.last_errno = *tmp___1;
        return -(16 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn tb_printf_inner(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
    mut out_w: *mut size_t,
    mut fmt: *const libc::c_char,
    mut vl: ::std::ffi::VaList,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut buf___0: [libc::c_char; 4096] = [0; 4096];
    let mut tmp: libc::c_int = 0;
    rv = vsnprintf(
        buf___0.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
        fmt,
        vl.as_va_list(),
    );
    if rv < 0 as libc::c_int {
        return -(1 as libc::c_int)
    } else {
        if rv
            >= ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                as libc::c_int
        {
            return -(1 as libc::c_int);
        }
    }
    tmp = tb_print_ex(x, y, fg, bg, out_w, buf___0.as_mut_ptr() as *const libc::c_char);
    return tmp;
}
unsafe extern "C" fn init_term_caps() -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp___0 = load_terminfo();
    if tmp___0 == 0 as libc::c_int {
        tmp = parse_terminfo_caps();
        return tmp;
    }
    tmp___1 = load_builtin_caps();
    return tmp___1;
}
unsafe extern "C" fn init_cap_trie() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 23 as libc::c_int {
        rv = cap_trie_add(
            global.caps[i as usize],
            (65535 as libc::c_int - i) as uint16_t,
            0 as libc::c_int as uint8_t,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while builtin_mod_caps[i as usize].cap as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        rv = cap_trie_add(
            builtin_mod_caps[i as usize].cap,
            builtin_mod_caps[i as usize].key,
            builtin_mod_caps[i as usize].mod_0,
        );
        if rv != 0 as libc::c_int {
            if rv != -(22 as libc::c_int) {
                return rv;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn cap_trie_add(
    mut cap: *const libc::c_char,
    mut key: uint16_t,
    mut mod_0: uint8_t,
) -> libc::c_int {
    let mut next: *mut cap_trie_t = 0 as *mut cap_trie_t;
    let mut node: *mut cap_trie_t = 0 as *mut cap_trie_t;
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut c: libc::c_char = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    node = &mut global.cap_trie;
    i = 0 as libc::c_int as size_t;
    while *cap.offset(i as isize) as libc::c_int != 0 as libc::c_int {
        c = *cap.offset(i as isize);
        next = 0 as *mut libc::c_void as *mut cap_trie_t;
        j = 0 as libc::c_int as size_t;
        while j < (*node).nchildren {
            if (*((*node).children).offset(j as isize)).c as libc::c_int
                == c as libc::c_int
            {
                next = ((*node).children).offset(j as isize);
                break;
            } else {
                j = j.wrapping_add(1);
            }
        }
        if next.is_null() {
            (*node).nchildren = ((*node).nchildren).wrapping_add(1);
            tmp = realloc(
                (*node).children as *mut libc::c_void,
                (::std::mem::size_of::<cap_trie_t>() as libc::c_ulong)
                    .wrapping_mul((*node).nchildren),
            );
            (*node).children = tmp as *mut cap_trie_t;
            if ((*node).children).is_null() {
                return -(5 as libc::c_int);
            }
            next = ((*node).children)
                .offset(((*node).nchildren).wrapping_sub(1 as libc::c_ulong) as isize);
            memset(
                next as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<cap_trie_t>() as libc::c_ulong,
            );
            (*next).c = c;
        }
        node = next;
        i = i.wrapping_add(1);
    }
    if (*node).is_leaf != 0 {
        return -(22 as libc::c_int);
    }
    (*node).is_leaf = 1 as libc::c_int;
    (*node).key = key;
    (*node).mod_0 = mod_0;
    return 0 as libc::c_int;
}
unsafe extern "C" fn cap_trie_find(
    mut buf___0: *const libc::c_char,
    mut nbuf: size_t,
    mut last: *mut *mut cap_trie_t,
    mut depth: *mut size_t,
) -> libc::c_int {
    let mut next: *mut cap_trie_t = 0 as *mut cap_trie_t;
    let mut node: *mut cap_trie_t = 0 as *mut cap_trie_t;
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut c: libc::c_char = 0;
    node = &mut global.cap_trie;
    *last = node;
    *depth = 0 as libc::c_int as size_t;
    i = 0 as libc::c_int as size_t;
    while i < nbuf {
        c = *buf___0.offset(i as isize);
        next = 0 as *mut libc::c_void as *mut cap_trie_t;
        j = 0 as libc::c_int as size_t;
        while j < (*node).nchildren {
            if (*((*node).children).offset(j as isize)).c as libc::c_int
                == c as libc::c_int
            {
                next = ((*node).children).offset(j as isize);
                break;
            } else {
                j = j.wrapping_add(1);
            }
        }
        if next.is_null() {
            return 0 as libc::c_int;
        }
        node = next;
        *last = node;
        *depth = (*depth).wrapping_add(1);
        if (*node).is_leaf != 0 {
            if (*node).nchildren < 1 as libc::c_ulong {
                break;
            }
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn cap_trie_deinit(mut node: *mut cap_trie_t) -> libc::c_int {
    let mut j: size_t = 0;
    j = 0 as libc::c_int as size_t;
    while j < (*node).nchildren {
        cap_trie_deinit(((*node).children).offset(j as isize));
        j = j.wrapping_add(1);
    }
    if !((*node).children).is_null() {
        free((*node).children as *mut libc::c_void);
    }
    memset(
        node as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<cap_trie_t>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn init_resize_handler() -> libc::c_int {
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_int = 0;
    let mut sa: sigaction = sigaction {
        __sigaction_handler: __anonunion___sigaction_handler_363639592 {
            sa_handler: None,
        },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: libc::c_int = 0;
    tmp___0 = pipe((global.resize_pipefd).as_mut_ptr());
    if tmp___0 != 0 as libc::c_int {
        tmp = __errno_location();
        global.last_errno = *tmp;
        return -(12 as libc::c_int);
    }
    memset(
        &mut sa as *mut sigaction as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sigaction>() as libc::c_ulong,
    );
    sa
        .__sigaction_handler
        .sa_handler = Some(handle_resize as unsafe extern "C" fn(libc::c_int) -> ());
    tmp___2 = sigaction(
        28 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    if tmp___2 != 0 as libc::c_int {
        tmp___1 = __errno_location();
        global.last_errno = *tmp___1;
        return -(13 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn send_init_escape_codes() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    rv = bytebuf_puts(&mut global.out, global.caps[23 as libc::c_int as usize]);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_puts(&mut global.out, global.caps[34 as libc::c_int as usize]);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_puts(&mut global.out, global.caps[26 as libc::c_int as usize]);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn send_clear() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    rv = send_attr(global.fg, global.bg);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_puts(&mut global.out, global.caps[27 as libc::c_int as usize]);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = send_cursor_if(global.cursor_x, global.cursor_y);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_flush(&mut global.out, global.wfd);
    if rv != 0 as libc::c_int {
        return rv;
    }
    global.last_x = -(1 as libc::c_int);
    global.last_y = -(1 as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn update_term_size() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut ioctl_errno: libc::c_int = 0;
    let mut sz: winsize = winsize {
        ws_row: 0,
        ws_col: 0,
        ws_xpixel: 0,
        ws_ypixel: 0,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    if global.ttyfd < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    memset(
        &mut sz as *mut winsize as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<winsize>() as libc::c_ulong,
    );
    tmp = ioctl(global.ttyfd, 21523 as libc::c_ulong, &mut sz as *mut winsize);
    if tmp == 0 as libc::c_int {
        global.width = sz.ws_col as libc::c_int;
        global.height = sz.ws_row as libc::c_int;
        return 0 as libc::c_int;
    }
    tmp___0 = __errno_location();
    ioctl_errno = *tmp___0;
    rv = update_term_size_via_esc();
    if rv == 0 as libc::c_int {
        return rv;
    }
    global.last_errno = ioctl_errno;
    return -(11 as libc::c_int);
}
unsafe extern "C" fn update_term_size_via_esc() -> libc::c_int {
    let mut move_and_report: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut write_rv: ssize_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: ssize_t = 0;
    let mut tmp___1: size_t = 0;
    let mut fds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut timeout: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut select_rv: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut buf___0: [libc::c_char; 64] = [0; 64];
    let mut read_rv: ssize_t = 0;
    let mut tmp___4: ssize_t = 0;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rw: libc::c_int = 0;
    let mut rh: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    move_and_report = b"\x1B[9999;9999H\x1B[6n\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    tmp = strlen(move_and_report as *const libc::c_char);
    tmp___0 = write(global.wfd, move_and_report as *const libc::c_void, tmp);
    write_rv = tmp___0;
    tmp___1 = strlen(move_and_report as *const libc::c_char);
    if write_rv != tmp___1 as ssize_t {
        return -(18 as libc::c_int);
    }
    let fresh0 = &mut __d0;
    let fresh1;
    let fresh2 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
    let fresh3 = &mut __d1;
    let fresh4;
    let fresh5 = &mut *(fds.fds_bits).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut __fd_mask;
    asm!(
        "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh0,
        fresh2) => fresh1, inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh3,
        fresh5) => fresh4, inlateout("ax") 0 as libc::c_int => _,
        options(preserves_flags, att_syntax)
    );
    c2rust_asm_casts::AsmCast::cast_out(fresh0, fresh2, fresh1);
    c2rust_asm_casts::AsmCast::cast_out(fresh3, fresh5, fresh4);
    fds
        .fds_bits[(global.rfd
        / (8 as libc::c_int
            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
        as usize]
        |= ((1 as libc::c_ulong)
            << global.rfd
                % (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as __fd_mask;
    timeout.tv_sec = 0 as libc::c_int as __time_t;
    timeout.tv_usec = 1000000 as libc::c_int as __suseconds_t;
    tmp___2 = select(
        global.rfd + 1 as libc::c_int,
        &mut fds as *mut fd_set,
        0 as *mut libc::c_void as *mut fd_set,
        0 as *mut libc::c_void as *mut fd_set,
        &mut timeout as *mut timeval,
    );
    select_rv = tmp___2;
    if select_rv != 1 as libc::c_int {
        tmp___3 = __errno_location();
        global.last_errno = *tmp___3;
        return -(19 as libc::c_int);
    }
    tmp___4 = read(
        global.rfd,
        buf___0.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_ulong),
    );
    read_rv = tmp___4;
    if read_rv < 1 as libc::c_long {
        tmp___5 = __errno_location();
        global.last_errno = *tmp___5;
        return -(20 as libc::c_int);
    }
    buf___0[read_rv as usize] = '\u{0}' as i32 as libc::c_char;
    tmp___6 = sscanf(
        buf___0.as_mut_ptr() as *const libc::c_char,
        b"\x1B[%d;%dR\0" as *const u8 as *const libc::c_char,
        &mut rh as *mut libc::c_int,
        &mut rw as *mut libc::c_int,
    );
    if tmp___6 != 2 as libc::c_int {
        return -(21 as libc::c_int);
    }
    global.width = rw;
    global.height = rh;
    return 0 as libc::c_int;
}
unsafe extern "C" fn init_cellbuf() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    rv = cellbuf_init(&mut global.back, global.width, global.height);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cellbuf_init(&mut global.front, global.width, global.height);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cellbuf_clear(&mut global.back);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cellbuf_clear(&mut global.front);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn tb_deinit() -> libc::c_int {
    let mut __constr_expr_0: sigaction = sigaction {
        __sigaction_handler: __anonunion___sigaction_handler_363639592 {
            sa_handler: None,
        },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    if global.caps[0 as libc::c_int as usize] as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        if global.wfd >= 0 as libc::c_int {
            bytebuf_puts(&mut global.out, global.caps[25 as libc::c_int as usize]);
            bytebuf_puts(&mut global.out, global.caps[28 as libc::c_int as usize]);
            bytebuf_puts(&mut global.out, global.caps[27 as libc::c_int as usize]);
            bytebuf_puts(&mut global.out, global.caps[24 as libc::c_int as usize]);
            bytebuf_puts(&mut global.out, global.caps[35 as libc::c_int as usize]);
            bytebuf_puts(
                &mut global.out,
                b"\x1B[?1006l\x1B[?1015l\x1B[?1002l\x1B[?1000l\0" as *const u8
                    as *const libc::c_char,
            );
            bytebuf_flush(&mut global.out, global.wfd);
        }
    }
    if global.ttyfd >= 0 as libc::c_int {
        if global.has_orig_tios != 0 {
            tcsetattr(
                global.ttyfd,
                2 as libc::c_int,
                &mut global.orig_tios as *mut termios as *const termios,
            );
        }
        if global.ttyfd_open != 0 {
            close(global.ttyfd);
            global.ttyfd_open = 0 as libc::c_int;
        }
    }
    __constr_expr_0.__sigaction_handler.sa_handler = None;
    __constr_expr_0.sa_mask.__val[0 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[1 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[2 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[3 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[4 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[5 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[6 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[7 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[8 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[9 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[10 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[11 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[12 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[13 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[14 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_mask.__val[15 as libc::c_int as usize] = 0 as libc::c_ulong;
    __constr_expr_0.sa_flags = 0 as libc::c_int;
    __constr_expr_0.sa_restorer = None;
    sigaction(
        28 as libc::c_int,
        &mut __constr_expr_0 as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    if global.resize_pipefd[0 as libc::c_int as usize] >= 0 as libc::c_int {
        close(global.resize_pipefd[0 as libc::c_int as usize]);
    }
    if global.resize_pipefd[1 as libc::c_int as usize] >= 0 as libc::c_int {
        close(global.resize_pipefd[1 as libc::c_int as usize]);
    }
    cellbuf_free(&mut global.back);
    cellbuf_free(&mut global.front);
    bytebuf_free(&mut global.in_0);
    bytebuf_free(&mut global.out);
    if !(global.terminfo).is_null() {
        free(global.terminfo as *mut libc::c_void);
    }
    cap_trie_deinit(&mut global.cap_trie);
    tb_reset();
    return 0 as libc::c_int;
}
unsafe extern "C" fn load_terminfo() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp: [libc::c_char; 4096] = [0; 4096];
    let mut term: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut terminfo: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: libc::c_int = 0;
    let mut home: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dirs: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut cdir: *const libc::c_char = 0 as *const libc::c_char;
    tmp___0 = getenv(b"TERM\0" as *const u8 as *const libc::c_char);
    term = tmp___0 as *const libc::c_char;
    if term.is_null() {
        return -(1 as libc::c_int);
    }
    tmp___1 = getenv(b"TERMINFO\0" as *const u8 as *const libc::c_char);
    terminfo = tmp___1 as *const libc::c_char;
    if !terminfo.is_null() {
        tmp___2 = load_terminfo_from_path(terminfo, term);
        return tmp___2;
    }
    tmp___3 = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    home = tmp___3 as *const libc::c_char;
    if !home.is_null() {
        rv = snprintf(
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
            b"%s/.terminfo\0" as *const u8 as *const libc::c_char,
            home,
        );
        if rv < 0 as libc::c_int {
            return -(1 as libc::c_int)
        } else {
            if rv
                >= ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                    as libc::c_int
            {
                return -(1 as libc::c_int);
            }
        }
        rv = load_terminfo_from_path(tmp.as_mut_ptr() as *const libc::c_char, term);
        if rv == 0 as libc::c_int {
            return rv;
        }
    }
    tmp___4 = getenv(b"TERMINFO_DIRS\0" as *const u8 as *const libc::c_char);
    dirs = tmp___4 as *const libc::c_char;
    if !dirs.is_null() {
        rv = snprintf(
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            dirs,
        );
        if rv < 0 as libc::c_int {
            return -(1 as libc::c_int)
        } else {
            if rv
                >= ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                    as libc::c_int
            {
                return -(1 as libc::c_int);
            }
        }
        tmp___5 = strtok(tmp.as_mut_ptr(), b":\0" as *const u8 as *const libc::c_char);
        dir = tmp___5;
        while !dir.is_null() {
            cdir = dir as *const libc::c_char;
            if *cdir as libc::c_int != 0 as libc::c_int {
                rv = load_terminfo_from_path(cdir, term);
                if rv == 0 as libc::c_int {
                    return rv;
                }
            }
            dir = strtok(
                0 as *mut libc::c_void as *mut libc::c_char,
                b":\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    rv = load_terminfo_from_path(
        b"/usr/local/etc/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/usr/local/share/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/usr/local/lib/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/etc/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/usr/share/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/usr/lib/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/usr/share/lib/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    rv = load_terminfo_from_path(
        b"/lib/terminfo\0" as *const u8 as *const libc::c_char,
        term,
    );
    if rv == 0 as libc::c_int {
        return rv;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn load_terminfo_from_path(
    mut path: *const libc::c_char,
    mut term: *const libc::c_char,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp: [libc::c_char; 4096] = [0; 4096];
    rv = snprintf(
        tmp.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
        b"%s/%c/%s\0" as *const u8 as *const libc::c_char,
        path,
        *term.offset(0 as libc::c_int as isize) as libc::c_int,
        term,
    );
    if rv < 0 as libc::c_int {
        return -(1 as libc::c_int)
    } else {
        if rv
            >= ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                as libc::c_int
        {
            return -(1 as libc::c_int);
        }
    }
    rv = read_terminfo_path(tmp.as_mut_ptr() as *const libc::c_char);
    if rv == 0 as libc::c_int {
        return rv;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn read_terminfo_path(mut path: *const libc::c_char) -> libc::c_int {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut tmp: *mut FILE = 0 as *mut FILE;
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut fsize: size_t = 0;
    let mut data: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: size_t = 0;
    tmp = fopen(path, b"rb\0" as *const u8 as *const libc::c_char);
    fp = tmp;
    if fp.is_null() {
        return -(1 as libc::c_int);
    }
    tmp___0 = fileno(fp);
    tmp___1 = fstat(tmp___0, &mut st);
    if tmp___1 != 0 as libc::c_int {
        fclose(fp);
        return -(1 as libc::c_int);
    }
    fsize = st.st_size as size_t;
    tmp___2 = malloc(fsize);
    data = tmp___2 as *mut libc::c_char;
    if data.is_null() {
        fclose(fp);
        return -(1 as libc::c_int);
    }
    tmp___3 = fread(data as *mut libc::c_void, 1 as libc::c_int as size_t, fsize, fp);
    if tmp___3 != fsize {
        fclose(fp);
        free(data as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    global.terminfo = data;
    global.nterminfo = fsize;
    fclose(fp);
    return 0 as libc::c_int;
}
unsafe extern "C" fn parse_terminfo_caps() -> libc::c_int {
    let mut header: *mut int16_t = 0 as *mut int16_t;
    let mut bytes_per_int: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut align_offset: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut pos_str_offsets: libc::c_int = 0;
    let mut pos_str_table: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut cap: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    if global.nterminfo < 6 as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    header = global.terminfo as *mut int16_t;
    if *header.offset(0 as libc::c_int as isize) as libc::c_int == 542 as libc::c_int {
        tmp = 4 as libc::c_int;
    } else {
        tmp = 2 as libc::c_int;
    }
    bytes_per_int = tmp;
    if (*header.offset(1 as libc::c_int as isize) as libc::c_int
        + *header.offset(2 as libc::c_int as isize) as libc::c_int) % 2 as libc::c_int
        != 0 as libc::c_int
    {
        tmp___0 = 1 as libc::c_int;
    } else {
        tmp___0 = 0 as libc::c_int;
    }
    align_offset = tmp___0;
    pos_str_offsets = (6 as libc::c_ulong)
        .wrapping_mul(::std::mem::size_of::<int16_t>() as libc::c_ulong)
        .wrapping_add(*header.offset(1 as libc::c_int as isize) as libc::c_ulong)
        .wrapping_add(*header.offset(2 as libc::c_int as isize) as libc::c_ulong)
        .wrapping_add(align_offset as libc::c_ulong)
        .wrapping_add(
            (*header.offset(3 as libc::c_int as isize) as libc::c_int * bytes_per_int)
                as libc::c_ulong,
        ) as libc::c_int;
    pos_str_table = (pos_str_offsets as libc::c_ulong)
        .wrapping_add(
            (*header.offset(4 as libc::c_int as isize) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<int16_t>() as libc::c_ulong),
        ) as libc::c_int;
    i = 0 as libc::c_int;
    while i < 36 as libc::c_int {
        tmp___1 = get_terminfo_string(
            pos_str_offsets as int16_t,
            pos_str_table as int16_t,
            *header.offset(5 as libc::c_int as isize),
            terminfo_cap_indexes[i as usize],
        );
        cap = tmp___1;
        if cap.is_null() {
            return -(1 as libc::c_int);
        }
        global.caps[i as usize] = cap;
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn load_builtin_caps() -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut term: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = getenv(b"TERM\0" as *const u8 as *const libc::c_char);
    term = tmp as *const libc::c_char;
    if term.is_null() {
        return -(7 as libc::c_int);
    }
    i = 0 as libc::c_int;
    while builtin_terms[i as usize].name as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___0 = strcmp(term, builtin_terms[i as usize].name);
        if tmp___0 == 0 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 36 as libc::c_int {
                global
                    .caps[j
                    as usize] = *(builtin_terms[i as usize].caps).offset(j as isize);
                j += 1;
            }
            return 0 as libc::c_int;
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while builtin_terms[i as usize].name as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___1 = strstr(term, builtin_terms[i as usize].name);
        's_136: {
            let mut current_block_26: u64;
            if !(tmp___1 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                if *builtin_terms[i as usize].alias as libc::c_int != 0 as libc::c_int {
                    tmp___2 = strstr(term, builtin_terms[i as usize].alias);
                    if tmp___2 as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        current_block_26 = 5906734188439846166;
                    } else {
                        current_block_26 = 11057878835866523405;
                    }
                } else {
                    current_block_26 = 11057878835866523405;
                }
                match current_block_26 {
                    5906734188439846166 => {}
                    _ => {
                        break 's_136;
                    }
                }
            }
            j = 0 as libc::c_int;
            while j < 36 as libc::c_int {
                global
                    .caps[j
                    as usize] = *(builtin_terms[i as usize].caps).offset(j as isize);
                j += 1;
            }
            return 0 as libc::c_int;
        }
        i += 1;
    }
    return -(17 as libc::c_int);
}
unsafe extern "C" fn get_terminfo_string(
    mut str_offsets_pos: int16_t,
    mut str_table_pos: int16_t,
    mut str_table_len: int16_t,
    mut str_index: int16_t,
) -> *const libc::c_char {
    let mut str_offset: *const int16_t = 0 as *const int16_t;
    str_offset = (global.terminfo)
        .offset(str_offsets_pos as libc::c_int as isize)
        .offset(
            (str_index as libc::c_int
                * ::std::mem::size_of::<int16_t>() as libc::c_ulong as libc::c_int)
                as isize,
        ) as *mut int16_t as *const int16_t;
    if *str_offset as libc::c_int >= str_table_len as libc::c_int {
        return 0 as *mut libc::c_void as *const libc::c_char;
    }
    if (str_table_pos as libc::c_int + *str_offset as libc::c_int) as size_t
        >= global.nterminfo
    {
        return 0 as *mut libc::c_void as *const libc::c_char;
    }
    return (global.terminfo)
        .offset(str_table_pos as libc::c_int as isize)
        .offset(*str_offset as libc::c_int as isize) as *const libc::c_char;
}
unsafe extern "C" fn wait_event(
    mut event: *mut tb_event,
    mut timeout: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut buf___0: [libc::c_char; 64] = [0; 64];
    let mut fds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut maxfd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut select_rv: libc::c_int = 0;
    let mut tmp___0: *mut timeval = 0 as *mut timeval;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tty_has_events: libc::c_int = 0;
    let mut resize_has_events: libc::c_int = 0;
    let mut read_rv: ssize_t = 0;
    let mut tmp___3: ssize_t = 0;
    let mut tmp___4: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ignore: libc::c_int = 0;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<tb_event>() as libc::c_ulong,
    );
    rv = extract_event(event);
    if rv == 0 as libc::c_int {
        return rv;
    }
    tv.tv_sec = (timeout / 1000 as libc::c_int) as __time_t;
    tv
        .tv_usec = (timeout as __time_t - tv.tv_sec * 1000 as libc::c_long)
        * 1000 as libc::c_long;
    loop {
        let fresh6 = &mut __d0;
        let fresh7;
        let fresh8 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh9 = &mut __d1;
        let fresh10;
        let fresh11 = &mut *(fds.fds_bits).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh6,
            fresh8) => fresh7, inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh9,
            fresh11) => fresh10, inlateout("ax") 0 as libc::c_int => _,
            options(preserves_flags, att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh6, fresh8, fresh7);
        c2rust_asm_casts::AsmCast::cast_out(fresh9, fresh11, fresh10);
        fds
            .fds_bits[(global.rfd
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << global.rfd
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        fds
            .fds_bits[(global.resize_pipefd[0 as libc::c_int as usize]
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << global.resize_pipefd[0 as libc::c_int as usize]
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        if global.resize_pipefd[0 as libc::c_int as usize] > global.rfd {
            tmp = global.resize_pipefd[0 as libc::c_int as usize];
        } else {
            tmp = global.rfd;
        }
        maxfd = tmp;
        if timeout < 0 as libc::c_int {
            tmp___0 = 0 as *mut libc::c_void as *mut timeval;
        } else {
            tmp___0 = &mut tv;
        }
        tmp___1 = select(
            maxfd + 1 as libc::c_int,
            &mut fds as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            tmp___0,
        );
        select_rv = tmp___1;
        if select_rv < 0 as libc::c_int {
            tmp___2 = __errno_location();
            global.last_errno = *tmp___2;
            return -(14 as libc::c_int);
        } else {
            if select_rv == 0 as libc::c_int {
                return -(6 as libc::c_int);
            }
        }
        tty_has_events = (fds
            .fds_bits[(global.rfd
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            & ((1 as libc::c_ulong)
                << global.rfd
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask != 0 as libc::c_long)
            as libc::c_int;
        resize_has_events = (fds
            .fds_bits[(global.resize_pipefd[0 as libc::c_int as usize]
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            & ((1 as libc::c_ulong)
                << global.resize_pipefd[0 as libc::c_int as usize]
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask != 0 as libc::c_long)
            as libc::c_int;
        if tty_has_events != 0 {
            tmp___3 = read(
                global.rfd,
                buf___0.as_mut_ptr() as *mut libc::c_void,
                ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            );
            read_rv = tmp___3;
            if read_rv < 0 as libc::c_long {
                tmp___4 = __errno_location();
                global.last_errno = *tmp___4;
                return -(10 as libc::c_int);
            } else {
                if read_rv > 0 as libc::c_long {
                    bytebuf_nputs(
                        &mut global.in_0,
                        buf___0.as_mut_ptr() as *const libc::c_char,
                        read_rv as size_t,
                    );
                }
            }
        }
        if resize_has_events != 0 {
            ignore = 0 as libc::c_int;
            read(
                global.resize_pipefd[0 as libc::c_int as usize],
                &mut ignore as *mut libc::c_int as *mut libc::c_void,
                ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
            );
            rv = update_term_size();
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = resize_cellbufs();
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*event).type_0 = 2 as libc::c_int as uint8_t;
            (*event).w = global.width;
            (*event).h = global.height;
            return 0 as libc::c_int;
        }
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<tb_event>() as libc::c_ulong,
        );
        rv = extract_event(event);
        if rv == 0 as libc::c_int {
            return rv;
        }
        if !(timeout == -(1 as libc::c_int)) {
            break;
        }
    }
    return rv;
}
unsafe extern "C" fn extract_event(mut event: *mut tb_event) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut in_0: *mut bytebuf_t = 0 as *mut bytebuf_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    in_0 = &mut global.in_0;
    if (*in_0).len == 0 as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    if *((*in_0).buf).offset(0 as libc::c_int as isize) as libc::c_int
        == 27 as libc::c_int
    {
        let mut current_block_10: u64;
        if global.input_mode & 1 as libc::c_int != 0 {
            if !((*in_0).len == 1 as libc::c_ulong) {
                current_block_10 = 11812856957841731496;
            } else {
                current_block_10 = 4166486009154926805;
            }
        } else {
            current_block_10 = 11812856957841731496;
        }
        match current_block_10 {
            11812856957841731496 => {
                rv = extract_esc(event);
                if rv == 0 as libc::c_int {
                    return rv
                } else {
                    if rv == -(2 as libc::c_int) {
                        return rv;
                    }
                }
            }
            _ => {}
        }
        if global.input_mode & 1 as libc::c_int != 0 {
            (*event).type_0 = 1 as libc::c_int as uint8_t;
            (*event).ch = 0 as libc::c_int as uint32_t;
            (*event).key = 27 as libc::c_int as uint16_t;
            (*event).mod_0 = 0 as libc::c_int as uint8_t;
            bytebuf_shift(in_0, 1 as libc::c_int as size_t);
            return 0 as libc::c_int;
        }
        (*event).mod_0 = ((*event).mod_0 as libc::c_int | 1 as libc::c_int) as uint8_t;
        bytebuf_shift(in_0, 1 as libc::c_int as size_t);
        tmp = extract_event(event);
        return tmp;
    }
    's_146: {
        if !((*((*in_0).buf).offset(0 as libc::c_int as isize) as uint16_t
            as libc::c_int) < 32 as libc::c_int)
        {
            if !(*((*in_0).buf).offset(0 as libc::c_int as isize) as libc::c_int
                == 127 as libc::c_int)
            {
                break 's_146;
            }
        }
        (*event).type_0 = 1 as libc::c_int as uint8_t;
        (*event).ch = 0 as libc::c_int as uint32_t;
        (*event).key = *((*in_0).buf).offset(0 as libc::c_int as isize) as uint16_t;
        (*event).mod_0 = ((*event).mod_0 as libc::c_int | 2 as libc::c_int) as uint8_t;
        bytebuf_shift(in_0, 1 as libc::c_int as size_t);
        return 0 as libc::c_int;
    }
    tmp___1 = tb_utf8_char_length(*((*in_0).buf).offset(0 as libc::c_int as isize));
    if (*in_0).len >= tmp___1 as size_t {
        (*event).type_0 = 1 as libc::c_int as uint8_t;
        tb_utf8_char_to_unicode(&mut (*event).ch, (*in_0).buf as *const libc::c_char);
        (*event).key = 0 as libc::c_int as uint16_t;
        tmp___0 = tb_utf8_char_length(*((*in_0).buf).offset(0 as libc::c_int as isize));
        bytebuf_shift(in_0, tmp___0 as size_t);
        return 0 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn extract_esc(mut event: *mut tb_event) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    rv = extract_esc_user(event, 0 as libc::c_int);
    if rv == 0 as libc::c_int {
        return rv
    } else {
        if rv == -(2 as libc::c_int) {
            return rv;
        }
    }
    rv = extract_esc_cap(event);
    if rv == 0 as libc::c_int {
        return rv
    } else {
        if rv == -(2 as libc::c_int) {
            return rv;
        }
    }
    rv = extract_esc_mouse(event);
    if rv == 0 as libc::c_int {
        return rv
    } else {
        if rv == -(2 as libc::c_int) {
            return rv;
        }
    }
    rv = extract_esc_user(event, 1 as libc::c_int);
    if rv == 0 as libc::c_int {
        return rv
    } else {
        if rv == -(2 as libc::c_int) {
            return rv;
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn extract_esc_user(
    mut event: *mut tb_event,
    mut is_post: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut consumed: size_t = 0;
    let mut in_0: *mut bytebuf_t = 0 as *mut bytebuf_t;
    let mut fn_0: Option::<
        unsafe extern "C" fn(*mut tb_event, *mut size_t) -> libc::c_int,
    > = None;
    consumed = 0 as libc::c_int as size_t;
    in_0 = &mut global.in_0;
    if is_post != 0 {
        fn_0 = global.fn_extract_esc_post;
    } else {
        fn_0 = global.fn_extract_esc_pre;
    }
    if fn_0.is_none() {
        return -(1 as libc::c_int);
    }
    rv = (Some(fn_0.expect("non-null function pointer")))
        .expect("non-null function pointer")(event, &mut consumed);
    if rv == 0 as libc::c_int {
        bytebuf_shift(in_0, consumed);
    }
    rv = rv;
    if rv == 0 as libc::c_int {
        return rv
    } else {
        if rv == -(2 as libc::c_int) {
            return rv;
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn extract_esc_cap(mut event: *mut tb_event) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut in_0: *mut bytebuf_t = 0 as *mut bytebuf_t;
    let mut node: *mut cap_trie_t = 0 as *mut cap_trie_t;
    let mut depth: size_t = 0;
    in_0 = &mut global.in_0;
    rv = cap_trie_find(
        (*in_0).buf as *const libc::c_char,
        (*in_0).len,
        &mut node,
        &mut depth,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if (*node).is_leaf != 0 {
        (*event).type_0 = 1 as libc::c_int as uint8_t;
        (*event).ch = 0 as libc::c_int as uint32_t;
        (*event).key = (*node).key;
        (*event).mod_0 = (*node).mod_0;
        bytebuf_shift(in_0, depth);
        return 0 as libc::c_int;
    } else {
        if (*node).nchildren > 0 as libc::c_ulong {
            if (*in_0).len <= depth {
                return -(2 as libc::c_int);
            }
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn extract_esc_mouse(mut event: *mut tb_event) -> libc::c_int {
    let mut in_0: *mut bytebuf_t = 0 as *mut bytebuf_t;
    let mut cmp: [*mut libc::c_char; 3] = [0 as *mut libc::c_char; 3];
    let mut type_0: type_0 = TYPE_VT200;
    let mut ret: libc::c_int = 0;
    let mut size: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut buf_shift: size_t = 0;
    let mut b: libc::c_int = 0;
    let mut fail: libc::c_int = 0;
    let mut index_fail: size_t = 0;
    let mut indices: [size_t; 3] = [0; 3];
    let mut m_is_capital: libc::c_int = 0;
    let mut i: size_t = 0;
    let mut start: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut n1: libc::c_int = 0;
    let mut tmp___2: libc::c_ulong = 0;
    let mut n2: libc::c_int = 0;
    let mut tmp___3: libc::c_ulong = 0;
    let mut n3: libc::c_int = 0;
    let mut tmp___4: libc::c_ulong = 0;
    let mut fail___0: libc::c_int = 0;
    in_0 = &mut global.in_0;
    cmp[0 as libc::c_int
        as usize] = b"\x1B[M\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    cmp[1 as libc::c_int
        as usize] = b"\x1B[<\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    cmp[2 as libc::c_int
        as usize] = b"\x1B[\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    type_0 = TYPE_VT200;
    ret = -(1 as libc::c_int);
    while (type_0 as libc::c_uint) < 3 as libc::c_uint {
        tmp = strlen(cmp[type_0 as usize] as *const libc::c_char);
        size = tmp;
        if (*in_0).len >= size {
            tmp___0 = strncmp(
                cmp[type_0 as usize] as *const libc::c_char,
                (*in_0).buf as *const libc::c_char,
                size,
            );
            if tmp___0 == 0 as libc::c_int {
                break;
            }
        }
        type_0 = (type_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as type_0;
    }
    if type_0 as libc::c_uint == 3 as libc::c_uint {
        ret = -(1 as libc::c_int);
        return ret;
    }
    buf_shift = 0 as libc::c_int as size_t;
    match type_0 as libc::c_uint {
        0 => {
            if (*in_0).len >= 6 as libc::c_ulong {
                b = *((*in_0).buf).offset(3 as libc::c_int as isize) as libc::c_int
                    - 32 as libc::c_int;
                fail = 0 as libc::c_int;
                match b & 3 as libc::c_int {
                    0 => {
                        if b & 64 as libc::c_int != 0 as libc::c_int {
                            (*event).key = 65508 as libc::c_int as uint16_t;
                        } else {
                            (*event).key = 65512 as libc::c_int as uint16_t;
                        }
                    }
                    1 => {
                        if b & 64 as libc::c_int != 0 as libc::c_int {
                            (*event).key = 65507 as libc::c_int as uint16_t;
                        } else {
                            (*event).key = 65510 as libc::c_int as uint16_t;
                        }
                    }
                    2 => {
                        (*event).key = 65511 as libc::c_int as uint16_t;
                    }
                    3 => {
                        (*event).key = 65509 as libc::c_int as uint16_t;
                    }
                    _ => {
                        ret = -(1 as libc::c_int);
                        fail = 1 as libc::c_int;
                    }
                }
                if fail == 0 {
                    if b & 32 as libc::c_int != 0 as libc::c_int {
                        (*event)
                            .mod_0 = ((*event).mod_0 as libc::c_int | 8 as libc::c_int)
                            as uint8_t;
                    }
                    (*event)
                        .x = *((*in_0).buf).offset(4 as libc::c_int as isize) as uint8_t
                        as libc::c_int - 33 as libc::c_int;
                    (*event)
                        .y = *((*in_0).buf).offset(5 as libc::c_int as isize) as uint8_t
                        as libc::c_int - 33 as libc::c_int;
                    ret = 0 as libc::c_int;
                }
                buf_shift = 6 as libc::c_int as size_t;
            }
        }
        2 | 1 => {
            index_fail = -(1 as libc::c_int) as size_t;
            indices[0 as libc::c_int as usize] = index_fail;
            indices[1 as libc::c_int as usize] = index_fail;
            indices[2 as libc::c_int as usize] = index_fail;
            m_is_capital = 0 as libc::c_int;
            i = 0 as libc::c_int as size_t;
            while i < (*in_0).len {
                if *((*in_0).buf).offset(i as isize) as libc::c_int == 59 as libc::c_int
                {
                    if indices[1 as libc::c_int as usize] == index_fail {
                        indices[1 as libc::c_int as usize] = i;
                    } else {
                        indices[2 as libc::c_int as usize] = i;
                    }
                } else if indices[0 as libc::c_int as usize] == index_fail {
                    if *((*in_0).buf).offset(i as isize) as libc::c_int
                        == 109 as libc::c_int
                    {
                        m_is_capital = (*((*in_0).buf).offset(i as isize) as libc::c_int
                            == 77 as libc::c_int) as libc::c_int;
                        indices[0 as libc::c_int as usize] = i;
                    } else if *((*in_0).buf).offset(i as isize) as libc::c_int
                            == 77 as libc::c_int
                        {
                        m_is_capital = (*((*in_0).buf).offset(i as isize) as libc::c_int
                            == 77 as libc::c_int) as libc::c_int;
                        indices[0 as libc::c_int as usize] = i;
                    }
                }
                i = i.wrapping_add(1);
            }
            if indices[0 as libc::c_int as usize] == index_fail {
                ret = -(1 as libc::c_int);
            } else if indices[1 as libc::c_int as usize] == index_fail {
                ret = -(1 as libc::c_int);
            } else if indices[2 as libc::c_int as usize] == index_fail {
                ret = -(1 as libc::c_int);
            } else {
                if type_0 as libc::c_uint == 2 as libc::c_uint {
                    tmp___1 = 2 as libc::c_int;
                } else {
                    tmp___1 = 3 as libc::c_int;
                }
                start = tmp___1;
                tmp___2 = strtoul(
                    ((*in_0).buf).offset(start as isize) as *const libc::c_char,
                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                n1 = tmp___2 as libc::c_int;
                tmp___3 = strtoul(
                    ((*in_0).buf)
                        .offset(
                            (indices[1 as libc::c_int as usize])
                                .wrapping_add(1 as libc::c_ulong) as isize,
                        ) as *const libc::c_char,
                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                n2 = tmp___3 as libc::c_int;
                tmp___4 = strtoul(
                    ((*in_0).buf)
                        .offset(
                            (indices[2 as libc::c_int as usize])
                                .wrapping_add(1 as libc::c_ulong) as isize,
                        ) as *const libc::c_char,
                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                n3 = tmp___4 as libc::c_int;
                if type_0 as libc::c_uint == 2 as libc::c_uint {
                    n1 -= 32 as libc::c_int;
                }
                fail___0 = 0 as libc::c_int;
                match n1 & 3 as libc::c_int {
                    0 => {
                        if n1 & 64 as libc::c_int != 0 as libc::c_int {
                            (*event).key = 65508 as libc::c_int as uint16_t;
                        } else {
                            (*event).key = 65512 as libc::c_int as uint16_t;
                        }
                    }
                    1 => {
                        if n1 & 64 as libc::c_int != 0 as libc::c_int {
                            (*event).key = 65507 as libc::c_int as uint16_t;
                        } else {
                            (*event).key = 65510 as libc::c_int as uint16_t;
                        }
                    }
                    2 => {
                        (*event).key = 65511 as libc::c_int as uint16_t;
                    }
                    3 => {
                        (*event).key = 65509 as libc::c_int as uint16_t;
                    }
                    _ => {
                        ret = -(1 as libc::c_int);
                        fail___0 = 1 as libc::c_int;
                    }
                }
                buf_shift = (*in_0).len;
                if fail___0 == 0 {
                    if m_is_capital == 0 {
                        (*event).key = 65509 as libc::c_int as uint16_t;
                    }
                    if n1 & 32 as libc::c_int != 0 as libc::c_int {
                        (*event)
                            .mod_0 = ((*event).mod_0 as libc::c_int | 8 as libc::c_int)
                            as uint8_t;
                    }
                    (*event).x = n2 as uint8_t as libc::c_int - 1 as libc::c_int;
                    (*event).y = n3 as uint8_t as libc::c_int - 1 as libc::c_int;
                    ret = 0 as libc::c_int;
                }
            }
        }
        3 => {
            ret = -(1 as libc::c_int);
        }
        _ => {}
    }
    if buf_shift > 0 as libc::c_ulong {
        bytebuf_shift(in_0, buf_shift);
    }
    if ret == 0 as libc::c_int {
        (*event).type_0 = 3 as libc::c_int as uint8_t;
    }
    return ret;
}
unsafe extern "C" fn resize_cellbufs() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    rv = cellbuf_resize(&mut global.back, global.width, global.height);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cellbuf_resize(&mut global.front, global.width, global.height);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cellbuf_clear(&mut global.front);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = send_clear();
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn handle_resize(mut sig: libc::c_int) {
    let mut errno_copy: libc::c_int = 0;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    tmp = __errno_location();
    errno_copy = *tmp;
    write(
        global.resize_pipefd[1 as libc::c_int as usize],
        &mut sig as *mut libc::c_int as *const libc::c_void,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
    );
    tmp___0 = __errno_location();
    *tmp___0 = errno_copy;
}
unsafe extern "C" fn send_attr(mut fg: uintattr_t, mut bg: uintattr_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut cfg: uintattr_t = 0;
    let mut cbg: uintattr_t = 0;
    let mut attr_bold: uintattr_t = 0;
    let mut attr_blink: uintattr_t = 0;
    let mut attr_italic: uintattr_t = 0;
    let mut attr_underline: uintattr_t = 0;
    let mut attr_reverse: uintattr_t = 0;
    if fg as libc::c_int == global.last_fg as libc::c_int {
        if bg as libc::c_int == global.last_bg as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    rv = bytebuf_puts(&mut global.out, global.caps[28 as libc::c_int as usize]);
    if rv != 0 as libc::c_int {
        return rv;
    }
    match global.output_mode {
        2 => {
            cfg = (fg as libc::c_int & 255 as libc::c_int) as uintattr_t;
            cbg = (bg as libc::c_int & 255 as libc::c_int) as uintattr_t;
        }
        3 => {
            cfg = (fg as libc::c_int & 255 as libc::c_int) as uintattr_t;
            if cfg as libc::c_int > 215 as libc::c_int {
                cfg = 7 as libc::c_int as uintattr_t;
            }
            cbg = (bg as libc::c_int & 255 as libc::c_int) as uintattr_t;
            if cbg as libc::c_int > 215 as libc::c_int {
                cbg = 0 as libc::c_int as uintattr_t;
            }
            cfg = (cfg as libc::c_int + 16 as libc::c_int) as uintattr_t;
            cbg = (cbg as libc::c_int + 16 as libc::c_int) as uintattr_t;
        }
        4 => {
            cfg = (fg as libc::c_int & 255 as libc::c_int) as uintattr_t;
            if cfg as libc::c_int > 23 as libc::c_int {
                cfg = 23 as libc::c_int as uintattr_t;
            }
            cbg = (bg as libc::c_int & 255 as libc::c_int) as uintattr_t;
            if cbg as libc::c_int > 23 as libc::c_int {
                cbg = 0 as libc::c_int as uintattr_t;
            }
            cfg = (cfg as libc::c_int + 232 as libc::c_int) as uintattr_t;
            cbg = (cbg as libc::c_int + 232 as libc::c_int) as uintattr_t;
        }
        _ => {
            cfg = (fg as libc::c_int & 15 as libc::c_int) as uintattr_t;
            cbg = (bg as libc::c_int & 15 as libc::c_int) as uintattr_t;
        }
    }
    attr_bold = 256 as libc::c_int as uintattr_t;
    attr_blink = 4096 as libc::c_int as uintattr_t;
    attr_italic = 2048 as libc::c_int as uintattr_t;
    attr_underline = 512 as libc::c_int as uintattr_t;
    attr_reverse = 1024 as libc::c_int as uintattr_t;
    if fg as libc::c_int & attr_bold as libc::c_int != 0 {
        rv = bytebuf_puts(&mut global.out, global.caps[30 as libc::c_int as usize]);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    if fg as libc::c_int & attr_blink as libc::c_int != 0 {
        rv = bytebuf_puts(&mut global.out, global.caps[31 as libc::c_int as usize]);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    if fg as libc::c_int & attr_underline as libc::c_int != 0 {
        rv = bytebuf_puts(&mut global.out, global.caps[29 as libc::c_int as usize]);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    if fg as libc::c_int & attr_italic as libc::c_int != 0 {
        rv = bytebuf_puts(&mut global.out, global.caps[32 as libc::c_int as usize]);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    let mut current_block_66: u64;
    if fg as libc::c_int & attr_reverse as libc::c_int != 0 {
        current_block_66 = 2244462385867744796;
    } else if bg as libc::c_int & attr_reverse as libc::c_int != 0 {
        current_block_66 = 2244462385867744796;
    } else {
        current_block_66 = 6072622540298447352;
    }
    match current_block_66 {
        2244462385867744796 => {
            rv = bytebuf_puts(&mut global.out, global.caps[33 as libc::c_int as usize]);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    rv = send_sgr(cfg, cbg);
    if rv != 0 as libc::c_int {
        return rv;
    }
    global.last_fg = fg;
    global.last_bg = bg;
    return 0 as libc::c_int;
}
unsafe extern "C" fn send_sgr(mut fg: uintattr_t, mut bg: uintattr_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut nbuf: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    if fg as libc::c_int == 0 as libc::c_int {
        if bg as libc::c_int == 0 as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    match global.output_mode {
        4 | 3 | 2 => {
            rv = bytebuf_nputs(
                &mut global.out,
                b"\x1B[\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            if fg as libc::c_int != 0 as libc::c_int {
                rv = bytebuf_nputs(
                    &mut global.out,
                    b"38;5;\0" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_ulong),
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
                tmp___1 = convert_num(fg as uint32_t, nbuf.as_mut_ptr());
                rv = bytebuf_nputs(
                    &mut global.out,
                    nbuf.as_mut_ptr() as *const libc::c_char,
                    tmp___1 as size_t,
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
                if bg as libc::c_int != 0 as libc::c_int {
                    rv = bytebuf_nputs(
                        &mut global.out,
                        b";\0" as *const u8 as *const libc::c_char,
                        (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_ulong),
                    );
                    if rv != 0 as libc::c_int {
                        return rv;
                    }
                }
            }
            if bg as libc::c_int != 0 as libc::c_int {
                rv = bytebuf_nputs(
                    &mut global.out,
                    b"48;5;\0" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_ulong),
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
                tmp___2 = convert_num(bg as uint32_t, nbuf.as_mut_ptr());
                rv = bytebuf_nputs(
                    &mut global.out,
                    nbuf.as_mut_ptr() as *const libc::c_char,
                    tmp___2 as size_t,
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
            }
            rv = bytebuf_nputs(
                &mut global.out,
                b"m\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {
            rv = bytebuf_nputs(
                &mut global.out,
                b"\x1B[\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            if fg as libc::c_int != 0 as libc::c_int {
                rv = bytebuf_nputs(
                    &mut global.out,
                    b"3\0" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_ulong),
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
                tmp = convert_num(
                    (fg as libc::c_int - 1 as libc::c_int) as uint32_t,
                    nbuf.as_mut_ptr(),
                );
                rv = bytebuf_nputs(
                    &mut global.out,
                    nbuf.as_mut_ptr() as *const libc::c_char,
                    tmp as size_t,
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
                if bg as libc::c_int != 0 as libc::c_int {
                    rv = bytebuf_nputs(
                        &mut global.out,
                        b";\0" as *const u8 as *const libc::c_char,
                        (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_ulong),
                    );
                    if rv != 0 as libc::c_int {
                        return rv;
                    }
                }
            }
            if bg as libc::c_int != 0 as libc::c_int {
                rv = bytebuf_nputs(
                    &mut global.out,
                    b"4\0" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_ulong),
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
                tmp___0 = convert_num(
                    (bg as libc::c_int - 1 as libc::c_int) as uint32_t,
                    nbuf.as_mut_ptr(),
                );
                rv = bytebuf_nputs(
                    &mut global.out,
                    nbuf.as_mut_ptr() as *const libc::c_char,
                    tmp___0 as size_t,
                );
                if rv != 0 as libc::c_int {
                    return rv;
                }
            }
            rv = bytebuf_nputs(
                &mut global.out,
                b"m\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn send_cursor_if(
    mut x: libc::c_int,
    mut y: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut nbuf: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if x < 0 as libc::c_int {
        return 0 as libc::c_int
    } else {
        if y < 0 as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    rv = bytebuf_nputs(
        &mut global.out,
        b"\x1B[\0" as *const u8 as *const libc::c_char,
        (::std::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = convert_num((y + 1 as libc::c_int) as uint32_t, nbuf.as_mut_ptr());
    rv = bytebuf_nputs(
        &mut global.out,
        nbuf.as_mut_ptr() as *const libc::c_char,
        tmp as size_t,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_nputs(
        &mut global.out,
        b";\0" as *const u8 as *const libc::c_char,
        (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp___0 = convert_num((x + 1 as libc::c_int) as uint32_t, nbuf.as_mut_ptr());
    rv = bytebuf_nputs(
        &mut global.out,
        nbuf.as_mut_ptr() as *const libc::c_char,
        tmp___0 as size_t,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = bytebuf_nputs(
        &mut global.out,
        b"H\0" as *const u8 as *const libc::c_char,
        (::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn send_char(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut ch: uint32_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = send_cluster(x, y, &mut ch, 1 as libc::c_int as size_t);
    return tmp;
}
unsafe extern "C" fn send_cluster(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut ch: *mut uint32_t,
    mut nch: size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut abuf: [libc::c_char; 8] = [0; 8];
    let mut i: libc::c_int = 0;
    let mut ach: uint32_t = 0;
    let mut aw: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut current_block_3: u64;
    if global.last_x != x - 1 as libc::c_int {
        current_block_3 = 12747171876953351391;
    } else if global.last_y != y {
        current_block_3 = 12747171876953351391;
    } else {
        current_block_3 = 14523784380283086299;
    }
    match current_block_3 {
        12747171876953351391 => {
            rv = send_cursor_if(x, y);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    global.last_x = x;
    global.last_y = y;
    i = 0 as libc::c_int;
    while i < nch as libc::c_int {
        ach = *ch.offset(i as isize);
        tmp = tb_utf8_unicode_to_char(abuf.as_mut_ptr(), ach);
        aw = tmp;
        if ach == 0 {
            abuf[0 as libc::c_int as usize] = ' ' as i32 as libc::c_char;
        }
        rv = bytebuf_nputs(
            &mut global.out,
            abuf.as_mut_ptr() as *const libc::c_char,
            aw as size_t,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn convert_num(
    mut num: uint32_t,
    mut buf___0: *mut libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut ch: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    l = 0 as libc::c_int;
    loop {
        tmp = l;
        l += 1;
        *buf___0
            .offset(
                tmp as isize,
            ) = (48 as libc::c_uint).wrapping_add(num.wrapping_rem(10 as libc::c_uint))
            as libc::c_char;
        num = (num as libc::c_uint).wrapping_div(10 as libc::c_uint) as uint32_t
            as uint32_t;
        if num == 0 {
            break;
        }
    }
    i = 0 as libc::c_int;
    while i < l / 2 as libc::c_int {
        ch = *buf___0.offset(i as isize) as libc::c_int;
        *buf___0
            .offset(i as isize) = *buf___0.offset((l - 1 as libc::c_int - i) as isize);
        *buf___0.offset((l - 1 as libc::c_int - i) as isize) = ch as libc::c_char;
        i += 1;
    }
    return l;
}
unsafe extern "C" fn cell_cmp(mut a: *mut tb_cell, mut b: *mut tb_cell) -> libc::c_int {
    if (*a).ch != (*b).ch {
        return 1 as libc::c_int
    } else {
        if (*a).fg as libc::c_int != (*b).fg as libc::c_int {
            return 1 as libc::c_int
        } else {
            if (*a).bg as libc::c_int != (*b).bg as libc::c_int {
                return 1 as libc::c_int;
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn cell_copy(
    mut dst: *mut tb_cell,
    mut src: *mut tb_cell,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = cell_set(
        dst,
        &mut (*src).ch,
        1 as libc::c_int as size_t,
        (*src).fg,
        (*src).bg,
    );
    return tmp;
}
unsafe extern "C" fn cell_set(
    mut cell: *mut tb_cell,
    mut ch: *mut uint32_t,
    mut nch: size_t,
    mut fg: uintattr_t,
    mut bg: uintattr_t,
) -> libc::c_int {
    if !ch.is_null() {
        (*cell).ch = *ch;
    } else {
        (*cell).ch = 0 as libc::c_int as uint32_t;
    }
    (*cell).fg = fg;
    (*cell).bg = bg;
    return 0 as libc::c_int;
}
unsafe extern "C" fn cell_free(mut cell: *mut tb_cell) -> libc::c_int {
    memset(
        cell as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<tb_cell>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn cellbuf_init(
    mut c: *mut cellbuf_t,
    mut w: libc::c_int,
    mut h: libc::c_int,
) -> libc::c_int {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(
        (::std::mem::size_of::<tb_cell>() as libc::c_ulong)
            .wrapping_mul(w as libc::c_ulong)
            .wrapping_mul(h as libc::c_ulong),
    );
    (*c).cells = tmp as *mut tb_cell;
    if ((*c).cells).is_null() {
        return -(5 as libc::c_int);
    }
    memset(
        (*c).cells as *mut libc::c_void,
        0 as libc::c_int,
        (::std::mem::size_of::<tb_cell>() as libc::c_ulong)
            .wrapping_mul(w as libc::c_ulong)
            .wrapping_mul(h as libc::c_ulong),
    );
    (*c).width = w;
    (*c).height = h;
    return 0 as libc::c_int;
}
unsafe extern "C" fn cellbuf_free(mut c: *mut cellbuf_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if !((*c).cells).is_null() {
        i = 0 as libc::c_int;
        while i < (*c).width * (*c).height {
            cell_free(((*c).cells).offset(i as isize));
            i += 1;
        }
        free((*c).cells as *mut libc::c_void);
    }
    memset(
        c as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<cellbuf_t>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn cellbuf_clear(mut c: *mut cellbuf_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut space: uint32_t = 0;
    space = ' ' as i32 as uint32_t;
    i = 0 as libc::c_int;
    while i < (*c).width * (*c).height {
        rv = cell_set(
            ((*c).cells).offset(i as isize),
            &mut space,
            1 as libc::c_int as size_t,
            global.fg,
            global.bg,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn cellbuf_get(
    mut c: *mut cellbuf_t,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut out: *mut *mut tb_cell,
) -> libc::c_int {
    if x < 0 as libc::c_int {
        *out = 0 as *mut libc::c_void as *mut tb_cell;
        return -(9 as libc::c_int);
    } else {
        if x >= (*c).width {
            *out = 0 as *mut libc::c_void as *mut tb_cell;
            return -(9 as libc::c_int);
        } else {
            if y < 0 as libc::c_int {
                *out = 0 as *mut libc::c_void as *mut tb_cell;
                return -(9 as libc::c_int);
            } else {
                if y >= (*c).height {
                    *out = 0 as *mut libc::c_void as *mut tb_cell;
                    return -(9 as libc::c_int);
                }
            }
        }
    }
    *out = ((*c).cells).offset((y * (*c).width + x) as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn cellbuf_resize(
    mut c: *mut cellbuf_t,
    mut w: libc::c_int,
    mut h: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut ow: libc::c_int = 0;
    let mut oh: libc::c_int = 0;
    let mut minw: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut minh: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut prev: *mut tb_cell = 0 as *mut tb_cell;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut src: *mut tb_cell = 0 as *mut tb_cell;
    let mut dst: *mut tb_cell = 0 as *mut tb_cell;
    ow = (*c).width;
    oh = (*c).height;
    if ow == w {
        if oh == h {
            return 0 as libc::c_int;
        }
    }
    if w < 1 as libc::c_int {
        w = 1 as libc::c_int;
    } else {
        w = w;
    }
    if h < 1 as libc::c_int {
        h = 1 as libc::c_int;
    } else {
        h = h;
    }
    if w < ow {
        tmp = w;
    } else {
        tmp = ow;
    }
    minw = tmp;
    if h < oh {
        tmp___0 = h;
    } else {
        tmp___0 = oh;
    }
    minh = tmp___0;
    prev = (*c).cells;
    rv = cellbuf_init(c, w, h);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = cellbuf_clear(c);
    if rv != 0 as libc::c_int {
        return rv;
    }
    x = 0 as libc::c_int;
    while x < minw {
        y = 0 as libc::c_int;
        while y < minh {
            src = prev.offset((y * ow + x) as isize);
            rv = cellbuf_get(c, x, y, &mut dst);
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = cell_copy(dst, src);
            if rv != 0 as libc::c_int {
                return rv;
            }
            y += 1;
        }
        x += 1;
    }
    free(prev as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn bytebuf_puts(
    mut b: *mut bytebuf_t,
    mut str: *const libc::c_char,
) -> libc::c_int {
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strlen(str);
    tmp___0 = bytebuf_nputs(b, str, tmp);
    return tmp___0;
}
unsafe extern "C" fn bytebuf_nputs(
    mut b: *mut bytebuf_t,
    mut str: *const libc::c_char,
    mut nstr: size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    rv = bytebuf_reserve(
        b,
        ((*b).len).wrapping_add(nstr).wrapping_add(1 as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    memcpy(
        ((*b).buf).offset((*b).len as isize) as *mut libc::c_void,
        str as *const libc::c_void,
        nstr,
    );
    (*b).len = ((*b).len as libc::c_ulong).wrapping_add(nstr) as size_t as size_t;
    *((*b).buf).offset((*b).len as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bytebuf_shift(mut b: *mut bytebuf_t, mut n: size_t) -> libc::c_int {
    let mut nmove: size_t = 0;
    if n > (*b).len {
        n = (*b).len;
    }
    nmove = ((*b).len).wrapping_sub(n);
    memmove(
        (*b).buf as *mut libc::c_void,
        ((*b).buf).offset(n as isize) as *const libc::c_void,
        nmove,
    );
    (*b).len = ((*b).len as libc::c_ulong).wrapping_sub(n) as size_t as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bytebuf_flush(
    mut b: *mut bytebuf_t,
    mut fd: libc::c_int,
) -> libc::c_int {
    let mut write_rv: ssize_t = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    if (*b).len <= 0 as libc::c_ulong {
        return 0 as libc::c_int;
    }
    tmp = write(fd, (*b).buf as *const libc::c_void, (*b).len);
    write_rv = tmp;
    if write_rv < 0 as libc::c_long {
        tmp___0 = __errno_location();
        global.last_errno = *tmp___0;
        return -(1 as libc::c_int);
    } else {
        if write_rv as size_t != (*b).len {
            tmp___0 = __errno_location();
            global.last_errno = *tmp___0;
            return -(1 as libc::c_int);
        }
    }
    (*b).len = 0 as libc::c_int as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bytebuf_reserve(
    mut b: *mut bytebuf_t,
    mut sz: size_t,
) -> libc::c_int {
    let mut newcap: size_t = 0;
    let mut tmp: size_t = 0;
    let mut newbuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if (*b).cap >= sz {
        return 0 as libc::c_int;
    }
    if (*b).cap > 0 as libc::c_ulong {
        tmp = (*b).cap;
    } else {
        tmp = 1 as libc::c_int as size_t;
    }
    newcap = tmp;
    while newcap < sz {
        newcap = (newcap as libc::c_ulong).wrapping_mul(2 as libc::c_ulong) as size_t
            as size_t;
    }
    if !((*b).buf).is_null() {
        tmp___0 = realloc((*b).buf as *mut libc::c_void, newcap);
        newbuf = tmp___0 as *mut libc::c_char;
    } else {
        tmp___1 = malloc(newcap);
        newbuf = tmp___1 as *mut libc::c_char;
    }
    if newbuf.is_null() {
        return -(5 as libc::c_int);
    }
    (*b).buf = newbuf;
    (*b).cap = newcap;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bytebuf_free(mut b: *mut bytebuf_t) -> libc::c_int {
    if !((*b).buf).is_null() {
        free((*b).buf as *mut libc::c_void);
    }
    memset(
        b as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<bytebuf_t>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
pub static mut opt_pid: pid_t = -(1 as libc::c_int);
pub static mut opt_pgrep_args: *mut libc::c_char = 0 as *const libc::c_void
    as *mut libc::c_void as *mut libc::c_char;
pub static mut opt_num_workers: libc::c_int = 16 as libc::c_int;
pub static mut opt_top_mode: libc::c_int = 0 as libc::c_int;
pub static mut opt_sleep_ns: libc::c_long = 10101010 as libc::c_long;
pub static mut opt_executor_globals_addr: uint64_t = 0 as libc::c_int as uint64_t;
pub static mut opt_sapi_globals_addr: uint64_t = 0 as libc::c_int as uint64_t;
pub static mut opt_capture_req: libc::c_int = 0 as libc::c_int;
pub static mut opt_capture_req_qstring: libc::c_int = 0 as libc::c_int;
pub static mut opt_capture_req_cookie: libc::c_int = 0 as libc::c_int;
pub static mut opt_capture_req_uri: libc::c_int = 0 as libc::c_int;
pub static mut opt_capture_req_path: libc::c_int = 0 as libc::c_int;
pub static mut opt_capture_mem: libc::c_int = 0 as libc::c_int;
pub static mut opt_max_stack_depth: libc::c_int = -(1 as libc::c_int);
pub static mut opt_frame_delim: libc::c_char = '\n' as i32 as libc::c_char;
pub static mut opt_trace_delim: libc::c_char = '\n' as i32 as libc::c_char;
pub static mut opt_trace_limit: uint64_t = 0 as libc::c_int as uint64_t;
pub static mut opt_time_limit_ms: libc::c_long = 0 as libc::c_long;
pub static mut opt_path_output: *mut libc::c_char = b"-\0" as *const u8
    as *const libc::c_char as *mut libc::c_char;
pub static mut opt_path_child_out: *mut libc::c_char = b"phpspy.%d.out\0" as *const u8
    as *const libc::c_char as *mut libc::c_char;
pub static mut opt_path_child_err: *mut libc::c_char = b"phpspy.%d.err\0" as *const u8
    as *const libc::c_char as *mut libc::c_char;
pub static mut opt_phpv: *mut libc::c_char = b"auto\0" as *const u8
    as *const libc::c_char as *mut libc::c_char;
pub static mut opt_pause: libc::c_int = 0 as libc::c_int;
pub static mut opt_filter_re: *mut regex_t = 0 as *const libc::c_void
    as *mut libc::c_void as *mut regex_t;
pub static mut opt_filter_negate: libc::c_int = 0 as libc::c_int;
pub static mut opt_verbose_fields_pid: libc::c_int = 0 as libc::c_int;
pub static mut opt_verbose_fields_ts: libc::c_int = 0 as libc::c_int;
pub static mut opt_event_handler: Option::<
    unsafe extern "C" fn(*mut trace_context_s, libc::c_int) -> libc::c_int,
> = Some(
    event_handler_fout
        as unsafe extern "C" fn(*mut trace_context_s, libc::c_int) -> libc::c_int,
);
pub static mut opt_continue_on_error: libc::c_int = 0 as libc::c_int;
pub static mut opt_fout_buffer_size: libc::c_int = 4096 as libc::c_int;
pub static mut done: libc::c_int = 0 as libc::c_int;
pub static mut do_trace_ptr: Option::<
    unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
> = unsafe {
    ::std::mem::transmute::<
        *mut libc::c_void,
        Option::<unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int>,
    >(0 as *const libc::c_void as *mut libc::c_void)
};
pub static mut varpeek_map: *mut varpeek_entry_t = 0 as *const libc::c_void
    as *mut libc::c_void as *mut varpeek_entry_t;
pub static mut glopeek_map: *mut glopeek_entry_t = 0 as *const libc::c_void
    as *mut libc::c_void as *mut glopeek_entry_t;
pub static mut filter_re: regex_t = regex_t {
    buffer: 0 as *const re_dfa_t as *mut re_dfa_t,
    allocated: 0,
    used: 0,
    syntax: 0,
    fastmap: 0 as *const libc::c_char as *mut libc::c_char,
    translate: 0 as *const libc::c_uchar as *mut libc::c_uchar,
    re_nsub: 0,
    can_be_null_regs_allocated_fastmap_accurate_no_sub_not_bol_not_eol_newline_anchor: [0; 1],
    c2rust_padding: [0; 7],
};
pub static mut log_error_enabled: libc::c_int = 1 as libc::c_int;
pub static mut in_pgrep_mode: libc::c_int = 0 as libc::c_int;
pub static mut trace_count: uint64_t = 0 as libc::c_int as uint64_t;
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    parse_opts(argc, argv);
    if opt_top_mode != 0 as libc::c_int {
        rv = main_top(argc, argv);
    } else if opt_pid != -(1 as libc::c_int) {
        rv = main_pid(opt_pid);
    } else if opt_pgrep_args as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
        in_pgrep_mode = 1 as libc::c_int;
        rv = main_pgrep();
    } else if optind < argc {
        rv = main_fork(argc, argv);
    } else {
        log_error(
            b"Expected pid (-p), pgrep (-P), or command\n\n\0" as *const u8
                as *const libc::c_char,
        );
        usage(stderr, 1 as libc::c_int);
        rv = 1 as libc::c_int;
    }
    cleanup();
    return rv;
}
pub unsafe extern "C" fn usage(mut fp: *mut FILE, mut exit_code: libc::c_int) {
    fprintf(fp, b"Usage:\n\0" as *const u8 as *const libc::c_char);
    fprintf(fp, b"  phpspy [options] -p <pid>\n\0" as *const u8 as *const libc::c_char);
    fprintf(
        fp,
        b"  phpspy [options] -P <pgrep-args>\n\0" as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  phpspy [options] [--] <cmd>\n\0" as *const u8 as *const libc::c_char,
    );
    fprintf(fp, b"\n\0" as *const u8 as *const libc::c_char);
    fprintf(fp, b"Options:\n\0" as *const u8 as *const libc::c_char);
    fprintf(
        fp,
        b"  -h, --help                         Show this help\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -p, --pid=<pid>                    Trace PHP process at `pid`\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -P, --pgrep=<args>                 Concurrently trace processes that\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       match pgrep `args` (see also `-T`)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -T, --threads=<num>                Set number of threads to use with `-P`\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %d)\n\0" as *const u8
            as *const libc::c_char,
        opt_num_workers,
    );
    fprintf(
        fp,
        b"  -s, --sleep-ns=<ns>                Sleep `ns` nanoseconds between traces\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (see also `-H`) (default: %ld)\n\0"
            as *const u8 as *const libc::c_char,
        opt_sleep_ns,
    );
    fprintf(
        fp,
        b"  -H, --rate-hz=<hz>                 Trace `hz` times per second\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (see also `-s`) (default: %lu)\n\0"
            as *const u8 as *const libc::c_char,
        (1000000000 as libc::c_ulong).wrapping_div(opt_sleep_ns as libc::c_ulong),
    );
    fprintf(
        fp,
        b"  -V, --php-version=<ver>            Set PHP version\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %s;\n\0" as *const u8
            as *const libc::c_char,
        opt_phpv,
    );
    fprintf(
        fp,
        b"                                       supported: 70 71 72 73 74 80 81 82)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -l, --limit=<num>                  Limit total number of traces to capture\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (approximate limit in pgrep mode)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %lu; 0=unlimited)\n\0"
            as *const u8 as *const libc::c_char,
        opt_trace_limit,
    );
    fprintf(
        fp,
        b"  -i, --time-limit-ms=<ms>           Stop tracing after `ms` milliseconds\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (second granularity in pgrep mode)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %lu; 0=unlimited)\n\0"
            as *const u8 as *const libc::c_char,
        opt_time_limit_ms,
    );
    fprintf(
        fp,
        b"  -n, --max-depth=<max>              Set max stack trace depth\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %d; -1=unlimited)\n\0"
            as *const u8 as *const libc::c_char,
        opt_max_stack_depth,
    );
    fprintf(
        fp,
        b"  -r, --request-info=<opts>          Set request info parts to capture\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (q=query c=cookie u=uri p=path\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       capital=negation)\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: QCUP; none)\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -m, --memory-usage                 Capture peak and current memory usage\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       with each trace (requires target PHP\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       process to have debug symbols)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -o, --output=<path>                Write phpspy output to `path`\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %s; -=stdout)\n\0"
            as *const u8 as *const libc::c_char,
        opt_path_output,
    );
    fprintf(
        fp,
        b"  -O, --child-stdout=<path>          Write child stdout to `path`\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %s)\n\0" as *const u8
            as *const libc::c_char,
        opt_path_child_out,
    );
    fprintf(
        fp,
        b"  -E, --child-stderr=<path>          Write child stderr to `path`\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %s)\n\0" as *const u8
            as *const libc::c_char,
        opt_path_child_err,
    );
    fprintf(
        fp,
        b"  -x, --addr-executor-globals=<hex>  Set address of executor_globals in hex\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %lu; 0=find dynamically)\n\0"
            as *const u8 as *const libc::c_char,
        opt_sapi_globals_addr,
    );
    fprintf(
        fp,
        b"  -a, --addr-sapi-globals=<hex>      Set address of sapi_globals in hex\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %lu; 0=find dynamically)\n\0"
            as *const u8 as *const libc::c_char,
        opt_executor_globals_addr,
    );
    fprintf(
        fp,
        b"  -1, --single-line                  Output in single-line mode\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -b, --buffer-size=<size>           Set output buffer size to `size`.\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       Note: In `-P` mode, setting this\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       above PIPE_BUF (4096) may lead to\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       interlaced writes across threads.\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: %d)\n\0" as *const u8
            as *const libc::c_char,
        opt_fout_buffer_size,
    );
    fprintf(
        fp,
        b"  -f, --filter=<regex>               Filter output by POSIX regex\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: none)\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -F, --filter-negate=<regex>        Same as `-f` except negated\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -d, --verbose-fields=<opts>        Set verbose output fields\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (p=pid t=timestamp\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       capital=negation)\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: PT; none)\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -c, --continue-on-error            Attempt to continue tracing after\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       encountering an error\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -#, --comment=<any>                Ignored; intended for self-documenting\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       commands\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -@, --nothing                      Ignored\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -v, --version                      Print phpspy version and exit\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(fp, b"\n\0" as *const u8 as *const libc::c_char);
    fprintf(fp, b"Experimental options:\n\0" as *const u8 as *const libc::c_char);
    fprintf(
        fp,
        b"  -j, --event-handler=<handler>      Set event handler (fout, callgrind)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (default: fout)\n\0" as *const u8
            as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -S, --pause-process                Pause process while reading stacktrace\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       (unsafe for production!)\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -e, --peek-var=<varspec>           Peek at the contents of the var located\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       at `varspec`, which has the format:\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       <varname>@<path>:<lineno>\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       <varname>@<path>:<start>-<end>\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       e.g., xyz@/path/to.php:10-20\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -g, --peek-global=<glospec>        Peek at the contents of a global var\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       located at `glospec`, which has\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       the format: <global>.<key>\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       where <global> is one of:\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       post|get|cookie|server|files|globals\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"                                       e.g., server.REQUEST_TIME\n\0"
            as *const u8 as *const libc::c_char,
    );
    fprintf(
        fp,
        b"  -t, --top                          Show dynamic top-like output\n\0"
            as *const u8 as *const libc::c_char,
    );
    cleanup();
    exit(exit_code);
}
unsafe extern "C" fn strtol_with_min_or_exit(
    mut name: *const libc::c_char,
    mut str: *const libc::c_char,
    mut min: libc::c_int,
) -> libc::c_long {
    let mut result: libc::c_long = 0;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    tmp = __errno_location();
    *tmp = 0 as libc::c_int;
    result = strtol(str, &mut end as *mut *mut libc::c_char, 10 as libc::c_int);
    if end as libc::c_ulong <= str as libc::c_ulong {
        log_error(
            b"Expected integer for %s, got '%s'\n\0" as *const u8 as *const libc::c_char,
            name,
            str,
        );
        usage(stderr, 1 as libc::c_int);
    } else if *end as libc::c_int != 0 as libc::c_int {
        log_error(
            b"Expected integer for %s, got '%s'\n\0" as *const u8 as *const libc::c_char,
            name,
            str,
        );
        usage(stderr, 1 as libc::c_int);
    }
    if result < min as libc::c_long {
        log_error(
            b"Expected integer >= %d for %s, got '%s'\n\0" as *const u8
                as *const libc::c_char,
            min,
            name,
            str,
        );
        usage(stderr, 1 as libc::c_int);
    }
    return result;
}
unsafe extern "C" fn atoi_with_min_or_exit(
    mut name: *const libc::c_char,
    mut str: *const libc::c_char,
    mut min: libc::c_int,
) -> libc::c_int {
    let mut result: libc::c_long = 0;
    let mut tmp: libc::c_long = 0;
    tmp = strtol_with_min_or_exit(name, str, min);
    result = tmp;
    if result > 2147483647 as libc::c_long {
        log_error(
            b"Expected value that could fit in a C int for %s, got '%s'\n\0" as *const u8
                as *const libc::c_char,
            name,
            str,
        );
        usage(stderr, 1 as libc::c_int);
    }
    return result as libc::c_int;
}
unsafe extern "C" fn parse_opts(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) {
    let mut c: libc::c_int = 0;
    let mut i: size_t = 0;
    let mut long_opts: [option; 32] = [option {
        name: 0 as *const libc::c_char,
        has_arg: 0,
        flag: 0 as *mut libc::c_int,
        val: 0,
    }; 32];
    let mut tmp: libc::c_long = 0;
    let mut tmp___0: libc::c_ulonglong = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: libc::c_ulonglong = 0;
    let mut tmp___3: libc::c_ulonglong = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    long_opts[0 as libc::c_int as usize]
        .name = b"help\0" as *const u8 as *const libc::c_char;
    long_opts[0 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[0 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[0 as libc::c_int as usize].val = 'h' as i32;
    long_opts[1 as libc::c_int as usize]
        .name = b"pid\0" as *const u8 as *const libc::c_char;
    long_opts[1 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[1 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[1 as libc::c_int as usize].val = 'p' as i32;
    long_opts[2 as libc::c_int as usize]
        .name = b"pgrep\0" as *const u8 as *const libc::c_char;
    long_opts[2 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[2 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[2 as libc::c_int as usize].val = 'P' as i32;
    long_opts[3 as libc::c_int as usize]
        .name = b"threads\0" as *const u8 as *const libc::c_char;
    long_opts[3 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[3 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[3 as libc::c_int as usize].val = 'T' as i32;
    long_opts[4 as libc::c_int as usize]
        .name = b"sleep-ns\0" as *const u8 as *const libc::c_char;
    long_opts[4 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[4 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[4 as libc::c_int as usize].val = 's' as i32;
    long_opts[5 as libc::c_int as usize]
        .name = b"rate-hz\0" as *const u8 as *const libc::c_char;
    long_opts[5 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[5 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[5 as libc::c_int as usize].val = 'H' as i32;
    long_opts[6 as libc::c_int as usize]
        .name = b"php-version\0" as *const u8 as *const libc::c_char;
    long_opts[6 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[6 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[6 as libc::c_int as usize].val = 'V' as i32;
    long_opts[7 as libc::c_int as usize]
        .name = b"limit\0" as *const u8 as *const libc::c_char;
    long_opts[7 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[7 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[7 as libc::c_int as usize].val = 'l' as i32;
    long_opts[8 as libc::c_int as usize]
        .name = b"time-limit-ms\0" as *const u8 as *const libc::c_char;
    long_opts[8 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[8 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[8 as libc::c_int as usize].val = 'i' as i32;
    long_opts[9 as libc::c_int as usize]
        .name = b"max-depth\0" as *const u8 as *const libc::c_char;
    long_opts[9 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[9 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[9 as libc::c_int as usize].val = 'n' as i32;
    long_opts[10 as libc::c_int as usize]
        .name = b"request-info\0" as *const u8 as *const libc::c_char;
    long_opts[10 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[10 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[10 as libc::c_int as usize].val = 'r' as i32;
    long_opts[11 as libc::c_int as usize]
        .name = b"memory-usage\0" as *const u8 as *const libc::c_char;
    long_opts[11 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[11 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[11 as libc::c_int as usize].val = 'm' as i32;
    long_opts[12 as libc::c_int as usize]
        .name = b"output\0" as *const u8 as *const libc::c_char;
    long_opts[12 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[12 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[12 as libc::c_int as usize].val = 'o' as i32;
    long_opts[13 as libc::c_int as usize]
        .name = b"child-stdout\0" as *const u8 as *const libc::c_char;
    long_opts[13 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[13 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[13 as libc::c_int as usize].val = 'O' as i32;
    long_opts[14 as libc::c_int as usize]
        .name = b"child-stderr\0" as *const u8 as *const libc::c_char;
    long_opts[14 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[14 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[14 as libc::c_int as usize].val = 'E' as i32;
    long_opts[15 as libc::c_int as usize]
        .name = b"addr-executor-globals\0" as *const u8 as *const libc::c_char;
    long_opts[15 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[15 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[15 as libc::c_int as usize].val = 'x' as i32;
    long_opts[16 as libc::c_int as usize]
        .name = b"addr-sapi-globals\0" as *const u8 as *const libc::c_char;
    long_opts[16 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[16 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[16 as libc::c_int as usize].val = 'a' as i32;
    long_opts[17 as libc::c_int as usize]
        .name = b"single-line\0" as *const u8 as *const libc::c_char;
    long_opts[17 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[17 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[17 as libc::c_int as usize].val = '1' as i32;
    long_opts[18 as libc::c_int as usize]
        .name = b"buffer-size\0" as *const u8 as *const libc::c_char;
    long_opts[18 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[18 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[18 as libc::c_int as usize].val = 'b' as i32;
    long_opts[19 as libc::c_int as usize]
        .name = b"filter\0" as *const u8 as *const libc::c_char;
    long_opts[19 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[19 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[19 as libc::c_int as usize].val = 'f' as i32;
    long_opts[20 as libc::c_int as usize]
        .name = b"filter-negate\0" as *const u8 as *const libc::c_char;
    long_opts[20 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[20 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[20 as libc::c_int as usize].val = 'F' as i32;
    long_opts[21 as libc::c_int as usize]
        .name = b"verbose-fields\0" as *const u8 as *const libc::c_char;
    long_opts[21 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[21 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[21 as libc::c_int as usize].val = 'd' as i32;
    long_opts[22 as libc::c_int as usize]
        .name = b"continue-on-error\0" as *const u8 as *const libc::c_char;
    long_opts[22 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[22 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[22 as libc::c_int as usize].val = 'c' as i32;
    long_opts[23 as libc::c_int as usize]
        .name = b"event-handler\0" as *const u8 as *const libc::c_char;
    long_opts[23 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[23 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[23 as libc::c_int as usize].val = 'j' as i32;
    long_opts[24 as libc::c_int as usize]
        .name = b"comment\0" as *const u8 as *const libc::c_char;
    long_opts[24 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[24 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[24 as libc::c_int as usize].val = '#' as i32;
    long_opts[25 as libc::c_int as usize]
        .name = b"nothing\0" as *const u8 as *const libc::c_char;
    long_opts[25 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[25 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[25 as libc::c_int as usize].val = '@' as i32;
    long_opts[26 as libc::c_int as usize]
        .name = b"version\0" as *const u8 as *const libc::c_char;
    long_opts[26 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[26 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[26 as libc::c_int as usize].val = 'v' as i32;
    long_opts[27 as libc::c_int as usize]
        .name = b"pause-process\0" as *const u8 as *const libc::c_char;
    long_opts[27 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[27 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[27 as libc::c_int as usize].val = 'S' as i32;
    long_opts[28 as libc::c_int as usize]
        .name = b"peek-var\0" as *const u8 as *const libc::c_char;
    long_opts[28 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[28 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[28 as libc::c_int as usize].val = 'e' as i32;
    long_opts[29 as libc::c_int as usize]
        .name = b"peek-global\0" as *const u8 as *const libc::c_char;
    long_opts[29 as libc::c_int as usize].has_arg = 1 as libc::c_int;
    long_opts[29 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[29 as libc::c_int as usize].val = 'g' as i32;
    long_opts[30 as libc::c_int as usize]
        .name = b"top\0" as *const u8 as *const libc::c_char;
    long_opts[30 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[30 as libc::c_int as usize]
        .flag = 0 as *mut libc::c_void as *mut libc::c_int;
    long_opts[30 as libc::c_int as usize].val = 't' as i32;
    long_opts[31 as libc::c_int as usize].name = 0 as *const libc::c_char;
    long_opts[31 as libc::c_int as usize].has_arg = 0 as libc::c_int;
    long_opts[31 as libc::c_int as usize].flag = 0 as *mut libc::c_int;
    long_opts[31 as libc::c_int as usize].val = 0 as libc::c_int;
    optind = 1 as libc::c_int;
    while optind < argc {
        if !(*(*argv.offset(optind as isize)).offset(0 as libc::c_int as isize)
            as libc::c_int == 45 as libc::c_int)
        {
            break;
        }
        c = getopt_long(
            argc,
            argv as *const *mut libc::c_char,
            b"hp:P:T:te:s:H:V:l:i:n:r:mo:O:E:x:a:1b:f:F:d:cj:#:@vSe:g:t\0" as *const u8
                as *const libc::c_char,
            long_opts.as_mut_ptr() as *const option,
            0 as *mut libc::c_void as *mut libc::c_int,
        );
        if !(c != -(1 as libc::c_int)) {
            break;
        }
        match c {
            104 => {
                usage(stdout, 0 as libc::c_int);
            }
            112 => {
                opt_pid = atoi_with_min_or_exit(
                    b"-p\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    1 as libc::c_int,
                );
            }
            80 => {
                opt_pgrep_args = optarg;
            }
            84 => {
                opt_num_workers = atoi_with_min_or_exit(
                    b"-T\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    1 as libc::c_int,
                );
            }
            115 => {
                opt_sleep_ns = strtol_with_min_or_exit(
                    b"-s\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    1 as libc::c_int,
                );
            }
            72 => {
                tmp = strtol_with_min_or_exit(
                    b"-H\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    1 as libc::c_int,
                );
                opt_sleep_ns = (1000000000 as libc::c_ulong)
                    .wrapping_div(tmp as libc::c_ulong) as libc::c_long;
            }
            86 => {
                opt_phpv = optarg;
            }
            108 => {
                tmp___0 = strtoull(
                    optarg as *const libc::c_char,
                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                opt_trace_limit = tmp___0 as uint64_t;
            }
            105 => {
                opt_time_limit_ms = strtol_with_min_or_exit(
                    b"-i\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    0 as libc::c_int,
                );
            }
            110 => {
                opt_max_stack_depth = atoi_with_min_or_exit(
                    b"-n\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    -(1 as libc::c_int),
                );
            }
            114 => {
                i = 0 as libc::c_int as size_t;
                loop {
                    tmp___1 = strlen(optarg as *const libc::c_char);
                    if !(i < tmp___1) {
                        break;
                    }
                    match *optarg.offset(i as isize) as libc::c_int {
                        113 => {
                            opt_capture_req_qstring = 1 as libc::c_int;
                        }
                        99 => {
                            opt_capture_req_cookie = 1 as libc::c_int;
                        }
                        117 => {
                            opt_capture_req_uri = 1 as libc::c_int;
                        }
                        112 => {
                            opt_capture_req_path = 1 as libc::c_int;
                        }
                        81 => {
                            opt_capture_req_qstring = 0 as libc::c_int;
                        }
                        67 => {
                            opt_capture_req_cookie = 0 as libc::c_int;
                        }
                        85 => {
                            opt_capture_req_uri = 0 as libc::c_int;
                        }
                        80 => {
                            opt_capture_req_path = 0 as libc::c_int;
                        }
                        _ => {}
                    }
                    i = i.wrapping_add(1);
                }
                opt_capture_req = opt_capture_req_qstring | opt_capture_req_cookie
                    | opt_capture_req_uri | opt_capture_req_path;
            }
            109 => {
                opt_capture_mem = 1 as libc::c_int;
            }
            111 => {
                opt_path_output = optarg;
            }
            79 => {
                opt_path_child_out = optarg;
            }
            69 => {
                opt_path_child_err = optarg;
            }
            120 => {
                tmp___2 = strtoull(
                    optarg as *const libc::c_char,
                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                    16 as libc::c_int,
                );
                opt_executor_globals_addr = tmp___2 as uint64_t;
            }
            97 => {
                tmp___3 = strtoull(
                    optarg as *const libc::c_char,
                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                    16 as libc::c_int,
                );
                opt_sapi_globals_addr = tmp___3 as uint64_t;
            }
            49 => {
                opt_frame_delim = '\t' as i32 as libc::c_char;
                opt_trace_delim = '\n' as i32 as libc::c_char;
            }
            98 => {
                opt_fout_buffer_size = atoi_with_min_or_exit(
                    b"-b\0" as *const u8 as *const libc::c_char,
                    optarg as *const libc::c_char,
                    1 as libc::c_int,
                );
            }
            70 | 102 => {
                if !opt_filter_re.is_null() {
                    regfree(opt_filter_re);
                }
                tmp___4 = regcomp(
                    &mut filter_re as *mut regex_t,
                    optarg as *const libc::c_char,
                    1 as libc::c_int | (1 as libc::c_int) << 3 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                );
                if tmp___4 == 0 as libc::c_int {
                    opt_filter_re = &mut filter_re;
                } else {
                    log_error(
                        b"parse_opts: Failed to compile filter regex\n\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    usage(stderr, 1 as libc::c_int);
                }
                if c == 70 as libc::c_int {
                    opt_filter_negate = 1 as libc::c_int;
                } else {
                    opt_filter_negate = 0 as libc::c_int;
                }
            }
            100 => {
                i = 0 as libc::c_int as size_t;
                loop {
                    tmp___5 = strlen(optarg as *const libc::c_char);
                    if !(i < tmp___5) {
                        break;
                    }
                    match *optarg.offset(i as isize) as libc::c_int {
                        112 => {
                            opt_verbose_fields_pid = 1 as libc::c_int;
                        }
                        116 => {
                            opt_verbose_fields_ts = 1 as libc::c_int;
                        }
                        80 => {
                            opt_verbose_fields_pid = 0 as libc::c_int;
                        }
                        84 => {
                            opt_verbose_fields_ts = 0 as libc::c_int;
                        }
                        _ => {}
                    }
                    i = i.wrapping_add(1);
                }
            }
            99 => {
                opt_continue_on_error = 1 as libc::c_int;
            }
            106 => {
                tmp___7 = strcmp(
                    optarg as *const libc::c_char,
                    b"fout\0" as *const u8 as *const libc::c_char,
                );
                if tmp___7 == 0 as libc::c_int {
                    opt_event_handler = Some(
                        event_handler_fout
                            as unsafe extern "C" fn(
                                *mut trace_context_s,
                                libc::c_int,
                            ) -> libc::c_int,
                    );
                } else {
                    tmp___6 = strcmp(
                        optarg as *const libc::c_char,
                        b"callgrind\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___6 == 0 as libc::c_int {
                        opt_event_handler = Some(
                            event_handler_callgrind
                                as unsafe extern "C" fn(
                                    *mut trace_context_s,
                                    libc::c_int,
                                ) -> libc::c_int,
                        );
                    } else {
                        log_error(
                            b"parse_opts: Expected 'fout' or 'callgrind' for `--event-handler`\n\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        usage(stderr, 1 as libc::c_int);
                    }
                }
            }
            118 => {
                printf(
                    b"phpspy v%s USE_ZEND=%s COMMIT=%s\n\0" as *const u8
                        as *const libc::c_char,
                    b"0.6.0\0" as *const u8 as *const libc::c_char,
                    b"n\0" as *const u8 as *const libc::c_char,
                    b"-\0" as *const u8 as *const libc::c_char,
                );
                exit(0 as libc::c_int);
            }
            83 => {
                opt_pause = 1 as libc::c_int;
            }
            101 => {
                varpeek_add(optarg);
            }
            103 => {
                glopeek_add(optarg);
            }
            116 => {
                opt_top_mode = 1 as libc::c_int;
            }
            35 | 64 | _ => {}
        }
    }
}
pub unsafe extern "C" fn main_pid(mut pid: pid_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut context: trace_context_t = trace_context_t {
        target: trace_target_t {
            pid: 0,
            executor_globals_addr: 0,
            sapi_globals_addr: 0,
            alloc_globals_addr: 0,
            basic_functions_module_addr: 0,
        },
        event: __anonstruct_event_441004094 {
            frame: trace_frame_t {
                loc: trace_loc_t {
                    func: [0; 256],
                    class: [0; 256],
                    file: [0; 256],
                    func_len: 0,
                    class_len: 0,
                    file_len: 0,
                    lineno: 0,
                },
                depth: 0,
            },
            request: trace_request_t {
                uri: [0; 256],
                path: [0; 256],
                qstring: [0; 256],
                cookie: [0; 256],
                ts: 0.,
            },
            mem: trace_mem_t { size: 0, peak: 0 },
            varpeek: trace_varpeek_t {
                entry: 0 as *mut varpeek_entry_t,
                var: 0 as *mut varpeek_var_t,
                zval_str: 0 as *mut libc::c_char,
            },
            glopeek: trace_glopeek_t {
                gentry: 0 as *mut glopeek_entry_t,
                zval_str: 0 as *mut libc::c_char,
            },
        },
        event_udata: 0 as *mut libc::c_void,
        event_handler: None,
        buf: [0; 256],
        buf_len: 0,
    };
    let mut start_time: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut end_time: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut sleep_time: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut _stop_time: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut limit_time: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut stop_time: *mut timespec = 0 as *mut timespec;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    memset(
        &mut context as *mut trace_context_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<trace_context_t>() as libc::c_ulong,
    );
    context.target.pid = pid;
    context.event_handler = opt_event_handler;
    rv = find_addresses(&mut context.target);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some((context.event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(&mut context, 0 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strcmp(
        opt_phpv as *const libc::c_char,
        b"auto\0" as *const u8 as *const libc::c_char,
    );
    if tmp == 0 as libc::c_int {
        rv = get_php_version(&mut context.target);
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    tmp___7 = strcmp(
        b"70\0" as *const u8 as *const libc::c_char,
        opt_phpv as *const libc::c_char,
    );
    if tmp___7 == 0 as libc::c_int {
        do_trace_ptr = Some(
            do_trace_70 as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
        );
    } else {
        tmp___6 = strcmp(
            b"71\0" as *const u8 as *const libc::c_char,
            opt_phpv as *const libc::c_char,
        );
        if tmp___6 == 0 as libc::c_int {
            do_trace_ptr = Some(
                do_trace_71 as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
            );
        } else {
            tmp___5 = strcmp(
                b"72\0" as *const u8 as *const libc::c_char,
                opt_phpv as *const libc::c_char,
            );
            if tmp___5 == 0 as libc::c_int {
                do_trace_ptr = Some(
                    do_trace_72
                        as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
                );
            } else {
                tmp___4 = strcmp(
                    b"73\0" as *const u8 as *const libc::c_char,
                    opt_phpv as *const libc::c_char,
                );
                if tmp___4 == 0 as libc::c_int {
                    do_trace_ptr = Some(
                        do_trace_73
                            as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
                    );
                } else {
                    tmp___3 = strcmp(
                        b"74\0" as *const u8 as *const libc::c_char,
                        opt_phpv as *const libc::c_char,
                    );
                    if tmp___3 == 0 as libc::c_int {
                        do_trace_ptr = Some(
                            do_trace_74
                                as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
                        );
                    } else {
                        tmp___2 = strcmp(
                            b"80\0" as *const u8 as *const libc::c_char,
                            opt_phpv as *const libc::c_char,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            do_trace_ptr = Some(
                                do_trace_80
                                    as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
                            );
                        } else {
                            tmp___1 = strcmp(
                                b"81\0" as *const u8 as *const libc::c_char,
                                opt_phpv as *const libc::c_char,
                            );
                            if tmp___1 == 0 as libc::c_int {
                                do_trace_ptr = Some(
                                    do_trace_81
                                        as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
                                );
                            } else {
                                tmp___0 = strcmp(
                                    b"82\0" as *const u8 as *const libc::c_char,
                                    opt_phpv as *const libc::c_char,
                                );
                                if tmp___0 == 0 as libc::c_int {
                                    do_trace_ptr = Some(
                                        do_trace_81
                                            as unsafe extern "C" fn(*mut trace_context_t) -> libc::c_int,
                                    );
                                } else {
                                    log_error(
                                        b"main_pid: Unrecognized PHP version (%s)\n\0" as *const u8
                                            as *const libc::c_char,
                                        opt_phpv,
                                    );
                                    return 1 as libc::c_int;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    stop_time = 0 as *mut libc::c_void as *mut timespec;
    if in_pgrep_mode == 0 {
        if opt_time_limit_ms > 0 as libc::c_long {
            stop_time = &mut _stop_time;
            limit_time.tv_sec = opt_time_limit_ms / 1000 as libc::c_long;
            limit_time
                .tv_nsec = opt_time_limit_ms % 1000 as libc::c_long
                * 1000000 as libc::c_long;
            clock_get(stop_time);
            clock_add(stop_time, &mut limit_time, stop_time);
        }
    }
    while done == 0 {
        clock_get(&mut start_time);
        rv = 0 as libc::c_int;
        if opt_pause != 0 {
            tmp___8 = pause_pid(pid);
            rv |= tmp___8;
        }
        tmp___9 = (Some(do_trace_ptr.expect("non-null function pointer")))
            .expect("non-null function pointer")(&mut context);
        rv |= tmp___9;
        if opt_pause != 0 {
            tmp___10 = unpause_pid(pid);
            rv |= tmp___10;
        }
        if rv & 2 as libc::c_int != 0 as libc::c_int {
            break;
        }
        if opt_trace_limit > 0 as libc::c_ulong {
            if rv == 0 as libc::c_int {
                if in_pgrep_mode != 0 {
                    let fresh12 = &mut trace_count;
                    let fresh13 = 1 as libc::c_int as uint64_t;
                    ::std::intrinsics::atomic_xadd_seqcst(fresh12, fresh13) + fresh13;
                } else {
                    trace_count = trace_count.wrapping_add(1);
                }
                if trace_count >= opt_trace_limit {
                    break;
                }
            }
        }
        if !stop_time.is_null() {
            tmp___11 = clock_diff(&mut end_time, stop_time);
            if tmp___11 >= 1 as libc::c_int {
                break;
            }
        }
        clock_get(&mut end_time);
        calc_sleep_time(&mut end_time, &mut start_time, &mut sleep_time);
        nanosleep(
            &mut sleep_time as *mut timespec as *const timespec,
            0 as *mut libc::c_void as *mut timespec,
        );
    }
    (Some((context.event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(&mut context, 9 as libc::c_int);
    if in_pgrep_mode != 0 {
        if opt_trace_limit > 0 as libc::c_ulong {
            if trace_count >= opt_trace_limit {
                write_done_pipe();
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn main_fork(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut status: libc::c_int = 0;
    let mut fork_pid: pid_t = 0;
    fork_pid = fork();
    if fork_pid == 0 as libc::c_int {
        redirect_child_stdio(1 as libc::c_int, opt_path_child_out);
        redirect_child_stdio(2 as libc::c_int, opt_path_child_err);
        ptrace(
            PTRACE_TRACEME,
            0 as libc::c_int,
            0 as *mut libc::c_void,
            0 as *mut libc::c_void,
        );
        execvp(
            *argv.offset(optind as isize) as *const libc::c_char,
            argv.offset(optind as isize) as *const *mut libc::c_char,
        );
        perror(b"execvp\0" as *const u8 as *const libc::c_char);
        exit(1 as libc::c_int);
    } else {
        if fork_pid < 0 as libc::c_int {
            perror(b"fork\0" as *const u8 as *const libc::c_char);
            exit(1 as libc::c_int);
        }
    }
    waitpid(fork_pid, &mut status, 0 as libc::c_int);
    if !(status & 255 as libc::c_int == 127 as libc::c_int) {
        log_error(
            b"main_fork: Expected SIGTRAP from child\n\0" as *const u8
                as *const libc::c_char,
        );
    } else if (status & 65280 as libc::c_int) >> 8 as libc::c_int != 5 as libc::c_int {
        log_error(
            b"main_fork: Expected SIGTRAP from child\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    ptrace(PTRACE_DETACH, fork_pid, 0 as *mut libc::c_void, 0 as *mut libc::c_void);
    rv = main_pid(fork_pid);
    waitpid(fork_pid, 0 as *mut libc::c_void as *mut libc::c_int, 0 as libc::c_int);
    return rv;
}
unsafe extern "C" fn cleanup() {
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut entry_tmp: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut var_tmp: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _hd_hh_del: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hd_bkt: libc::c_uint = 0;
    let mut _hd_head: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _hd_hh_del___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hd_bkt___0: libc::c_uint = 0;
    let mut _hd_head___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _hd_hh_del___1: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hd_bkt___1: libc::c_uint = 0;
    let mut _hd_head___1: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    if !opt_filter_re.is_null() {
        regfree(opt_filter_re);
    }
    entry = varpeek_map;
    if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*varpeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    entry_tmp = tmp as *mut varpeek_entry_t;
    while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        var = (*entry).varmap;
        if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___1 = (*(*entry).varmap).hh.next;
        } else {
            tmp___1 = 0 as *mut libc::c_void;
        }
        var_tmp = tmp___1 as *mut varpeek_var_t;
        while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            _hd_hh_del = &mut (*var).hh;
            let mut current_block_48: u64;
            if (*_hd_hh_del).prev as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                if (*_hd_hh_del).next as libc::c_ulong
                    == 0 as *mut libc::c_void as libc::c_ulong
                {
                    free((*(*(*entry).varmap).hh.tbl).buckets as *mut libc::c_void);
                    free((*(*entry).varmap).hh.tbl as *mut libc::c_void);
                    (*entry).varmap = 0 as *mut libc::c_void as *mut varpeek_var_t;
                    current_block_48 = 1854459640724737493;
                } else {
                    current_block_48 = 10080099696181661617;
                }
            } else {
                current_block_48 = 10080099696181661617;
            }
            match current_block_48 {
                10080099696181661617 => {
                    if _hd_hh_del as libc::c_ulong
                        == (*(*(*entry).varmap).hh.tbl).tail as libc::c_ulong
                    {
                        (*(*(*entry).varmap).hh.tbl)
                            .tail = ((*_hd_hh_del).prev as *mut libc::c_char)
                            .offset((*(*(*entry).varmap).hh.tbl).hho as isize)
                            as *mut UT_hash_handle;
                    }
                    if (*_hd_hh_del).prev as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        let ref mut fresh14 = (*(((*_hd_hh_del).prev
                            as *mut libc::c_char)
                            .offset((*(*(*entry).varmap).hh.tbl).hho as isize)
                            as *mut UT_hash_handle))
                            .next;
                        *fresh14 = (*_hd_hh_del).next;
                    } else {
                        (*entry).varmap = (*_hd_hh_del).next as *mut varpeek_var_t;
                    }
                    if (*_hd_hh_del).next as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        let ref mut fresh15 = (*(((*_hd_hh_del).next
                            as *mut libc::c_char)
                            .offset((*(*(*entry).varmap).hh.tbl).hho as isize)
                            as *mut UT_hash_handle))
                            .prev;
                        *fresh15 = (*_hd_hh_del).prev;
                    }
                    _hd_bkt = (*_hd_hh_del).hashv
                        & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                            .wrapping_sub(1 as libc::c_uint);
                    _hd_head = ((*(*(*entry).varmap).hh.tbl).buckets)
                        .offset(_hd_bkt as isize);
                    (*_hd_head).count = ((*_hd_head).count).wrapping_sub(1);
                    if (*_hd_head).hh_head as libc::c_ulong
                        == _hd_hh_del as libc::c_ulong
                    {
                        (*_hd_head).hh_head = (*_hd_hh_del).hh_next;
                    }
                    if !((*_hd_hh_del).hh_prev).is_null() {
                        (*(*_hd_hh_del).hh_prev).hh_next = (*_hd_hh_del).hh_next;
                    }
                    if !((*_hd_hh_del).hh_next).is_null() {
                        (*(*_hd_hh_del).hh_next).hh_prev = (*_hd_hh_del).hh_prev;
                    }
                    (*(*(*entry).varmap).hh.tbl)
                        .num_items = ((*(*(*entry).varmap).hh.tbl).num_items)
                        .wrapping_sub(1);
                }
                _ => {}
            }
            free(var as *mut libc::c_void);
            var = var_tmp;
            if var_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___2 = (*var_tmp).hh.next;
            } else {
                tmp___2 = 0 as *mut libc::c_void;
            }
            var_tmp = tmp___2 as *mut varpeek_var_t;
        }
        _hd_hh_del___0 = &mut (*entry).hh;
        let mut current_block_92: u64;
        if (*_hd_hh_del___0).prev as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            if (*_hd_hh_del___0).next as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                free((*(*varpeek_map).hh.tbl).buckets as *mut libc::c_void);
                free((*varpeek_map).hh.tbl as *mut libc::c_void);
                varpeek_map = 0 as *mut libc::c_void as *mut varpeek_entry_t;
                current_block_92 = 6014157347423944569;
            } else {
                current_block_92 = 7159774230656996199;
            }
        } else {
            current_block_92 = 7159774230656996199;
        }
        match current_block_92 {
            7159774230656996199 => {
                if _hd_hh_del___0 as libc::c_ulong
                    == (*(*varpeek_map).hh.tbl).tail as libc::c_ulong
                {
                    (*(*varpeek_map).hh.tbl)
                        .tail = ((*_hd_hh_del___0).prev as *mut libc::c_char)
                        .offset((*(*varpeek_map).hh.tbl).hho as isize)
                        as *mut UT_hash_handle;
                }
                if (*_hd_hh_del___0).prev as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    let ref mut fresh16 = (*(((*_hd_hh_del___0).prev
                        as *mut libc::c_char)
                        .offset((*(*varpeek_map).hh.tbl).hho as isize)
                        as *mut UT_hash_handle))
                        .next;
                    *fresh16 = (*_hd_hh_del___0).next;
                } else {
                    varpeek_map = (*_hd_hh_del___0).next as *mut varpeek_entry_t;
                }
                if (*_hd_hh_del___0).next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    let ref mut fresh17 = (*(((*_hd_hh_del___0).next
                        as *mut libc::c_char)
                        .offset((*(*varpeek_map).hh.tbl).hho as isize)
                        as *mut UT_hash_handle))
                        .prev;
                    *fresh17 = (*_hd_hh_del___0).prev;
                }
                _hd_bkt___0 = (*_hd_hh_del___0).hashv
                    & ((*(*varpeek_map).hh.tbl).num_buckets)
                        .wrapping_sub(1 as libc::c_uint);
                _hd_head___0 = ((*(*varpeek_map).hh.tbl).buckets)
                    .offset(_hd_bkt___0 as isize);
                (*_hd_head___0).count = ((*_hd_head___0).count).wrapping_sub(1);
                if (*_hd_head___0).hh_head as libc::c_ulong
                    == _hd_hh_del___0 as libc::c_ulong
                {
                    (*_hd_head___0).hh_head = (*_hd_hh_del___0).hh_next;
                }
                if !((*_hd_hh_del___0).hh_prev).is_null() {
                    (*(*_hd_hh_del___0).hh_prev).hh_next = (*_hd_hh_del___0).hh_next;
                }
                if !((*_hd_hh_del___0).hh_next).is_null() {
                    (*(*_hd_hh_del___0).hh_next).hh_prev = (*_hd_hh_del___0).hh_prev;
                }
                (*(*varpeek_map).hh.tbl)
                    .num_items = ((*(*varpeek_map).hh.tbl).num_items).wrapping_sub(1);
            }
            _ => {}
        }
        free(entry as *mut libc::c_void);
        entry = entry_tmp;
        if entry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*entry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        entry_tmp = tmp___0 as *mut varpeek_entry_t;
    }
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___3 = (*glopeek_map).hh.next;
    } else {
        tmp___3 = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp___3 as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        _hd_hh_del___1 = &mut (*gentry).hh;
        let mut current_block_143: u64;
        if (*_hd_hh_del___1).prev as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            if (*_hd_hh_del___1).next as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                free((*(*glopeek_map).hh.tbl).buckets as *mut libc::c_void);
                free((*glopeek_map).hh.tbl as *mut libc::c_void);
                glopeek_map = 0 as *mut libc::c_void as *mut glopeek_entry_t;
                current_block_143 = 13174377073168946860;
            } else {
                current_block_143 = 641503382594615254;
            }
        } else {
            current_block_143 = 641503382594615254;
        }
        match current_block_143 {
            641503382594615254 => {
                if _hd_hh_del___1 as libc::c_ulong
                    == (*(*glopeek_map).hh.tbl).tail as libc::c_ulong
                {
                    (*(*glopeek_map).hh.tbl)
                        .tail = ((*_hd_hh_del___1).prev as *mut libc::c_char)
                        .offset((*(*glopeek_map).hh.tbl).hho as isize)
                        as *mut UT_hash_handle;
                }
                if (*_hd_hh_del___1).prev as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    let ref mut fresh18 = (*(((*_hd_hh_del___1).prev
                        as *mut libc::c_char)
                        .offset((*(*glopeek_map).hh.tbl).hho as isize)
                        as *mut UT_hash_handle))
                        .next;
                    *fresh18 = (*_hd_hh_del___1).next;
                } else {
                    glopeek_map = (*_hd_hh_del___1).next as *mut glopeek_entry_t;
                }
                if (*_hd_hh_del___1).next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    let ref mut fresh19 = (*(((*_hd_hh_del___1).next
                        as *mut libc::c_char)
                        .offset((*(*glopeek_map).hh.tbl).hho as isize)
                        as *mut UT_hash_handle))
                        .prev;
                    *fresh19 = (*_hd_hh_del___1).prev;
                }
                _hd_bkt___1 = (*_hd_hh_del___1).hashv
                    & ((*(*glopeek_map).hh.tbl).num_buckets)
                        .wrapping_sub(1 as libc::c_uint);
                _hd_head___1 = ((*(*glopeek_map).hh.tbl).buckets)
                    .offset(_hd_bkt___1 as isize);
                (*_hd_head___1).count = ((*_hd_head___1).count).wrapping_sub(1);
                if (*_hd_head___1).hh_head as libc::c_ulong
                    == _hd_hh_del___1 as libc::c_ulong
                {
                    (*_hd_head___1).hh_head = (*_hd_hh_del___1).hh_next;
                }
                if !((*_hd_hh_del___1).hh_prev).is_null() {
                    (*(*_hd_hh_del___1).hh_prev).hh_next = (*_hd_hh_del___1).hh_next;
                }
                if !((*_hd_hh_del___1).hh_next).is_null() {
                    (*(*_hd_hh_del___1).hh_next).hh_prev = (*_hd_hh_del___1).hh_prev;
                }
                (*(*glopeek_map).hh.tbl)
                    .num_items = ((*(*glopeek_map).hh.tbl).num_items).wrapping_sub(1);
            }
            _ => {}
        }
        free(gentry as *mut libc::c_void);
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___4 = (*gentry_tmp).hh.next;
        } else {
            tmp___4 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___4 as *mut glopeek_entry_t;
    }
}
unsafe extern "C" fn pause_pid(mut pid: pid_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_long = 0;
    let mut tmp___2: __pid_t = 0;
    tmp___1 = ptrace(PTRACE_ATTACH, pid, 0 as libc::c_int, 0 as libc::c_int);
    if tmp___1 == -(1 as libc::c_long) {
        tmp = __errno_location();
        rv = *tmp;
        perror(b"ptrace\0" as *const u8 as *const libc::c_char);
        if rv == 3 as libc::c_int {
            tmp___0 = 2 as libc::c_int;
        } else {
            tmp___0 = 0 as libc::c_int;
        }
        return 1 as libc::c_int + tmp___0;
    }
    tmp___2 = waitpid(pid, 0 as *mut libc::c_void as *mut libc::c_int, 0 as libc::c_int);
    if tmp___2 < 0 as libc::c_int {
        perror(b"waitpid\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn unpause_pid(mut pid: pid_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_long = 0;
    tmp___1 = ptrace(PTRACE_DETACH, pid, 0 as libc::c_int, 0 as libc::c_int);
    if tmp___1 == -(1 as libc::c_long) {
        tmp = __errno_location();
        rv = *tmp;
        perror(b"ptrace\0" as *const u8 as *const libc::c_char);
        if rv == 3 as libc::c_int {
            tmp___0 = 2 as libc::c_int;
        } else {
            tmp___0 = 0 as libc::c_int;
        }
        return 1 as libc::c_int + tmp___0;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn redirect_child_stdio(
    mut proc_fd: libc::c_int,
    mut opt_path: *mut libc::c_char,
) {
    let mut redir_path: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut redir_file: *mut FILE = 0 as *mut FILE;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: __pid_t = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    tmp___3 = strcmp(
        opt_path as *const libc::c_char,
        b"-\0" as *const u8 as *const libc::c_char,
    );
    if tmp___3 == 0 as libc::c_int {
        return
    } else {
        tmp___2 = strstr(
            opt_path as *const libc::c_char,
            b"%d\0" as *const u8 as *const libc::c_char,
        );
        if tmp___2 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = getpid();
            tmp___1 = asprintf(
                &mut redir_path as *mut *mut libc::c_char,
                opt_path as *const libc::c_char,
                tmp___0,
            );
            if tmp___1 < 0 as libc::c_int {
                tmp = __errno_location();
                *tmp = 12 as libc::c_int;
                perror(b"asprintf\0" as *const u8 as *const libc::c_char);
                exit(1 as libc::c_int);
            }
        } else {
            redir_path = strdup(opt_path as *const libc::c_char);
            if redir_path as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                perror(b"strdup\0" as *const u8 as *const libc::c_char);
                exit(1 as libc::c_int);
            }
        }
    }
    redir_file = fopen(
        redir_path as *const libc::c_char,
        b"w\0" as *const u8 as *const libc::c_char,
    );
    if redir_file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        perror(b"fopen\0" as *const u8 as *const libc::c_char);
        free(redir_path as *mut libc::c_void);
        exit(1 as libc::c_int);
    }
    tmp___4 = fileno(redir_file);
    dup2(tmp___4, proc_fd);
    fclose(redir_file);
    free(redir_path as *mut libc::c_void);
}
unsafe extern "C" fn find_addresses(mut target: *mut trace_target_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut memo: addr_memo_t = addr_memo_t {
        php_bin_path: [0; 256],
        php_bin_path_root: [0; 256],
        php_base_addr: 0,
    };
    let mut tmp: libc::c_int = 0;
    memset(
        &mut memo as *mut addr_memo_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addr_memo_t>() as libc::c_ulong,
    );
    if opt_executor_globals_addr != 0 as libc::c_ulong {
        (*target).executor_globals_addr = opt_executor_globals_addr;
    } else {
        rv = get_symbol_addr(
            &mut memo,
            (*target).pid,
            b"executor_globals\0" as *const u8 as *const libc::c_char,
            &mut (*target).executor_globals_addr,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    if opt_sapi_globals_addr != 0 as libc::c_ulong {
        (*target).sapi_globals_addr = opt_sapi_globals_addr;
    } else if opt_capture_req != 0 {
        rv = get_symbol_addr(
            &mut memo,
            (*target).pid,
            b"sapi_globals\0" as *const u8 as *const libc::c_char,
            &mut (*target).sapi_globals_addr,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    if opt_capture_mem != 0 {
        rv = get_symbol_addr(
            &mut memo,
            (*target).pid,
            b"alloc_globals\0" as *const u8 as *const libc::c_char,
            &mut (*target).alloc_globals_addr,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
    }
    log_error_enabled = 0 as libc::c_int;
    tmp = get_symbol_addr(
        &mut memo,
        (*target).pid,
        b"basic_functions_module\0" as *const u8 as *const libc::c_char,
        &mut (*target).basic_functions_module_addr,
    );
    if tmp != 0 as libc::c_int {
        (*target).basic_functions_module_addr = 0 as libc::c_int as uint64_t;
    }
    log_error_enabled = 1 as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn clock_get(mut ts: *mut timespec) {
    let mut tmp: libc::c_int = 0;
    tmp = clock_gettime(4 as libc::c_int, ts);
    if tmp == -(1 as libc::c_int) {
        perror(b"clock_gettime\0" as *const u8 as *const libc::c_char);
        (*ts).tv_sec = 0 as libc::c_int as __time_t;
        (*ts).tv_nsec = 0 as libc::c_int as __syscall_slong_t;
    }
}
unsafe extern "C" fn clock_add(
    mut a: *mut timespec,
    mut b: *mut timespec,
    mut res: *mut timespec,
) {
    (*res).tv_sec = (*a).tv_sec + (*b).tv_sec;
    (*res).tv_nsec = (*a).tv_nsec + (*b).tv_nsec;
    if (*res).tv_nsec >= 1000000000 as libc::c_long {
        (*res).tv_sec += (*res).tv_nsec / 1000000000 as libc::c_long;
        (*res).tv_nsec %= 1000000000 as libc::c_long;
    }
}
unsafe extern "C" fn clock_diff(
    mut a: *mut timespec,
    mut b: *mut timespec,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if (*a).tv_sec == (*b).tv_sec {
        if (*a).tv_nsec == (*b).tv_nsec {
            return 0 as libc::c_int;
        }
        if (*a).tv_nsec > (*b).tv_nsec {
            tmp = 1 as libc::c_int;
        } else {
            tmp = -(1 as libc::c_int);
        }
        return tmp;
    }
    if (*a).tv_sec > (*b).tv_sec {
        tmp___0 = 1 as libc::c_int;
    } else {
        tmp___0 = -(1 as libc::c_int);
    }
    return tmp___0;
}
unsafe extern "C" fn calc_sleep_time(
    mut end: *mut timespec,
    mut start: *mut timespec,
    mut sleep___0: *mut timespec,
) {
    let mut end_ns: libc::c_long = 0;
    let mut start_ns: libc::c_long = 0;
    let mut sleep_ns: libc::c_long = 0;
    if (*end).tv_sec == (*start).tv_sec {
        sleep_ns = opt_sleep_ns - ((*end).tv_nsec - (*start).tv_nsec);
    } else {
        end_ns = ((*end).tv_sec as libc::c_ulong)
            .wrapping_mul(1000000000 as libc::c_ulong)
            .wrapping_add((*end).tv_nsec as libc::c_ulong) as libc::c_long;
        start_ns = ((*start).tv_sec as libc::c_ulong)
            .wrapping_mul(1000000000 as libc::c_ulong)
            .wrapping_add((*start).tv_nsec as libc::c_ulong) as libc::c_long;
        sleep_ns = opt_sleep_ns - (end_ns - start_ns);
    }
    if sleep_ns < 0 as libc::c_long {
        log_error(
            b"calc_sleep_time: Expected sleep_ns>0; decrease sample rate\n\0"
                as *const u8 as *const libc::c_char,
        );
        sleep_ns = 0 as libc::c_long;
    }
    if sleep_ns < 1000000000 as libc::c_long {
        (*sleep___0).tv_sec = 0 as libc::c_int as __time_t;
        (*sleep___0).tv_nsec = sleep_ns;
    } else {
        (*sleep___0).tv_sec = sleep_ns / 1000000000 as libc::c_long;
        (*sleep___0)
            .tv_nsec = sleep_ns - (*sleep___0).tv_sec * 1000000000 as libc::c_long;
    };
}
unsafe extern "C" fn varpeek_add(mut varspec: *mut libc::c_char) {
    let mut at_sign: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut colon: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dash: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut line_start: uint32_t = 0;
    let mut line_end: uint32_t = 0;
    let mut lineno: uint32_t = 0;
    let mut varpeek: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut tmp: libc::c_ulong = 0;
    let mut tmp___0: libc::c_ulong = 0;
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___1: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _uthash_hastr_keylen: libc::c_uint = 0;
    let mut tmp___4: size_t = 0;
    let mut _ha_hashv: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _ha_bkt: libc::c_uint = 0;
    let mut _ha_head: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_bkt: libc::c_uint = 0;
    let mut _he_bkt_i: libc::c_uint = 0;
    let mut _he_thh: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_hh_nxt: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_new_buckets: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_newbkt: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _uthash_hastr_keylen___0: libc::c_uint = 0;
    let mut tmp___10: size_t = 0;
    let mut _ha_hashv___0: libc::c_uint = 0;
    let mut _hj_i___1: libc::c_uint = 0;
    let mut _hj_j___1: libc::c_uint = 0;
    let mut _hj_k___1: libc::c_uint = 0;
    let mut _hj_key___1: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _ha_bkt___0: libc::c_uint = 0;
    let mut _ha_head___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_bkt___0: libc::c_uint = 0;
    let mut _he_bkt_i___0: libc::c_uint = 0;
    let mut _he_thh___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_hh_nxt___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_new_buckets___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_newbkt___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: libc::c_uint = 0;
    at_sign = strchr(varspec as *const libc::c_char, '@' as i32);
    colon = strrchr(varspec as *const libc::c_char, ':' as i32);
    dash = strrchr(varspec as *const libc::c_char, '-' as i32);
    if at_sign.is_null() {
        log_error(
            b"varpeek_add: Malformed varspec: %s\n\n\0" as *const u8
                as *const libc::c_char,
            varspec,
        );
        usage(stderr, 1 as libc::c_int);
    } else if colon.is_null() {
        log_error(
            b"varpeek_add: Malformed varspec: %s\n\n\0" as *const u8
                as *const libc::c_char,
            varspec,
        );
        usage(stderr, 1 as libc::c_int);
    }
    tmp = strtoul(
        colon.offset(1 as libc::c_int as isize) as *const libc::c_char,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    line_start = tmp as uint32_t;
    if !dash.is_null() {
        tmp___0 = strtoul(
            dash.offset(1 as libc::c_int as isize) as *const libc::c_char,
            0 as *mut libc::c_void as *mut *mut libc::c_char,
            10 as libc::c_int,
        );
        line_end = tmp___0 as uint32_t;
    } else {
        line_end = line_start;
    }
    lineno = line_start;
    while lineno <= line_end {
        snprintf(
            varpeek_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b"%.*s:%d\0" as *const u8 as *const libc::c_char,
            (colon.offset_from(at_sign) as libc::c_long - 1 as libc::c_long)
                as libc::c_int,
            at_sign.offset(1 as libc::c_int as isize),
            lineno,
        );
        tmp___1 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
        _uthash_hfstr_keylen = tmp___1 as libc::c_uint;
        _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv = 4276993775 as libc::c_uint;
        _hj_j = 2654435769 as libc::c_uint;
        _hj_i = _hj_j;
        _hj_k = _uthash_hfstr_keylen;
        while _hj_k >= 12 as libc::c_uint {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                                << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                                << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                                << 24 as libc::c_int,
                        ),
                );
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                                << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                                << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                                << 24 as libc::c_int,
                        ),
                );
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                                << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                                << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                                << 24 as libc::c_int,
                        ),
                );
            _hj_i = _hj_i.wrapping_sub(_hj_j);
            _hj_i = _hj_i.wrapping_sub(_hf_hashv);
            _hj_i ^= _hf_hashv >> 13 as libc::c_int;
            _hj_j = _hj_j.wrapping_sub(_hf_hashv);
            _hj_j = _hj_j.wrapping_sub(_hj_i);
            _hj_j ^= _hj_i << 8 as libc::c_int;
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
            _hf_hashv ^= _hj_j >> 13 as libc::c_int;
            _hj_i = _hj_i.wrapping_sub(_hj_j);
            _hj_i = _hj_i.wrapping_sub(_hf_hashv);
            _hj_i ^= _hf_hashv >> 12 as libc::c_int;
            _hj_j = _hj_j.wrapping_sub(_hf_hashv);
            _hj_j = _hj_j.wrapping_sub(_hj_i);
            _hj_j ^= _hj_i << 16 as libc::c_int;
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
            _hf_hashv ^= _hj_j >> 5 as libc::c_int;
            _hj_i = _hj_i.wrapping_sub(_hj_j);
            _hj_i = _hj_i.wrapping_sub(_hf_hashv);
            _hj_i ^= _hf_hashv >> 3 as libc::c_int;
            _hj_j = _hj_j.wrapping_sub(_hf_hashv);
            _hj_j = _hj_j.wrapping_sub(_hj_i);
            _hj_j ^= _hj_i << 10 as libc::c_int;
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
            _hf_hashv ^= _hj_j >> 15 as libc::c_int;
            _hj_key = _hj_key.offset(12 as libc::c_int as isize);
            _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
        let mut current_block_74: u64;
        match _hj_k {
            11 => {
                _hf_hashv = _hf_hashv
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_74 = 17753969102672856493;
            }
            10 => {
                current_block_74 = 17753969102672856493;
            }
            9 => {
                current_block_74 = 17686009086820902596;
            }
            8 => {
                current_block_74 = 3803013425724075773;
            }
            7 => {
                current_block_74 = 9963805098063667323;
            }
            6 => {
                current_block_74 = 8409049506199415548;
            }
            5 => {
                current_block_74 = 3448531469717569008;
            }
            4 => {
                current_block_74 = 840475230475336896;
            }
            3 => {
                current_block_74 = 4801405821185399573;
            }
            2 => {
                current_block_74 = 3936359720063008204;
            }
            1 => {
                current_block_74 = 4138028631709185825;
            }
            _ => {
                current_block_74 = 3879520548144599102;
            }
        }
        match current_block_74 {
            17753969102672856493 => {
                _hf_hashv = _hf_hashv
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_74 = 17686009086820902596;
            }
            _ => {}
        }
        match current_block_74 {
            17686009086820902596 => {
                _hf_hashv = _hf_hashv
                    .wrapping_add(
                        (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_74 = 3803013425724075773;
            }
            _ => {}
        }
        match current_block_74 {
            3803013425724075773 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_74 = 9963805098063667323;
            }
            _ => {}
        }
        match current_block_74 {
            9963805098063667323 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_74 = 8409049506199415548;
            }
            _ => {}
        }
        match current_block_74 {
            8409049506199415548 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_74 = 3448531469717569008;
            }
            _ => {}
        }
        match current_block_74 {
            3448531469717569008 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_74 = 840475230475336896;
            }
            _ => {}
        }
        match current_block_74 {
            840475230475336896 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_74 = 4801405821185399573;
            }
            _ => {}
        }
        match current_block_74 {
            4801405821185399573 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_74 = 3936359720063008204;
            }
            _ => {}
        }
        match current_block_74 {
            3936359720063008204 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_74 = 4138028631709185825;
            }
            _ => {}
        }
        match current_block_74 {
            4138028631709185825 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        varpeek = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        if !varpeek_map.is_null() {
            _hf_bkt = _hf_hashv
                & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
            if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
                as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                varpeek = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                varpeek = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
            while varpeek as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*varpeek).hh.hashv == _hf_hashv {
                    if (*varpeek).hh.keylen == _uthash_hfstr_keylen {
                        tmp___2 = memcmp(
                            (*varpeek).hh.key as *const libc::c_void,
                            varpeek_key.as_mut_ptr() as *const libc::c_void,
                            _uthash_hfstr_keylen as size_t,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*varpeek).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    varpeek = ((*varpeek).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_entry_t;
                } else {
                    varpeek = 0 as *mut libc::c_void as *mut varpeek_entry_t;
                }
            }
        }
        if varpeek.is_null() {
            tmp___3 = calloc(
                1 as libc::c_int as size_t,
                ::std::mem::size_of::<varpeek_entry_t>() as libc::c_ulong,
            );
            varpeek = tmp___3 as *mut varpeek_entry_t;
            strncpy(
                ((*varpeek).filename_lineno).as_mut_ptr(),
                varpeek_key.as_mut_ptr() as *const libc::c_char,
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            );
            tmp___4 = strlen(
                ((*varpeek).filename_lineno).as_mut_ptr() as *const libc::c_char,
            );
            _uthash_hastr_keylen = tmp___4 as libc::c_uint;
            _hj_key___0 = &mut *((*varpeek).filename_lineno)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize) as *mut libc::c_char
                as *const libc::c_uchar;
            _ha_hashv = 4276993775 as libc::c_uint;
            _hj_j___0 = 2654435769 as libc::c_uint;
            _hj_i___0 = _hj_j___0;
            _hj_k___0 = _uthash_hastr_keylen;
            while _hj_k___0 >= 12 as libc::c_uint {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___0.offset(1 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(2 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(3 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___0.offset(5 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(6 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(7 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _ha_hashv = _ha_hashv
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___0.offset(9 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(10 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(11 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
                _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
                _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
                _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
                _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
                _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
                _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
                _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
                _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
                _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
                _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
                _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
                _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
                _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
                _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
                _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
                _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
                _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
                _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
                _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
                _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
                _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
                _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
            }
            _ha_hashv = _ha_hashv.wrapping_add(_uthash_hastr_keylen);
            let mut current_block_185: u64;
            match _hj_k___0 {
                11 => {
                    _ha_hashv = _ha_hashv
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_185 = 16842915216900049512;
                }
                10 => {
                    current_block_185 = 16842915216900049512;
                }
                9 => {
                    current_block_185 = 4768595193237277684;
                }
                8 => {
                    current_block_185 = 7436474087617346210;
                }
                7 => {
                    current_block_185 = 2338404663740643194;
                }
                6 => {
                    current_block_185 = 10548392101688309197;
                }
                5 => {
                    current_block_185 = 6127226897011585180;
                }
                4 => {
                    current_block_185 = 6922367094506587990;
                }
                3 => {
                    current_block_185 = 6138085628227349250;
                }
                2 => {
                    current_block_185 = 10138930824169494442;
                }
                1 => {
                    current_block_185 = 5933523187125570184;
                }
                _ => {
                    current_block_185 = 18009804086567542307;
                }
            }
            match current_block_185 {
                16842915216900049512 => {
                    _ha_hashv = _ha_hashv
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_185 = 4768595193237277684;
                }
                _ => {}
            }
            match current_block_185 {
                4768595193237277684 => {
                    _ha_hashv = _ha_hashv
                        .wrapping_add(
                            (*_hj_key___0.offset(8 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_185 = 7436474087617346210;
                }
                _ => {}
            }
            match current_block_185 {
                7436474087617346210 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_185 = 2338404663740643194;
                }
                _ => {}
            }
            match current_block_185 {
                2338404663740643194 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_185 = 10548392101688309197;
                }
                _ => {}
            }
            match current_block_185 {
                10548392101688309197 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_185 = 6127226897011585180;
                }
                _ => {}
            }
            match current_block_185 {
                6127226897011585180 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            *_hj_key___0.offset(4 as libc::c_int as isize)
                                as libc::c_uint,
                        );
                    current_block_185 = 6922367094506587990;
                }
                _ => {}
            }
            match current_block_185 {
                6922367094506587990 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_185 = 6138085628227349250;
                }
                _ => {}
            }
            match current_block_185 {
                6138085628227349250 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_185 = 10138930824169494442;
                }
                _ => {}
            }
            match current_block_185 {
                10138930824169494442 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_185 = 5933523187125570184;
                }
                _ => {}
            }
            match current_block_185 {
                5933523187125570184 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            *_hj_key___0.offset(0 as libc::c_int as isize)
                                as libc::c_uint,
                        );
                }
                _ => {}
            }
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
            (*varpeek).hh.hashv = _ha_hashv;
            (*varpeek)
                .hh
                .key = &mut *((*varpeek).filename_lineno)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize) as *mut libc::c_char
                as *mut libc::c_void;
            (*varpeek).hh.keylen = _uthash_hastr_keylen;
            if varpeek_map.is_null() {
                (*varpeek).hh.next = 0 as *mut libc::c_void;
                (*varpeek).hh.prev = 0 as *mut libc::c_void;
                tmp___5 = malloc(
                    ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                );
                (*varpeek).hh.tbl = tmp___5 as *mut UT_hash_table;
                if ((*varpeek).hh.tbl).is_null() {
                    exit(-(1 as libc::c_int));
                } else {
                    memset(
                        (*varpeek).hh.tbl as *mut libc::c_void,
                        '\u{0}' as i32,
                        ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                    );
                    (*(*varpeek).hh.tbl).tail = &mut (*varpeek).hh;
                    (*(*varpeek).hh.tbl).num_buckets = 32 as libc::c_uint;
                    (*(*varpeek).hh.tbl).log2_num_buckets = 5 as libc::c_uint;
                    (*(*varpeek).hh.tbl)
                        .hho = (&mut (*varpeek).hh as *mut UT_hash_handle
                        as *mut libc::c_char)
                        .offset_from(varpeek as *mut libc::c_char) as libc::c_long;
                    tmp___6 = malloc(
                        (32 as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                    (*(*varpeek).hh.tbl).buckets = tmp___6 as *mut UT_hash_bucket;
                    (*(*varpeek).hh.tbl).signature = 2685476833 as libc::c_uint;
                    if ((*(*varpeek).hh.tbl).buckets).is_null() {
                        exit(-(1 as libc::c_int));
                    } else {
                        memset(
                            (*(*varpeek).hh.tbl).buckets as *mut libc::c_void,
                            '\u{0}' as i32,
                            (32 as libc::c_ulong)
                                .wrapping_mul(
                                    ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                ),
                        );
                    }
                }
                varpeek_map = varpeek;
            } else {
                (*varpeek).hh.tbl = (*varpeek_map).hh.tbl;
                (*varpeek).hh.next = 0 as *mut libc::c_void;
                (*varpeek)
                    .hh
                    .prev = ((*(*varpeek_map).hh.tbl).tail as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void;
                (*(*(*varpeek_map).hh.tbl).tail).next = varpeek as *mut libc::c_void;
                (*(*varpeek_map).hh.tbl).tail = &mut (*varpeek).hh;
            }
            (*(*varpeek_map).hh.tbl)
                .num_items = ((*(*varpeek_map).hh.tbl).num_items).wrapping_add(1);
            _ha_bkt = _ha_hashv
                & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
            _ha_head = ((*(*varpeek_map).hh.tbl).buckets).offset(_ha_bkt as isize);
            (*_ha_head).count = ((*_ha_head).count).wrapping_add(1);
            (*varpeek).hh.hh_next = (*_ha_head).hh_head;
            (*varpeek).hh.hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
            if (*_ha_head).hh_head as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                (*(*_ha_head).hh_head).hh_prev = &mut (*varpeek).hh;
            }
            (*_ha_head).hh_head = &mut (*varpeek).hh;
            if (*_ha_head).count
                >= ((*_ha_head).expand_mult)
                    .wrapping_add(1 as libc::c_uint)
                    .wrapping_mul(10 as libc::c_uint)
            {
                if (*(*varpeek).hh.tbl).noexpand == 0 {
                    tmp___7 = malloc(
                        (2 as libc::c_ulong)
                            .wrapping_mul(
                                (*(*varpeek).hh.tbl).num_buckets as libc::c_ulong,
                            )
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                    _he_new_buckets = tmp___7 as *mut UT_hash_bucket;
                    if _he_new_buckets.is_null() {
                        exit(-(1 as libc::c_int));
                    } else {
                        memset(
                            _he_new_buckets as *mut libc::c_void,
                            '\u{0}' as i32,
                            (2 as libc::c_ulong)
                                .wrapping_mul(
                                    (*(*varpeek).hh.tbl).num_buckets as libc::c_ulong,
                                )
                                .wrapping_mul(
                                    ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                ),
                        );
                        if (*(*varpeek).hh.tbl).num_items
                            & ((*(*varpeek).hh.tbl).num_buckets)
                                .wrapping_mul(2 as libc::c_uint)
                                .wrapping_sub(1 as libc::c_uint) != 0 as libc::c_uint
                        {
                            tmp___8 = 1 as libc::c_uint;
                        } else {
                            tmp___8 = 0 as libc::c_uint;
                        }
                        (*(*varpeek).hh.tbl)
                            .ideal_chain_maxlen = ((*(*varpeek).hh.tbl).num_items
                            >> ((*(*varpeek).hh.tbl).log2_num_buckets)
                                .wrapping_add(1 as libc::c_uint))
                            .wrapping_add(tmp___8);
                        (*(*varpeek).hh.tbl).nonideal_items = 0 as libc::c_uint;
                        _he_bkt_i = 0 as libc::c_uint;
                        while _he_bkt_i < (*(*varpeek).hh.tbl).num_buckets {
                            _he_thh = (*((*(*varpeek).hh.tbl).buckets)
                                .offset(_he_bkt_i as isize))
                                .hh_head;
                            while _he_thh as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                _he_hh_nxt = (*_he_thh).hh_next;
                                _he_bkt = (*_he_thh).hashv
                                    & ((*(*varpeek).hh.tbl).num_buckets)
                                        .wrapping_mul(2 as libc::c_uint)
                                        .wrapping_sub(1 as libc::c_uint);
                                _he_newbkt = _he_new_buckets.offset(_he_bkt as isize);
                                (*_he_newbkt).count = ((*_he_newbkt).count).wrapping_add(1);
                                if (*_he_newbkt).count
                                    > (*(*varpeek).hh.tbl).ideal_chain_maxlen
                                {
                                    (*(*varpeek).hh.tbl)
                                        .nonideal_items = ((*(*varpeek).hh.tbl).nonideal_items)
                                        .wrapping_add(1);
                                    (*_he_newbkt)
                                        .expand_mult = ((*_he_newbkt).count)
                                        .wrapping_div((*(*varpeek).hh.tbl).ideal_chain_maxlen);
                                }
                                (*_he_thh)
                                    .hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                (*_he_thh).hh_next = (*_he_newbkt).hh_head;
                                if (*_he_newbkt).hh_head as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    (*(*_he_newbkt).hh_head).hh_prev = _he_thh;
                                }
                                (*_he_newbkt).hh_head = _he_thh;
                                _he_thh = _he_hh_nxt;
                            }
                            _he_bkt_i = _he_bkt_i.wrapping_add(1);
                        }
                        free((*(*varpeek).hh.tbl).buckets as *mut libc::c_void);
                        (*(*varpeek).hh.tbl)
                            .num_buckets = ((*(*varpeek).hh.tbl).num_buckets)
                            .wrapping_mul(2 as libc::c_uint);
                        (*(*varpeek).hh.tbl)
                            .log2_num_buckets = ((*(*varpeek).hh.tbl).log2_num_buckets)
                            .wrapping_add(1);
                        (*(*varpeek).hh.tbl).buckets = _he_new_buckets;
                        if (*(*varpeek).hh.tbl).nonideal_items
                            > (*(*varpeek).hh.tbl).num_items >> 1 as libc::c_int
                        {
                            (*(*varpeek).hh.tbl)
                                .ineff_expands = ((*(*varpeek).hh.tbl).ineff_expands)
                                .wrapping_add(1);
                        } else {
                            (*(*varpeek).hh.tbl).ineff_expands = 0 as libc::c_uint;
                        }
                        if (*(*varpeek).hh.tbl).ineff_expands > 1 as libc::c_uint {
                            (*(*varpeek).hh.tbl).noexpand = 1 as libc::c_uint;
                        }
                    }
                }
            }
        }
        tmp___9 = calloc(
            1 as libc::c_int as size_t,
            ::std::mem::size_of::<varpeek_var_t>() as libc::c_ulong,
        );
        var = tmp___9 as *mut varpeek_var_t;
        snprintf(
            ((*var).name).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b"%.*s\0" as *const u8 as *const libc::c_char,
            at_sign.offset_from(varspec) as libc::c_long as libc::c_int,
            varspec,
        );
        tmp___10 = strlen(((*var).name).as_mut_ptr() as *const libc::c_char);
        _uthash_hastr_keylen___0 = tmp___10 as libc::c_uint;
        _hj_key___1 = &mut *((*var).name).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut libc::c_char as *const libc::c_uchar;
        _ha_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___1 = 2654435769 as libc::c_uint;
        _hj_i___1 = _hj_j___1;
        _hj_k___1 = _uthash_hastr_keylen___0;
        while _hj_k___1 >= 12 as libc::c_uint {
            _hj_i___1 = _hj_i___1
                .wrapping_add(
                    (*_hj_key___1.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___1.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___1.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___1.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___1 = _hj_j___1
                .wrapping_add(
                    (*_hj_key___1.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___1.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___1.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___1.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _ha_hashv___0 = _ha_hashv___0
                .wrapping_add(
                    (*_hj_key___1.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___1.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___1.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___1.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
            _hj_i___1 = _hj_i___1.wrapping_sub(_ha_hashv___0);
            _hj_i___1 ^= _ha_hashv___0 >> 13 as libc::c_int;
            _hj_j___1 = _hj_j___1.wrapping_sub(_ha_hashv___0);
            _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
            _hj_j___1 ^= _hj_i___1 << 8 as libc::c_int;
            _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___1);
            _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___1);
            _ha_hashv___0 ^= _hj_j___1 >> 13 as libc::c_int;
            _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
            _hj_i___1 = _hj_i___1.wrapping_sub(_ha_hashv___0);
            _hj_i___1 ^= _ha_hashv___0 >> 12 as libc::c_int;
            _hj_j___1 = _hj_j___1.wrapping_sub(_ha_hashv___0);
            _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
            _hj_j___1 ^= _hj_i___1 << 16 as libc::c_int;
            _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___1);
            _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___1);
            _ha_hashv___0 ^= _hj_j___1 >> 5 as libc::c_int;
            _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
            _hj_i___1 = _hj_i___1.wrapping_sub(_ha_hashv___0);
            _hj_i___1 ^= _ha_hashv___0 >> 3 as libc::c_int;
            _hj_j___1 = _hj_j___1.wrapping_sub(_ha_hashv___0);
            _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
            _hj_j___1 ^= _hj_i___1 << 10 as libc::c_int;
            _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___1);
            _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___1);
            _ha_hashv___0 ^= _hj_j___1 >> 15 as libc::c_int;
            _hj_key___1 = _hj_key___1.offset(12 as libc::c_int as isize);
            _hj_k___1 = _hj_k___1.wrapping_sub(12 as libc::c_uint);
        }
        _ha_hashv___0 = _ha_hashv___0.wrapping_add(_uthash_hastr_keylen___0);
        let mut current_block_381: u64;
        match _hj_k___1 {
            11 => {
                _ha_hashv___0 = _ha_hashv___0
                    .wrapping_add(
                        (*_hj_key___1.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_381 = 7894745075995980557;
            }
            10 => {
                current_block_381 = 7894745075995980557;
            }
            9 => {
                current_block_381 = 15106467998494609679;
            }
            8 => {
                current_block_381 = 1269601209473169247;
            }
            7 => {
                current_block_381 = 3045881946759993227;
            }
            6 => {
                current_block_381 = 9561619043351057609;
            }
            5 => {
                current_block_381 = 7688274332601903809;
            }
            4 => {
                current_block_381 = 8298852434379543549;
            }
            3 => {
                current_block_381 = 9160261197181570026;
            }
            2 => {
                current_block_381 = 9352411590983226390;
            }
            1 => {
                current_block_381 = 120570791738685635;
            }
            _ => {
                current_block_381 = 8625465213201146391;
            }
        }
        match current_block_381 {
            7894745075995980557 => {
                _ha_hashv___0 = _ha_hashv___0
                    .wrapping_add(
                        (*_hj_key___1.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_381 = 15106467998494609679;
            }
            _ => {}
        }
        match current_block_381 {
            15106467998494609679 => {
                _ha_hashv___0 = _ha_hashv___0
                    .wrapping_add(
                        (*_hj_key___1.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_381 = 1269601209473169247;
            }
            _ => {}
        }
        match current_block_381 {
            1269601209473169247 => {
                _hj_j___1 = _hj_j___1
                    .wrapping_add(
                        (*_hj_key___1.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_381 = 3045881946759993227;
            }
            _ => {}
        }
        match current_block_381 {
            3045881946759993227 => {
                _hj_j___1 = _hj_j___1
                    .wrapping_add(
                        (*_hj_key___1.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_381 = 9561619043351057609;
            }
            _ => {}
        }
        match current_block_381 {
            9561619043351057609 => {
                _hj_j___1 = _hj_j___1
                    .wrapping_add(
                        (*_hj_key___1.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_381 = 7688274332601903809;
            }
            _ => {}
        }
        match current_block_381 {
            7688274332601903809 => {
                _hj_j___1 = _hj_j___1
                    .wrapping_add(
                        *_hj_key___1.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_381 = 8298852434379543549;
            }
            _ => {}
        }
        match current_block_381 {
            8298852434379543549 => {
                _hj_i___1 = _hj_i___1
                    .wrapping_add(
                        (*_hj_key___1.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_381 = 9160261197181570026;
            }
            _ => {}
        }
        match current_block_381 {
            9160261197181570026 => {
                _hj_i___1 = _hj_i___1
                    .wrapping_add(
                        (*_hj_key___1.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_381 = 9352411590983226390;
            }
            _ => {}
        }
        match current_block_381 {
            9352411590983226390 => {
                _hj_i___1 = _hj_i___1
                    .wrapping_add(
                        (*_hj_key___1.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_381 = 120570791738685635;
            }
            _ => {}
        }
        match current_block_381 {
            120570791738685635 => {
                _hj_i___1 = _hj_i___1
                    .wrapping_add(
                        *_hj_key___1.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
        _hj_i___1 = _hj_i___1.wrapping_sub(_ha_hashv___0);
        _hj_i___1 ^= _ha_hashv___0 >> 13 as libc::c_int;
        _hj_j___1 = _hj_j___1.wrapping_sub(_ha_hashv___0);
        _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
        _hj_j___1 ^= _hj_i___1 << 8 as libc::c_int;
        _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___1);
        _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___1);
        _ha_hashv___0 ^= _hj_j___1 >> 13 as libc::c_int;
        _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
        _hj_i___1 = _hj_i___1.wrapping_sub(_ha_hashv___0);
        _hj_i___1 ^= _ha_hashv___0 >> 12 as libc::c_int;
        _hj_j___1 = _hj_j___1.wrapping_sub(_ha_hashv___0);
        _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
        _hj_j___1 ^= _hj_i___1 << 16 as libc::c_int;
        _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___1);
        _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___1);
        _ha_hashv___0 ^= _hj_j___1 >> 5 as libc::c_int;
        _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
        _hj_i___1 = _hj_i___1.wrapping_sub(_ha_hashv___0);
        _hj_i___1 ^= _ha_hashv___0 >> 3 as libc::c_int;
        _hj_j___1 = _hj_j___1.wrapping_sub(_ha_hashv___0);
        _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
        _hj_j___1 ^= _hj_i___1 << 10 as libc::c_int;
        _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___1);
        _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___1);
        _ha_hashv___0 ^= _hj_j___1 >> 15 as libc::c_int;
        (*var).hh.hashv = _ha_hashv___0;
        (*var)
            .hh
            .key = &mut *((*var).name).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut libc::c_char as *mut libc::c_void;
        (*var).hh.keylen = _uthash_hastr_keylen___0;
        if ((*varpeek).varmap).is_null() {
            (*var).hh.next = 0 as *mut libc::c_void;
            (*var).hh.prev = 0 as *mut libc::c_void;
            tmp___11 = malloc(::std::mem::size_of::<UT_hash_table>() as libc::c_ulong);
            (*var).hh.tbl = tmp___11 as *mut UT_hash_table;
            if ((*var).hh.tbl).is_null() {
                exit(-(1 as libc::c_int));
            } else {
                memset(
                    (*var).hh.tbl as *mut libc::c_void,
                    '\u{0}' as i32,
                    ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                );
                (*(*var).hh.tbl).tail = &mut (*var).hh;
                (*(*var).hh.tbl).num_buckets = 32 as libc::c_uint;
                (*(*var).hh.tbl).log2_num_buckets = 5 as libc::c_uint;
                (*(*var).hh.tbl)
                    .hho = (&mut (*var).hh as *mut UT_hash_handle as *mut libc::c_char)
                    .offset_from(var as *mut libc::c_char) as libc::c_long;
                tmp___12 = malloc(
                    (32 as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                        ),
                );
                (*(*var).hh.tbl).buckets = tmp___12 as *mut UT_hash_bucket;
                (*(*var).hh.tbl).signature = 2685476833 as libc::c_uint;
                if ((*(*var).hh.tbl).buckets).is_null() {
                    exit(-(1 as libc::c_int));
                } else {
                    memset(
                        (*(*var).hh.tbl).buckets as *mut libc::c_void,
                        '\u{0}' as i32,
                        (32 as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                }
            }
            (*varpeek).varmap = var;
        } else {
            (*var).hh.tbl = (*(*varpeek).varmap).hh.tbl;
            (*var).hh.next = 0 as *mut libc::c_void;
            (*var)
                .hh
                .prev = ((*(*(*varpeek).varmap).hh.tbl).tail as *mut libc::c_char)
                .offset(-((*(*(*varpeek).varmap).hh.tbl).hho as isize))
                as *mut libc::c_void;
            (*(*(*(*varpeek).varmap).hh.tbl).tail).next = var as *mut libc::c_void;
            (*(*(*varpeek).varmap).hh.tbl).tail = &mut (*var).hh;
        }
        (*(*(*varpeek).varmap).hh.tbl)
            .num_items = ((*(*(*varpeek).varmap).hh.tbl).num_items).wrapping_add(1);
        _ha_bkt___0 = _ha_hashv___0
            & ((*(*(*varpeek).varmap).hh.tbl).num_buckets)
                .wrapping_sub(1 as libc::c_uint);
        _ha_head___0 = ((*(*(*varpeek).varmap).hh.tbl).buckets)
            .offset(_ha_bkt___0 as isize);
        (*_ha_head___0).count = ((*_ha_head___0).count).wrapping_add(1);
        (*var).hh.hh_next = (*_ha_head___0).hh_head;
        (*var).hh.hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
        if (*_ha_head___0).hh_head as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            (*(*_ha_head___0).hh_head).hh_prev = &mut (*var).hh;
        }
        (*_ha_head___0).hh_head = &mut (*var).hh;
        if (*_ha_head___0).count
            >= ((*_ha_head___0).expand_mult)
                .wrapping_add(1 as libc::c_uint)
                .wrapping_mul(10 as libc::c_uint)
        {
            if (*(*var).hh.tbl).noexpand == 0 {
                tmp___13 = malloc(
                    (2 as libc::c_ulong)
                        .wrapping_mul((*(*var).hh.tbl).num_buckets as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                        ),
                );
                _he_new_buckets___0 = tmp___13 as *mut UT_hash_bucket;
                if _he_new_buckets___0.is_null() {
                    exit(-(1 as libc::c_int));
                } else {
                    memset(
                        _he_new_buckets___0 as *mut libc::c_void,
                        '\u{0}' as i32,
                        (2 as libc::c_ulong)
                            .wrapping_mul((*(*var).hh.tbl).num_buckets as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                    if (*(*var).hh.tbl).num_items
                        & ((*(*var).hh.tbl).num_buckets)
                            .wrapping_mul(2 as libc::c_uint)
                            .wrapping_sub(1 as libc::c_uint) != 0 as libc::c_uint
                    {
                        tmp___14 = 1 as libc::c_uint;
                    } else {
                        tmp___14 = 0 as libc::c_uint;
                    }
                    (*(*var).hh.tbl)
                        .ideal_chain_maxlen = ((*(*var).hh.tbl).num_items
                        >> ((*(*var).hh.tbl).log2_num_buckets)
                            .wrapping_add(1 as libc::c_uint))
                        .wrapping_add(tmp___14);
                    (*(*var).hh.tbl).nonideal_items = 0 as libc::c_uint;
                    _he_bkt_i___0 = 0 as libc::c_uint;
                    while _he_bkt_i___0 < (*(*var).hh.tbl).num_buckets {
                        _he_thh___0 = (*((*(*var).hh.tbl).buckets)
                            .offset(_he_bkt_i___0 as isize))
                            .hh_head;
                        while _he_thh___0 as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            _he_hh_nxt___0 = (*_he_thh___0).hh_next;
                            _he_bkt___0 = (*_he_thh___0).hashv
                                & ((*(*var).hh.tbl).num_buckets)
                                    .wrapping_mul(2 as libc::c_uint)
                                    .wrapping_sub(1 as libc::c_uint);
                            _he_newbkt___0 = _he_new_buckets___0
                                .offset(_he_bkt___0 as isize);
                            (*_he_newbkt___0)
                                .count = ((*_he_newbkt___0).count).wrapping_add(1);
                            if (*_he_newbkt___0).count
                                > (*(*var).hh.tbl).ideal_chain_maxlen
                            {
                                (*(*var).hh.tbl)
                                    .nonideal_items = ((*(*var).hh.tbl).nonideal_items)
                                    .wrapping_add(1);
                                (*_he_newbkt___0)
                                    .expand_mult = ((*_he_newbkt___0).count)
                                    .wrapping_div((*(*var).hh.tbl).ideal_chain_maxlen);
                            }
                            (*_he_thh___0)
                                .hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                            (*_he_thh___0).hh_next = (*_he_newbkt___0).hh_head;
                            if (*_he_newbkt___0).hh_head as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                (*(*_he_newbkt___0).hh_head).hh_prev = _he_thh___0;
                            }
                            (*_he_newbkt___0).hh_head = _he_thh___0;
                            _he_thh___0 = _he_hh_nxt___0;
                        }
                        _he_bkt_i___0 = _he_bkt_i___0.wrapping_add(1);
                    }
                    free((*(*var).hh.tbl).buckets as *mut libc::c_void);
                    (*(*var).hh.tbl)
                        .num_buckets = ((*(*var).hh.tbl).num_buckets)
                        .wrapping_mul(2 as libc::c_uint);
                    (*(*var).hh.tbl)
                        .log2_num_buckets = ((*(*var).hh.tbl).log2_num_buckets)
                        .wrapping_add(1);
                    (*(*var).hh.tbl).buckets = _he_new_buckets___0;
                    if (*(*var).hh.tbl).nonideal_items
                        > (*(*var).hh.tbl).num_items >> 1 as libc::c_int
                    {
                        (*(*var).hh.tbl)
                            .ineff_expands = ((*(*var).hh.tbl).ineff_expands)
                            .wrapping_add(1);
                    } else {
                        (*(*var).hh.tbl).ineff_expands = 0 as libc::c_uint;
                    }
                    if (*(*var).hh.tbl).ineff_expands > 1 as libc::c_uint {
                        (*(*var).hh.tbl).noexpand = 1 as libc::c_uint;
                    }
                }
            }
        }
        lineno = lineno.wrapping_add(1);
    }
}
unsafe extern "C" fn glopeek_add(mut glospec: *mut libc::c_char) {
    let mut dot: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut gloname: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _uthash_hastr_keylen: libc::c_uint = 0;
    let mut tmp___8: size_t = 0;
    let mut _ha_hashv: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _ha_bkt: libc::c_uint = 0;
    let mut _ha_head: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_bkt: libc::c_uint = 0;
    let mut _he_bkt_i: libc::c_uint = 0;
    let mut _he_thh: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_hh_nxt: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_new_buckets: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_newbkt: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: libc::c_uint = 0;
    dot = strchr(glospec as *const libc::c_char, '.' as i32);
    if dot.is_null() {
        log_error(
            b"glopeek_add: Malformed glospec: %s\n\n\0" as *const u8
                as *const libc::c_char,
            glospec,
        );
        usage(stderr, 1 as libc::c_int);
    }
    tmp = strlen(glospec as *const libc::c_char);
    _uthash_hfstr_keylen = tmp as libc::c_uint;
    _hj_key = glospec as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_58: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_58 = 6663386889101824274;
        }
        10 => {
            current_block_58 = 6663386889101824274;
        }
        9 => {
            current_block_58 = 3986343704479077829;
        }
        8 => {
            current_block_58 = 7316564558619993345;
        }
        7 => {
            current_block_58 = 16149001981823388618;
        }
        6 => {
            current_block_58 = 17152694404469101753;
        }
        5 => {
            current_block_58 = 1957380298155704371;
        }
        4 => {
            current_block_58 = 6465220999181335856;
        }
        3 => {
            current_block_58 = 6045721050461829827;
        }
        2 => {
            current_block_58 = 4854112010246695789;
        }
        1 => {
            current_block_58 = 10619942410194141143;
        }
        _ => {
            current_block_58 = 1623252117315916725;
        }
    }
    match current_block_58 {
        6663386889101824274 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_58 = 3986343704479077829;
        }
        _ => {}
    }
    match current_block_58 {
        3986343704479077829 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_58 = 7316564558619993345;
        }
        _ => {}
    }
    match current_block_58 {
        7316564558619993345 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_58 = 16149001981823388618;
        }
        _ => {}
    }
    match current_block_58 {
        16149001981823388618 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_58 = 17152694404469101753;
        }
        _ => {}
    }
    match current_block_58 {
        17152694404469101753 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_58 = 1957380298155704371;
        }
        _ => {}
    }
    match current_block_58 {
        1957380298155704371 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_58 = 6465220999181335856;
        }
        _ => {}
    }
    match current_block_58 {
        6465220999181335856 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_58 = 6045721050461829827;
        }
        _ => {}
    }
    match current_block_58 {
        6045721050461829827 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_58 = 4854112010246695789;
        }
        _ => {}
    }
    match current_block_58 {
        4854112010246695789 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_58 = 10619942410194141143;
        }
        _ => {}
    }
    match current_block_58 {
        10619942410194141143 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    gentry = 0 as *mut libc::c_void as *mut glopeek_entry_t;
    if !glopeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*glopeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*glopeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            gentry = ((*((*(*glopeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*glopeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut glopeek_entry_t;
        } else {
            gentry = 0 as *mut libc::c_void as *mut glopeek_entry_t;
        }
        while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*gentry).hh.hashv == _hf_hashv {
                if (*gentry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___0 = memcmp(
                        (*gentry).hh.key as *const libc::c_void,
                        glospec as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___0 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*gentry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                gentry = ((*gentry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*glopeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut glopeek_entry_t;
            } else {
                gentry = 0 as *mut libc::c_void as *mut glopeek_entry_t;
            }
        }
    }
    if !gentry.is_null() {
        return;
    }
    tmp___6 = strncmp(
        b"post.\0" as *const u8 as *const libc::c_char,
        glospec as *const libc::c_char,
        dot.offset_from(glospec) as libc::c_long as size_t,
    );
    if tmp___6 == 0 as libc::c_int {
        gloname = b"_POST\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    } else {
        tmp___5 = strncmp(
            b"get.\0" as *const u8 as *const libc::c_char,
            glospec as *const libc::c_char,
            dot.offset_from(glospec) as libc::c_long as size_t,
        );
        if tmp___5 == 0 as libc::c_int {
            gloname = b"_GET\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        } else {
            tmp___4 = strncmp(
                b"cookie.\0" as *const u8 as *const libc::c_char,
                glospec as *const libc::c_char,
                dot.offset_from(glospec) as libc::c_long as size_t,
            );
            if tmp___4 == 0 as libc::c_int {
                gloname = b"_COOKIE\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
            } else {
                tmp___3 = strncmp(
                    b"server.\0" as *const u8 as *const libc::c_char,
                    glospec as *const libc::c_char,
                    dot.offset_from(glospec) as libc::c_long as size_t,
                );
                if tmp___3 == 0 as libc::c_int {
                    gloname = b"_SERVER\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                } else {
                    tmp___2 = strncmp(
                        b"files.\0" as *const u8 as *const libc::c_char,
                        glospec as *const libc::c_char,
                        dot.offset_from(glospec) as libc::c_long as size_t,
                    );
                    if tmp___2 == 0 as libc::c_int {
                        gloname = b"_FILES\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                    } else {
                        tmp___1 = strncmp(
                            b"globals.\0" as *const u8 as *const libc::c_char,
                            glospec as *const libc::c_char,
                            dot.offset_from(glospec) as libc::c_long as size_t,
                        );
                        if tmp___1 == 0 as libc::c_int {
                            gloname = b"\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        } else {
                            log_error(
                                b"glopeek_add: Invalid global: %s\n\n\0" as *const u8
                                    as *const libc::c_char,
                                glospec,
                            );
                            usage(stderr, 1 as libc::c_int);
                        }
                    }
                }
            }
        }
    }
    tmp___7 = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<glopeek_entry_t>() as libc::c_ulong,
    );
    gentry = tmp___7 as *mut glopeek_entry_t;
    snprintf(
        ((*gentry).key).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        glospec,
    );
    snprintf(
        ((*gentry).gloname).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        gloname,
    );
    snprintf(
        ((*gentry).varname).as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s\0" as *const u8 as *const libc::c_char,
        dot.offset(1 as libc::c_int as isize),
    );
    tmp___8 = strlen(((*gentry).key).as_mut_ptr() as *const libc::c_char);
    _uthash_hastr_keylen = tmp___8 as libc::c_uint;
    _hj_key___0 = &mut *((*gentry).key).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut libc::c_char as *const libc::c_uchar;
    _ha_hashv = 4276993775 as libc::c_uint;
    _hj_j___0 = 2654435769 as libc::c_uint;
    _hj_i___0 = _hj_j___0;
    _hj_k___0 = _uthash_hastr_keylen;
    while _hj_k___0 >= 12 as libc::c_uint {
        _hj_i___0 = _hj_i___0
            .wrapping_add(
                (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j___0 = _hj_j___0
            .wrapping_add(
                (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _ha_hashv = _ha_hashv
            .wrapping_add(
                (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key___0.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
        _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
        _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
        _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
        _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
        _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
        _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
        _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
        _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
    }
    _ha_hashv = _ha_hashv.wrapping_add(_uthash_hastr_keylen);
    let mut current_block_206: u64;
    match _hj_k___0 {
        11 => {
            _ha_hashv = _ha_hashv
                .wrapping_add(
                    (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_206 = 8697487052610783712;
        }
        10 => {
            current_block_206 = 8697487052610783712;
        }
        9 => {
            current_block_206 = 18138810494823327305;
        }
        8 => {
            current_block_206 = 4398528925228648566;
        }
        7 => {
            current_block_206 = 16656535096080077038;
        }
        6 => {
            current_block_206 = 7923489464634278509;
        }
        5 => {
            current_block_206 = 9520522480845047218;
        }
        4 => {
            current_block_206 = 9915810670781950341;
        }
        3 => {
            current_block_206 = 321135136330141110;
        }
        2 => {
            current_block_206 = 9962125251217308354;
        }
        1 => {
            current_block_206 = 8015033599878225731;
        }
        _ => {
            current_block_206 = 18312853480645871422;
        }
    }
    match current_block_206 {
        8697487052610783712 => {
            _ha_hashv = _ha_hashv
                .wrapping_add(
                    (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_206 = 18138810494823327305;
        }
        _ => {}
    }
    match current_block_206 {
        18138810494823327305 => {
            _ha_hashv = _ha_hashv
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_206 = 4398528925228648566;
        }
        _ => {}
    }
    match current_block_206 {
        4398528925228648566 => {
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_206 = 16656535096080077038;
        }
        _ => {}
    }
    match current_block_206 {
        16656535096080077038 => {
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_206 = 7923489464634278509;
        }
        _ => {}
    }
    match current_block_206 {
        7923489464634278509 => {
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_206 = 9520522480845047218;
        }
        _ => {}
    }
    match current_block_206 {
        9520522480845047218 => {
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_206 = 9915810670781950341;
        }
        _ => {}
    }
    match current_block_206 {
        9915810670781950341 => {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_206 = 321135136330141110;
        }
        _ => {}
    }
    match current_block_206 {
        321135136330141110 => {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_206 = 9962125251217308354;
        }
        _ => {}
    }
    match current_block_206 {
        9962125251217308354 => {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_206 = 8015033599878225731;
        }
        _ => {}
    }
    match current_block_206 {
        8015033599878225731 => {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
    _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
    _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
    _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
    _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
    _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
    _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
    _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
    _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
    _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
    _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
    _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
    _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
    _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
    _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
    _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
    _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
    _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
    _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
    _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
    _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
    _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
    _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
    _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
    _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
    _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
    _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
    (*gentry).hh.hashv = _ha_hashv;
    (*gentry)
        .hh
        .key = &mut *((*gentry).key).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut libc::c_char as *mut libc::c_void;
    (*gentry).hh.keylen = _uthash_hastr_keylen;
    if glopeek_map.is_null() {
        (*gentry).hh.next = 0 as *mut libc::c_void;
        (*gentry).hh.prev = 0 as *mut libc::c_void;
        tmp___9 = malloc(::std::mem::size_of::<UT_hash_table>() as libc::c_ulong);
        (*gentry).hh.tbl = tmp___9 as *mut UT_hash_table;
        if ((*gentry).hh.tbl).is_null() {
            exit(-(1 as libc::c_int));
        } else {
            memset(
                (*gentry).hh.tbl as *mut libc::c_void,
                '\u{0}' as i32,
                ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
            );
            (*(*gentry).hh.tbl).tail = &mut (*gentry).hh;
            (*(*gentry).hh.tbl).num_buckets = 32 as libc::c_uint;
            (*(*gentry).hh.tbl).log2_num_buckets = 5 as libc::c_uint;
            (*(*gentry).hh.tbl)
                .hho = (&mut (*gentry).hh as *mut UT_hash_handle as *mut libc::c_char)
                .offset_from(gentry as *mut libc::c_char) as libc::c_long;
            tmp___10 = malloc(
                (32 as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                    ),
            );
            (*(*gentry).hh.tbl).buckets = tmp___10 as *mut UT_hash_bucket;
            (*(*gentry).hh.tbl).signature = 2685476833 as libc::c_uint;
            if ((*(*gentry).hh.tbl).buckets).is_null() {
                exit(-(1 as libc::c_int));
            } else {
                memset(
                    (*(*gentry).hh.tbl).buckets as *mut libc::c_void,
                    '\u{0}' as i32,
                    (32 as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                        ),
                );
            }
        }
        glopeek_map = gentry;
    } else {
        (*gentry).hh.tbl = (*glopeek_map).hh.tbl;
        (*gentry).hh.next = 0 as *mut libc::c_void;
        (*gentry)
            .hh
            .prev = ((*(*glopeek_map).hh.tbl).tail as *mut libc::c_char)
            .offset(-((*(*glopeek_map).hh.tbl).hho as isize)) as *mut libc::c_void;
        (*(*(*glopeek_map).hh.tbl).tail).next = gentry as *mut libc::c_void;
        (*(*glopeek_map).hh.tbl).tail = &mut (*gentry).hh;
    }
    (*(*glopeek_map).hh.tbl)
        .num_items = ((*(*glopeek_map).hh.tbl).num_items).wrapping_add(1);
    _ha_bkt = _ha_hashv
        & ((*(*glopeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
    _ha_head = ((*(*glopeek_map).hh.tbl).buckets).offset(_ha_bkt as isize);
    (*_ha_head).count = ((*_ha_head).count).wrapping_add(1);
    (*gentry).hh.hh_next = (*_ha_head).hh_head;
    (*gentry).hh.hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
    if (*_ha_head).hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*(*_ha_head).hh_head).hh_prev = &mut (*gentry).hh;
    }
    (*_ha_head).hh_head = &mut (*gentry).hh;
    if (*_ha_head).count
        >= ((*_ha_head).expand_mult)
            .wrapping_add(1 as libc::c_uint)
            .wrapping_mul(10 as libc::c_uint)
    {
        if (*(*gentry).hh.tbl).noexpand == 0 {
            tmp___11 = malloc(
                (2 as libc::c_ulong)
                    .wrapping_mul((*(*gentry).hh.tbl).num_buckets as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                    ),
            );
            _he_new_buckets = tmp___11 as *mut UT_hash_bucket;
            if _he_new_buckets.is_null() {
                exit(-(1 as libc::c_int));
            } else {
                memset(
                    _he_new_buckets as *mut libc::c_void,
                    '\u{0}' as i32,
                    (2 as libc::c_ulong)
                        .wrapping_mul((*(*gentry).hh.tbl).num_buckets as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                        ),
                );
                if (*(*gentry).hh.tbl).num_items
                    & ((*(*gentry).hh.tbl).num_buckets)
                        .wrapping_mul(2 as libc::c_uint)
                        .wrapping_sub(1 as libc::c_uint) != 0 as libc::c_uint
                {
                    tmp___12 = 1 as libc::c_uint;
                } else {
                    tmp___12 = 0 as libc::c_uint;
                }
                (*(*gentry).hh.tbl)
                    .ideal_chain_maxlen = ((*(*gentry).hh.tbl).num_items
                    >> ((*(*gentry).hh.tbl).log2_num_buckets)
                        .wrapping_add(1 as libc::c_uint))
                    .wrapping_add(tmp___12);
                (*(*gentry).hh.tbl).nonideal_items = 0 as libc::c_uint;
                _he_bkt_i = 0 as libc::c_uint;
                while _he_bkt_i < (*(*gentry).hh.tbl).num_buckets {
                    _he_thh = (*((*(*gentry).hh.tbl).buckets).offset(_he_bkt_i as isize))
                        .hh_head;
                    while _he_thh as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        _he_hh_nxt = (*_he_thh).hh_next;
                        _he_bkt = (*_he_thh).hashv
                            & ((*(*gentry).hh.tbl).num_buckets)
                                .wrapping_mul(2 as libc::c_uint)
                                .wrapping_sub(1 as libc::c_uint);
                        _he_newbkt = _he_new_buckets.offset(_he_bkt as isize);
                        (*_he_newbkt).count = ((*_he_newbkt).count).wrapping_add(1);
                        if (*_he_newbkt).count > (*(*gentry).hh.tbl).ideal_chain_maxlen {
                            (*(*gentry).hh.tbl)
                                .nonideal_items = ((*(*gentry).hh.tbl).nonideal_items)
                                .wrapping_add(1);
                            (*_he_newbkt)
                                .expand_mult = ((*_he_newbkt).count)
                                .wrapping_div((*(*gentry).hh.tbl).ideal_chain_maxlen);
                        }
                        (*_he_thh)
                            .hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                        (*_he_thh).hh_next = (*_he_newbkt).hh_head;
                        if (*_he_newbkt).hh_head as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            (*(*_he_newbkt).hh_head).hh_prev = _he_thh;
                        }
                        (*_he_newbkt).hh_head = _he_thh;
                        _he_thh = _he_hh_nxt;
                    }
                    _he_bkt_i = _he_bkt_i.wrapping_add(1);
                }
                free((*(*gentry).hh.tbl).buckets as *mut libc::c_void);
                (*(*gentry).hh.tbl)
                    .num_buckets = ((*(*gentry).hh.tbl).num_buckets)
                    .wrapping_mul(2 as libc::c_uint);
                (*(*gentry).hh.tbl)
                    .log2_num_buckets = ((*(*gentry).hh.tbl).log2_num_buckets)
                    .wrapping_add(1);
                (*(*gentry).hh.tbl).buckets = _he_new_buckets;
                if (*(*gentry).hh.tbl).nonideal_items
                    > (*(*gentry).hh.tbl).num_items >> 1 as libc::c_int
                {
                    (*(*gentry).hh.tbl)
                        .ineff_expands = ((*(*gentry).hh.tbl).ineff_expands)
                        .wrapping_add(1);
                } else {
                    (*(*gentry).hh.tbl).ineff_expands = 0 as libc::c_uint;
                }
                if (*(*gentry).hh.tbl).ineff_expands > 1 as libc::c_uint {
                    (*(*gentry).hh.tbl).noexpand = 1 as libc::c_uint;
                }
            }
        }
    }
}
unsafe extern "C" fn copy_proc_mem(
    mut pid: pid_t,
    mut what: *const libc::c_char,
    mut raddr: *mut libc::c_void,
    mut laddr: *mut libc::c_void,
    mut size: size_t,
) -> libc::c_int {
    let mut local: [iovec; 1] = [iovec {
        iov_base: 0 as *mut libc::c_void,
        iov_len: 0,
    }; 1];
    let mut remote: [iovec; 1] = [iovec {
        iov_base: 0 as *mut libc::c_void,
        iov_len: 0,
    }; 1];
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: ssize_t = 0;
    if raddr as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        log_error(
            b"copy_proc_mem: Not copying %s; raddr is NULL\n\0" as *const u8
                as *const libc::c_char,
            what,
        );
        return 1 as libc::c_int;
    }
    local[0 as libc::c_int as usize].iov_base = laddr;
    local[0 as libc::c_int as usize].iov_len = size;
    remote[0 as libc::c_int as usize].iov_base = raddr;
    remote[0 as libc::c_int as usize].iov_len = size;
    tmp___2 = process_vm_readv(
        pid,
        local.as_mut_ptr() as *const iovec,
        1 as libc::c_ulong,
        remote.as_mut_ptr() as *const iovec,
        1 as libc::c_ulong,
        0 as libc::c_ulong,
    );
    if tmp___2 == -(1 as libc::c_long) {
        tmp = __errno_location();
        if *tmp == 3 as libc::c_int {
            perror(b"process_vm_readv\0" as *const u8 as *const libc::c_char);
            return 3 as libc::c_int;
        }
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        log_error(
            b"copy_proc_mem: Failed to copy %s; err=%s raddr=%p size=%lu\n\0"
                as *const u8 as *const libc::c_char,
            what,
            tmp___1,
            raddr,
            size,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_php_version(mut target: *mut trace_target_t) -> libc::c_int {
    let mut basic_functions_module: _zend_module_entry = _zend_module_entry {
        pad0: [0; 88],
        version: 0 as *const libc::c_char,
    };
    let mut version_cmd: [libc::c_char; 1024] = [0; 1024];
    let mut phpv: [libc::c_char; 4] = [0; 4];
    let mut pid: pid_t = 0;
    let mut pcmd: *mut FILE = 0 as *mut FILE;
    let mut tmp: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    pid = (*target).pid;
    phpv[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    if (*target).basic_functions_module_addr != 0 {
        tmp = copy_proc_mem(
            pid,
            b"basic_functions_module\0" as *const u8 as *const libc::c_char,
            (*target).basic_functions_module_addr as *mut libc::c_void,
            &mut basic_functions_module as *mut _zend_module_entry as *mut libc::c_void,
            ::std::mem::size_of::<_zend_module_entry>() as libc::c_ulong,
        );
        if tmp == 0 as libc::c_int {
            copy_proc_mem(
                pid,
                b"basic_functions_module.version\0" as *const u8 as *const libc::c_char,
                basic_functions_module.version as *mut libc::c_void,
                phpv.as_mut_ptr() as *mut libc::c_void,
                3 as libc::c_int as size_t,
            );
        }
    }
    if phpv[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        tmp___0 = snprintf(
            version_cmd.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            b"{ echo -n /proc/%d/root/;   awk -ve=1 '/libphp[78]?/{print $NF; e=0; exit} END{exit e}' /proc/%d/maps   || readlink /proc/%d/exe; } | { xargs stat --printf=%%n 2>/dev/null || echo /proc/%d/exe; } | xargs strings | grep -Po '(?<=X-Powered-By: PHP/)\\d\\.\\d'\0"
                as *const u8 as *const libc::c_char,
            pid,
            pid,
            pid,
            pid,
        );
        n = tmp___0;
        if n as size_t
            >= (::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_ulong)
        {
            log_error(
                b"get_php_version: snprintf overflow\n\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        pcmd = popen(
            version_cmd.as_mut_ptr() as *const libc::c_char,
            b"r\0" as *const u8 as *const libc::c_char,
        );
        if pcmd as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            perror(b"get_php_version: popen\0" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        } else {
            tmp___1 = fread(
                &mut phpv as *mut [libc::c_char; 4] as *mut libc::c_void,
                ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                3 as libc::c_int as size_t,
                pcmd,
            );
            if tmp___1 != 3 as libc::c_ulong {
                log_error(
                    b"get_php_version: Could not detect PHP version\n\0" as *const u8
                        as *const libc::c_char,
                );
                pclose(pcmd);
                return 1 as libc::c_int;
            }
        }
        pclose(pcmd);
    }
    tmp___9 = strncmp(
        phpv.as_mut_ptr() as *const libc::c_char,
        b"7.0\0" as *const u8 as *const libc::c_char,
        3 as libc::c_int as size_t,
    );
    if tmp___9 == 0 as libc::c_int {
        opt_phpv = b"70\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    } else {
        tmp___8 = strncmp(
            phpv.as_mut_ptr() as *const libc::c_char,
            b"7.1\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int as size_t,
        );
        if tmp___8 == 0 as libc::c_int {
            opt_phpv = b"71\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        } else {
            tmp___7 = strncmp(
                phpv.as_mut_ptr() as *const libc::c_char,
                b"7.2\0" as *const u8 as *const libc::c_char,
                3 as libc::c_int as size_t,
            );
            if tmp___7 == 0 as libc::c_int {
                opt_phpv = b"72\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
            } else {
                tmp___6 = strncmp(
                    phpv.as_mut_ptr() as *const libc::c_char,
                    b"7.3\0" as *const u8 as *const libc::c_char,
                    3 as libc::c_int as size_t,
                );
                if tmp___6 == 0 as libc::c_int {
                    opt_phpv = b"73\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                } else {
                    tmp___5 = strncmp(
                        phpv.as_mut_ptr() as *const libc::c_char,
                        b"7.4\0" as *const u8 as *const libc::c_char,
                        3 as libc::c_int as size_t,
                    );
                    if tmp___5 == 0 as libc::c_int {
                        opt_phpv = b"74\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                    } else {
                        tmp___4 = strncmp(
                            phpv.as_mut_ptr() as *const libc::c_char,
                            b"8.0\0" as *const u8 as *const libc::c_char,
                            3 as libc::c_int as size_t,
                        );
                        if tmp___4 == 0 as libc::c_int {
                            opt_phpv = b"80\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        } else {
                            tmp___3 = strncmp(
                                phpv.as_mut_ptr() as *const libc::c_char,
                                b"8.1\0" as *const u8 as *const libc::c_char,
                                3 as libc::c_int as size_t,
                            );
                            if tmp___3 == 0 as libc::c_int {
                                opt_phpv = b"81\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char;
                            } else {
                                tmp___2 = strncmp(
                                    phpv.as_mut_ptr() as *const libc::c_char,
                                    b"8.2\0" as *const u8 as *const libc::c_char,
                                    3 as libc::c_int as size_t,
                                );
                                if tmp___2 == 0 as libc::c_int {
                                    opt_phpv = b"82\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char;
                                } else {
                                    log_error(
                                        b"get_php_version: Unrecognized PHP version (%s)\n\0"
                                            as *const u8 as *const libc::c_char,
                                        phpv.as_mut_ptr(),
                                    );
                                    return 1 as libc::c_int;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn phpspy_zend_inline_hash_func(
    mut str: *const libc::c_char,
    mut len: size_t,
) -> uint64_t {
    let mut hash: uint64_t = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: *const libc::c_char = 0 as *const libc::c_char;
    hash = 5381 as libc::c_ulong;
    while len >= 8 as libc::c_ulong {
        tmp = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp as uint64_t);
        tmp___0 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___0 as uint64_t);
        tmp___1 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___1 as uint64_t);
        tmp___2 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___2 as uint64_t);
        tmp___3 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___3 as uint64_t);
        tmp___4 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___4 as uint64_t);
        tmp___5 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___5 as uint64_t);
        tmp___6 = str;
        str = str.offset(1);
        hash = (hash << 5 as libc::c_int)
            .wrapping_add(hash)
            .wrapping_add(*tmp___6 as uint64_t);
        len = (len as libc::c_ulong).wrapping_sub(8 as libc::c_ulong) as size_t
            as size_t;
    }
    let mut current_block_48: u64;
    match len {
        7 => {
            tmp___7 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___7 as uint64_t);
            current_block_48 = 12902337488919192885;
        }
        6 => {
            current_block_48 = 12902337488919192885;
        }
        5 => {
            current_block_48 = 16513447978708325810;
        }
        4 => {
            current_block_48 = 5239929943746334299;
        }
        3 => {
            current_block_48 = 7449875212375422480;
        }
        2 => {
            current_block_48 = 13858897683172678628;
        }
        1 => {
            current_block_48 = 3223092629080418811;
        }
        0 | _ => {
            current_block_48 = 572715077006366937;
        }
    }
    match current_block_48 {
        12902337488919192885 => {
            tmp___8 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___8 as uint64_t);
            current_block_48 = 16513447978708325810;
        }
        _ => {}
    }
    match current_block_48 {
        16513447978708325810 => {
            tmp___9 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___9 as uint64_t);
            current_block_48 = 5239929943746334299;
        }
        _ => {}
    }
    match current_block_48 {
        5239929943746334299 => {
            tmp___10 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___10 as uint64_t);
            current_block_48 = 7449875212375422480;
        }
        _ => {}
    }
    match current_block_48 {
        7449875212375422480 => {
            tmp___11 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___11 as uint64_t);
            current_block_48 = 13858897683172678628;
        }
        _ => {}
    }
    match current_block_48 {
        13858897683172678628 => {
            tmp___12 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___12 as uint64_t);
            current_block_48 = 3223092629080418811;
        }
        _ => {}
    }
    match current_block_48 {
        3223092629080418811 => {
            tmp___13 = str;
            str = str.offset(1);
            hash = (hash << 5 as libc::c_int)
                .wrapping_add(hash)
                .wrapping_add(*tmp___13 as uint64_t);
        }
        _ => {}
    }
    return (hash as libc::c_ulonglong | 9223372036854775808 as libc::c_ulonglong)
        as uint64_t;
}
pub unsafe extern "C" fn log_error(mut fmt: *const libc::c_char, mut args: ...) {
    let mut args_0: ::std::ffi::VaListImpl;
    if log_error_enabled != 0 {
        args_0 = args.clone();
        vfprintf(stderr, fmt, args_0.as_va_list());
    }
}
unsafe extern "C" fn do_trace_70(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_70 = zend_executor_globals_70 {
        pad0: [0; 304],
        symbol_table: zend_array_70 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_70,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 140],
        current_execute_data: 0 as *mut zend_execute_data_70,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_70(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_70(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_70(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_70(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_70(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 913274408240785659;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 913274408240785659;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        913274408240785659 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_70(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_70,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_70 = zend_execute_data_70 {
        opline: 0 as *mut zend_op_70,
        pad0: [0; 16],
        func: 0 as *mut zend_function_70,
        pad1: [0; 24],
        prev_execute_data: 0 as *mut zend_execute_data_70,
        symbol_table: 0 as *mut zend_array_70,
    };
    let mut zfunc: zend_function_70 = _zend_function_70 { type_0: 0 };
    let mut zstring: zend_string_70 = zend_string_70 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_70 = zend_class_entry_70 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_70,
    };
    let mut zop: zend_op_70 = zend_op_70 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_70 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_70>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_70 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_70>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_70 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_70>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_70 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_70>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_70 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_70>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_70 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_70>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_70 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_70>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_70(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_70 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_70>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_70(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_70(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_70 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_70>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_70(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_70(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_70 = sapi_globals_struct_70 {
        pad0: [0; 8],
        request_info: sapi_request_info_70 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_70 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_70>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_70 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_70(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_70 = zend_mm_heap_70 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_70 = zend_alloc_globals_70 {
        mm_heap: 0 as *mut zend_mm_heap_70,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_70 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_70>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_70;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_70 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_70 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_70(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_70 = 0 as *mut zend_array_70;
    let mut symtable: *mut zend_array_70 = 0 as *mut zend_array_70;
    let mut lbucket: Bucket_70 = Bucket_70 {
        val: zval_70 {
            value: _zend_value_70 { lval: 0 },
            u1: __anonunion_u1_468731550 {
                v: __anonstruct_v_569059773 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_346947711 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_70,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_70)).symbol_table
                as *mut zend_array_70 as libc::c_ulong,
        ) as *mut zend_array_70;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_70(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val70(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_70(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_70,
    mut remote_execute_data: *mut zend_execute_data_70,
    mut op_array: *mut zend_op_array_70,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_70 = 0 as *mut zend_string_70;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_70 = zval_70 {
        value: _zend_value_70 { lval: 0 },
        u1: __anonunion_u1_468731550 {
            v: __anonstruct_v_569059773 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_346947711 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 13877920998136894547;
        }
        10 => {
            current_block_54 = 13877920998136894547;
        }
        9 => {
            current_block_54 = 4896267759008248240;
        }
        8 => {
            current_block_54 = 8150786795262162551;
        }
        7 => {
            current_block_54 = 11256270533560853342;
        }
        6 => {
            current_block_54 = 11247305578666895793;
        }
        5 => {
            current_block_54 = 1152385339822844332;
        }
        4 => {
            current_block_54 = 8773182264702778274;
        }
        3 => {
            current_block_54 = 16603488243404161880;
        }
        2 => {
            current_block_54 = 787847376031598386;
        }
        1 => {
            current_block_54 = 10924444953879111248;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        13877920998136894547 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 4896267759008248240;
        }
        _ => {}
    }
    match current_block_54 {
        4896267759008248240 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 8150786795262162551;
        }
        _ => {}
    }
    match current_block_54 {
        8150786795262162551 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 11256270533560853342;
        }
        _ => {}
    }
    match current_block_54 {
        11256270533560853342 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 11247305578666895793;
        }
        _ => {}
    }
    match current_block_54 {
        11247305578666895793 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 1152385339822844332;
        }
        _ => {}
    }
    match current_block_54 {
        1152385339822844332 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 8773182264702778274;
        }
        _ => {}
    }
    match current_block_54 {
        8773182264702778274 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 16603488243404161880;
        }
        _ => {}
    }
    match current_block_54 {
        16603488243404161880 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 787847376031598386;
        }
        _ => {}
    }
    match current_block_54 {
        787847376031598386 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 10924444953879111248;
        }
        _ => {}
    }
    match current_block_54 {
        10924444953879111248 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_70 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_70>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_70(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 17222562488919639701;
            }
            10 => {
                current_block_180 = 17222562488919639701;
            }
            9 => {
                current_block_180 = 6161064184338962700;
            }
            8 => {
                current_block_180 = 10147890516177784418;
            }
            7 => {
                current_block_180 = 2951604226104549251;
            }
            6 => {
                current_block_180 = 17167119937054530969;
            }
            5 => {
                current_block_180 = 17093285810580535773;
            }
            4 => {
                current_block_180 = 514769488347160072;
            }
            3 => {
                current_block_180 = 2862847878772273211;
            }
            2 => {
                current_block_180 = 14731411312022231980;
            }
            1 => {
                current_block_180 = 1014459501167618322;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            17222562488919639701 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 6161064184338962700;
            }
            _ => {}
        }
        match current_block_180 {
            6161064184338962700 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 10147890516177784418;
            }
            _ => {}
        }
        match current_block_180 {
            10147890516177784418 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 2951604226104549251;
            }
            _ => {}
        }
        match current_block_180 {
            2951604226104549251 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 17167119937054530969;
            }
            _ => {}
        }
        match current_block_180 {
            17167119937054530969 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 17093285810580535773;
            }
            _ => {}
        }
        match current_block_180 {
            17093285810580535773 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 514769488347160072;
            }
            _ => {}
        }
        match current_block_180 {
            514769488347160072 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 2862847878772273211;
            }
            _ => {}
        }
        match current_block_180 {
            2862847878772273211 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 14731411312022231980;
            }
            _ => {}
        }
        match current_block_180 {
            14731411312022231980 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 1014459501167618322;
            }
            _ => {}
        }
        match current_block_180 {
            1014459501167618322 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_70)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_70 as *mut libc::c_void,
                ::std::mem::size_of::<zval_70>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_70(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_70(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_70,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_70;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_70(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_70,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_70,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_70 = zend_array_70 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_70,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_70 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_70>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_70(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_70(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_70,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_70 = zend_string_70 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_70 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_70)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_70(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_70,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_70(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_70(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_70(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_70,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_70; 128] = [Bucket_70 {
        val: zval_70 {
            value: _zend_value_70 { lval: 0 },
            u1: __anonunion_u1_468731550 {
                v: __anonstruct_v_569059773 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_346947711 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_70,
    }; 128];
    let mut lzarray: zend_array_70 = zend_array_70 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_70,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_70 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_70>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_70>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_70(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val70(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_70,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_70 = Bucket_70 {
        val: zval_70 {
            value: _zend_value_70 { lval: 0 },
            u1: __anonunion_u1_468731550 {
                v: __anonstruct_v_569059773 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_346947711 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_70,
    };
    rv = copy_zarray_bucket_70(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_70(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_70(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_70,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_70(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_70(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn do_trace_71(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_71 = zend_executor_globals_71 {
        pad0: [0; 304],
        symbol_table: zend_array_71 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_71,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 140],
        current_execute_data: 0 as *mut zend_execute_data_71,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_71(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_71(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_71(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_71(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_71(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 6061305313280251373;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 6061305313280251373;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        6061305313280251373 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_71(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_71,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_71 = zend_execute_data_71 {
        opline: 0 as *mut zend_op_71,
        pad0: [0; 16],
        func: 0 as *mut zend_function_71,
        pad1: [0; 16],
        prev_execute_data: 0 as *mut zend_execute_data_71,
        symbol_table: 0 as *mut zend_array_71,
    };
    let mut zfunc: zend_function_71 = _zend_function_71 { type_0: 0 };
    let mut zstring: zend_string_71 = zend_string_71 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_71 = zend_class_entry_71 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_71,
    };
    let mut zop: zend_op_71 = zend_op_71 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_71 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_71>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_71 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_71>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_71 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_71>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_71 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_71>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_71 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_71>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_71 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_71>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_71 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_71>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_71(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_71 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_71>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_71(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_71(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_71 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_71>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_71(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_71(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_71 = sapi_globals_struct_71 {
        pad0: [0; 8],
        request_info: sapi_request_info_71 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_71 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_71>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_71 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_71(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_71 = zend_mm_heap_71 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_71 = zend_alloc_globals_71 {
        mm_heap: 0 as *mut zend_mm_heap_71,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_71 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_71>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_71;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_71 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_71 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_71(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_71 = 0 as *mut zend_array_71;
    let mut symtable: *mut zend_array_71 = 0 as *mut zend_array_71;
    let mut lbucket: Bucket_71 = Bucket_71 {
        val: zval_71 {
            value: _zend_value_71 { lval: 0 },
            u1: __anonunion_u1_382201446 {
                v: __anonstruct_v_569059774 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_569059775 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_71,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_71)).symbol_table
                as *mut zend_array_71 as libc::c_ulong,
        ) as *mut zend_array_71;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_71(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val71(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_71(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_71,
    mut remote_execute_data: *mut zend_execute_data_71,
    mut op_array: *mut zend_op_array_71,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_71 = 0 as *mut zend_string_71;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_71 = zval_71 {
        value: _zend_value_71 { lval: 0 },
        u1: __anonunion_u1_382201446 {
            v: __anonstruct_v_569059774 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_569059775 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 5391091297242389783;
        }
        10 => {
            current_block_54 = 5391091297242389783;
        }
        9 => {
            current_block_54 = 12968706949103532699;
        }
        8 => {
            current_block_54 = 8954434238739005907;
        }
        7 => {
            current_block_54 = 15657584998187436562;
        }
        6 => {
            current_block_54 = 11085210150516258599;
        }
        5 => {
            current_block_54 = 12223092415917683758;
        }
        4 => {
            current_block_54 = 11718090224403671455;
        }
        3 => {
            current_block_54 = 13242541850678541271;
        }
        2 => {
            current_block_54 = 18179256136578542206;
        }
        1 => {
            current_block_54 = 10463480025386336502;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        5391091297242389783 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 12968706949103532699;
        }
        _ => {}
    }
    match current_block_54 {
        12968706949103532699 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 8954434238739005907;
        }
        _ => {}
    }
    match current_block_54 {
        8954434238739005907 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 15657584998187436562;
        }
        _ => {}
    }
    match current_block_54 {
        15657584998187436562 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 11085210150516258599;
        }
        _ => {}
    }
    match current_block_54 {
        11085210150516258599 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 12223092415917683758;
        }
        _ => {}
    }
    match current_block_54 {
        12223092415917683758 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 11718090224403671455;
        }
        _ => {}
    }
    match current_block_54 {
        11718090224403671455 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 13242541850678541271;
        }
        _ => {}
    }
    match current_block_54 {
        13242541850678541271 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 18179256136578542206;
        }
        _ => {}
    }
    match current_block_54 {
        18179256136578542206 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 10463480025386336502;
        }
        _ => {}
    }
    match current_block_54 {
        10463480025386336502 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_71 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_71>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_71(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 4747181578508970741;
            }
            10 => {
                current_block_180 = 4747181578508970741;
            }
            9 => {
                current_block_180 = 4772794779897180721;
            }
            8 => {
                current_block_180 = 2616227417902128813;
            }
            7 => {
                current_block_180 = 8360354389298745747;
            }
            6 => {
                current_block_180 = 4005197144086726954;
            }
            5 => {
                current_block_180 = 806953877945700757;
            }
            4 => {
                current_block_180 = 5343274357309835639;
            }
            3 => {
                current_block_180 = 15905738532137066111;
            }
            2 => {
                current_block_180 = 13894271487384187026;
            }
            1 => {
                current_block_180 = 7351175019160591985;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            4747181578508970741 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 4772794779897180721;
            }
            _ => {}
        }
        match current_block_180 {
            4772794779897180721 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 2616227417902128813;
            }
            _ => {}
        }
        match current_block_180 {
            2616227417902128813 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 8360354389298745747;
            }
            _ => {}
        }
        match current_block_180 {
            8360354389298745747 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 4005197144086726954;
            }
            _ => {}
        }
        match current_block_180 {
            4005197144086726954 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 806953877945700757;
            }
            _ => {}
        }
        match current_block_180 {
            806953877945700757 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 5343274357309835639;
            }
            _ => {}
        }
        match current_block_180 {
            5343274357309835639 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 15905738532137066111;
            }
            _ => {}
        }
        match current_block_180 {
            15905738532137066111 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 13894271487384187026;
            }
            _ => {}
        }
        match current_block_180 {
            13894271487384187026 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 7351175019160591985;
            }
            _ => {}
        }
        match current_block_180 {
            7351175019160591985 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_71)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_71 as *mut libc::c_void,
                ::std::mem::size_of::<zval_71>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_71(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_71(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_71,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_71;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_71(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_71,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_71,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_71 = zend_array_71 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_71,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_71 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_71>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_71(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_71(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_71,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_71 = zend_string_71 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_71 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_71)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_71(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_71,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_71(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_71(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_71(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_71,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_71; 128] = [Bucket_71 {
        val: zval_71 {
            value: _zend_value_71 { lval: 0 },
            u1: __anonunion_u1_382201446 {
                v: __anonstruct_v_569059774 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_569059775 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_71,
    }; 128];
    let mut lzarray: zend_array_71 = zend_array_71 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_71,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_71 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_71>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_71>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_71(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val71(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_71,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_71 = Bucket_71 {
        val: zval_71 {
            value: _zend_value_71 { lval: 0 },
            u1: __anonunion_u1_382201446 {
                v: __anonstruct_v_569059774 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_569059775 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_71,
    };
    rv = copy_zarray_bucket_71(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_71(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_71(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_71,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_71(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_71(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn do_trace_72(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_72 = zend_executor_globals_72 {
        pad0: [0; 304],
        symbol_table: zend_array_72 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_72,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 140],
        current_execute_data: 0 as *mut zend_execute_data_72,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_72(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_72(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_72(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_72(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_72(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 13290895612498752712;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 13290895612498752712;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        13290895612498752712 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_72(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_72,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_72 = zend_execute_data_72 {
        opline: 0 as *mut zend_op_72,
        pad0: [0; 16],
        func: 0 as *mut zend_function_72,
        pad1: [0; 16],
        prev_execute_data: 0 as *mut zend_execute_data_72,
        symbol_table: 0 as *mut zend_array_72,
    };
    let mut zfunc: zend_function_72 = _zend_function_72 { type_0: 0 };
    let mut zstring: zend_string_72 = zend_string_72 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_72 = zend_class_entry_72 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_72,
    };
    let mut zop: zend_op_72 = zend_op_72 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_72 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_72>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_72 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_72>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_72 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_72>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_72 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_72>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_72 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_72>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_72 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_72>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_72 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_72>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_72(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_72 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_72>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_72(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_72(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_72 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_72>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_72(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_72(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_72 = sapi_globals_struct_72 {
        pad0: [0; 8],
        request_info: sapi_request_info_72 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_72 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_72>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_72 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_72(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_72 = zend_mm_heap_72 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_72 = zend_alloc_globals_72 {
        mm_heap: 0 as *mut zend_mm_heap_72,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_72 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_72>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_72;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_72 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_72 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_72(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_72 = 0 as *mut zend_array_72;
    let mut symtable: *mut zend_array_72 = 0 as *mut zend_array_72;
    let mut lbucket: Bucket_72 = Bucket_72 {
        val: zval_72 {
            value: _zend_value_72 { lval: 0 },
            u1: __anonunion_u1_787548746 {
                v: __anonstruct_v_997371364 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371365 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_72,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_72)).symbol_table
                as *mut zend_array_72 as libc::c_ulong,
        ) as *mut zend_array_72;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_72(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val72(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_72(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_72,
    mut remote_execute_data: *mut zend_execute_data_72,
    mut op_array: *mut zend_op_array_72,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_72 = 0 as *mut zend_string_72;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_72 = zval_72 {
        value: _zend_value_72 { lval: 0 },
        u1: __anonunion_u1_787548746 {
            v: __anonstruct_v_997371364 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_997371365 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 10095747366349896143;
        }
        10 => {
            current_block_54 = 10095747366349896143;
        }
        9 => {
            current_block_54 = 4678722812687857124;
        }
        8 => {
            current_block_54 = 16383682169377114800;
        }
        7 => {
            current_block_54 = 12006232559596118786;
        }
        6 => {
            current_block_54 = 15130086430566924034;
        }
        5 => {
            current_block_54 = 2657587632158140671;
        }
        4 => {
            current_block_54 = 10480984815006487574;
        }
        3 => {
            current_block_54 = 15555387167116853691;
        }
        2 => {
            current_block_54 = 5505139181155977090;
        }
        1 => {
            current_block_54 = 15779355220531114656;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        10095747366349896143 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 4678722812687857124;
        }
        _ => {}
    }
    match current_block_54 {
        4678722812687857124 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 16383682169377114800;
        }
        _ => {}
    }
    match current_block_54 {
        16383682169377114800 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 12006232559596118786;
        }
        _ => {}
    }
    match current_block_54 {
        12006232559596118786 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 15130086430566924034;
        }
        _ => {}
    }
    match current_block_54 {
        15130086430566924034 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 2657587632158140671;
        }
        _ => {}
    }
    match current_block_54 {
        2657587632158140671 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 10480984815006487574;
        }
        _ => {}
    }
    match current_block_54 {
        10480984815006487574 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 15555387167116853691;
        }
        _ => {}
    }
    match current_block_54 {
        15555387167116853691 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 5505139181155977090;
        }
        _ => {}
    }
    match current_block_54 {
        5505139181155977090 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 15779355220531114656;
        }
        _ => {}
    }
    match current_block_54 {
        15779355220531114656 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_72 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_72>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_72(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 1284460803583640984;
            }
            10 => {
                current_block_180 = 1284460803583640984;
            }
            9 => {
                current_block_180 = 7367176533057231671;
            }
            8 => {
                current_block_180 = 8798095391541709850;
            }
            7 => {
                current_block_180 = 6328973006253756463;
            }
            6 => {
                current_block_180 = 1960848369518058307;
            }
            5 => {
                current_block_180 = 6724654074095376286;
            }
            4 => {
                current_block_180 = 6314785657618587492;
            }
            3 => {
                current_block_180 = 4667691672593119434;
            }
            2 => {
                current_block_180 = 686607183613963898;
            }
            1 => {
                current_block_180 = 5955817576523026355;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            1284460803583640984 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 7367176533057231671;
            }
            _ => {}
        }
        match current_block_180 {
            7367176533057231671 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 8798095391541709850;
            }
            _ => {}
        }
        match current_block_180 {
            8798095391541709850 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 6328973006253756463;
            }
            _ => {}
        }
        match current_block_180 {
            6328973006253756463 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 1960848369518058307;
            }
            _ => {}
        }
        match current_block_180 {
            1960848369518058307 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 6724654074095376286;
            }
            _ => {}
        }
        match current_block_180 {
            6724654074095376286 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 6314785657618587492;
            }
            _ => {}
        }
        match current_block_180 {
            6314785657618587492 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 4667691672593119434;
            }
            _ => {}
        }
        match current_block_180 {
            4667691672593119434 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 686607183613963898;
            }
            _ => {}
        }
        match current_block_180 {
            686607183613963898 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 5955817576523026355;
            }
            _ => {}
        }
        match current_block_180 {
            5955817576523026355 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_72)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_72 as *mut libc::c_void,
                ::std::mem::size_of::<zval_72>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_72(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_72(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_72,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_72;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_72(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_72,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_72,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_72 = zend_array_72 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_72,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_72 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_72>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_72(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_72(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_72,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_72 = zend_string_72 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_72 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_72)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_72(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_72,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_72(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_72(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_72(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_72,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_72; 128] = [Bucket_72 {
        val: zval_72 {
            value: _zend_value_72 { lval: 0 },
            u1: __anonunion_u1_787548746 {
                v: __anonstruct_v_997371364 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371365 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_72,
    }; 128];
    let mut lzarray: zend_array_72 = zend_array_72 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_72,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_72 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_72>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_72>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_72(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val72(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_72,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_72 = Bucket_72 {
        val: zval_72 {
            value: _zend_value_72 { lval: 0 },
            u1: __anonunion_u1_787548746 {
                v: __anonstruct_v_997371364 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371365 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_72,
    };
    rv = copy_zarray_bucket_72(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_72(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_72(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_72,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_72(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_72(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn do_trace_73(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_73 = zend_executor_globals_73 {
        pad0: [0; 304],
        symbol_table: zend_array_73 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_73,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 148],
        current_execute_data: 0 as *mut zend_execute_data_73,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_73(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_73(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_73(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_73(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_73(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 6857063010803083107;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 6857063010803083107;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        6857063010803083107 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_73(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_73,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_73 = zend_execute_data_73 {
        opline: 0 as *mut zend_op_73,
        pad0: [0; 16],
        func: 0 as *mut zend_function_73,
        pad1: [0; 16],
        prev_execute_data: 0 as *mut zend_execute_data_73,
        symbol_table: 0 as *mut zend_array_73,
    };
    let mut zfunc: zend_function_73 = _zend_function_73 { type_0: 0 };
    let mut zstring: zend_string_73 = zend_string_73 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_73 = zend_class_entry_73 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_73,
    };
    let mut zop: zend_op_73 = zend_op_73 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_73 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_73>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_73 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_73>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_73 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_73>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_73 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_73>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_73 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_73>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_73 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_73>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_73 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_73>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_73(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_73 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_73>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_73(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_73(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_73 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_73>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_73(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_73(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_73 = sapi_globals_struct_73 {
        pad0: [0; 8],
        request_info: sapi_request_info_73 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_73 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_73>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_73 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_73(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_73 = zend_mm_heap_73 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_73 = zend_alloc_globals_73 {
        mm_heap: 0 as *mut zend_mm_heap_73,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_73 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_73>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_73;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_73 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_73 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_73(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_73 = 0 as *mut zend_array_73;
    let mut symtable: *mut zend_array_73 = 0 as *mut zend_array_73;
    let mut lbucket: Bucket_73 = Bucket_73 {
        val: zval_73 {
            value: _zend_value_73 { lval: 0 },
            u1: __anonunion_u1_488409722 {
                v: __anonstruct_v_997371366 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371367 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_73,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_73)).symbol_table
                as *mut zend_array_73 as libc::c_ulong,
        ) as *mut zend_array_73;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_73(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val73(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_73(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_73,
    mut remote_execute_data: *mut zend_execute_data_73,
    mut op_array: *mut zend_op_array_73,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_73 = 0 as *mut zend_string_73;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_73 = zval_73 {
        value: _zend_value_73 { lval: 0 },
        u1: __anonunion_u1_488409722 {
            v: __anonstruct_v_997371366 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_997371367 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 6592146692717220712;
        }
        10 => {
            current_block_54 = 6592146692717220712;
        }
        9 => {
            current_block_54 = 17196636909187418234;
        }
        8 => {
            current_block_54 = 5732588802769662302;
        }
        7 => {
            current_block_54 = 3318783957787839798;
        }
        6 => {
            current_block_54 = 14894526479484134059;
        }
        5 => {
            current_block_54 = 6380101767080080957;
        }
        4 => {
            current_block_54 = 13552613067660073215;
        }
        3 => {
            current_block_54 = 6156957191855552792;
        }
        2 => {
            current_block_54 = 892066299704483888;
        }
        1 => {
            current_block_54 = 15751563878602450721;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        6592146692717220712 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 17196636909187418234;
        }
        _ => {}
    }
    match current_block_54 {
        17196636909187418234 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 5732588802769662302;
        }
        _ => {}
    }
    match current_block_54 {
        5732588802769662302 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 3318783957787839798;
        }
        _ => {}
    }
    match current_block_54 {
        3318783957787839798 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 14894526479484134059;
        }
        _ => {}
    }
    match current_block_54 {
        14894526479484134059 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 6380101767080080957;
        }
        _ => {}
    }
    match current_block_54 {
        6380101767080080957 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 13552613067660073215;
        }
        _ => {}
    }
    match current_block_54 {
        13552613067660073215 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 6156957191855552792;
        }
        _ => {}
    }
    match current_block_54 {
        6156957191855552792 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 892066299704483888;
        }
        _ => {}
    }
    match current_block_54 {
        892066299704483888 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 15751563878602450721;
        }
        _ => {}
    }
    match current_block_54 {
        15751563878602450721 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_73 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_73>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_73(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 6103904176707020548;
            }
            10 => {
                current_block_180 = 6103904176707020548;
            }
            9 => {
                current_block_180 = 12990541963152269818;
            }
            8 => {
                current_block_180 = 7914196183420086967;
            }
            7 => {
                current_block_180 = 6884297732373710381;
            }
            6 => {
                current_block_180 = 10863696367847558522;
            }
            5 => {
                current_block_180 = 59490868430179086;
            }
            4 => {
                current_block_180 = 1712399889014320234;
            }
            3 => {
                current_block_180 = 2665674406892973894;
            }
            2 => {
                current_block_180 = 17447299068176318611;
            }
            1 => {
                current_block_180 = 1574065211783390582;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            6103904176707020548 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 12990541963152269818;
            }
            _ => {}
        }
        match current_block_180 {
            12990541963152269818 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 7914196183420086967;
            }
            _ => {}
        }
        match current_block_180 {
            7914196183420086967 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 6884297732373710381;
            }
            _ => {}
        }
        match current_block_180 {
            6884297732373710381 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 10863696367847558522;
            }
            _ => {}
        }
        match current_block_180 {
            10863696367847558522 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 59490868430179086;
            }
            _ => {}
        }
        match current_block_180 {
            59490868430179086 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 1712399889014320234;
            }
            _ => {}
        }
        match current_block_180 {
            1712399889014320234 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 2665674406892973894;
            }
            _ => {}
        }
        match current_block_180 {
            2665674406892973894 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 17447299068176318611;
            }
            _ => {}
        }
        match current_block_180 {
            17447299068176318611 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 1574065211783390582;
            }
            _ => {}
        }
        match current_block_180 {
            1574065211783390582 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_73)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_73 as *mut libc::c_void,
                ::std::mem::size_of::<zval_73>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_73(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_73(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_73,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_73;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_73(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_73,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_73,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_73 = zend_array_73 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_73,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_73 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_73>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_73(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_73(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_73,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_73 = zend_string_73 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_73 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_73)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_73(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_73,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_73(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_73(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_73(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_73,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_73; 128] = [Bucket_73 {
        val: zval_73 {
            value: _zend_value_73 { lval: 0 },
            u1: __anonunion_u1_488409722 {
                v: __anonstruct_v_997371366 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371367 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_73,
    }; 128];
    let mut lzarray: zend_array_73 = zend_array_73 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_73,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_73 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_73>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_73>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_73(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val73(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_73,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_73 = Bucket_73 {
        val: zval_73 {
            value: _zend_value_73 { lval: 0 },
            u1: __anonunion_u1_488409722 {
                v: __anonstruct_v_997371366 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371367 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_73,
    };
    rv = copy_zarray_bucket_73(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_73(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_73(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_73,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_73(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_73(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn do_trace_74(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_74 = zend_executor_globals_74 {
        pad0: [0; 304],
        symbol_table: zend_array_74 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_74,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 148],
        current_execute_data: 0 as *mut zend_execute_data_74,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_74(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_74(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_74(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_74(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_74(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 9135080337726554624;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 9135080337726554624;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        9135080337726554624 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_74(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_74,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_74 = zend_execute_data_74 {
        opline: 0 as *mut zend_op_74,
        pad0: [0; 16],
        func: 0 as *mut zend_function_74,
        pad1: [0; 16],
        prev_execute_data: 0 as *mut zend_execute_data_74,
        symbol_table: 0 as *mut zend_array_74,
    };
    let mut zfunc: zend_function_74 = _zend_function_74 { type_0: 0 };
    let mut zstring: zend_string_74 = zend_string_74 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_74 = zend_class_entry_74 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_74,
    };
    let mut zop: zend_op_74 = zend_op_74 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_74 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_74>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_74 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_74>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_74 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_74>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_74 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_74>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_74 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_74>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_74 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_74>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_74 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_74>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_74(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_74 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_74>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_74(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_74(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_74 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_74>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_74(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_74(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_74 = sapi_globals_struct_74 {
        pad0: [0; 8],
        request_info: sapi_request_info_74 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_74 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_74>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_74 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_74(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_74 = zend_mm_heap_74 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_74 = zend_alloc_globals_74 {
        mm_heap: 0 as *mut zend_mm_heap_74,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_74 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_74>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_74;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_74 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_74 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_74(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_74 = 0 as *mut zend_array_74;
    let mut symtable: *mut zend_array_74 = 0 as *mut zend_array_74;
    let mut lbucket: Bucket_74 = Bucket_74 {
        val: zval_74 {
            value: _zend_value_74 { lval: 0 },
            u1: __anonunion_u1_609040281 {
                v: __anonstruct_v_997371368 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371369 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_74,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_74)).symbol_table
                as *mut zend_array_74 as libc::c_ulong,
        ) as *mut zend_array_74;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_74(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val74(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_74(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_74,
    mut remote_execute_data: *mut zend_execute_data_74,
    mut op_array: *mut zend_op_array_74,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_74 = 0 as *mut zend_string_74;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_74 = zval_74 {
        value: _zend_value_74 { lval: 0 },
        u1: __anonunion_u1_609040281 {
            v: __anonstruct_v_997371368 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_997371369 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 9375675289787594587;
        }
        10 => {
            current_block_54 = 9375675289787594587;
        }
        9 => {
            current_block_54 = 15473922604431337421;
        }
        8 => {
            current_block_54 = 3781672047703525513;
        }
        7 => {
            current_block_54 = 11005732709391009981;
        }
        6 => {
            current_block_54 = 206780877628175530;
        }
        5 => {
            current_block_54 = 1053204135852859008;
        }
        4 => {
            current_block_54 = 13462162262779419878;
        }
        3 => {
            current_block_54 = 12814292403584130305;
        }
        2 => {
            current_block_54 = 15028444932640378386;
        }
        1 => {
            current_block_54 = 18163743429790265022;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        9375675289787594587 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 15473922604431337421;
        }
        _ => {}
    }
    match current_block_54 {
        15473922604431337421 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 3781672047703525513;
        }
        _ => {}
    }
    match current_block_54 {
        3781672047703525513 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 11005732709391009981;
        }
        _ => {}
    }
    match current_block_54 {
        11005732709391009981 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 206780877628175530;
        }
        _ => {}
    }
    match current_block_54 {
        206780877628175530 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 1053204135852859008;
        }
        _ => {}
    }
    match current_block_54 {
        1053204135852859008 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 13462162262779419878;
        }
        _ => {}
    }
    match current_block_54 {
        13462162262779419878 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 12814292403584130305;
        }
        _ => {}
    }
    match current_block_54 {
        12814292403584130305 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 15028444932640378386;
        }
        _ => {}
    }
    match current_block_54 {
        15028444932640378386 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 18163743429790265022;
        }
        _ => {}
    }
    match current_block_54 {
        18163743429790265022 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_74 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_74>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_74(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 750004696237938262;
            }
            10 => {
                current_block_180 = 750004696237938262;
            }
            9 => {
                current_block_180 = 14796388314244321503;
            }
            8 => {
                current_block_180 = 14455219406489107706;
            }
            7 => {
                current_block_180 = 13371687465586313137;
            }
            6 => {
                current_block_180 = 9649393147082068491;
            }
            5 => {
                current_block_180 = 5900313899478289194;
            }
            4 => {
                current_block_180 = 5199848503491564481;
            }
            3 => {
                current_block_180 = 11287942742637945099;
            }
            2 => {
                current_block_180 = 8617742068475353611;
            }
            1 => {
                current_block_180 = 863255670686904226;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            750004696237938262 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 14796388314244321503;
            }
            _ => {}
        }
        match current_block_180 {
            14796388314244321503 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 14455219406489107706;
            }
            _ => {}
        }
        match current_block_180 {
            14455219406489107706 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 13371687465586313137;
            }
            _ => {}
        }
        match current_block_180 {
            13371687465586313137 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 9649393147082068491;
            }
            _ => {}
        }
        match current_block_180 {
            9649393147082068491 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 5900313899478289194;
            }
            _ => {}
        }
        match current_block_180 {
            5900313899478289194 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 5199848503491564481;
            }
            _ => {}
        }
        match current_block_180 {
            5199848503491564481 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 11287942742637945099;
            }
            _ => {}
        }
        match current_block_180 {
            11287942742637945099 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 8617742068475353611;
            }
            _ => {}
        }
        match current_block_180 {
            8617742068475353611 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 863255670686904226;
            }
            _ => {}
        }
        match current_block_180 {
            863255670686904226 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_74)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_74 as *mut libc::c_void,
                ::std::mem::size_of::<zval_74>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_74(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_74(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_74,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_74;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_74(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_74,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_74,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_74 = zend_array_74 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_74,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_74 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_74>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_74(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_74(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_74,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_74 = zend_string_74 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_74 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_74)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_74(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_74,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_74(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_74(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_74(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_74,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_74; 128] = [Bucket_74 {
        val: zval_74 {
            value: _zend_value_74 { lval: 0 },
            u1: __anonunion_u1_609040281 {
                v: __anonstruct_v_997371368 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371369 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_74,
    }; 128];
    let mut lzarray: zend_array_74 = zend_array_74 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_74,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_74 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_74>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_74>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_74(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val74(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_74,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_74 = Bucket_74 {
        val: zval_74 {
            value: _zend_value_74 { lval: 0 },
            u1: __anonunion_u1_609040281 {
                v: __anonstruct_v_997371368 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371369 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_74,
    };
    rv = copy_zarray_bucket_74(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_74(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_74(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_74,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_74(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_74(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn do_trace_80(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_80 = zend_executor_globals_80 {
        pad0: [0; 304],
        symbol_table: zend_array_80 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_80,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 148],
        current_execute_data: 0 as *mut zend_execute_data_80,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_80(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_80(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_80(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_80(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_80(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 1691363349700840663;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 1691363349700840663;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        1691363349700840663 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_80(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_80,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_80 = zend_execute_data_80 {
        opline: 0 as *mut zend_op_80,
        pad0: [0; 16],
        func: 0 as *mut zend_function_80,
        pad1: [0; 16],
        prev_execute_data: 0 as *mut zend_execute_data_80,
        symbol_table: 0 as *mut zend_array_80,
    };
    let mut zfunc: zend_function_80 = _zend_function_80 { type_0: 0 };
    let mut zstring: zend_string_80 = zend_string_80 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_80 = zend_class_entry_80 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_80,
    };
    let mut zop: zend_op_80 = zend_op_80 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_80 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_80>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_80 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_80>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_80 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_80>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_80 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_80>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_80 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_80>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_80 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_80>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_80 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_80>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_80(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_80 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_80>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_80(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_80(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_80 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_80>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_80(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_80(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_80 = sapi_globals_struct_80 {
        pad0: [0; 8],
        request_info: sapi_request_info_80 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_80 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_80>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_80 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_80(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_80 = zend_mm_heap_80 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_80 = zend_alloc_globals_80 {
        mm_heap: 0 as *mut zend_mm_heap_80,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_80 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_80>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_80;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_80 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_80 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_80(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_80 = 0 as *mut zend_array_80;
    let mut symtable: *mut zend_array_80 = 0 as *mut zend_array_80;
    let mut lbucket: Bucket_80 = Bucket_80 {
        val: zval_80 {
            value: _zend_value_80 { lval: 0 },
            u1: __anonunion_u1_920790402 {
                v: __anonstruct_v_997371370 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371371 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_80,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_80)).symbol_table
                as *mut zend_array_80 as libc::c_ulong,
        ) as *mut zend_array_80;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_80(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val80(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_80(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_80,
    mut remote_execute_data: *mut zend_execute_data_80,
    mut op_array: *mut zend_op_array_80,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_80 = 0 as *mut zend_string_80;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_80 = zval_80 {
        value: _zend_value_80 { lval: 0 },
        u1: __anonunion_u1_920790402 {
            v: __anonstruct_v_997371370 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_997371371 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 15980280541913295813;
        }
        10 => {
            current_block_54 = 15980280541913295813;
        }
        9 => {
            current_block_54 = 17894728765599011546;
        }
        8 => {
            current_block_54 = 15510195816584522499;
        }
        7 => {
            current_block_54 = 11042136199330215986;
        }
        6 => {
            current_block_54 = 4746975275211897749;
        }
        5 => {
            current_block_54 = 1499694298034786054;
        }
        4 => {
            current_block_54 = 11543417352688010462;
        }
        3 => {
            current_block_54 = 6934939171037577988;
        }
        2 => {
            current_block_54 = 16189399678838732709;
        }
        1 => {
            current_block_54 = 1761686518262549635;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        15980280541913295813 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 17894728765599011546;
        }
        _ => {}
    }
    match current_block_54 {
        17894728765599011546 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 15510195816584522499;
        }
        _ => {}
    }
    match current_block_54 {
        15510195816584522499 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 11042136199330215986;
        }
        _ => {}
    }
    match current_block_54 {
        11042136199330215986 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 4746975275211897749;
        }
        _ => {}
    }
    match current_block_54 {
        4746975275211897749 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 1499694298034786054;
        }
        _ => {}
    }
    match current_block_54 {
        1499694298034786054 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 11543417352688010462;
        }
        _ => {}
    }
    match current_block_54 {
        11543417352688010462 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 6934939171037577988;
        }
        _ => {}
    }
    match current_block_54 {
        6934939171037577988 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 16189399678838732709;
        }
        _ => {}
    }
    match current_block_54 {
        16189399678838732709 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 1761686518262549635;
        }
        _ => {}
    }
    match current_block_54 {
        1761686518262549635 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_80 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_80>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_80(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 3979456725769321890;
            }
            10 => {
                current_block_180 = 3979456725769321890;
            }
            9 => {
                current_block_180 = 2513664822307493878;
            }
            8 => {
                current_block_180 = 376031111843931458;
            }
            7 => {
                current_block_180 = 11779810459724106992;
            }
            6 => {
                current_block_180 = 5604374519229756473;
            }
            5 => {
                current_block_180 = 13105384068072185994;
            }
            4 => {
                current_block_180 = 8755124981922367599;
            }
            3 => {
                current_block_180 = 1448604346562096812;
            }
            2 => {
                current_block_180 = 4927621250113292477;
            }
            1 => {
                current_block_180 = 7731959745344626998;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            3979456725769321890 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 2513664822307493878;
            }
            _ => {}
        }
        match current_block_180 {
            2513664822307493878 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 376031111843931458;
            }
            _ => {}
        }
        match current_block_180 {
            376031111843931458 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 11779810459724106992;
            }
            _ => {}
        }
        match current_block_180 {
            11779810459724106992 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 5604374519229756473;
            }
            _ => {}
        }
        match current_block_180 {
            5604374519229756473 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 13105384068072185994;
            }
            _ => {}
        }
        match current_block_180 {
            13105384068072185994 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 8755124981922367599;
            }
            _ => {}
        }
        match current_block_180 {
            8755124981922367599 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 1448604346562096812;
            }
            _ => {}
        }
        match current_block_180 {
            1448604346562096812 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 4927621250113292477;
            }
            _ => {}
        }
        match current_block_180 {
            4927621250113292477 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 7731959745344626998;
            }
            _ => {}
        }
        match current_block_180 {
            7731959745344626998 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_80)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_80 as *mut libc::c_void,
                ::std::mem::size_of::<zval_80>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_80(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_80(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_80,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_80;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_80(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_80,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_80,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_80 = zend_array_80 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_80,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_80 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_80>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_80(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_80(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_80,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_80 = zend_string_80 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_80 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_80)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_80(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_80,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_80(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_80(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_80(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_80,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_80; 128] = [Bucket_80 {
        val: zval_80 {
            value: _zend_value_80 { lval: 0 },
            u1: __anonunion_u1_920790402 {
                v: __anonstruct_v_997371370 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371371 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_80,
    }; 128];
    let mut lzarray: zend_array_80 = zend_array_80 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_80,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_80 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_80>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_80>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_80(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val80(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_80,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_80 = Bucket_80 {
        val: zval_80 {
            value: _zend_value_80 { lval: 0 },
            u1: __anonunion_u1_920790402 {
                v: __anonstruct_v_997371370 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371371 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_80,
    };
    rv = copy_zarray_bucket_80(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_80(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_80(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_80,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_80(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_80(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn do_trace_81(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut executor_globals: zend_executor_globals_81 = zend_executor_globals_81 {
        pad0: [0; 304],
        symbol_table: zend_array_81 {
            pad0: [0; 12],
            nTableMask: 0,
            arData: 0 as *mut Bucket_81,
            nNumUsed: 0,
            nNumOfElements: 0,
            nTableSize: 0,
        },
        pad1: [0; 148],
        current_execute_data: 0 as *mut zend_execute_data_81,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_uint = 0;
    rv = copy_executor_globals_81(context, &mut executor_globals);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 1 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = 0 as libc::c_int;
    tmp = trace_stack_81(context, executor_globals.current_execute_data, &mut depth);
    rv |= tmp;
    if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
        if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
            opt_continue_on_error == 0;
        }
    }
    if !(depth < 1 as libc::c_int) {
        if opt_capture_req != 0 {
            tmp___0 = trace_request_info_81(context);
            rv |= tmp___0;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if opt_capture_mem != 0 {
            tmp___1 = trace_memory_info_81(context);
            rv |= tmp___1;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
        if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = (*(*glopeek_map).hh.tbl).num_items;
        } else {
            tmp___3 = 0 as libc::c_uint;
        }
        if tmp___3 > 0 as libc::c_uint {
            tmp___2 = trace_globals_81(context);
            rv |= tmp___2;
            if !(rv & 2 as libc::c_int != 0 as libc::c_int) {
                if !(rv & 4 as libc::c_int != 0 as libc::c_int) {
                    opt_continue_on_error == 0;
                }
            }
        }
    }
    let mut current_block_39: u64;
    if rv == 0 as libc::c_int {
        current_block_39 = 2432265733535871624;
    } else if opt_continue_on_error != 0 {
        current_block_39 = 2432265733535871624;
    } else {
        current_block_39 = 5807581744382915773;
    }
    match current_block_39 {
        2432265733535871624 => {
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 7 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_stack_81(
    mut context: *mut trace_context_t,
    mut remote_execute_data: *mut zend_execute_data_81,
    mut depth: *mut libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut execute_data: zend_execute_data_81 = zend_execute_data_81 {
        opline: 0 as *mut zend_op_81,
        pad0: [0; 16],
        func: 0 as *mut zend_function_81,
        pad1: [0; 16],
        prev_execute_data: 0 as *mut zend_execute_data_81,
        symbol_table: 0 as *mut zend_array_81,
    };
    let mut zfunc: zend_function_81 = _zend_function_81 { type_0: 0 };
    let mut zstring: zend_string_81 = zend_string_81 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut zce: zend_class_entry_81 = zend_class_entry_81 {
        pad0: [0; 8],
        name: 0 as *mut zend_string_81,
    };
    let mut zop: zend_op_81 = zend_op_81 {
        pad0: [0; 24],
        lineno: 0,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    target = &mut (*context).target;
    frame = &mut (*context).event.frame;
    *depth = 0 as libc::c_int;
    while !remote_execute_data.is_null() {
        if !(*depth != opt_max_stack_depth) {
            break;
        }
        memset(
            &mut execute_data as *mut zend_execute_data_81 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_execute_data_81>() as libc::c_ulong,
        );
        memset(
            &mut zfunc as *mut zend_function_81 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_function_81>() as libc::c_ulong,
        );
        memset(
            &mut zstring as *mut zend_string_81 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_string_81>() as libc::c_ulong,
        );
        memset(
            &mut zce as *mut zend_class_entry_81 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_class_entry_81>() as libc::c_ulong,
        );
        memset(
            &mut zop as *mut zend_op_81 as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<zend_op_81>() as libc::c_ulong,
        );
        rv = copy_proc_mem(
            (*context).target.pid,
            b"execute_data\0" as *const u8 as *const libc::c_char,
            remote_execute_data as *mut libc::c_void,
            &mut execute_data as *mut zend_execute_data_81 as *mut libc::c_void,
            ::std::mem::size_of::<zend_execute_data_81>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"zfunc\0" as *const u8 as *const libc::c_char,
            execute_data.func as *mut libc::c_void,
            &mut zfunc as *mut zend_function_81 as *mut libc::c_void,
            ::std::mem::size_of::<zend_function_81>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if !(zfunc.common.function_name).is_null() {
            rv = sprint_zstring_81(
                context,
                b"function_name\0" as *const u8 as *const libc::c_char,
                zfunc.common.function_name,
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.func_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            tmp = snprintf(
                ((*frame).loc.func).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<main>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.func_len = tmp as size_t;
        }
        if !(zfunc.common.scope).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zce\0" as *const u8 as *const libc::c_char,
                zfunc.common.scope as *mut libc::c_void,
                &mut zce as *mut zend_class_entry_81 as *mut libc::c_void,
                ::std::mem::size_of::<zend_class_entry_81>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zstring_81(
                context,
                b"class_name\0" as *const u8 as *const libc::c_char,
                zce.name,
                ((*frame).loc.class).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.class_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*frame)
                .loc
                .class[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
            (*frame).loc.class_len = 0 as libc::c_int as size_t;
        }
        if zfunc.type_0 as libc::c_int == 2 as libc::c_int {
            rv = sprint_zstring_81(
                context,
                b"filename\0" as *const u8 as *const libc::c_char,
                zfunc.op_array.filename,
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut (*frame).loc.file_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*frame).loc.lineno = zfunc.op_array.line_start as libc::c_int;
            if varpeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___1 = (*(*varpeek_map).hh.tbl).num_items;
            } else {
                tmp___1 = 0 as libc::c_uint;
            }
            if tmp___1 > 0 as libc::c_uint {
                tmp___0 = copy_proc_mem(
                    (*target).pid,
                    b"opline\0" as *const u8 as *const libc::c_char,
                    execute_data.opline as *mut libc::c_void,
                    &mut zop as *mut zend_op_81 as *mut libc::c_void,
                    ::std::mem::size_of::<zend_op_81>() as libc::c_ulong,
                );
                if tmp___0 == 0 as libc::c_int {
                    trace_locals_81(
                        context,
                        &mut zop,
                        remote_execute_data,
                        &mut zfunc.op_array,
                        ((*frame).loc.file).as_mut_ptr(),
                        (*frame).loc.file_len as libc::c_int,
                    );
                }
            }
        } else {
            tmp___2 = snprintf(
                ((*frame).loc.file).as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b"<internal>\0" as *const u8 as *const libc::c_char,
            );
            (*frame).loc.file_len = tmp___2 as size_t;
            (*frame).loc.lineno = -(1 as libc::c_int);
        }
        (*frame).depth = *depth;
        rv = (Some(((*context).event_handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(context, 2 as libc::c_int);
        if rv != 0 as libc::c_int {
            return rv;
        }
        remote_execute_data = execute_data.prev_execute_data;
        *depth += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_request_info_81(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut sapi_globals: sapi_globals_struct_81 = sapi_globals_struct_81 {
        pad0: [0; 8],
        request_info: sapi_request_info_81 {
            pad0: [0; 8],
            query_string: 0 as *mut libc::c_char,
            cookie_data: 0 as *mut libc::c_char,
            pad1: [0; 8],
            path_translated: 0 as *mut libc::c_char,
            request_uri: 0 as *mut libc::c_char,
        },
        pad1: [0; 384],
        global_request_time: 0.,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    memset(
        &mut sapi_globals as *mut sapi_globals_struct_81 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sapi_globals_struct_81>() as libc::c_ulong,
    );
    request = &mut (*context).event.request;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"sapi_globals\0" as *const u8 as *const libc::c_char,
        (*target).sapi_globals_addr as *mut libc::c_void,
        &mut sapi_globals as *mut sapi_globals_struct_81 as *mut libc::c_void,
        ::std::mem::size_of::<sapi_globals_struct_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if opt_capture_req_qstring != 0 {
        if !(sapi_globals.request_info.query_string).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"query_string\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.query_string as *mut libc::c_void,
                ((*request).qstring).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).qstring[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).qstring[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_cookie != 0 {
        if !(sapi_globals.request_info.cookie_data).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"cookie_data\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.cookie_data as *mut libc::c_void,
                ((*request).cookie).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request)
                .cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).cookie[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).cookie[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_uri != 0 {
        if !(sapi_globals.request_info.request_uri).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"request_uri\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.request_uri as *mut libc::c_void,
                ((*request).uri).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).uri[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).uri[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    if opt_capture_req_path != 0 {
        if !(sapi_globals.request_info.path_translated).is_null() {
            rv = copy_proc_mem(
                (*context).target.pid,
                b"path_translated\0" as *const u8 as *const libc::c_char,
                sapi_globals.request_info.path_translated as *mut libc::c_void,
                ((*request).path).as_mut_ptr() as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        } else {
            (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
            (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        }
    } else {
        (*request).path[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
        (*request).path[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    }
    (*request).ts = sapi_globals.global_request_time;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 5 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_memory_info_81(
    mut context: *mut trace_context_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut mm_heap: zend_mm_heap_81 = zend_mm_heap_81 {
        pad0: [0; 16],
        size: 0,
        peak: 0,
    };
    let mut alloc_globals: zend_alloc_globals_81 = zend_alloc_globals_81 {
        mm_heap: 0 as *mut zend_mm_heap_81,
    };
    let mut target: *mut trace_target_t = 0 as *mut trace_target_t;
    memset(
        &mut mm_heap as *mut zend_mm_heap_81 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<zend_mm_heap_81>() as libc::c_ulong,
    );
    alloc_globals.mm_heap = 0 as *mut libc::c_void as *mut zend_mm_heap_81;
    target = &mut (*context).target;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"alloc_globals\0" as *const u8 as *const libc::c_char,
        (*target).alloc_globals_addr as *mut libc::c_void,
        &mut alloc_globals as *mut zend_alloc_globals_81 as *mut libc::c_void,
        ::std::mem::size_of::<zend_alloc_globals_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"mm_heap\0" as *const u8 as *const libc::c_char,
        alloc_globals.mm_heap as *mut libc::c_void,
        &mut mm_heap as *mut zend_mm_heap_81 as *mut libc::c_void,
        ::std::mem::size_of::<zend_mm_heap_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    (*context).event.mem.size = mm_heap.size;
    (*context).event.mem.peak = mm_heap.peak;
    rv = (Some(((*context).event_handler).expect("non-null function pointer")))
        .expect("non-null function pointer")(context, 6 as libc::c_int);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_globals_81(mut context: *mut trace_context_t) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut gentry: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut gentry_tmp: *mut glopeek_entry_t = 0 as *mut glopeek_entry_t;
    let mut garray: *mut zend_array_81 = 0 as *mut zend_array_81;
    let mut symtable: *mut zend_array_81 = 0 as *mut zend_array_81;
    let mut lbucket: Bucket_81 = Bucket_81 {
        val: zval_81 {
            value: _zend_value_81 { lval: 0 },
            u1: __anonunion_u1_671508906 {
                v: __anonstruct_v_997371372 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371373 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_81,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    symtable = ((*context).target.executor_globals_addr)
        .wrapping_add(
            &mut (*(0 as *mut zend_executor_globals_81)).symbol_table
                as *mut zend_array_81 as libc::c_ulong,
        ) as *mut zend_array_81;
    gentry = glopeek_map;
    if glopeek_map as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*glopeek_map).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    gentry_tmp = tmp as *mut glopeek_entry_t;
    while gentry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*gentry).gloname[0 as libc::c_int as usize] != 0 {
            rv = copy_zarray_bucket_81(
                context,
                symtable,
                ((*gentry).gloname).as_mut_ptr() as *const libc::c_char,
                &mut lbucket,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            garray = lbucket.val.value.arr;
        } else {
            garray = symtable;
        }
        rv = sprint_zarray_val81(
            context,
            garray,
            ((*gentry).varname).as_mut_ptr() as *const libc::c_char,
            ((*context).buf).as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut (*context).buf_len,
        );
        if rv == 0 as libc::c_int {
            (*context).event.glopeek.gentry = gentry;
            (*context).event.glopeek.zval_str = ((*context).buf).as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 4 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        gentry = gentry_tmp;
        if gentry_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*gentry_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        gentry_tmp = tmp___0 as *mut glopeek_entry_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn trace_locals_81(
    mut context: *mut trace_context_t,
    mut zop: *mut zend_op_81,
    mut remote_execute_data: *mut zend_execute_data_81,
    mut op_array: *mut zend_op_array_81,
    mut file: *mut libc::c_char,
    mut file_len: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut num_vars_found: libc::c_int = 0;
    let mut num_vars_peeking: libc::c_int = 0;
    let mut tmp: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut zstrp: *mut zend_string_81 = 0 as *mut zend_string_81;
    let mut entry: *mut varpeek_entry_t = 0 as *mut varpeek_entry_t;
    let mut var: *mut varpeek_var_t = 0 as *mut varpeek_var_t;
    let mut varpeek_key: [libc::c_char; 256] = [0; 256];
    let mut zv: zval_81 = zval_81 {
        value: _zend_value_81 { lval: 0 },
        u1: __anonunion_u1_671508906 {
            v: __anonstruct_v_997371372 {
                type_0: 0,
                pad0: [0; 3],
            },
        },
        u2: __anonunion_u2_997371373 {
            next: 0,
        },
    };
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___2: libc::c_int = 0;
    snprintf(
        varpeek_key.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%.*s:%d\0" as *const u8 as *const libc::c_char,
        file_len,
        file,
        (*zop).lineno,
    );
    tmp___0 = strlen(varpeek_key.as_mut_ptr() as *const libc::c_char);
    _uthash_hfstr_keylen = tmp___0 as libc::c_uint;
    _hj_key = varpeek_key.as_mut_ptr() as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = _uthash_hfstr_keylen;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
    let mut current_block_54: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 1222360903049251371;
        }
        10 => {
            current_block_54 = 1222360903049251371;
        }
        9 => {
            current_block_54 = 1255694926451118310;
        }
        8 => {
            current_block_54 = 3253698132193929537;
        }
        7 => {
            current_block_54 = 16504497642807223611;
        }
        6 => {
            current_block_54 = 3626230208733962659;
        }
        5 => {
            current_block_54 = 15894617942165631243;
        }
        4 => {
            current_block_54 = 4432797858801346280;
        }
        3 => {
            current_block_54 = 4298259978366130457;
        }
        2 => {
            current_block_54 = 2827738661213284820;
        }
        1 => {
            current_block_54 = 9398457679699488899;
        }
        _ => {
            current_block_54 = 1854459640724737493;
        }
    }
    match current_block_54 {
        1222360903049251371 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 1255694926451118310;
        }
        _ => {}
    }
    match current_block_54 {
        1255694926451118310 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 3253698132193929537;
        }
        _ => {}
    }
    match current_block_54 {
        3253698132193929537 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 16504497642807223611;
        }
        _ => {}
    }
    match current_block_54 {
        16504497642807223611 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 3626230208733962659;
        }
        _ => {}
    }
    match current_block_54 {
        3626230208733962659 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 15894617942165631243;
        }
        _ => {}
    }
    match current_block_54 {
        15894617942165631243 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_54 = 4432797858801346280;
        }
        _ => {}
    }
    match current_block_54 {
        4432797858801346280 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_54 = 4298259978366130457;
        }
        _ => {}
    }
    match current_block_54 {
        4298259978366130457 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_54 = 2827738661213284820;
        }
        _ => {}
    }
    match current_block_54 {
        2827738661213284820 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_54 = 9398457679699488899;
        }
        _ => {}
    }
    match current_block_54 {
        9398457679699488899 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
    if !varpeek_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*varpeek_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            entry = ((*((*(*varpeek_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*varpeek_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut varpeek_entry_t;
        } else {
            entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
        }
        while entry as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*entry).hh.hashv == _hf_hashv {
                if (*entry).hh.keylen == _uthash_hfstr_keylen {
                    tmp___1 = memcmp(
                        (*entry).hh.key as *const libc::c_void,
                        varpeek_key.as_mut_ptr() as *const libc::c_void,
                        _uthash_hfstr_keylen as size_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*entry).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                entry = ((*entry).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*varpeek_map).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_entry_t;
            } else {
                entry = 0 as *mut libc::c_void as *mut varpeek_entry_t;
            }
        }
    }
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    num_vars_found = 0 as libc::c_int;
    if (*entry).varmap as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        num_vars_peeking = (*(*(*entry).varmap).hh.tbl).num_items as libc::c_int;
    } else {
        num_vars_peeking = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*op_array).last_var {
        rv = copy_proc_mem(
            (*context).target.pid,
            b"var\0" as *const u8 as *const libc::c_char,
            ((*op_array).vars).offset(i as isize) as *mut libc::c_void,
            &mut zstrp as *mut *mut zend_string_81 as *mut libc::c_void,
            ::std::mem::size_of::<*mut zend_string_81>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        rv = sprint_zstring_81(
            context,
            b"var\0" as *const u8 as *const libc::c_char,
            zstrp,
            tmp.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        _hj_key___0 = tmp.as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv___0 = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = tmp_len as libc::c_uint;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hf_hashv___0 = _hf_hashv___0
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
            _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
            _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv___0 = _hf_hashv___0.wrapping_add(tmp_len as libc::c_uint);
        let mut current_block_180: u64;
        match _hj_k___0 {
            11 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 10073844389934626487;
            }
            10 => {
                current_block_180 = 10073844389934626487;
            }
            9 => {
                current_block_180 = 3618165486180289145;
            }
            8 => {
                current_block_180 = 13419256696328437746;
            }
            7 => {
                current_block_180 = 5737657294091357635;
            }
            6 => {
                current_block_180 = 12217906003743355115;
            }
            5 => {
                current_block_180 = 13008268978911968680;
            }
            4 => {
                current_block_180 = 5562588924599818725;
            }
            3 => {
                current_block_180 = 7983587312511368329;
            }
            2 => {
                current_block_180 = 747966612415563580;
            }
            1 => {
                current_block_180 = 4736130647341600033;
            }
            _ => {
                current_block_180 = 8552664524913350887;
            }
        }
        match current_block_180 {
            10073844389934626487 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 3618165486180289145;
            }
            _ => {}
        }
        match current_block_180 {
            3618165486180289145 => {
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 13419256696328437746;
            }
            _ => {}
        }
        match current_block_180 {
            13419256696328437746 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 5737657294091357635;
            }
            _ => {}
        }
        match current_block_180 {
            5737657294091357635 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 12217906003743355115;
            }
            _ => {}
        }
        match current_block_180 {
            12217906003743355115 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 13008268978911968680;
            }
            _ => {}
        }
        match current_block_180 {
            13008268978911968680 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_180 = 5562588924599818725;
            }
            _ => {}
        }
        match current_block_180 {
            5562588924599818725 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_180 = 7983587312511368329;
            }
            _ => {}
        }
        match current_block_180 {
            7983587312511368329 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_180 = 747966612415563580;
            }
            _ => {}
        }
        match current_block_180 {
            747966612415563580 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_180 = 4736130647341600033;
            }
            _ => {}
        }
        match current_block_180 {
            4736130647341600033 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_hf_hashv___0);
        _hj_i___0 ^= _hf_hashv___0 >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_hf_hashv___0);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___0);
        _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___0);
        _hf_hashv___0 ^= _hj_j___0 >> 15 as libc::c_int;
        var = 0 as *mut libc::c_void as *mut varpeek_var_t;
        if !((*entry).varmap).is_null() {
            _hf_bkt___0 = _hf_hashv___0
                & ((*(*(*entry).varmap).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*entry).varmap).hh.tbl).buckets).offset(_hf_bkt___0 as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                var = ((*((*(*(*entry).varmap).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut varpeek_var_t;
            } else {
                var = 0 as *mut libc::c_void as *mut varpeek_var_t;
            }
            while var as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*var).hh.hashv == _hf_hashv___0 {
                    if (*var).hh.keylen as size_t == tmp_len {
                        tmp___2 = memcmp(
                            (*var).hh.key as *const libc::c_void,
                            tmp.as_mut_ptr() as *const libc::c_void,
                            tmp_len,
                        );
                        if tmp___2 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*var).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    var = ((*var).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*entry).varmap).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut varpeek_var_t;
                } else {
                    var = 0 as *mut libc::c_void as *mut varpeek_var_t;
                }
            }
        }
        if !var.is_null() {
            num_vars_found += 1;
            rv = copy_proc_mem(
                (*context).target.pid,
                b"zval\0" as *const u8 as *const libc::c_char,
                (remote_execute_data as *mut zval_81)
                    .offset((5 as libc::c_int + i) as isize) as *mut libc::c_void,
                &mut zv as *mut zval_81 as *mut libc::c_void,
                ::std::mem::size_of::<zval_81>() as libc::c_ulong,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = sprint_zval_81(
                context,
                &mut zv,
                tmp.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                &mut tmp_len,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            (*context).event.varpeek.entry = entry;
            (*context).event.varpeek.var = var;
            (*context).event.varpeek.zval_str = tmp.as_mut_ptr();
            rv = (Some(((*context).event_handler).expect("non-null function pointer")))
                .expect("non-null function pointer")(context, 3 as libc::c_int);
            if rv != 0 as libc::c_int {
                return rv;
            }
            if num_vars_found >= num_vars_peeking {
                break;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_executor_globals_81(
    mut context: *mut trace_context_t,
    mut executor_globals: *mut zend_executor_globals_81,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    (*executor_globals)
        .current_execute_data = 0 as *mut libc::c_void as *mut zend_execute_data_81;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"executor_globals\0" as *const u8 as *const libc::c_char,
        (*context).target.executor_globals_addr as *mut libc::c_void,
        executor_globals as *mut libc::c_void,
        ::std::mem::size_of::<zend_executor_globals_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn copy_zarray_bucket_81(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_81,
    mut key: *const libc::c_char,
    mut lbucket: *mut Bucket_81,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzarray: zend_array_81 = zend_array_81 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_81,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut hash_table_size: uint32_t = 0;
    let mut hash_val: uint64_t = 0;
    let mut hash_index: uint32_t = 0;
    let mut hash_table_val: uint32_t = 0;
    let mut hash_bucket: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_81 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    tmp = strlen(key);
    hash_val = phpspy_zend_inline_hash_func(key, tmp);
    hash_table_size = (-(1 as libc::c_int) * lzarray.nTableMask as int32_t) as uint32_t;
    hash_index = hash_val.wrapping_rem(hash_table_size as libc::c_ulong) as uint32_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"hash_table_val\0" as *const u8 as *const libc::c_char,
        (lzarray.arData as *mut uint32_t)
            .offset(-(hash_table_size as isize))
            .offset(hash_index as isize) as *mut libc::c_void,
        &mut hash_table_val as *mut uint32_t as *mut libc::c_void,
        ::std::mem::size_of::<uint32_t>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    hash_bucket = &mut hash_table_val;
    loop {
        if *hash_bucket == 4294967295 as libc::c_uint {
            return 1 as libc::c_int;
        }
        rv = copy_proc_mem(
            (*context).target.pid,
            b"bucket\0" as *const u8 as *const libc::c_char,
            (lzarray.arData).offset(*hash_bucket as isize) as *mut libc::c_void,
            lbucket as *mut libc::c_void,
            ::std::mem::size_of::<Bucket_81>() as libc::c_ulong,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if (*lbucket).key as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        rv = sprint_zstring_81(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        tmp___0 = strcmp(key, tmp_key.as_mut_ptr() as *const libc::c_char);
        if tmp___0 == 0 as libc::c_int {
            hash_bucket = 0 as *mut libc::c_void as *mut uint32_t;
        } else {
            hash_bucket = &mut (*lbucket).val.u2.next;
        }
        if hash_bucket.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zstring_81(
    mut context: *mut trace_context_t,
    mut what: *const libc::c_char,
    mut rzstring: *mut zend_string_81,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut lzstring: zend_string_81 = zend_string_81 {
        pad0: [0; 16],
        len: 0,
        val: [0; 1],
    };
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    *buf_len___0 = 0 as libc::c_int as size_t;
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        rzstring as *mut libc::c_void,
        &mut lzstring as *mut zend_string_81 as *mut libc::c_void,
        ::std::mem::size_of::<zend_string_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if 1 as libc::c_ulong > buf_size {
        tmp___1 = 1 as libc::c_int as size_t;
    } else {
        tmp___1 = buf_size;
    }
    if lzstring.len < tmp___1.wrapping_sub(1 as libc::c_ulong) {
        *buf_len___0 = lzstring.len;
    } else {
        if 1 as libc::c_ulong > buf_size {
            tmp___0 = 1 as libc::c_int as size_t;
        } else {
            tmp___0 = buf_size;
        }
        *buf_len___0 = tmp___0.wrapping_sub(1 as libc::c_ulong);
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        what,
        (rzstring as *mut libc::c_char)
            .offset(
                &mut (*(0 as *mut zend_string_81)).val as *mut [libc::c_char; 1]
                    as libc::c_ulong as isize,
            ) as *mut libc::c_void,
        buf___0 as *mut libc::c_void,
        *buf_len___0,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    *buf___0
        .offset(*buf_len___0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zval_81(
    mut context: *mut trace_context_t,
    mut lzval: *mut zval_81,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    type_0 = (*lzval).u1.v.type_0 as libc::c_int;
    match type_0 {
        4 => {
            snprintf(
                buf___0,
                buf_size,
                b"%ld\0" as *const u8 as *const libc::c_char,
                (*lzval).value.lval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        5 => {
            snprintf(
                buf___0,
                buf_size,
                b"%f\0" as *const u8 as *const libc::c_char,
                (*lzval).value.dval,
            );
            *buf_len___0 = strlen(buf___0 as *const libc::c_char);
        }
        6 => {
            rv = sprint_zstring_81(
                context,
                b"zval\0" as *const u8 as *const libc::c_char,
                (*lzval).value.str_0,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            rv = sprint_zarray_81(
                context,
                (*lzval).value.arr,
                buf___0,
                buf_size,
                buf_len___0,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_81(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_81,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut array_len: libc::c_int = 0;
    let mut tmp_len: size_t = 0;
    let mut buckets: [Bucket_81; 128] = [Bucket_81 {
        val: zval_81 {
            value: _zend_value_81 { lval: 0 },
            u1: __anonunion_u1_671508906 {
                v: __anonstruct_v_997371372 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371373 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_81,
    }; 128];
    let mut lzarray: zend_array_81 = zend_array_81 {
        pad0: [0; 12],
        nTableMask: 0,
        arData: 0 as *mut Bucket_81,
        nNumUsed: 0,
        nNumOfElements: 0,
        nTableSize: 0,
    };
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    rv = copy_proc_mem(
        (*context).target.pid,
        b"array\0" as *const u8 as *const libc::c_char,
        rzarray as *mut libc::c_void,
        &mut lzarray as *mut zend_array_81 as *mut libc::c_void,
        ::std::mem::size_of::<zend_array_81>() as libc::c_ulong,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    if lzarray.nNumOfElements < 128 as libc::c_uint {
        array_len = lzarray.nNumOfElements as libc::c_int;
    } else {
        array_len = 128 as libc::c_int;
    }
    rv = copy_proc_mem(
        (*context).target.pid,
        b"buckets\0" as *const u8 as *const libc::c_char,
        lzarray.arData as *mut libc::c_void,
        buckets.as_mut_ptr() as *mut libc::c_void,
        (::std::mem::size_of::<Bucket_81>() as libc::c_ulong)
            .wrapping_mul(array_len as libc::c_ulong),
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    i = 0 as libc::c_int;
    while i < array_len {
        rv = sprint_zarray_bucket_81(
            context,
            buckets.as_mut_ptr().offset(i as isize),
            buf___0,
            buf_size,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        buf_size = (buf_size as libc::c_ulong).wrapping_sub(tmp_len) as size_t as size_t;
        buf___0 = buf___0.offset(tmp_len as isize);
        if buf_size >= 2 as libc::c_ulong {
            *buf___0 = ',' as i32 as libc::c_char;
            buf_size = buf_size.wrapping_sub(1);
            buf___0 = buf___0.offset(1);
        }
        i += 1;
    }
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_val81(
    mut context: *mut trace_context_t,
    mut rzarray: *mut zend_array_81,
    mut key: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut bucket: Bucket_81 = Bucket_81 {
        val: zval_81 {
            value: _zend_value_81 { lval: 0 },
            u1: __anonunion_u1_671508906 {
                v: __anonstruct_v_997371372 {
                    type_0: 0,
                    pad0: [0; 3],
                },
            },
            u2: __anonunion_u2_997371373 {
                next: 0,
            },
        },
        h: 0,
        key: 0 as *mut zend_string_81,
    };
    rv = copy_zarray_bucket_81(context, rzarray, key, &mut bucket);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sprint_zval_81(context, &mut bucket.val, buf___0, buf_size, buf_len___0);
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sprint_zarray_bucket_81(
    mut context: *mut trace_context_t,
    mut lbucket: *mut Bucket_81,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut buf_len___0: *mut size_t,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut tmp_key: [libc::c_char; 256] = [0; 256];
    let mut tmp_len: size_t = 0;
    let mut obuf: *mut libc::c_char = 0 as *mut libc::c_char;
    obuf = buf___0;
    if (*lbucket).key as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        rv = sprint_zstring_81(
            context,
            b"array_key\0" as *const u8 as *const libc::c_char,
            (*lbucket).key,
            tmp_key.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            &mut tmp_len,
        );
        if rv != 0 as libc::c_int {
            return rv;
        }
        if buf_size
            > tmp_len.wrapping_add(1 as libc::c_ulong).wrapping_add(1 as libc::c_ulong)
        {
            snprintf(
                buf___0,
                buf_size,
                b"%s=\0" as *const u8 as *const libc::c_char,
                tmp_key.as_mut_ptr(),
            );
            buf_size = (buf_size as libc::c_ulong)
                .wrapping_sub(tmp_len.wrapping_add(1 as libc::c_ulong)) as size_t
                as size_t;
            buf___0 = buf___0.offset(tmp_len.wrapping_add(1 as libc::c_ulong) as isize);
        }
    }
    rv = sprint_zval_81(context, &mut (*lbucket).val, buf___0, buf_size, &mut tmp_len);
    if rv != 0 as libc::c_int {
        return rv;
    }
    buf___0 = buf___0.offset(tmp_len as isize);
    *buf_len___0 = buf___0.offset_from(obuf) as libc::c_long as size_t;
    return 0 as libc::c_int;
}
static mut avail_pids: *mut libc::c_int = 0 as *const libc::c_void as *mut libc::c_void
    as *mut libc::c_int;
static mut attached_pids: *mut libc::c_int = 0 as *const libc::c_void
    as *mut libc::c_void as *mut libc::c_int;
static mut work_threads: *mut pthread_t = 0 as *const libc::c_void as *mut libc::c_void
    as *mut pthread_t;
static mut signal_thread: pthread_t = 0;
static mut avail_pids_count: libc::c_int = 0 as libc::c_int;
static mut mutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
    __data: {
        let mut init = __pthread_mutex_s {
            __lock: 0 as libc::c_int,
            __count: 0 as libc::c_uint,
            __owner: 0 as libc::c_int,
            __nusers: 0 as libc::c_uint,
            __kind: 0 as libc::c_int,
            __spins: 0 as libc::c_int as libc::c_short,
            __elision: 0 as libc::c_int as libc::c_short,
            __list: {
                let mut init = __pthread_internal_list {
                    __prev: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                };
                init
            },
        };
        init
    },
};
static mut can_produce: pthread_cond_t = __anonunion_pthread_cond_t_951761805 {
    __data: {
        let mut init = __pthread_cond_s {
            __annonCompField1: __anonunion____missing_field_name_419419941 {
                __wseq: 0 as libc::c_ulonglong,
            },
            __annonCompField2: __anonunion____missing_field_name_349613679 {
                __g1_start: 0 as libc::c_ulonglong,
            },
            __g_refs: [0 as libc::c_uint, 0 as libc::c_uint],
            __g_size: [0 as libc::c_uint, 0 as libc::c_uint],
            __g1_orig_size: 0 as libc::c_uint,
            __wrefs: 0 as libc::c_uint,
            __g_signals: [0 as libc::c_uint, 0 as libc::c_uint],
        };
        init
    },
};
static mut can_consume: pthread_cond_t = __anonunion_pthread_cond_t_951761805 {
    __data: {
        let mut init = __pthread_cond_s {
            __annonCompField1: __anonunion____missing_field_name_419419941 {
                __wseq: 0 as libc::c_ulonglong,
            },
            __annonCompField2: __anonunion____missing_field_name_349613679 {
                __g1_start: 0 as libc::c_ulonglong,
            },
            __g_refs: [0 as libc::c_uint, 0 as libc::c_uint],
            __g_size: [0 as libc::c_uint, 0 as libc::c_uint],
            __g1_orig_size: 0 as libc::c_uint,
            __wrefs: 0 as libc::c_uint,
            __g_signals: [0 as libc::c_uint, 0 as libc::c_uint],
        };
        init
    },
};
static mut done_pipe: [libc::c_int; 2] = [-(1 as libc::c_int), -(1 as libc::c_int)];
pub unsafe extern "C" fn main_pgrep() -> libc::c_int {
    let mut i: libc::c_long = 0;
    let mut tmp: libc::c_long = 0;
    if opt_num_workers < 1 as libc::c_int {
        log_error(
            b"Expected max concurrent workers (-T) > 0\n\0" as *const u8
                as *const libc::c_char,
        );
        exit(1 as libc::c_int);
    }
    pthread_create(
        &mut signal_thread as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        Some(
            run_signal_thread
                as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        ),
        0 as *mut libc::c_void,
    );
    block_all_signals();
    init_work_threads();
    i = 0 as libc::c_long;
    while i < opt_num_workers as libc::c_long {
        pthread_create(
            work_threads.offset(i as isize),
            0 as *mut libc::c_void as *const pthread_attr_t,
            Some(
                run_work_thread
                    as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
            ),
            i as *mut libc::c_void,
        );
        i += 1;
    }
    if opt_time_limit_ms > 0 as libc::c_long {
        if 1 as libc::c_long > opt_time_limit_ms / 1000 as libc::c_long {
            tmp = 1 as libc::c_long;
        } else {
            tmp = opt_time_limit_ms / 1000 as libc::c_long;
        }
        alarm(tmp as libc::c_uint);
    }
    pgrep_for_pids();
    i = 0 as libc::c_long;
    while i < opt_num_workers as libc::c_long {
        pthread_join(
            *work_threads.offset(i as isize),
            0 as *mut libc::c_void as *mut *mut libc::c_void,
        );
        i += 1;
    }
    pthread_join(signal_thread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
    deinit_work_threads();
    log_error(b"main_pgrep finished gracefully\n\0" as *const u8 as *const libc::c_char);
    return 0 as libc::c_int;
}
unsafe extern "C" fn wait_for_turn(
    mut producer_or_consumer: libc::c_char,
) -> libc::c_int {
    let mut timeout: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut tmp: *mut pthread_cond_t = 0 as *mut pthread_cond_t;
    pthread_mutex_lock(&mut mutex);
    while done == 0 {
        if producer_or_consumer as libc::c_int == 112 as libc::c_int {
            if avail_pids_count < opt_num_workers {
                break;
            }
        }
        if avail_pids_count > 0 as libc::c_int {
            break;
        }
        clock_gettime(0 as libc::c_int, &mut timeout);
        timeout.tv_sec += 2 as libc::c_long;
        if producer_or_consumer as libc::c_int == 112 as libc::c_int {
            tmp = &mut can_produce;
        } else {
            tmp = &mut can_consume;
        }
        pthread_cond_timedwait(
            tmp,
            &mut mutex as *mut pthread_mutex_t,
            &mut timeout as *mut timespec as *const timespec,
        );
    }
    if done != 0 {
        pthread_mutex_unlock(&mut mutex);
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn pgrep_for_pids() {
    let mut pcmd: *mut FILE = 0 as *mut FILE;
    let mut pgrep_cmd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut line: [libc::c_char; 64] = [0; 64];
    let mut pid: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut timeout: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp___0 = asprintf(
        &mut pgrep_cmd as *mut *mut libc::c_char,
        b"pgrep %s\0" as *const u8 as *const libc::c_char,
        opt_pgrep_args,
    );
    if tmp___0 < 0 as libc::c_int {
        tmp = __errno_location();
        *tmp = 12 as libc::c_int;
        perror(b"asprintf\0" as *const u8 as *const libc::c_char);
        exit(1 as libc::c_int);
    }
    while done == 0 {
        tmp___1 = wait_for_turn('p' as i32 as libc::c_char);
        if tmp___1 != 0 {
            break;
        }
        found = 0 as libc::c_int;
        pcmd = popen(
            pgrep_cmd as *const libc::c_char,
            b"r\0" as *const u8 as *const libc::c_char,
        );
        if pcmd as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            while avail_pids_count < opt_num_workers {
                tmp___5 = fgets(
                    line.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    pcmd,
                );
                if !(tmp___5 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong)
                {
                    break;
                }
                tmp___2 = strlen(line.as_mut_ptr() as *const libc::c_char);
                if tmp___2 < 1 as libc::c_ulong {
                    continue;
                }
                if line[0 as libc::c_int as usize] as libc::c_int == 10 as libc::c_int {
                    continue;
                }
                pid = atoi(line.as_mut_ptr() as *const libc::c_char);
                tmp___3 = is_already_attached(pid);
                if tmp___3 != 0 {
                    continue;
                }
                tmp___4 = avail_pids_count;
                avail_pids_count += 1;
                *avail_pids.offset(tmp___4 as isize) = pid;
                found += 1;
            }
            pclose(pcmd);
        }
        if found > 0 as libc::c_int {
            pthread_cond_broadcast(&mut can_consume);
        } else {
            clock_gettime(0 as libc::c_int, &mut timeout);
            timeout.tv_sec += 2 as libc::c_long;
            pthread_cond_timedwait(
                &mut can_produce as *mut pthread_cond_t,
                &mut mutex as *mut pthread_mutex_t,
                &mut timeout as *mut timespec as *const timespec,
            );
        }
        pthread_mutex_unlock(&mut mutex);
    }
    free(pgrep_cmd as *mut libc::c_void);
}
unsafe extern "C" fn run_work_thread(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut worker_num: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    worker_num = arg as libc::c_long as libc::c_int;
    while done == 0 {
        tmp = wait_for_turn('c' as i32 as libc::c_char);
        if tmp != 0 {
            break;
        }
        avail_pids_count -= 1;
        *attached_pids
            .offset(worker_num as isize) = *avail_pids.offset(avail_pids_count as isize);
        pthread_cond_signal(&mut can_produce);
        pthread_mutex_unlock(&mut mutex);
        main_pid(*attached_pids.offset(worker_num as isize));
        *attached_pids.offset(worker_num as isize) = 0 as libc::c_int;
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn is_already_attached(mut pid: libc::c_int) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < opt_num_workers {
        if *attached_pids.offset(i as isize) == pid {
            return 1 as libc::c_int
        } else {
            if i < avail_pids_count {
                if *avail_pids.offset(i as isize) == pid {
                    return 1 as libc::c_int;
                }
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn init_work_threads() {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    tmp = calloc(
        opt_num_workers as size_t,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
    );
    avail_pids = tmp as *mut libc::c_int;
    tmp___0 = calloc(
        opt_num_workers as size_t,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
    );
    attached_pids = tmp___0 as *mut libc::c_int;
    tmp___1 = calloc(
        opt_num_workers as size_t,
        ::std::mem::size_of::<pthread_t>() as libc::c_ulong,
    );
    work_threads = tmp___1 as *mut pthread_t;
    if avail_pids.is_null() {
        tmp___2 = __errno_location();
        *tmp___2 = 12 as libc::c_int;
        perror(b"calloc\0" as *const u8 as *const libc::c_char);
        exit(1 as libc::c_int);
    } else {
        if attached_pids.is_null() {
            tmp___2 = __errno_location();
            *tmp___2 = 12 as libc::c_int;
            perror(b"calloc\0" as *const u8 as *const libc::c_char);
            exit(1 as libc::c_int);
        } else {
            if work_threads.is_null() {
                tmp___2 = __errno_location();
                *tmp___2 = 12 as libc::c_int;
                perror(b"calloc\0" as *const u8 as *const libc::c_char);
                exit(1 as libc::c_int);
            }
        }
    }
    pthread_mutex_init(&mut mutex, 0 as *mut libc::c_void as *const pthread_mutexattr_t);
    pthread_cond_init(
        &mut can_produce as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    pthread_cond_init(
        &mut can_consume as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
}
unsafe extern "C" fn deinit_work_threads() {
    free(avail_pids as *mut libc::c_void);
    free(attached_pids as *mut libc::c_void);
    free(work_threads as *mut libc::c_void);
    pthread_mutex_destroy(&mut mutex);
    pthread_cond_destroy(&mut can_produce);
    pthread_cond_destroy(&mut can_consume);
}
unsafe extern "C" fn block_all_signals() -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut set: sigset_t = __sigset_t { __val: [0; 16] };
    rv = sigfillset(&mut set);
    if rv != 0 as libc::c_int {
        return rv;
    }
    rv = sigprocmask(
        0 as libc::c_int,
        &mut set as *mut sigset_t as *const sigset_t,
        0 as *mut libc::c_void as *mut sigset_t,
    );
    if rv != 0 as libc::c_int {
        return rv;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn write_done_pipe() {
    let mut rv: libc::c_int = 0;
    let mut ignore: libc::c_int = 0;
    let mut tmp: ssize_t = 0;
    if done_pipe[1 as libc::c_int as usize] >= 0 as libc::c_int {
        ignore = 1 as libc::c_int;
        tmp = write(
            done_pipe[1 as libc::c_int as usize],
            &mut ignore as *mut libc::c_int as *const libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
        );
        rv = tmp as libc::c_int;
    }
}
unsafe extern "C" fn handle_signal(mut signum: libc::c_int) {
    write_done_pipe();
}
unsafe extern "C" fn run_signal_thread(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut rv: libc::c_int = 0;
    let mut ignore: libc::c_int = 0;
    let mut rfds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut sa: sigaction = sigaction {
        __sigaction_handler: __anonunion___sigaction_handler_363639592 {
            sa_handler: None,
        },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut tmp: ssize_t = 0;
    rv = pipe(done_pipe.as_mut_ptr());
    rv = fcntl(
        done_pipe[1 as libc::c_int as usize],
        4 as libc::c_int,
        2048 as libc::c_int,
    );
    memset(
        &mut sa as *mut sigaction as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sigaction>() as libc::c_ulong,
    );
    sa
        .__sigaction_handler
        .sa_handler = Some(handle_signal as unsafe extern "C" fn(libc::c_int) -> ());
    sigaction(
        2 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    sigaction(
        15 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    sigaction(
        1 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    sigaction(
        14 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    sa
        .__sigaction_handler
        .sa_handler = ::std::mem::transmute::<
        libc::intptr_t,
        Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    >(1 as libc::c_int as libc::intptr_t);
    sigaction(
        13 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    loop {
        let fresh20 = &mut __d0;
        let fresh21;
        let fresh22 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh23 = &mut __d1;
        let fresh24;
        let fresh25 = &mut *(rfds.fds_bits)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh20, fresh22) => fresh21,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh23, fresh25) =>
            fresh24, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh20, fresh22, fresh21);
        c2rust_asm_casts::AsmCast::cast_out(fresh23, fresh25, fresh24);
        rfds
            .fds_bits[(done_pipe[0 as libc::c_int as usize]
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << done_pipe[0 as libc::c_int as usize]
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        tv.tv_sec = 1 as libc::c_int as __time_t;
        tv.tv_usec = 0 as libc::c_int as __suseconds_t;
        rv = select(
            done_pipe[0 as libc::c_int as usize] + 1 as libc::c_int,
            &mut rfds as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut tv as *mut timeval,
        );
        if !(rv < 1 as libc::c_int) {
            break;
        }
    }
    tmp = read(
        done_pipe[0 as libc::c_int as usize],
        &mut ignore as *mut libc::c_int as *mut libc::c_void,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
    );
    rv = tmp as libc::c_int;
    done = 1 as libc::c_int;
    pthread_mutex_lock(&mut mutex);
    pthread_cond_broadcast(&mut can_consume);
    pthread_cond_broadcast(&mut can_produce);
    pthread_mutex_unlock(&mut mutex);
    return 0 as *mut libc::c_void;
}
static mut func_map: *mut func_entry_t = 0 as *const libc::c_void as *mut libc::c_void
    as *mut func_entry_t;
static mut func_list: *mut *mut func_entry_t = 0 as *const libc::c_void
    as *mut libc::c_void as *mut *mut func_entry_t;
static mut func_list_len: size_t = 0 as libc::c_int as size_t;
static mut func_list_size: size_t = 0 as libc::c_int as size_t;
static mut buf: [libc::c_char; 512] = [0; 512];
static mut buf_len: size_t = 0 as libc::c_int as size_t;
static mut total_samp_count: libc::c_ulong = 0 as libc::c_ulong;
static mut samp_count: libc::c_ulong = 0 as libc::c_ulong;
static mut total_err_count: libc::c_ulong = 0 as libc::c_ulong;
static mut is_paused: libc::c_int = 0 as libc::c_int;
static mut phpspy_args: [libc::c_char; 512] = [0; 512];
pub unsafe extern "C" fn main_top(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut readfds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut ttyfd: libc::c_int = 0;
    let mut outfd: libc::c_int = 0;
    let mut errfd: libc::c_int = 0;
    let mut maxfd: libc::c_int = 0;
    let mut pid: pid_t = 0;
    let mut timeout: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut ts: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut last_display: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut event: tb_event = tb_event {
        type_0: 0,
        mod_0: 0,
        key: 0,
        ch: 0,
        w: 0,
        h: 0,
        x: 0,
        y: 0,
    };
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    pid = -(1 as libc::c_int);
    ttyfd = pid;
    errfd = ttyfd;
    outfd = errfd;
    if opt_pid == -(1 as libc::c_int) {
        if opt_pgrep_args as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            if optind >= argc {
                log_error(
                    b"Expected pid (-p), pgrep (-P), or command\n\n\0" as *const u8
                        as *const libc::c_char,
                );
                usage(stderr, 1 as libc::c_int);
                return 1 as libc::c_int;
            }
        }
    }
    filter_child_args(argc, argv);
    snprintf(
        phpspy_args.as_mut_ptr(),
        512 as libc::c_int as size_t,
        b"phpspy \0" as *const u8 as *const libc::c_char,
    );
    i = 1 as libc::c_int;
    while i < argc {
        tmp = strlen(phpspy_args.as_mut_ptr() as *const libc::c_char);
        tmp___0 = strlen(phpspy_args.as_mut_ptr() as *const libc::c_char);
        snprintf(
            phpspy_args.as_mut_ptr().offset(tmp___0 as isize),
            (512 as libc::c_ulong).wrapping_sub(tmp),
            b"%s \0" as *const u8 as *const libc::c_char,
            *argv.offset(i as isize),
        );
        i += 1;
    }
    ttyfd = open(b"/dev/tty\0" as *const u8 as *const libc::c_char, 0 as libc::c_int);
    if ttyfd < 0 as libc::c_int {
        perror(b"open\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___1 = fork_child(argc, argv, &mut pid, &mut outfd, &mut errfd);
    if tmp___1 < 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    if ttyfd > outfd {
        tmp___4 = ttyfd;
    } else {
        tmp___4 = outfd;
    }
    if tmp___4 > errfd {
        if ttyfd > outfd {
            tmp___3 = ttyfd;
        } else {
            tmp___3 = outfd;
        }
        maxfd = tmp___3;
    } else {
        maxfd = errfd;
    }
    last_display.tv_sec = 0 as libc::c_int as __time_t;
    last_display.tv_nsec = 0 as libc::c_int as __syscall_slong_t;
    tb_init();
    while done == 0 {
        clock_gettime(1 as libc::c_int, &mut ts);
        if last_display.tv_sec == 0 as libc::c_long {
            display();
            last_display = ts;
        } else if ts.tv_sec - last_display.tv_sec >= 1 as libc::c_long {
            display();
            last_display = ts;
        }
        let fresh26 = &mut __d0;
        let fresh27;
        let fresh28 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh29 = &mut __d1;
        let fresh30;
        let fresh31 = &mut *(readfds.fds_bits)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh26, fresh28) => fresh27,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh29, fresh31) =>
            fresh30, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh26, fresh28, fresh27);
        c2rust_asm_casts::AsmCast::cast_out(fresh29, fresh31, fresh30);
        readfds
            .fds_bits[(ttyfd
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << ttyfd
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        readfds
            .fds_bits[(outfd
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << outfd
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        readfds
            .fds_bits[(errfd
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << errfd
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        timeout.tv_sec = 1 as libc::c_int as __time_t;
        timeout.tv_usec = 0 as libc::c_int as __suseconds_t;
        rc = select(
            maxfd + 1 as libc::c_int,
            &mut readfds as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut timeout as *mut timeval,
        );
        if rc < 0 as libc::c_int {
            tmp___5 = __errno_location();
            if *tmp___5 == 4 as libc::c_int {
                tb_peek_event(&mut event, 0 as libc::c_int);
                last_display.tv_sec = 0 as libc::c_int as __time_t;
            } else {
                perror(b"select\0" as *const u8 as *const libc::c_char);
                break;
            }
        } else {
            if readfds
                .fds_bits[(outfd
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << outfd
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                read_child_out(outfd);
            }
            if readfds
                .fds_bits[(errfd
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << errfd
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                read_child_err(errfd);
            }
            if readfds
                .fds_bits[(ttyfd
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << ttyfd
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                event.type_0 = 0 as libc::c_int as uint8_t;
                tb_peek_event(&mut event, 0 as libc::c_int);
                handle_event(&mut event);
            }
        }
    }
    tb_shutdown();
    close(outfd);
    close(errfd);
    close(ttyfd);
    kill(pid, 15 as libc::c_int);
    waitpid(pid, 0 as *mut libc::c_void as *mut libc::c_int, 0 as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fork_child(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
    mut pid: *mut pid_t,
    mut outfd: *mut libc::c_int,
    mut errfd: *mut libc::c_int,
) -> libc::c_int {
    let mut pout: [libc::c_int; 2] = [0; 2];
    let mut perr: [libc::c_int; 2] = [0; 2];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = pipe(pout.as_mut_ptr());
    if tmp < 0 as libc::c_int {
        perror(b"pipe\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    } else {
        tmp___0 = pipe(perr.as_mut_ptr());
        if tmp___0 < 0 as libc::c_int {
            perror(b"pipe\0" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        }
    }
    *pid = fork();
    if *pid == 0 as libc::c_int {
        close(pout[0 as libc::c_int as usize]);
        dup2(pout[1 as libc::c_int as usize], 1 as libc::c_int);
        close(pout[1 as libc::c_int as usize]);
        close(perr[0 as libc::c_int as usize]);
        dup2(perr[1 as libc::c_int as usize], 2 as libc::c_int);
        close(perr[1 as libc::c_int as usize]);
        execvp(
            *argv.offset(0 as libc::c_int as isize) as *const libc::c_char,
            argv as *const *mut libc::c_char,
        );
        perror(b"execvp\0" as *const u8 as *const libc::c_char);
        exit(1 as libc::c_int);
    } else {
        if *pid < 0 as libc::c_int {
            perror(b"fork\0" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        }
    }
    close(pout[1 as libc::c_int as usize]);
    close(perr[1 as libc::c_int as usize]);
    *outfd = pout[0 as libc::c_int as usize];
    *errfd = perr[0 as libc::c_int as usize];
    return 0 as libc::c_int;
}
unsafe extern "C" fn filter_child_args(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < argc {
        tmp = strncmp(
            *argv.offset(i as isize) as *const libc::c_char,
            b"-o\0" as *const u8 as *const libc::c_char,
            (::std::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_ulong),
        );
        if tmp == 0 as libc::c_int {
            *(*argv.offset(i as isize))
                .offset(1 as libc::c_int as isize) = '#' as i32 as libc::c_char;
            *(*argv.offset(i as isize))
                .offset(2 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
        } else {
            tmp___0 = strncmp(
                *argv.offset(i as isize) as *const libc::c_char,
                b"--output\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong),
            );
            if tmp___0 == 0 as libc::c_int {
                *(*argv.offset(i as isize))
                    .offset(1 as libc::c_int as isize) = '#' as i32 as libc::c_char;
                *(*argv.offset(i as isize))
                    .offset(2 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            }
        }
        tmp___1 = strncmp(
            *argv.offset(i as isize) as *const libc::c_char,
            b"-1\0" as *const u8 as *const libc::c_char,
            (::std::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_ulong),
        );
        if tmp___1 == 0 as libc::c_int {
            *(*argv.offset(i as isize))
                .offset(1 as libc::c_int as isize) = '@' as i32 as libc::c_char;
            *(*argv.offset(i as isize))
                .offset(2 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
        } else {
            tmp___2 = strncmp(
                *argv.offset(i as isize) as *const libc::c_char,
                b"--single-line\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_ulong),
            );
            if tmp___2 == 0 as libc::c_int {
                *(*argv.offset(i as isize))
                    .offset(1 as libc::c_int as isize) = '@' as i32 as libc::c_char;
                *(*argv.offset(i as isize))
                    .offset(2 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            } else {
                tmp___3 = strncmp(
                    *argv.offset(i as isize) as *const libc::c_char,
                    b"-t\0" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_ulong),
                );
                if tmp___3 == 0 as libc::c_int {
                    *(*argv.offset(i as isize))
                        .offset(1 as libc::c_int as isize) = '@' as i32 as libc::c_char;
                    *(*argv.offset(i as isize))
                        .offset(
                            2 as libc::c_int as isize,
                        ) = '\u{0}' as i32 as libc::c_char;
                } else {
                    tmp___4 = strncmp(
                        *argv.offset(i as isize) as *const libc::c_char,
                        b"--top\0" as *const u8 as *const libc::c_char,
                        (::std::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_ulong),
                    );
                    if tmp___4 == 0 as libc::c_int {
                        *(*argv.offset(i as isize))
                            .offset(
                                1 as libc::c_int as isize,
                            ) = '@' as i32 as libc::c_char;
                        *(*argv.offset(i as isize))
                            .offset(
                                2 as libc::c_int as isize,
                            ) = '\u{0}' as i32 as libc::c_char;
                    }
                }
            }
        }
        i += 1;
    }
}
unsafe extern "C" fn read_child_out(mut fd: libc::c_int) {
    let mut rem: size_t = 0;
    let mut line_len: size_t = 0;
    let mut nl: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut read_rv: ssize_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    rem = (512 as libc::c_ulong).wrapping_sub(buf_len);
    if rem < 1 as libc::c_ulong {
        buf_len = 0 as libc::c_int as size_t;
        rem = 512 as libc::c_int as size_t;
    }
    read_rv = read(
        fd,
        buf.as_mut_ptr().offset(buf_len as isize) as *mut libc::c_void,
        rem,
    );
    if read_rv < 0 as libc::c_long {
        perror(b"read\0" as *const u8 as *const libc::c_char);
        return;
    } else {
        if read_rv == 0 as libc::c_long {
            done = 1 as libc::c_int;
            return;
        }
    }
    buf_len = (buf_len as libc::c_ulong).wrapping_add(read_rv as size_t) as size_t
        as size_t;
    loop {
        tmp = memchr(buf.as_mut_ptr() as *const libc::c_void, '\n' as i32, buf_len);
        nl = tmp as *mut libc::c_char;
        if !(nl as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        line_len = nl.offset_from(buf.as_mut_ptr()) as libc::c_long as size_t;
        handle_line(buf.as_mut_ptr(), line_len as libc::c_int);
        memmove(
            buf.as_mut_ptr() as *mut libc::c_void,
            nl.offset(1 as libc::c_int as isize) as *const libc::c_void,
            buf_len.wrapping_sub(line_len.wrapping_add(1 as libc::c_ulong)),
        );
        buf_len = (buf_len as libc::c_ulong)
            .wrapping_sub(line_len.wrapping_add(1 as libc::c_ulong)) as size_t as size_t;
    };
}
unsafe extern "C" fn read_child_err(mut fd: libc::c_int) {
    let mut buf___0: [libc::c_char; 512] = [0; 512];
    let mut nl: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut buf_pos: size_t = 0;
    let mut read_rv: ssize_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    read_rv = read(
        fd,
        buf___0.as_mut_ptr() as *mut libc::c_void,
        512 as libc::c_int as size_t,
    );
    if read_rv < 0 as libc::c_long {
        perror(b"read\0" as *const u8 as *const libc::c_char);
        return;
    } else {
        if read_rv == 0 as libc::c_long {
            done = 1 as libc::c_int;
            return;
        }
    }
    buf_pos = 0 as libc::c_int as size_t;
    while read_rv > 0 as libc::c_long {
        tmp = memchr(
            buf___0.as_mut_ptr().offset(buf_pos as isize) as *const libc::c_void,
            '\n' as i32,
            read_rv as size_t,
        );
        nl = tmp as *mut libc::c_char;
        if !(nl as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        total_err_count = total_err_count.wrapping_add(1);
        buf_pos = (buf_pos as libc::c_ulong)
            .wrapping_add(
                (nl.offset_from(buf___0.as_mut_ptr()) as libc::c_long
                    + 1 as libc::c_long) as size_t,
            ) as size_t as size_t;
        read_rv
            -= nl.offset_from(buf___0.as_mut_ptr()) as libc::c_long + 1 as libc::c_long;
    }
}
unsafe extern "C" fn handle_line(
    mut line: *mut libc::c_char,
    mut line_len: libc::c_int,
) {
    let mut frame_num: libc::c_ulong = 0;
    let mut func: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut func_len: size_t = 0;
    let mut func_el: *mut func_entry_t = 0 as *mut func_entry_t;
    let mut tmp: libc::c_ulonglong = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _uthash_hastr_keylen: libc::c_uint = 0;
    let mut tmp___2: size_t = 0;
    let mut _ha_hashv: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _ha_bkt: libc::c_uint = 0;
    let mut _ha_head: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_bkt: libc::c_uint = 0;
    let mut _he_bkt_i: libc::c_uint = 0;
    let mut _he_thh: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_hh_nxt: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_new_buckets: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_newbkt: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    if line_len < 3 as libc::c_int {
        return;
    }
    if *line.offset(0 as libc::c_int as isize) as libc::c_int == 35 as libc::c_int {
        return;
    }
    tmp = strtoull(
        line as *const libc::c_char,
        &mut func as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    frame_num = tmp as libc::c_ulong;
    if frame_num == 0 as libc::c_ulong {
        if *line.offset(0 as libc::c_int as isize) as libc::c_int != 48 as libc::c_int {
            return;
        }
    }
    if *func as libc::c_int != 32 as libc::c_int {
        return;
    }
    func = func.offset(1);
    func_len = (line_len as libc::c_long - func.offset_from(line) as libc::c_long)
        as size_t;
    if func_len < 1 as libc::c_ulong {
        return
    } else {
        if func_len >= 256 as libc::c_ulong {
            return;
        }
    }
    _hj_key = func as *const libc::c_uchar;
    _hf_hashv = 4276993775 as libc::c_uint;
    _hj_j = 2654435769 as libc::c_uint;
    _hj_i = _hj_j;
    _hj_k = func_len as libc::c_uint;
    while _hj_k >= 12 as libc::c_uint {
        _hj_i = _hj_i
            .wrapping_add(
                (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_j = _hj_j
            .wrapping_add(
                (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hf_hashv = _hf_hashv
            .wrapping_add(
                (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    )
                    .wrapping_add(
                        (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    ),
            );
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        _hj_key = _hj_key.offset(12 as libc::c_int as isize);
        _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
    }
    _hf_hashv = _hf_hashv.wrapping_add(func_len as libc::c_uint);
    let mut current_block_75: u64;
    match _hj_k {
        11 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_75 = 3392204020619465943;
        }
        10 => {
            current_block_75 = 3392204020619465943;
        }
        9 => {
            current_block_75 = 9960857388512999596;
        }
        8 => {
            current_block_75 = 1424822628000323894;
        }
        7 => {
            current_block_75 = 2571106693052432160;
        }
        6 => {
            current_block_75 = 17528063775428179294;
        }
        5 => {
            current_block_75 = 1972285568473611889;
        }
        4 => {
            current_block_75 = 15292451710767490830;
        }
        3 => {
            current_block_75 = 361743433572870263;
        }
        2 => {
            current_block_75 = 16750978649452213598;
        }
        1 => {
            current_block_75 = 3437861484860790674;
        }
        _ => {
            current_block_75 = 10512632378975961025;
        }
    }
    match current_block_75 {
        3392204020619465943 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_75 = 9960857388512999596;
        }
        _ => {}
    }
    match current_block_75 {
        9960857388512999596 => {
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_75 = 1424822628000323894;
        }
        _ => {}
    }
    match current_block_75 {
        1424822628000323894 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_75 = 2571106693052432160;
        }
        _ => {}
    }
    match current_block_75 {
        2571106693052432160 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_75 = 17528063775428179294;
        }
        _ => {}
    }
    match current_block_75 {
        17528063775428179294 => {
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_75 = 1972285568473611889;
        }
        _ => {}
    }
    match current_block_75 {
        1972285568473611889 => {
            _hj_j = _hj_j
                .wrapping_add(
                    *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                );
            current_block_75 = 15292451710767490830;
        }
        _ => {}
    }
    match current_block_75 {
        15292451710767490830 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                        << 24 as libc::c_int,
                );
            current_block_75 = 361743433572870263;
        }
        _ => {}
    }
    match current_block_75 {
        361743433572870263 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                        << 16 as libc::c_int,
                );
            current_block_75 = 16750978649452213598;
        }
        _ => {}
    }
    match current_block_75 {
        16750978649452213598 => {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                        << 8 as libc::c_int,
                );
            current_block_75 = 3437861484860790674;
        }
        _ => {}
    }
    match current_block_75 {
        3437861484860790674 => {
            _hj_i = _hj_i
                .wrapping_add(
                    *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                );
        }
        _ => {}
    }
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 13 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 8 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 13 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 12 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 16 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 5 as libc::c_int;
    _hj_i = _hj_i.wrapping_sub(_hj_j);
    _hj_i = _hj_i.wrapping_sub(_hf_hashv);
    _hj_i ^= _hf_hashv >> 3 as libc::c_int;
    _hj_j = _hj_j.wrapping_sub(_hf_hashv);
    _hj_j = _hj_j.wrapping_sub(_hj_i);
    _hj_j ^= _hj_i << 10 as libc::c_int;
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
    _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
    _hf_hashv ^= _hj_j >> 15 as libc::c_int;
    func_el = 0 as *mut libc::c_void as *mut func_entry_t;
    if !func_map.is_null() {
        _hf_bkt = _hf_hashv
            & ((*(*func_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        if (*((*(*func_map).hh.tbl).buckets).offset(_hf_bkt as isize)).hh_head
            as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            func_el = ((*((*(*func_map).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as *mut libc::c_char)
                .offset(-((*(*func_map).hh.tbl).hho as isize)) as *mut libc::c_void
                as *mut func_entry_t;
        } else {
            func_el = 0 as *mut libc::c_void as *mut func_entry_t;
        }
        while func_el as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            if (*func_el).hh.hashv == _hf_hashv {
                if (*func_el).hh.keylen as size_t == func_len {
                    tmp___0 = memcmp(
                        (*func_el).hh.key as *const libc::c_void,
                        func as *const libc::c_void,
                        func_len,
                    );
                    if tmp___0 == 0 as libc::c_int {
                        break;
                    }
                }
            }
            if (*func_el).hh.hh_next as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                func_el = ((*func_el).hh.hh_next as *mut libc::c_char)
                    .offset(-((*(*func_map).hh.tbl).hho as isize)) as *mut libc::c_void
                    as *mut func_entry_t;
            } else {
                func_el = 0 as *mut libc::c_void as *mut func_entry_t;
            }
        }
    }
    if func_el.is_null() {
        tmp___1 = calloc(
            1 as libc::c_int as size_t,
            ::std::mem::size_of::<func_entry_t>() as libc::c_ulong,
        );
        func_el = tmp___1 as *mut func_entry_t;
        snprintf(
            ((*func_el).func).as_mut_ptr(),
            256 as libc::c_int as size_t,
            b"%.*s\0" as *const u8 as *const libc::c_char,
            func_len as libc::c_int,
            func,
        );
        tmp___2 = strlen(((*func_el).func).as_mut_ptr() as *const libc::c_char);
        _uthash_hastr_keylen = tmp___2 as libc::c_uint;
        _hj_key___0 = &mut *((*func_el).func)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut libc::c_char
            as *const libc::c_uchar;
        _ha_hashv = 4276993775 as libc::c_uint;
        _hj_j___0 = 2654435769 as libc::c_uint;
        _hj_i___0 = _hj_j___0;
        _hj_k___0 = _uthash_hastr_keylen;
        while _hj_k___0 >= 12 as libc::c_uint {
            _hj_i___0 = _hj_i___0
                .wrapping_add(
                    (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_j___0 = _hj_j___0
                .wrapping_add(
                    (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _ha_hashv = _ha_hashv
                .wrapping_add(
                    (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key___0.offset(11 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        ),
                );
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
            _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
            _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
        }
        _ha_hashv = _ha_hashv.wrapping_add(_uthash_hastr_keylen);
        let mut current_block_185: u64;
        match _hj_k___0 {
            11 => {
                _ha_hashv = _ha_hashv
                    .wrapping_add(
                        (*_hj_key___0.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_185 = 2759322998302693554;
            }
            10 => {
                current_block_185 = 2759322998302693554;
            }
            9 => {
                current_block_185 = 2754738251920144159;
            }
            8 => {
                current_block_185 = 2040432914424334438;
            }
            7 => {
                current_block_185 = 15170047362471857579;
            }
            6 => {
                current_block_185 = 15474844289544790043;
            }
            5 => {
                current_block_185 = 15073460235733877051;
            }
            4 => {
                current_block_185 = 13981027811449431130;
            }
            3 => {
                current_block_185 = 15505086279097134955;
            }
            2 => {
                current_block_185 = 5575106798985624601;
            }
            1 => {
                current_block_185 = 5748422980410355017;
            }
            _ => {
                current_block_185 = 2089914658669629659;
            }
        }
        match current_block_185 {
            2759322998302693554 => {
                _ha_hashv = _ha_hashv
                    .wrapping_add(
                        (*_hj_key___0.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_185 = 2754738251920144159;
            }
            _ => {}
        }
        match current_block_185 {
            2754738251920144159 => {
                _ha_hashv = _ha_hashv
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_185 = 2040432914424334438;
            }
            _ => {}
        }
        match current_block_185 {
            2040432914424334438 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_185 = 15170047362471857579;
            }
            _ => {}
        }
        match current_block_185 {
            15170047362471857579 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_185 = 15474844289544790043;
            }
            _ => {}
        }
        match current_block_185 {
            15474844289544790043 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_185 = 15073460235733877051;
            }
            _ => {}
        }
        match current_block_185 {
            15073460235733877051 => {
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        *_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_185 = 13981027811449431130;
            }
            _ => {}
        }
        match current_block_185 {
            13981027811449431130 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_185 = 15505086279097134955;
            }
            _ => {}
        }
        match current_block_185 {
            15505086279097134955 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_185 = 5575106798985624601;
            }
            _ => {}
        }
        match current_block_185 {
            5575106798985624601 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_185 = 5748422980410355017;
            }
            _ => {}
        }
        match current_block_185 {
            5748422980410355017 => {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        *_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
        _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
        _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
        _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
        _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
        _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
        _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
        _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
        _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
        _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
        _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
        _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
        _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
        (*func_el).hh.hashv = _ha_hashv;
        (*func_el)
            .hh
            .key = &mut *((*func_el).func).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut libc::c_char as *mut libc::c_void;
        (*func_el).hh.keylen = _uthash_hastr_keylen;
        if func_map.is_null() {
            (*func_el).hh.next = 0 as *mut libc::c_void;
            (*func_el).hh.prev = 0 as *mut libc::c_void;
            tmp___3 = malloc(::std::mem::size_of::<UT_hash_table>() as libc::c_ulong);
            (*func_el).hh.tbl = tmp___3 as *mut UT_hash_table;
            if ((*func_el).hh.tbl).is_null() {
                exit(-(1 as libc::c_int));
            } else {
                memset(
                    (*func_el).hh.tbl as *mut libc::c_void,
                    '\u{0}' as i32,
                    ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                );
                (*(*func_el).hh.tbl).tail = &mut (*func_el).hh;
                (*(*func_el).hh.tbl).num_buckets = 32 as libc::c_uint;
                (*(*func_el).hh.tbl).log2_num_buckets = 5 as libc::c_uint;
                (*(*func_el).hh.tbl)
                    .hho = (&mut (*func_el).hh as *mut UT_hash_handle
                    as *mut libc::c_char)
                    .offset_from(func_el as *mut libc::c_char) as libc::c_long;
                tmp___4 = malloc(
                    (32 as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                        ),
                );
                (*(*func_el).hh.tbl).buckets = tmp___4 as *mut UT_hash_bucket;
                (*(*func_el).hh.tbl).signature = 2685476833 as libc::c_uint;
                if ((*(*func_el).hh.tbl).buckets).is_null() {
                    exit(-(1 as libc::c_int));
                } else {
                    memset(
                        (*(*func_el).hh.tbl).buckets as *mut libc::c_void,
                        '\u{0}' as i32,
                        (32 as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                }
            }
            func_map = func_el;
        } else {
            (*func_el).hh.tbl = (*func_map).hh.tbl;
            (*func_el).hh.next = 0 as *mut libc::c_void;
            (*func_el)
                .hh
                .prev = ((*(*func_map).hh.tbl).tail as *mut libc::c_char)
                .offset(-((*(*func_map).hh.tbl).hho as isize)) as *mut libc::c_void;
            (*(*(*func_map).hh.tbl).tail).next = func_el as *mut libc::c_void;
            (*(*func_map).hh.tbl).tail = &mut (*func_el).hh;
        }
        (*(*func_map).hh.tbl)
            .num_items = ((*(*func_map).hh.tbl).num_items).wrapping_add(1);
        _ha_bkt = _ha_hashv
            & ((*(*func_map).hh.tbl).num_buckets).wrapping_sub(1 as libc::c_uint);
        _ha_head = ((*(*func_map).hh.tbl).buckets).offset(_ha_bkt as isize);
        (*_ha_head).count = ((*_ha_head).count).wrapping_add(1);
        (*func_el).hh.hh_next = (*_ha_head).hh_head;
        (*func_el).hh.hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
        if (*_ha_head).hh_head as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            (*(*_ha_head).hh_head).hh_prev = &mut (*func_el).hh;
        }
        (*_ha_head).hh_head = &mut (*func_el).hh;
        if (*_ha_head).count
            >= ((*_ha_head).expand_mult)
                .wrapping_add(1 as libc::c_uint)
                .wrapping_mul(10 as libc::c_uint)
        {
            if (*(*func_el).hh.tbl).noexpand == 0 {
                tmp___5 = malloc(
                    (2 as libc::c_ulong)
                        .wrapping_mul((*(*func_el).hh.tbl).num_buckets as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                        ),
                );
                _he_new_buckets = tmp___5 as *mut UT_hash_bucket;
                if _he_new_buckets.is_null() {
                    exit(-(1 as libc::c_int));
                } else {
                    memset(
                        _he_new_buckets as *mut libc::c_void,
                        '\u{0}' as i32,
                        (2 as libc::c_ulong)
                            .wrapping_mul(
                                (*(*func_el).hh.tbl).num_buckets as libc::c_ulong,
                            )
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                    if (*(*func_el).hh.tbl).num_items
                        & ((*(*func_el).hh.tbl).num_buckets)
                            .wrapping_mul(2 as libc::c_uint)
                            .wrapping_sub(1 as libc::c_uint) != 0 as libc::c_uint
                    {
                        tmp___6 = 1 as libc::c_uint;
                    } else {
                        tmp___6 = 0 as libc::c_uint;
                    }
                    (*(*func_el).hh.tbl)
                        .ideal_chain_maxlen = ((*(*func_el).hh.tbl).num_items
                        >> ((*(*func_el).hh.tbl).log2_num_buckets)
                            .wrapping_add(1 as libc::c_uint))
                        .wrapping_add(tmp___6);
                    (*(*func_el).hh.tbl).nonideal_items = 0 as libc::c_uint;
                    _he_bkt_i = 0 as libc::c_uint;
                    while _he_bkt_i < (*(*func_el).hh.tbl).num_buckets {
                        _he_thh = (*((*(*func_el).hh.tbl).buckets)
                            .offset(_he_bkt_i as isize))
                            .hh_head;
                        while _he_thh as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            _he_hh_nxt = (*_he_thh).hh_next;
                            _he_bkt = (*_he_thh).hashv
                                & ((*(*func_el).hh.tbl).num_buckets)
                                    .wrapping_mul(2 as libc::c_uint)
                                    .wrapping_sub(1 as libc::c_uint);
                            _he_newbkt = _he_new_buckets.offset(_he_bkt as isize);
                            (*_he_newbkt).count = ((*_he_newbkt).count).wrapping_add(1);
                            if (*_he_newbkt).count
                                > (*(*func_el).hh.tbl).ideal_chain_maxlen
                            {
                                (*(*func_el).hh.tbl)
                                    .nonideal_items = ((*(*func_el).hh.tbl).nonideal_items)
                                    .wrapping_add(1);
                                (*_he_newbkt)
                                    .expand_mult = ((*_he_newbkt).count)
                                    .wrapping_div((*(*func_el).hh.tbl).ideal_chain_maxlen);
                            }
                            (*_he_thh)
                                .hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                            (*_he_thh).hh_next = (*_he_newbkt).hh_head;
                            if (*_he_newbkt).hh_head as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                (*(*_he_newbkt).hh_head).hh_prev = _he_thh;
                            }
                            (*_he_newbkt).hh_head = _he_thh;
                            _he_thh = _he_hh_nxt;
                        }
                        _he_bkt_i = _he_bkt_i.wrapping_add(1);
                    }
                    free((*(*func_el).hh.tbl).buckets as *mut libc::c_void);
                    (*(*func_el).hh.tbl)
                        .num_buckets = ((*(*func_el).hh.tbl).num_buckets)
                        .wrapping_mul(2 as libc::c_uint);
                    (*(*func_el).hh.tbl)
                        .log2_num_buckets = ((*(*func_el).hh.tbl).log2_num_buckets)
                        .wrapping_add(1);
                    (*(*func_el).hh.tbl).buckets = _he_new_buckets;
                    if (*(*func_el).hh.tbl).nonideal_items
                        > (*(*func_el).hh.tbl).num_items >> 1 as libc::c_int
                    {
                        (*(*func_el).hh.tbl)
                            .ineff_expands = ((*(*func_el).hh.tbl).ineff_expands)
                            .wrapping_add(1);
                    } else {
                        (*(*func_el).hh.tbl).ineff_expands = 0 as libc::c_uint;
                    }
                    if (*(*func_el).hh.tbl).ineff_expands > 1 as libc::c_uint {
                        (*(*func_el).hh.tbl).noexpand = 1 as libc::c_uint;
                    }
                }
            }
        }
        func_list_len = func_list_len.wrapping_add(1);
        if func_list_len > func_list_size {
            tmp___7 = realloc(
                func_list as *mut libc::c_void,
                (::std::mem::size_of::<*mut func_entry_t>() as libc::c_ulong)
                    .wrapping_mul(func_list_size.wrapping_add(1024 as libc::c_ulong)),
            );
            func_list = tmp___7 as *mut *mut func_entry_t;
            func_list_size = (func_list_size as libc::c_ulong)
                .wrapping_add(1024 as libc::c_ulong) as size_t as size_t;
        }
        let ref mut fresh32 = *func_list
            .offset(func_list_len.wrapping_sub(1 as libc::c_ulong) as isize);
        *fresh32 = func_el;
    }
    if frame_num == 0 as libc::c_ulong {
        samp_count = samp_count.wrapping_add(1);
        (*func_el).count_excl = ((*func_el).count_excl).wrapping_add(1);
    }
    (*func_el).count_incl = ((*func_el).count_incl).wrapping_add(1);
}
unsafe extern "C" fn handle_event(mut event: *mut tb_event) {
    if (*event).type_0 as libc::c_int != 1 as libc::c_int {
        return
    } else {
        if (*event).ch == 113 as libc::c_uint {
            done = 1 as libc::c_int;
        } else if (*event).ch == 112 as libc::c_uint {
            is_paused = 1 as libc::c_int - is_paused;
        }
    };
}
unsafe extern "C" fn func_list_compare(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut fa: *mut func_entry_t = 0 as *mut func_entry_t;
    let mut fb: *mut func_entry_t = 0 as *mut func_entry_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    fa = *(a as *mut *mut func_entry_t);
    fb = *(b as *mut *mut func_entry_t);
    if (*fb).count_excl == (*fa).count_excl {
        if (*fb).count_incl == (*fa).count_incl {
            if (*fb).total_count_excl == (*fa).total_count_excl {
                if (*fb).total_count_incl == (*fa).total_count_incl {
                    return 0 as libc::c_int;
                }
                if (*fb).total_count_incl > (*fa).total_count_incl {
                    tmp = 1 as libc::c_int;
                } else {
                    tmp = -(1 as libc::c_int);
                }
                return tmp;
            }
            if (*fb).total_count_excl > (*fa).total_count_excl {
                tmp___0 = 1 as libc::c_int;
            } else {
                tmp___0 = -(1 as libc::c_int);
            }
            return tmp___0;
        }
        if (*fb).count_incl > (*fa).count_incl {
            tmp___1 = 1 as libc::c_int;
        } else {
            tmp___1 = -(1 as libc::c_int);
        }
        return tmp___1;
    }
    if (*fb).count_excl > (*fa).count_excl {
        tmp___2 = 1 as libc::c_int;
    } else {
        tmp___2 = -(1 as libc::c_int);
    }
    return tmp___2;
}
unsafe extern "C" fn display() {
    let mut y: libc::c_int = 0;
    let mut w: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut el: *mut func_entry_t = 0 as *mut func_entry_t;
    let mut i: size_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    if func_list_len > 0 as libc::c_ulong {
        qsort(
            func_list as *mut libc::c_void,
            func_list_len,
            ::std::mem::size_of::<*mut func_entry_t>() as libc::c_ulong,
            Some(
                func_list_compare
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
        i = 0 as libc::c_int as size_t;
        while i < func_list_len {
            let ref mut fresh33 = (**func_list.offset(i as isize)).total_count_excl;
            *fresh33 = (*fresh33)
                .wrapping_add((**func_list.offset(i as isize)).count_excl);
            let ref mut fresh34 = (**func_list.offset(i as isize)).total_count_incl;
            *fresh34 = (*fresh34)
                .wrapping_add((**func_list.offset(i as isize)).count_incl);
            if samp_count < 1 as libc::c_ulong {
                (**func_list.offset(i as isize)).percent_excl = 0.0f32;
            } else {
                (**func_list.offset(i as isize))
                    .percent_excl = 100.0f32
                    * (**func_list.offset(i as isize)).count_excl as libc::c_float
                    / samp_count as libc::c_float;
            }
            i = i.wrapping_add(1);
        }
    }
    total_samp_count = total_samp_count.wrapping_add(samp_count);
    tb_clear();
    w = tb_width();
    h = tb_height();
    y = 0 as libc::c_int;
    tmp = y;
    y += 1;
    tb_printf(
        0 as libc::c_int,
        tmp,
        256 as libc::c_int as uintattr_t,
        0 as libc::c_int as uintattr_t,
        b"%s\0" as *const u8 as *const libc::c_char,
        phpspy_args.as_mut_ptr(),
    );
    tmp___0 = y;
    y += 1;
    tb_printf(
        0 as libc::c_int,
        tmp___0,
        0 as libc::c_int as uintattr_t,
        0 as libc::c_int as uintattr_t,
        b"samp_count=%llu  err_count=%llu  func_count=%llu\0" as *const u8
            as *const libc::c_char,
        total_samp_count,
        total_err_count,
        func_list_len,
    );
    y += 1;
    tb_printf(
        0 as libc::c_int,
        y,
        1280 as libc::c_int as uintattr_t,
        0 as libc::c_int as uintattr_t,
        b"%-10s %-10s %-10s %-10s %-7s \0" as *const u8 as *const libc::c_char,
        b"tincl\0" as *const u8 as *const libc::c_char,
        b"texcl\0" as *const u8 as *const libc::c_char,
        b"incl\0" as *const u8 as *const libc::c_char,
        b"excl\0" as *const u8 as *const libc::c_char,
        b"excl%\0" as *const u8 as *const libc::c_char,
    );
    tmp___1 = y;
    y += 1;
    tb_printf(
        52 as libc::c_int,
        tmp___1,
        1280 as libc::c_int as uintattr_t,
        0 as libc::c_int as uintattr_t,
        b"%-*s\0" as *const u8 as *const libc::c_char,
        w - 52 as libc::c_int,
        b"func\0" as *const u8 as *const libc::c_char,
    );
    i = 0 as libc::c_int as size_t;
    while y < h {
        if !(i < func_list_len) {
            break;
        }
        tmp___2 = i;
        i = i.wrapping_add(1);
        el = *func_list.offset(tmp___2 as isize);
        tmp___3 = y;
        y += 1;
        tb_printf(
            0 as libc::c_int,
            tmp___3,
            0 as libc::c_int as uintattr_t,
            0 as libc::c_int as uintattr_t,
            b"%-9llu  %-9llu  %-9llu  %-9llu  %-6.2f  %s\0" as *const u8
                as *const libc::c_char,
            (*el).total_count_incl,
            (*el).total_count_excl,
            (*el).count_incl,
            (*el).count_excl,
            (*el).percent_excl as libc::c_double,
            ((*el).func).as_mut_ptr(),
        );
    }
    i = 0 as libc::c_int as size_t;
    while i < func_list_len {
        (**func_list.offset(i as isize)).count_excl = 0 as libc::c_ulong;
        (**func_list.offset(i as isize)).count_incl = 0 as libc::c_ulong;
        i = i.wrapping_add(1);
    }
    samp_count = 0 as libc::c_ulong;
    if is_paused == 0 {
        tb_present();
    }
}
unsafe extern "C" fn shell_escape(
    mut arg: *const libc::c_char,
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
) -> libc::c_int {
    let mut buf_end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    buf_end = buf___0.offset(buf_size as isize);
    if !(buf_size >= 1 as libc::c_ulong) {
        __assert_fail(
            b"buf_size >= 1\0" as *const u8 as *const libc::c_char,
            b"addr_objdump.c\0" as *const u8 as *const libc::c_char,
            11 as libc::c_uint,
            b"shell_escape\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp = buf___0;
    buf___0 = buf___0.offset(1);
    *tmp = '\'' as i32 as libc::c_char;
    while *arg != 0 {
        if *arg as libc::c_int == 39 as libc::c_int {
            if (buf_end.offset_from(buf___0) as libc::c_long) < 4 as libc::c_long {
                return 1 as libc::c_int;
            }
            tmp___0 = buf___0;
            buf___0 = buf___0.offset(1);
            *tmp___0 = '\'' as i32 as libc::c_char;
            tmp___1 = buf___0;
            buf___0 = buf___0.offset(1);
            *tmp___1 = '\\' as i32 as libc::c_char;
            tmp___2 = buf___0;
            buf___0 = buf___0.offset(1);
            *tmp___2 = '\'' as i32 as libc::c_char;
            tmp___3 = buf___0;
            buf___0 = buf___0.offset(1);
            *tmp___3 = '\'' as i32 as libc::c_char;
            arg = arg.offset(1);
        } else {
            if (buf_end.offset_from(buf___0) as libc::c_long) < 1 as libc::c_long {
                return 1 as libc::c_int;
            }
            tmp___4 = buf___0;
            buf___0 = buf___0.offset(1);
            tmp___5 = arg;
            arg = arg.offset(1);
            *tmp___4 = *tmp___5;
        }
    }
    if (buf_end.offset_from(buf___0) as libc::c_long) < 2 as libc::c_long {
        return 1 as libc::c_int;
    }
    tmp___6 = buf___0;
    buf___0 = buf___0.offset(1);
    *tmp___6 = '\'' as i32 as libc::c_char;
    *buf___0 = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn get_symbol_addr(
    mut memo: *mut addr_memo_t,
    mut pid: pid_t,
    mut symbol: *const libc::c_char,
    mut raddr: *mut uint64_t,
) -> libc::c_int {
    let mut php_bin_path: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut php_bin_path_root: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut php_base_addr: *mut uint64_t = 0 as *mut uint64_t;
    let mut addr_offset: uint64_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    php_bin_path = ((*memo).php_bin_path).as_mut_ptr();
    php_bin_path_root = ((*memo).php_bin_path_root).as_mut_ptr();
    php_base_addr = &mut (*memo).php_base_addr;
    if *php_bin_path as libc::c_int == 0 as libc::c_int {
        tmp___1 = get_php_bin_path(pid, php_bin_path_root, php_bin_path);
        if tmp___1 != 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    if *php_base_addr == 0 as libc::c_ulong {
        tmp___0 = get_php_base_addr(pid, php_bin_path_root, php_bin_path, php_base_addr);
        if tmp___0 != 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    tmp = get_symbol_offset(php_bin_path_root, symbol, &mut addr_offset);
    if tmp != 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    *raddr = (*php_base_addr).wrapping_add(addr_offset);
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_php_bin_path(
    mut pid: pid_t,
    mut path_root: *mut libc::c_char,
    mut path: *mut libc::c_char,
) -> libc::c_int {
    let mut buf___0: [libc::c_char; 256] = [0; 256];
    let mut cmd_fmt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    cmd_fmt = b"awk -ve=1 '/libphp[78]?/{print $NF; e=0; exit} END{exit e}' /proc/%d/maps || readlink /proc/%d/exe\0"
        as *const u8 as *const libc::c_char as *mut libc::c_char;
    tmp = popen_read_line(
        buf___0.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        cmd_fmt,
        pid,
        pid,
    );
    if tmp != 0 as libc::c_int {
        log_error(b"get_php_bin_path: Failed\n\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = snprintf(
        path_root,
        256 as libc::c_int as size_t,
        b"/proc/%d/root/%s\0" as *const u8 as *const libc::c_char,
        pid,
        buf___0.as_mut_ptr(),
    );
    if tmp___0 > 255 as libc::c_int {
        log_error(
            b"get_php_bin_path: snprintf overflow\n\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    tmp___1 = access(path_root as *const libc::c_char, 0 as libc::c_int);
    if tmp___1 != 0 as libc::c_int {
        snprintf(
            path_root,
            256 as libc::c_int as size_t,
            b"/proc/%d/exe\0" as *const u8 as *const libc::c_char,
            pid,
        );
    }
    strcpy(path, buf___0.as_mut_ptr() as *const libc::c_char);
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_php_base_addr(
    mut pid: pid_t,
    mut path_root: *mut libc::c_char,
    mut path: *mut libc::c_char,
    mut raddr: *mut uint64_t,
) -> libc::c_int {
    let mut buf___0: [libc::c_char; 256] = [0; 256];
    let mut arg_buf: [libc::c_char; 256] = [0; 256];
    let mut start_addr: uint64_t = 0;
    let mut virt_addr: uint64_t = 0;
    let mut cmd_fmt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_ulonglong = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_ulonglong = 0;
    cmd_fmt = b"grep -m1 ' '%s\\$ /proc/%d/maps\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    tmp = shell_escape(
        path as *const libc::c_char,
        arg_buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
    );
    if tmp != 0 {
        log_error(
            b"shell_escape: Buffer too small to escape path: %s\n\0" as *const u8
                as *const libc::c_char,
            path,
        );
        return 1 as libc::c_int;
    }
    tmp___0 = popen_read_line(
        buf___0.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        cmd_fmt,
        arg_buf.as_mut_ptr(),
        pid,
    );
    if tmp___0 != 0 as libc::c_int {
        log_error(
            b"get_php_base_addr: Failed to get start_addr\n\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    tmp___1 = strtoull(
        buf___0.as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        16 as libc::c_int,
    );
    start_addr = tmp___1 as uint64_t;
    tmp___2 = shell_escape(
        path_root as *const libc::c_char,
        arg_buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
    );
    if tmp___2 != 0 {
        log_error(
            b"shell_escape: Buffer too small to escape path_root: %s\n\0" as *const u8
                as *const libc::c_char,
            path_root,
        );
        return 1 as libc::c_int;
    }
    cmd_fmt = b"objdump -p %s | awk '/LOAD/{print $5; exit}'\0" as *const u8
        as *const libc::c_char as *mut libc::c_char;
    tmp___3 = popen_read_line(
        buf___0.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        cmd_fmt,
        arg_buf.as_mut_ptr(),
    );
    if tmp___3 != 0 as libc::c_int {
        log_error(
            b"get_php_base_addr: Failed to get virt_addr\n\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    tmp___4 = strtoull(
        buf___0.as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        16 as libc::c_int,
    );
    virt_addr = tmp___4 as uint64_t;
    *raddr = start_addr.wrapping_sub(virt_addr);
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_symbol_offset(
    mut path_root: *mut libc::c_char,
    mut symbol: *const libc::c_char,
    mut raddr: *mut uint64_t,
) -> libc::c_int {
    let mut buf___0: [libc::c_char; 256] = [0; 256];
    let mut arg_buf: [libc::c_char; 256] = [0; 256];
    let mut cmd_fmt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_ulonglong = 0;
    cmd_fmt = b"objdump -Tt %s | awk '/ %s$/{print $1; exit}'\0" as *const u8
        as *const libc::c_char as *mut libc::c_char;
    tmp = shell_escape(
        path_root as *const libc::c_char,
        arg_buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
    );
    if tmp != 0 {
        log_error(
            b"shell_escape: Buffer too smal to escape path_root: %s\n\0" as *const u8
                as *const libc::c_char,
            path_root,
        );
        return 1 as libc::c_int;
    }
    tmp___0 = popen_read_line(
        buf___0.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        cmd_fmt,
        arg_buf.as_mut_ptr(),
        symbol,
    );
    if tmp___0 != 0 as libc::c_int {
        log_error(b"get_symbol_offset: Failed\n\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___1 = strtoull(
        buf___0.as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        16 as libc::c_int,
    );
    *raddr = tmp___1 as uint64_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn popen_read_line(
    mut buf___0: *mut libc::c_char,
    mut buf_size: size_t,
    mut cmd_fmt: *mut libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut cmd: [libc::c_char; 256] = [0; 256];
    let mut buf_len___0: libc::c_int = 0;
    let mut cmd_args: ::std::ffi::VaListImpl;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: size_t = 0;
    cmd_args = args.clone();
    tmp = vsnprintf(
        cmd.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        cmd_fmt as *const libc::c_char,
        cmd_args.as_va_list(),
    );
    if tmp
        >= (::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_ulong) as libc::c_int
    {
        log_error(b"vsnprintf overflow\n\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    fp = popen(
        cmd.as_mut_ptr() as *const libc::c_char,
        b"r\0" as *const u8 as *const libc::c_char,
    );
    if fp.is_null() {
        perror(b"popen\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = fgets(
        buf___0,
        buf_size.wrapping_sub(1 as libc::c_ulong) as libc::c_int,
        fp,
    );
    if tmp___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        log_error(
            b"popen_read_line: No stdout; cmd=%s\n\0" as *const u8
                as *const libc::c_char,
            cmd.as_mut_ptr(),
        );
        pclose(fp);
        return 1 as libc::c_int;
    }
    pclose(fp);
    tmp___1 = strlen(buf___0 as *const libc::c_char);
    buf_len___0 = tmp___1 as libc::c_int;
    while buf_len___0 > 0 as libc::c_int {
        if !(*buf___0.offset((buf_len___0 - 1 as libc::c_int) as isize) as libc::c_int
            == 10 as libc::c_int)
        {
            break;
        }
        buf_len___0 -= 1;
    }
    if buf_len___0 < 1 as libc::c_int {
        log_error(
            b"popen_read_line: Expected strlen(buf)>0; cmd=%s\n\0" as *const u8
                as *const libc::c_char,
            cmd.as_mut_ptr(),
        );
        return 1 as libc::c_int;
    }
    *buf___0.offset(buf_len___0 as isize) = '\u{0}' as i32 as libc::c_char;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn event_handler_fout(
    mut context: *mut trace_context_s,
    mut event_type: libc::c_int,
) -> libc::c_int {
    let mut rv: libc::c_int = 0;
    let mut fd: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut frame: *mut trace_frame_t = 0 as *mut trace_frame_t;
    let mut request: *mut trace_request_t = 0 as *mut trace_request_t;
    let mut udata: *mut event_handler_fout_udata_t = 0
        as *mut event_handler_fout_udata_t;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    udata = (*context).event_udata as *mut event_handler_fout_udata_t;
    if udata.is_null() {
        if event_type != 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    len = 0 as libc::c_int as size_t;
    let mut current_block_145: u64;
    match event_type {
        0 => {
            rv = event_handler_fout_open(&mut fd);
            if rv != 0 as libc::c_int {
                return rv;
            }
            tmp = calloc(
                1 as libc::c_int as size_t,
                ::std::mem::size_of::<event_handler_fout_udata_t>() as libc::c_ulong,
            );
            udata = tmp as *mut event_handler_fout_udata_t;
            (*udata).fd = fd;
            (*udata).buf_size = (opt_fout_buffer_size + 1 as libc::c_int) as size_t;
            tmp___0 = malloc((*udata).buf_size);
            (*udata).buf = tmp___0 as *mut libc::c_char;
            (*udata).cur = (*udata).buf;
            (*udata).rem = (*udata).buf_size;
            (*context).event_udata = udata as *mut libc::c_void;
        }
        1 => {
            (*udata).cur = (*udata).buf;
            *((*udata).cur)
                .offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            (*udata).rem = (*udata).buf_size;
        }
        2 => {
            frame = &mut (*context).event.frame;
            if (*frame).loc.class_len > 0 as libc::c_ulong {
                tmp___1 = b"::\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___1 = b"\0" as *const u8 as *const libc::c_char;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"%d %.*s%s%.*s %.*s:%d\0" as *const u8 as *const libc::c_char,
                (*frame).depth,
                (*frame).loc.class_len as libc::c_int,
                ((*frame).loc.class).as_mut_ptr(),
                tmp___1,
                (*frame).loc.func_len as libc::c_int,
                ((*frame).loc.func).as_mut_ptr(),
                (*frame).loc.file_len as libc::c_int,
                ((*frame).loc.file).as_mut_ptr(),
                (*frame).loc.lineno,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        3 => {
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# varpeek %s@%s = %s\0" as *const u8 as *const libc::c_char,
                ((*(*context).event.varpeek.var).name).as_mut_ptr(),
                ((*(*context).event.varpeek.entry).filename_lineno).as_mut_ptr(),
                (*context).event.varpeek.zval_str,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        4 => {
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# glopeek %s = %s\0" as *const u8 as *const libc::c_char,
                ((*(*context).event.glopeek.gentry).key).as_mut_ptr(),
                (*context).event.glopeek.zval_str,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        5 => {
            request = &mut (*context).event.request;
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# uri = %s\0" as *const u8 as *const libc::c_char,
                ((*request).uri).as_mut_ptr(),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# path = %s\0" as *const u8 as *const libc::c_char,
                ((*request).path).as_mut_ptr(),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# qstring = %s\0" as *const u8 as *const libc::c_char,
                ((*request).qstring).as_mut_ptr(),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# cookie = %s\0" as *const u8 as *const libc::c_char,
                ((*request).cookie).as_mut_ptr(),
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# ts = %f\0" as *const u8 as *const libc::c_char,
                (*request).ts,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        6 => {
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                1 as libc::c_int,
                b"# mem %lu %lu\0" as *const u8 as *const libc::c_char,
                (*context).event.mem.size,
                (*context).event.mem.peak,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
            rv = event_handler_fout_snprintf(
                &mut (*udata).cur as *mut *mut libc::c_char,
                &mut (*udata).rem as *mut size_t,
                &mut len as *mut size_t,
                0 as libc::c_int,
                b"%c\0" as *const u8 as *const libc::c_char,
                opt_frame_delim as libc::c_int,
            );
            if rv != 0 as libc::c_int {
                return rv;
            }
        }
        7 => {
            if !((*udata).cur as libc::c_ulong == (*udata).buf as libc::c_ulong) {
                if !opt_filter_re.is_null() {
                    rv = regexec(
                        opt_filter_re as *const regex_t,
                        (*udata).buf as *const libc::c_char,
                        0 as libc::c_int as size_t,
                        0 as *mut libc::c_void as *mut regmatch_t,
                        0 as libc::c_int,
                    );
                    if opt_filter_negate == 0 as libc::c_int {
                        if rv != 0 as libc::c_int {
                            current_block_145 = 2544535129495155983;
                        } else {
                            current_block_145 = 11718254377427810743;
                        }
                    } else {
                        current_block_145 = 11718254377427810743;
                    }
                    match current_block_145 {
                        2544535129495155983 => {}
                        _ => {
                            if opt_filter_negate != 0 as libc::c_int {
                                if rv == 0 as libc::c_int {
                                    current_block_145 = 2544535129495155983;
                                } else {
                                    current_block_145 = 9073771928613846474;
                                }
                            } else {
                                current_block_145 = 9073771928613846474;
                            }
                        }
                    }
                } else {
                    current_block_145 = 9073771928613846474;
                }
                match current_block_145 {
                    2544535129495155983 => {}
                    _ => {
                        if opt_verbose_fields_ts != 0 {
                            gettimeofday(
                                &mut tv as *mut timeval,
                                0 as *mut libc::c_void,
                            );
                            rv = event_handler_fout_snprintf(
                                &mut (*udata).cur as *mut *mut libc::c_char,
                                &mut (*udata).rem as *mut size_t,
                                &mut len as *mut size_t,
                                1 as libc::c_int,
                                b"# trace_ts = %f\0" as *const u8 as *const libc::c_char,
                                tv.tv_sec as libc::c_double
                                    + tv.tv_usec as libc::c_double / 1000000.0f64,
                            );
                            rv != 0 as libc::c_int;
                            rv = event_handler_fout_snprintf(
                                &mut (*udata).cur as *mut *mut libc::c_char,
                                &mut (*udata).rem as *mut size_t,
                                &mut len as *mut size_t,
                                0 as libc::c_int,
                                b"%c\0" as *const u8 as *const libc::c_char,
                                opt_frame_delim as libc::c_int,
                            );
                            rv != 0 as libc::c_int;
                        }
                        if opt_verbose_fields_pid != 0 {
                            rv = event_handler_fout_snprintf(
                                &mut (*udata).cur as *mut *mut libc::c_char,
                                &mut (*udata).rem as *mut size_t,
                                &mut len as *mut size_t,
                                1 as libc::c_int,
                                b"# pid = %d\0" as *const u8 as *const libc::c_char,
                                (*context).target.pid,
                            );
                            rv != 0 as libc::c_int;
                            rv = event_handler_fout_snprintf(
                                &mut (*udata).cur as *mut *mut libc::c_char,
                                &mut (*udata).rem as *mut size_t,
                                &mut len as *mut size_t,
                                0 as libc::c_int,
                                b"%c\0" as *const u8 as *const libc::c_char,
                                opt_frame_delim as libc::c_int,
                            );
                            rv != 0 as libc::c_int;
                        }
                        rv = event_handler_fout_snprintf(
                            &mut (*udata).cur as *mut *mut libc::c_char,
                            &mut (*udata).rem as *mut size_t,
                            &mut len as *mut size_t,
                            0 as libc::c_int,
                            b"%c\0" as *const u8 as *const libc::c_char,
                            opt_trace_delim as libc::c_int,
                        );
                        rv != 0 as libc::c_int;
                        rv = event_handler_fout_write(udata);
                        if rv != 0 as libc::c_int {
                            return rv;
                        }
                    }
                }
            }
        }
        9 => {
            close((*udata).fd);
            free((*udata).buf as *mut libc::c_void);
            free(udata as *mut libc::c_void);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn event_handler_fout_write(
    mut udata: *mut event_handler_fout_udata_t,
) -> libc::c_int {
    let mut write_len: ssize_t = 0;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___4: ssize_t = 0;
    write_len = ((*udata).cur).offset_from((*udata).buf) as libc::c_long;
    if !(write_len < 1 as libc::c_long) {
        tmp___4 = write(
            (*udata).fd,
            (*udata).buf as *const libc::c_void,
            write_len as size_t,
        );
        if tmp___4 != write_len {
            tmp___3 = __errno_location();
            if *tmp___3 != 0 as libc::c_int {
                tmp___0 = __errno_location();
                tmp___1 = strerror(*tmp___0);
                tmp___2 = tmp___1 as *const libc::c_char;
            } else {
                tmp___2 = b"partial\0" as *const u8 as *const libc::c_char;
            }
            log_error(
                b"event_handler_fout: Write failed (%s)\n\0" as *const u8
                    as *const libc::c_char,
                tmp___2,
            );
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn event_handler_fout_snprintf(
    mut s: *mut *mut libc::c_char,
    mut n: *mut size_t,
    mut ret_len: *mut size_t,
    mut repl_delim: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut vl: ::std::ffi::VaListImpl;
    let mut c: *mut libc::c_char = 0 as *mut libc::c_char;
    vl = args.clone();
    len = vsnprintf(*s, *n, fmt, vl.as_va_list());
    if len < 0 as libc::c_int {
        log_error(
            b"event_handler_fout_snprintf: Not enough space in buffer; truncating\n\0"
                as *const u8 as *const libc::c_char,
        );
        return 5 as libc::c_int;
    } else {
        if len as size_t >= *n {
            log_error(
                b"event_handler_fout_snprintf: Not enough space in buffer; truncating\n\0"
                    as *const u8 as *const libc::c_char,
            );
            return 5 as libc::c_int;
        }
    }
    if repl_delim != 0 {
        i = 0 as libc::c_int;
        while i < len {
            c = (*s).offset(i as isize);
            if *c as libc::c_int == opt_trace_delim as libc::c_int {
                *c = '?' as i32 as libc::c_char;
            } else if *c as libc::c_int == opt_frame_delim as libc::c_int {
                *c = '?' as i32 as libc::c_char;
            }
            i += 1;
        }
    }
    *s = (*s).offset(len as isize);
    *n = (*n as libc::c_ulong).wrapping_sub(len as size_t) as size_t as size_t;
    *ret_len = len as size_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn event_handler_fout_open(mut fd: *mut libc::c_int) -> libc::c_int {
    let mut tfd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strcmp(
        opt_path_output as *const libc::c_char,
        b"-\0" as *const u8 as *const libc::c_char,
    );
    if tmp == 0 as libc::c_int {
        tfd = dup(1 as libc::c_int);
        if tfd < 0 as libc::c_int {
            perror(
                b"event_handler_fout_open: dup\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    } else {
        tfd = open(
            opt_path_output as *const libc::c_char,
            577 as libc::c_int,
            384 as libc::c_int | 256 as libc::c_int >> 3 as libc::c_int
                | 256 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,
        );
        if tfd < 0 as libc::c_int {
            perror(
                b"event_handler_fout_open: open\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    }
    *fd = tfd;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn event_handler_callgrind(
    mut context: *mut trace_context_s,
    mut event_type: libc::c_int,
) -> libc::c_int {
    let mut udata: *mut callgrind_udata_t = 0 as *mut callgrind_udata_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    udata = (*context).event_udata as *mut callgrind_udata_t;
    if udata.is_null() {
        if event_type != 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    match event_type {
        0 => {
            tmp = calloc(
                1 as libc::c_int as size_t,
                ::std::mem::size_of::<callgrind_udata_t>() as libc::c_ulong,
            );
            udata = tmp as *mut callgrind_udata_t;
            tmp___0 = callgrind_open(&mut (*udata).fout);
            if tmp___0 != 0 as libc::c_int {
                free(udata as *mut libc::c_void);
                return 1 as libc::c_int;
            }
            (*context).event_udata = udata as *mut libc::c_void;
        }
        1 => {
            (*udata).self_len = 0 as libc::c_int;
        }
        2 => {
            callgrind_ingest_frame(udata, context);
        }
        7 => {
            callgrind_digest_stack(udata);
            memcpy(
                ((*udata).prev).as_mut_ptr() as *mut libc::c_void,
                ((*udata).self_0).as_mut_ptr() as *const libc::c_void,
                (::std::mem::size_of::<trace_loc_t>() as libc::c_ulong)
                    .wrapping_mul((*udata).self_len as libc::c_ulong),
            );
            memcpy(
                ((*udata).prev_str).as_mut_ptr() as *mut libc::c_void,
                ((*udata).self_str).as_mut_ptr() as *const libc::c_void,
                (256 as libc::c_int * (*udata).self_len) as size_t,
            );
            (*udata).prev_len = (*udata).self_len;
            (*udata).self_len = 0 as libc::c_int;
        }
        9 => {
            callgrind_dump(udata);
            callgrind_free(udata);
            free(udata as *mut libc::c_void);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn callgrind_ingest_frame(
    mut udata: *mut callgrind_udata_t,
    mut context: *mut trace_context_s,
) {
    if (*udata).self_len >= 128 as libc::c_int {
        log_error(
            b"callgrind_ingest_frame: Exceeded max stack depth (%d); truncating\n\0"
                as *const u8 as *const libc::c_char,
            128 as libc::c_int,
        );
        return;
    }
    memcpy(
        &mut *((*udata).self_0).as_mut_ptr().offset((*udata).self_len as isize)
            as *mut trace_loc_t as *mut libc::c_void,
        &mut (*context).event.frame.loc as *mut trace_loc_t as *const libc::c_void,
        ::std::mem::size_of::<trace_loc_t>() as libc::c_ulong,
    );
    callgrind_sprint_loc(
        ((*udata).self_str[(*udata).self_len as usize]).as_mut_ptr(),
        &mut (*context).event.frame.loc,
    );
    (*udata).self_len += 1;
}
unsafe extern "C" fn callgrind_sprint_loc(
    mut str: *mut libc::c_char,
    mut loc: *mut trace_loc_t,
) {
    let mut len: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if (*loc).class_len > 0 as libc::c_ulong {
        tmp = b"::\0" as *const u8 as *const libc::c_char;
    } else {
        tmp = b"\0" as *const u8 as *const libc::c_char;
    }
    len = snprintf(
        str,
        256 as libc::c_int as size_t,
        b"%.*s%s%.*s %.*s:%d\0" as *const u8 as *const libc::c_char,
        (*loc).class_len as libc::c_int,
        ((*loc).class).as_mut_ptr(),
        tmp,
        (*loc).func_len as libc::c_int,
        ((*loc).func).as_mut_ptr(),
        (*loc).file_len as libc::c_int,
        ((*loc).file).as_mut_ptr(),
        (*loc).lineno,
    );
    if len >= 256 as libc::c_int {
        log_error(
            b"callgrind_sprint_loc: Exceeded max loc len (%d); truncating\n\0"
                as *const u8 as *const libc::c_char,
            256 as libc::c_int,
        );
    }
}
unsafe extern "C" fn callgrind_digest_stack(mut udata: *mut callgrind_udata_t) {
    let mut caller: *mut callgrind_caller_t = 0 as *mut callgrind_caller_t;
    let mut prev_caller: *mut callgrind_caller_t = 0 as *mut callgrind_caller_t;
    let mut callee: *mut callgrind_callee_t = 0 as *mut callgrind_callee_t;
    let mut i: libc::c_int = 0;
    let mut _uthash_hfstr_keylen: libc::c_uint = 0;
    let mut tmp: size_t = 0;
    let mut _hf_hashv: libc::c_uint = 0;
    let mut _hj_i: libc::c_uint = 0;
    let mut _hj_j: libc::c_uint = 0;
    let mut _hj_k: libc::c_uint = 0;
    let mut _hj_key: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt: libc::c_uint = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _uthash_hastr_keylen: libc::c_uint = 0;
    let mut tmp___2: size_t = 0;
    let mut _ha_hashv: libc::c_uint = 0;
    let mut _hj_i___0: libc::c_uint = 0;
    let mut _hj_j___0: libc::c_uint = 0;
    let mut _hj_k___0: libc::c_uint = 0;
    let mut _hj_key___0: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _ha_bkt: libc::c_uint = 0;
    let mut _ha_head: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_bkt: libc::c_uint = 0;
    let mut _he_bkt_i: libc::c_uint = 0;
    let mut _he_thh: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_hh_nxt: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_new_buckets: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_newbkt: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: libc::c_uint = 0;
    let mut _uthash_hfstr_keylen___0: libc::c_uint = 0;
    let mut tmp___7: size_t = 0;
    let mut _hf_hashv___0: libc::c_uint = 0;
    let mut _hj_i___1: libc::c_uint = 0;
    let mut _hj_j___1: libc::c_uint = 0;
    let mut _hj_k___1: libc::c_uint = 0;
    let mut _hj_key___1: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut _hf_bkt___0: libc::c_uint = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _uthash_hastr_keylen___0: libc::c_uint = 0;
    let mut tmp___10: size_t = 0;
    let mut _ha_hashv___0: libc::c_uint = 0;
    let mut _hj_i___2: libc::c_uint = 0;
    let mut _hj_j___2: libc::c_uint = 0;
    let mut _hj_k___2: libc::c_uint = 0;
    let mut _hj_key___2: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _ha_bkt___0: libc::c_uint = 0;
    let mut _ha_head___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_bkt___0: libc::c_uint = 0;
    let mut _he_bkt_i___0: libc::c_uint = 0;
    let mut _he_thh___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_hh_nxt___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _he_new_buckets___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _he_newbkt___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: libc::c_int = 0;
    prev_caller = 0 as *mut libc::c_void as *mut callgrind_caller_t;
    i = (*udata).self_len - 1 as libc::c_int;
    while i >= 0 as libc::c_int {
        tmp = strlen(
            ((*udata).self_str[i as usize]).as_mut_ptr() as *const libc::c_char,
        );
        _uthash_hfstr_keylen = tmp as libc::c_uint;
        _hj_key = ((*udata).self_str[i as usize]).as_mut_ptr() as *const libc::c_uchar;
        _hf_hashv = 4276993775 as libc::c_uint;
        _hj_j = 2654435769 as libc::c_uint;
        _hj_i = _hj_j;
        _hj_k = _uthash_hfstr_keylen;
        while _hj_k >= 12 as libc::c_uint {
            _hj_i = _hj_i
                .wrapping_add(
                    (*_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                                << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                                << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                                << 24 as libc::c_int,
                        ),
                );
            _hj_j = _hj_j
                .wrapping_add(
                    (*_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                                << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                                << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                                << 24 as libc::c_int,
                        ),
                );
            _hf_hashv = _hf_hashv
                .wrapping_add(
                    (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                        .wrapping_add(
                            (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                                << 8 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                                << 16 as libc::c_int,
                        )
                        .wrapping_add(
                            (*_hj_key.offset(11 as libc::c_int as isize) as libc::c_uint)
                                << 24 as libc::c_int,
                        ),
                );
            _hj_i = _hj_i.wrapping_sub(_hj_j);
            _hj_i = _hj_i.wrapping_sub(_hf_hashv);
            _hj_i ^= _hf_hashv >> 13 as libc::c_int;
            _hj_j = _hj_j.wrapping_sub(_hf_hashv);
            _hj_j = _hj_j.wrapping_sub(_hj_i);
            _hj_j ^= _hj_i << 8 as libc::c_int;
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
            _hf_hashv ^= _hj_j >> 13 as libc::c_int;
            _hj_i = _hj_i.wrapping_sub(_hj_j);
            _hj_i = _hj_i.wrapping_sub(_hf_hashv);
            _hj_i ^= _hf_hashv >> 12 as libc::c_int;
            _hj_j = _hj_j.wrapping_sub(_hf_hashv);
            _hj_j = _hj_j.wrapping_sub(_hj_i);
            _hj_j ^= _hj_i << 16 as libc::c_int;
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
            _hf_hashv ^= _hj_j >> 5 as libc::c_int;
            _hj_i = _hj_i.wrapping_sub(_hj_j);
            _hj_i = _hj_i.wrapping_sub(_hf_hashv);
            _hj_i ^= _hf_hashv >> 3 as libc::c_int;
            _hj_j = _hj_j.wrapping_sub(_hf_hashv);
            _hj_j = _hj_j.wrapping_sub(_hj_i);
            _hj_j ^= _hj_i << 10 as libc::c_int;
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
            _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
            _hf_hashv ^= _hj_j >> 15 as libc::c_int;
            _hj_key = _hj_key.offset(12 as libc::c_int as isize);
            _hj_k = _hj_k.wrapping_sub(12 as libc::c_uint);
        }
        _hf_hashv = _hf_hashv.wrapping_add(_uthash_hfstr_keylen);
        let mut current_block_55: u64;
        match _hj_k {
            11 => {
                _hf_hashv = _hf_hashv
                    .wrapping_add(
                        (*_hj_key.offset(10 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_55 = 5547411220502753044;
            }
            10 => {
                current_block_55 = 5547411220502753044;
            }
            9 => {
                current_block_55 = 7046051612796912078;
            }
            8 => {
                current_block_55 = 2176324984557990713;
            }
            7 => {
                current_block_55 = 16751541006246249349;
            }
            6 => {
                current_block_55 = 2006354247379599535;
            }
            5 => {
                current_block_55 = 1255796057429864816;
            }
            4 => {
                current_block_55 = 3222845463133742107;
            }
            3 => {
                current_block_55 = 4055940048447470167;
            }
            2 => {
                current_block_55 = 9823556230498588751;
            }
            1 => {
                current_block_55 = 3009126938061302832;
            }
            _ => {
                current_block_55 = 7858101417678297991;
            }
        }
        match current_block_55 {
            5547411220502753044 => {
                _hf_hashv = _hf_hashv
                    .wrapping_add(
                        (*_hj_key.offset(9 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_55 = 7046051612796912078;
            }
            _ => {}
        }
        match current_block_55 {
            7046051612796912078 => {
                _hf_hashv = _hf_hashv
                    .wrapping_add(
                        (*_hj_key.offset(8 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_55 = 2176324984557990713;
            }
            _ => {}
        }
        match current_block_55 {
            2176324984557990713 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        (*_hj_key.offset(7 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_55 = 16751541006246249349;
            }
            _ => {}
        }
        match current_block_55 {
            16751541006246249349 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        (*_hj_key.offset(6 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_55 = 2006354247379599535;
            }
            _ => {}
        }
        match current_block_55 {
            2006354247379599535 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        (*_hj_key.offset(5 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_55 = 1255796057429864816;
            }
            _ => {}
        }
        match current_block_55 {
            1255796057429864816 => {
                _hj_j = _hj_j
                    .wrapping_add(
                        *_hj_key.offset(4 as libc::c_int as isize) as libc::c_uint,
                    );
                current_block_55 = 3222845463133742107;
            }
            _ => {}
        }
        match current_block_55 {
            3222845463133742107 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        (*_hj_key.offset(3 as libc::c_int as isize) as libc::c_uint)
                            << 24 as libc::c_int,
                    );
                current_block_55 = 4055940048447470167;
            }
            _ => {}
        }
        match current_block_55 {
            4055940048447470167 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        (*_hj_key.offset(2 as libc::c_int as isize) as libc::c_uint)
                            << 16 as libc::c_int,
                    );
                current_block_55 = 9823556230498588751;
            }
            _ => {}
        }
        match current_block_55 {
            9823556230498588751 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        (*_hj_key.offset(1 as libc::c_int as isize) as libc::c_uint)
                            << 8 as libc::c_int,
                    );
                current_block_55 = 3009126938061302832;
            }
            _ => {}
        }
        match current_block_55 {
            3009126938061302832 => {
                _hj_i = _hj_i
                    .wrapping_add(
                        *_hj_key.offset(0 as libc::c_int as isize) as libc::c_uint,
                    );
            }
            _ => {}
        }
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 13 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 8 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 13 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 12 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 16 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 5 as libc::c_int;
        _hj_i = _hj_i.wrapping_sub(_hj_j);
        _hj_i = _hj_i.wrapping_sub(_hf_hashv);
        _hj_i ^= _hf_hashv >> 3 as libc::c_int;
        _hj_j = _hj_j.wrapping_sub(_hf_hashv);
        _hj_j = _hj_j.wrapping_sub(_hj_i);
        _hj_j ^= _hj_i << 10 as libc::c_int;
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_i);
        _hf_hashv = _hf_hashv.wrapping_sub(_hj_j);
        _hf_hashv ^= _hj_j >> 15 as libc::c_int;
        caller = 0 as *mut libc::c_void as *mut callgrind_caller_t;
        if !((*udata).callers).is_null() {
            _hf_bkt = _hf_hashv
                & ((*(*(*udata).callers).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            if (*((*(*(*udata).callers).hh.tbl).buckets).offset(_hf_bkt as isize))
                .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                caller = ((*((*(*(*udata).callers).hh.tbl).buckets)
                    .offset(_hf_bkt as isize))
                    .hh_head as *mut libc::c_char)
                    .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut callgrind_caller_t;
            } else {
                caller = 0 as *mut libc::c_void as *mut callgrind_caller_t;
            }
            while caller as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*caller).hh.hashv == _hf_hashv {
                    if (*caller).hh.keylen == _uthash_hfstr_keylen {
                        tmp___0 = memcmp(
                            (*caller).hh.key as *const libc::c_void,
                            ((*udata).self_str[i as usize]).as_mut_ptr()
                                as *const libc::c_void,
                            _uthash_hfstr_keylen as size_t,
                        );
                        if tmp___0 == 0 as libc::c_int {
                            break;
                        }
                    }
                }
                if (*caller).hh.hh_next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    caller = ((*caller).hh.hh_next as *mut libc::c_char)
                        .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut callgrind_caller_t;
                } else {
                    caller = 0 as *mut libc::c_void as *mut callgrind_caller_t;
                }
            }
        }
        if caller.is_null() {
            tmp___1 = calloc(
                1 as libc::c_int as size_t,
                ::std::mem::size_of::<callgrind_caller_t>() as libc::c_ulong,
            );
            caller = tmp___1 as *mut callgrind_caller_t;
            strcpy(
                ((*caller).loc_str).as_mut_ptr(),
                ((*udata).self_str[i as usize]).as_mut_ptr() as *const libc::c_char,
            );
            memcpy(
                &mut (*caller).loc as *mut trace_loc_t as *mut libc::c_void,
                &mut *((*udata).self_0).as_mut_ptr().offset(i as isize)
                    as *mut trace_loc_t as *const libc::c_void,
                ::std::mem::size_of::<trace_loc_t>() as libc::c_ulong,
            );
            tmp___2 = strlen(((*caller).loc_str).as_mut_ptr() as *const libc::c_char);
            _uthash_hastr_keylen = tmp___2 as libc::c_uint;
            _hj_key___0 = &mut *((*caller).loc_str)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize) as *mut libc::c_char
                as *const libc::c_uchar;
            _ha_hashv = 4276993775 as libc::c_uint;
            _hj_j___0 = 2654435769 as libc::c_uint;
            _hj_i___0 = _hj_j___0;
            _hj_k___0 = _uthash_hastr_keylen;
            while _hj_k___0 >= 12 as libc::c_uint {
                _hj_i___0 = _hj_i___0
                    .wrapping_add(
                        (*_hj_key___0.offset(0 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___0.offset(1 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(2 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(3 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hj_j___0 = _hj_j___0
                    .wrapping_add(
                        (*_hj_key___0.offset(4 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___0.offset(5 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(6 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(7 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _ha_hashv = _ha_hashv
                    .wrapping_add(
                        (*_hj_key___0.offset(8 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___0.offset(9 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(10 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___0.offset(11 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
                _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
                _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
                _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
                _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
                _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
                _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
                _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
                _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
                _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
                _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
                _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
                _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
                _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
                _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
                _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
                _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
                _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
                _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
                _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
                _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
                _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
                _hj_key___0 = _hj_key___0.offset(12 as libc::c_int as isize);
                _hj_k___0 = _hj_k___0.wrapping_sub(12 as libc::c_uint);
            }
            _ha_hashv = _ha_hashv.wrapping_add(_uthash_hastr_keylen);
            let mut current_block_167: u64;
            match _hj_k___0 {
                11 => {
                    _ha_hashv = _ha_hashv
                        .wrapping_add(
                            (*_hj_key___0.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_167 = 5459393859742515509;
                }
                10 => {
                    current_block_167 = 5459393859742515509;
                }
                9 => {
                    current_block_167 = 12552397485702490331;
                }
                8 => {
                    current_block_167 = 17430348988689004741;
                }
                7 => {
                    current_block_167 = 15468129706590261270;
                }
                6 => {
                    current_block_167 = 3183050536898567390;
                }
                5 => {
                    current_block_167 = 4540527903101587044;
                }
                4 => {
                    current_block_167 = 10148983328973557304;
                }
                3 => {
                    current_block_167 = 5905263930243526765;
                }
                2 => {
                    current_block_167 = 6376263998049852202;
                }
                1 => {
                    current_block_167 = 14734432426211419710;
                }
                _ => {
                    current_block_167 = 3990161529967994542;
                }
            }
            match current_block_167 {
                5459393859742515509 => {
                    _ha_hashv = _ha_hashv
                        .wrapping_add(
                            (*_hj_key___0.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_167 = 12552397485702490331;
                }
                _ => {}
            }
            match current_block_167 {
                12552397485702490331 => {
                    _ha_hashv = _ha_hashv
                        .wrapping_add(
                            (*_hj_key___0.offset(8 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_167 = 17430348988689004741;
                }
                _ => {}
            }
            match current_block_167 {
                17430348988689004741 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            (*_hj_key___0.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_167 = 15468129706590261270;
                }
                _ => {}
            }
            match current_block_167 {
                15468129706590261270 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            (*_hj_key___0.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_167 = 3183050536898567390;
                }
                _ => {}
            }
            match current_block_167 {
                3183050536898567390 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            (*_hj_key___0.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_167 = 4540527903101587044;
                }
                _ => {}
            }
            match current_block_167 {
                4540527903101587044 => {
                    _hj_j___0 = _hj_j___0
                        .wrapping_add(
                            *_hj_key___0.offset(4 as libc::c_int as isize)
                                as libc::c_uint,
                        );
                    current_block_167 = 10148983328973557304;
                }
                _ => {}
            }
            match current_block_167 {
                10148983328973557304 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            (*_hj_key___0.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_167 = 5905263930243526765;
                }
                _ => {}
            }
            match current_block_167 {
                5905263930243526765 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            (*_hj_key___0.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_167 = 6376263998049852202;
                }
                _ => {}
            }
            match current_block_167 {
                6376263998049852202 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            (*_hj_key___0.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_167 = 14734432426211419710;
                }
                _ => {}
            }
            match current_block_167 {
                14734432426211419710 => {
                    _hj_i___0 = _hj_i___0
                        .wrapping_add(
                            *_hj_key___0.offset(0 as libc::c_int as isize)
                                as libc::c_uint,
                        );
                }
                _ => {}
            }
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 13 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 8 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 13 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 12 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 16 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 5 as libc::c_int;
            _hj_i___0 = _hj_i___0.wrapping_sub(_hj_j___0);
            _hj_i___0 = _hj_i___0.wrapping_sub(_ha_hashv);
            _hj_i___0 ^= _ha_hashv >> 3 as libc::c_int;
            _hj_j___0 = _hj_j___0.wrapping_sub(_ha_hashv);
            _hj_j___0 = _hj_j___0.wrapping_sub(_hj_i___0);
            _hj_j___0 ^= _hj_i___0 << 10 as libc::c_int;
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_i___0);
            _ha_hashv = _ha_hashv.wrapping_sub(_hj_j___0);
            _ha_hashv ^= _hj_j___0 >> 15 as libc::c_int;
            (*caller).hh.hashv = _ha_hashv;
            (*caller)
                .hh
                .key = &mut *((*caller).loc_str)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize) as *mut libc::c_char
                as *mut libc::c_void;
            (*caller).hh.keylen = _uthash_hastr_keylen;
            if ((*udata).callers).is_null() {
                (*caller).hh.next = 0 as *mut libc::c_void;
                (*caller).hh.prev = 0 as *mut libc::c_void;
                tmp___3 = malloc(
                    ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                );
                (*caller).hh.tbl = tmp___3 as *mut UT_hash_table;
                if ((*caller).hh.tbl).is_null() {
                    exit(-(1 as libc::c_int));
                } else {
                    memset(
                        (*caller).hh.tbl as *mut libc::c_void,
                        '\u{0}' as i32,
                        ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                    );
                    (*(*caller).hh.tbl).tail = &mut (*caller).hh;
                    (*(*caller).hh.tbl).num_buckets = 32 as libc::c_uint;
                    (*(*caller).hh.tbl).log2_num_buckets = 5 as libc::c_uint;
                    (*(*caller).hh.tbl)
                        .hho = (&mut (*caller).hh as *mut UT_hash_handle
                        as *mut libc::c_char)
                        .offset_from(caller as *mut libc::c_char) as libc::c_long;
                    tmp___4 = malloc(
                        (32 as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                    (*(*caller).hh.tbl).buckets = tmp___4 as *mut UT_hash_bucket;
                    (*(*caller).hh.tbl).signature = 2685476833 as libc::c_uint;
                    if ((*(*caller).hh.tbl).buckets).is_null() {
                        exit(-(1 as libc::c_int));
                    } else {
                        memset(
                            (*(*caller).hh.tbl).buckets as *mut libc::c_void,
                            '\u{0}' as i32,
                            (32 as libc::c_ulong)
                                .wrapping_mul(
                                    ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                ),
                        );
                    }
                }
                (*udata).callers = caller;
            } else {
                (*caller).hh.tbl = (*(*udata).callers).hh.tbl;
                (*caller).hh.next = 0 as *mut libc::c_void;
                (*caller)
                    .hh
                    .prev = ((*(*(*udata).callers).hh.tbl).tail as *mut libc::c_char)
                    .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                    as *mut libc::c_void;
                (*(*(*(*udata).callers).hh.tbl).tail).next = caller as *mut libc::c_void;
                (*(*(*udata).callers).hh.tbl).tail = &mut (*caller).hh;
            }
            (*(*(*udata).callers).hh.tbl)
                .num_items = ((*(*(*udata).callers).hh.tbl).num_items).wrapping_add(1);
            _ha_bkt = _ha_hashv
                & ((*(*(*udata).callers).hh.tbl).num_buckets)
                    .wrapping_sub(1 as libc::c_uint);
            _ha_head = ((*(*(*udata).callers).hh.tbl).buckets).offset(_ha_bkt as isize);
            (*_ha_head).count = ((*_ha_head).count).wrapping_add(1);
            (*caller).hh.hh_next = (*_ha_head).hh_head;
            (*caller).hh.hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
            if (*_ha_head).hh_head as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                (*(*_ha_head).hh_head).hh_prev = &mut (*caller).hh;
            }
            (*_ha_head).hh_head = &mut (*caller).hh;
            if (*_ha_head).count
                >= ((*_ha_head).expand_mult)
                    .wrapping_add(1 as libc::c_uint)
                    .wrapping_mul(10 as libc::c_uint)
            {
                if (*(*caller).hh.tbl).noexpand == 0 {
                    tmp___5 = malloc(
                        (2 as libc::c_ulong)
                            .wrapping_mul(
                                (*(*caller).hh.tbl).num_buckets as libc::c_ulong,
                            )
                            .wrapping_mul(
                                ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                            ),
                    );
                    _he_new_buckets = tmp___5 as *mut UT_hash_bucket;
                    if _he_new_buckets.is_null() {
                        exit(-(1 as libc::c_int));
                    } else {
                        memset(
                            _he_new_buckets as *mut libc::c_void,
                            '\u{0}' as i32,
                            (2 as libc::c_ulong)
                                .wrapping_mul(
                                    (*(*caller).hh.tbl).num_buckets as libc::c_ulong,
                                )
                                .wrapping_mul(
                                    ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                ),
                        );
                        if (*(*caller).hh.tbl).num_items
                            & ((*(*caller).hh.tbl).num_buckets)
                                .wrapping_mul(2 as libc::c_uint)
                                .wrapping_sub(1 as libc::c_uint) != 0 as libc::c_uint
                        {
                            tmp___6 = 1 as libc::c_uint;
                        } else {
                            tmp___6 = 0 as libc::c_uint;
                        }
                        (*(*caller).hh.tbl)
                            .ideal_chain_maxlen = ((*(*caller).hh.tbl).num_items
                            >> ((*(*caller).hh.tbl).log2_num_buckets)
                                .wrapping_add(1 as libc::c_uint))
                            .wrapping_add(tmp___6);
                        (*(*caller).hh.tbl).nonideal_items = 0 as libc::c_uint;
                        _he_bkt_i = 0 as libc::c_uint;
                        while _he_bkt_i < (*(*caller).hh.tbl).num_buckets {
                            _he_thh = (*((*(*caller).hh.tbl).buckets)
                                .offset(_he_bkt_i as isize))
                                .hh_head;
                            while _he_thh as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                _he_hh_nxt = (*_he_thh).hh_next;
                                _he_bkt = (*_he_thh).hashv
                                    & ((*(*caller).hh.tbl).num_buckets)
                                        .wrapping_mul(2 as libc::c_uint)
                                        .wrapping_sub(1 as libc::c_uint);
                                _he_newbkt = _he_new_buckets.offset(_he_bkt as isize);
                                (*_he_newbkt).count = ((*_he_newbkt).count).wrapping_add(1);
                                if (*_he_newbkt).count
                                    > (*(*caller).hh.tbl).ideal_chain_maxlen
                                {
                                    (*(*caller).hh.tbl)
                                        .nonideal_items = ((*(*caller).hh.tbl).nonideal_items)
                                        .wrapping_add(1);
                                    (*_he_newbkt)
                                        .expand_mult = ((*_he_newbkt).count)
                                        .wrapping_div((*(*caller).hh.tbl).ideal_chain_maxlen);
                                }
                                (*_he_thh)
                                    .hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                (*_he_thh).hh_next = (*_he_newbkt).hh_head;
                                if (*_he_newbkt).hh_head as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    (*(*_he_newbkt).hh_head).hh_prev = _he_thh;
                                }
                                (*_he_newbkt).hh_head = _he_thh;
                                _he_thh = _he_hh_nxt;
                            }
                            _he_bkt_i = _he_bkt_i.wrapping_add(1);
                        }
                        free((*(*caller).hh.tbl).buckets as *mut libc::c_void);
                        (*(*caller).hh.tbl)
                            .num_buckets = ((*(*caller).hh.tbl).num_buckets)
                            .wrapping_mul(2 as libc::c_uint);
                        (*(*caller).hh.tbl)
                            .log2_num_buckets = ((*(*caller).hh.tbl).log2_num_buckets)
                            .wrapping_add(1);
                        (*(*caller).hh.tbl).buckets = _he_new_buckets;
                        if (*(*caller).hh.tbl).nonideal_items
                            > (*(*caller).hh.tbl).num_items >> 1 as libc::c_int
                        {
                            (*(*caller).hh.tbl)
                                .ineff_expands = ((*(*caller).hh.tbl).ineff_expands)
                                .wrapping_add(1);
                        } else {
                            (*(*caller).hh.tbl).ineff_expands = 0 as libc::c_uint;
                        }
                        if (*(*caller).hh.tbl).ineff_expands > 1 as libc::c_uint {
                            (*(*caller).hh.tbl).noexpand = 1 as libc::c_uint;
                        }
                    }
                }
            }
        }
        if i == 0 as libc::c_int {
            (*caller).exclusive = ((*caller).exclusive).wrapping_add(1);
        }
        if !prev_caller.is_null() {
            tmp___7 = strlen(
                ((*udata).self_str[i as usize]).as_mut_ptr() as *const libc::c_char,
            );
            _uthash_hfstr_keylen___0 = tmp___7 as libc::c_uint;
            _hj_key___1 = ((*udata).self_str[i as usize]).as_mut_ptr()
                as *const libc::c_uchar;
            _hf_hashv___0 = 4276993775 as libc::c_uint;
            _hj_j___1 = 2654435769 as libc::c_uint;
            _hj_i___1 = _hj_j___1;
            _hj_k___1 = _uthash_hfstr_keylen___0;
            while _hj_k___1 >= 12 as libc::c_uint {
                _hj_i___1 = _hj_i___1
                    .wrapping_add(
                        (*_hj_key___1.offset(0 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___1.offset(1 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___1.offset(2 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___1.offset(3 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hj_j___1 = _hj_j___1
                    .wrapping_add(
                        (*_hj_key___1.offset(4 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___1.offset(5 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___1.offset(6 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___1.offset(7 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hf_hashv___0 = _hf_hashv___0
                    .wrapping_add(
                        (*_hj_key___1.offset(8 as libc::c_int as isize) as libc::c_uint)
                            .wrapping_add(
                                (*_hj_key___1.offset(9 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___1.offset(10 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            )
                            .wrapping_add(
                                (*_hj_key___1.offset(11 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            ),
                    );
                _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
                _hj_i___1 = _hj_i___1.wrapping_sub(_hf_hashv___0);
                _hj_i___1 ^= _hf_hashv___0 >> 13 as libc::c_int;
                _hj_j___1 = _hj_j___1.wrapping_sub(_hf_hashv___0);
                _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
                _hj_j___1 ^= _hj_i___1 << 8 as libc::c_int;
                _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___1);
                _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___1);
                _hf_hashv___0 ^= _hj_j___1 >> 13 as libc::c_int;
                _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
                _hj_i___1 = _hj_i___1.wrapping_sub(_hf_hashv___0);
                _hj_i___1 ^= _hf_hashv___0 >> 12 as libc::c_int;
                _hj_j___1 = _hj_j___1.wrapping_sub(_hf_hashv___0);
                _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
                _hj_j___1 ^= _hj_i___1 << 16 as libc::c_int;
                _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___1);
                _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___1);
                _hf_hashv___0 ^= _hj_j___1 >> 5 as libc::c_int;
                _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
                _hj_i___1 = _hj_i___1.wrapping_sub(_hf_hashv___0);
                _hj_i___1 ^= _hf_hashv___0 >> 3 as libc::c_int;
                _hj_j___1 = _hj_j___1.wrapping_sub(_hf_hashv___0);
                _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
                _hj_j___1 ^= _hj_i___1 << 10 as libc::c_int;
                _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___1);
                _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___1);
                _hf_hashv___0 ^= _hj_j___1 >> 15 as libc::c_int;
                _hj_key___1 = _hj_key___1.offset(12 as libc::c_int as isize);
                _hj_k___1 = _hj_k___1.wrapping_sub(12 as libc::c_uint);
            }
            _hf_hashv___0 = _hf_hashv___0.wrapping_add(_uthash_hfstr_keylen___0);
            let mut current_block_363: u64;
            match _hj_k___1 {
                11 => {
                    _hf_hashv___0 = _hf_hashv___0
                        .wrapping_add(
                            (*_hj_key___1.offset(10 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_363 = 4283374020190744998;
                }
                10 => {
                    current_block_363 = 4283374020190744998;
                }
                9 => {
                    current_block_363 = 8840345964803798354;
                }
                8 => {
                    current_block_363 = 14166695088034427055;
                }
                7 => {
                    current_block_363 = 1792139352321279456;
                }
                6 => {
                    current_block_363 = 11824521626931513778;
                }
                5 => {
                    current_block_363 = 6758577565518194179;
                }
                4 => {
                    current_block_363 = 3050222434331557517;
                }
                3 => {
                    current_block_363 = 11010064789467729324;
                }
                2 => {
                    current_block_363 = 15850528357756641372;
                }
                1 => {
                    current_block_363 = 6629665842716869510;
                }
                _ => {
                    current_block_363 = 11366682102430008042;
                }
            }
            match current_block_363 {
                4283374020190744998 => {
                    _hf_hashv___0 = _hf_hashv___0
                        .wrapping_add(
                            (*_hj_key___1.offset(9 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_363 = 8840345964803798354;
                }
                _ => {}
            }
            match current_block_363 {
                8840345964803798354 => {
                    _hf_hashv___0 = _hf_hashv___0
                        .wrapping_add(
                            (*_hj_key___1.offset(8 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_363 = 14166695088034427055;
                }
                _ => {}
            }
            match current_block_363 {
                14166695088034427055 => {
                    _hj_j___1 = _hj_j___1
                        .wrapping_add(
                            (*_hj_key___1.offset(7 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_363 = 1792139352321279456;
                }
                _ => {}
            }
            match current_block_363 {
                1792139352321279456 => {
                    _hj_j___1 = _hj_j___1
                        .wrapping_add(
                            (*_hj_key___1.offset(6 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_363 = 11824521626931513778;
                }
                _ => {}
            }
            match current_block_363 {
                11824521626931513778 => {
                    _hj_j___1 = _hj_j___1
                        .wrapping_add(
                            (*_hj_key___1.offset(5 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_363 = 6758577565518194179;
                }
                _ => {}
            }
            match current_block_363 {
                6758577565518194179 => {
                    _hj_j___1 = _hj_j___1
                        .wrapping_add(
                            *_hj_key___1.offset(4 as libc::c_int as isize)
                                as libc::c_uint,
                        );
                    current_block_363 = 3050222434331557517;
                }
                _ => {}
            }
            match current_block_363 {
                3050222434331557517 => {
                    _hj_i___1 = _hj_i___1
                        .wrapping_add(
                            (*_hj_key___1.offset(3 as libc::c_int as isize)
                                as libc::c_uint) << 24 as libc::c_int,
                        );
                    current_block_363 = 11010064789467729324;
                }
                _ => {}
            }
            match current_block_363 {
                11010064789467729324 => {
                    _hj_i___1 = _hj_i___1
                        .wrapping_add(
                            (*_hj_key___1.offset(2 as libc::c_int as isize)
                                as libc::c_uint) << 16 as libc::c_int,
                        );
                    current_block_363 = 15850528357756641372;
                }
                _ => {}
            }
            match current_block_363 {
                15850528357756641372 => {
                    _hj_i___1 = _hj_i___1
                        .wrapping_add(
                            (*_hj_key___1.offset(1 as libc::c_int as isize)
                                as libc::c_uint) << 8 as libc::c_int,
                        );
                    current_block_363 = 6629665842716869510;
                }
                _ => {}
            }
            match current_block_363 {
                6629665842716869510 => {
                    _hj_i___1 = _hj_i___1
                        .wrapping_add(
                            *_hj_key___1.offset(0 as libc::c_int as isize)
                                as libc::c_uint,
                        );
                }
                _ => {}
            }
            _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
            _hj_i___1 = _hj_i___1.wrapping_sub(_hf_hashv___0);
            _hj_i___1 ^= _hf_hashv___0 >> 13 as libc::c_int;
            _hj_j___1 = _hj_j___1.wrapping_sub(_hf_hashv___0);
            _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
            _hj_j___1 ^= _hj_i___1 << 8 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___1);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___1);
            _hf_hashv___0 ^= _hj_j___1 >> 13 as libc::c_int;
            _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
            _hj_i___1 = _hj_i___1.wrapping_sub(_hf_hashv___0);
            _hj_i___1 ^= _hf_hashv___0 >> 12 as libc::c_int;
            _hj_j___1 = _hj_j___1.wrapping_sub(_hf_hashv___0);
            _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
            _hj_j___1 ^= _hj_i___1 << 16 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___1);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___1);
            _hf_hashv___0 ^= _hj_j___1 >> 5 as libc::c_int;
            _hj_i___1 = _hj_i___1.wrapping_sub(_hj_j___1);
            _hj_i___1 = _hj_i___1.wrapping_sub(_hf_hashv___0);
            _hj_i___1 ^= _hf_hashv___0 >> 3 as libc::c_int;
            _hj_j___1 = _hj_j___1.wrapping_sub(_hf_hashv___0);
            _hj_j___1 = _hj_j___1.wrapping_sub(_hj_i___1);
            _hj_j___1 ^= _hj_i___1 << 10 as libc::c_int;
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_i___1);
            _hf_hashv___0 = _hf_hashv___0.wrapping_sub(_hj_j___1);
            _hf_hashv___0 ^= _hj_j___1 >> 15 as libc::c_int;
            callee = 0 as *mut libc::c_void as *mut callgrind_callee_t;
            if !((*prev_caller).callees).is_null() {
                _hf_bkt___0 = _hf_hashv___0
                    & ((*(*(*prev_caller).callees).hh.tbl).num_buckets)
                        .wrapping_sub(1 as libc::c_uint);
                if (*((*(*(*prev_caller).callees).hh.tbl).buckets)
                    .offset(_hf_bkt___0 as isize))
                    .hh_head as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
                {
                    callee = ((*((*(*(*prev_caller).callees).hh.tbl).buckets)
                        .offset(_hf_bkt___0 as isize))
                        .hh_head as *mut libc::c_char)
                        .offset(-((*(*(*prev_caller).callees).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut callgrind_callee_t;
                } else {
                    callee = 0 as *mut libc::c_void as *mut callgrind_callee_t;
                }
                while callee as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
                {
                    if (*callee).hh.hashv == _hf_hashv___0 {
                        if (*callee).hh.keylen == _uthash_hfstr_keylen___0 {
                            tmp___8 = memcmp(
                                (*callee).hh.key as *const libc::c_void,
                                ((*udata).self_str[i as usize]).as_mut_ptr()
                                    as *const libc::c_void,
                                _uthash_hfstr_keylen___0 as size_t,
                            );
                            if tmp___8 == 0 as libc::c_int {
                                break;
                            }
                        }
                    }
                    if (*callee).hh.hh_next as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        callee = ((*callee).hh.hh_next as *mut libc::c_char)
                            .offset(-((*(*(*prev_caller).callees).hh.tbl).hho as isize))
                            as *mut libc::c_void as *mut callgrind_callee_t;
                    } else {
                        callee = 0 as *mut libc::c_void as *mut callgrind_callee_t;
                    }
                }
            }
            if callee.is_null() {
                tmp___9 = calloc(
                    1 as libc::c_int as size_t,
                    ::std::mem::size_of::<callgrind_callee_t>() as libc::c_ulong,
                );
                callee = tmp___9 as *mut callgrind_callee_t;
                strcpy(
                    ((*callee).loc_str).as_mut_ptr(),
                    ((*udata).self_str[i as usize]).as_mut_ptr() as *const libc::c_char,
                );
                memcpy(
                    &mut (*callee).loc as *mut trace_loc_t as *mut libc::c_void,
                    &mut *((*udata).self_0).as_mut_ptr().offset(i as isize)
                        as *mut trace_loc_t as *const libc::c_void,
                    ::std::mem::size_of::<trace_loc_t>() as libc::c_ulong,
                );
                tmp___10 = strlen(
                    ((*callee).loc_str).as_mut_ptr() as *const libc::c_char,
                );
                _uthash_hastr_keylen___0 = tmp___10 as libc::c_uint;
                _hj_key___2 = &mut *((*callee).loc_str)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut libc::c_char
                    as *const libc::c_uchar;
                _ha_hashv___0 = 4276993775 as libc::c_uint;
                _hj_j___2 = 2654435769 as libc::c_uint;
                _hj_i___2 = _hj_j___2;
                _hj_k___2 = _uthash_hastr_keylen___0;
                while _hj_k___2 >= 12 as libc::c_uint {
                    _hj_i___2 = _hj_i___2
                        .wrapping_add(
                            (*_hj_key___2.offset(0 as libc::c_int as isize)
                                as libc::c_uint)
                                .wrapping_add(
                                    (*_hj_key___2.offset(1 as libc::c_int as isize)
                                        as libc::c_uint) << 8 as libc::c_int,
                                )
                                .wrapping_add(
                                    (*_hj_key___2.offset(2 as libc::c_int as isize)
                                        as libc::c_uint) << 16 as libc::c_int,
                                )
                                .wrapping_add(
                                    (*_hj_key___2.offset(3 as libc::c_int as isize)
                                        as libc::c_uint) << 24 as libc::c_int,
                                ),
                        );
                    _hj_j___2 = _hj_j___2
                        .wrapping_add(
                            (*_hj_key___2.offset(4 as libc::c_int as isize)
                                as libc::c_uint)
                                .wrapping_add(
                                    (*_hj_key___2.offset(5 as libc::c_int as isize)
                                        as libc::c_uint) << 8 as libc::c_int,
                                )
                                .wrapping_add(
                                    (*_hj_key___2.offset(6 as libc::c_int as isize)
                                        as libc::c_uint) << 16 as libc::c_int,
                                )
                                .wrapping_add(
                                    (*_hj_key___2.offset(7 as libc::c_int as isize)
                                        as libc::c_uint) << 24 as libc::c_int,
                                ),
                        );
                    _ha_hashv___0 = _ha_hashv___0
                        .wrapping_add(
                            (*_hj_key___2.offset(8 as libc::c_int as isize)
                                as libc::c_uint)
                                .wrapping_add(
                                    (*_hj_key___2.offset(9 as libc::c_int as isize)
                                        as libc::c_uint) << 8 as libc::c_int,
                                )
                                .wrapping_add(
                                    (*_hj_key___2.offset(10 as libc::c_int as isize)
                                        as libc::c_uint) << 16 as libc::c_int,
                                )
                                .wrapping_add(
                                    (*_hj_key___2.offset(11 as libc::c_int as isize)
                                        as libc::c_uint) << 24 as libc::c_int,
                                ),
                        );
                    _hj_i___2 = _hj_i___2.wrapping_sub(_hj_j___2);
                    _hj_i___2 = _hj_i___2.wrapping_sub(_ha_hashv___0);
                    _hj_i___2 ^= _ha_hashv___0 >> 13 as libc::c_int;
                    _hj_j___2 = _hj_j___2.wrapping_sub(_ha_hashv___0);
                    _hj_j___2 = _hj_j___2.wrapping_sub(_hj_i___2);
                    _hj_j___2 ^= _hj_i___2 << 8 as libc::c_int;
                    _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___2);
                    _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___2);
                    _ha_hashv___0 ^= _hj_j___2 >> 13 as libc::c_int;
                    _hj_i___2 = _hj_i___2.wrapping_sub(_hj_j___2);
                    _hj_i___2 = _hj_i___2.wrapping_sub(_ha_hashv___0);
                    _hj_i___2 ^= _ha_hashv___0 >> 12 as libc::c_int;
                    _hj_j___2 = _hj_j___2.wrapping_sub(_ha_hashv___0);
                    _hj_j___2 = _hj_j___2.wrapping_sub(_hj_i___2);
                    _hj_j___2 ^= _hj_i___2 << 16 as libc::c_int;
                    _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___2);
                    _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___2);
                    _ha_hashv___0 ^= _hj_j___2 >> 5 as libc::c_int;
                    _hj_i___2 = _hj_i___2.wrapping_sub(_hj_j___2);
                    _hj_i___2 = _hj_i___2.wrapping_sub(_ha_hashv___0);
                    _hj_i___2 ^= _ha_hashv___0 >> 3 as libc::c_int;
                    _hj_j___2 = _hj_j___2.wrapping_sub(_ha_hashv___0);
                    _hj_j___2 = _hj_j___2.wrapping_sub(_hj_i___2);
                    _hj_j___2 ^= _hj_i___2 << 10 as libc::c_int;
                    _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___2);
                    _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___2);
                    _ha_hashv___0 ^= _hj_j___2 >> 15 as libc::c_int;
                    _hj_key___2 = _hj_key___2.offset(12 as libc::c_int as isize);
                    _hj_k___2 = _hj_k___2.wrapping_sub(12 as libc::c_uint);
                }
                _ha_hashv___0 = _ha_hashv___0.wrapping_add(_uthash_hastr_keylen___0);
                let mut current_block_475: u64;
                match _hj_k___2 {
                    11 => {
                        _ha_hashv___0 = _ha_hashv___0
                            .wrapping_add(
                                (*_hj_key___2.offset(10 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            );
                        current_block_475 = 10411149913126971825;
                    }
                    10 => {
                        current_block_475 = 10411149913126971825;
                    }
                    9 => {
                        current_block_475 = 10447270912020021144;
                    }
                    8 => {
                        current_block_475 = 8023763168208648047;
                    }
                    7 => {
                        current_block_475 = 870530962823179070;
                    }
                    6 => {
                        current_block_475 = 16540515049681533952;
                    }
                    5 => {
                        current_block_475 = 16519629343284758150;
                    }
                    4 => {
                        current_block_475 = 2550907748557608188;
                    }
                    3 => {
                        current_block_475 = 18272264006209492077;
                    }
                    2 => {
                        current_block_475 = 1626968685482578567;
                    }
                    1 => {
                        current_block_475 = 12130255237546864359;
                    }
                    _ => {
                        current_block_475 = 11224840739733357990;
                    }
                }
                match current_block_475 {
                    10411149913126971825 => {
                        _ha_hashv___0 = _ha_hashv___0
                            .wrapping_add(
                                (*_hj_key___2.offset(9 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            );
                        current_block_475 = 10447270912020021144;
                    }
                    _ => {}
                }
                match current_block_475 {
                    10447270912020021144 => {
                        _ha_hashv___0 = _ha_hashv___0
                            .wrapping_add(
                                (*_hj_key___2.offset(8 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            );
                        current_block_475 = 8023763168208648047;
                    }
                    _ => {}
                }
                match current_block_475 {
                    8023763168208648047 => {
                        _hj_j___2 = _hj_j___2
                            .wrapping_add(
                                (*_hj_key___2.offset(7 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            );
                        current_block_475 = 870530962823179070;
                    }
                    _ => {}
                }
                match current_block_475 {
                    870530962823179070 => {
                        _hj_j___2 = _hj_j___2
                            .wrapping_add(
                                (*_hj_key___2.offset(6 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            );
                        current_block_475 = 16540515049681533952;
                    }
                    _ => {}
                }
                match current_block_475 {
                    16540515049681533952 => {
                        _hj_j___2 = _hj_j___2
                            .wrapping_add(
                                (*_hj_key___2.offset(5 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            );
                        current_block_475 = 16519629343284758150;
                    }
                    _ => {}
                }
                match current_block_475 {
                    16519629343284758150 => {
                        _hj_j___2 = _hj_j___2
                            .wrapping_add(
                                *_hj_key___2.offset(4 as libc::c_int as isize)
                                    as libc::c_uint,
                            );
                        current_block_475 = 2550907748557608188;
                    }
                    _ => {}
                }
                match current_block_475 {
                    2550907748557608188 => {
                        _hj_i___2 = _hj_i___2
                            .wrapping_add(
                                (*_hj_key___2.offset(3 as libc::c_int as isize)
                                    as libc::c_uint) << 24 as libc::c_int,
                            );
                        current_block_475 = 18272264006209492077;
                    }
                    _ => {}
                }
                match current_block_475 {
                    18272264006209492077 => {
                        _hj_i___2 = _hj_i___2
                            .wrapping_add(
                                (*_hj_key___2.offset(2 as libc::c_int as isize)
                                    as libc::c_uint) << 16 as libc::c_int,
                            );
                        current_block_475 = 1626968685482578567;
                    }
                    _ => {}
                }
                match current_block_475 {
                    1626968685482578567 => {
                        _hj_i___2 = _hj_i___2
                            .wrapping_add(
                                (*_hj_key___2.offset(1 as libc::c_int as isize)
                                    as libc::c_uint) << 8 as libc::c_int,
                            );
                        current_block_475 = 12130255237546864359;
                    }
                    _ => {}
                }
                match current_block_475 {
                    12130255237546864359 => {
                        _hj_i___2 = _hj_i___2
                            .wrapping_add(
                                *_hj_key___2.offset(0 as libc::c_int as isize)
                                    as libc::c_uint,
                            );
                    }
                    _ => {}
                }
                _hj_i___2 = _hj_i___2.wrapping_sub(_hj_j___2);
                _hj_i___2 = _hj_i___2.wrapping_sub(_ha_hashv___0);
                _hj_i___2 ^= _ha_hashv___0 >> 13 as libc::c_int;
                _hj_j___2 = _hj_j___2.wrapping_sub(_ha_hashv___0);
                _hj_j___2 = _hj_j___2.wrapping_sub(_hj_i___2);
                _hj_j___2 ^= _hj_i___2 << 8 as libc::c_int;
                _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___2);
                _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___2);
                _ha_hashv___0 ^= _hj_j___2 >> 13 as libc::c_int;
                _hj_i___2 = _hj_i___2.wrapping_sub(_hj_j___2);
                _hj_i___2 = _hj_i___2.wrapping_sub(_ha_hashv___0);
                _hj_i___2 ^= _ha_hashv___0 >> 12 as libc::c_int;
                _hj_j___2 = _hj_j___2.wrapping_sub(_ha_hashv___0);
                _hj_j___2 = _hj_j___2.wrapping_sub(_hj_i___2);
                _hj_j___2 ^= _hj_i___2 << 16 as libc::c_int;
                _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___2);
                _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___2);
                _ha_hashv___0 ^= _hj_j___2 >> 5 as libc::c_int;
                _hj_i___2 = _hj_i___2.wrapping_sub(_hj_j___2);
                _hj_i___2 = _hj_i___2.wrapping_sub(_ha_hashv___0);
                _hj_i___2 ^= _ha_hashv___0 >> 3 as libc::c_int;
                _hj_j___2 = _hj_j___2.wrapping_sub(_ha_hashv___0);
                _hj_j___2 = _hj_j___2.wrapping_sub(_hj_i___2);
                _hj_j___2 ^= _hj_i___2 << 10 as libc::c_int;
                _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_i___2);
                _ha_hashv___0 = _ha_hashv___0.wrapping_sub(_hj_j___2);
                _ha_hashv___0 ^= _hj_j___2 >> 15 as libc::c_int;
                (*callee).hh.hashv = _ha_hashv___0;
                (*callee)
                    .hh
                    .key = &mut *((*callee).loc_str)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut libc::c_char
                    as *mut libc::c_void;
                (*callee).hh.keylen = _uthash_hastr_keylen___0;
                if ((*prev_caller).callees).is_null() {
                    (*callee).hh.next = 0 as *mut libc::c_void;
                    (*callee).hh.prev = 0 as *mut libc::c_void;
                    tmp___11 = malloc(
                        ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                    );
                    (*callee).hh.tbl = tmp___11 as *mut UT_hash_table;
                    if ((*callee).hh.tbl).is_null() {
                        exit(-(1 as libc::c_int));
                    } else {
                        memset(
                            (*callee).hh.tbl as *mut libc::c_void,
                            '\u{0}' as i32,
                            ::std::mem::size_of::<UT_hash_table>() as libc::c_ulong,
                        );
                        (*(*callee).hh.tbl).tail = &mut (*callee).hh;
                        (*(*callee).hh.tbl).num_buckets = 32 as libc::c_uint;
                        (*(*callee).hh.tbl).log2_num_buckets = 5 as libc::c_uint;
                        (*(*callee).hh.tbl)
                            .hho = (&mut (*callee).hh as *mut UT_hash_handle
                            as *mut libc::c_char)
                            .offset_from(callee as *mut libc::c_char) as libc::c_long;
                        tmp___12 = malloc(
                            (32 as libc::c_ulong)
                                .wrapping_mul(
                                    ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                ),
                        );
                        (*(*callee).hh.tbl).buckets = tmp___12 as *mut UT_hash_bucket;
                        (*(*callee).hh.tbl).signature = 2685476833 as libc::c_uint;
                        if ((*(*callee).hh.tbl).buckets).is_null() {
                            exit(-(1 as libc::c_int));
                        } else {
                            memset(
                                (*(*callee).hh.tbl).buckets as *mut libc::c_void,
                                '\u{0}' as i32,
                                (32 as libc::c_ulong)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                    ),
                            );
                        }
                    }
                    (*prev_caller).callees = callee;
                } else {
                    (*callee).hh.tbl = (*(*prev_caller).callees).hh.tbl;
                    (*callee).hh.next = 0 as *mut libc::c_void;
                    (*callee)
                        .hh
                        .prev = ((*(*(*prev_caller).callees).hh.tbl).tail
                        as *mut libc::c_char)
                        .offset(-((*(*(*prev_caller).callees).hh.tbl).hho as isize))
                        as *mut libc::c_void;
                    (*(*(*(*prev_caller).callees).hh.tbl).tail)
                        .next = callee as *mut libc::c_void;
                    (*(*(*prev_caller).callees).hh.tbl).tail = &mut (*callee).hh;
                }
                (*(*(*prev_caller).callees).hh.tbl)
                    .num_items = ((*(*(*prev_caller).callees).hh.tbl).num_items)
                    .wrapping_add(1);
                _ha_bkt___0 = _ha_hashv___0
                    & ((*(*(*prev_caller).callees).hh.tbl).num_buckets)
                        .wrapping_sub(1 as libc::c_uint);
                _ha_head___0 = ((*(*(*prev_caller).callees).hh.tbl).buckets)
                    .offset(_ha_bkt___0 as isize);
                (*_ha_head___0).count = ((*_ha_head___0).count).wrapping_add(1);
                (*callee).hh.hh_next = (*_ha_head___0).hh_head;
                (*callee).hh.hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                if (*_ha_head___0).hh_head as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    (*(*_ha_head___0).hh_head).hh_prev = &mut (*callee).hh;
                }
                (*_ha_head___0).hh_head = &mut (*callee).hh;
                if (*_ha_head___0).count
                    >= ((*_ha_head___0).expand_mult)
                        .wrapping_add(1 as libc::c_uint)
                        .wrapping_mul(10 as libc::c_uint)
                {
                    if (*(*callee).hh.tbl).noexpand == 0 {
                        tmp___13 = malloc(
                            (2 as libc::c_ulong)
                                .wrapping_mul(
                                    (*(*callee).hh.tbl).num_buckets as libc::c_ulong,
                                )
                                .wrapping_mul(
                                    ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                ),
                        );
                        _he_new_buckets___0 = tmp___13 as *mut UT_hash_bucket;
                        if _he_new_buckets___0.is_null() {
                            exit(-(1 as libc::c_int));
                        } else {
                            memset(
                                _he_new_buckets___0 as *mut libc::c_void,
                                '\u{0}' as i32,
                                (2 as libc::c_ulong)
                                    .wrapping_mul(
                                        (*(*callee).hh.tbl).num_buckets as libc::c_ulong,
                                    )
                                    .wrapping_mul(
                                        ::std::mem::size_of::<UT_hash_bucket>() as libc::c_ulong,
                                    ),
                            );
                            if (*(*callee).hh.tbl).num_items
                                & ((*(*callee).hh.tbl).num_buckets)
                                    .wrapping_mul(2 as libc::c_uint)
                                    .wrapping_sub(1 as libc::c_uint) != 0 as libc::c_uint
                            {
                                tmp___14 = 1 as libc::c_uint;
                            } else {
                                tmp___14 = 0 as libc::c_uint;
                            }
                            (*(*callee).hh.tbl)
                                .ideal_chain_maxlen = ((*(*callee).hh.tbl).num_items
                                >> ((*(*callee).hh.tbl).log2_num_buckets)
                                    .wrapping_add(1 as libc::c_uint))
                                .wrapping_add(tmp___14);
                            (*(*callee).hh.tbl).nonideal_items = 0 as libc::c_uint;
                            _he_bkt_i___0 = 0 as libc::c_uint;
                            while _he_bkt_i___0 < (*(*callee).hh.tbl).num_buckets {
                                _he_thh___0 = (*((*(*callee).hh.tbl).buckets)
                                    .offset(_he_bkt_i___0 as isize))
                                    .hh_head;
                                while _he_thh___0 as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    _he_hh_nxt___0 = (*_he_thh___0).hh_next;
                                    _he_bkt___0 = (*_he_thh___0).hashv
                                        & ((*(*callee).hh.tbl).num_buckets)
                                            .wrapping_mul(2 as libc::c_uint)
                                            .wrapping_sub(1 as libc::c_uint);
                                    _he_newbkt___0 = _he_new_buckets___0
                                        .offset(_he_bkt___0 as isize);
                                    (*_he_newbkt___0)
                                        .count = ((*_he_newbkt___0).count).wrapping_add(1);
                                    if (*_he_newbkt___0).count
                                        > (*(*callee).hh.tbl).ideal_chain_maxlen
                                    {
                                        (*(*callee).hh.tbl)
                                            .nonideal_items = ((*(*callee).hh.tbl).nonideal_items)
                                            .wrapping_add(1);
                                        (*_he_newbkt___0)
                                            .expand_mult = ((*_he_newbkt___0).count)
                                            .wrapping_div((*(*callee).hh.tbl).ideal_chain_maxlen);
                                    }
                                    (*_he_thh___0)
                                        .hh_prev = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                    (*_he_thh___0).hh_next = (*_he_newbkt___0).hh_head;
                                    if (*_he_newbkt___0).hh_head as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        (*(*_he_newbkt___0).hh_head).hh_prev = _he_thh___0;
                                    }
                                    (*_he_newbkt___0).hh_head = _he_thh___0;
                                    _he_thh___0 = _he_hh_nxt___0;
                                }
                                _he_bkt_i___0 = _he_bkt_i___0.wrapping_add(1);
                            }
                            free((*(*callee).hh.tbl).buckets as *mut libc::c_void);
                            (*(*callee).hh.tbl)
                                .num_buckets = ((*(*callee).hh.tbl).num_buckets)
                                .wrapping_mul(2 as libc::c_uint);
                            (*(*callee).hh.tbl)
                                .log2_num_buckets = ((*(*callee).hh.tbl).log2_num_buckets)
                                .wrapping_add(1);
                            (*(*callee).hh.tbl).buckets = _he_new_buckets___0;
                            if (*(*callee).hh.tbl).nonideal_items
                                > (*(*callee).hh.tbl).num_items >> 1 as libc::c_int
                            {
                                (*(*callee).hh.tbl)
                                    .ineff_expands = ((*(*callee).hh.tbl).ineff_expands)
                                    .wrapping_add(1);
                            } else {
                                (*(*callee).hh.tbl).ineff_expands = 0 as libc::c_uint;
                            }
                            if (*(*callee).hh.tbl).ineff_expands > 1 as libc::c_uint {
                                (*(*callee).hh.tbl).noexpand = 1 as libc::c_uint;
                            }
                        }
                    }
                }
            }
            (*callee).inclusive = ((*callee).inclusive).wrapping_add(1);
            if i >= (*udata).prev_len {
                (*callee).count = ((*callee).count).wrapping_add(1);
            } else {
                tmp___15 = strcmp(
                    ((*udata).self_str[i as usize]).as_mut_ptr() as *const libc::c_char,
                    ((*udata).prev_str[i as usize]).as_mut_ptr() as *const libc::c_char,
                );
                if tmp___15 != 0 as libc::c_int {
                    (*callee).count = ((*callee).count).wrapping_add(1);
                }
            }
        }
        prev_caller = caller;
        i -= 1;
    }
}
unsafe extern "C" fn callgrind_dump(mut udata: *mut callgrind_udata_t) {
    let mut caller: *mut callgrind_caller_t = 0 as *mut callgrind_caller_t;
    let mut caller_tmp: *mut callgrind_caller_t = 0 as *mut callgrind_caller_t;
    let mut callee: *mut callgrind_callee_t = 0 as *mut callgrind_callee_t;
    let mut callee_tmp: *mut callgrind_callee_t = 0 as *mut callgrind_callee_t;
    let mut _hs_i: libc::c_uint = 0;
    let mut _hs_looping: libc::c_uint = 0;
    let mut _hs_nmerges: libc::c_uint = 0;
    let mut _hs_insize: libc::c_uint = 0;
    let mut _hs_psize: libc::c_uint = 0;
    let mut _hs_qsize: libc::c_uint = 0;
    let mut _hs_p: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_q: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_e: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_list: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_tail: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut _hs_i___0: libc::c_uint = 0;
    let mut _hs_looping___0: libc::c_uint = 0;
    let mut _hs_nmerges___0: libc::c_uint = 0;
    let mut _hs_insize___0: libc::c_uint = 0;
    let mut _hs_psize___0: libc::c_uint = 0;
    let mut _hs_qsize___0: libc::c_uint = 0;
    let mut _hs_p___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_q___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_e___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_list___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hs_tail___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    fprintf(
        (*udata).fout,
        b"# callgrind format\n\0" as *const u8 as *const libc::c_char,
    );
    fprintf((*udata).fout, b"version: 1\n\0" as *const u8 as *const libc::c_char);
    fprintf((*udata).fout, b"creator: phpspy\n\0" as *const u8 as *const libc::c_char);
    fprintf((*udata).fout, b"events: Samples\n\0" as *const u8 as *const libc::c_char);
    if (*udata).callers as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        _hs_insize = 1 as libc::c_uint;
        _hs_looping = 1 as libc::c_uint;
        _hs_list = &mut (*(*udata).callers).hh;
        while _hs_looping != 0 as libc::c_uint {
            _hs_p = _hs_list;
            _hs_list = 0 as *mut libc::c_void as *mut UT_hash_handle;
            _hs_tail = 0 as *mut libc::c_void as *mut UT_hash_handle;
            _hs_nmerges = 0 as libc::c_uint;
            while _hs_p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                _hs_nmerges = _hs_nmerges.wrapping_add(1);
                _hs_q = _hs_p;
                _hs_psize = 0 as libc::c_uint;
                _hs_i = 0 as libc::c_uint;
                while _hs_i < _hs_insize {
                    _hs_psize = _hs_psize.wrapping_add(1);
                    if (*_hs_q).next as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        _hs_q = ((*_hs_q).next as *mut libc::c_char)
                            .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                            as *mut UT_hash_handle;
                    } else {
                        _hs_q = 0 as *mut libc::c_void as *mut UT_hash_handle;
                    }
                    if _hs_q as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                    {
                        break;
                    }
                    _hs_i = _hs_i.wrapping_add(1);
                }
                _hs_qsize = _hs_insize;
                loop {
                    if !(_hs_psize != 0 as libc::c_uint) {
                        if !(_hs_qsize != 0 as libc::c_uint) {
                            break;
                        }
                        if !(_hs_q as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong)
                        {
                            break;
                        }
                    }
                    if _hs_psize == 0 as libc::c_uint {
                        _hs_e = _hs_q;
                        if (*_hs_q).next as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            _hs_q = ((*_hs_q).next as *mut libc::c_char)
                                .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                                as *mut UT_hash_handle;
                        } else {
                            _hs_q = 0 as *mut libc::c_void as *mut UT_hash_handle;
                        }
                        _hs_qsize = _hs_qsize.wrapping_sub(1);
                    } else {
                        let mut current_block_61: u64;
                        if _hs_qsize == 0 as libc::c_uint {
                            current_block_61 = 4769914247218419755;
                        } else if _hs_q as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                            current_block_61 = 4769914247218419755;
                        } else {
                            tmp = callgrind_sort_callers(
                                (_hs_p as *mut libc::c_char)
                                    .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                                    as *mut libc::c_void as *mut callgrind_caller_t,
                                (_hs_q as *mut libc::c_char)
                                    .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                                    as *mut libc::c_void as *mut callgrind_caller_t,
                            );
                            if tmp <= 0 as libc::c_int {
                                _hs_e = _hs_p;
                                if _hs_p as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    if (*_hs_p).next as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        _hs_p = ((*_hs_p).next as *mut libc::c_char)
                                            .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                                            as *mut UT_hash_handle;
                                    } else {
                                        _hs_p = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                    }
                                }
                                _hs_psize = _hs_psize.wrapping_sub(1);
                            } else {
                                _hs_e = _hs_q;
                                if (*_hs_q).next as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    _hs_q = ((*_hs_q).next as *mut libc::c_char)
                                        .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                                        as *mut UT_hash_handle;
                                } else {
                                    _hs_q = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                }
                                _hs_qsize = _hs_qsize.wrapping_sub(1);
                            }
                            current_block_61 = 9437375157805982253;
                        }
                        match current_block_61 {
                            4769914247218419755 => {
                                _hs_e = _hs_p;
                                if _hs_p as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    if (*_hs_p).next as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        _hs_p = ((*_hs_p).next as *mut libc::c_char)
                                            .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                                            as *mut UT_hash_handle;
                                    } else {
                                        _hs_p = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                    }
                                }
                                _hs_psize = _hs_psize.wrapping_sub(1);
                            }
                            _ => {}
                        }
                    }
                    if _hs_tail as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        if _hs_e as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            (*_hs_tail)
                                .next = (_hs_e as *mut libc::c_char)
                                .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                                as *mut libc::c_void;
                        } else {
                            (*_hs_tail).next = 0 as *mut libc::c_void;
                        }
                    } else {
                        _hs_list = _hs_e;
                    }
                    if _hs_e as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        if _hs_tail as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            (*_hs_e)
                                .prev = (_hs_tail as *mut libc::c_char)
                                .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                                as *mut libc::c_void;
                        } else {
                            (*_hs_e).prev = 0 as *mut libc::c_void;
                        }
                    }
                    _hs_tail = _hs_e;
                }
                _hs_p = _hs_q;
            }
            if _hs_tail as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                (*_hs_tail).next = 0 as *mut libc::c_void;
            }
            if _hs_nmerges <= 1 as libc::c_uint {
                _hs_looping = 0 as libc::c_uint;
                (*(*(*udata).callers).hh.tbl).tail = _hs_tail;
                (*udata)
                    .callers = (_hs_list as *mut libc::c_char)
                    .offset(-((*(*(*udata).callers).hh.tbl).hho as isize))
                    as *mut libc::c_void as *mut callgrind_caller_t;
            }
            _hs_insize = _hs_insize.wrapping_mul(2 as libc::c_uint);
        }
    }
    caller = (*udata).callers;
    if (*udata).callers as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = (*(*udata).callers).hh.next;
    } else {
        tmp___0 = 0 as *mut libc::c_void;
    }
    caller_tmp = tmp___0 as *mut callgrind_caller_t;
    while caller as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        fprintf((*udata).fout, b"\n\0" as *const u8 as *const libc::c_char);
        fprintf(
            (*udata).fout,
            b"fl=%.*s\n\0" as *const u8 as *const libc::c_char,
            (*caller).loc.file_len as libc::c_int,
            ((*caller).loc.file).as_mut_ptr(),
        );
        if (*caller).loc.class_len > 0 as libc::c_ulong {
            tmp___2 = b"::\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___2 = b"\0" as *const u8 as *const libc::c_char;
        }
        fprintf(
            (*udata).fout,
            b"fn=%.*s%s%.*s\n\0" as *const u8 as *const libc::c_char,
            (*caller).loc.class_len as libc::c_int,
            ((*caller).loc.class).as_mut_ptr(),
            tmp___2,
            (*caller).loc.func_len as libc::c_int,
            ((*caller).loc.func).as_mut_ptr(),
        );
        fprintf(
            (*udata).fout,
            b"%d %ld\n\0" as *const u8 as *const libc::c_char,
            (*caller).loc.lineno,
            (*caller).exclusive,
        );
        if (*caller).callees as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            _hs_insize___0 = 1 as libc::c_uint;
            _hs_looping___0 = 1 as libc::c_uint;
            _hs_list___0 = &mut (*(*caller).callees).hh;
            while _hs_looping___0 != 0 as libc::c_uint {
                _hs_p___0 = _hs_list___0;
                _hs_list___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                _hs_tail___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                _hs_nmerges___0 = 0 as libc::c_uint;
                while _hs_p___0 as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    _hs_nmerges___0 = _hs_nmerges___0.wrapping_add(1);
                    _hs_q___0 = _hs_p___0;
                    _hs_psize___0 = 0 as libc::c_uint;
                    _hs_i___0 = 0 as libc::c_uint;
                    while _hs_i___0 < _hs_insize___0 {
                        _hs_psize___0 = _hs_psize___0.wrapping_add(1);
                        if (*_hs_q___0).next as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            _hs_q___0 = ((*_hs_q___0).next as *mut libc::c_char)
                                .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                                as *mut UT_hash_handle;
                        } else {
                            _hs_q___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                        }
                        if _hs_q___0 as libc::c_ulong
                            == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            break;
                        }
                        _hs_i___0 = _hs_i___0.wrapping_add(1);
                    }
                    _hs_qsize___0 = _hs_insize___0;
                    loop {
                        if !(_hs_psize___0 != 0 as libc::c_uint) {
                            if !(_hs_qsize___0 != 0 as libc::c_uint) {
                                break;
                            }
                            if !(_hs_q___0 as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong)
                            {
                                break;
                            }
                        }
                        if _hs_psize___0 == 0 as libc::c_uint {
                            _hs_e___0 = _hs_q___0;
                            if (*_hs_q___0).next as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                _hs_q___0 = ((*_hs_q___0).next as *mut libc::c_char)
                                    .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                                    as *mut UT_hash_handle;
                            } else {
                                _hs_q___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                            }
                            _hs_qsize___0 = _hs_qsize___0.wrapping_sub(1);
                        } else {
                            let mut current_block_173: u64;
                            if _hs_qsize___0 == 0 as libc::c_uint {
                                current_block_173 = 9467709793573298627;
                            } else if _hs_q___0 as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                current_block_173 = 9467709793573298627;
                            } else {
                                tmp___3 = callgrind_sort_callees(
                                    (_hs_p___0 as *mut libc::c_char)
                                        .offset(-((*(*(*caller).callees).hh.tbl).hho as isize))
                                        as *mut libc::c_void as *mut callgrind_callee_t,
                                    (_hs_q___0 as *mut libc::c_char)
                                        .offset(-((*(*(*caller).callees).hh.tbl).hho as isize))
                                        as *mut libc::c_void as *mut callgrind_callee_t,
                                );
                                if tmp___3 <= 0 as libc::c_int {
                                    _hs_e___0 = _hs_p___0;
                                    if _hs_p___0 as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        if (*_hs_p___0).next as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            _hs_p___0 = ((*_hs_p___0).next as *mut libc::c_char)
                                                .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                                                as *mut UT_hash_handle;
                                        } else {
                                            _hs_p___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                        }
                                    }
                                    _hs_psize___0 = _hs_psize___0.wrapping_sub(1);
                                } else {
                                    _hs_e___0 = _hs_q___0;
                                    if (*_hs_q___0).next as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        _hs_q___0 = ((*_hs_q___0).next as *mut libc::c_char)
                                            .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                                            as *mut UT_hash_handle;
                                    } else {
                                        _hs_q___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                    }
                                    _hs_qsize___0 = _hs_qsize___0.wrapping_sub(1);
                                }
                                current_block_173 = 2885804587290726961;
                            }
                            match current_block_173 {
                                9467709793573298627 => {
                                    _hs_e___0 = _hs_p___0;
                                    if _hs_p___0 as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        if (*_hs_p___0).next as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            _hs_p___0 = ((*_hs_p___0).next as *mut libc::c_char)
                                                .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                                                as *mut UT_hash_handle;
                                        } else {
                                            _hs_p___0 = 0 as *mut libc::c_void as *mut UT_hash_handle;
                                        }
                                    }
                                    _hs_psize___0 = _hs_psize___0.wrapping_sub(1);
                                }
                                _ => {}
                            }
                        }
                        if _hs_tail___0 as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            if _hs_e___0 as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                (*_hs_tail___0)
                                    .next = (_hs_e___0 as *mut libc::c_char)
                                    .offset(-((*(*(*caller).callees).hh.tbl).hho as isize))
                                    as *mut libc::c_void;
                            } else {
                                (*_hs_tail___0).next = 0 as *mut libc::c_void;
                            }
                        } else {
                            _hs_list___0 = _hs_e___0;
                        }
                        if _hs_e___0 as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            if _hs_tail___0 as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                (*_hs_e___0)
                                    .prev = (_hs_tail___0 as *mut libc::c_char)
                                    .offset(-((*(*(*caller).callees).hh.tbl).hho as isize))
                                    as *mut libc::c_void;
                            } else {
                                (*_hs_e___0).prev = 0 as *mut libc::c_void;
                            }
                        }
                        _hs_tail___0 = _hs_e___0;
                    }
                    _hs_p___0 = _hs_q___0;
                }
                if _hs_tail___0 as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    (*_hs_tail___0).next = 0 as *mut libc::c_void;
                }
                if _hs_nmerges___0 <= 1 as libc::c_uint {
                    _hs_looping___0 = 0 as libc::c_uint;
                    (*(*(*caller).callees).hh.tbl).tail = _hs_tail___0;
                    (*caller)
                        .callees = (_hs_list___0 as *mut libc::c_char)
                        .offset(-((*(*(*caller).callees).hh.tbl).hho as isize))
                        as *mut libc::c_void as *mut callgrind_callee_t;
                }
                _hs_insize___0 = _hs_insize___0.wrapping_mul(2 as libc::c_uint);
            }
        }
        callee = (*caller).callees;
        if (*caller).callees as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp___4 = (*(*caller).callees).hh.next;
        } else {
            tmp___4 = 0 as *mut libc::c_void;
        }
        callee_tmp = tmp___4 as *mut callgrind_callee_t;
        while callee as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            fprintf((*udata).fout, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*udata).fout,
                b"cfl=%.*s\n\0" as *const u8 as *const libc::c_char,
                (*callee).loc.file_len as libc::c_int,
                ((*callee).loc.file).as_mut_ptr(),
            );
            if (*callee).loc.class_len > 0 as libc::c_ulong {
                tmp___6 = b"::\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___6 = b"\0" as *const u8 as *const libc::c_char;
            }
            fprintf(
                (*udata).fout,
                b"cfn=%.*s%s%.*s\n\0" as *const u8 as *const libc::c_char,
                (*callee).loc.class_len as libc::c_int,
                ((*callee).loc.class).as_mut_ptr(),
                tmp___6,
                (*callee).loc.func_len as libc::c_int,
                ((*callee).loc.func).as_mut_ptr(),
            );
            fprintf(
                (*udata).fout,
                b"calls=%ld %d\n\0" as *const u8 as *const libc::c_char,
                (*callee).count,
                (*callee).loc.lineno,
            );
            fprintf(
                (*udata).fout,
                b"%d %ld\n\0" as *const u8 as *const libc::c_char,
                (*caller).loc.lineno,
                (*callee).inclusive,
            );
            callee = callee_tmp;
            if callee_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___5 = (*callee_tmp).hh.next;
            } else {
                tmp___5 = 0 as *mut libc::c_void;
            }
            callee_tmp = tmp___5 as *mut callgrind_callee_t;
        }
        caller = caller_tmp;
        if caller_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___1 = (*caller_tmp).hh.next;
        } else {
            tmp___1 = 0 as *mut libc::c_void;
        }
        caller_tmp = tmp___1 as *mut callgrind_caller_t;
    }
}
unsafe extern "C" fn callgrind_free(mut udata: *mut callgrind_udata_t) {
    let mut caller: *mut callgrind_caller_t = 0 as *mut callgrind_caller_t;
    let mut caller_tmp: *mut callgrind_caller_t = 0 as *mut callgrind_caller_t;
    let mut callee: *mut callgrind_callee_t = 0 as *mut callgrind_callee_t;
    let mut callee_tmp: *mut callgrind_callee_t = 0 as *mut callgrind_callee_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut _hd_hh_del: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hd_bkt: libc::c_uint = 0;
    let mut _hd_head: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    let mut _hd_hh_del___0: *mut UT_hash_handle = 0 as *mut UT_hash_handle;
    let mut _hd_bkt___0: libc::c_uint = 0;
    let mut _hd_head___0: *mut UT_hash_bucket = 0 as *mut UT_hash_bucket;
    caller = (*udata).callers;
    if (*udata).callers as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = (*(*udata).callers).hh.next;
    } else {
        tmp = 0 as *mut libc::c_void;
    }
    caller_tmp = tmp as *mut callgrind_caller_t;
    while caller as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        callee = (*caller).callees;
        if (*caller).callees as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp___1 = (*(*caller).callees).hh.next;
        } else {
            tmp___1 = 0 as *mut libc::c_void;
        }
        callee_tmp = tmp___1 as *mut callgrind_callee_t;
        while callee as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            _hd_hh_del = &mut (*callee).hh;
            let mut current_block_45: u64;
            if (*_hd_hh_del).prev as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                if (*_hd_hh_del).next as libc::c_ulong
                    == 0 as *mut libc::c_void as libc::c_ulong
                {
                    free((*(*(*caller).callees).hh.tbl).buckets as *mut libc::c_void);
                    free((*(*caller).callees).hh.tbl as *mut libc::c_void);
                    (*caller)
                        .callees = 0 as *mut libc::c_void as *mut callgrind_callee_t;
                    current_block_45 = 14220266465818359136;
                } else {
                    current_block_45 = 779916146425440979;
                }
            } else {
                current_block_45 = 779916146425440979;
            }
            match current_block_45 {
                779916146425440979 => {
                    if _hd_hh_del as libc::c_ulong
                        == (*(*(*caller).callees).hh.tbl).tail as libc::c_ulong
                    {
                        (*(*(*caller).callees).hh.tbl)
                            .tail = ((*_hd_hh_del).prev as *mut libc::c_char)
                            .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                            as *mut UT_hash_handle;
                    }
                    if (*_hd_hh_del).prev as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        let ref mut fresh35 = (*(((*_hd_hh_del).prev
                            as *mut libc::c_char)
                            .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                            as *mut UT_hash_handle))
                            .next;
                        *fresh35 = (*_hd_hh_del).next;
                    } else {
                        (*caller)
                            .callees = (*_hd_hh_del).next as *mut callgrind_callee_t;
                    }
                    if (*_hd_hh_del).next as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        let ref mut fresh36 = (*(((*_hd_hh_del).next
                            as *mut libc::c_char)
                            .offset((*(*(*caller).callees).hh.tbl).hho as isize)
                            as *mut UT_hash_handle))
                            .prev;
                        *fresh36 = (*_hd_hh_del).prev;
                    }
                    _hd_bkt = (*_hd_hh_del).hashv
                        & ((*(*(*caller).callees).hh.tbl).num_buckets)
                            .wrapping_sub(1 as libc::c_uint);
                    _hd_head = ((*(*(*caller).callees).hh.tbl).buckets)
                        .offset(_hd_bkt as isize);
                    (*_hd_head).count = ((*_hd_head).count).wrapping_sub(1);
                    if (*_hd_head).hh_head as libc::c_ulong
                        == _hd_hh_del as libc::c_ulong
                    {
                        (*_hd_head).hh_head = (*_hd_hh_del).hh_next;
                    }
                    if !((*_hd_hh_del).hh_prev).is_null() {
                        (*(*_hd_hh_del).hh_prev).hh_next = (*_hd_hh_del).hh_next;
                    }
                    if !((*_hd_hh_del).hh_next).is_null() {
                        (*(*_hd_hh_del).hh_next).hh_prev = (*_hd_hh_del).hh_prev;
                    }
                    (*(*(*caller).callees).hh.tbl)
                        .num_items = ((*(*(*caller).callees).hh.tbl).num_items)
                        .wrapping_sub(1);
                }
                _ => {}
            }
            free(callee as *mut libc::c_void);
            callee = callee_tmp;
            if callee_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___2 = (*callee_tmp).hh.next;
            } else {
                tmp___2 = 0 as *mut libc::c_void;
            }
            callee_tmp = tmp___2 as *mut callgrind_callee_t;
        }
        _hd_hh_del___0 = &mut (*caller).hh;
        let mut current_block_89: u64;
        if (*_hd_hh_del___0).prev as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            if (*_hd_hh_del___0).next as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                free((*(*(*udata).callers).hh.tbl).buckets as *mut libc::c_void);
                free((*(*udata).callers).hh.tbl as *mut libc::c_void);
                (*udata).callers = 0 as *mut libc::c_void as *mut callgrind_caller_t;
                current_block_89 = 10769842751669019566;
            } else {
                current_block_89 = 8054613762980988211;
            }
        } else {
            current_block_89 = 8054613762980988211;
        }
        match current_block_89 {
            8054613762980988211 => {
                if _hd_hh_del___0 as libc::c_ulong
                    == (*(*(*udata).callers).hh.tbl).tail as libc::c_ulong
                {
                    (*(*(*udata).callers).hh.tbl)
                        .tail = ((*_hd_hh_del___0).prev as *mut libc::c_char)
                        .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                        as *mut UT_hash_handle;
                }
                if (*_hd_hh_del___0).prev as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    let ref mut fresh37 = (*(((*_hd_hh_del___0).prev
                        as *mut libc::c_char)
                        .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                        as *mut UT_hash_handle))
                        .next;
                    *fresh37 = (*_hd_hh_del___0).next;
                } else {
                    (*udata).callers = (*_hd_hh_del___0).next as *mut callgrind_caller_t;
                }
                if (*_hd_hh_del___0).next as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    let ref mut fresh38 = (*(((*_hd_hh_del___0).next
                        as *mut libc::c_char)
                        .offset((*(*(*udata).callers).hh.tbl).hho as isize)
                        as *mut UT_hash_handle))
                        .prev;
                    *fresh38 = (*_hd_hh_del___0).prev;
                }
                _hd_bkt___0 = (*_hd_hh_del___0).hashv
                    & ((*(*(*udata).callers).hh.tbl).num_buckets)
                        .wrapping_sub(1 as libc::c_uint);
                _hd_head___0 = ((*(*(*udata).callers).hh.tbl).buckets)
                    .offset(_hd_bkt___0 as isize);
                (*_hd_head___0).count = ((*_hd_head___0).count).wrapping_sub(1);
                if (*_hd_head___0).hh_head as libc::c_ulong
                    == _hd_hh_del___0 as libc::c_ulong
                {
                    (*_hd_head___0).hh_head = (*_hd_hh_del___0).hh_next;
                }
                if !((*_hd_hh_del___0).hh_prev).is_null() {
                    (*(*_hd_hh_del___0).hh_prev).hh_next = (*_hd_hh_del___0).hh_next;
                }
                if !((*_hd_hh_del___0).hh_next).is_null() {
                    (*(*_hd_hh_del___0).hh_next).hh_prev = (*_hd_hh_del___0).hh_prev;
                }
                (*(*(*udata).callers).hh.tbl)
                    .num_items = ((*(*(*udata).callers).hh.tbl).num_items)
                    .wrapping_sub(1);
            }
            _ => {}
        }
        free(caller as *mut libc::c_void);
        caller = caller_tmp;
        if caller_tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___0 = (*caller_tmp).hh.next;
        } else {
            tmp___0 = 0 as *mut libc::c_void;
        }
        caller_tmp = tmp___0 as *mut callgrind_caller_t;
    }
}
unsafe extern "C" fn callgrind_sort_callers(
    mut a: *mut callgrind_caller_t,
    mut b: *mut callgrind_caller_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = strcmp(
        ((*a).loc_str).as_mut_ptr() as *const libc::c_char,
        ((*b).loc_str).as_mut_ptr() as *const libc::c_char,
    );
    return tmp;
}
unsafe extern "C" fn callgrind_sort_callees(
    mut a: *mut callgrind_callee_t,
    mut b: *mut callgrind_callee_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = strcmp(
        ((*a).loc_str).as_mut_ptr() as *const libc::c_char,
        ((*b).loc_str).as_mut_ptr() as *const libc::c_char,
    );
    return tmp;
}
unsafe extern "C" fn callgrind_open(mut fout: *mut *mut FILE) -> libc::c_int {
    let mut tfd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    tfd = -(1 as libc::c_int);
    tmp = strcmp(
        opt_path_output as *const libc::c_char,
        b"-\0" as *const u8 as *const libc::c_char,
    );
    if tmp == 0 as libc::c_int {
        tfd = dup(1 as libc::c_int);
        *fout = fdopen(tfd, b"w\0" as *const u8 as *const libc::c_char);
    } else {
        *fout = fopen(
            opt_path_output as *const libc::c_char,
            b"w\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*fout).is_null() {
        perror(b"fopen\0" as *const u8 as *const libc::c_char);
        if tfd != -(1 as libc::c_int) {
            close(tfd);
        }
        return 1 as libc::c_int;
    }
    setvbuf(
        *fout,
        0 as *mut libc::c_void as *mut libc::c_char,
        1 as libc::c_int,
        4096 as libc::c_int as size_t,
    );
    return 0 as libc::c_int;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
