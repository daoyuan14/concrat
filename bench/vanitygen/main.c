/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_622077928 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_119281978 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_119281977 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_119281978 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_622077928 __annonCompField1 ;
   union __anonunion____missing_field_name_119281977 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef int wchar_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct bignum_st ;
typedef struct bignum_st BIGNUM;
struct bignum_ctx ;
typedef struct bignum_ctx BN_CTX;
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
enum __anonenum_point_conversion_form_t_134566212 {
    POINT_CONVERSION_COMPRESSED = 2,
    POINT_CONVERSION_UNCOMPRESSED = 4,
    POINT_CONVERSION_HYBRID = 6
} ;
typedef enum __anonenum_point_conversion_form_t_134566212 point_conversion_form_t;
struct ec_group_st ;
typedef struct ec_group_st EC_GROUP;
struct ec_point_st ;
typedef struct ec_point_st EC_POINT;
struct ec_key_st ;
typedef struct ec_key_st EC_KEY;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
typedef void CURL;
enum __anonenum_CURLcode_1040171027 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_NOT_BUILT_IN = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_WEIRD_SERVER_REPLY = 8,
    CURLE_REMOTE_ACCESS_DENIED = 9,
    CURLE_FTP_ACCEPT_FAILED = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_ACCEPT_TIMEOUT = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_HTTP2 = 16,
    CURLE_FTP_COULDNT_SET_TYPE = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_OBSOLETE20 = 20,
    CURLE_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_OBSOLETE24 = 24,
    CURLE_UPLOAD_FAILED = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEDOUT = 28,
    CURLE_OBSOLETE29 = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_OBSOLETE32 = 32,
    CURLE_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_OBSOLETE40 = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_OBSOLETE44 = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_OBSOLETE46 = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE50 = 50,
    CURLE_OBSOLETE51 = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_OBSOLETE57 = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_PEER_FAILED_VERIFICATION = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_USE_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURLE_TFTP_NOTFOUND = 68,
    CURLE_TFTP_PERM = 69,
    CURLE_REMOTE_DISK_FULL = 70,
    CURLE_TFTP_ILLEGAL = 71,
    CURLE_TFTP_UNKNOWNID = 72,
    CURLE_REMOTE_FILE_EXISTS = 73,
    CURLE_TFTP_NOSUCHUSER = 74,
    CURLE_CONV_FAILED = 75,
    CURLE_CONV_REQD = 76,
    CURLE_SSL_CACERT_BADFILE = 77,
    CURLE_REMOTE_FILE_NOT_FOUND = 78,
    CURLE_SSH = 79,
    CURLE_SSL_SHUTDOWN_FAILED = 80,
    CURLE_AGAIN = 81,
    CURLE_SSL_CRL_BADFILE = 82,
    CURLE_SSL_ISSUER_ERROR = 83,
    CURLE_FTP_PRET_FAILED = 84,
    CURLE_RTSP_CSEQ_ERROR = 85,
    CURLE_RTSP_SESSION_ERROR = 86,
    CURLE_FTP_BAD_FILE_LIST = 87,
    CURLE_CHUNK_FAILED = 88,
    CURLE_NO_CONNECTION_AVAILABLE = 89,
    CURLE_SSL_PINNEDPUBKEYNOTMATCH = 90,
    CURLE_SSL_INVALIDCERTSTATUS = 91,
    CURLE_HTTP2_STREAM = 92,
    CURLE_RECURSIVE_API_CALL = 93,
    CURLE_AUTH_ERROR = 94,
    CURLE_HTTP3 = 95,
    CURL_LAST = 96
} ;
typedef enum __anonenum_CURLcode_1040171027 CURLcode;
enum __anonenum_CURLoption_714703655 {
    CURLOPT_WRITEDATA = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_READDATA = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_KEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_HEADERDATA = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_OBSOLETE40 = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_DIRLISTONLY = 48,
    CURLOPT_APPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRBLEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_OBSOLETE72 = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ACCEPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_USE_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_COOKIELIST = 10135,
    CURLOPT_IGNORE_CONTENT_LENGTH = 136,
    CURLOPT_FTP_SKIP_PASV_IP = 137,
    CURLOPT_FTP_FILEMETHOD = 138,
    CURLOPT_LOCALPORT = 139,
    CURLOPT_LOCALPORTRANGE = 140,
    CURLOPT_CONNECT_ONLY = 141,
    CURLOPT_CONV_FROM_NETWORK_FUNCTION = 20142,
    CURLOPT_CONV_TO_NETWORK_FUNCTION = 20143,
    CURLOPT_CONV_FROM_UTF8_FUNCTION = 20144,
    CURLOPT_MAX_SEND_SPEED_LARGE = 30145,
    CURLOPT_MAX_RECV_SPEED_LARGE = 30146,
    CURLOPT_FTP_ALTERNATIVE_TO_USER = 10147,
    CURLOPT_SOCKOPTFUNCTION = 20148,
    CURLOPT_SOCKOPTDATA = 10149,
    CURLOPT_SSL_SESSIONID_CACHE = 150,
    CURLOPT_SSH_AUTH_TYPES = 151,
    CURLOPT_SSH_PUBLIC_KEYFILE = 10152,
    CURLOPT_SSH_PRIVATE_KEYFILE = 10153,
    CURLOPT_FTP_SSL_CCC = 154,
    CURLOPT_TIMEOUT_MS = 155,
    CURLOPT_CONNECTTIMEOUT_MS = 156,
    CURLOPT_HTTP_TRANSFER_DECODING = 157,
    CURLOPT_HTTP_CONTENT_DECODING = 158,
    CURLOPT_NEW_FILE_PERMS = 159,
    CURLOPT_NEW_DIRECTORY_PERMS = 160,
    CURLOPT_POSTREDIR = 161,
    CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = 10162,
    CURLOPT_OPENSOCKETFUNCTION = 20163,
    CURLOPT_OPENSOCKETDATA = 10164,
    CURLOPT_COPYPOSTFIELDS = 10165,
    CURLOPT_PROXY_TRANSFER_MODE = 166,
    CURLOPT_SEEKFUNCTION = 20167,
    CURLOPT_SEEKDATA = 10168,
    CURLOPT_CRLFILE = 10169,
    CURLOPT_ISSUERCERT = 10170,
    CURLOPT_ADDRESS_SCOPE = 171,
    CURLOPT_CERTINFO = 172,
    CURLOPT_USERNAME = 10173,
    CURLOPT_PASSWORD = 10174,
    CURLOPT_PROXYUSERNAME = 10175,
    CURLOPT_PROXYPASSWORD = 10176,
    CURLOPT_NOPROXY = 10177,
    CURLOPT_TFTP_BLKSIZE = 178,
    CURLOPT_SOCKS5_GSSAPI_SERVICE = 10179,
    CURLOPT_SOCKS5_GSSAPI_NEC = 180,
    CURLOPT_PROTOCOLS = 181,
    CURLOPT_REDIR_PROTOCOLS = 182,
    CURLOPT_SSH_KNOWNHOSTS = 10183,
    CURLOPT_SSH_KEYFUNCTION = 20184,
    CURLOPT_SSH_KEYDATA = 10185,
    CURLOPT_MAIL_FROM = 10186,
    CURLOPT_MAIL_RCPT = 10187,
    CURLOPT_FTP_USE_PRET = 188,
    CURLOPT_RTSP_REQUEST = 189,
    CURLOPT_RTSP_SESSION_ID = 10190,
    CURLOPT_RTSP_STREAM_URI = 10191,
    CURLOPT_RTSP_TRANSPORT = 10192,
    CURLOPT_RTSP_CLIENT_CSEQ = 193,
    CURLOPT_RTSP_SERVER_CSEQ = 194,
    CURLOPT_INTERLEAVEDATA = 10195,
    CURLOPT_INTERLEAVEFUNCTION = 20196,
    CURLOPT_WILDCARDMATCH = 197,
    CURLOPT_CHUNK_BGN_FUNCTION = 20198,
    CURLOPT_CHUNK_END_FUNCTION = 20199,
    CURLOPT_FNMATCH_FUNCTION = 20200,
    CURLOPT_CHUNK_DATA = 10201,
    CURLOPT_FNMATCH_DATA = 10202,
    CURLOPT_RESOLVE = 10203,
    CURLOPT_TLSAUTH_USERNAME = 10204,
    CURLOPT_TLSAUTH_PASSWORD = 10205,
    CURLOPT_TLSAUTH_TYPE = 10206,
    CURLOPT_TRANSFER_ENCODING = 207,
    CURLOPT_CLOSESOCKETFUNCTION = 20208,
    CURLOPT_CLOSESOCKETDATA = 10209,
    CURLOPT_GSSAPI_DELEGATION = 210,
    CURLOPT_DNS_SERVERS = 10211,
    CURLOPT_ACCEPTTIMEOUT_MS = 212,
    CURLOPT_TCP_KEEPALIVE = 213,
    CURLOPT_TCP_KEEPIDLE = 214,
    CURLOPT_TCP_KEEPINTVL = 215,
    CURLOPT_SSL_OPTIONS = 216,
    CURLOPT_MAIL_AUTH = 10217,
    CURLOPT_SASL_IR = 218,
    CURLOPT_XFERINFOFUNCTION = 20219,
    CURLOPT_XOAUTH2_BEARER = 10220,
    CURLOPT_DNS_INTERFACE = 10221,
    CURLOPT_DNS_LOCAL_IP4 = 10222,
    CURLOPT_DNS_LOCAL_IP6 = 10223,
    CURLOPT_LOGIN_OPTIONS = 10224,
    CURLOPT_SSL_ENABLE_NPN = 225,
    CURLOPT_SSL_ENABLE_ALPN = 226,
    CURLOPT_EXPECT_100_TIMEOUT_MS = 227,
    CURLOPT_PROXYHEADER = 10228,
    CURLOPT_HEADEROPT = 229,
    CURLOPT_PINNEDPUBLICKEY = 10230,
    CURLOPT_UNIX_SOCKET_PATH = 10231,
    CURLOPT_SSL_VERIFYSTATUS = 232,
    CURLOPT_SSL_FALSESTART = 233,
    CURLOPT_PATH_AS_IS = 234,
    CURLOPT_PROXY_SERVICE_NAME = 10235,
    CURLOPT_SERVICE_NAME = 10236,
    CURLOPT_PIPEWAIT = 237,
    CURLOPT_DEFAULT_PROTOCOL = 10238,
    CURLOPT_STREAM_WEIGHT = 239,
    CURLOPT_STREAM_DEPENDS = 10240,
    CURLOPT_STREAM_DEPENDS_E = 10241,
    CURLOPT_TFTP_NO_OPTIONS = 242,
    CURLOPT_CONNECT_TO = 10243,
    CURLOPT_TCP_FASTOPEN = 244,
    CURLOPT_KEEP_SENDING_ON_ERROR = 245,
    CURLOPT_PROXY_CAINFO = 10246,
    CURLOPT_PROXY_CAPATH = 10247,
    CURLOPT_PROXY_SSL_VERIFYPEER = 248,
    CURLOPT_PROXY_SSL_VERIFYHOST = 249,
    CURLOPT_PROXY_SSLVERSION = 250,
    CURLOPT_PROXY_TLSAUTH_USERNAME = 10251,
    CURLOPT_PROXY_TLSAUTH_PASSWORD = 10252,
    CURLOPT_PROXY_TLSAUTH_TYPE = 10253,
    CURLOPT_PROXY_SSLCERT = 10254,
    CURLOPT_PROXY_SSLCERTTYPE = 10255,
    CURLOPT_PROXY_SSLKEY = 10256,
    CURLOPT_PROXY_SSLKEYTYPE = 10257,
    CURLOPT_PROXY_KEYPASSWD = 10258,
    CURLOPT_PROXY_SSL_CIPHER_LIST = 10259,
    CURLOPT_PROXY_CRLFILE = 10260,
    CURLOPT_PROXY_SSL_OPTIONS = 261,
    CURLOPT_PRE_PROXY = 10262,
    CURLOPT_PROXY_PINNEDPUBLICKEY = 10263,
    CURLOPT_ABSTRACT_UNIX_SOCKET = 10264,
    CURLOPT_SUPPRESS_CONNECT_HEADERS = 265,
    CURLOPT_REQUEST_TARGET = 10266,
    CURLOPT_SOCKS5_AUTH = 267,
    CURLOPT_SSH_COMPRESSION = 268,
    CURLOPT_MIMEPOST = 10269,
    CURLOPT_TIMEVALUE_LARGE = 30270,
    CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS = 271,
    CURLOPT_RESOLVER_START_FUNCTION = 20272,
    CURLOPT_RESOLVER_START_DATA = 10273,
    CURLOPT_HAPROXYPROTOCOL = 274,
    CURLOPT_DNS_SHUFFLE_ADDRESSES = 275,
    CURLOPT_TLS13_CIPHERS = 10276,
    CURLOPT_PROXY_TLS13_CIPHERS = 10277,
    CURLOPT_DISALLOW_USERNAME_IN_URL = 278,
    CURLOPT_DOH_URL = 10279,
    CURLOPT_UPLOAD_BUFFERSIZE = 280,
    CURLOPT_UPKEEP_INTERVAL_MS = 281,
    CURLOPT_CURLU = 10282,
    CURLOPT_TRAILERFUNCTION = 20283,
    CURLOPT_TRAILERDATA = 10284,
    CURLOPT_HTTP09_ALLOWED = 285,
    CURLOPT_ALTSVC_CTRL = 286,
    CURLOPT_ALTSVC = 10287,
    CURLOPT_MAXAGE_CONN = 288,
    CURLOPT_SASL_AUTHZID = 10289,
    CURLOPT_LASTENTRY = 10290
} ;
typedef enum __anonenum_CURLoption_714703655 CURLoption;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct _vg_context_s ;
typedef struct _vg_context_s vg_context_t;
struct _vg_exec_context_s ;
typedef struct _vg_exec_context_s vg_exec_context_t;
struct _vg_exec_context_s {
   vg_context_t *vxc_vc ;
   BN_CTX *vxc_bnctx ;
   EC_KEY *vxc_key ;
   int vxc_delta ;
   unsigned char vxc_binres[28] ;
   BIGNUM vxc_bntarg ;
   BIGNUM vxc_bnbase ;
   BIGNUM vxc_bntmp ;
   BIGNUM vxc_bntmp2 ;
   void *(*vxc_threadfunc)(vg_exec_context_t * ) ;
   pthread_t vxc_pthread ;
   int vxc_thread_active ;
   struct _vg_exec_context_s *vxc_next ;
   int vxc_lockmode ;
   int vxc_stop ;
};
enum vg_format {
    VCF_PUBKEY = 0,
    VCF_SCRIPT = 1
} ;
struct _timing_info_s ;
struct _vg_context_s {
   int vc_addrtype ;
   int vc_privtype ;
   unsigned long vc_npatterns ;
   unsigned long vc_npatterns_start ;
   unsigned long long vc_found ;
   int vc_pattern_generation ;
   double vc_chance ;
   char const   *vc_result_file ;
   char const   *vc_key_protect_pass ;
   int vc_remove_on_match ;
   int vc_only_one ;
   int vc_verbose ;
   enum vg_format vc_format ;
   int vc_pubkeytype ;
   EC_POINT *vc_pubkey_base ;
   int vc_halt ;
   vg_exec_context_t *vc_threads ;
   int vc_thread_excl ;
   void (*vc_free)(vg_context_t * ) ;
   int (*vc_add_patterns)(vg_context_t * , char const   ** const  patterns , int npatterns ) ;
   void (*vc_clear_all_patterns)(vg_context_t * ) ;
   int (*vc_test)(vg_exec_context_t * ) ;
   int (*vc_hash160_sort)(vg_context_t *vcp , void *buf ) ;
   unsigned long long vc_timing_total ;
   unsigned long long vc_timing_prevfound ;
   unsigned long long vc_timing_sincelast ;
   struct _timing_info_s *vc_timing_head ;
   void (*vc_output_error)(vg_context_t *vcp , char const   *info ) ;
   void (*vc_output_match)(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern ) ;
   void (*vc_output_timing)(vg_context_t *vcp , double count , unsigned long long rate ,
                            unsigned long long total ) ;
};
struct _vg_ocl_context_s ;
typedef struct _vg_ocl_context_s vg_ocl_context_t;
enum __anonenum_avl_balance_t_281414157 {
    CENT = 1,
    LEFT = 0,
    RIGHT = 2
} ;
typedef enum __anonenum_avl_balance_t_281414157 avl_balance_t;
struct _avl_item_s {
   struct _avl_item_s *ai_left ;
   struct _avl_item_s *ai_right ;
   struct _avl_item_s *ai_up ;
   avl_balance_t ai_balance ;
   int ai_indexed ;
};
typedef struct _avl_item_s avl_item_t;
struct _avl_root_s {
   avl_item_t *ar_root ;
};
typedef struct _avl_root_s avl_root_t;
struct workitem_s {
   avl_item_t avlent ;
   char const   *pattern ;
   char const   *comment ;
   EC_POINT *pubkey ;
   int addrtype ;
   double difficulty ;
   double reward ;
   double value ;
};
typedef struct workitem_s workitem_t;
struct pubkeybatch_s {
   avl_item_t avlent ;
   EC_POINT *pubkey ;
   char const   *pubkey_hex ;
   avl_root_t items ;
   int nitems ;
   double total_value ;
};
typedef struct pubkeybatch_s pubkeybatch_t;
struct server_request_s {
   int request_status ;
   EC_GROUP const   *group ;
   char *part_buf ;
   size_t part_off ;
   size_t part_end ;
   size_t part_size ;
   avl_root_t items ;
   int nitems ;
};
typedef struct server_request_s server_request_t;
struct server_context_s {
   EC_KEY *dummy_key ;
   char const   *url ;
   char const   *credit_addr ;
   char *getwork ;
   char *submit ;
   int verbose ;
   avl_root_t items ;
   int nitems ;
};
typedef struct server_context_s server_context_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
typedef __int32_t int32_t;
struct bn_mont_ctx_st ;
typedef struct bn_mont_ctx_st BN_MONT_CTX;
struct env_md_st ;
typedef struct env_md_st EVP_MD;
struct env_md_ctx_st ;
typedef struct env_md_ctx_st EVP_MD_CTX;
struct evp_pkey_ctx_st ;
typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
struct engine_st ;
typedef struct engine_st ENGINE;
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0[2] ;
   int flags ;
};
struct ec_method_st ;
typedef struct ec_method_st EC_METHOD;
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
   int (*md_ctrl)(EVP_MD_CTX *ctx , int cmd , int p1 , void *p2 ) ;
};
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
   EVP_PKEY_CTX *pctx ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
};
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef long intptr_t;
typedef int32_t cl_int;
typedef uint32_t cl_uint;
typedef uint64_t cl_ulong;
typedef int __attribute__((__vector_size__(8), __may_alias__))  __m64;
typedef int __attribute__((__vector_size__(8), __may_alias__, __aligned__(1)))  __m64_u;
typedef int __attribute__((__vector_size__(8)))  __v2si;
typedef short __attribute__((__vector_size__(8)))  __v4hi;
typedef char __attribute__((__vector_size__(8)))  __v8qi;
typedef long long __attribute__((__vector_size__(8)))  __v1di;
typedef float __attribute__((__vector_size__(8)))  __v2sf;
enum _mm_hint {
    _MM_HINT_ET0 = 7,
    _MM_HINT_ET1 = 6,
    _MM_HINT_T0 = 3,
    _MM_HINT_T1 = 2,
    _MM_HINT_T2 = 1,
    _MM_HINT_NTA = 0
} ;
typedef float __attribute__((__vector_size__(16), __may_alias__))  __m128;
typedef float __attribute__((__vector_size__(16), __may_alias__, __aligned__(1)))  __m128_u;
typedef float __attribute__((__vector_size__(16)))  __v4sf;
typedef double __attribute__((__vector_size__(16)))  __v2df;
typedef long long __attribute__((__vector_size__(16)))  __v2di;
typedef unsigned long long __attribute__((__vector_size__(16)))  __v2du;
typedef int __attribute__((__vector_size__(16)))  __v4si;
typedef unsigned int __attribute__((__vector_size__(16)))  __v4su;
typedef short __attribute__((__vector_size__(16)))  __v8hi;
typedef unsigned short __attribute__((__vector_size__(16)))  __v8hu;
typedef char __attribute__((__vector_size__(16)))  __v16qi;
typedef signed char __attribute__((__vector_size__(16)))  __v16qs;
typedef unsigned char __attribute__((__vector_size__(16)))  __v16qu;
typedef long long __attribute__((__vector_size__(16), __may_alias__))  __m128i;
typedef double __attribute__((__vector_size__(16), __may_alias__))  __m128d;
typedef long long __attribute__((__vector_size__(16), __may_alias__, __aligned__(1)))  __m128i_u;
typedef double __attribute__((__vector_size__(16), __may_alias__, __aligned__(1)))  __m128d_u;
struct _cl_platform_id ;
typedef struct _cl_platform_id *cl_platform_id;
struct _cl_device_id ;
typedef struct _cl_device_id *cl_device_id;
struct _cl_context ;
typedef struct _cl_context *cl_context;
struct _cl_command_queue ;
typedef struct _cl_command_queue *cl_command_queue;
struct _cl_mem ;
typedef struct _cl_mem *cl_mem;
struct _cl_program ;
typedef struct _cl_program *cl_program;
struct _cl_kernel ;
typedef struct _cl_kernel *cl_kernel;
struct _cl_event ;
typedef struct _cl_event *cl_event;
typedef cl_uint cl_bool;
typedef cl_ulong cl_bitfield;
typedef cl_bitfield cl_device_type;
typedef cl_uint cl_platform_info;
typedef cl_uint cl_device_info;
typedef cl_bitfield cl_command_queue_properties;
typedef intptr_t cl_context_properties;
typedef cl_bitfield cl_mem_flags;
typedef cl_bitfield cl_map_flags;
typedef cl_uint cl_program_info;
typedef cl_uint cl_program_build_info;
typedef int (*vg_ocl_check_t)(struct _vg_ocl_context_s * , int slot );
struct _vg_ocl_context_s {
   vg_exec_context_t base ;
   cl_device_id voc_ocldid ;
   cl_context voc_oclctx ;
   cl_command_queue voc_oclcmdq ;
   cl_program voc_oclprog ;
   int (*voc_init_func)(struct _vg_ocl_context_s * ) ;
   int (*voc_rekey_func)(struct _vg_ocl_context_s * ) ;
   int (*voc_check_func)(struct _vg_ocl_context_s * , int slot ) ;
   int voc_quirks ;
   int voc_nslots ;
   cl_kernel voc_oclkernel[2][3] ;
   cl_event voc_oclkrnwait[2] ;
   cl_mem voc_args[2][6] ;
   size_t voc_arg_size[2][6] ;
   int voc_pattern_rewrite ;
   int voc_pattern_alloc ;
   vg_ocl_check_t voc_verify_func[3] ;
   pthread_t voc_ocl_thread ;
   pthread_mutex_t voc_lock ;
   pthread_cond_t voc_wait ;
   int voc_ocl_slot ;
   int voc_ocl_rows ;
   int voc_ocl_cols ;
   int voc_ocl_invsize ;
   int voc_halt ;
   int voc_dump_done ;
};
struct __anonstruct_vg_elf32_header_t_838073139 {
   unsigned char e_ident[16] ;
   uint16_t e_type ;
   uint16_t e_machine ;
   uint32_t e_version ;
   uint32_t e_entry ;
   uint32_t e_phoff ;
   uint32_t e_shoff ;
   uint32_t e_flags ;
   uint16_t e_ehsize ;
   uint16_t e_phentsize ;
   uint16_t e_phnum ;
   uint16_t e_shentsize ;
   uint16_t e_shnum ;
   uint16_t e_shstrndx ;
};
typedef struct __anonstruct_vg_elf32_header_t_838073139 vg_elf32_header_t;
struct __anonstruct_vg_elf32_shdr_t_293933665 {
   uint32_t sh_name ;
   uint32_t sh_type ;
   uint32_t sh_flags ;
   uint32_t sh_addr ;
   uint32_t sh_offset ;
   uint32_t sh_size ;
   uint32_t sh_link ;
   uint32_t sh_info ;
   uint32_t sh_addralign ;
   uint32_t sh_entsize ;
};
typedef struct __anonstruct_vg_elf32_shdr_t_293933665 vg_elf32_shdr_t;
struct ec_point_st {
   EC_METHOD const   *meth ;
   BIGNUM X ;
   BIGNUM Y ;
   BIGNUM Z ;
   int Z_is_one ;
};
struct real_pcre ;
typedef struct real_pcre pcre;
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
typedef struct pcre_extra pcre_extra;
struct _timing_info_s {
   struct _timing_info_s *ti_next ;
   pthread_t ti_thread ;
   unsigned long ti_last_rate ;
   unsigned long long ti_hist_time[5] ;
   unsigned long ti_hist_work[5] ;
   int ti_hist_last ;
};
typedef struct _timing_info_s timing_info_t;
struct _vg_prefix_s {
   avl_item_t vp_item ;
   struct _vg_prefix_s *vp_sibling ;
   char const   *vp_pattern ;
   BIGNUM *vp_low ;
   BIGNUM *vp_high ;
};
typedef struct _vg_prefix_s vg_prefix_t;
struct _prefix_case_iter_s {
   char ci_prefix[32] ;
   char ci_case_map[32] ;
   char ci_nbits ;
   int ci_value ;
};
typedef struct _prefix_case_iter_s prefix_case_iter_t;
struct _vg_prefix_context_s {
   vg_context_t base ;
   avl_root_t vcp_avlroot ;
   BIGNUM vcp_difficulty ;
   int vcp_caseinsensitive ;
};
typedef struct _vg_prefix_context_s vg_prefix_context_t;
struct _vg_regex_context_s {
   vg_context_t base ;
   pcre **vcr_regex ;
   pcre_extra **vcr_regex_extra ;
   char const   **vcr_regex_pat ;
   unsigned long vcr_nalloc ;
};
typedef struct _vg_regex_context_s vg_regex_context_t;
struct asn1_string_st ;
typedef struct asn1_string_st ASN1_INTEGER;
typedef struct asn1_string_st ASN1_ENUMERATED;
typedef struct asn1_string_st ASN1_BIT_STRING;
typedef struct asn1_string_st ASN1_OCTET_STRING;
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
typedef struct asn1_string_st ASN1_T61STRING;
typedef struct asn1_string_st ASN1_IA5STRING;
typedef struct asn1_string_st ASN1_GENERALSTRING;
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
typedef struct asn1_string_st ASN1_BMPSTRING;
typedef struct asn1_string_st ASN1_UTCTIME;
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
typedef struct asn1_string_st ASN1_VISIBLESTRING;
typedef struct asn1_string_st ASN1_UTF8STRING;
typedef struct asn1_string_st ASN1_STRING;
typedef int ASN1_BOOLEAN;
struct bn_blinding_st ;
typedef struct bn_blinding_st BN_BLINDING;
struct bn_gencb_st ;
typedef struct bn_gencb_st BN_GENCB;
struct buf_mem_st ;
typedef struct buf_mem_st BUF_MEM;
struct evp_cipher_st ;
typedef struct evp_cipher_st EVP_CIPHER;
struct evp_cipher_ctx_st ;
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
struct evp_pkey_st ;
typedef struct evp_pkey_st EVP_PKEY;
struct evp_pkey_asn1_method_st ;
typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;
struct dh_st ;
typedef struct dh_st DH;
struct dh_method ;
typedef struct dh_method DH_METHOD;
struct dsa_st ;
typedef struct dsa_st DSA;
struct dsa_method ;
typedef struct dsa_method DSA_METHOD;
struct rsa_st ;
typedef struct rsa_st RSA;
struct rsa_meth_st ;
typedef struct rsa_meth_st RSA_METHOD;
struct X509_algor_st ;
typedef struct X509_algor_st X509_ALGOR;
struct pkcs8_priv_key_info_st ;
typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;
struct crypto_ex_data_st ;
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(void const   * , void const   * ) ;
};
typedef struct stack_st _STACK;
struct bio_st ;
struct stack_st_void ;
struct crypto_ex_data_st {
   struct stack_st_void *sk ;
   int dummy ;
};
struct stack_st_void {
   _STACK stack ;
};
union __anonunion_cb_888073939 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_888073939 cb ;
};
typedef struct bio_st BIO;
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
typedef struct bio_method_st BIO_METHOD;
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char const   *data ;
   int flags ;
};
typedef struct asn1_object_st ASN1_OBJECT;
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
struct ASN1_VALUE_st ;
typedef struct ASN1_VALUE_st ASN1_VALUE;
union __anonunion_value_401497255 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
   ASN1_VALUE *asn1_value ;
};
struct asn1_type_st {
   int type ;
   union __anonunion_value_401497255 value ;
};
typedef struct asn1_type_st ASN1_TYPE;
union __anonunion_pkey_1024245030 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
   struct ec_key_st *ec ;
};
struct stack_st_X509_ATTRIBUTE ;
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   EVP_PKEY_ASN1_METHOD const   *ameth ;
   ENGINE *engine ;
   union __anonunion_pkey_1024245030 pkey ;
   int save_parameters ;
   struct stack_st_X509_ATTRIBUTE *attributes ;
};
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    size_t inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
struct buf_mem_st {
   size_t length ;
   char *data ;
   size_t max ;
};
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char const   *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
typedef struct DSA_SIG_st DSA_SIG;
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char const   *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
struct X509_sig_st {
   X509_ALGOR *algor ;
   ASN1_OCTET_STRING *digest ;
};
typedef struct X509_sig_st X509_SIG;
struct stack_st_X509_ATTRIBUTE {
   _STACK stack ;
};
struct pkcs8_priv_key_info_st {
   int broken ;
   ASN1_INTEGER *version ;
   X509_ALGOR *pkeyalg ;
   ASN1_TYPE *pkey ;
   struct stack_st_X509_ATTRIBUTE *attributes ;
};
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
struct __anonstruct_vg_protkey_parameters_t_1070732568 {
   int mode ;
   int iterations ;
   EVP_MD const   *(*pbkdf_hash_getter)(void) ;
   EVP_CIPHER const   *(*cipher_getter)(void) ;
};
typedef struct __anonstruct_vg_protkey_parameters_t_1070732568 vg_protkey_parameters_t;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-TRAokokX.i","-ggdb,-O3,-Wall")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                  char const   * __restrict  __fmt 
                                                                                                  , ...) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                 , ...) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                                             , ...) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                   char const   * __restrict  __fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                                              __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__gnu_inline__, __artificial__, __always_inline__)) snprintf)(char * __restrict  __s ,
                                                              size_t __n , char const   * __restrict  __fmt 
                                                              , ...) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__gnu_inline__, __artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                               size_t __n , char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   * __restrict  __fmt , __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   * __restrict  __fmt  , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void * __restrict  __ptr , size_t __size , size_t __n ,
                           FILE * __restrict  __stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void * __restrict  __ptr , size_t __size , size_t __n ,
                                    FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp___0 ;

  {
  tmp___0 = getc(stdin);
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = putc(__c, stdout);
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                                             , ...) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                            char const   * __restrict  __fmt 
                                                                                                            , ...) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__s, 1);
  tmp___1 = __builtin___sprintf_chk((char *)__s, 1, tmp___0, (char const   *)__fmt,
                                    __builtin_va_arg_pack());
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                                              __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                             char const   * __restrict  __fmt ,
                                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__s, 1);
  tmp___1 = __builtin___vsprintf_chk((char *)__s, 1, tmp___0, (char const   *)__fmt,
                                     __ap);
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__gnu_inline__, __artificial__, __always_inline__)) snprintf)(char * __restrict  __s ,
                                                              size_t __n , char const   * __restrict  __fmt 
                                                              , ...) ;
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__s, 1);
  tmp___1 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp___0, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__gnu_inline__, __artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                               size_t __n , char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__s, 1);
  tmp___1 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp___0, (char const   *)__fmt,
                                      __ap);
  return (tmp___1);
}
}
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                  char const   * __restrict  __fmt 
                                                                                                  , ...) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                 , ...) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __printf_chk(1, __fmt, __builtin_va_arg_pack());
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                   char const   * __restrict  __fmt ,
                                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  return (tmp___0);
}
}
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   * __restrict  __fmt  , ...) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
  return (tmp___0);
}
}
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   * __restrict  __fmt , __gnuc_va_list __ap ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  return (tmp___0);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char * __restrict  __s , int __n , FILE * __restrict  __stream ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__s, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__s, 1);
    tmp___1 = __fgets_chk(__s, tmp___0, __n, __stream);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__s, 1);
      tmp___3 = __fgets_chk_warn(__s, tmp___2, __n, __stream);
      return (tmp___3);
    }
  }
  tmp___6 = __fgets_alias(__s, __n, __stream);
  return (tmp___6);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void * __restrict  __ptr , size_t __size , size_t __n ,
                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__ptr, 0);
    tmp___1 = __fread_chk(__ptr, tmp___0, __size, __n, __stream);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__ptr, 0);
      tmp___3 = __fread_chk_warn(__ptr, tmp___2, __size, __n, __stream);
      return (tmp___3);
    }
  }
  tmp___6 = __fread_alias(__ptr, __size, __n, __stream);
  return (tmp___6);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void * __restrict  __ptr , size_t __size , size_t __n ,
                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___7 ;

  {
  tmp___5 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__ptr, 0);
    tmp___1 = __fread_unlocked_chk(__ptr, tmp___0, __size, __n, __stream);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__ptr, 0);
      tmp___3 = __fread_unlocked_chk_warn(__ptr, tmp___2, __size, __n, __stream);
      return (tmp___3);
    }
  }
  tmp___7 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  return (tmp___7);
}
}
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                      void const   * __restrict  __src ,
                                                                      size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) memmove)(void *__dest ,
                                                                       void const   *__src ,
                                                                       size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                      int __ch , size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                      char const   * __restrict  __src ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                       char const   * __restrict  __src ,
                                                                       size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                                      char const   * __restrict  __src ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                                       char const   * __restrict  __src ,
                                                                       size_t __len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) bcopy)(void const   *__src ,
                                                                     void *__dest ,
                                                                     size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                     size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) bcopy)(void const   *__src ,
                                                                     void *__dest ,
                                                                     size_t __len ) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size(__dest, 0);
  __builtin___memmove_chk(__dest, __src, __len, tmp___0);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                     size_t __len ) ;
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size(__dest, 0);
  __builtin___memset_chk(__dest, '\000', __len, tmp___0);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) explicit_bzero)(void *__dest ,
                                                                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                       char const   * __restrict  __src ,
                                                                       size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                      void const   * __restrict  __src ,
                                                                      size_t __len ) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                            size_t __len ) 
{ 
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__dest, 0);
  tmp___1 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp___0);
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) memmove)(void *__dest ,
                                                                       void const   *__src ,
                                                                       size_t __len ) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len ) 
{ 
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
  tmp___0 = __builtin_object_size(__dest, 0);
  tmp___1 = __builtin___memmove_chk(__dest, __src, __len, tmp___0);
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                      int __ch , size_t __len ) ;
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
  tmp___0 = __builtin_object_size(__dest, 0);
  tmp___1 = __builtin___memset_chk(__dest, __ch, __len, tmp___0);
  return (tmp___1);
}
}
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) __explicit_bzero_chk)(void *__dest ,
                                                                                                            size_t __len ,
                                                                                                            size_t __destlen ) ;
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) explicit_bzero)(void *__dest ,
                                                                              size_t __len ) ;
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size(__dest, 0);
  __explicit_bzero_chk(__dest, __len, tmp___0);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                      char const   * __restrict  __src ) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__dest, 1);
  tmp___1 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp___0);
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                       char const   * __restrict  __src ,
                                                                       size_t __len ) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__dest, 1);
  tmp___1 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp___0);
  return (tmp___1);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                       char const   * __restrict  __src ,
                                                                       size_t __n ) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __n ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
  tmp___2 = __builtin_object_size((void *)__dest, 1);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__dest, 1);
    tmp___1 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp___0);
    return (tmp___1);
  }
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                                      char const   * __restrict  __src ) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__dest, 1);
  tmp___1 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp___0);
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                                       char const   * __restrict  __src ,
                                                                       size_t __len ) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                                             size_t __len ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;

  {
  tmp___0 = __builtin_object_size((void *)__dest, 1);
  tmp___1 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp___0);
  return (tmp___1);
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                               pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp___0 ;

  {
  tmp___0 = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                   10);
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp___0 ;

  {
  tmp___0 = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                   10);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp___0 ;

  {
  tmp___0 = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                    10);
  return (tmp___0);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__, __alloc_size__(1))) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size )  __attribute__((__alloc_size__(2))) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                        char * __restrict  __resolved ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                      wchar_t __wchar ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp___0 ;

  {
  tmp___0 = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp___0);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                        char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
  tmp___2 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__resolved, 1);
    tmp___1 = __realpath_chk(__name, __resolved, tmp___0);
    return (tmp___1);
  }
  tmp___3 = __realpath_alias(__name, __resolved);
  return (tmp___3);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                              char *__buf ,
                                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __ptsname_r_chk(__fd, __buf, __buflen, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __ptsname_r_alias(__fd, __buf, __buflen);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                      wchar_t __wchar ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
  tmp___2 = __builtin_object_size((void *)__s, 1);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___3) {
      tmp___0 = __builtin_object_size((void *)__s, 1);
      tmp___1 = __wctomb_chk(__s, __wchar, tmp___0);
      return (tmp___1);
    }
  }
  tmp___4 = __wctomb_alias(__s, __wchar);
  return (tmp___4);
}
}
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) 
{ 
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__dst, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__dst, 1);
    tmp___1 = __mbstowcs_chk(__dst, __src, __len, tmp___0 / sizeof(wchar_t ));
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___4 / sizeof(wchar_t )) {
      tmp___2 = __builtin_object_size((void *)__dst, 1);
      tmp___3 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___2 / sizeof(wchar_t ));
      return (tmp___3);
    }
  }
  tmp___6 = __mbstowcs_alias(__dst, __src, __len);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) 
{ 
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__dst, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__dst, 1);
    tmp___1 = __wcstombs_chk(__dst, __src, __len, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__dst, 1);
      tmp___3 = __wcstombs_chk_warn(__dst, __src, __len, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __wcstombs_alias(__dst, __src, __len);
  return (tmp___6);
}
}
extern void CRYPTO_free(void *ptr ) ;
extern char *BN_bn2hex(BIGNUM const   *a ) ;
extern void EC_POINT_free(EC_POINT *point ) ;
extern char *EC_POINT_point2hex(EC_GROUP const   * , EC_POINT const   * , point_conversion_form_t form ,
                                BN_CTX * ) ;
extern EC_POINT *EC_POINT_hex2point(EC_GROUP const   * , char const   * , EC_POINT * ,
                                    BN_CTX * ) ;
extern int EC_POINT_cmp(EC_GROUP const   *group , EC_POINT const   *a , EC_POINT const   *b ,
                        BN_CTX *ctx ) ;
extern void EC_KEY_free(EC_KEY *key ) ;
extern EC_GROUP const   *EC_KEY_get0_group(EC_KEY const   *key ) ;
extern BIGNUM const   *EC_KEY_get0_private_key(EC_KEY const   *key ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__,
__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__,
__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__leaf__, __gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                           struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recv)(int __fd ,
                                                                                                   void *__buf ,
                                                                                                   size_t __n ,
                                                                                                   int __flags ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                                       void * __restrict  __buf ,
                                                                                                       size_t __n ,
                                                                                                       int __flags ,
                                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                                       socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recv)(int __fd ,
                                                                                                   void *__buf ,
                                                                                                   size_t __n ,
                                                                                                   int __flags ) 
{ 
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  ssize_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size(__buf, 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size(__buf, 0);
    tmp___1 = __recv_chk(__fd, __buf, __n, tmp___0, __flags);
    return (tmp___1);
    tmp___4 = __builtin_object_size(__buf, 0);
    if (__n > tmp___4) {
      tmp___2 = __builtin_object_size(__buf, 0);
      tmp___3 = __recv_chk_warn(__fd, __buf, __n, tmp___2, __flags);
      return (tmp___3);
    }
  }
  tmp___6 = __recv_alias(__fd, __buf, __n, __flags);
  return (tmp___6);
}
}
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                                       void * __restrict  __buf ,
                                                                                                       size_t __n ,
                                                                                                       int __flags ,
                                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                                       socklen_t * __restrict  __addr_len ) 
{ 
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  ssize_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 0);
    tmp___1 = __recvfrom_chk(__fd, __buf, __n, tmp___0, __flags, __addr, __addr_len);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 0);
    if (__n > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 0);
      tmp___3 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___2, __flags, __addr, __addr_len);
      return (tmp___3);
    }
  }
  tmp___6 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   void * __restrict  __tz ) ;
extern char const   *curl_easy_strerror(CURLcode  ) ;
extern CURL *curl_easy_init(void) ;
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
extern CURLcode curl_easy_perform(CURL *curl ) ;
extern void curl_easy_cleanup(CURL *curl ) ;
static void __attribute__((__warning__("curl_easy_setopt expects a long argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_long)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a long argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_long)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_off_t argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_off_t)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_off_t argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_off_t)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a string (\'char *\' or char[]) argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_string)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a string (\'char *\' or char[]) argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_string)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_write_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_write_callback)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_write_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_write_callback)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_resolver_start_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_resolver_start_callback)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_resolver_start_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_resolver_start_callback)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_read_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_read_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_read_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_read_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ioctl_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ioctl_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ioctl_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ioctl_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_sockopt_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_sockopt_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_sockopt_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_sockopt_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_opensocket_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_opensocket_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_opensocket_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_opensocket_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_progress_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_progress_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_progress_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_progress_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_debug_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_debug_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_debug_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_debug_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ssl_ctx_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ssl_ctx_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ssl_ctx_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ssl_ctx_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_conv_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_conv_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_conv_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_conv_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_seek_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_seek_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_seek_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_seek_cb)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a private data pointer as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_cb_data)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a private data pointer as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_cb_data)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a char buffer of CURL_ERROR_SIZE as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_error_buffer)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a char buffer of CURL_ERROR_SIZE as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_error_buffer)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'FILE *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_FILE)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'FILE *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_FILE)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'void *\' or \'char *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_postfields)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'void *\' or \'char *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_postfields)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_httppost *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_httpost)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_httppost *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_httpost)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'curl_mime *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_mimepost)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'curl_mime *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_mimepost)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_slist *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_slist)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_slist *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_slist)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a CURLSH* argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_CURLSH)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a CURLSH* argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_CURLSH)(void) 
{ 


  {
  __asm__  ("":);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__, __gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename ,
                                    struct stat * __restrict  __statbuf , int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode ,
                                    __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver ,
                                                                                               int __fildes ,
                                                                                               struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int __ver ,
                                                                                                char const   *__filename ,
                                                                                                struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int __ver ,
                                                                                                 char const   *__filename ,
                                                                                                 struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int __ver ,
                                                                                                   int __fildes ,
                                                                                                   char const   *__filename ,
                                                                                                   struct stat *__stat_buf ,
                                                                                                   int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int __ver ,
                                                                                                 char const   *__path ,
                                                                                                 __mode_t __mode ,
                                                                                                 __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int __ver ,
                                                                                                   int __fd ,
                                                                                                   char const   *__path ,
                                                                                                   __mode_t __mode ,
                                                                                                   __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                                        struct stat * __restrict  __statbuf ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                                         struct stat * __restrict  __statbuf ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) fstat)(int __fd ,
                                                                                       struct stat *__statbuf ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __fxstat(1, __fd, __statbuf);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__, __gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename ,
                                    struct stat * __restrict  __statbuf , int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __leaf__, __gnu_inline__)) fstatat)(int __fd ,
                                                                                           char const   * __restrict  __filename ,
                                                                                           struct stat * __restrict  __statbuf ,
                                                                                           int __flag ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                       __flag);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__)) mknod)(char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t __dev ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __xmknod(0, __path, __mode, & __dev);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode ,
                                    __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) mknodat)(int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t __dev ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp___0);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                      size_t __size ) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                         __gid_t *__list ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                          char * __restrict  __buf ,
                                                                                          size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                                            char const   * __restrict  __path ,
                                                                                            char * __restrict  __buf ,
                                                                                            size_t __len ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
extern char *optarg ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt)(int ___argc ,
                                                                                               char * const  *___argv ,
                                                                                               char const   *__shortopts ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                           size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                                             size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) 
{ 
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  ssize_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size(__buf, 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size(__buf, 0);
    tmp___1 = __read_chk(__fd, __buf, __nbytes, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___4) {
      tmp___2 = __builtin_object_size(__buf, 0);
      tmp___3 = __read_chk_warn(__fd, __buf, __nbytes, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __read_alias(__fd, __buf, __nbytes);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                          char * __restrict  __buf ,
                                                                                          size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                        char * __restrict  __buf ,
                                                                        size_t __len ) 
{ 
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  ssize_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __readlink_chk(__path, __buf, __len, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __readlink_chk_warn(__path, __buf, __len, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __readlink_alias(__path, __buf, __len);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                                            char const   * __restrict  __path ,
                                                                                            char * __restrict  __buf ,
                                                                                            size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) 
{ 
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  ssize_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __readlinkat_chk(__fd, __path, __buf, __len, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __readlinkat_alias(__fd, __path, __buf, __len);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                      size_t __size ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __getcwd_chk(__buf, __size, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__size > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __getcwd_chk_warn(__buf, __size, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __getcwd_alias(__buf, __size);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
  tmp___2 = __builtin_object_size((void *)__buf, 1);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __getwd_chk(__buf, tmp___0);
    return ((char __attribute__((__deprecated__))  *)tmp___1);
  }
  tmp___3 = __getwd_warn(__buf);
  return ((char __attribute__((__deprecated__))  *)tmp___3);
}
}
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) 
{ 
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __confstr_chk(__name, __buf, __len, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (tmp___4 < __len) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __confstr_chk_warn(__name, __buf, __len, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __confstr_alias(__name, __buf, __len);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                         __gid_t *__list ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__list, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__list, 1);
    tmp___1 = __getgroups_chk(__size, __list, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__list, 1);
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__list, 1);
      tmp___3 = __getgroups_chk_warn(__size, __list, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __getgroups_alias(__size, __list);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __ttyname_r_chk(__fd, __buf, __buflen, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __ttyname_r_alias(__fd, __buf, __buflen);
  return (tmp___6);
}
}
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __getlogin_r_chk(__buf, __buflen, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __getlogin_r_chk_warn(__buf, __buflen, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __getlogin_r_alias(__buf, __buflen);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                           size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __gethostname_chk(__buf, __buflen, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __gethostname_chk_warn(__buf, __buflen, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __gethostname_alias(__buf, __buflen);
  return (tmp___6);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                                             size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__buf, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___0 = __builtin_object_size((void *)__buf, 1);
    tmp___1 = __getdomainname_chk(__buf, __buflen, tmp___0);
    return (tmp___1);
    tmp___4 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___4) {
      tmp___2 = __builtin_object_size((void *)__buf, 1);
      tmp___3 = __getdomainname_chk_warn(__buf, __buflen, tmp___2);
      return (tmp___3);
    }
  }
  tmp___6 = __getdomainname_alias(__buf, __buflen);
  return (tmp___6);
}
}
int vg_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                            int npatterns ) ;
void vg_context_clear_all_patterns(vg_context_t *vcp ) ;
int vg_context_start_threads(vg_context_t *vcp ) ;
void vg_context_stop_threads(vg_context_t *vcp ) ;
vg_context_t *vg_prefix_context_new(int addrtype , int privtype , int caseinsensitive ) ;
double vg_prefix_get_difficulty(int addrtype , char const   *pattern ) ;
void vg_output_match_console(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern ) ;
void vg_output_timing_console(vg_context_t *vcp , double count , unsigned long long rate ,
                              unsigned long long total ) ;
EC_KEY *vg_exec_context_new_key(void) ;
vg_ocl_context_t *vg_ocl_context_new(vg_context_t *vcp , int platformidx , int deviceidx ,
                                     int safe_mode , int verify , int worksize , int nthreads ,
                                     int nrows , int ncols , int invsize ) ;
vg_ocl_context_t *vg_ocl_context_new_from_devstr(vg_context_t *vcp , char const   *devstr ,
                                                 int safemode , int verify ) ;
void vg_ocl_enumerate_devices(void) ;
int vg_b58_decode_check(char const   *input , void *buf , size_t len ) ;
__inline static void avl_root_init(avl_root_t *rootp ) 
{ 


  {
  rootp->ar_root = (avl_item_t *)((void *)0);
  return;
}
}
__inline static int avl_root_empty(avl_root_t *rootp ) 
{ 
  int tmp___0 ;

  {
  if ((unsigned long )rootp->ar_root == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
__inline static void avl_item_init(avl_item_t *itemp ) 
{ 


  {
  itemp->ai_left = (struct _avl_item_s *)((void *)0);
  itemp->ai_right = (struct _avl_item_s *)((void *)0);
  itemp->ai_up = (struct _avl_item_s *)((void *)0);
  itemp->ai_balance = (avl_balance_t )1;
  itemp->ai_indexed = 0;
  return;
}
}
__inline static void _avl_rotate_ll(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *tmp___0 ;

  {
  tmp___0 = itemp->ai_left;
  itemp->ai_left = tmp___0->ai_right;
  if (itemp->ai_left) {
    (itemp->ai_left)->ai_up = itemp;
  }
  tmp___0->ai_right = itemp;
  if (itemp->ai_up) {
    if ((unsigned long )(itemp->ai_up)->ai_left == (unsigned long )itemp) {
      (itemp->ai_up)->ai_left = tmp___0;
    } else {
      if (! ((unsigned long )(itemp->ai_up)->ai_right == (unsigned long )itemp)) {
        __assert_fail("itemp->ai_up->ai_right == itemp", "avl.h", 89U, "_avl_rotate_ll");
      }
      (itemp->ai_up)->ai_right = tmp___0;
    }
  } else {
    rootp->ar_root = tmp___0;
  }
  tmp___0->ai_up = itemp->ai_up;
  itemp->ai_up = tmp___0;
  return;
}
}
__inline static void _avl_rotate_lr(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *rcp ;
  avl_item_t *rlcp ;

  {
  rcp = itemp->ai_left;
  rlcp = rcp->ai_right;
  if (itemp->ai_up) {
    if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left) {
      (itemp->ai_up)->ai_left = rlcp;
    } else {
      if (! ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_right)) {
        __assert_fail("itemp == itemp->ai_up->ai_right", "avl.h", 109U, "_avl_rotate_lr");
      }
      (itemp->ai_up)->ai_right = rlcp;
    }
  } else {
    rootp->ar_root = rlcp;
  }
  rlcp->ai_up = itemp->ai_up;
  rcp->ai_right = rlcp->ai_left;
  if (rcp->ai_right) {
    (rcp->ai_right)->ai_up = rcp;
  }
  itemp->ai_left = rlcp->ai_right;
  if (itemp->ai_left) {
    (itemp->ai_left)->ai_up = itemp;
  }
  rlcp->ai_left = rcp;
  rlcp->ai_right = itemp;
  rcp->ai_up = rlcp;
  itemp->ai_up = rlcp;
  return;
}
}
__inline static void _avl_rotate_rr(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *tmp___0 ;

  {
  tmp___0 = itemp->ai_right;
  itemp->ai_right = tmp___0->ai_left;
  if (itemp->ai_right) {
    (itemp->ai_right)->ai_up = itemp;
  }
  tmp___0->ai_left = itemp;
  if (itemp->ai_up) {
    if ((unsigned long )(itemp->ai_up)->ai_right == (unsigned long )itemp) {
      (itemp->ai_up)->ai_right = tmp___0;
    } else {
      if (! ((unsigned long )(itemp->ai_up)->ai_left == (unsigned long )itemp)) {
        __assert_fail("itemp->ai_up->ai_left == itemp", "avl.h", 142U, "_avl_rotate_rr");
      }
      (itemp->ai_up)->ai_left = tmp___0;
    }
  } else {
    rootp->ar_root = tmp___0;
  }
  tmp___0->ai_up = itemp->ai_up;
  itemp->ai_up = tmp___0;
  return;
}
}
__inline static void _avl_rotate_rl(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *rcp ;
  avl_item_t *rlcp ;

  {
  rcp = itemp->ai_right;
  rlcp = rcp->ai_left;
  if (itemp->ai_up) {
    if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_right) {
      (itemp->ai_up)->ai_right = rlcp;
    } else {
      if (! ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left)) {
        __assert_fail("itemp == itemp->ai_up->ai_left", "avl.h", 162U, "_avl_rotate_rl");
      }
      (itemp->ai_up)->ai_left = rlcp;
    }
  } else {
    rootp->ar_root = rlcp;
  }
  rlcp->ai_up = itemp->ai_up;
  rcp->ai_left = rlcp->ai_right;
  if (rcp->ai_left) {
    (rcp->ai_left)->ai_up = rcp;
  }
  itemp->ai_right = rlcp->ai_left;
  if (itemp->ai_right) {
    (itemp->ai_right)->ai_up = itemp;
  }
  rlcp->ai_right = rcp;
  rlcp->ai_left = itemp;
  rcp->ai_up = rlcp;
  itemp->ai_up = rlcp;
  return;
}
}
static void avl_delete_fix(avl_root_t *rootp , avl_item_t *itemp , avl_item_t *parentp ) 
{ 
  avl_item_t *childp ;

  {
  if ((unsigned long )parentp->ai_left == (unsigned long )((void *)0)) {
    if ((unsigned long )parentp->ai_right == (unsigned long )((void *)0)) {
      if (! ((unsigned long )itemp == (unsigned long )((void *)0))) {
        __assert_fail("itemp == NULL", "avl.h", 188U, "avl_delete_fix");
      }
      parentp->ai_balance = (avl_balance_t )1;
      itemp = parentp;
      parentp = itemp->ai_up;
    }
  }
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_right) {
      itemp = parentp->ai_left;
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )2;
          parentp->ai_balance = (avl_balance_t )0;
          break;
        } else {
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    } else {
      itemp = parentp->ai_right;
      if ((unsigned int )parentp->ai_balance == 2U) {
        if ((unsigned int )itemp->ai_balance == 2U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )0;
          parentp->ai_balance = (avl_balance_t )2;
          break;
        } else {
          childp = itemp->ai_left;
          _avl_rotate_rl(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            parentp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            itemp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )2;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
static void avl_insert_fix(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *childp ;
  avl_item_t *parentp ;
  struct _avl_item_s *tmp___0 ;

  {
  parentp = itemp->ai_up;
  tmp___0 = (struct _avl_item_s *)((void *)0);
  itemp->ai_right = tmp___0;
  itemp->ai_left = tmp___0;
  if (! (! itemp->ai_indexed)) {
    __assert_fail("!itemp->ai_indexed", "avl.h", 275U, "avl_insert_fix");
  }
  itemp->ai_indexed = 1;
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          break;
        } else {
          if (! ((unsigned int )itemp->ai_balance != 1U)) {
            __assert_fail("itemp->ai_balance != CENT", "avl.h", 290U, "avl_insert_fix");
          }
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          break;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
        return;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 2U) {
      if ((unsigned int )itemp->ai_balance == 2U) {
        _avl_rotate_rr(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        break;
      } else {
        if (! ((unsigned int )itemp->ai_balance != 1U)) {
          __assert_fail("itemp->ai_balance != CENT", "avl.h", 316U, "avl_insert_fix");
        }
        childp = itemp->ai_left;
        _avl_rotate_rl(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        if ((unsigned int )childp->ai_balance == 2U) {
          parentp->ai_balance = (avl_balance_t )0;
        }
        if ((unsigned int )childp->ai_balance == 0U) {
          itemp->ai_balance = (avl_balance_t )2;
        }
        childp->ai_balance = (avl_balance_t )1;
        break;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 1U) {
      parentp->ai_balance = (avl_balance_t )2;
    } else {
      parentp->ai_balance = (avl_balance_t )1;
      break;
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
__inline static avl_item_t *avl_first(avl_root_t *rootp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = rootp->ar_root;
  if (itemp) {
    while (itemp->ai_left) {
      itemp = itemp->ai_left;
    }
  }
  return (itemp);
}
}
__inline static avl_item_t *avl_next(avl_item_t *itemp ) 
{ 


  {
  if (itemp->ai_right) {
    itemp = itemp->ai_right;
    while (itemp->ai_left) {
      itemp = itemp->ai_left;
    }
    return (itemp);
  }
  while (1) {
    if (itemp->ai_up) {
      if (! ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_right)) {
        break;
      }
    } else {
      break;
    }
    itemp = itemp->ai_up;
  }
  if (! itemp->ai_up) {
    return ((avl_item_t *)((void *)0));
  }
  return (itemp->ai_up);
}
}
static void avl_remove(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *relocp ;
  avl_item_t *replacep ;
  avl_item_t *parentp ;

  {
  parentp = (avl_item_t *)((void *)0);
  if (! itemp->ai_indexed) {
    __assert_fail("itemp->ai_indexed", "avl.h", 376U, "avl_remove");
  }
  itemp->ai_indexed = 0;
  if ((unsigned long )itemp->ai_left == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )itemp->ai_right == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    parentp = itemp->ai_up;
    replacep = itemp->ai_left;
    if ((unsigned long )replacep == (unsigned long )((void *)0)) {
      replacep = itemp->ai_right;
    }
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = parentp;
    }
    if ((unsigned long )parentp == (unsigned long )((void *)0)) {
      rootp->ar_root = replacep;
    } else {
      if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
        parentp->ai_left = replacep;
      } else {
        parentp->ai_right = replacep;
      }
      avl_delete_fix(rootp, replacep, parentp);
    }
    return;
  }
  relocp = avl_next(itemp);
  if (! relocp) {
    __assert_fail("relocp", "avl.h", 405U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_up != (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_up != NULL", "avl.h", 406U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_left == (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_left == NULL", "avl.h", 407U, "avl_remove");
  }
  replacep = relocp->ai_right;
  relocp->ai_left = itemp->ai_left;
  if ((unsigned long )relocp->ai_left != (unsigned long )((void *)0)) {
    (relocp->ai_left)->ai_up = relocp;
  }
  if ((unsigned long )itemp->ai_up == (unsigned long )((void *)0)) {
    rootp->ar_root = relocp;
  } else
  if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left) {
    (itemp->ai_up)->ai_left = relocp;
  } else {
    (itemp->ai_up)->ai_right = relocp;
  }
  if ((unsigned long )relocp == (unsigned long )(relocp->ai_up)->ai_left) {
    if (! ((unsigned long )relocp->ai_up != (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up != itemp", "avl.h", 421U, "avl_remove");
    }
    (relocp->ai_up)->ai_left = replacep;
    parentp = relocp->ai_up;
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = relocp->ai_up;
    }
    relocp->ai_right = itemp->ai_right;
  } else {
    if (! ((unsigned long )relocp->ai_up == (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up == itemp", "avl.h", 428U, "avl_remove");
    }
    relocp->ai_right = replacep;
    parentp = relocp;
  }
  if ((unsigned long )relocp->ai_right != (unsigned long )((void *)0)) {
    (relocp->ai_right)->ai_up = relocp;
  }
  relocp->ai_up = itemp->ai_up;
  relocp->ai_balance = itemp->ai_balance;
  avl_delete_fix(rootp, replacep, parentp);
  return;
}
}
char const   *version  =    "0.22";
int const   debug  =    (int const   )0;
static int workitem_cmp(workitem_t *a , workitem_t *b ) 
{ 
  int cmpres ;
  int tmp___0 ;

  {
  cmpres = strcmp(a->pattern, b->pattern);
  if (! cmpres) {
    if (a->reward < b->reward) {
      cmpres = -1;
    } else {
      if (a->reward > b->reward) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      cmpres = tmp___0;
    }
  }
  return (cmpres);
}
}
static workitem_t *workitem_avl_search(avl_root_t *rootp , char const   *pattern ) 
{ 
  workitem_t *vp ;
  avl_item_t *itemp ;
  int cmpres ;

  {
  itemp = rootp->ar_root;
  while (itemp) {
    vp = (workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent));
    cmpres = strcmp(vp->pattern, pattern);
    if (cmpres > 0) {
      itemp = itemp->ai_left;
    } else
    if (cmpres < 0) {
      itemp = itemp->ai_right;
    } else {
      return (vp);
    }
  }
  return ((workitem_t *)((void *)0));
}
}
static workitem_t *workitem_avl_insert(avl_root_t *rootp , workitem_t *vpnew ) 
{ 
  workitem_t *vp ;
  avl_item_t *itemp ;
  avl_item_t **ptrp ;
  int cmpres ;

  {
  itemp = (avl_item_t *)((void *)0);
  ptrp = & rootp->ar_root;
  while (*ptrp) {
    itemp = *ptrp;
    vp = (workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent));
    cmpres = workitem_cmp(vp, vpnew);
    if (cmpres > 0) {
      ptrp = & itemp->ai_left;
    } else
    if (cmpres < 0) {
      ptrp = & itemp->ai_right;
    } else {
      return (vp);
    }
  }
  vpnew->avlent.ai_up = itemp;
  itemp = & vpnew->avlent;
  *ptrp = itemp;
  avl_insert_fix(rootp, itemp);
  return ((workitem_t *)((void *)0));
}
}
static workitem_t *workitem_avl_first(avl_root_t *rootp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = avl_first(rootp);
  if (itemp) {
    return ((workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent)));
  }
  return ((workitem_t *)((void *)0));
}
}
static workitem_t *workitem_avl_next(workitem_t *vp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = & vp->avlent;
  itemp = avl_next(itemp);
  if (itemp) {
    return ((workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent)));
  }
  return ((workitem_t *)((void *)0));
}
}
void server_workitem_free(workitem_t *wip ) 
{ 


  {
  if (wip->pubkey) {
    EC_POINT_free(wip->pubkey);
  }
  free((void *)wip);
  return;
}
}
void server_batch_free(pubkeybatch_t *pbatch ) 
{ 
  workitem_t *wip ;

  {
  while (1) {
    wip = workitem_avl_first(& pbatch->items);
    if (! ((unsigned long )wip != (unsigned long )((void *)0))) {
      break;
    }
    if ((unsigned long )wip->pubkey == (unsigned long )pbatch->pubkey) {
      wip->pubkey = (EC_POINT *)((void *)0);
    }
    avl_remove(& pbatch->items, & wip->avlent);
    server_workitem_free(wip);
  }
  if (pbatch->pubkey) {
    EC_POINT_free(pbatch->pubkey);
  }
  if (pbatch->pubkey_hex) {
    CRYPTO_free((void *)((char *)pbatch->pubkey_hex));
  }
  free((void *)pbatch);
  return;
}
}
static int pubkeybatch_cmp(pubkeybatch_t *a , pubkeybatch_t *b ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = strcmp(a->pubkey_hex, b->pubkey_hex);
  return (tmp___0);
}
}
static pubkeybatch_t *pubkeybatch_avl_search(avl_root_t *rootp , EC_POINT const   *pubkey ,
                                             EC_GROUP const   *pgroup ) 
{ 
  char *pubkey_hex ;
  pubkeybatch_t *vp ;
  avl_item_t *itemp ;
  int cmpres ;

  {
  itemp = rootp->ar_root;
  pubkey_hex = EC_POINT_point2hex(pgroup, pubkey, (point_conversion_form_t )4, (BN_CTX *)((void *)0));
  while (itemp) {
    vp = (pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent));
    cmpres = strcmp((char const   *)pubkey_hex, vp->pubkey_hex);
    if (cmpres > 0) {
      itemp = itemp->ai_left;
    } else
    if (cmpres < 0) {
      itemp = itemp->ai_right;
    } else {
      CRYPTO_free((void *)pubkey_hex);
      return (vp);
    }
  }
  CRYPTO_free((void *)pubkey_hex);
  return ((pubkeybatch_t *)((void *)0));
}
}
static pubkeybatch_t *pubkeybatch_avl_insert(avl_root_t *rootp , pubkeybatch_t *vpnew ) 
{ 
  pubkeybatch_t *vp ;
  avl_item_t *itemp ;
  avl_item_t **ptrp ;
  int cmpres ;

  {
  itemp = (avl_item_t *)((void *)0);
  ptrp = & rootp->ar_root;
  while (*ptrp) {
    itemp = *ptrp;
    vp = (pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent));
    cmpres = pubkeybatch_cmp(vpnew, vp);
    if (cmpres > 0) {
      ptrp = & itemp->ai_left;
    } else
    if (cmpres < 0) {
      ptrp = & itemp->ai_right;
    } else {
      return (vp);
    }
  }
  vpnew->avlent.ai_up = itemp;
  itemp = & vpnew->avlent;
  *ptrp = itemp;
  avl_insert_fix(rootp, itemp);
  return ((pubkeybatch_t *)((void *)0));
}
}
static pubkeybatch_t *pubkeybatch_avl_first(avl_root_t *rootp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = avl_first(rootp);
  if (itemp) {
    return ((pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent)));
  }
  return ((pubkeybatch_t *)((void *)0));
}
}
static pubkeybatch_t *pubkeybatch_avl_next(pubkeybatch_t *vp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = & vp->avlent;
  itemp = avl_next(itemp);
  if (itemp) {
    return ((pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent)));
  }
  return ((pubkeybatch_t *)((void *)0));
}
}
static workitem_t *server_workitem_new(server_request_t *reqp , char const   *pfx ,
                                       char const   *pubkey_s , char const   *addrtype_s ,
                                       char const   *reward_s , char const   *comment ) 
{ 
  workitem_t *wip ;
  EC_POINT *pubkey ;
  int addrtype ;
  double reward ;
  double difficulty ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;

  {
  addrtype = atoi(addrtype_s);
  if (addrtype < 0) {
    return ((workitem_t *)((void *)0));
  } else
  if (addrtype > 255) {
    return ((workitem_t *)((void *)0));
  }
  reward = strtod((char const   * __restrict  )reward_s, (char ** __restrict  )((void *)0));
  if (reward < 0.0) {
    return ((workitem_t *)((void *)0));
  }
  difficulty = vg_prefix_get_difficulty(addrtype, pfx);
  if (difficulty == 0.0) {
    return ((workitem_t *)((void *)0));
  }
  pubkey = EC_POINT_hex2point(reqp->group, pubkey_s, (EC_POINT *)((void *)0), (BN_CTX *)((void *)0));
  if ((unsigned long )pubkey == (unsigned long )((void *)0)) {
    return ((workitem_t *)((void *)0));
  }
  tmp___0 = strlen(pfx);
  tmp___1 = strlen(comment);
  tmp___2 = malloc(((sizeof(*wip) + tmp___0) + tmp___1) + 2UL);
  wip = (workitem_t *)tmp___2;
  memset((void *)wip, 0, sizeof(*wip));
  avl_item_init(& wip->avlent);
  wip->pattern = (char const   *)((char *)(wip + 1));
  strcpy((char * __restrict  )((char *)wip->pattern), (char const   * __restrict  )pfx);
  tmp___3 = strlen(wip->pattern);
  wip->comment = wip->pattern + (tmp___3 + 1UL);
  strcpy((char * __restrict  )((char *)wip->comment), (char const   * __restrict  )comment);
  wip->pubkey = pubkey;
  wip->addrtype = addrtype;
  wip->difficulty = difficulty;
  wip->reward = reward;
  wip->value = (reward * 1000000000.0) / difficulty;
  return (wip);
}
}
static int server_workitem_equal(workitem_t *a , workitem_t *b ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  if (a->reward == b->reward) {
    tmp___0 = strcmp(a->pattern, b->pattern);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static int server_pubkeybatch_equal(server_context_t *ctxp , pubkeybatch_t *a , pubkeybatch_t *b ) 
{ 
  workitem_t *wipa ;
  workitem_t *wipb ;
  EC_GROUP const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (a->nitems != b->nitems) {
    return (0);
  }
  tmp___0 = EC_KEY_get0_group((EC_KEY const   *)ctxp->dummy_key);
  tmp___1 = EC_POINT_cmp(tmp___0, (EC_POINT const   *)a->pubkey, (EC_POINT const   *)b->pubkey,
                         (BN_CTX *)((void *)0));
  if (tmp___1) {
    return (0);
  }
  wipa = workitem_avl_first(& a->items);
  wipb = workitem_avl_first(& b->items);
  while (1) {
    if (wipa) {
      if (! wipb) {
        break;
      }
    } else {
      break;
    }
    tmp___2 = server_workitem_equal(wipa, wipb);
    if (! tmp___2) {
      return (0);
    }
    wipa = workitem_avl_next(wipa);
    wipb = workitem_avl_next(wipb);
  }
  return (1);
}
}
void server_context_free(server_context_t *ctxp ) 
{ 


  {
  if (ctxp->dummy_key) {
    EC_KEY_free(ctxp->dummy_key);
  }
  if (ctxp->getwork) {
    free((void *)ctxp->getwork);
  }
  if (ctxp->submit) {
    free((void *)ctxp->submit);
  }
  free((void *)ctxp);
  return;
}
}
server_context_t *server_context_new(char const   *url , char const   *credit_addr ) 
{ 
  server_context_t *ctxp ;
  int urllen ;
  size_t tmp___0 ;
  int addrlen ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp___0 = strlen(url);
  urllen = (int )tmp___0;
  tmp___1 = strlen(credit_addr);
  addrlen = (int )tmp___1;
  tmp___2 = malloc(((sizeof(*ctxp) + (unsigned long )urllen) + (unsigned long )addrlen) + 2UL);
  ctxp = (server_context_t *)tmp___2;
  memset((void *)ctxp, 0, sizeof(*ctxp));
  avl_root_init(& ctxp->items);
  ctxp->url = (char const   *)(ctxp + 1);
  ctxp->credit_addr = (ctxp->url + urllen) + 1;
  strcpy((char * __restrict  )((char *)ctxp->url), (char const   * __restrict  )url);
  strcpy((char * __restrict  )((char *)ctxp->credit_addr), (char const   * __restrict  )credit_addr);
  ctxp->dummy_key = vg_exec_context_new_key();
  tmp___3 = malloc((size_t )(urllen + 9));
  ctxp->getwork = (char *)tmp___3;
  tmp___4 = malloc((size_t )(urllen + 7));
  ctxp->submit = (char *)tmp___4;
  if ((int const   )*(url + (urllen - 1)) == 47) {
    snprintf((char * __restrict  )ctxp->getwork, (size_t )(urllen + 9), (char const   * __restrict  )"%sgetWork",
             url);
    snprintf((char * __restrict  )ctxp->submit, (size_t )(urllen + 7), (char const   * __restrict  )"%ssolve",
             url);
  } else {
    snprintf((char * __restrict  )ctxp->getwork, (size_t )(urllen + 9), (char const   * __restrict  )"%s/getWork",
             url);
    snprintf((char * __restrict  )ctxp->submit, (size_t )(urllen + 7), (char const   * __restrict  )"%s/solve",
             url);
  }
  return (ctxp);
}
}
int server_workitem_add(server_request_t *reqp , workitem_t *wip ) 
{ 
  workitem_t *xwip ;
  pubkeybatch_t *pbatch ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  pbatch = (pubkeybatch_t *)((void *)0);
  pbatch = pubkeybatch_avl_search(& reqp->items, (EC_POINT const   *)wip->pubkey,
                                  reqp->group);
  if ((unsigned long )pbatch == (unsigned long )((void *)0)) {
    tmp___0 = malloc(sizeof(*pbatch));
    pbatch = (pubkeybatch_t *)tmp___0;
    if ((unsigned long )pbatch == (unsigned long )((void *)0)) {
      return (-1);
    }
    memset((void *)pbatch, 0, sizeof(*pbatch));
    avl_item_init(& pbatch->avlent);
    avl_root_init(& pbatch->items);
    pbatch->total_value = (double )0;
    pbatch->pubkey = wip->pubkey;
    tmp___1 = EC_POINT_point2hex(reqp->group, (EC_POINT const   *)wip->pubkey, (point_conversion_form_t )4,
                                 (BN_CTX *)((void *)0));
    pbatch->pubkey_hex = (char const   *)tmp___1;
    pubkeybatch_avl_insert(& reqp->items, pbatch);
    (reqp->nitems) ++;
  }
  xwip = workitem_avl_insert(& pbatch->items, wip);
  if (xwip) {
    return (-1);
  }
  if (wip->pubkey) {
    if ((unsigned long )wip->pubkey != (unsigned long )pbatch->pubkey) {
      EC_POINT_free(wip->pubkey);
    }
  }
  wip->pubkey = pbatch->pubkey;
  (pbatch->nitems) ++;
  pbatch->total_value += wip->value;
  return (0);
}
}
static size_t server_body_reader(char const   *buf , size_t elemsize , size_t len ,
                                 void *param ) 
{ 
  server_request_t *reqp ;
  char *line ;
  char *sep ;
  char *pfx ;
  char *pubkey_s ;
  char *addrtype_s ;
  char *reward_s ;
  char *comment ;
  workitem_t *wip ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  reqp = (server_request_t *)param;
  if (! len) {
    return ((size_t )0);
  }
  if (reqp->part_size < (reqp->part_end + len) + 1UL) {
    if (reqp->part_off > 0UL) {
      memmove((void *)reqp->part_buf, (void const   *)(reqp->part_buf + reqp->part_off),
              reqp->part_end - reqp->part_off);
      reqp->part_end -= reqp->part_off;
      reqp->part_off = (size_t )0;
    }
  }
  if (reqp->part_size < (reqp->part_end + len) + 1UL) {
    if (reqp->part_size == 0UL) {
      reqp->part_size = (size_t )4096;
    }
    while (reqp->part_size < (reqp->part_end + len) + 1UL) {
      reqp->part_size *= 2UL;
      if (reqp->part_size > 1048576UL) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Line too long from server");
        reqp->request_status = 0;
        return ((size_t )0);
      }
    }
    tmp___0 = realloc((void *)reqp->part_buf, reqp->part_size);
    reqp->part_buf = (char *)tmp___0;
    if (! reqp->part_buf) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory");
      return ((size_t )0);
    }
  }
  memcpy((void * __restrict  )(reqp->part_buf + reqp->part_end), (void const   * __restrict  )buf,
         len);
  reqp->part_end += len;
  *(reqp->part_buf + reqp->part_end) = (char )'\000';
  line = reqp->part_buf + reqp->part_off;
  while (1) {
    sep = strchr((char const   *)line, '\n');
    if (! sep) {
      break;
    }
    pfx = line;
    *sep = (char )'\000';
    line = sep + 1;
    sep = strchr((char const   *)pfx, ':');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    pubkey_s = sep;
    sep = strchr((char const   *)sep, ':');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    addrtype_s = sep;
    sep = strchr((char const   *)sep, ':');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    reward_s = sep;
    sep = strchr((char const   *)sep, ';');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    comment = sep;
    wip = server_workitem_new(reqp, (char const   *)pfx, (char const   *)pubkey_s,
                              (char const   *)addrtype_s, (char const   *)reward_s,
                              (char const   *)comment);
    if (! wip) {
      goto bad_line;
    }
    tmp___1 = server_workitem_add(reqp, wip);
    if (tmp___1) {
      server_workitem_free(wip);
      goto bad_line;
    }
    continue;
    bad_line: ;
  }
  reqp->part_off = (size_t )(line - reqp->part_buf);
  if (reqp->part_off == reqp->part_end) {
    reqp->part_off = (size_t )0;
    reqp->part_end = (size_t )0;
  }
  return (len);
}
}
void dump_work(avl_root_t *work ) 
{ 
  pubkeybatch_t *pbatch ;
  workitem_t *wip ;

  {
  printf((char const   * __restrict  )"Available bounties:\n");
  pbatch = pubkeybatch_avl_first(work);
  while ((unsigned long )pbatch != (unsigned long )((void *)0)) {
    wip = workitem_avl_first(& pbatch->items);
    while ((unsigned long )wip != (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"Pattern: \"%s\" Reward: %f Value: %f BTC/Gkey\n",
             wip->pattern, wip->reward, wip->value);
      wip = workitem_avl_next(wip);
    }
    if (pbatch->nitems > 1) {
      printf((char const   * __restrict  )"Batch of %d, total value: %f BTC/Gkey\n",
             pbatch->nitems, pbatch->total_value);
    }
    pbatch = pubkeybatch_avl_next(pbatch);
  }
  return;
}
}
void free_pkb_tree(avl_root_t *rootp , pubkeybatch_t *save_pkb ) 
{ 
  pubkeybatch_t *pkb ;

  {
  while (1) {
    pkb = pubkeybatch_avl_first(rootp);
    if (! ((unsigned long )pkb != (unsigned long )((void *)0))) {
      break;
    }
    avl_remove(rootp, & pkb->avlent);
    if ((unsigned long )pkb != (unsigned long )save_pkb) {
      server_batch_free(pkb);
    }
  }
  return;
}
}
void server_request_free(server_request_t *reqp ) 
{ 
  int tmp___0 ;

  {
  if ((unsigned long )reqp->part_buf != (unsigned long )((void *)0)) {
    free((void *)reqp->part_buf);
  }
  tmp___0 = avl_root_empty(& reqp->items);
  if (! tmp___0) {
    free_pkb_tree(& reqp->items, (pubkeybatch_t *)((void *)0));
  }
  free((void *)reqp);
  return;
}
}
int server_context_getwork(server_context_t *ctxp ) 
{ 
  CURLcode res ;
  server_request_t *reqp ;
  CURL *creq ;
  void *tmp___0 ;
  int _curl_opt ;
  int tmp___1 ;
  int tmp___2 ;
  CURLcode tmp___3 ;
  int _curl_opt___0 ;
  int tmp___4 ;
  CURLcode tmp___5 ;
  int _curl_opt___1 ;
  int tmp___6 ;
  CURLcode tmp___7 ;
  int _curl_opt___2 ;
  int tmp___8 ;
  CURLcode tmp___9 ;
  int _curl_opt___3 ;
  CURLcode tmp___10 ;
  char const   *tmp___11 ;

  {
  tmp___0 = malloc(sizeof(*reqp));
  reqp = (server_request_t *)tmp___0;
  memset((void *)reqp, 0, sizeof(*reqp));
  reqp->group = EC_KEY_get0_group((EC_KEY const   *)ctxp->dummy_key);
  creq = curl_easy_init();
  _curl_opt = 10002;
  if (0) {
    if (0 < _curl_opt) {
      if (_curl_opt < 10000) {
        _curl_easy_setopt_err_long();
      }
    }
    if (_curl_opt > 30000) {
      _curl_easy_setopt_err_curl_off_t();
    }
    if (_curl_opt == 10264) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10102) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10287) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10065) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10097) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10022) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10031) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10082) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10135) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10169) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10036) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10238) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10221) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10222) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10223) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10211) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10279) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10077) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10017) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10134) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10147) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10062) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10170) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10026) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10063) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10224) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10217) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10186) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10118) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10177) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10174) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10230) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10262) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10004) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10176) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10175) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10006) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10246) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10247) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10260) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10258) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10263) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10235) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10254) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10255) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10256) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10257) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10259) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10277) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10252) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10253) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10251) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10076) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10007) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10016) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10266) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10190) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10191) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10192) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10289) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10236) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10179) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10162) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10183) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10153) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10152) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10025) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10086) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10089) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10087) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10088) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10083) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10276) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10205) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10206) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10204) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10231) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10002) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10018) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10173) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10005) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10220) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (_curl_opt == 20079) {
      _curl_easy_setopt_err_write_callback();
    } else
    if (_curl_opt == 20011) {
      _curl_easy_setopt_err_write_callback();
    }
    if (_curl_opt == 20272) {
      _curl_easy_setopt_err_resolver_start_callback();
    }
    if (_curl_opt == 20012) {
      _curl_easy_setopt_err_read_cb();
    }
    if (_curl_opt == 20130) {
      _curl_easy_setopt_err_ioctl_cb();
    }
    if (_curl_opt == 20148) {
      _curl_easy_setopt_err_sockopt_cb();
    }
    if (_curl_opt == 20163) {
      _curl_easy_setopt_err_opensocket_cb();
    }
    if (_curl_opt == 20056) {
      _curl_easy_setopt_err_progress_cb();
    }
    if (_curl_opt == 20094) {
      _curl_easy_setopt_err_debug_cb();
    }
    if (_curl_opt == 20108) {
      _curl_easy_setopt_err_ssl_ctx_cb();
    }
    if (_curl_opt == 20143) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20142) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20144) {
      _curl_easy_setopt_err_conv_cb();
    }
    if (_curl_opt == 20167) {
      _curl_easy_setopt_err_seek_cb();
    }
    if (_curl_opt == 10201) {
      goto _L;
    } else
    if (_curl_opt == 10209) {
      goto _L;
    } else
    if (_curl_opt == 10095) {
      goto _L;
    } else
    if (_curl_opt == 10202) {
      goto _L;
    } else
    if (_curl_opt == 10029) {
      goto _L;
    } else
    if (_curl_opt == 10195) {
      goto _L;
    } else
    if (_curl_opt == 10131) {
      goto _L;
    } else
    if (_curl_opt == 10164) {
      goto _L;
    } else
    if (_curl_opt == 10103) {
      goto _L;
    } else
    if (_curl_opt == 10057) {
      goto _L;
    } else
    if (_curl_opt == 10009) {
      goto _L;
    } else
    if (_curl_opt == 10168) {
      goto _L;
    } else
    if (_curl_opt == 10149) {
      goto _L;
    } else
    if (_curl_opt == 10185) {
      goto _L;
    } else
    if (_curl_opt == 10109) {
      goto _L;
    } else
    if (_curl_opt == 10001) {
      goto _L;
    } else
    if (_curl_opt == 10273) {
      goto _L;
    } else
    if (_curl_opt == 10284) {
      goto _L;
    } else
    if (0) {
      _L: /* CIL Label */ 
      if (! (sizeof(ctxp->getwork) == sizeof(void *))) {
        _curl_easy_setopt_err_cb_data();
      }
    }
    if (_curl_opt == 10037) {
      _curl_easy_setopt_err_FILE();
    }
    if (_curl_opt == 10015) {
      tmp___2 = 1;
    } else
    if (_curl_opt == 10165) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    if (_curl_opt == 10024) {
      _curl_easy_setopt_err_curl_httpost();
    }
    if (_curl_opt == 10269) {
      _curl_easy_setopt_err_curl_mimepost();
    }
    if (_curl_opt == 10104) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10023) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10187) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10039) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10093) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10228) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10028) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10203) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10070) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10243) {
      _curl_easy_setopt_err_curl_slist();
    }
    if (_curl_opt == 10100) {
      _curl_easy_setopt_err_CURLSH();
    }
  }
  tmp___3 = curl_easy_setopt(creq, (CURLoption )_curl_opt, ctxp->getwork);
  if (tmp___3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
    exit(1);
  } else {
    _curl_opt___0 = 41;
    if (0) {
      if (0 < _curl_opt___0) {
        if (_curl_opt___0 < 10000) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
      } else {
        tmp___4 = 0;
      }
      if (_curl_opt___0 > 30000) {
        _curl_easy_setopt_err_curl_off_t();
      }
      if (_curl_opt___0 == 10264) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10102) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10287) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10065) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10097) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10022) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10031) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10082) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10135) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10169) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10036) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10238) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10221) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10222) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10223) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10211) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10279) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10077) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10017) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10134) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10147) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10062) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10170) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10026) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10063) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10224) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10217) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10186) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10118) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10177) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10174) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10230) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10262) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10004) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10176) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10175) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10006) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10246) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10247) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10260) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10258) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10263) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10235) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10254) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10255) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10256) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10257) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10259) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10277) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10252) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10253) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10251) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10076) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10007) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10016) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10266) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10190) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10191) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10192) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10289) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10236) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10179) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10162) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10183) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10153) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10152) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10025) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10086) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10089) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10087) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10088) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10083) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10276) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10205) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10206) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10204) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10231) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10002) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10018) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10173) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10005) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10220) {
        _curl_easy_setopt_err_string();
      }
      if (_curl_opt___0 == 20079) {
        _curl_easy_setopt_err_write_callback();
      } else
      if (_curl_opt___0 == 20011) {
        _curl_easy_setopt_err_write_callback();
      }
      if (_curl_opt___0 == 20272) {
        _curl_easy_setopt_err_resolver_start_callback();
      }
      if (_curl_opt___0 == 20012) {
        _curl_easy_setopt_err_read_cb();
      }
      if (_curl_opt___0 == 20130) {
        _curl_easy_setopt_err_ioctl_cb();
      }
      if (_curl_opt___0 == 20148) {
        _curl_easy_setopt_err_sockopt_cb();
      }
      if (_curl_opt___0 == 20163) {
        _curl_easy_setopt_err_opensocket_cb();
      }
      if (_curl_opt___0 == 20056) {
        _curl_easy_setopt_err_progress_cb();
      }
      if (_curl_opt___0 == 20094) {
        _curl_easy_setopt_err_debug_cb();
      }
      if (_curl_opt___0 == 20108) {
        _curl_easy_setopt_err_ssl_ctx_cb();
      }
      if (_curl_opt___0 == 20143) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20142) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20144) {
        _curl_easy_setopt_err_conv_cb();
      }
      if (_curl_opt___0 == 20167) {
        _curl_easy_setopt_err_seek_cb();
      }
      if (_curl_opt___0 == 10201) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10209) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10095) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10202) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10029) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10195) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10131) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10164) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10103) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10057) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10009) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10168) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10149) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10185) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10109) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10001) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10273) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10284) {
        goto _L___0;
      } else
      if (0) {
        _L___0: /* CIL Label */ 
        if (! (sizeof(ctxp->verbose > 1) == sizeof(void *))) {
          _curl_easy_setopt_err_cb_data();
        }
      }
      if (_curl_opt___0 == 10010) {
        _curl_easy_setopt_err_error_buffer();
      }
      if (_curl_opt___0 == 10037) {
        _curl_easy_setopt_err_FILE();
      }
      if (_curl_opt___0 == 10015) {
        _curl_easy_setopt_err_postfields();
      } else
      if (_curl_opt___0 == 10165) {
        _curl_easy_setopt_err_postfields();
      }
      if (_curl_opt___0 == 10024) {
        _curl_easy_setopt_err_curl_httpost();
      }
      if (_curl_opt___0 == 10269) {
        _curl_easy_setopt_err_curl_mimepost();
      }
      if (_curl_opt___0 == 10104) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10023) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10187) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10039) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10093) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10228) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10028) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10203) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10070) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10243) {
        _curl_easy_setopt_err_curl_slist();
      }
      if (_curl_opt___0 == 10100) {
        _curl_easy_setopt_err_CURLSH();
      }
    }
    tmp___5 = curl_easy_setopt(creq, (CURLoption )_curl_opt___0, ctxp->verbose > 1);
    if (tmp___5) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
      exit(1);
    } else {
      _curl_opt___1 = 20011;
      if (0) {
        if (0 < _curl_opt___1) {
          if (_curl_opt___1 < 10000) {
            _curl_easy_setopt_err_long();
          }
        }
        if (_curl_opt___1 > 30000) {
          _curl_easy_setopt_err_curl_off_t();
        }
        if (_curl_opt___1 == 10264) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10102) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10287) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10065) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10097) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10022) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10031) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10082) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10135) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10169) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10036) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10238) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10221) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10222) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10223) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10211) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10279) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10077) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10017) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10134) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10147) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10062) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10170) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10026) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10063) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10224) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10217) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10186) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10118) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10177) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10174) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10230) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10262) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10004) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10176) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10175) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10006) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10246) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10247) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10260) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10258) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10263) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10235) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10254) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10255) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10256) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10257) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10259) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10277) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10252) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10253) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10251) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10076) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10007) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10016) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10266) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10190) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10191) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10192) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10289) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10236) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10179) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10162) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10183) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10153) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10152) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10025) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10086) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10089) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10087) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10088) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10083) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10276) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10205) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10206) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10204) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10231) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10002) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10018) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10173) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10005) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10220) {
          _curl_easy_setopt_err_string();
        }
        if (_curl_opt___1 == 20079) {
          tmp___6 = 1;
        } else
        if (_curl_opt___1 == 20011) {
          tmp___6 = 1;
        } else {
          tmp___6 = 0;
        }
        if (_curl_opt___1 == 20272) {
          _curl_easy_setopt_err_resolver_start_callback();
        }
        if (_curl_opt___1 == 20130) {
          _curl_easy_setopt_err_ioctl_cb();
        }
        if (_curl_opt___1 == 20148) {
          _curl_easy_setopt_err_sockopt_cb();
        }
        if (_curl_opt___1 == 20163) {
          _curl_easy_setopt_err_opensocket_cb();
        }
        if (_curl_opt___1 == 20056) {
          _curl_easy_setopt_err_progress_cb();
        }
        if (_curl_opt___1 == 20094) {
          _curl_easy_setopt_err_debug_cb();
        }
        if (_curl_opt___1 == 20108) {
          _curl_easy_setopt_err_ssl_ctx_cb();
        }
        if (_curl_opt___1 == 20143) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20142) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20144) {
          _curl_easy_setopt_err_conv_cb();
        }
        if (_curl_opt___1 == 20167) {
          _curl_easy_setopt_err_seek_cb();
        }
        if (_curl_opt___1 == 10201) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10209) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10095) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10202) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10029) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10195) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10131) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10164) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10103) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10057) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10009) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10168) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10149) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10185) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10109) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10001) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10273) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10284) {
          goto _L___1;
        } else
        if (0) {
          _L___1: /* CIL Label */ 
          if (! (sizeof(server_body_reader) == sizeof(void *))) {
            _curl_easy_setopt_err_cb_data();
          }
        }
        if (_curl_opt___1 == 10010) {
          _curl_easy_setopt_err_error_buffer();
        }
        if (_curl_opt___1 == 10037) {
          _curl_easy_setopt_err_FILE();
        }
        if (_curl_opt___1 == 10015) {
          _curl_easy_setopt_err_postfields();
        } else
        if (_curl_opt___1 == 10165) {
          _curl_easy_setopt_err_postfields();
        }
        if (_curl_opt___1 == 10024) {
          _curl_easy_setopt_err_curl_httpost();
        }
        if (_curl_opt___1 == 10269) {
          _curl_easy_setopt_err_curl_mimepost();
        }
        if (_curl_opt___1 == 10104) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10023) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10187) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10039) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10093) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10228) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10028) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10203) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10070) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10243) {
          _curl_easy_setopt_err_curl_slist();
        }
        if (_curl_opt___1 == 10100) {
          _curl_easy_setopt_err_CURLSH();
        }
      }
      tmp___7 = curl_easy_setopt(creq, (CURLoption )_curl_opt___1, & server_body_reader);
      if (tmp___7) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
        exit(1);
      } else {
        _curl_opt___2 = 52;
        if (0) {
          if (0 < _curl_opt___2) {
            if (_curl_opt___2 < 10000) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
          } else {
            tmp___8 = 0;
          }
          if (_curl_opt___2 > 30000) {
            _curl_easy_setopt_err_curl_off_t();
          }
          if (_curl_opt___2 == 10264) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10102) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10287) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10065) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10097) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10022) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10031) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10082) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10135) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10169) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10036) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10238) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10221) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10222) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10223) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10211) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10279) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10077) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10017) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10134) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10147) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10062) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10170) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10026) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10063) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10224) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10217) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10186) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10118) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10177) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10174) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10230) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10262) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10004) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10176) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10175) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10006) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10246) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10247) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10260) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10258) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10263) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10235) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10254) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10255) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10256) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10257) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10259) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10277) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10252) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10253) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10251) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10076) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10007) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10016) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10266) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10190) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10191) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10192) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10289) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10236) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10179) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10162) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10183) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10153) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10152) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10025) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10086) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10089) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10087) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10088) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10083) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10276) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10205) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10206) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10204) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10231) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10002) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10018) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10173) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10005) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10220) {
            _curl_easy_setopt_err_string();
          }
          if (_curl_opt___2 == 20079) {
            _curl_easy_setopt_err_write_callback();
          } else
          if (_curl_opt___2 == 20011) {
            _curl_easy_setopt_err_write_callback();
          }
          if (_curl_opt___2 == 20272) {
            _curl_easy_setopt_err_resolver_start_callback();
          }
          if (_curl_opt___2 == 20012) {
            _curl_easy_setopt_err_read_cb();
          }
          if (_curl_opt___2 == 20130) {
            _curl_easy_setopt_err_ioctl_cb();
          }
          if (_curl_opt___2 == 20148) {
            _curl_easy_setopt_err_sockopt_cb();
          }
          if (_curl_opt___2 == 20163) {
            _curl_easy_setopt_err_opensocket_cb();
          }
          if (_curl_opt___2 == 20056) {
            _curl_easy_setopt_err_progress_cb();
          }
          if (_curl_opt___2 == 20094) {
            _curl_easy_setopt_err_debug_cb();
          }
          if (_curl_opt___2 == 20108) {
            _curl_easy_setopt_err_ssl_ctx_cb();
          }
          if (_curl_opt___2 == 20143) {
            _curl_easy_setopt_err_conv_cb();
          } else
          if (_curl_opt___2 == 20142) {
            _curl_easy_setopt_err_conv_cb();
          } else
          if (_curl_opt___2 == 20144) {
            _curl_easy_setopt_err_conv_cb();
          }
          if (_curl_opt___2 == 20167) {
            _curl_easy_setopt_err_seek_cb();
          }
          if (_curl_opt___2 == 10201) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10209) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10095) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10202) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10029) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10195) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10131) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10164) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10103) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10057) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10009) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10168) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10149) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10185) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10109) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10001) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10273) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10284) {
            goto _L___2;
          } else
          if (0) {
            _L___2: /* CIL Label */ 
            if (! (sizeof(1) == sizeof(void *))) {
              _curl_easy_setopt_err_cb_data();
            }
          }
          if (_curl_opt___2 == 10010) {
            _curl_easy_setopt_err_error_buffer();
          }
          if (_curl_opt___2 == 10037) {
            _curl_easy_setopt_err_FILE();
          }
          if (_curl_opt___2 == 10015) {
            _curl_easy_setopt_err_postfields();
          } else
          if (_curl_opt___2 == 10165) {
            _curl_easy_setopt_err_postfields();
          }
          if (_curl_opt___2 == 10024) {
            _curl_easy_setopt_err_curl_httpost();
          }
          if (_curl_opt___2 == 10269) {
            _curl_easy_setopt_err_curl_mimepost();
          }
          if (_curl_opt___2 == 10104) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10023) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10187) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10039) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10093) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10228) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10028) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10203) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10070) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10243) {
            _curl_easy_setopt_err_curl_slist();
          }
          if (_curl_opt___2 == 10100) {
            _curl_easy_setopt_err_CURLSH();
          }
        }
        tmp___9 = curl_easy_setopt(creq, (CURLoption )_curl_opt___2, 1);
        if (tmp___9) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
          exit(1);
        } else {
          _curl_opt___3 = 10001;
          if (0) {
            if (0 < _curl_opt___3) {
              if (_curl_opt___3 < 10000) {
                _curl_easy_setopt_err_long();
              }
            }
            if (_curl_opt___3 > 30000) {
              _curl_easy_setopt_err_curl_off_t();
            }
            if (_curl_opt___3 == 10264) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10102) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10287) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10065) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10097) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10022) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10031) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10082) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10135) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10169) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10036) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10238) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10221) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10222) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10223) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10211) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10279) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10077) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10017) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10134) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10147) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10062) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10170) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10026) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10063) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10224) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10217) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10186) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10118) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10177) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10174) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10230) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10262) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10004) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10176) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10175) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10006) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10246) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10247) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10260) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10258) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10263) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10235) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10254) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10255) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10256) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10257) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10259) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10277) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10252) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10253) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10251) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10076) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10007) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10016) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10266) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10190) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10191) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10192) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10289) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10236) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10179) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10162) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10183) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10153) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10152) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10025) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10086) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10089) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10087) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10088) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10083) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10276) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10205) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10206) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10204) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10231) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10002) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10018) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10173) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10005) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10220) {
              _curl_easy_setopt_err_string();
            }
            if (_curl_opt___3 == 20079) {
              _curl_easy_setopt_err_write_callback();
            } else
            if (_curl_opt___3 == 20011) {
              _curl_easy_setopt_err_write_callback();
            }
            if (_curl_opt___3 == 20272) {
              _curl_easy_setopt_err_resolver_start_callback();
            }
            if (_curl_opt___3 == 20012) {
              _curl_easy_setopt_err_read_cb();
            }
            if (_curl_opt___3 == 20130) {
              _curl_easy_setopt_err_ioctl_cb();
            }
            if (_curl_opt___3 == 20148) {
              _curl_easy_setopt_err_sockopt_cb();
            }
            if (_curl_opt___3 == 20163) {
              _curl_easy_setopt_err_opensocket_cb();
            }
            if (_curl_opt___3 == 20056) {
              _curl_easy_setopt_err_progress_cb();
            }
            if (_curl_opt___3 == 20094) {
              _curl_easy_setopt_err_debug_cb();
            }
            if (_curl_opt___3 == 20108) {
              _curl_easy_setopt_err_ssl_ctx_cb();
            }
            if (_curl_opt___3 == 20143) {
              _curl_easy_setopt_err_conv_cb();
            } else
            if (_curl_opt___3 == 20142) {
              _curl_easy_setopt_err_conv_cb();
            } else
            if (_curl_opt___3 == 20144) {
              _curl_easy_setopt_err_conv_cb();
            }
            if (_curl_opt___3 == 20167) {
              _curl_easy_setopt_err_seek_cb();
            }
            if (_curl_opt___3 == 10201) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10209) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10095) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10202) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10029) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10195) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10131) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10164) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10103) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10057) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10009) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10168) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10149) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10185) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10109) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10001) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10273) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10284) {
              goto _L___3;
            } else
            if (0) {
              _L___3: /* CIL Label */ 
              if (! (sizeof(reqp) == sizeof(void *))) {
                _curl_easy_setopt_err_cb_data();
              }
            }
            if (_curl_opt___3 == 10010) {
              _curl_easy_setopt_err_error_buffer();
            }
            if (_curl_opt___3 == 10037) {
              _curl_easy_setopt_err_FILE();
            }
            if (_curl_opt___3 == 10015) {
              _curl_easy_setopt_err_postfields();
            } else
            if (_curl_opt___3 == 10165) {
              _curl_easy_setopt_err_postfields();
            }
            if (_curl_opt___3 == 10024) {
              _curl_easy_setopt_err_curl_httpost();
            }
            if (_curl_opt___3 == 10104) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10023) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10187) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10039) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10093) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10228) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10028) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10203) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10070) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10243) {
              _curl_easy_setopt_err_curl_slist();
            }
            if (_curl_opt___3 == 10100) {
              _curl_easy_setopt_err_CURLSH();
            }
          }
          tmp___10 = curl_easy_setopt(creq, (CURLoption )_curl_opt___3, reqp);
          if (tmp___10) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
            exit(1);
          }
        }
      }
    }
  }
  res = curl_easy_perform(creq);
  curl_easy_cleanup(creq);
  if ((unsigned int )res != 0U) {
    tmp___11 = curl_easy_strerror(res);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Get work request failed: %s\n",
            tmp___11);
    server_request_free(reqp);
    return (-1);
  }
  ctxp->items.ar_root = reqp->items.ar_root;
  return (0);
}
}
int server_context_submit_solution(server_context_t *ctxp , workitem_t *work , char const   *privkey ) 
{ 
  char urlbuf[8192] ;
  char *pubhex ;
  CURL *creq ;
  CURLcode res ;
  EC_GROUP const   *tmp___0 ;
  int _curl_opt ;
  int tmp___1 ;
  int tmp___2 ;
  CURLcode tmp___3 ;
  int _curl_opt___0 ;
  int tmp___4 ;
  CURLcode tmp___5 ;
  int _curl_opt___1 ;
  int tmp___6 ;
  CURLcode tmp___7 ;
  char const   *tmp___8 ;

  {
  tmp___0 = EC_KEY_get0_group((EC_KEY const   *)ctxp->dummy_key);
  pubhex = EC_POINT_point2hex(tmp___0, (EC_POINT const   *)work->pubkey, (point_conversion_form_t )4,
                              (BN_CTX *)((void *)0));
  snprintf((char * __restrict  )(urlbuf), sizeof(urlbuf), (char const   * __restrict  )"%s?key=%s%%3A%s&privateKey=%s&bitcoinAddress=%s",
           ctxp->submit, work->pattern, pubhex, privkey, ctxp->credit_addr);
  CRYPTO_free((void *)pubhex);
  creq = curl_easy_init();
  _curl_opt = 10002;
  if (0) {
    if (0 < _curl_opt) {
      if (_curl_opt < 10000) {
        _curl_easy_setopt_err_long();
      }
    }
    if (_curl_opt > 30000) {
      _curl_easy_setopt_err_curl_off_t();
    }
    if (_curl_opt == 10264) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10102) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10287) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10065) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10097) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10022) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10031) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10082) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10135) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10169) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10036) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10238) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10221) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10222) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10223) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10211) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10279) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10077) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10017) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10134) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10147) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10062) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10170) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10026) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10063) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10224) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10217) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10186) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10118) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10177) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10174) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10230) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10262) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10004) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10176) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10175) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10006) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10246) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10247) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10260) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10258) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10263) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10235) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10254) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10255) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10256) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10257) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10259) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10277) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10252) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10253) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10251) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10076) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10007) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10016) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10266) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10190) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10191) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10192) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10289) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10236) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10179) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10162) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10183) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10153) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10152) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10025) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10086) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10089) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10087) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10088) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10083) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10276) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10205) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10206) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10204) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10231) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10002) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10018) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10173) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10005) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10220) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (_curl_opt == 20079) {
      _curl_easy_setopt_err_write_callback();
    } else
    if (_curl_opt == 20011) {
      _curl_easy_setopt_err_write_callback();
    }
    if (_curl_opt == 20272) {
      _curl_easy_setopt_err_resolver_start_callback();
    }
    if (_curl_opt == 20012) {
      _curl_easy_setopt_err_read_cb();
    }
    if (_curl_opt == 20130) {
      _curl_easy_setopt_err_ioctl_cb();
    }
    if (_curl_opt == 20148) {
      _curl_easy_setopt_err_sockopt_cb();
    }
    if (_curl_opt == 20163) {
      _curl_easy_setopt_err_opensocket_cb();
    }
    if (_curl_opt == 20056) {
      _curl_easy_setopt_err_progress_cb();
    }
    if (_curl_opt == 20094) {
      _curl_easy_setopt_err_debug_cb();
    }
    if (_curl_opt == 20108) {
      _curl_easy_setopt_err_ssl_ctx_cb();
    }
    if (_curl_opt == 20143) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20142) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20144) {
      _curl_easy_setopt_err_conv_cb();
    }
    if (_curl_opt == 20167) {
      _curl_easy_setopt_err_seek_cb();
    }
    if (_curl_opt == 10201) {
      goto _L;
    } else
    if (_curl_opt == 10209) {
      goto _L;
    } else
    if (_curl_opt == 10095) {
      goto _L;
    } else
    if (_curl_opt == 10202) {
      goto _L;
    } else
    if (_curl_opt == 10029) {
      goto _L;
    } else
    if (_curl_opt == 10195) {
      goto _L;
    } else
    if (_curl_opt == 10131) {
      goto _L;
    } else
    if (_curl_opt == 10164) {
      goto _L;
    } else
    if (_curl_opt == 10103) {
      goto _L;
    } else
    if (_curl_opt == 10057) {
      goto _L;
    } else
    if (_curl_opt == 10009) {
      goto _L;
    } else
    if (_curl_opt == 10168) {
      goto _L;
    } else
    if (_curl_opt == 10149) {
      goto _L;
    } else
    if (_curl_opt == 10185) {
      goto _L;
    } else
    if (_curl_opt == 10109) {
      goto _L;
    } else
    if (_curl_opt == 10001) {
      goto _L;
    } else
    if (_curl_opt == 10273) {
      goto _L;
    } else
    if (_curl_opt == 10284) {
      goto _L;
    } else
    if (0) {
      _L: /* CIL Label */ 
      if (! (sizeof(urlbuf) == sizeof(void *))) {
        _curl_easy_setopt_err_cb_data();
      }
    }
    if (_curl_opt == 10037) {
      _curl_easy_setopt_err_FILE();
    }
    if (_curl_opt == 10015) {
      tmp___2 = 1;
    } else
    if (_curl_opt == 10165) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    if (_curl_opt == 10024) {
      _curl_easy_setopt_err_curl_httpost();
    }
    if (_curl_opt == 10269) {
      _curl_easy_setopt_err_curl_mimepost();
    }
    if (_curl_opt == 10104) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10023) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10187) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10039) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10093) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10228) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10028) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10203) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10070) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10243) {
      _curl_easy_setopt_err_curl_slist();
    }
    if (_curl_opt == 10100) {
      _curl_easy_setopt_err_CURLSH();
    }
  }
  tmp___3 = curl_easy_setopt(creq, (CURLoption )_curl_opt, urlbuf);
  if (tmp___3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
    exit(1);
  } else {
    _curl_opt___0 = 41;
    if (0) {
      if (0 < _curl_opt___0) {
        if (_curl_opt___0 < 10000) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
      } else {
        tmp___4 = 0;
      }
      if (_curl_opt___0 > 30000) {
        _curl_easy_setopt_err_curl_off_t();
      }
      if (_curl_opt___0 == 10264) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10102) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10287) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10065) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10097) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10022) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10031) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10082) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10135) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10169) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10036) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10238) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10221) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10222) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10223) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10211) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10279) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10077) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10017) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10134) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10147) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10062) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10170) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10026) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10063) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10224) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10217) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10186) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10118) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10177) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10174) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10230) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10262) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10004) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10176) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10175) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10006) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10246) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10247) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10260) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10258) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10263) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10235) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10254) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10255) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10256) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10257) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10259) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10277) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10252) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10253) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10251) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10076) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10007) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10016) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10266) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10190) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10191) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10192) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10289) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10236) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10179) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10162) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10183) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10153) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10152) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10025) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10086) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10089) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10087) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10088) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10083) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10276) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10205) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10206) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10204) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10231) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10002) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10018) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10173) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10005) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10220) {
        _curl_easy_setopt_err_string();
      }
      if (_curl_opt___0 == 20079) {
        _curl_easy_setopt_err_write_callback();
      } else
      if (_curl_opt___0 == 20011) {
        _curl_easy_setopt_err_write_callback();
      }
      if (_curl_opt___0 == 20272) {
        _curl_easy_setopt_err_resolver_start_callback();
      }
      if (_curl_opt___0 == 20012) {
        _curl_easy_setopt_err_read_cb();
      }
      if (_curl_opt___0 == 20130) {
        _curl_easy_setopt_err_ioctl_cb();
      }
      if (_curl_opt___0 == 20148) {
        _curl_easy_setopt_err_sockopt_cb();
      }
      if (_curl_opt___0 == 20163) {
        _curl_easy_setopt_err_opensocket_cb();
      }
      if (_curl_opt___0 == 20056) {
        _curl_easy_setopt_err_progress_cb();
      }
      if (_curl_opt___0 == 20094) {
        _curl_easy_setopt_err_debug_cb();
      }
      if (_curl_opt___0 == 20108) {
        _curl_easy_setopt_err_ssl_ctx_cb();
      }
      if (_curl_opt___0 == 20143) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20142) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20144) {
        _curl_easy_setopt_err_conv_cb();
      }
      if (_curl_opt___0 == 20167) {
        _curl_easy_setopt_err_seek_cb();
      }
      if (_curl_opt___0 == 10201) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10209) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10095) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10202) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10029) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10195) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10131) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10164) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10103) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10057) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10009) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10168) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10149) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10185) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10109) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10001) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10273) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10284) {
        goto _L___0;
      } else
      if (0) {
        _L___0: /* CIL Label */ 
        if (! (sizeof(ctxp->verbose > 1) == sizeof(void *))) {
          _curl_easy_setopt_err_cb_data();
        }
      }
      if (_curl_opt___0 == 10010) {
        _curl_easy_setopt_err_error_buffer();
      }
      if (_curl_opt___0 == 10037) {
        _curl_easy_setopt_err_FILE();
      }
      if (_curl_opt___0 == 10015) {
        _curl_easy_setopt_err_postfields();
      } else
      if (_curl_opt___0 == 10165) {
        _curl_easy_setopt_err_postfields();
      }
      if (_curl_opt___0 == 10024) {
        _curl_easy_setopt_err_curl_httpost();
      }
      if (_curl_opt___0 == 10269) {
        _curl_easy_setopt_err_curl_mimepost();
      }
      if (_curl_opt___0 == 10104) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10023) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10187) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10039) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10093) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10228) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10028) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10203) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10070) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10243) {
        _curl_easy_setopt_err_curl_slist();
      }
      if (_curl_opt___0 == 10100) {
        _curl_easy_setopt_err_CURLSH();
      }
    }
    tmp___5 = curl_easy_setopt(creq, (CURLoption )_curl_opt___0, ctxp->verbose > 1);
    if (tmp___5) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
      exit(1);
    } else {
      _curl_opt___1 = 52;
      if (0) {
        if (0 < _curl_opt___1) {
          if (_curl_opt___1 < 10000) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (_curl_opt___1 > 30000) {
          _curl_easy_setopt_err_curl_off_t();
        }
        if (_curl_opt___1 == 10264) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10102) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10287) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10065) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10097) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10022) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10031) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10082) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10135) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10169) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10036) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10238) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10221) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10222) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10223) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10211) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10279) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10077) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10017) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10134) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10147) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10062) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10170) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10026) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10063) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10224) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10217) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10186) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10118) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10177) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10174) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10230) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10262) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10004) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10176) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10175) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10006) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10246) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10247) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10260) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10258) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10263) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10235) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10254) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10255) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10256) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10257) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10259) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10277) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10252) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10253) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10251) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10076) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10007) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10016) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10266) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10190) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10191) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10192) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10289) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10236) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10179) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10162) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10183) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10153) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10152) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10025) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10086) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10089) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10087) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10088) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10083) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10276) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10205) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10206) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10204) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10231) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10002) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10018) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10173) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10005) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10220) {
          _curl_easy_setopt_err_string();
        }
        if (_curl_opt___1 == 20079) {
          _curl_easy_setopt_err_write_callback();
        } else
        if (_curl_opt___1 == 20011) {
          _curl_easy_setopt_err_write_callback();
        }
        if (_curl_opt___1 == 20272) {
          _curl_easy_setopt_err_resolver_start_callback();
        }
        if (_curl_opt___1 == 20012) {
          _curl_easy_setopt_err_read_cb();
        }
        if (_curl_opt___1 == 20130) {
          _curl_easy_setopt_err_ioctl_cb();
        }
        if (_curl_opt___1 == 20148) {
          _curl_easy_setopt_err_sockopt_cb();
        }
        if (_curl_opt___1 == 20163) {
          _curl_easy_setopt_err_opensocket_cb();
        }
        if (_curl_opt___1 == 20056) {
          _curl_easy_setopt_err_progress_cb();
        }
        if (_curl_opt___1 == 20094) {
          _curl_easy_setopt_err_debug_cb();
        }
        if (_curl_opt___1 == 20108) {
          _curl_easy_setopt_err_ssl_ctx_cb();
        }
        if (_curl_opt___1 == 20143) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20142) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20144) {
          _curl_easy_setopt_err_conv_cb();
        }
        if (_curl_opt___1 == 20167) {
          _curl_easy_setopt_err_seek_cb();
        }
        if (_curl_opt___1 == 10201) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10209) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10095) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10202) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10029) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10195) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10131) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10164) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10103) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10057) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10009) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10168) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10149) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10185) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10109) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10001) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10273) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10284) {
          goto _L___1;
        } else
        if (0) {
          _L___1: /* CIL Label */ 
          if (! (sizeof(1) == sizeof(void *))) {
            _curl_easy_setopt_err_cb_data();
          }
        }
        if (_curl_opt___1 == 10010) {
          _curl_easy_setopt_err_error_buffer();
        }
        if (_curl_opt___1 == 10037) {
          _curl_easy_setopt_err_FILE();
        }
        if (_curl_opt___1 == 10015) {
          _curl_easy_setopt_err_postfields();
        } else
        if (_curl_opt___1 == 10165) {
          _curl_easy_setopt_err_postfields();
        }
        if (_curl_opt___1 == 10024) {
          _curl_easy_setopt_err_curl_httpost();
        }
        if (_curl_opt___1 == 10269) {
          _curl_easy_setopt_err_curl_mimepost();
        }
        if (_curl_opt___1 == 10104) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10023) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10187) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10039) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10093) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10228) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10028) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10203) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10070) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10243) {
          _curl_easy_setopt_err_curl_slist();
        }
        if (_curl_opt___1 == 10100) {
          _curl_easy_setopt_err_CURLSH();
        }
      }
      tmp___7 = curl_easy_setopt(creq, (CURLoption )_curl_opt___1, 1);
      if (tmp___7) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
        exit(1);
      }
    }
  }
  res = curl_easy_perform(creq);
  if ((unsigned int )res != 0U) {
    tmp___8 = curl_easy_strerror(res);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Submission failed: %s\n",
            tmp___8);
    curl_easy_cleanup(creq);
    return (-1);
  }
  curl_easy_cleanup(creq);
  return (0);
}
}
static pthread_mutex_t soln_lock  ;
static pthread_cond_t soln_cond  ;
static char *soln_pattern  =    (char *)((void *)0);
static char *soln_private_key  =    (char *)((void *)0);
void free_soln(void) 
{ 


  {
  if (soln_pattern) {
    free((void *)soln_pattern);
    soln_pattern = (char *)((void *)0);
  }
  if (soln_private_key) {
    CRYPTO_free((void *)soln_private_key);
    soln_private_key = (char *)((void *)0);
  }
  return;
}
}
void output_match_work_complete(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern ) 
{ 
  BIGNUM const   *tmp___0 ;

  {
  vg_output_match_console(vcp, pkey, pattern);
  pthread_mutex_lock(& soln_lock);
  free_soln();
  soln_pattern = strdup(pattern);
  tmp___0 = EC_KEY_get0_private_key((EC_KEY const   *)pkey);
  soln_private_key = BN_bn2hex(tmp___0);
  vcp->vc_halt = 1;
  pthread_cond_broadcast(& soln_cond);
  pthread_mutex_unlock(& soln_lock);
  return;
}
}
int check_solution(server_context_t *scp , pubkeybatch_t *pbatch ) 
{ 
  int res ;
  workitem_t *wip ;
  workitem_t *tmp___0 ;

  {
  res = 0;
  pthread_mutex_lock(& soln_lock);
  if ((unsigned long )soln_private_key != (unsigned long )((void *)0)) {
    tmp___0 = workitem_avl_search(& pbatch->items, (char const   *)soln_pattern);
    wip = tmp___0;
    if (! ((unsigned long )wip != (unsigned long )((void *)0))) {
      __assert_fail("wip != NULL", "oclvanityminer.c", 712U, "check_solution");
    }
    avl_remove(& pbatch->items, & wip->avlent);
    (pbatch->nitems) --;
    pbatch->total_value -= wip->value;
    server_context_submit_solution(scp, wip, (char const   *)soln_private_key);
    if ((unsigned long )wip->pubkey == (unsigned long )pbatch->pubkey) {
      wip->pubkey = (EC_POINT *)((void *)0);
    }
    server_workitem_free(wip);
    free_soln();
    res = 1;
  }
  pthread_mutex_unlock(& soln_lock);
  return (res);
}
}
pubkeybatch_t *most_valuable_pkb(server_context_t *scp ) 
{ 
  pubkeybatch_t *pbatch ;
  pubkeybatch_t *res ;

  {
  res = (pubkeybatch_t *)((void *)0);
  pbatch = pubkeybatch_avl_first(& scp->items);
  while ((unsigned long )pbatch != (unsigned long )((void *)0)) {
    if (! res) {
      res = pbatch;
    } else
    if (res->total_value < pbatch->total_value) {
      res = pbatch;
    }
    pbatch = pubkeybatch_avl_next(pbatch);
  }
  return (res);
}
}
void usage(char const   *name ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"oclVanityMiner %s (OpenSSL 1.0.1u  22 Sep 2016)\nUsage: %s -u <URL> -a <credit address>\nOrganized vanity address mining client using OpenCL.  Contacts the specified\nbounty pool server, downloads a list of active bounties, and attempts to\ngenerate the address with the best difficulty to reward ratio.  Maintains\ncontact with the bounty pool server and periodically refreshes the bounty\nlist.\nBy default, if no device is specified, and the system has exactly one OpenCL\ndevice, it will be selected automatically, otherwise if the system has\nmultiple OpenCL devices and no device is specified, an error will be\nreported.  To use multiple devices simultaneously, specify the -D option for\neach device.\n\nOptions:\n-u <URL>      Bounty pool URL\n-a <address>  Credit address for completed work\n-i <interval> Set server polling interval in seconds (default 90)\n-v            Verbose output\n-q            Quiet output\n-p <platform> Select OpenCL platform\n-d <device>   Select OpenCL device\n-D <devstr>   Use OpenCL device, identified by device string\n              Form: <platform>:<devicenumber>[,<options>]\n              Example: 0:0,grid=1024x1024\n-S            Safe mode, disable OpenCL loop unrolling optimizations\n-w <worksize> Set work items per thread in a work unit\n-t <threads>  Set target thread count per multiprocessor\n-g <x>x<y>    Set grid size\n-b <invsize>  Set modular inverse ops per thread\n-V            Enable kernel/OpenCL/hardware verification (SLOW)\n",
          version, name);
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char const   *url ;
  char const   *credit_addr ;
  int opt ;
  int platformidx ;
  int deviceidx ;
  char *pend ;
  int verbose ;
  int interval ;
  int nthreads ;
  int worksize ;
  int nrows ;
  int ncols ;
  int invsize ;
  int verify_mode ;
  int safe_mode ;
  char *devstrs[32] ;
  int ndevstrs ;
  vg_context_t *vcp ;
  vg_ocl_context_t *vocp ;
  int res ;
  int thread_started ;
  pubkeybatch_t *active_pkb ;
  float active_pkb_value ;
  server_context_t *scp ;
  pubkeybatch_t *pkb ;
  int was_sleeping ;
  struct timeval tv ;
  struct timespec sleepy ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  workitem_t *wip ;
  int tmp___7 ;
  int tmp___8 ;

  {
  url = (char const   *)((void *)0);
  credit_addr = (char const   *)((void *)0);
  platformidx = -1;
  deviceidx = -1;
  verbose = 1;
  interval = 90;
  nthreads = 0;
  worksize = 0;
  nrows = 0;
  ncols = 0;
  invsize = 0;
  verify_mode = 0;
  safe_mode = 0;
  ndevstrs = 0;
  vcp = (vg_context_t *)((void *)0);
  vocp = (vg_ocl_context_t *)((void *)0);
  thread_started = 0;
  active_pkb = (pubkeybatch_t *)((void *)0);
  active_pkb_value = (float )0;
  scp = (server_context_t *)((void *)0);
  was_sleeping = 0;
  pthread_mutex_init(& soln_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& soln_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (argc == 1) {
    usage((char const   *)*(argv + 0));
    return (1);
  }
  while (1) {
    opt = getopt(argc, (char * const  *)argv, "u:a:vqp:d:w:t:g:b:VD:Sh?i:");
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 117: 
    url = (char const   *)optarg;
    break;
    case 97: 
    credit_addr = (char const   *)optarg;
    break;
    case 118: 
    verbose = 2;
    break;
    case 113: 
    verbose = 0;
    break;
    case 105: 
    interval = atoi((char const   *)optarg);
    if (interval < 10) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid interval \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 112: 
    platformidx = atoi((char const   *)optarg);
    break;
    case 100: 
    deviceidx = atoi((char const   *)optarg);
    break;
    case 119: 
    worksize = atoi((char const   *)optarg);
    if (worksize == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid work size \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 116: 
    nthreads = atoi((char const   *)optarg);
    if (nthreads == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid thread count \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 103: 
    nrows = 0;
    tmp___0 = strtol((char const   * __restrict  )optarg, (char ** __restrict  )(& pend),
                     0);
    ncols = (int )tmp___0;
    if (pend) {
      if ((int )*pend == 120) {
        tmp___1 = strtol((char const   * __restrict  )(pend + 1), (char ** __restrict  )((void *)0),
                         0);
        nrows = (int )tmp___1;
      }
    }
    if (! nrows) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid grid size \'%s\'\n",
              optarg);
      return (1);
    } else
    if (! ncols) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid grid size \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 98: 
    invsize = atoi((char const   *)optarg);
    if (! invsize) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid modular inverse size \'%s\'\n",
              optarg);
      return (1);
    }
    if (invsize & (invsize - 1)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse size must be a power of 2\n");
      return (1);
    }
    break;
    case 86: 
    verify_mode = 1;
    break;
    case 83: 
    safe_mode = 1;
    break;
    case 68: 
    if (ndevstrs >= 32) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too many OpenCL devices (limit %d)\n",
              32);
      return (1);
    }
    tmp___2 = ndevstrs;
    ndevstrs ++;
    devstrs[tmp___2] = optarg;
    break;
    default: 
    usage((char const   *)*(argv + 0));
    return (1);
    }
  }
  curl_easy_init();
  vcp = vg_prefix_context_new(0, 128, 0);
  vcp->vc_verbose = verbose;
  vcp->vc_output_match = & output_match_work_complete;
  vcp->vc_output_timing = & vg_output_timing_console;
  if (! url) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: No server URL specified\n");
    return (1);
  }
  if (! credit_addr) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: No reward address specified\n");
    return (1);
  }
  tmp___3 = vg_b58_decode_check(credit_addr, (void *)0, (size_t )0);
  if (! tmp___3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Invalid reward address specified\n");
    return (1);
  }
  scp = server_context_new(url, credit_addr);
  scp->verbose = verbose;
  tmp___4 = server_context_getwork(scp);
  if (tmp___4) {
    return (1);
  }
  res = 0;
  if (ndevstrs) {
    opt = 0;
    while (opt < ndevstrs) {
      vocp = vg_ocl_context_new_from_devstr(vcp, (char const   *)devstrs[opt], safe_mode,
                                            verify_mode);
      if (! vocp) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not open device \'%s\', ignoring\n",
                devstrs[opt]);
      } else {
        res ++;
      }
      opt ++;
    }
  } else {
    vocp = vg_ocl_context_new(vcp, platformidx, deviceidx, safe_mode, verify_mode,
                              worksize, nthreads, nrows, ncols, invsize);
    if (vocp) {
      res ++;
    }
  }
  if (! res) {
    vg_ocl_enumerate_devices();
    return (1);
  }
  if (verbose > 1) {
    dump_work(& scp->items);
  }
  while (1) {
    tmp___5 = avl_root_empty(& scp->items);
    if (tmp___5) {
      server_context_getwork(scp);
    }
    pkb = most_valuable_pkb(scp);
    if (pkb) {
      if (active_pkb) {
        tmp___6 = server_pubkeybatch_equal(scp, active_pkb, pkb);
        if (tmp___6) {
          pkb = active_pkb;
        }
      }
    }
    if (thread_started) {
      if (! active_pkb) {
        goto _L;
      } else
      if ((unsigned long )pkb != (unsigned long )active_pkb) {
        _L: /* CIL Label */ 
        vg_context_stop_threads(vcp);
        thread_started = 0;
        if (active_pkb) {
          check_solution(scp, active_pkb);
          active_pkb = (pubkeybatch_t *)((void *)0);
        }
        vg_context_clear_all_patterns(vcp);
        if (verbose > 1) {
          dump_work(& scp->items);
        }
      }
    }
    if (! pkb) {
      if (! was_sleeping) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No work available, sleeping\n");
        was_sleeping = 1;
      }
    } else
    if (! active_pkb) {
      was_sleeping = 0;
      active_pkb_value = (float )0;
      vcp->vc_pubkey_base = pkb->pubkey;
      wip = workitem_avl_first(& pkb->items);
      while ((unsigned long )wip != (unsigned long )((void *)0)) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Searching for pattern: \"%s\" Reward: %f Value: %f BTC/Gkey\n",
                wip->pattern, wip->reward, wip->value);
        vcp->vc_addrtype = wip->addrtype;
        tmp___7 = vg_context_add_patterns(vcp, (char const   ** const  )(& wip->pattern),
                                          1);
        if (tmp___7) {
          active_pkb_value = (float )((double )active_pkb_value + wip->value);
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: could not add pattern\n");
        }
        if (! vcp->vc_npatterns) {
          __assert_fail("vcp->vc_npatterns", "oclvanityminer.c", 1042U, "main");
        }
        wip = workitem_avl_next(wip);
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nTotal value for current work: %f BTC/Gkey\n",
              (double )active_pkb_value);
      res = vg_context_start_threads(vcp);
      if (res) {
        return (1);
      }
      thread_started = 1;
      active_pkb = pkb;
    }
    gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
    sleepy.tv_sec = tv.tv_sec;
    sleepy.tv_nsec = tv.tv_usec * 1000L;
    sleepy.tv_sec += (__time_t )interval;
    pthread_mutex_lock(& soln_lock);
    res = 0;
    if (! soln_private_key) {
      res = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& soln_cond), (pthread_mutex_t * __restrict  )(& soln_lock),
                                   (struct timespec  const  * __restrict  )(& sleepy));
    }
    pthread_mutex_unlock(& soln_lock);
    if (res == 0) {
      tmp___8 = check_solution(scp, active_pkb);
      if (tmp___8) {
        active_pkb = (pubkeybatch_t *)((void *)0);
      }
    } else
    if (res == 110) {
      free_pkb_tree(& scp->items, active_pkb);
    }
  }
  return (0);
}
}
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
#pragma merger("0","/tmp/cil-ILat4I7x.i","-ggdb,-O3,-Wall")
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern BN_CTX *BN_CTX_new(void) ;
extern void BN_CTX_free(BN_CTX *c ) ;
extern void BN_init(BIGNUM * ) ;
extern void BN_clear_free(BIGNUM *a ) ;
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
extern unsigned long BN_get_word(BIGNUM const   *a ) ;
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
extern BIGNUM *BN_mod_inverse(BIGNUM *ret , BIGNUM const   *a , BIGNUM const   *n ,
                              BN_CTX *ctx ) ;
extern BN_MONT_CTX *BN_MONT_CTX_new(void) ;
extern int BN_mod_mul_montgomery(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ,
                                 BN_MONT_CTX *mont , BN_CTX *ctx ) ;
extern void BN_MONT_CTX_free(BN_MONT_CTX *mont ) ;
extern int BN_MONT_CTX_set(BN_MONT_CTX *mont , BIGNUM const   *mod , BN_CTX *ctx ) ;
extern BIGNUM *bn_expand2(BIGNUM *a , int words ) ;
extern EC_POINT const   *EC_GROUP_get0_generator(EC_GROUP const   *group ) ;
extern int EC_GROUP_get_order(EC_GROUP const   *group , BIGNUM *order , BN_CTX *ctx ) ;
extern EC_POINT *EC_POINT_new(EC_GROUP const   *group ) ;
extern int EC_POINT_copy(EC_POINT *dst , EC_POINT const   *src ) ;
extern int EC_POINT_add(EC_GROUP const   *group , EC_POINT *r , EC_POINT const   *a ,
                        EC_POINT const   *b , BN_CTX *ctx ) ;
extern int EC_POINT_make_affine(EC_GROUP const   *group , EC_POINT *point , BN_CTX *ctx ) ;
extern int EC_POINTs_make_affine(EC_GROUP const   *group , size_t num , EC_POINT **points ,
                                 BN_CTX *ctx ) ;
extern int EC_POINT_mul(EC_GROUP const   *group , EC_POINT *r , BIGNUM const   *n ,
                        EC_POINT const   *q , BIGNUM const   *m , BN_CTX *ctx ) ;
extern EC_POINT const   *EC_KEY_get0_public_key(EC_KEY const   *key ) ;
extern int EC_KEY_generate_key(EC_KEY *key ) ;
extern EVP_MD_CTX *EVP_MD_CTX_create(void) ;
extern void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx ) ;
extern int EVP_DigestInit_ex(EVP_MD_CTX *ctx , EVP_MD const   *type , ENGINE *impl ) ;
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
extern int EVP_DigestFinal_ex(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
extern EVP_MD const   *EVP_md5(void) ;
#pragma message("cl_version.h: CL_TARGET_OPENCL_VERSION is not defined. Defaulting to 220 (OpenCL 2.2)")
extern int ( /* missing proto */  __builtin_ia32_emms)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_empty)(void) 
{ 


  {
  __builtin_ia32_emms();
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_empty)(void) 
{ 


  {
  _mm_empty();
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_init_v2si)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi32_si64)(int __i ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_init_v2si(__i, 0);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_from_int)(int __i ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cvtsi32_si64(__i);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_from_int64)(long long __i ) 
{ 


  {
  return ((__m64 )__i);
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v2si)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi64_si32)(__m64 __i ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_ext_v2si((__v2si )__i, 0);
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_to_int)(__m64 __i ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = _mm_cvtsi64_si32(__i);
  return (tmp___0);
}
}
__inline extern long long ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_to_int64)(__m64 __i ) 
{ 


  {
  return ((long long )__i);
}
}
extern int ( /* missing proto */  __builtin_ia32_packsswb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_packsswb((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                    (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                                                        __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_packs_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_packssdw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_packssdw((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                                                        __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_packs_pi32(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_packuswb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_packuswb((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                    (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                                                        __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_packs_pu16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhbw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                                                             __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhbw((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                     (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_unpackhi_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhwd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                                                              __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                     (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_unpackhi_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhdq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                                                              __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhdq((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_unpackhi_pi32(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpcklbw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                                                             __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpcklbw((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                     (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_unpacklo_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpcklwd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                                                              __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpcklwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                     (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_unpacklo_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckldq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                                                              __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckldq((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_unpacklo_pi32(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                                                        __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                 (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddb)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_add_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                 (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddw)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_add_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddd((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddd)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_add_pi32(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddq((__v1di )__m1, (__v1di )__m2);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddsb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddsb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                  (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddsb)(__m64 __m1 ,
                                                                                                      __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_adds_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddsw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddsw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                  (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddsw)(__m64 __m1 ,
                                                                                                      __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_adds_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddusb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddusb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddusb)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_adds_pu8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddusw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddusw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_paddusw)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_adds_pu16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                                                        __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                 (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubb)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sub_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                 (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubw)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sub_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubd((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubd)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sub_pi32(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubq((__v1di )__m1, (__v1di )__m2);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubsb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubsb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                  (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubsb)(__m64 __m1 ,
                                                                                                      __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_subs_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubsw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubsw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                  (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubsw)(__m64 __m1 ,
                                                                                                      __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_subs_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubusb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubusb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubusb)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_subs_pu8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubusw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubusw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psubusw)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_subs_pu16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmaddwd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmaddwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmaddwd)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_madd_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmulhw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmulhw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                  (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmulhw)(__m64 __m1 ,
                                                                                                      __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_mulhi_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmullw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmullw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                  (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmullw)(__m64 __m1 ,
                                                                                                      __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_mullo_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m),
                                 (int __attribute__((__vector_size__(8)))  )((__v4hi )__count));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psllw)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sll_pi16(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllwi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllwi((int __attribute__((__vector_size__(8)))  )((__v4hi )__m),
                                  __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psllwi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_slli_pi16(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pslld)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pslld((__v2si )__m, (__v2si )__count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pslld)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sll_pi32(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pslldi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pslldi((__v2si )__m, __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pslldi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_slli_pi32(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllq((__v1di )__m, (__v1di )__count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psllq)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sll_si64(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllqi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllqi((__v1di )__m, __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psllqi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_slli_si64(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psraw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psraw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m),
                                 (int __attribute__((__vector_size__(8)))  )((__v4hi )__count));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psraw)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sra_pi16(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrawi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrawi((int __attribute__((__vector_size__(8)))  )((__v4hi )__m),
                                  __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrawi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srai_pi16(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrad)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrad((__v2si )__m, (__v2si )__count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrad)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sra_pi32(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psradi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psradi((__v2si )__m, __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psradi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srai_pi32(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m),
                                 (int __attribute__((__vector_size__(8)))  )((__v4hi )__count));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrlw)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srl_pi16(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlwi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlwi((int __attribute__((__vector_size__(8)))  )((__v4hi )__m),
                                  __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrlwi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srli_pi16(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrld)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrld((__v2si )__m, (__v2si )__count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrld)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srl_pi32(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrldi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrldi((__v2si )__m, __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrldi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srli_pi32(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                                                         __m64 __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlq((__v1di )__m, (__v1di )__count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrlq)(__m64 __m ,
                                                                                                     __m64 __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srl_si64(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlqi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                                                          int __count ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlqi((__v1di )__m, __count);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psrlqi)(__m64 __m ,
                                                                                                      int __count ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_srli_si64(__m, __count);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pand)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pand(__m1, __m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pand)(__m64 __m1 ,
                                                                                                    __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_and_si64(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pandn)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                                                            __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pandn(__m1, __m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pandn)(__m64 __m1 ,
                                                                                                     __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_andnot_si64(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_por)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                                                        __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_por(__m1, __m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_por)(__m64 __m1 ,
                                                                                                   __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_or_si64(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pxor)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                                                         __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pxor(__m1, __m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pxor)(__m64 __m1 ,
                                                                                                    __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_xor_si64(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pcmpeqb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pcmpeqb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pcmpeqb)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cmpeq_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pcmpgtb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                                                          __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pcmpgtb((int __attribute__((__vector_size__(8)))  )((__v8qi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v8qi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pcmpgtb)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cmpgt_pi8(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pcmpeqw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pcmpeqw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pcmpeqw)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cmpeq_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pcmpgtw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pcmpgtw((int __attribute__((__vector_size__(8)))  )((__v4hi )__m1),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__m2));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pcmpgtw)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cmpgt_pi16(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pcmpeqd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pcmpeqd((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pcmpeqd)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cmpeq_pi32(__m1, __m2);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pcmpgtd)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                                                           __m64 __m2 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pcmpgtd((__v2si )__m1, (__v2si )__m2);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pcmpgtd)(__m64 __m1 ,
                                                                                                       __m64 __m2 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cmpgt_pi32(__m1, __m2);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setzero_si64)(void) 
{ 


  {
  return ((__m64 )0LL);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_pi32)(int __i1 ,
                                                                                                         int __i0 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_init_v2si(__i0, __i1);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_init_v4hi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_pi16)(short __w3 ,
                                                                                                         short __w2 ,
                                                                                                         short __w1 ,
                                                                                                         short __w0 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_init_v4hi((int )__w0, (int )__w1, (int )__w2, (int )__w3);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_init_v8qi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_pi8)(char __b7 ,
                                                                                                        char __b6 ,
                                                                                                        char __b5 ,
                                                                                                        char __b4 ,
                                                                                                        char __b3 ,
                                                                                                        char __b2 ,
                                                                                                        char __b1 ,
                                                                                                        char __b0 ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_init_v8qi((int )__b0, (int )__b1, (int )__b2, (int )__b3,
                                         (int )__b4, (int )__b5, (int )__b6, (int )__b7);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                                                          int __i1 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_set_pi32(__i1, __i0);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                                                          short __w1 ,
                                                                                                          short __w2 ,
                                                                                                          short __w3 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_set_pi16(__w3, __w2, __w1, __w0);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                                                         char __b1 ,
                                                                                                         char __b2 ,
                                                                                                         char __b3 ,
                                                                                                         char __b4 ,
                                                                                                         char __b5 ,
                                                                                                         char __b6 ,
                                                                                                         char __b7 ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_pi32)(int __i ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_set_pi32(__i, __i);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_pi16)(short __w ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_set_pi16(__w, __w, __w, __w);
  return (tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_pi8)(char __b ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  return (tmp___0);
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_prefetch)(void const   *__P ,
                                                                                                        enum _mm_hint __I ) 
{ 


  {
  __builtin_prefetch(__P, ((unsigned int )__I & 4U) >> 2, (unsigned int )__I & 3U);
  return;
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_undefined_ps)(void) 
{ 
  __m128 __Y ;

  {
  __Y = __Y;
  return (__Y);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setzero_ps)(void) 
{ 


  {
  return ((float __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
extern int ( /* missing proto */  __builtin_ia32_addss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_addss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_subss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_subss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_mulss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mul_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_mulss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_divss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_div_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_divss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_sqrtss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sqrt_ss)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_sqrtss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_rcpss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_rcp_ss)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_rcpss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_rsqrtss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_rsqrt_ss)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_rsqrtss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_minss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_minss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_maxss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_maxss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 


  {
  return ((__m128 )((__v4sf )__A + (__v4sf )__B));
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 


  {
  return ((__m128 )((__v4sf )__A - (__v4sf )__B));
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 


  {
  return ((__m128 )((__v4sf )__A * (__v4sf )__B));
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_div_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 


  {
  return ((__m128 )((__v4sf )__A / (__v4sf )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_sqrtps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sqrt_ps)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_sqrtps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_rcpps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_rcp_ps)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_rcpps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_rsqrtps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_rsqrt_ps)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_rsqrtps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_minps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_minps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  float __attribute__((____vector_size____(16)))  tmp___0 ;

  {
  tmp___0 = __builtin_ia32_maxps((float __attribute__((____vector_size____(16)))  )((__v4sf )__A),
                                 (float __attribute__((____vector_size____(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_andps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_and_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_andps((double __attribute__((__vector_size__(16), __may_alias__))  )__A,
                                 (double __attribute__((__vector_size__(16), __may_alias__))  )__B);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_andnps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_andnot_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_andnps((double __attribute__((__vector_size__(16), __may_alias__))  )__A,
                                  (double __attribute__((__vector_size__(16), __may_alias__))  )__B);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_orps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_or_ps)(__m128 __A ,
                                                                                                       __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_orps((double __attribute__((__vector_size__(16), __may_alias__))  )__A,
                                (double __attribute__((__vector_size__(16), __may_alias__))  )__B);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_xorps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_xor_ps)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_xorps((double __attribute__((__vector_size__(16), __may_alias__))  )__A,
                                 (double __attribute__((__vector_size__(16), __may_alias__))  )__B);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpeqss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpeqss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpltss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpltss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpless)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpless((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_ss)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpltss((double __attribute__((__vector_size__(16)))  )((__v4sf )__B),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  tmp___1 = __builtin_ia32_movss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )tmp___0));
  return ((__m128 )tmp___1);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpge_ss)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpless((double __attribute__((__vector_size__(16)))  )((__v4sf )__B),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  tmp___1 = __builtin_ia32_movss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )tmp___0));
  return ((__m128 )tmp___1);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpneqss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpneqss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnltss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnltss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnless)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnless((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpngt_ss)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpnltss((double __attribute__((__vector_size__(16)))  )((__v4sf )__B),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  tmp___1 = __builtin_ia32_movss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )tmp___0));
  return ((__m128 )tmp___1);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnge_ss)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpnless((double __attribute__((__vector_size__(16)))  )((__v4sf )__B),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  tmp___1 = __builtin_ia32_movss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                 (double __attribute__((__vector_size__(16)))  )((__v4sf )tmp___0));
  return ((__m128 )tmp___1);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpordss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpordss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpunordss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                                                             __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpunordss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                      (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpeqps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpeqps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpltps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpltps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpleps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpleps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpgtps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_ps)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpgtps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpgeps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpge_ps)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpgeps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpneqps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpneqps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnltps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnltps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnleps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnleps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpngtps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpngt_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpngtps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpngeps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnge_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpngeps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpordps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpordps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpunordps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                                                             __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpunordps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                      (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comieq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comieq((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                  (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comilt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comilt((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                  (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comile)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comile((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                  (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comigt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comigt((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                  (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comige)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                                                        __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comige((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                  (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comineq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comineq((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomieq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomieq((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomilt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomilt((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomile)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomile((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomigt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomigt((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomige)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomige((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomineq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                                                          __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomineq((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtss2si)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtss_si32)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtss2si((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvt_ss2si)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = _mm_cvtss_si32(__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtss2si64)() ;
__inline extern long long ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtss_si64)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtss2si64((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((long long )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtps2pi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtps_pi32)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtps2pi((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvt_ps2pi)(__m128 __A ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cvtps_pi32(__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttss2si)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttss_si32)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttss2si((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtt_ss2si)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = _mm_cvttss_si32(__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttss2si64)() ;
__inline extern long long ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttss_si64)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttss2si64((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((long long )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttps2pi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttps_pi32)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttps2pi((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_cvttps_pi32(__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsi2ss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                                                            int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsi2ss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    __B);
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                                                           int __B ) 
{ 
  __m128 tmp___0 ;

  {
  tmp___0 = _mm_cvtsi32_ss(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsi642ss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                                                            long long __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsi642ss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                      __B);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtpi2ps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                                                            __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (__v2si )__B);
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                                                           __m64 __B ) 
{ 
  __m128 tmp___0 ;

  {
  tmp___0 = _mm_cvtpi32_ps(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movlhps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpi16_ps)(__m64 __A ) 
{ 
  __v4hi __sign ;
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __m128 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp___0 = __builtin_ia32_pcmpgtw((int __attribute__((__vector_size__(8)))  )((__v4hi )0LL),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__A));
  __sign = (__v4hi )tmp___0;
  tmp___1 = __builtin_ia32_punpcklwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                     (int __attribute__((__vector_size__(8)))  )__sign);
  __losi = (__v2si )tmp___1;
  tmp___2 = __builtin_ia32_punpckhwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                     (int __attribute__((__vector_size__(8)))  )__sign);
  __hisi = (__v2si )tmp___2;
  tmp___3 = _mm_setzero_ps();
  __zero = (__v4sf )tmp___3;
  tmp___4 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )__zero,
                                    __losi);
  __ra = (__v4sf )tmp___4;
  tmp___5 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )__ra,
                                    __hisi);
  __rb = (__v4sf )tmp___5;
  tmp___6 = __builtin_ia32_movlhps((double __attribute__((__vector_size__(16)))  )__ra,
                                   (double __attribute__((__vector_size__(16)))  )__rb);
  return ((__m128 )tmp___6);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpu16_ps)(__m64 __A ) 
{ 
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int tmp___0 ;
  int tmp___1 ;
  __m128 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp___0 = __builtin_ia32_punpcklwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                     (int __attribute__((__vector_size__(8)))  )((__v4hi )0LL));
  __losi = (__v2si )tmp___0;
  tmp___1 = __builtin_ia32_punpckhwd((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                     (int __attribute__((__vector_size__(8)))  )((__v4hi )0LL));
  __hisi = (__v2si )tmp___1;
  tmp___2 = _mm_setzero_ps();
  __zero = (__v4sf )tmp___2;
  tmp___3 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )__zero,
                                    __losi);
  __ra = (__v4sf )tmp___3;
  tmp___4 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )__ra,
                                    __hisi);
  __rb = (__v4sf )tmp___4;
  tmp___5 = __builtin_ia32_movlhps((double __attribute__((__vector_size__(16)))  )__ra,
                                   (double __attribute__((__vector_size__(16)))  )__rb);
  return ((__m128 )tmp___5);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpi8_ps)(__m64 __A ) 
{ 
  __v8qi __sign ;
  int tmp___0 ;
  int tmp___1 ;
  __m128 tmp___2 ;

  {
  tmp___0 = __builtin_ia32_pcmpgtb((int __attribute__((__vector_size__(8)))  )((__v8qi )0LL),
                                   (int __attribute__((__vector_size__(8)))  )((__v8qi )__A));
  __sign = (__v8qi )tmp___0;
  tmp___1 = __builtin_ia32_punpcklbw((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                                     (int __attribute__((__vector_size__(8)))  )__sign);
  __A = (__m64 )tmp___1;
  tmp___2 = _mm_cvtpi16_ps(__A);
  return (tmp___2);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpu8_ps)(__m64 __A ) 
{ 
  int tmp___0 ;
  __m128 tmp___1 ;

  {
  tmp___0 = __builtin_ia32_punpcklbw((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                                     (int __attribute__((__vector_size__(8)))  )((__v8qi )0LL));
  __A = (__m64 )tmp___0;
  tmp___1 = _mm_cvtpu16_ps(__A);
  return (tmp___1);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                                                              __m64 __B ) 
{ 
  __v4sf __zero ;
  __m128 tmp___0 ;
  __v4sf __sfa ;
  int tmp___1 ;
  __v4sf __sfb ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___0 = _mm_setzero_ps();
  __zero = (__v4sf )tmp___0;
  tmp___1 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )__zero,
                                    (__v2si )__A);
  __sfa = (__v4sf )tmp___1;
  tmp___2 = __builtin_ia32_cvtpi2ps((double __attribute__((__vector_size__(16)))  )__sfa,
                                    (__v2si )__B);
  __sfb = (__v4sf )tmp___2;
  tmp___3 = __builtin_ia32_movlhps((double __attribute__((__vector_size__(16)))  )__sfa,
                                   (double __attribute__((__vector_size__(16)))  )__sfb);
  return ((__m128 )tmp___3);
}
}
extern int ( /* missing proto */  __builtin_ia32_movhlps)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtps_pi16)(__m128 __A ) 
{ 
  __v4sf __hisf ;
  __v4sf __losf ;
  int tmp___0 ;
  __v2si __hisi ;
  int tmp___1 ;
  __v2si __losi ;
  int tmp___2 ;
  int tmp___3 ;

  {
  __hisf = (__v4sf )__A;
  tmp___0 = __builtin_ia32_movhlps((double __attribute__((__vector_size__(16)))  )__hisf,
                                   (double __attribute__((__vector_size__(16)))  )__hisf);
  __losf = (__v4sf )tmp___0;
  tmp___1 = __builtin_ia32_cvtps2pi((double __attribute__((__vector_size__(16)))  )__hisf);
  __hisi = (__v2si )tmp___1;
  tmp___2 = __builtin_ia32_cvtps2pi((double __attribute__((__vector_size__(16)))  )__losf);
  __losi = (__v2si )tmp___2;
  tmp___3 = __builtin_ia32_packssdw(__hisi, __losi);
  return ((__m64 )tmp___3);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtps_pi8)(__m128 __A ) 
{ 
  __v4hi __tmp ;
  __m64 tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = _mm_cvtps_pi16(__A);
  __tmp = (__v4hi )tmp___0;
  tmp___1 = __builtin_ia32_packsswb((int __attribute__((__vector_size__(8)))  )__tmp,
                                    (int __attribute__((__vector_size__(8)))  )((__v4hi )0LL));
  return ((__m64 )tmp___1);
}
}
extern int ( /* missing proto */  __builtin_ia32_shufps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_shuffle_ps)(__m128 __A ,
                                                                                                            __m128 __B ,
                                                                                                            int const   __mask ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_shufps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                  (double __attribute__((__vector_size__(16)))  )((__v4sf )__B),
                                  __mask);
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_ps)(__m128 __A ,
                                                                                                             __m128 __B ) 
{ 
  float __attribute__((____vector_size____(16)))  tmp___0 ;

  {
  tmp___0 = __builtin_ia32_unpckhps((float __attribute__((____vector_size____(16)))  )((__v4sf )__A),
                                    (float __attribute__((____vector_size____(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_ps)(__m128 __A ,
                                                                                                             __m128 __B ) 
{ 
  float __attribute__((____vector_size____(16)))  tmp___0 ;

  {
  tmp___0 = __builtin_ia32_unpcklps((float __attribute__((____vector_size____(16)))  )((__v4sf )__A),
                                    (float __attribute__((____vector_size____(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_loadhps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                                                          __m64 const   *__P ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_loadhps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (__v2sf const   *)__P);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_storehps)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                                                         __m128 __A ) 
{ 


  {
  __builtin_ia32_storehps((__v2sf *)__P, (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return;
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movehl_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_movhlps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movelh_ps)(__m128 __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_movlhps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_loadlps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadl_pi)(__m128 __A ,
                                                                                                          __m64 const   *__P ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_loadlps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                   (__v2sf const   *)__P);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_storelps)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                                                         __m128 __A ) 
{ 


  {
  __builtin_ia32_storelps((__v2sf *)__P, (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_movmskps)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movemask_ps)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_movmskps((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_stmxcsr)() ;
__inline extern unsigned int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_getcsr)(void) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_stmxcsr();
  return ((unsigned int )tmp___0);
}
}
__inline extern unsigned int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_GET_EXCEPTION_STATE)(void) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  return (tmp___0 & 63U);
}
}
__inline extern unsigned int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_GET_EXCEPTION_MASK)(void) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  return (tmp___0 & 8064U);
}
}
__inline extern unsigned int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_GET_ROUNDING_MODE)(void) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  return (tmp___0 & 24576U);
}
}
__inline extern unsigned int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_GET_FLUSH_ZERO_MODE)(void) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  return (tmp___0 & 32768U);
}
}
extern int ( /* missing proto */  __builtin_ia32_ldmxcsr)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setcsr)(unsigned int __I ) 
{ 


  {
  __builtin_ia32_ldmxcsr(__I);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  _mm_setcsr((tmp___0 & 4294967232U) | __mask);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_SET_EXCEPTION_MASK)(unsigned int __mask ) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  _mm_setcsr((tmp___0 & 4294959231U) | __mask);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_SET_ROUNDING_MODE)(unsigned int __mode ) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  _mm_setcsr((tmp___0 & 4294942719U) | __mode);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _MM_SET_FLUSH_ZERO_MODE)(unsigned int __mode ) 
{ 
  unsigned int tmp___0 ;

  {
  tmp___0 = _mm_getcsr();
  _mm_setcsr((tmp___0 & 4294934527U) | __mode);
  return;
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_ss)(float __F ) 
{ 


  {
  return ((float __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_ps1)(float __F ) 
{ 
  __m128 tmp___0 ;

  {
  tmp___0 = _mm_set_ss(__F);
  return (tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load_ss)(float const   *__P ) 
{ 
  __m128 tmp___0 ;

  {
  tmp___0 = _mm_set_ss((float )*__P);
  return (tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load_ps1)(float const   *__P ) 
{ 
  __m128 tmp___0 ;

  {
  tmp___0 = _mm_load_ss(__P);
  return (tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load_ps)(float const   *__P ) 
{ 


  {
  return (*((__m128 *)__P));
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadu_ps)(float const   *__P ) 
{ 


  {
  return ((__m128 )*((__m128_u *)__P));
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadr_ps)(float const   *__P ) 
{ 
  __v4sf __tmp ;
  int tmp___0 ;

  {
  __tmp = *((__v4sf *)__P);
  tmp___0 = __builtin_ia32_shufps((double __attribute__((__vector_size__(16)))  )__tmp,
                                  (double __attribute__((__vector_size__(16)))  )__tmp,
                                  ((1 << 4) | (2 << 2)) | 3);
  return ((__m128 )tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_ps)(float const   __Z ,
                                                                                                        float const   __Y ,
                                                                                                        float const   __X ,
                                                                                                        float const   __W ) 
{ 


  {
  return ((float __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_ps)(float __Z ,
                                                                                                         float __Y ,
                                                                                                         float __X ,
                                                                                                         float __W ) 
{ 


  {
  return ((float __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_ss)(float *__P ,
                                                                                                        __m128 __A ) 
{ 


  {
  return;
}
}
__inline extern float ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtss_f32)(__m128 __A ) 
{ 


  {
  return ((float )0);
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_ps)(float *__P ,
                                                                                                        __m128 __A ) 
{ 


  {
  *((__m128 *)__P) = __A;
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storeu_ps)(float *__P ,
                                                                                                         __m128 __A ) 
{ 


  {
  *((__m128_u *)__P) = (__m128_u )__A;
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store1_ps)(float *__P ,
                                                                                                         __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int tmp___0 ;

  {
  __va = (__v4sf )__A;
  tmp___0 = __builtin_ia32_shufps((double __attribute__((__vector_size__(16)))  )__va,
                                  (double __attribute__((__vector_size__(16)))  )__va,
                                  0);
  __tmp = (__v4sf )tmp___0;
  _mm_storeu_ps(__P, (__m128 )__tmp);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_ps1)(float *__P ,
                                                                                                         __m128 __A ) 
{ 


  {
  _mm_store1_ps(__P, __A);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storer_ps)(float *__P ,
                                                                                                         __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int tmp___0 ;

  {
  __va = (__v4sf )__A;
  tmp___0 = __builtin_ia32_shufps((double __attribute__((__vector_size__(16)))  )__va,
                                  (double __attribute__((__vector_size__(16)))  )__va,
                                  ((1 << 4) | (2 << 2)) | 3);
  __tmp = (__v4sf )tmp___0;
  _mm_store_ps(__P, (__m128 )__tmp);
  return;
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_move_ss)(__m128 __A ,
                                                                                                         __m128 __B ) 
{ 


  {
  return ((float __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v4hi)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_extract_pi16)(__m64 const   __A ,
                                                                                                           int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_ext_v4hi((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                        __N);
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pextrw)(__m64 const   __A ,
                                                                                                    int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = _mm_extract_pi16(__A, __N);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_set_v4hi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_insert_pi16)(__m64 const   __A ,
                                                                                                            int const   __D ,
                                                                                                            int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_set_v4hi((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                        __D, __N);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pinsrw)(__m64 const   __A ,
                                                                                                      int const   __D ,
                                                                                                      int const   __N ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_insert_pi16(__A, __D, __N);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmaxsw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                                                         __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmaxsw((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                  (int __attribute__((__vector_size__(8)))  )((__v4hi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmaxsw)(__m64 __A ,
                                                                                                      __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_max_pi16(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmaxub)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_pu8)(__m64 __A ,
                                                                                                        __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmaxub((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                                  (int __attribute__((__vector_size__(8)))  )((__v8qi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmaxub)(__m64 __A ,
                                                                                                      __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_max_pu8(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pminsw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                                                         __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pminsw((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                  (int __attribute__((__vector_size__(8)))  )((__v4hi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pminsw)(__m64 __A ,
                                                                                                      __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_min_pi16(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pminub)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_pu8)(__m64 __A ,
                                                                                                        __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pminub((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                                  (int __attribute__((__vector_size__(8)))  )((__v8qi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pminub)(__m64 __A ,
                                                                                                      __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_min_pu8(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmovmskb)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movemask_pi8)(__m64 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmovmskb((int __attribute__((__vector_size__(8)))  )((__v8qi )__A));
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmovmskb)(__m64 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = _mm_movemask_pi8(__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmulhuw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                                                           __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmulhuw((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                   (int __attribute__((__vector_size__(8)))  )((__v4hi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pmulhuw)(__m64 __A ,
                                                                                                       __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_mulhi_pu16(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pshufw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_shuffle_pi16)(__m64 __A ,
                                                                                                             int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pshufw((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                  __N);
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pshufw)(__m64 __A ,
                                                                                                      int const   __N ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_shuffle_pi16(__A, __N);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_maskmovq)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                                                             __m64 __N ,
                                                                                                             char *__P ) 
{ 


  {
  __builtin_ia32_maskmovq((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                          (int __attribute__((__vector_size__(8)))  )((__v8qi )__N),
                          __P);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_maskmovq)(__m64 __A ,
                                                                                                       __m64 __N ,
                                                                                                       char *__P ) 
{ 


  {
  _mm_maskmove_si64(__A, __N, __P);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_pavgb)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_avg_pu8)(__m64 __A ,
                                                                                                        __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pavgb((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                                 (int __attribute__((__vector_size__(8)))  )((__v8qi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pavgb)(__m64 __A ,
                                                                                                     __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_avg_pu8(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pavgw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                                                         __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pavgw((int __attribute__((__vector_size__(8)))  )((__v4hi )__A),
                                 (int __attribute__((__vector_size__(8)))  )((__v4hi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_pavgw)(__m64 __A ,
                                                                                                     __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_avg_pu16(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psadbw)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sad_pu8)(__m64 __A ,
                                                                                                        __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psadbw((int __attribute__((__vector_size__(8)))  )((__v8qi )__A),
                                  (int __attribute__((__vector_size__(8)))  )((__v8qi )__B));
  return ((__m64 )tmp___0);
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _m_psadbw)(__m64 __A ,
                                                                                                      __m64 __B ) 
{ 
  __m64 tmp___0 ;

  {
  tmp___0 = _mm_sad_pu8(__A, __B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movntq)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                                                         __m64 __A ) 
{ 


  {
  __builtin_ia32_movntq((unsigned long long *)__P, (unsigned long long )__A);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_movntps)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_stream_ps)(float *__P ,
                                                                                                         __m128 __A ) 
{ 


  {
  __builtin_ia32_movntps(__P, (double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_sfence)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sfence)(void) 
{ 


  {
  __builtin_ia32_sfence();
  return;
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_sd)(double __F ) 
{ 


  {
  return ((double __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_pd1)(double __F ) 
{ 
  __m128d tmp___0 ;

  {
  tmp___0 = _mm_set_sd(__F);
  return (tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_pd)(double __W ,
                                                                                                         double __X ) 
{ 


  {
  return ((double __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_undefined_pd)(void) 
{ 
  __m128d __Y ;

  {
  __Y = __Y;
  return (__Y);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setzero_pd)(void) 
{ 


  {
  return ((double __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_move_sd)(__m128d __A ,
                                                                                                          __m128d __B ) 
{ 


  {
  return ((double __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load_pd)(double const   *__P ) 
{ 


  {
  return (*((__m128d *)__P));
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadu_pd)(double const   *__P ) 
{ 


  {
  return ((__m128d )*((__m128d_u *)__P));
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load1_pd)(double const   *__P ) 
{ 
  __m128d tmp___0 ;

  {
  tmp___0 = _mm_set_sd((double )*__P);
  return (tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load_pd1)(double const   *__P ) 
{ 
  __m128d tmp___0 ;

  {
  tmp___0 = _mm_load1_pd(__P);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_shufpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadr_pd)(double const   *__P ) 
{ 
  __m128d __tmp ;
  __m128d tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = _mm_load_pd(__P);
  __tmp = tmp___0;
  tmp___1 = __builtin_ia32_shufpd(__tmp, __tmp, 1);
  return ((__m128d )tmp___1);
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_pd)(double *__P ,
                                                                                                        __m128d __A ) 
{ 


  {
  *((__m128d *)__P) = __A;
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storeu_pd)(double *__P ,
                                                                                                         __m128d __A ) 
{ 


  {
  *((__m128d_u *)__P) = (__m128d_u )__A;
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_sd)(double *__P ,
                                                                                                        __m128d __A ) 
{ 


  {
  return;
}
}
__inline extern double ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsd_f64)(__m128d __A ) 
{ 


  {
  return ((double )0);
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storel_pd)(double *__P ,
                                                                                                         __m128d __A ) 
{ 


  {
  _mm_store_sd(__P, __A);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store1_pd)(double *__P ,
                                                                                                         __m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_shufpd(__A, __A, 0);
  _mm_store_pd(__P, (__m128d )tmp___0);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_pd1)(double *__P ,
                                                                                                         __m128d __A ) 
{ 


  {
  _mm_store1_pd(__P, __A);
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storer_pd)(double *__P ,
                                                                                                         __m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_shufpd(__A, __A, 1);
  _mm_store_pd(__P, (__m128d )tmp___0);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v4si)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi128_si32)(__m128i __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_ext_v4si((__v4si )__A, 0);
  return (tmp___0);
}
}
__inline extern long long ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi128_si64)(__m128i __A ) 
{ 


  {
  return (0LL);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 


  {
  return ((__m128d )((__v2df )__A + (__v2df )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_addsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_addsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 


  {
  return ((__m128d )((__v2df )__A - (__v2df )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_subsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_subsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 


  {
  return ((__m128d )((__v2df )__A * (__v2df )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_mulsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mul_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_mulsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_div_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 


  {
  return ((__m128d )((__v2df )__A / (__v2df )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_divsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_div_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_divsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_sqrtpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sqrt_pd)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_sqrtpd((__v2df )__A);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movsd)() ;
extern int ( /* missing proto */  __builtin_ia32_sqrtsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                                                          __m128d __B ) 
{ 
  __v2df __tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_movsd((__v2df )__A, (__v2df )__B);
  __tmp = (__v2df )tmp___0;
  tmp___1 = __builtin_ia32_sqrtsd(__tmp);
  return ((__m128d )tmp___1);
}
}
extern int ( /* missing proto */  __builtin_ia32_minpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_minpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_minsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_minsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_maxpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_maxpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_maxsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_maxsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_andpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_and_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_andpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_andnpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_andnot_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_andnpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_orpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_or_pd)(__m128d __A ,
                                                                                                        __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_orpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_xorpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_xor_pd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_xorpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpeqpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpeqpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpltpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpltpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmplepd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmplepd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpgtpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_pd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpgtpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpgepd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpge_pd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpgepd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpneqpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpneqpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnltpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnltpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnlepd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnlepd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpngtpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpngt_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpngtpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpngepd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnge_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpngepd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpordpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpordpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpunordpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                                                              __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpunordpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpeqsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpeqsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpltsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpltsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmplesd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmplesd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_sd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpltsd((__v2df )__B, (__v2df )__A);
  tmp___1 = __builtin_ia32_movsd((__v2df )__A, (__v2df )tmp___0);
  return ((__m128d )tmp___1);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpge_sd)(__m128d __A ,
                                                                                                           __m128d __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmplesd((__v2df )__B, (__v2df )__A);
  tmp___1 = __builtin_ia32_movsd((__v2df )__A, (__v2df )tmp___0);
  return ((__m128d )tmp___1);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpneqsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpneqsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnltsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnltsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpnlesd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpnlesd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpngt_sd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpnltsd((__v2df )__B, (__v2df )__A);
  tmp___1 = __builtin_ia32_movsd((__v2df )__A, (__v2df )tmp___0);
  return ((__m128d )tmp___1);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpnge_sd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = __builtin_ia32_cmpnlesd((__v2df )__B, (__v2df )__A);
  tmp___1 = __builtin_ia32_movsd((__v2df )__A, (__v2df )tmp___0);
  return ((__m128d )tmp___1);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpordsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                                                            __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpordsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cmpunordsd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                                                              __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cmpunordsd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comisdeq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                                                        __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comisdeq((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comisdlt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                                                        __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comisdlt((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comisdle)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                                                        __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comisdle((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comisdgt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                                                        __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comisdgt((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comisdge)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                                                        __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comisdge((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_comisdneq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_comisdneq((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomisdeq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomisdeq((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomisdlt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomisdlt((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomisdle)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomisdle((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomisdgt)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomisdgt((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomisdge)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                                                         __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomisdge((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_ucomisdneq)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                                                          __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_ucomisdneq((__v2df )__A, (__v2df )__B);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                                                             long long __q0 ) 
{ 


  {
  return ((long long __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                                                            __m64 __q0 ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64x((long long )__q1, (long long )__q0);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_epi32)(int __q3 ,
                                                                                                            int __q2 ,
                                                                                                            int __q1 ,
                                                                                                            int __q0 ) 
{ 


  {
  return ((long long __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_epi16)(short __q7 ,
                                                                                                            short __q6 ,
                                                                                                            short __q5 ,
                                                                                                            short __q4 ,
                                                                                                            short __q3 ,
                                                                                                            short __q2 ,
                                                                                                            short __q1 ,
                                                                                                            short __q0 ) 
{ 


  {
  return ((long long __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set_epi8)(char __q15 ,
                                                                                                           char __q14 ,
                                                                                                           char __q13 ,
                                                                                                           char __q12 ,
                                                                                                           char __q11 ,
                                                                                                           char __q10 ,
                                                                                                           char __q09 ,
                                                                                                           char __q08 ,
                                                                                                           char __q07 ,
                                                                                                           char __q06 ,
                                                                                                           char __q05 ,
                                                                                                           char __q04 ,
                                                                                                           char __q03 ,
                                                                                                           char __q02 ,
                                                                                                           char __q01 ,
                                                                                                           char __q00 ) 
{ 


  {
  return ((long long __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_epi64x)(long long __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64x(__A, __A);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_epi64)(__m64 __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64(__A, __A);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_epi32)(int __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi32(__A, __A, __A, __A);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_epi16)(short __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_set1_epi8)(char __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A,
                         __A, __A, __A, __A);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                                                             __m64 __q1 ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64(__q1, __q0);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                                                             int __q1 ,
                                                                                                             int __q2 ,
                                                                                                             int __q3 ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi32(__q3, __q2, __q1, __q0);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                                                             short __q1 ,
                                                                                                             short __q2 ,
                                                                                                             short __q3 ,
                                                                                                             short __q4 ,
                                                                                                             short __q5 ,
                                                                                                             short __q6 ,
                                                                                                             short __q7 ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                                                            char __q01 ,
                                                                                                            char __q02 ,
                                                                                                            char __q03 ,
                                                                                                            char __q04 ,
                                                                                                            char __q05 ,
                                                                                                            char __q06 ,
                                                                                                            char __q07 ,
                                                                                                            char __q08 ,
                                                                                                            char __q09 ,
                                                                                                            char __q10 ,
                                                                                                            char __q11 ,
                                                                                                            char __q12 ,
                                                                                                            char __q13 ,
                                                                                                            char __q14 ,
                                                                                                            char __q15 ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08, __q07,
                         __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_load_si128)(__m128i const   *__P ) 
{ 


  {
  return ((__m128i )*__P);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadu_si128)(__m128i_u const   *__P ) 
{ 


  {
  return ((__m128i )*__P);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadl_epi64)(__m128i_u const   *__P ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64((__m64 )0LL, (__m64 )*((__m64_u *)__P));
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadu_si64)(void const   *__P ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_loadl_epi64((__m128i_u const   *)((__m128i_u *)__P));
  return (tmp___0);
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                                                           __m128i __B ) 
{ 


  {
  *__P = __B;
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                                                            __m128i __B ) 
{ 


  {
  *__P = (__m128i_u )__B;
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                                                            __m128i __B ) 
{ 


  {
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_storeu_si64)(void *__P ,
                                                                                                           __m128i __B ) 
{ 


  {
  _mm_storel_epi64((__m128i_u *)__P, __B);
  return;
}
}
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movepi64_pi64)(__m128i __B ) 
{ 


  {
  return ((int __attribute__((__vector_size__(8), __may_alias__))  )0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movpi64_epi64)(__m64 __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64((__m64 )0LL, __A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_move_epi64)(__m128i __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_movq128((__v2di )__A);
  return ((__m128i )tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_undefined_si128)(void) 
{ 
  __m128i __Y ;

  {
  __Y = __Y;
  return (__Y);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_setzero_si128)(void) 
{ 


  {
  return ((long long __attribute__((__vector_size__(16), __may_alias__))  )0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtdq2pd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtepi32_pd)(__m128i __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtdq2pd((__v4si )__A);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtdq2ps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtepi32_ps)(__m128i __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtdq2ps((__v4si )__A);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtpd2dq)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpd_epi32)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtpd2dq((__v2df )__A);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtpd2pi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpd_pi32)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtpd2pi((__v2df )__A);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtpd2ps)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpd_ps)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtpd2ps((__v2df )__A);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttpd2dq)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttpd_epi32)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttpd2dq((__v2df )__A);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttpd2pi)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttpd_pi32)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttpd2pi((__v2df )__A);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtpi2pd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtpi32_pd)(__m64 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtpi2pd((__v2si )__A);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtps2dq)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtps_epi32)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtps2dq((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttps2dq)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttps_epi32)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttps2dq((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtps2pd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtps_pd)(__m128 __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtps2pd((double __attribute__((__vector_size__(16)))  )((__v4sf )__A));
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsd_si32)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsd2si((__v2df )__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si64)() ;
__inline extern long long ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsd_si64)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsd2si64((__v2df )__A);
  return ((long long )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttsd_si32)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttsd2si((__v2df )__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si64)() ;
__inline extern long long ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvttsd_si64)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvttsd2si64((__v2df )__A);
  return ((long long )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsd2ss)() ;
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                                                          __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsd2ss((double __attribute__((__vector_size__(16)))  )((__v4sf )__A),
                                    (__v2df )__B);
  return ((__m128 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsi2sd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsi2sd((__v2df )__A, __B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtsi642sd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                                                             long long __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtsi642sd((__v2df )__A, __B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_cvtss2sd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                                                           __m128 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_cvtss2sd((__v2df )__A, (double __attribute__((__vector_size__(16)))  )((__v4sf )__B));
  return ((__m128d )tmp___0);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_shuffle_pd)(__m128d __A ,
                                                                                                             __m128d __B ,
                                                                                                             int const   __mask ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_shufpd((__v2df )__A, (__v2df )__B, __mask);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_unpckhpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_pd)(__m128d __A ,
                                                                                                              __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_unpckhpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_unpcklpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_pd)(__m128d __A ,
                                                                                                              __m128d __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_unpcklpd((__v2df )__A, (__v2df )__B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_loadhpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                                                           double const   *__B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_loadhpd((__v2df )__A, __B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_loadlpd)() ;
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_loadl_pd)(__m128d __A ,
                                                                                                           double const   *__B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_loadlpd((__v2df )__A, __B);
  return ((__m128d )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movmskpd)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movemask_pd)(__m128d __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_movmskpd((__v2df )__A);
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_packsswb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_packsswb128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                       (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_packssdw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_packssdw128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_packuswb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                                                               __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_packuswb128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                       (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhbw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                                                                __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhbw128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                        (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhwd128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_epi16)(__m128i __A ,
                                                                                                                 __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhwd128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                        (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhdq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_epi32)(__m128i __A ,
                                                                                                                 __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhdq128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckhqdq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpackhi_epi64)(__m128i __A ,
                                                                                                                 __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckhqdq128((__v2di )__A, (__v2di )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpcklbw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_epi8)(__m128i __A ,
                                                                                                                __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpcklbw128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                        (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpcklwd128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_epi16)(__m128i __A ,
                                                                                                                 __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpcklwd128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                        (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpckldq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_epi32)(__m128i __A ,
                                                                                                                 __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpckldq128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_punpcklqdq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_unpacklo_epi64)(__m128i __A ,
                                                                                                                 __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_punpcklqdq128((__v2di )__A, (__v2di )__B);
  return ((__m128i )tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v16qu )__A) + (int __attribute__((__vector_size__(16)))  )((__v16qu )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v8hu )__A) + (int __attribute__((__vector_size__(16)))  )((__v8hu )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((__v4su )__A + (__v4su )__B));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((__v2du )__A + (__v2du )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_paddsb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddsb128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddsw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddsw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddusb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddusb128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                      (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_paddusw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_paddusw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                      (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v16qu )__A) - (int __attribute__((__vector_size__(16)))  )((__v16qu )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v8hu )__A) - (int __attribute__((__vector_size__(16)))  )((__v8hu )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((__v4su )__A - (__v4su )__B));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((__v2du )__A - (__v2du )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_psubsb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubsb128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubsw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubsw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubusb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubusb128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                      (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psubusw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psubusw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                      (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmaddwd128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmaddwd128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                      (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmulhw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmulhw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v8hu )__A) * (int __attribute__((__vector_size__(16)))  )((__v8hu )__B)));
}
}
extern int ( /* missing proto */  __builtin_ia32_pmuludq)() ;
__inline extern __m64 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                                                         __m64 __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmuludq((__v2si )__A, (__v2si )__B);
  return ((__m64 )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmuludq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmuludq128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllwi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllwi128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pslldi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pslldi128((__v4si )__A, __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllqi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllqi128((__v2di )__A, __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrawi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrawi128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psradi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psradi128((__v4si )__A, __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrldqi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_bsrli_si128)(__m128i __A ,
                                                                                                              int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrldqi128(__A, __N * 8);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pslldqi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_bslli_si128)(__m128i __A ,
                                                                                                              int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pslldqi128(__A, __N * 8);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlwi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlwi128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrldi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrldi128((__v4si )__A, __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlqi128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                                                             int __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlqi128((__v2di )__A, __B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                    (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pslld128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pslld128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psllq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psllq128((__v2di )__A, (__v2di )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psraw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psraw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                    (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrad128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrad128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                    (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrld128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrld128((__v4si )__A, (__v4si )__B);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psrlq128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psrlq128((__v2di )__A, (__v2di )__B);
  return ((__m128i )tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_and_si128)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((__v2du )__A & (__v2du )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_pandn128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_andnot_si128)(__m128i __A ,
                                                                                                               __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pandn128((__v2di )__A, (__v2di )__B);
  return ((__m128i )tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_or_si128)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 


  {
  return ((__m128i )((__v2du )__A | (__v2du )__B));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 


  {
  return ((__m128i )((__v2du )__A ^ (__v2du )__B));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v16qi )__A) == (int __attribute__((__vector_size__(16)))  )((__v16qi )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v8hi )__A) == (int __attribute__((__vector_size__(16)))  )((__v8hi )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((__v4si )__A == (__v4si )__B));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v16qs )__A) < (int __attribute__((__vector_size__(16)))  )((__v16qs )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v8hi )__A) < (int __attribute__((__vector_size__(16)))  )((__v8hi )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((__v4si )__A < (__v4si )__B));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                                                             __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v16qs )__A) > (int __attribute__((__vector_size__(16)))  )((__v16qs )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((int __attribute__((__vector_size__(16)))  )((__v8hi )__A) > (int __attribute__((__vector_size__(16)))  )((__v8hi )__B)));
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 


  {
  return ((__m128i )((__v4si )__A > (__v4si )__B));
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v8hi)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_extract_epi16)(__m128i const   __A ,
                                                                                                            int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_ext_v8hi((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                        __N);
  return ((int )((unsigned short )tmp___0));
}
}
extern int ( /* missing proto */  __builtin_ia32_vec_set_v8hi)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_insert_epi16)(__m128i const   __A ,
                                                                                                               int const   __D ,
                                                                                                               int const   __N ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_vec_set_v8hi((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                        __D, __N);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmaxsw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmaxsw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmaxub128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmaxub128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pminsw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pminsw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pminub128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pminub128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmovmskb128)() ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_movemask_epi8)(__m128i __A ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmovmskb128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A));
  return (tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pmulhuw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                                                              __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pmulhuw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                      (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pshufhw)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_shufflehi_epi16)(__m128i __A ,
                                                                                                                  int const   __mask ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pshufhw((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                   __mask);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pshuflw)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_shufflelo_epi16)(__m128i __A ,
                                                                                                                  int const   __mask ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pshuflw((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                   __mask);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pshufd)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_shuffle_epi32)(__m128i __A ,
                                                                                                                int const   __mask ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pshufd((__v4si )__A, __mask);
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_maskmovdqu)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                                                               __m128i __B ,
                                                                                                               char *__C ) 
{ 


  {
  __builtin_ia32_maskmovdqu((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                            (int __attribute__((__vector_size__(16)))  )((__v16qi )__B),
                            __C);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_pavgb128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pavgb128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                    (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_pavgw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                                                            __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_pavgw128((int __attribute__((__vector_size__(16)))  )((__v8hi )__A),
                                    (int __attribute__((__vector_size__(16)))  )((__v8hi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_psadbw128)() ;
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                                                           __m128i __B ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = __builtin_ia32_psadbw128((int __attribute__((__vector_size__(16)))  )((__v16qi )__A),
                                     (int __attribute__((__vector_size__(16)))  )((__v16qi )__B));
  return ((__m128i )tmp___0);
}
}
extern int ( /* missing proto */  __builtin_ia32_movnti)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_stream_si32)(int *__A ,
                                                                                                           int __B ) 
{ 


  {
  __builtin_ia32_movnti(__A, __B);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_movnti64)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_stream_si64)(long long *__A ,
                                                                                                           long long __B ) 
{ 


  {
  __builtin_ia32_movnti64(__A, __B);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_movntdq)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                                                            __m128i __B ) 
{ 


  {
  __builtin_ia32_movntdq((__v2di *)__A, (__v2di )__B);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_movntpd)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_stream_pd)(double *__A ,
                                                                                                         __m128d __B ) 
{ 


  {
  __builtin_ia32_movntpd(__A, (__v2df )__B);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_clflush)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_clflush)(void const   *__A ) 
{ 


  {
  __builtin_ia32_clflush(__A);
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_lfence)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_lfence)(void) 
{ 


  {
  __builtin_ia32_lfence();
  return;
}
}
extern int ( /* missing proto */  __builtin_ia32_mfence)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_mfence)(void) 
{ 


  {
  __builtin_ia32_mfence();
  return;
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi32_si128)(int __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi32(0, 0, 0, __A);
  return (tmp___0);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_cvtsi64_si128)(long long __A ) 
{ 
  __m128i tmp___0 ;

  {
  tmp___0 = _mm_set_epi64x(0LL, __A);
  return (tmp___0);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_castpd_ps)(__m128d __A ) 
{ 


  {
  return ((__m128 )__A);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_castpd_si128)(__m128d __A ) 
{ 


  {
  return ((__m128i )__A);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_castps_pd)(__m128 __A ) 
{ 


  {
  return ((__m128d )__A);
}
}
__inline extern __m128i ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_castps_si128)(__m128 __A ) 
{ 


  {
  return ((__m128i )__A);
}
}
__inline extern __m128 ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_castsi128_ps)(__m128i __A ) 
{ 


  {
  return ((__m128 )__A);
}
}
__inline extern __m128d ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_castsi128_pd)(__m128i __A ) 
{ 


  {
  return ((__m128d )__A);
}
}
extern int ( /* missing proto */  __builtin_ia32_pause)() ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) _mm_pause)(void) 
{ 


  {
  __builtin_ia32_pause();
  return;
}
}
extern cl_int clGetPlatformIDs(cl_uint num_entries , cl_platform_id *platforms , cl_uint *num_platforms ) ;
extern cl_int clGetPlatformInfo(cl_platform_id platform , cl_platform_info param_name ,
                                size_t param_value_size , void *param_value , size_t *param_value_size_ret ) ;
extern cl_int clGetDeviceIDs(cl_platform_id platform , cl_device_type device_type ,
                             cl_uint num_entries , cl_device_id *devices , cl_uint *num_devices ) ;
extern cl_int clGetDeviceInfo(cl_device_id device , cl_device_info param_name , size_t param_value_size ,
                              void *param_value , size_t *param_value_size_ret ) ;
extern cl_context clCreateContext(cl_context_properties const   *properties , cl_uint num_devices ,
                                  cl_device_id const   *devices , void (*pfn_notify)(char const   *errinfo ,
                                                                                     void const   *private_info ,
                                                                                     size_t cb ,
                                                                                     void *user_data ) ,
                                  void *user_data , cl_int *errcode_ret ) ;
extern cl_int clReleaseContext(cl_context context ) ;
extern cl_int clReleaseCommandQueue(cl_command_queue command_queue ) ;
extern cl_mem clCreateBuffer(cl_context context , cl_mem_flags flags , size_t size ,
                             void *host_ptr , cl_int *errcode_ret ) ;
extern cl_int clRetainMemObject(cl_mem memobj ) ;
extern cl_int clReleaseMemObject(cl_mem memobj ) ;
extern cl_program clCreateProgramWithSource(cl_context context , cl_uint count , char const   **strings ,
                                            size_t const   *lengths , cl_int *errcode_ret ) ;
extern cl_program clCreateProgramWithBinary(cl_context context , cl_uint num_devices ,
                                            cl_device_id const   *device_list , size_t const   *lengths ,
                                            unsigned char const   **binaries , cl_int *binary_status ,
                                            cl_int *errcode_ret ) ;
extern cl_int clReleaseProgram(cl_program program ) ;
extern cl_int clBuildProgram(cl_program program , cl_uint num_devices , cl_device_id const   *device_list ,
                             char const   *options , void (*pfn_notify)(cl_program program ,
                                                                        void *user_data ) ,
                             void *user_data ) ;
extern cl_int clGetProgramInfo(cl_program program , cl_program_info param_name , size_t param_value_size ,
                               void *param_value , size_t *param_value_size_ret ) ;
extern cl_int clGetProgramBuildInfo(cl_program program , cl_device_id device , cl_program_build_info param_name ,
                                    size_t param_value_size , void *param_value ,
                                    size_t *param_value_size_ret ) ;
extern cl_kernel clCreateKernel(cl_program program , char const   *kernel_name , cl_int *errcode_ret ) ;
extern cl_int clReleaseKernel(cl_kernel kernel ) ;
extern cl_int clSetKernelArg(cl_kernel kernel , cl_uint arg_index , size_t arg_size ,
                             void const   *arg_value ) ;
extern cl_int clWaitForEvents(cl_uint num_events , cl_event const   *event_list ) ;
extern cl_int clReleaseEvent(cl_event event ) ;
extern cl_int clEnqueueWriteBuffer(cl_command_queue command_queue , cl_mem buffer ,
                                   cl_bool blocking_write , size_t offset , size_t size ,
                                   void const   *ptr , cl_uint num_events_in_wait_list ,
                                   cl_event const   *event_wait_list , cl_event *event ) ;
extern void *clEnqueueMapBuffer(cl_command_queue command_queue , cl_mem buffer , cl_bool blocking_map ,
                                cl_map_flags map_flags , size_t offset , size_t size ,
                                cl_uint num_events_in_wait_list , cl_event const   *event_wait_list ,
                                cl_event *event , cl_int *errcode_ret ) ;
extern cl_int clEnqueueUnmapMemObject(cl_command_queue command_queue , cl_mem memobj ,
                                      void *mapped_ptr , cl_uint num_events_in_wait_list ,
                                      cl_event const   *event_wait_list , cl_event *event ) ;
extern cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue , cl_kernel kernel ,
                                     cl_uint work_dim , size_t const   *global_work_offset ,
                                     size_t const   *global_work_size , size_t const   *local_work_size ,
                                     cl_uint num_events_in_wait_list , cl_event const   *event_wait_list ,
                                     cl_event *event ) ;
extern cl_command_queue clCreateCommandQueue(cl_context context , cl_device_id device ,
                                             cl_command_queue_properties properties ,
                                             cl_int *errcode_ret )  __attribute__((__deprecated__)) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
int vg_output_timing(vg_context_t *vcp , int cycle , struct timeval *last ) ;
int vg_context_hash160_sort(vg_context_t *vcp , void *buf ) ;
void vg_context_thread_exit(vg_context_t *vcp ) ;
int vg_exec_context_init(vg_context_t *vcp , vg_exec_context_t *vxcp ) ;
void vg_exec_context_del(vg_exec_context_t *vxcp ) ;
void vg_exec_context_calc_address(vg_exec_context_t *vxcp ) ;
void vg_exec_context_downgrade_lock(vg_exec_context_t *vxcp ) ;
int vg_exec_context_upgrade_lock(vg_exec_context_t *vxcp ) ;
void vg_exec_context_yield(vg_exec_context_t *vxcp ) ;
void vg_ocl_context_free(vg_ocl_context_t *vocp ) ;
void fdumphex(FILE *fp , unsigned char const   *src , size_t len ) ;
void fdumpbn(FILE *fp , BIGNUM const   *bn ) ;
static void vg_ocl_free_args(vg_ocl_context_t *vocp ) ;
static void *vg_opencl_loop(vg_exec_context_t *arg ) ;
void vg_exec_downgrade_lock(vg_exec_context_t *vxcp ) 
{ 


  {
  return;
}
}
int vg_exec_upgrade_lock(vg_exec_context_t *vxcp ) 
{ 


  {
  return (0);
}
}
static char tmp[64]  ;
static char const   *vg_ocl_strerror(cl_int ret ) 
{ 


  {
  switch (ret) {
  case 0: 
  return ("CL_SUCCESS");
  case -1: 
  return ("CL_DEVICE_NOT_FOUND");
  case -2: 
  return ("CL_DEVICE_NOT_AVAILABLE");
  case -3: 
  return ("CL_COMPILER_NOT_AVAILABLE");
  case -4: 
  return ("CL_MEM_OBJECT_ALLOCATION_FAILURE");
  case -5: 
  return ("CL_OUT_OF_RESOURCES");
  case -6: 
  return ("CL_OUT_OF_HOST_MEMORY");
  case -7: 
  return ("CL_PROFILING_INFO_NOT_AVAILABLE");
  case -8: 
  return ("CL_MEM_COPY_OVERLAP");
  case -9: 
  return ("CL_IMAGE_FORMAT_MISMATCH");
  case -10: 
  return ("CL_IMAGE_FORMAT_NOT_SUPPORTED");
  case -11: 
  return ("CL_BUILD_PROGRAM_FAILURE");
  case -12: 
  return ("CL_MAP_FAILURE");
  case -13: 
  return ("CL_MISALIGNED_SUB_BUFFER_OFFSET");
  case -14: 
  return ("CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST");
  case -30: 
  return ("CL_INVALID_VALUE");
  case -31: 
  return ("CL_INVALID_DEVICE_TYPE");
  case -32: 
  return ("CL_INVALID_PLATFORM");
  case -33: 
  return ("CL_INVALID_DEVICE");
  case -34: 
  return ("CL_INVALID_CONTEXT");
  case -35: 
  return ("CL_INVALID_QUEUE_PROPERTIES");
  case -36: 
  return ("CL_INVALID_COMMAND_QUEUE");
  case -37: 
  return ("CL_INVALID_HOST_PTR");
  case -38: 
  return ("CL_INVALID_MEM_OBJECT");
  case -39: 
  return ("CL_INVALID_IMAGE_FORMAT_DESCRIPTOR");
  case -40: 
  return ("CL_INVALID_IMAGE_SIZE");
  case -41: 
  return ("CL_INVALID_SAMPLER");
  case -42: 
  return ("CL_INVALID_BINARY");
  case -43: 
  return ("CL_INVALID_BUILD_OPTIONS");
  case -44: 
  return ("CL_INVALID_PROGRAM");
  case -45: 
  return ("CL_INVALID_PROGRAM_EXECUTABLE");
  case -46: 
  return ("CL_INVALID_KERNEL_NAME");
  case -47: 
  return ("CL_INVALID_KERNEL_DEFINITION");
  case -48: 
  return ("CL_INVALID_KERNEL");
  case -49: 
  return ("CL_INVALID_ARG_INDEX");
  case -50: 
  return ("CL_INVALID_ARG_VALUE");
  case -51: 
  return ("CL_INVALID_ARG_SIZE");
  case -52: 
  return ("CL_INVALID_KERNEL_ARGS");
  case -53: 
  return ("CL_INVALID_WORK_DIMENSION");
  case -54: 
  return ("CL_INVALID_WORK_GROUP_SIZE");
  case -55: 
  return ("CL_INVALID_WORK_ITEM_SIZE");
  case -56: 
  return ("CL_INVALID_GLOBAL_OFFSET");
  case -57: 
  return ("CL_INVALID_EVENT_WAIT_LIST");
  case -58: 
  return ("CL_INVALID_EVENT");
  case -59: 
  return ("CL_INVALID_OPERATION");
  case -60: 
  return ("CL_INVALID_GL_OBJECT");
  case -61: 
  return ("CL_INVALID_BUFFER_SIZE");
  case -62: 
  return ("CL_INVALID_MIP_LEVEL");
  case -63: 
  return ("CL_INVALID_GLOBAL_WORK_SIZE");
  case -64: 
  return ("CL_INVALID_PROPERTY");
  default: 
  snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"Unknown code %d",
           ret);
  return ((char const   *)(tmp));
  }
}
}
static char platform_str[1024]  ;
static char const   *vg_ocl_platform_getstr(cl_platform_id pid , cl_platform_info param ) 
{ 
  cl_int ret ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetPlatformInfo(pid, param, sizeof(platform_str), (void *)(platform_str),
                          & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    snprintf((char * __restrict  )(platform_str), sizeof(platform_str), (char const   * __restrict  )"clGetPlatformInfo(%d): %s",
             param, tmp___0);
  }
  return ((char const   *)(platform_str));
}
}
static cl_platform_id vg_ocl_device_getplatform(cl_device_id did ) 
{ 
  cl_int ret ;
  cl_platform_id val ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetDeviceInfo(did, (cl_device_info )4145, sizeof(val), (void *)(& val),
                        & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clGetDeviceInfo(CL_DEVICE_PLATFORM): %s",
            tmp___0);
  }
  return (val);
}
}
static cl_device_type vg_ocl_device_gettype(cl_device_id did ) 
{ 
  cl_int ret ;
  cl_device_type val ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetDeviceInfo(did, (cl_device_info )4096, sizeof(val), (void *)(& val),
                        & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clGetDeviceInfo(CL_DEVICE_TYPE): %s",
            tmp___0);
  }
  return (val);
}
}
static char device_str[1024]  ;
static char const   *vg_ocl_device_getstr(cl_device_id did , cl_device_info param ) 
{ 
  cl_int ret ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetDeviceInfo(did, param, sizeof(device_str), (void *)(device_str), & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    snprintf((char * __restrict  )(device_str), sizeof(device_str), (char const   * __restrict  )"clGetDeviceInfo(%d): %s",
             param, tmp___0);
  }
  return ((char const   *)(device_str));
}
}
static size_t vg_ocl_device_getsizet(cl_device_id did , cl_device_info param ) 
{ 
  cl_int ret ;
  size_t val ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetDeviceInfo(did, param, sizeof(val), (void *)(& val), & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clGetDeviceInfo(%d): %s",
            param, tmp___0);
  }
  return (val);
}
}
static cl_ulong vg_ocl_device_getulong(cl_device_id did , cl_device_info param ) 
{ 
  cl_int ret ;
  cl_ulong val ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetDeviceInfo(did, param, sizeof(val), (void *)(& val), & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clGetDeviceInfo(%d): %s",
            param, tmp___0);
  }
  return (val);
}
}
static cl_uint vg_ocl_device_getuint(cl_device_id did , cl_device_info param ) 
{ 
  cl_int ret ;
  cl_uint val ;
  size_t size_ret ;
  char const   *tmp___0 ;

  {
  ret = clGetDeviceInfo(did, param, sizeof(val), (void *)(& val), & size_ret);
  if (ret != 0) {
    tmp___0 = vg_ocl_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clGetDeviceInfo(%d): %s",
            param, tmp___0);
  }
  return (val);
}
}
void vg_ocl_dump_info(vg_ocl_context_t *vocp ) 
{ 
  cl_device_id did ;
  char const   *tmp___0 ;
  cl_uint tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  cl_ulong tmp___8 ;
  cl_ulong tmp___9 ;

  {
  if (vocp->base.vxc_vc) {
    if ((vocp->base.vxc_vc)->vc_verbose < 1) {
      return;
    }
  }
  if (vocp->voc_dump_done) {
    return;
  }
  did = vocp->voc_ocldid;
  tmp___0 = vg_ocl_device_getstr(did, (cl_device_info )4139);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Device: %s\n",
          tmp___0);
  tmp___1 = vg_ocl_device_getuint(did, (cl_device_info )4097);
  tmp___2 = vg_ocl_device_getstr(did, (cl_device_info )4140);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Vendor: %s (%04x)\n",
          tmp___2, tmp___1);
  tmp___3 = vg_ocl_device_getstr(did, (cl_device_info )4141);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Driver: %s\n",
          tmp___3);
  tmp___4 = vg_ocl_device_getstr(did, (cl_device_info )4142);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Profile: %s\n",
          tmp___4);
  tmp___5 = vg_ocl_device_getstr(did, (cl_device_info )4143);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Version: %s\n",
          tmp___5);
  tmp___6 = vg_ocl_device_getsizet(did, (cl_device_info )4098);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Max compute units: %zd\n",
          tmp___6);
  tmp___7 = vg_ocl_device_getsizet(did, (cl_device_info )4100);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Max workgroup size: %zd\n",
          tmp___7);
  tmp___8 = vg_ocl_device_getulong(did, (cl_device_info )4127);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Global memory: %ld\n",
          tmp___8);
  tmp___9 = vg_ocl_device_getulong(did, (cl_device_info )4112);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Max allocation: %ld\n",
          tmp___9);
  vocp->voc_dump_done = 1;
  return;
}
}
void vg_ocl_error(vg_ocl_context_t *vocp , int code , char const   *desc ) 
{ 
  char const   *err ;
  char const   *tmp___0 ;

  {
  tmp___0 = vg_ocl_strerror(code);
  err = tmp___0;
  if (desc) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s\n",
            desc, err);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", err);
  }
  if (vocp) {
    if (vocp->voc_ocldid) {
      vg_ocl_dump_info(vocp);
    }
  }
  return;
}
}
static void vg_ocl_buildlog(vg_ocl_context_t *vocp , cl_program prog ) 
{ 
  size_t logbufsize ;
  size_t logsize ;
  char *log___0 ;
  int off ;
  cl_int ret ;
  void *tmp___0 ;

  {
  off = 0;
  ret = clGetProgramBuildInfo(prog, vocp->voc_ocldid, (cl_program_build_info )4483,
                              (size_t )0, (void *)0, & logbufsize);
  if (ret != 0) {
    vg_ocl_error((vg_ocl_context_t *)((void *)0), ret, "clGetProgramBuildInfo");
    return;
  }
  tmp___0 = malloc(logbufsize);
  log___0 = (char *)tmp___0;
  if (! log___0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate build log buffer\n");
    return;
  }
  ret = clGetProgramBuildInfo(prog, vocp->voc_ocldid, (cl_program_build_info )4483,
                              logbufsize, (void *)log___0, & logsize);
  if (ret != 0) {
    vg_ocl_error((vg_ocl_context_t *)((void *)0), ret, "clGetProgramBuildInfo");
  } else {
    *(log___0 + (logbufsize - 1UL)) = (char )'\000';
    off = (int )(logsize - 1UL);
    while (off >= 0) {
      if ((int )*(log___0 + off) != 13) {
        if ((int )*(log___0 + off) != 10) {
          if ((int )*(log___0 + off) != 32) {
            if ((int )*(log___0 + off) != 9) {
              if ((int )*(log___0 + off) != 0) {
                break;
              }
            }
          }
        }
      }
      *(log___0 + off) = (char )'\000';
      off --;
    }
    off = 0;
    while ((size_t )off < logbufsize) {
      if ((int )*(log___0 + off) != 13) {
        if ((int )*(log___0 + off) != 10) {
          break;
        }
      }
      off ++;
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Build log:\n%s\n",
            log___0 + off);
  }
  free((void *)log___0);
  return;
}
}
static int vg_ocl_get_quirks(vg_ocl_context_t *vocp ) 
{ 
  uint32_t vend ;
  char const   *dvn ;
  unsigned int quirks ;
  char *tmp___0 ;
  int tmp___1 ;
  cl_device_type tmp___2 ;

  {
  quirks = 0U;
  quirks |= 1U;
  vend = vg_ocl_device_getuint(vocp->voc_ocldid, (cl_device_info )4097);
  switch (vend) {
  case 4318U: 
  quirks &= 4294967294U;
  quirks |= 2U;
  quirks |= 32U;
  break;
  case 4098U: 
  tmp___2 = vg_ocl_device_gettype(vocp->voc_ocldid);
  if (tmp___2 & (unsigned long )(1 << 2)) {
    quirks |= 4U;
    quirks |= 8U;
    dvn = vg_ocl_device_getstr(vocp->voc_ocldid, (cl_device_info )4144);
    if (dvn) {
      tmp___0 = strstr(dvn, "cl_amd_media_ops");
      if (tmp___0) {
        quirks |= 16U;
      }
    }
    dvn = vg_ocl_device_getstr(vocp->voc_ocldid, (cl_device_info )4139);
    tmp___1 = strcmp(dvn, "ATI RV710");
    if (! tmp___1) {
      quirks &= 4294967264U;
      quirks |= 128U;
    }
  }
  break;
  default: 
  break;
  }
  return ((int )quirks);
}
}
static int vg_ocl_create_kernel(vg_ocl_context_t *vocp , int knum , char const   *func ) 
{ 
  int i ;
  cl_kernel krn ;
  cl_int ret ;

  {
  i = 0;
  while (i < 2) {
    krn = clCreateKernel(vocp->voc_oclprog, func, & ret);
    if (! krn) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clCreateKernel(%d): ",
              i);
      vg_ocl_error(vocp, ret, (char const   *)((void *)0));
      while (1) {
        i --;
        if (! (i >= 0)) {
          break;
        }
        clReleaseKernel(vocp->voc_oclkernel[i][knum]);
        vocp->voc_oclkernel[i][knum] = (cl_kernel )((void *)0);
      }
      return (0);
    }
    vocp->voc_oclkernel[i][knum] = krn;
    vocp->voc_oclkrnwait[i] = (cl_event )((void *)0);
    i ++;
  }
  return (1);
}
}
static void vg_ocl_hash_program(vg_ocl_context_t *vocp , char const   *opts , char const   *program ,
                                size_t size , unsigned char *hash_out ) 
{ 
  EVP_MD_CTX *mdctx ;
  cl_platform_id pid ;
  char const   *str ;
  EVP_MD const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  mdctx = EVP_MD_CTX_create();
  tmp___0 = EVP_md5();
  EVP_DigestInit_ex(mdctx, tmp___0, (ENGINE *)((void *)0));
  pid = vg_ocl_device_getplatform(vocp->voc_ocldid);
  str = vg_ocl_platform_getstr(pid, (cl_platform_info )2306);
  tmp___1 = strlen(str);
  EVP_DigestUpdate(mdctx, (void const   *)str, tmp___1 + 1UL);
  str = vg_ocl_platform_getstr(pid, (cl_platform_info )2305);
  tmp___2 = strlen(str);
  EVP_DigestUpdate(mdctx, (void const   *)str, tmp___2 + 1UL);
  str = vg_ocl_device_getstr(vocp->voc_ocldid, (cl_device_info )4139);
  tmp___3 = strlen(str);
  EVP_DigestUpdate(mdctx, (void const   *)str, tmp___3 + 1UL);
  if (opts) {
    tmp___4 = strlen(opts);
    EVP_DigestUpdate(mdctx, (void const   *)opts, tmp___4 + 1UL);
  }
  if (size) {
    EVP_DigestUpdate(mdctx, (void const   *)program, size);
  }
  EVP_DigestFinal_ex(mdctx, hash_out, (unsigned int *)((void *)0));
  EVP_MD_CTX_destroy(mdctx);
  return;
}
}
static int vg_ocl_amd_patch_inner(unsigned char *binary , size_t size ) 
{ 
  vg_elf32_header_t *ehp ;
  vg_elf32_shdr_t *shp ;
  vg_elf32_shdr_t *nshp ;
  uint32_t *instr ;
  size_t off ;
  int i ;
  int n ;
  int txt2idx ;
  int patched ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ehp = (vg_elf32_header_t *)binary;
  if (size < sizeof(*ehp)) {
    return (0);
  } else {
    tmp___0 = memcmp((void const   *)(ehp->e_ident), (void const   *)"\177ELF\001\001\001d",
                     (size_t )8);
    if (tmp___0) {
      return (0);
    } else
    if (! ehp->e_shoff) {
      return (0);
    }
  }
  off = (size_t )(ehp->e_shoff + (uint32_t )((int )ehp->e_shstrndx * (int )ehp->e_shentsize));
  nshp = (vg_elf32_shdr_t *)(binary + off);
  if (off + sizeof(*nshp) > size) {
    return (0);
  }
  shp = (vg_elf32_shdr_t *)(binary + ehp->e_shoff);
  n = 0;
  txt2idx = 0;
  i = 0;
  while (i < (int )ehp->e_shnum) {
    off = (size_t )(nshp->sh_offset + (shp + i)->sh_name);
    if (off + 6UL >= size) {
      goto __Cont;
    } else {
      tmp___1 = memcmp((void const   *)(binary + off), (void const   *)".text", (size_t )6);
      if (tmp___1) {
        goto __Cont;
      }
    }
    n ++;
    if (n == 2) {
      txt2idx = i;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (n != 2) {
    return (0);
  }
  off = (size_t )(shp + txt2idx)->sh_offset;
  instr = (uint32_t *)(binary + off);
  n = (int )((shp + txt2idx)->sh_size / 4U);
  patched = 0;
  i = 0;
  while (i < n) {
    if ((*(instr + i) & 33558528U) == 0U) {
      if ((*(instr + (i + 1)) & 2416177152U) == 106496U) {
        *(instr + (i + 1)) ^= 90112U;
        patched ++;
      }
    }
    i += 2;
  }
  return (patched);
}
}
static int vg_ocl_amd_patch(vg_ocl_context_t *vocp , unsigned char *binary , size_t size ) 
{ 
  vg_context_t *vcp ;
  vg_elf32_header_t *ehp ;
  unsigned char *ptr ;
  size_t offset ;
  int ninner ;
  int nrun ;
  int npatched ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  vcp = vocp->base.vxc_vc;
  offset = (size_t )1;
  ninner = 0;
  npatched = 0;
  ehp = (vg_elf32_header_t *)binary;
  if (size < sizeof(*ehp)) {
    return (0);
  } else {
    tmp___0 = memcmp((void const   *)(ehp->e_ident), (void const   *)"\177ELF\001\001\001\000",
                     (size_t )8);
    if (tmp___0) {
      return (0);
    } else
    if (! ehp->e_shoff) {
      return (0);
    }
  }
  offset = (size_t )1;
  while (offset < size - 8UL) {
    tmp___1 = memchr((void const   *)(binary + offset), 127, size - offset);
    ptr = (unsigned char *)tmp___1;
    if (! ptr) {
      return (npatched);
    }
    offset = (size_t )(ptr - binary);
    ehp = (vg_elf32_header_t *)ptr;
    if (size - offset < sizeof(*ehp)) {
      offset ++;
      continue;
    } else {
      tmp___2 = memcmp((void const   *)(ehp->e_ident), (void const   *)"\177ELF\001\001\001d",
                       (size_t )8);
      if (tmp___2) {
        offset ++;
        continue;
      } else
      if (! ehp->e_shoff) {
        offset ++;
        continue;
      }
    }
    ninner ++;
    nrun = vg_ocl_amd_patch_inner(ptr, size - offset);
    npatched += nrun;
    if (vcp->vc_verbose > 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"AMD BFI_INT: patched %d instructions in kernel %d\n",
              nrun, ninner);
    }
    npatched ++;
    offset ++;
  }
  return (npatched);
}
}
static int vg_ocl_load_program(vg_context_t *vcp , vg_ocl_context_t *vocp , char const   *filename ,
                               char const   *opts ) 
{ 
  FILE *kfp ;
  char *buf ;
  char *tbuf ;
  int len ;
  int fromsource ;
  int patched ;
  size_t sz ;
  size_t szr ;
  cl_program prog ;
  cl_int ret ;
  cl_int sts ;
  unsigned char prog_hash[16] ;
  char bin_name[64] ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  fromsource = 0;
  patched = 0;
  if (vcp->vc_verbose > 1) {
    if (opts) {
      tmp___0 = opts;
    } else {
      tmp___0 = "";
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"OpenCL compiler flags: %s\n",
            tmp___0);
  }
  sz = (size_t )131072;
  tmp___1 = malloc(sz);
  buf = (char *)tmp___1;
  if (! buf) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate program buffer\n");
    return (0);
  }
  kfp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  if (! kfp) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error loading kernel file \'%s\': %s\n",
            filename, tmp___3);
    free((void *)buf);
    return (0);
  }
  tmp___4 = fread((void * __restrict  )buf, (size_t )1, sz, (FILE * __restrict  )kfp);
  len = (int )tmp___4;
  fclose(kfp);
  if (! len) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Short read on CL kernel\n");
    free((void *)buf);
    return (0);
  }
  vg_ocl_hash_program(vocp, opts, (char const   *)buf, (size_t )len, prog_hash);
  snprintf((char * __restrict  )(bin_name), sizeof(bin_name), (char const   * __restrict  )"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x.oclbin",
           (int )prog_hash[0], (int )prog_hash[1], (int )prog_hash[2], (int )prog_hash[3],
           (int )prog_hash[4], (int )prog_hash[5], (int )prog_hash[6], (int )prog_hash[7],
           (int )prog_hash[8], (int )prog_hash[9], (int )prog_hash[10], (int )prog_hash[11],
           (int )prog_hash[12], (int )prog_hash[13], (int )prog_hash[14], (int )prog_hash[15]);
  if (vocp->voc_quirks & 128) {
    kfp = (FILE *)((void *)0);
    if (vcp->vc_verbose > 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Binary OpenCL programs disabled\n");
    }
  } else {
    kfp = fopen((char const   * __restrict  )(bin_name), (char const   * __restrict  )"rb");
  }
  if (! kfp) {
    fromsource = 1;
    sz = (size_t )len;
    prog = clCreateProgramWithSource(vocp->voc_oclctx, (cl_uint )1, (char const   **)(& buf),
                                     (size_t const   *)(& sz), & ret);
  } else {
    if (vcp->vc_verbose > 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Loading kernel binary %s\n",
              bin_name);
    }
    szr = (size_t )0;
    while (1) {
      tmp___7 = feof(kfp);
      if (tmp___7) {
        break;
      }
      tmp___5 = fread((void * __restrict  )(buf + szr), (size_t )1, sz - szr, (FILE * __restrict  )kfp);
      len = (int )tmp___5;
      if (! len) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Short read on CL kernel binary\n");
        fclose(kfp);
        free((void *)buf);
        return (0);
      }
      szr += (size_t )len;
      if (szr == sz) {
        tmp___6 = realloc((void *)buf, sz * 2UL);
        tbuf = (char *)tmp___6;
        if (! tbuf) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not expand CL kernel binary buffer\n");
          fclose(kfp);
          free((void *)buf);
          return (0);
        }
        buf = tbuf;
        sz *= 2UL;
      }
    }
    fclose(kfp);
    rebuild: 
    prog = clCreateProgramWithBinary(vocp->voc_oclctx, (cl_uint )1, (cl_device_id const   *)(& vocp->voc_ocldid),
                                     (size_t const   *)(& szr), (unsigned char const   **)(& buf),
                                     & sts, & ret);
  }
  free((void *)buf);
  if (! prog) {
    vg_ocl_error(vocp, ret, "clCreateProgramWithSource");
    return (0);
  }
  if (vcp->vc_verbose > 0) {
    if (fromsource) {
      if (! patched) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Compiling kernel, can take minutes...");
        fflush(stderr);
      }
    }
  }
  ret = clBuildProgram(prog, (cl_uint )1, (cl_device_id const   *)(& vocp->voc_ocldid),
                       opts, (void (*)(cl_program program , void *user_data ))((void *)0),
                       (void *)0);
  if (ret != 0) {
    if (vcp->vc_verbose > 0) {
      if (fromsource) {
        if (! patched) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failure.\n");
        }
      }
    }
    vg_ocl_error((vg_ocl_context_t *)((void *)0), ret, "clBuildProgram");
  } else
  if (vcp->vc_verbose > 0) {
    if (fromsource) {
      if (! patched) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"done!\n");
      }
    }
  }
  if (ret != 0) {
    vg_ocl_buildlog(vocp, prog);
  } else
  if (vcp->vc_verbose > 1) {
    if (fromsource) {
      if (! patched) {
        vg_ocl_buildlog(vocp, prog);
      }
    }
  }
  if (ret != 0) {
    vg_ocl_dump_info(vocp);
    clReleaseProgram(prog);
    return (0);
  }
  if (fromsource) {
    if (! (vocp->voc_quirks & 128)) {
      ret = clGetProgramInfo(prog, (cl_program_info )4453, sizeof(szr), (void *)(& szr),
                             & sz);
      if (ret != 0) {
        vg_ocl_error(vocp, ret, "WARNING: clGetProgramInfo(BINARY_SIZES)");
        goto out;
      }
      if (sz == 0UL) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: zero-length CL kernel binary\n");
        goto out;
      }
      tmp___8 = malloc(szr);
      buf = (char *)tmp___8;
      if (! buf) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Could not allocate %zd bytes for CL binary\n",
                szr);
        goto out;
      }
      ret = clGetProgramInfo(prog, (cl_program_info )4454, sizeof(buf), (void *)(& buf),
                             & sz);
      if (ret != 0) {
        vg_ocl_error(vocp, ret, "WARNING: clGetProgramInfo(BINARIES)");
        free((void *)buf);
        goto out;
      }
      if (vocp->voc_quirks & 16) {
        if (! patched) {
          patched = vg_ocl_amd_patch(vocp, (unsigned char *)buf, szr);
          if (patched > 0) {
            if (vcp->vc_verbose > 1) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"AMD BFI_INT patch complete\n");
            }
            clReleaseProgram(prog);
            goto rebuild;
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: AMD BFI_INT patching failed\n");
          if (patched < 0) {
            free((void *)buf);
            goto out;
          }
        }
      }
      kfp = fopen((char const   * __restrict  )(bin_name), (char const   * __restrict  )"wb");
      if (! kfp) {
        tmp___9 = __errno_location();
        tmp___10 = strerror(*tmp___9);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: could not save CL kernel binary: %s\n",
                tmp___10);
      } else {
        sz = fwrite((void const   * __restrict  )buf, (size_t )1, szr, (FILE * __restrict  )kfp);
        fclose(kfp);
        if (sz != szr) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: short write on CL kernel binary file: expected %zd, got %zd\n",
                  szr, sz);
          unlink((char const   *)(bin_name));
        }
      }
      free((void *)buf);
    }
  }
  out: 
  vocp->voc_oclprog = prog;
  tmp___11 = vg_ocl_create_kernel(vocp, 0, "ec_add_grid");
  if (tmp___11) {
    tmp___12 = vg_ocl_create_kernel(vocp, 1, "heap_invert");
    if (! tmp___12) {
      clReleaseProgram(vocp->voc_oclprog);
      vocp->voc_oclprog = (cl_program )((void *)0);
      return (0);
    }
  } else {
    clReleaseProgram(vocp->voc_oclprog);
    vocp->voc_oclprog = (cl_program )((void *)0);
    return (0);
  }
  return (1);
}
}
static void vg_ocl_context_callback(char const   *errinfo , void const   *private_info ,
                                    size_t cb , void *user_data ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"vg_ocl_context_callback error: %s\n",
          errinfo);
  return;
}
}
static int vg_ocl_init(vg_context_t *vcp , vg_ocl_context_t *vocp , cl_device_id did ,
                       int safe_mode ) 
{ 
  cl_int ret ;
  char optbuf[128] ;
  int end ;
  char yesbuf[16] ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  end = 0;
  memset((void *)vocp, 0, sizeof(*vocp));
  vg_exec_context_init(vcp, & vocp->base);
  vocp->base.vxc_threadfunc = & vg_opencl_loop;
  pthread_mutex_init(& vocp->voc_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& vocp->voc_wait), (pthread_condattr_t const   * __restrict  )((void *)0));
  vocp->voc_ocl_slot = -1;
  vocp->voc_ocldid = did;
  if (vcp->vc_verbose > 1) {
    vg_ocl_dump_info(vocp);
  }
  vocp->voc_quirks = vg_ocl_get_quirks(vocp);
  if (vocp->voc_quirks & 64) {
    if (vcp->vc_verbose > 0) {
      printf((char const   * __restrict  )"Type \'yes\' to continue: ");
      fflush(stdout);
      tmp___0 = fgets((char * __restrict  )(yesbuf), (int )sizeof(yesbuf), (FILE * __restrict  )stdin);
      if (tmp___0) {
        tmp___1 = strncmp((char const   *)(yesbuf), "yes", (size_t )3);
        if (tmp___1) {
          exit(1);
        }
      } else {
        exit(1);
      }
    }
  }
  vocp->voc_oclctx = clCreateContext((cl_context_properties const   *)((void *)0),
                                     (cl_uint )1, (cl_device_id const   *)(& did),
                                     & vg_ocl_context_callback, (void *)0, & ret);
  if (! vocp->voc_oclctx) {
    vg_ocl_error(vocp, ret, "clCreateContext");
    return (0);
  }
  vocp->voc_oclcmdq = clCreateCommandQueue(vocp->voc_oclctx, vocp->voc_ocldid, (cl_command_queue_properties )0,
                                           & ret);
  if (! vocp->voc_oclcmdq) {
    vg_ocl_error(vocp, ret, "clCreateCommandQueue");
    return (0);
  }
  if (safe_mode) {
    vocp->voc_quirks &= -32;
  }
  end = 0;
  optbuf[end] = (char )'\000';
  if (vocp->voc_quirks & 1) {
    tmp___2 = snprintf((char * __restrict  )(optbuf + end), sizeof(optbuf) - (unsigned long )end,
                       (char const   * __restrict  )"-DDEEP_PREPROC_UNROLL ");
    end += tmp___2;
  }
  if (vocp->voc_quirks & 2) {
    tmp___3 = snprintf((char * __restrict  )(optbuf + end), sizeof(optbuf) - (unsigned long )end,
                       (char const   * __restrict  )"-DPRAGMA_UNROLL ");
    end += tmp___3;
  }
  if (vocp->voc_quirks & 4) {
    tmp___4 = snprintf((char * __restrict  )(optbuf + end), sizeof(optbuf) - (unsigned long )end,
                       (char const   * __restrict  )"-DVERY_EXPENSIVE_BRANCHES ");
    end += tmp___4;
  }
  if (vocp->voc_quirks & 8) {
    tmp___5 = snprintf((char * __restrict  )(optbuf + end), sizeof(optbuf) - (unsigned long )end,
                       (char const   * __restrict  )"-DDEEP_VLIW ");
    end += tmp___5;
  }
  if (vocp->voc_quirks & 16) {
    tmp___6 = snprintf((char * __restrict  )(optbuf + end), sizeof(optbuf) - (unsigned long )end,
                       (char const   * __restrict  )"-DAMD_BFI_INT ");
    end += tmp___6;
  }
  if (vocp->voc_quirks & 32) {
    tmp___7 = snprintf((char * __restrict  )(optbuf + end), sizeof(optbuf) - (unsigned long )end,
                       (char const   * __restrict  )"-cl-nv-verbose ");
    end += tmp___7;
  }
  tmp___8 = vg_ocl_load_program(vcp, vocp, "calc_addrs.cl", (char const   *)(optbuf));
  if (! tmp___8) {
    return (0);
  }
  return (1);
}
}
static void vg_ocl_del(vg_ocl_context_t *vocp ) 
{ 


  {
  vg_ocl_free_args(vocp);
  if (vocp->voc_oclprog) {
    clReleaseProgram(vocp->voc_oclprog);
    vocp->voc_oclprog = (cl_program )((void *)0);
  }
  if (vocp->voc_oclcmdq) {
    clReleaseCommandQueue(vocp->voc_oclcmdq);
    vocp->voc_oclcmdq = (cl_command_queue )((void *)0);
  }
  if (vocp->voc_oclctx) {
    clReleaseContext(vocp->voc_oclctx);
    vocp->voc_oclctx = (cl_context )((void *)0);
  }
  pthread_cond_destroy(& vocp->voc_wait);
  pthread_mutex_destroy(& vocp->voc_lock);
  vg_exec_context_del(& vocp->base);
  return;
}
}
static int vg_ocl_arg_map[6][8]  = { {        2,        0,        -1}, 
   {        0,        1,        1,        0, 
            2,        2,        -1}, 
   {        0,        0,        2,        1, 
            -1}, 
   {        0,        2,        -1}, 
   {        0,        3,        -1}, 
   {        2,        3,        -1}};
static int vg_ocl_kernel_arg_alloc(vg_ocl_context_t *vocp , int slot , int arg , size_t size ,
                                   int host ) 
{ 
  cl_mem clbuf ;
  cl_int ret ;
  int i ;
  int j ;
  int knum ;
  int karg ;
  int tmp___0 ;

  {
  i = 0;
  while (i < 2) {
    if (i != slot) {
      if (slot >= 0) {
        goto __Cont;
      }
    }
    if (vocp->voc_args[i][arg]) {
      clReleaseMemObject(vocp->voc_args[i][arg]);
      vocp->voc_args[i][arg] = (cl_mem )((void *)0);
      vocp->voc_arg_size[i][arg] = (size_t )0;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (host) {
    tmp___0 = 1 << 4;
  } else {
    tmp___0 = 0;
  }
  clbuf = clCreateBuffer(vocp->voc_oclctx, (cl_mem_flags )(1 | tmp___0), size, (void *)0,
                         & ret);
  if (! clbuf) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clCreateBuffer(%d,%d): ",
            slot, arg);
    vg_ocl_error(vocp, ret, (char const   *)((void *)0));
    return (0);
  }
  i = 0;
  while (i < 2) {
    if (i != slot) {
      if (slot >= 0) {
        goto __Cont___0;
      }
    }
    clRetainMemObject(clbuf);
    vocp->voc_args[i][arg] = clbuf;
    vocp->voc_arg_size[i][arg] = size;
    j = 0;
    while (vg_ocl_arg_map[arg][j] >= 0) {
      knum = vg_ocl_arg_map[arg][j];
      karg = vg_ocl_arg_map[arg][j + 1];
      ret = clSetKernelArg(vocp->voc_oclkernel[i][knum], (cl_uint )karg, sizeof(clbuf),
                           (void const   *)(& clbuf));
      if (ret) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clSetKernelArg(%d,%d): ",
                knum, karg);
        vg_ocl_error(vocp, ret, (char const   *)((void *)0));
        return (0);
      }
      j += 2;
    }
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  clReleaseMemObject(clbuf);
  return (1);
}
}
int vg_ocl_copyout_arg(vg_ocl_context_t *vocp , int wslot , int arg , void *buffer ,
                       size_t size ) 
{ 
  cl_int slot ;
  cl_int ret ;

  {
  if (wslot < 0) {
    slot = 0;
  } else {
    slot = wslot;
  }
  if (slot >= 0) {
    if (! (slot < 2)) {
      __assert_fail("(slot >= 0) && (slot < MAX_SLOT)", "oclengine.c", 1048U, "vg_ocl_copyout_arg");
    }
  } else {
    __assert_fail("(slot >= 0) && (slot < MAX_SLOT)", "oclengine.c", 1048U, "vg_ocl_copyout_arg");
  }
  if (! (size <= vocp->voc_arg_size[slot][arg])) {
    __assert_fail("size <= vocp->voc_arg_size[slot][arg]", "oclengine.c", 1049U, "vg_ocl_copyout_arg");
  }
  ret = clEnqueueWriteBuffer(vocp->voc_oclcmdq, vocp->voc_args[slot][arg], (cl_bool )1,
                             (size_t )0, size, (void const   *)buffer, (cl_uint )0,
                             (cl_event const   *)((void *)0), (cl_event *)((void *)0));
  if (ret) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clEnqueueWriteBuffer(%d): ",
            arg);
    vg_ocl_error(vocp, ret, (char const   *)((void *)0));
    return (0);
  }
  return (1);
}
}
static void *vg_ocl_map_arg_buffer(vg_ocl_context_t *vocp , int slot , int arg , int rw ) 
{ 
  void *buf ;
  cl_int ret ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (slot >= 0) {
    if (! (slot < 2)) {
      __assert_fail("(slot >= 0) && (slot < MAX_SLOT)", "oclengine.c", 1075U, "vg_ocl_map_arg_buffer");
    }
  } else {
    __assert_fail("(slot >= 0) && (slot < MAX_SLOT)", "oclengine.c", 1075U, "vg_ocl_map_arg_buffer");
  }
  if (rw == 2) {
    tmp___2 = 1 | (1 << 1);
  } else {
    if (rw) {
      tmp___1 = 1 << 1;
    } else {
      tmp___1 = 1;
    }
    tmp___2 = tmp___1;
  }
  buf = clEnqueueMapBuffer(vocp->voc_oclcmdq, vocp->voc_args[slot][arg], (cl_bool )1,
                           (cl_map_flags )tmp___2, (size_t )0, vocp->voc_arg_size[slot][arg],
                           (cl_uint )0, (cl_event const   *)((void *)0), (cl_event *)((void *)0),
                           & ret);
  if (! buf) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clEnqueueMapBuffer(%d): ",
            arg);
    vg_ocl_error(vocp, ret, (char const   *)((void *)0));
    return ((void *)0);
  }
  return (buf);
}
}
static void vg_ocl_unmap_arg_buffer(vg_ocl_context_t *vocp , int slot , int arg ,
                                    void *buf ) 
{ 
  cl_int ret ;
  cl_event ev ;

  {
  if (slot >= 0) {
    if (! (slot < 2)) {
      __assert_fail("(slot >= 0) && (slot < MAX_SLOT)", "oclengine.c", 1101U, "vg_ocl_unmap_arg_buffer");
    }
  } else {
    __assert_fail("(slot >= 0) && (slot < MAX_SLOT)", "oclengine.c", 1101U, "vg_ocl_unmap_arg_buffer");
  }
  ret = clEnqueueUnmapMemObject(vocp->voc_oclcmdq, vocp->voc_args[slot][arg], buf,
                                (cl_uint )0, (cl_event const   *)((void *)0), & ev);
  if (ret != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clEnqueueUnmapMemObject(%d): ",
            arg);
    vg_ocl_error(vocp, ret, (char const   *)((void *)0));
    return;
  }
  ret = clWaitForEvents((cl_uint )1, (cl_event const   *)(& ev));
  clReleaseEvent(ev);
  if (ret != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clWaitForEvent(clUnmapMemObject,%d): ",
            arg);
    vg_ocl_error(vocp, ret, (char const   *)((void *)0));
  }
  return;
}
}
int vg_ocl_kernel_int_arg(vg_ocl_context_t *vocp , int slot , int arg , int value ) 
{ 
  cl_int ret ;
  int i ;

  {
  i = 0;
  while (i < 2) {
    if (i != slot) {
      if (slot >= 0) {
        goto __Cont;
      }
    }
    ret = clSetKernelArg(vocp->voc_oclkernel[i][2], (cl_uint )arg, sizeof(value),
                         (void const   *)(& value));
    if (ret) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clSetKernelArg(%d): ",
              arg);
      vg_ocl_error(vocp, ret, (char const   *)((void *)0));
      return (0);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (1);
}
}
int vg_ocl_kernel_buffer_arg(vg_ocl_context_t *vocp , int slot , int arg , void *value ,
                             size_t size ) 
{ 
  cl_int ret ;
  int i ;
  int j ;
  int knum ;
  int karg ;

  {
  i = 0;
  while (i < 2) {
    if (i != slot) {
      if (slot >= 0) {
        goto __Cont;
      }
    }
    j = 0;
    while (vg_ocl_arg_map[arg][j] >= 0) {
      knum = vg_ocl_arg_map[arg][j];
      karg = vg_ocl_arg_map[arg][j + 1];
      ret = clSetKernelArg(vocp->voc_oclkernel[i][knum], (cl_uint )karg, size, (void const   *)value);
      if (ret) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"clSetKernelArg(%d,%d): ",
                knum, karg);
        vg_ocl_error(vocp, ret, (char const   *)((void *)0));
        return (0);
      }
      j += 2;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (1);
}
}
static void vg_ocl_free_args(vg_ocl_context_t *vocp ) 
{ 
  int i ;
  int arg ;

  {
  i = 0;
  while (i < 2) {
    arg = 0;
    while (arg < 6) {
      if (vocp->voc_args[i][arg]) {
        clReleaseMemObject(vocp->voc_args[i][arg]);
        vocp->voc_args[i][arg] = (cl_mem )((void *)0);
        vocp->voc_arg_size[i][arg] = (size_t )0;
      }
      arg ++;
    }
    i ++;
  }
  return;
}
}
int vg_ocl_kernel_dead(vg_ocl_context_t *vocp , int slot ) 
{ 


  {
  return ((unsigned long )vocp->voc_oclkrnwait[slot] == (unsigned long )((void *)0));
}
}
static int vg_ocl_kernel_start(vg_ocl_context_t *vocp , int slot , int ncol , int nrow ,
                               int invsize ) 
{ 
  cl_int val ;
  cl_int ret ;
  cl_event ev ;
  size_t globalws[2] ;
  size_t invws ;
  int tmp___2 ;
  int tmp___3 ;

  {
  globalws[0] = (size_t )ncol;
  globalws[1] = (size_t )nrow;
  invws = (size_t )((ncol * nrow) / invsize);
  if (! (! vocp->voc_oclkrnwait[slot])) {
    __assert_fail("!vocp->voc_oclkrnwait[slot]", "oclengine.c", 1203U, "vg_ocl_kernel_start");
  }
  if (! (invsize & (invsize - 1))) {
    if (! (invsize > 1)) {
      __assert_fail("is_pow2(invsize) && (invsize > 1)", "oclengine.c", 1206U, "vg_ocl_kernel_start");
    }
  } else {
    __assert_fail("is_pow2(invsize) && (invsize > 1)", "oclengine.c", 1206U, "vg_ocl_kernel_start");
  }
  val = invsize;
  ret = clSetKernelArg(vocp->voc_oclkernel[slot][1], (cl_uint )1, sizeof(val), (void const   *)(& val));
  if (ret != 0) {
    vg_ocl_error(vocp, ret, "clSetKernelArg(ncol)");
    return (0);
  }
  ret = clEnqueueNDRangeKernel(vocp->voc_oclcmdq, vocp->voc_oclkernel[slot][0], (cl_uint )2,
                               (size_t const   *)((void *)0), (size_t const   *)(globalws),
                               (size_t const   *)((void *)0), (cl_uint )0, (cl_event const   *)((void *)0),
                               & ev);
  if (ret != 0) {
    vg_ocl_error(vocp, ret, "clEnqueueNDRange(0)");
    return (0);
  }
  ret = clWaitForEvents((cl_uint )1, (cl_event const   *)(& ev));
  clReleaseEvent(ev);
  if (ret != 0) {
    vg_ocl_error(vocp, ret, "clWaitForEvents(NDRange,0)");
    return (0);
  }
  if (vocp->voc_verify_func[0]) {
    tmp___2 = (*(vocp->voc_verify_func[0]))(vocp, slot);
    if (! tmp___2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Kernel 0 failed verification test\n");
      return (0);
    }
  }
  ret = clEnqueueNDRangeKernel(vocp->voc_oclcmdq, vocp->voc_oclkernel[slot][1], (cl_uint )1,
                               (size_t const   *)((void *)0), (size_t const   *)(& invws),
                               (size_t const   *)((void *)0), (cl_uint )0, (cl_event const   *)((void *)0),
                               & ev);
  if (ret != 0) {
    vg_ocl_error(vocp, ret, "clEnqueueNDRange(1)");
    return (0);
  }
  ret = clWaitForEvents((cl_uint )1, (cl_event const   *)(& ev));
  clReleaseEvent(ev);
  if (ret != 0) {
    vg_ocl_error(vocp, ret, "clWaitForEvents(NDRange,1)");
    return (0);
  }
  if (vocp->voc_verify_func[1]) {
    tmp___3 = (*(vocp->voc_verify_func[1]))(vocp, slot);
    if (! tmp___3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Kernel 1 failed verification test\n");
      return (0);
    }
  }
  ret = clEnqueueNDRangeKernel(vocp->voc_oclcmdq, vocp->voc_oclkernel[slot][2], (cl_uint )2,
                               (size_t const   *)((void *)0), (size_t const   *)(globalws),
                               (size_t const   *)((void *)0), (cl_uint )0, (cl_event const   *)((void *)0),
                               & ev);
  if (ret != 0) {
    vg_ocl_error(vocp, ret, "clEnqueueNDRange(2)");
    return (0);
  }
  vocp->voc_oclkrnwait[slot] = ev;
  return (1);
}
}
static int vg_ocl_kernel_wait(vg_ocl_context_t *vocp , int slot ) 
{ 
  cl_event ev ;
  cl_int ret ;

  {
  ev = vocp->voc_oclkrnwait[slot];
  vocp->voc_oclkrnwait[slot] = (cl_event )((void *)0);
  if (ev) {
    ret = clWaitForEvents((cl_uint )1, (cl_event const   *)(& ev));
    clReleaseEvent(ev);
    if (ret != 0) {
      vg_ocl_error(vocp, ret, "clWaitForEvents(NDRange,e)");
      return (0);
    }
  }
  return (1);
}
}
__inline static void vg_ocl_get_bignum_raw(BIGNUM *bn , unsigned char const   *buf ) 
{ 


  {
  if (! (4 <= bn->dmax)) {
    bn_expand2(bn, 4);
  }
  memcpy((void * __restrict  )bn->d, (void const   * __restrict  )buf, (size_t )32);
  bn->top = (int )(32UL / sizeof(unsigned long ));
  return;
}
}
__inline static void vg_ocl_put_bignum_raw(unsigned char *buf , BIGNUM const   *bn ) 
{ 
  int bnlen ;

  {
  bnlen = (int )((unsigned long )bn->top * sizeof(unsigned long ));
  if (bnlen >= 32) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )bn->d, (size_t )32);
  } else {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )bn->d, (size_t )bnlen);
    memset((void *)(buf + bnlen), 0, (size_t )(32 - bnlen));
  }
  return;
}
}
static void vg_ocl_get_bignum_tpa(BIGNUM *bn , unsigned char const   *buf , int cell ) 
{ 
  unsigned char bnbuf[32] ;
  int start ;
  int i ;

  {
  start = (cell / 128) * 1024 + cell % 128;
  i = 0;
  while (i < 8) {
    memcpy((void * __restrict  )(bnbuf + i * 4), (void const   * __restrict  )(buf + 4 * (start + i * 128)),
           (size_t )4);
    i ++;
  }
  vg_ocl_get_bignum_raw(bn, (unsigned char const   *)(bnbuf));
  return;
}
}
__inline static void vg_ocl_get_point(EC_POINT *ppnt , unsigned char const   *buf ) ;
static unsigned char const   mont_one[5]  = {      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )209};
__inline static void vg_ocl_get_point(EC_POINT *ppnt , unsigned char const   *buf ) 
{ 


  {
  vg_ocl_get_bignum_raw(& ppnt->X, buf);
  vg_ocl_get_bignum_raw(& ppnt->Y, buf + 32);
  if (! ppnt->Z_is_one) {
    ppnt->Z_is_one = 1;
    BN_bin2bn(mont_one, (int )sizeof(mont_one), & ppnt->Z);
  }
  return;
}
}
__inline static void vg_ocl_put_point(unsigned char *buf , EC_POINT const   *ppnt ) 
{ 


  {
  if (! ppnt->Z_is_one) {
    __assert_fail("ppnt->Z_is_one", "oclengine.c", 1368U, "vg_ocl_put_point");
  }
  vg_ocl_put_bignum_raw(buf, & ppnt->X);
  vg_ocl_put_bignum_raw(buf + 32, & ppnt->Y);
  return;
}
}
static void vg_ocl_put_point_tpa(unsigned char *buf , int cell , EC_POINT const   *ppnt ) 
{ 
  unsigned char pntbuf[64] ;
  int start ;
  int i ;

  {
  vg_ocl_put_point(pntbuf, ppnt);
  start = ((2 * cell) / 128) * 1024 + cell % 64;
  i = 0;
  while (i < 8) {
    memcpy((void * __restrict  )(buf + 4 * (start + i * 128)), (void const   * __restrict  )(pntbuf + i * 4),
           (size_t )4);
    i ++;
  }
  i = 0;
  while (i < 8) {
    memcpy((void * __restrict  )(buf + 4 * ((start + 64) + i * 128)), (void const   * __restrict  )((pntbuf + 32) + i * 4),
           (size_t )4);
    i ++;
  }
  return;
}
}
static void vg_ocl_get_point_tpa(EC_POINT *ppnt , unsigned char const   *buf , int cell ) 
{ 
  unsigned char pntbuf[64] ;
  int start ;
  int i ;

  {
  start = ((2 * cell) / 128) * 1024 + cell % 64;
  i = 0;
  while (i < 8) {
    memcpy((void * __restrict  )(pntbuf + i * 4), (void const   * __restrict  )(buf + 4 * (start + i * 128)),
           (size_t )4);
    i ++;
  }
  i = 0;
  while (i < 8) {
    memcpy((void * __restrict  )((pntbuf + 32) + i * 4), (void const   * __restrict  )(buf + 4 * ((start + 64) + i * 128)),
           (size_t )4);
    i ++;
  }
  vg_ocl_get_point(ppnt, (unsigned char const   *)(pntbuf));
  return;
}
}
void show_elapsed(struct timeval *tv , char const   *place ) 
{ 
  struct timeval now ;
  struct timeval delta ;

  {
  gettimeofday((struct timeval * __restrict  )(& now), (void * __restrict  )((void *)0));
  while (1) {
    delta.tv_sec = now.tv_sec - tv->tv_sec;
    delta.tv_usec = now.tv_usec - tv->tv_usec;
    if (delta.tv_usec < 0L) {
      (delta.tv_sec) --;
      delta.tv_usec += 1000000L;
    }
    break;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s spent %ld.%06lds\n",
          place, delta.tv_sec, delta.tv_usec);
  return;
}
}
static int vg_ocl_gethash_check(vg_ocl_context_t *vocp , int slot ) 
{ 
  vg_exec_context_t *vxcp ;
  vg_context_t *vcp ;
  int (*test_func)(vg_exec_context_t * ) ;
  unsigned char *ocl_hashes_out ;
  int i ;
  int res ;
  int round___0 ;
  void *tmp___0 ;

  {
  vxcp = & vocp->base;
  vcp = vocp->base.vxc_vc;
  test_func = vcp->vc_test;
  res = 0;
  tmp___0 = vg_ocl_map_arg_buffer(vocp, slot, 0, 0);
  ocl_hashes_out = (unsigned char *)tmp___0;
  if (! ocl_hashes_out) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Could not map hash result buffer for slot %d\n",
            slot);
    return (2);
  }
  round___0 = vocp->voc_ocl_cols * vocp->voc_ocl_rows;
  i = 0;
  while (i < round___0) {
    memcpy((void * __restrict  )(& vxcp->vxc_binres[1]), (void const   * __restrict  )(ocl_hashes_out + 20 * i),
           (size_t )20);
    res = (*test_func)(vxcp);
    if (res) {
      break;
    }
    i ++;
    (vxcp->vxc_delta) ++;
  }
  vg_ocl_unmap_arg_buffer(vocp, slot, 0, (void *)ocl_hashes_out);
  return (res);
}
}
static int vg_ocl_gethash_init(vg_ocl_context_t *vocp ) 
{ 
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = vg_ocl_create_kernel(vocp, 2, "hash_ec_point_get");
  if (! tmp___0) {
    return (0);
  }
  i = 0;
  while (i < vocp->voc_nslots) {
    tmp___1 = vg_ocl_kernel_arg_alloc(vocp, i, 0, (size_t )((20 * vocp->voc_ocl_rows) * vocp->voc_ocl_cols),
                                      1);
    if (! tmp___1) {
      return (0);
    }
    i ++;
  }
  vocp->voc_rekey_func = (int (*)(struct _vg_ocl_context_s * ))((void *)0);
  vocp->voc_check_func = & vg_ocl_gethash_check;
  return (1);
}
}
static int vg_ocl_prefix_rekey(vg_ocl_context_t *vocp ) 
{ 
  vg_context_t *vcp ;
  unsigned char *ocl_targets_in ;
  uint32_t *ocl_found_out ;
  int i ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  vcp = vocp->base.vxc_vc;
  i = 0;
  while (i < vocp->voc_nslots) {
    tmp___0 = vg_ocl_map_arg_buffer(vocp, i, 0, 1);
    ocl_found_out = (uint32_t *)tmp___0;
    if (! ocl_found_out) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Could not map result buffer for slot %d (rekey)\n",
              i);
      return (-1);
    }
    *(ocl_found_out + 0) = 4294967295U;
    vg_ocl_unmap_arg_buffer(vocp, i, 0, (void *)ocl_found_out);
    i ++;
  }
  if (vocp->voc_pattern_rewrite) {
    i = vg_context_hash160_sort(vcp, (void *)0);
    if (! i) {
      return (0);
    }
    if (i > vocp->voc_pattern_alloc) {
      tmp___1 = vg_ocl_kernel_arg_alloc(vocp, -1, 5, (size_t )(40 * i), 0);
      if (! tmp___1) {
        return (-1);
      }
      vocp->voc_pattern_alloc = i;
    }
    tmp___2 = vg_ocl_map_arg_buffer(vocp, 0, 5, 1);
    ocl_targets_in = (unsigned char *)tmp___2;
    if (! ocl_targets_in) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Could not map hash target buffer\n");
      return (-1);
    }
    vg_context_hash160_sort(vcp, (void *)ocl_targets_in);
    vg_ocl_unmap_arg_buffer(vocp, 0, 5, (void *)ocl_targets_in);
    vg_ocl_kernel_int_arg(vocp, -1, 4, i);
    vocp->voc_pattern_rewrite = 0;
  }
  return (1);
}
}
static int vg_ocl_prefix_check(vg_ocl_context_t *vocp , int slot ) 
{ 
  vg_exec_context_t *vxcp ;
  vg_context_t *vcp ;
  int (*test_func)(vg_exec_context_t * ) ;
  uint32_t *ocl_found_out ;
  uint32_t found_delta ;
  int orig_delta ;
  int tablesize ;
  int res ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  vxcp = & vocp->base;
  vcp = vocp->base.vxc_vc;
  test_func = vcp->vc_test;
  res = 0;
  tmp___0 = vg_ocl_map_arg_buffer(vocp, slot, 0, 2);
  ocl_found_out = (uint32_t *)tmp___0;
  if (! ocl_found_out) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Could not map result buffer for slot %d\n",
            slot);
    return (2);
  }
  found_delta = *(ocl_found_out + 0);
  if (found_delta != 4294967295U) {
    orig_delta = vxcp->vxc_delta;
    vxcp->vxc_delta = (int )((uint32_t )vxcp->vxc_delta + found_delta);
    vg_exec_context_calc_address(vxcp);
    res = 0;
    tmp___1 = memcmp((void const   *)(vxcp->vxc_binres + 1), (void const   *)(ocl_found_out + 2),
                     (size_t )20);
    if (! tmp___1) {
      res = (*test_func)(vxcp);
    }
    if (res == 0) {
      tablesize = (int )*(ocl_found_out + 2);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Match idx: %d\n",
              *(ocl_found_out + 1));
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CPU hash: ");
      fdumphex(stderr, (unsigned char const   *)(vxcp->vxc_binres + 1), (size_t )20);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"GPU hash: ");
      fdumphex(stderr, (unsigned char const   *)((unsigned char *)(ocl_found_out + 2)),
               (size_t )20);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Found delta: %d Start delta: %d\n",
              found_delta, orig_delta);
      res = 1;
    }
  } else {
    vxcp->vxc_delta += vocp->voc_ocl_cols * vocp->voc_ocl_rows;
  }
  vg_ocl_unmap_arg_buffer(vocp, slot, 0, (void *)ocl_found_out);
  return (res);
}
}
static int vg_ocl_prefix_init(vg_ocl_context_t *vocp ) 
{ 
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = vg_ocl_create_kernel(vocp, 2, "hash_ec_point_search_prefix");
  if (! tmp___0) {
    return (0);
  }
  i = 0;
  while (i < vocp->voc_nslots) {
    tmp___1 = vg_ocl_kernel_arg_alloc(vocp, i, 0, (size_t )28, 1);
    if (! tmp___1) {
      return (0);
    }
    i ++;
  }
  vocp->voc_rekey_func = & vg_ocl_prefix_rekey;
  vocp->voc_check_func = & vg_ocl_prefix_check;
  vocp->voc_pattern_rewrite = 1;
  vocp->voc_pattern_alloc = 0;
  return (1);
}
}
static int vg_ocl_config_pattern(vg_ocl_context_t *vocp ) 
{ 
  vg_context_t *vcp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  vcp = vocp->base.vxc_vc;
  i = vg_context_hash160_sort(vcp, (void *)0);
  if (i > 0) {
    if (vcp->vc_verbose > 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Using OpenCL prefix matcher\n");
    }
    tmp___0 = vg_ocl_prefix_init(vocp);
    return (tmp___0);
  }
  if (vcp->vc_verbose > 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Using CPU pattern matcher\n");
  }
  tmp___1 = vg_ocl_gethash_init(vocp);
  return (tmp___1);
}
}
static int vg_ocl_verify_temporary(vg_ocl_context_t *vocp , int slot , int z_inverted ) ;
static unsigned char const   raw_modulus[32]  = 
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )252,      (unsigned char const   )47};
static int vg_ocl_verify_temporary(vg_ocl_context_t *vocp , int slot , int z_inverted ) 
{ 
  vg_exec_context_t *vxcp ;
  unsigned char *point_tmp ;
  unsigned char *z_heap ;
  unsigned char *ocl_points_in ;
  unsigned char *ocl_strides_in ;
  EC_GROUP const   *pgroup ;
  EC_POINT *ppr ;
  EC_POINT *ppc ;
  EC_POINT *pps ;
  EC_POINT *ppt ;
  BIGNUM bnz ;
  BIGNUM bnez ;
  BIGNUM bnm ;
  BIGNUM *bnzc ;
  BN_CTX *bnctx ;
  BN_MONT_CTX *bnmont ;
  int ret ;
  int mismatches ;
  int mm_r ;
  int x ;
  int y ;
  int bx ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  BIGNUM const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  vxcp = & vocp->base;
  point_tmp = (unsigned char *)((void *)0);
  z_heap = (unsigned char *)((void *)0);
  ocl_points_in = (unsigned char *)((void *)0);
  ocl_strides_in = (unsigned char *)((void *)0);
  ppr = (EC_POINT *)((void *)0);
  ppc = (EC_POINT *)((void *)0);
  pps = (EC_POINT *)((void *)0);
  ppt = (EC_POINT *)((void *)0);
  bnctx = (BN_CTX *)((void *)0);
  ret = 0;
  mismatches = 0;
  BN_init(& bnz);
  BN_init(& bnez);
  BN_init(& bnm);
  bnctx = BN_CTX_new();
  bnmont = BN_MONT_CTX_new();
  pgroup = EC_KEY_get0_group((EC_KEY const   *)vxcp->vxc_key);
  ppr = EC_POINT_new(pgroup);
  ppc = EC_POINT_new(pgroup);
  pps = EC_POINT_new(pgroup);
  ppt = EC_POINT_new(pgroup);
  if (! bnctx) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: out of memory\n");
    goto out;
  } else
  if (! bnmont) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: out of memory\n");
    goto out;
  } else
  if (! ppr) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: out of memory\n");
    goto out;
  } else
  if (! ppc) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: out of memory\n");
    goto out;
  } else
  if (! pps) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: out of memory\n");
    goto out;
  } else
  if (! ppt) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: out of memory\n");
    goto out;
  }
  BN_bin2bn(raw_modulus, (int )sizeof(raw_modulus), & bnm);
  BN_MONT_CTX_set(bnmont, (BIGNUM const   *)(& bnm), bnctx);
  if (z_inverted) {
    bnzc = & bnez;
  } else {
    bnzc = & pps->Z;
  }
  tmp___0 = vg_ocl_map_arg_buffer(vocp, slot, 1, 0);
  z_heap = (unsigned char *)tmp___0;
  tmp___1 = vg_ocl_map_arg_buffer(vocp, slot, 2, 0);
  point_tmp = (unsigned char *)tmp___1;
  tmp___2 = vg_ocl_map_arg_buffer(vocp, slot, 3, 0);
  ocl_points_in = (unsigned char *)tmp___2;
  tmp___3 = vg_ocl_map_arg_buffer(vocp, slot, 4, 0);
  ocl_strides_in = (unsigned char *)tmp___3;
  if (! z_heap) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not map OpenCL point buffers\n");
    goto out;
  } else
  if (! point_tmp) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not map OpenCL point buffers\n");
    goto out;
  } else
  if (! ocl_points_in) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not map OpenCL point buffers\n");
    goto out;
  } else
  if (! ocl_strides_in) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not map OpenCL point buffers\n");
    goto out;
  }
  y = 0;
  while (y < vocp->voc_ocl_rows) {
    vg_ocl_get_point(ppr, (unsigned char const   *)(ocl_strides_in + 64 * y));
    bx = y * vocp->voc_ocl_cols;
    mm_r = 0;
    x = 0;
    while (x < vocp->voc_ocl_cols) {
      vg_ocl_get_point_tpa(ppc, (unsigned char const   *)ocl_points_in, x);
      if (ppr->Z_is_one) {
        if (! ppc->Z_is_one) {
          __assert_fail("ppr->Z_is_one && ppc->Z_is_one", "oclengine.c", 1718U, "vg_ocl_verify_temporary");
        }
      } else {
        __assert_fail("ppr->Z_is_one && ppc->Z_is_one", "oclengine.c", 1718U, "vg_ocl_verify_temporary");
      }
      EC_POINT_add(pgroup, pps, (EC_POINT const   *)ppc, (EC_POINT const   *)ppr,
                   bnctx);
      if (! (! pps->Z_is_one)) {
        __assert_fail("!pps->Z_is_one", "oclengine.c", 1720U, "vg_ocl_verify_temporary");
      }
      vg_ocl_get_point_tpa(ppt, (unsigned char const   *)point_tmp, bx + x);
      vg_ocl_get_bignum_tpa(& bnz, (unsigned char const   *)z_heap, bx + x);
      if (z_inverted) {
        BN_mod_inverse(& bnez, (BIGNUM const   *)(& pps->Z), (BIGNUM const   *)(& bnm),
                       bnctx);
        BN_mod_mul_montgomery(& bnez, (BIGNUM const   *)(& bnez), (BIGNUM const   *)(& bnmont->RR),
                              bnmont, bnctx);
        BN_mod_mul_montgomery(& bnez, (BIGNUM const   *)(& bnez), (BIGNUM const   *)(& bnmont->RR),
                              bnmont, bnctx);
      }
      tmp___10 = BN_cmp((BIGNUM const   *)(& ppt->X), (BIGNUM const   *)(& pps->X));
      if (tmp___10) {
        goto _L;
      } else {
        tmp___11 = BN_cmp((BIGNUM const   *)(& ppt->Y), (BIGNUM const   *)(& pps->Y));
        if (tmp___11) {
          goto _L;
        } else {
          tmp___12 = BN_cmp((BIGNUM const   *)(& bnz), (BIGNUM const   *)bnzc);
          if (tmp___12) {
            _L: /* CIL Label */ 
            if (! mismatches) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Base privkey: ");
              tmp___6 = EC_KEY_get0_private_key((EC_KEY const   *)vxcp->vxc_key);
              fdumpbn(stderr, tmp___6);
            }
            mismatches ++;
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Mismatch for kernel %d, offset %d (%d,%d)\n",
                    z_inverted, bx + x, y, x);
            if (! mm_r) {
              mm_r = 1;
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Row X   : ");
              fdumpbn(stderr, (BIGNUM const   *)(& ppr->X));
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Row Y   : ");
              fdumpbn(stderr, (BIGNUM const   *)(& ppr->Y));
            }
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Column X: ");
            fdumpbn(stderr, (BIGNUM const   *)(& ppc->X));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Column Y: ");
            fdumpbn(stderr, (BIGNUM const   *)(& ppc->Y));
            tmp___7 = BN_cmp((BIGNUM const   *)(& ppt->X), (BIGNUM const   *)(& pps->X));
            if (tmp___7) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Expect X: ");
              fdumpbn(stderr, (BIGNUM const   *)(& pps->X));
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Device X: ");
              fdumpbn(stderr, (BIGNUM const   *)(& ppt->X));
            }
            tmp___8 = BN_cmp((BIGNUM const   *)(& ppt->Y), (BIGNUM const   *)(& pps->Y));
            if (tmp___8) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Expect Y: ");
              fdumpbn(stderr, (BIGNUM const   *)(& pps->Y));
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Device Y: ");
              fdumpbn(stderr, (BIGNUM const   *)(& ppt->Y));
            }
            tmp___9 = BN_cmp((BIGNUM const   *)(& bnz), (BIGNUM const   *)bnzc);
            if (tmp___9) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Expect Z: ");
              fdumpbn(stderr, (BIGNUM const   *)bnzc);
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Device Z: ");
              fdumpbn(stderr, (BIGNUM const   *)(& bnz));
            }
          }
        }
      }
      x ++;
    }
    y ++;
  }
  ret = ! mismatches;
  out: 
  if (z_heap) {
    vg_ocl_unmap_arg_buffer(vocp, slot, 1, (void *)z_heap);
  }
  if (point_tmp) {
    vg_ocl_unmap_arg_buffer(vocp, slot, 2, (void *)point_tmp);
  }
  if (ocl_points_in) {
    vg_ocl_unmap_arg_buffer(vocp, slot, 3, (void *)ocl_points_in);
  }
  if (ocl_strides_in) {
    vg_ocl_unmap_arg_buffer(vocp, slot, 4, (void *)ocl_strides_in);
  }
  if (ppr) {
    EC_POINT_free(ppr);
  }
  if (ppc) {
    EC_POINT_free(ppc);
  }
  if (pps) {
    EC_POINT_free(pps);
  }
  if (ppt) {
    EC_POINT_free(ppt);
  }
  BN_clear_free(& bnz);
  BN_clear_free(& bnez);
  BN_clear_free(& bnm);
  if (bnmont) {
    BN_MONT_CTX_free(bnmont);
  }
  if (bnctx) {
    BN_CTX_free(bnctx);
  }
  return (ret);
}
}
static int vg_ocl_verify_k0(vg_ocl_context_t *vocp , int slot ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = vg_ocl_verify_temporary(vocp, slot, 0);
  return (tmp___0);
}
}
static int vg_ocl_verify_k1(vg_ocl_context_t *vocp , int slot ) 
{ 
  int tmp___0 ;

  {
  tmp___0 = vg_ocl_verify_temporary(vocp, slot, 1);
  return (tmp___0);
}
}
static void *vg_opencl_thread(void *arg ) 
{ 
  vg_ocl_context_t *vocp ;
  vg_context_t *vcp ;
  int halt ;
  int slot ;
  int rows ;
  int cols ;
  int invsize ;
  unsigned long long idleu ;
  unsigned long long busyu ;
  double pidle ;
  struct timeval tv ;
  struct timeval tvt ;
  struct timeval tvd ;
  struct timeval idle ;
  struct timeval busy ;
  int tmp___1 ;
  int tmp___2 ;

  {
  vocp = (vg_ocl_context_t *)arg;
  vcp = vocp->base.vxc_vc;
  halt = 0;
  slot = -1;
  memset((void *)(& idle), 0, sizeof(idle));
  memset((void *)(& busy), 0, sizeof(busy));
  while (1) {
    pthread_mutex_lock(& vocp->voc_lock);
    if (halt) {
      halt = 0;
      vocp->voc_halt = 1;
    }
    if (slot != -1) {
      if (! (vocp->voc_ocl_slot == slot)) {
        __assert_fail("vocp->voc_ocl_slot == slot", "oclengine.c", 1838U, "vg_opencl_thread");
      }
      vocp->voc_ocl_slot = -1;
      slot = -1;
      pthread_cond_signal(& vocp->voc_wait);
    }
    if (vocp->voc_ocl_slot == -1) {
      gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
      while (vocp->voc_ocl_slot == -1) {
        if (vocp->voc_halt) {
          goto out;
        }
        pthread_cond_wait((pthread_cond_t * __restrict  )(& vocp->voc_wait), (pthread_mutex_t * __restrict  )(& vocp->voc_lock));
      }
      gettimeofday((struct timeval * __restrict  )(& tvt), (void * __restrict  )((void *)0));
      while (1) {
        tvd.tv_sec = tvt.tv_sec - tv.tv_sec;
        tvd.tv_usec = tvt.tv_usec - tv.tv_usec;
        if (tvd.tv_usec < 0L) {
          (tvd.tv_sec) --;
          tvd.tv_usec += 1000000L;
        }
        break;
      }
      while (1) {
        idle.tv_sec = tvd.tv_sec + idle.tv_sec;
        idle.tv_usec = tvd.tv_usec + idle.tv_usec;
        if (idle.tv_usec >= 1000000L) {
          (idle.tv_sec) ++;
          idle.tv_usec -= 1000000L;
        }
        break;
      }
    }
    slot = vocp->voc_ocl_slot;
    rows = vocp->voc_ocl_rows;
    cols = vocp->voc_ocl_cols;
    invsize = vocp->voc_ocl_invsize;
    pthread_mutex_unlock(& vocp->voc_lock);
    gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
    tmp___1 = vg_ocl_kernel_start(vocp, slot, cols, rows, invsize);
    if (! tmp___1) {
      halt = 1;
    }
    tmp___2 = vg_ocl_kernel_wait(vocp, slot);
    if (! tmp___2) {
      halt = 1;
    }
    if (vcp->vc_verbose > 1) {
      gettimeofday((struct timeval * __restrict  )(& tvt), (void * __restrict  )((void *)0));
      while (1) {
        tvd.tv_sec = tvt.tv_sec - tv.tv_sec;
        tvd.tv_usec = tvt.tv_usec - tv.tv_usec;
        if (tvd.tv_usec < 0L) {
          (tvd.tv_sec) --;
          tvd.tv_usec += 1000000L;
        }
        break;
      }
      while (1) {
        busy.tv_sec = tvd.tv_sec + busy.tv_sec;
        busy.tv_usec = tvd.tv_usec + busy.tv_usec;
        if (busy.tv_usec >= 1000000L) {
          (busy.tv_sec) ++;
          busy.tv_usec -= 1000000L;
        }
        break;
      }
      if (busy.tv_sec + idle.tv_sec > 1L) {
        idleu = (unsigned long long )(1000000L * idle.tv_sec + idle.tv_usec);
        busyu = (unsigned long long )(1000000L * busy.tv_sec + busy.tv_usec);
        pidle = (double )idleu / (double )(idleu + busyu);
        if (pidle > 0.01) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\rGPU idle: %.2f%%                                                              \n",
                  (double )100 * pidle);
        }
        memset((void *)(& idle), 0, sizeof(idle));
        memset((void *)(& busy), 0, sizeof(busy));
      }
    }
  }
  out: 
  pthread_mutex_unlock(& vocp->voc_lock);
  return ((void *)0);
}
}
static void *vg_opencl_loop(vg_exec_context_t *arg ) 
{ 
  vg_ocl_context_t *vocp ;
  int i ;
  int round___0 ;
  int nrows ;
  int ncols ;
  int pattern_generation ;
  unsigned long rekey_max ;
  unsigned long npoints ;
  unsigned long rekey_at ;
  EC_KEY *pkey ;
  EC_GROUP const   *pgroup ;
  EC_POINT const   *pgen ;
  EC_POINT **ppbase ;
  EC_POINT **pprow ;
  EC_POINT *pbatchinc ;
  EC_POINT *poffset ;
  EC_POINT *pseek ;
  unsigned char *ocl_points_in ;
  unsigned char *ocl_strides_in ;
  vg_context_t *vcp ;
  vg_exec_context_t *vxcp ;
  int slot ;
  int nslots ;
  int slot_busy ;
  int slot_done ;
  int halt ;
  int c ;
  int output_interval ;
  struct timeval tvstart ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  BIGNUM const   *tmp___8 ;
  EC_POINT const   *tmp___10 ;
  void *tmp___11 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
  vocp = (vg_ocl_context_t *)arg;
  rekey_max = 100000000UL;
  pkey = (EC_KEY *)((void *)0);
  ppbase = (EC_POINT **)((void *)0);
  pbatchinc = (EC_POINT *)((void *)0);
  poffset = (EC_POINT *)((void *)0);
  pseek = (EC_POINT *)((void *)0);
  vcp = vocp->base.vxc_vc;
  vxcp = & vocp->base;
  slot_busy = 0;
  slot_done = 0;
  halt = 0;
  c = 0;
  output_interval = 1000;
  pkey = vxcp->vxc_key;
  pgroup = EC_KEY_get0_group((EC_KEY const   *)pkey);
  pgen = EC_GROUP_get0_generator(pgroup);
  round___0 = vocp->voc_ocl_rows * vocp->voc_ocl_cols;
  if (! vcp->vc_remove_on_match) {
    if (vcp->vc_chance >= (double )1.0f) {
      if (vcp->vc_chance < (double )round___0) {
        if (vcp->vc_verbose > 0) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: low pattern difficulty\n");
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: better match throughput is possible using vanitygen on the CPU\n");
        }
      }
    }
  }
  slot = 0;
  nslots = 2;
  vocp->voc_nslots = nslots;
  nrows = vocp->voc_ocl_rows;
  ncols = vocp->voc_ocl_cols;
  tmp___0 = malloc((unsigned long )(nrows + ncols) * sizeof(EC_POINT *));
  ppbase = (EC_POINT **)tmp___0;
  if (! ppbase) {
    goto enomem;
  }
  i = 0;
  while (i < nrows + ncols) {
    *(ppbase + i) = EC_POINT_new(pgroup);
    if (! *(ppbase + i)) {
      goto enomem;
    }
    i ++;
  }
  pprow = ppbase + ncols;
  pbatchinc = EC_POINT_new(pgroup);
  poffset = EC_POINT_new(pgroup);
  pseek = EC_POINT_new(pgroup);
  if (! pbatchinc) {
    goto enomem;
  } else
  if (! poffset) {
    goto enomem;
  } else
  if (! pseek) {
    goto enomem;
  }
  BN_set_word(& vxcp->vxc_bntmp, (unsigned long )ncols);
  EC_POINT_mul(pgroup, pbatchinc, (BIGNUM const   *)(& vxcp->vxc_bntmp), (EC_POINT const   *)((void *)0),
               (BIGNUM const   *)((void *)0), vxcp->vxc_bnctx);
  EC_POINT_make_affine(pgroup, pbatchinc, vxcp->vxc_bnctx);
  BN_set_word(& vxcp->vxc_bntmp, (unsigned long )round___0);
  EC_POINT_mul(pgroup, poffset, (BIGNUM const   *)(& vxcp->vxc_bntmp), (EC_POINT const   *)((void *)0),
               (BIGNUM const   *)((void *)0), vxcp->vxc_bnctx);
  EC_POINT_make_affine(pgroup, poffset, vxcp->vxc_bnctx);
  tmp___1 = vg_ocl_config_pattern(vocp);
  if (! tmp___1) {
    goto enomem;
  }
  i = 0;
  while (i < nslots) {
    tmp___2 = vg_ocl_kernel_arg_alloc(vocp, i, 4, (size_t )(64 * nrows), 1);
    if (! tmp___2) {
      goto enomem;
    }
    i ++;
  }
  tmp___3 = vg_ocl_kernel_arg_alloc(vocp, -1, 1, (size_t )((64 * round___0 + 4095) & -4096),
                                    0);
  if (tmp___3) {
    tmp___4 = vg_ocl_kernel_arg_alloc(vocp, -1, 2, (size_t )((64 * round___0 + 4095) & -4096),
                                      0);
    if (tmp___4) {
      tmp___5 = vg_ocl_kernel_arg_alloc(vocp, -1, 3, (size_t )((64 * ncols + 4095) & -4096),
                                        1);
      if (! tmp___5) {
        goto enomem;
      }
    } else {
      goto enomem;
    }
  } else {
    goto enomem;
  }
  npoints = 0UL;
  rekey_at = 0UL;
  vxcp->vxc_binres[0] = (unsigned char )vcp->vc_addrtype;
  tmp___6 = pthread_create((pthread_t * __restrict  )(& vocp->voc_ocl_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                           & vg_opencl_thread, (void * __restrict  )vocp);
  if (tmp___6) {
    goto enomem;
  }
  gettimeofday((struct timeval * __restrict  )(& tvstart), (void * __restrict  )((void *)0));
  l_rekey: 
  if (vocp->voc_rekey_func) {
    tmp___7 = (*(vocp->voc_rekey_func))(vocp);
    switch (tmp___7) {
    case 1: 
    break;
    case 0: 
    goto nopatterns;
    default: 
    goto enomem;
    }
  }
  vg_exec_context_upgrade_lock(vxcp);
  pattern_generation = vcp->vc_pattern_generation;
  EC_KEY_generate_key(pkey);
  npoints = 0UL;
  EC_GROUP_get_order(pgroup, & vxcp->vxc_bntmp, vxcp->vxc_bnctx);
  tmp___8 = EC_KEY_get0_private_key((EC_KEY const   *)pkey);
  BN_sub(& vxcp->vxc_bntmp2, (BIGNUM const   *)(& vxcp->vxc_bntmp), tmp___8);
  rekey_at = BN_get_word((BIGNUM const   *)(& vxcp->vxc_bntmp2));
  if (rekey_at == 18446744073709551615) {
    rekey_at = rekey_max;
  } else
  if (rekey_at > rekey_max) {
    rekey_at = rekey_max;
  }
  if (! (rekey_at > 0UL)) {
    __assert_fail("rekey_at > 0", "oclengine.c", 2040U, "vg_opencl_loop");
  }
  tmp___10 = EC_KEY_get0_public_key((EC_KEY const   *)pkey);
  EC_POINT_copy(*(ppbase + 0), tmp___10);
  vg_exec_context_downgrade_lock(vxcp);
  if (vcp->vc_pubkey_base) {
    EC_POINT_add(pgroup, *(ppbase + 0), (EC_POINT const   *)*(ppbase + 0), (EC_POINT const   *)vcp->vc_pubkey_base,
                 vxcp->vxc_bnctx);
  }
  i = 1;
  while (i < ncols) {
    EC_POINT_add(pgroup, *(ppbase + i), (EC_POINT const   *)*(ppbase + (i - 1)), pgen,
                 vxcp->vxc_bnctx);
    i ++;
  }
  EC_POINTs_make_affine(pgroup, (size_t )ncols, ppbase, vxcp->vxc_bnctx);
  tmp___11 = vg_ocl_map_arg_buffer(vocp, 0, 3, 1);
  ocl_points_in = (unsigned char *)tmp___11;
  if (! ocl_points_in) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Could not map column buffer\n");
    goto enomem;
  }
  i = 0;
  while (i < ncols) {
    vg_ocl_put_point_tpa(ocl_points_in, i, (EC_POINT const   *)*(ppbase + i));
    i ++;
  }
  vg_ocl_unmap_arg_buffer(vocp, 0, 3, (void *)ocl_points_in);
  EC_POINT_copy(*(pprow + 0), pgen);
  i = 1;
  while (i < nrows) {
    EC_POINT_add(pgroup, *(pprow + i), (EC_POINT const   *)*(pprow + (i - 1)), (EC_POINT const   *)pbatchinc,
                 vxcp->vxc_bnctx);
    i ++;
  }
  EC_POINTs_make_affine(pgroup, (size_t )nrows, pprow, vxcp->vxc_bnctx);
  vxcp->vxc_delta = 1;
  npoints = 1UL;
  slot = 0;
  slot_busy = 0;
  slot_done = 0;
  while (1) {
    if (slot_done) {
      if (! (rekey_at > 0UL)) {
        __assert_fail("rekey_at > 0", "oclengine.c", 2096U, "vg_opencl_loop");
      }
      slot_done = 0;
      tmp___13 = (*(vocp->voc_check_func))(vocp, slot);
      switch (tmp___13) {
      case 1: 
      rekey_at = 0UL;
      break;
      case 2: 
      halt = 1;
      break;
      default: 
      break;
      }
      c += round___0;
      if (! halt) {
        if (c >= output_interval) {
          output_interval = vg_output_timing(vcp, c, & tvstart);
          c = 0;
        }
      }
      vg_exec_context_yield(vxcp);
      if (vocp->voc_rekey_func) {
        if (pattern_generation != vcp->vc_pattern_generation) {
          vocp->voc_pattern_rewrite = 1;
          rekey_at = 0UL;
        }
      }
    }
    if (vcp->vc_halt) {
      halt = 1;
    }
    if (halt) {
      break;
    }
    if (npoints + (unsigned long )round___0 < rekey_at) {
      if (npoints > 1UL) {
        i = 0;
        while (i < nrows) {
          EC_POINT_add(pgroup, *(pprow + i), (EC_POINT const   *)*(pprow + i), (EC_POINT const   *)poffset,
                       vxcp->vxc_bnctx);
          i ++;
        }
        EC_POINTs_make_affine(pgroup, (size_t )nrows, pprow, vxcp->vxc_bnctx);
      }
      tmp___14 = vg_ocl_map_arg_buffer(vocp, slot, 4, 1);
      ocl_strides_in = (unsigned char *)tmp___14;
      if (! ocl_strides_in) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Could not map row buffer for slot %d\n",
                slot);
        goto enomem;
      }
      memset((void *)ocl_strides_in, 0, (size_t )(64 * nrows));
      i = 0;
      while (i < nrows) {
        vg_ocl_put_point(ocl_strides_in + 64 * i, (EC_POINT const   *)*(pprow + i));
        i ++;
      }
      vg_ocl_unmap_arg_buffer(vocp, slot, 4, (void *)ocl_strides_in);
      npoints += (unsigned long )round___0;
      pthread_mutex_lock(& vocp->voc_lock);
      while (vocp->voc_ocl_slot != -1) {
        if (! slot_busy) {
          __assert_fail("slot_busy", "oclengine.c", 2166U, "vg_opencl_loop");
        }
        pthread_cond_wait((pthread_cond_t * __restrict  )(& vocp->voc_wait), (pthread_mutex_t * __restrict  )(& vocp->voc_lock));
      }
      if (vocp->voc_halt) {
        pthread_mutex_unlock(& vocp->voc_lock);
        halt = 1;
        break;
      }
      vocp->voc_ocl_slot = slot;
      pthread_cond_signal(& vocp->voc_wait);
      pthread_mutex_unlock(& vocp->voc_lock);
      slot_done = slot_busy;
      slot_busy = 1;
      slot = (slot + 1) % nslots;
    } else {
      if (slot_busy) {
        pthread_mutex_lock(& vocp->voc_lock);
        while (vocp->voc_ocl_slot != -1) {
          if (! (vocp->voc_ocl_slot == ((slot + nslots) - 1) % nslots)) {
            __assert_fail("vocp->voc_ocl_slot == ((slot + nslots - 1) % nslots)",
                          "oclengine.c", 2189U, "vg_opencl_loop");
          }
          pthread_cond_wait((pthread_cond_t * __restrict  )(& vocp->voc_wait), (pthread_mutex_t * __restrict  )(& vocp->voc_lock));
        }
        pthread_mutex_unlock(& vocp->voc_lock);
        slot_busy = 0;
        slot_done = 1;
      }
      if (! rekey_at) {
        goto l_rekey;
      } else
      if (! slot_done) {
        if (npoints + (unsigned long )round___0 >= rekey_at) {
          goto l_rekey;
        }
      }
    }
  }
  if (0) {
    enomem: 
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: allocation failure?\n");
    nopatterns: ;
  }
  if (halt) {
    if (vcp->vc_verbose > 1) {
      printf((char const   * __restrict  )"Halting...");
      fflush(stdout);
    }
    pthread_mutex_lock(& vocp->voc_lock);
    vocp->voc_halt = 1;
    pthread_cond_signal(& vocp->voc_wait);
    while (vocp->voc_ocl_slot != -1) {
      if (! slot_busy) {
        __assert_fail("slot_busy", "oclengine.c", 2221U, "vg_opencl_loop");
      }
      pthread_cond_wait((pthread_cond_t * __restrict  )(& vocp->voc_wait), (pthread_mutex_t * __restrict  )(& vocp->voc_lock));
    }
    slot_busy = 0;
    pthread_mutex_unlock(& vocp->voc_lock);
    pthread_join(vocp->voc_ocl_thread, (void **)((void *)0));
    if (vcp->vc_verbose > 1) {
      printf((char const   * __restrict  )"done!\n");
    }
  }
  vg_exec_context_yield(vxcp);
  if (ppbase) {
    i = 0;
    while (i < nrows + ncols) {
      if (*(ppbase + i)) {
        EC_POINT_free(*(ppbase + i));
      }
      i ++;
    }
    free((void *)ppbase);
  }
  if (pbatchinc) {
    EC_POINT_free(pbatchinc);
  }
  vg_ocl_free_args(vocp);
  vocp->voc_halt = 0;
  vocp->voc_ocl_slot = -1;
  vg_context_thread_exit(vcp);
  return ((void *)0);
}
}
static int get_device_list(cl_platform_id pid , cl_device_id **list_out ) 
{ 
  cl_uint nd ;
  cl_int res ;
  cl_device_id *ids ;
  void *tmp___0 ;

  {
  res = clGetDeviceIDs(pid, (cl_device_type )4294967295U, (cl_uint )0, (cl_device_id *)((void *)0),
                       & nd);
  if (res != 0) {
    vg_ocl_error((vg_ocl_context_t *)((void *)0), res, "clGetDeviceIDs(0)");
    *list_out = (cl_device_id *)((void *)0);
    return (-1);
  }
  if (nd) {
    tmp___0 = malloc((unsigned long )nd * sizeof(*ids));
    ids = (cl_device_id *)tmp___0;
    if ((unsigned long )ids == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate device ID list\n");
      *list_out = (cl_device_id *)((void *)0);
      return (-1);
    }
    res = clGetDeviceIDs(pid, (cl_device_type )4294967295U, nd, ids, (cl_uint *)((void *)0));
    if (res != 0) {
      vg_ocl_error((vg_ocl_context_t *)((void *)0), res, "clGetDeviceIDs(n)");
      free((void *)ids);
      *list_out = (cl_device_id *)((void *)0);
      return (-1);
    }
    *list_out = ids;
  }
  return ((int )nd);
}
}
static void show_devices(cl_platform_id pid , cl_device_id *ids , int nd , int base ) 
{ 
  int i ;
  char nbuf[128] ;
  char vbuf[128] ;
  size_t len ;
  cl_int res ;

  {
  i = 0;
  while (i < nd) {
    res = clGetDeviceInfo(*(ids + i), (cl_device_info )4139, sizeof(nbuf), (void *)(nbuf),
                          & len);
    if (res != 0) {
      goto __Cont;
    }
    if (len >= sizeof(nbuf)) {
      len = sizeof(nbuf) - 1UL;
    }
    nbuf[len] = (char )'\000';
    res = clGetDeviceInfo(*(ids + i), (cl_device_info )4140, sizeof(vbuf), (void *)(vbuf),
                          & len);
    if (res != 0) {
      goto __Cont;
    }
    if (len >= sizeof(vbuf)) {
      len = sizeof(vbuf) - 1UL;
    }
    vbuf[len] = (char )'\000';
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %d: [%s] %s\n",
            i + base, vbuf, nbuf);
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
static cl_device_id get_device(cl_platform_id pid , int num ) 
{ 
  int nd ;
  cl_device_id id ;
  cl_device_id *ids ;

  {
  nd = get_device_list(pid, & ids);
  if (nd < 0) {
    return ((cl_device_id )((void *)0));
  }
  if (! nd) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No OpenCL devices found\n");
    return ((cl_device_id )((void *)0));
  }
  if (num < 0) {
    if (nd == 1) {
      num = 0;
    } else {
      num = nd;
    }
  }
  if (num < nd) {
    id = *(ids + num);
    free((void *)ids);
    return (id);
  }
  free((void *)ids);
  return ((cl_device_id )((void *)0));
}
}
static int get_platform_list(cl_platform_id **list_out ) 
{ 
  cl_uint np ;
  cl_int res ;
  cl_platform_id *ids ;
  void *tmp___0 ;

  {
  res = clGetPlatformIDs((cl_uint )0, (cl_platform_id *)((void *)0), & np);
  if (res != 0) {
    vg_ocl_error((vg_ocl_context_t *)((void *)0), res, "clGetPlatformIDs(0)");
    *list_out = (cl_platform_id *)((void *)0);
    return (-1);
  }
  if (np) {
    tmp___0 = malloc((unsigned long )np * sizeof(*ids));
    ids = (cl_platform_id *)tmp___0;
    if ((unsigned long )ids == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate platform ID list\n");
      *list_out = (cl_platform_id *)((void *)0);
      return (-1);
    }
    res = clGetPlatformIDs(np, ids, (cl_uint *)((void *)0));
    if (res != 0) {
      vg_ocl_error((vg_ocl_context_t *)((void *)0), res, "clGetPlatformIDs(n)");
      free((void *)ids);
      *list_out = (cl_platform_id *)((void *)0);
      return (-1);
    }
    *list_out = ids;
  }
  return ((int )np);
}
}
void show_platforms(cl_platform_id *ids , int np , int base ) 
{ 
  int i ;
  char nbuf[128] ;
  char vbuf[128] ;
  size_t len ;
  cl_int res ;

  {
  i = 0;
  while (i < np) {
    res = clGetPlatformInfo(*(ids + i), (cl_platform_info )2306, sizeof(nbuf), (void *)(nbuf),
                            & len);
    if (res != 0) {
      vg_ocl_error((vg_ocl_context_t *)((void *)0), res, "clGetPlatformInfo(NAME)");
      goto __Cont;
    }
    if (len >= sizeof(nbuf)) {
      len = sizeof(nbuf) - 1UL;
    }
    nbuf[len] = (char )'\000';
    res = clGetPlatformInfo(*(ids + i), (cl_platform_info )2307, sizeof(vbuf), (void *)(vbuf),
                            & len);
    if (res != 0) {
      vg_ocl_error((vg_ocl_context_t *)((void *)0), res, "clGetPlatformInfo(VENDOR)");
      goto __Cont;
    }
    if (len >= sizeof(vbuf)) {
      len = sizeof(vbuf) - 1UL;
    }
    vbuf[len] = (char )'\000';
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d: [%s] %s\n",
            i + base, vbuf, nbuf);
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
static cl_platform_id get_platform(int num ) 
{ 
  int np ;
  cl_platform_id id ;
  cl_platform_id *ids ;

  {
  np = get_platform_list(& ids);
  if (np < 0) {
    return ((cl_platform_id )((void *)0));
  }
  if (! np) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No OpenCL platforms available\n");
    return ((cl_platform_id )((void *)0));
  }
  if (num < 0) {
    if (np == 1) {
      num = 0;
    } else {
      num = np;
    }
  }
  if (num < np) {
    id = *(ids + num);
    free((void *)ids);
    return (id);
  }
  free((void *)ids);
  return ((cl_platform_id )((void *)0));
}
}
void vg_ocl_enumerate_devices(void) 
{ 
  cl_platform_id *pids ;
  cl_device_id *dids ;
  int np ;
  int nd ;
  int i ;

  {
  np = get_platform_list(& pids);
  if (! np) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No OpenCL platforms available\n");
    return;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Available OpenCL platforms:\n");
  i = 0;
  while (i < np) {
    show_platforms(pids + i, 1, i);
    nd = get_device_list(*(pids + i), & dids);
    if (! nd) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -- No devices\n");
    } else {
      show_devices(*(pids + i), dids, nd, 0);
    }
    i ++;
  }
  return;
}
}
static cl_device_id get_opencl_device(int platformidx , int deviceidx ) 
{ 
  cl_platform_id pid ;
  cl_device_id did ;

  {
  did = (cl_device_id )((void *)0);
  pid = get_platform(platformidx);
  if (pid) {
    did = get_device(pid, deviceidx);
    if (did) {
      return (did);
    }
  }
  return ((cl_device_id )((void *)0));
}
}
vg_ocl_context_t *vg_ocl_context_new(vg_context_t *vcp , int platformidx , int deviceidx ,
                                     int safe_mode , int verify , int worksize , int nthreads ,
                                     int nrows , int ncols , int invsize ) 
{ 
  cl_device_id did ;
  int round___0 ;
  int full_threads ;
  int wsmult ;
  cl_ulong memsize ;
  cl_ulong allocsize ;
  vg_ocl_context_t *vocp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  cl_device_type tmp___3 ;
  size_t tmp___4 ;
  cl_device_type tmp___5 ;

  {
  did = get_opencl_device(platformidx, deviceidx);
  if (! did) {
    return ((vg_ocl_context_t *)0);
  }
  tmp___0 = malloc(sizeof(*vocp));
  vocp = (vg_ocl_context_t *)tmp___0;
  if (! vocp) {
    return ((vg_ocl_context_t *)((void *)0));
  }
  tmp___1 = vg_ocl_init(vcp, vocp, did, safe_mode);
  if (! tmp___1) {
    free((void *)vocp);
    return ((vg_ocl_context_t *)((void *)0));
  }
  if (verify) {
    if (vcp->vc_verbose > 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Hardware verification mode enabled\n");
    }
    if (! nthreads) {
      nthreads = 1;
    }
    vocp->voc_verify_func[0] = & vg_ocl_verify_k0;
    vocp->voc_verify_func[1] = & vg_ocl_verify_k1;
  }
  if (! nthreads) {
    tmp___3 = vg_ocl_device_gettype(vocp->voc_ocldid);
    if (tmp___3 & (unsigned long )(1 << 1)) {
      nthreads = 1;
    } else {
      tmp___2 = vg_ocl_device_getsizet(vocp->voc_ocldid, (cl_device_info )4100);
      nthreads = (int )tmp___2;
    }
  }
  tmp___4 = vg_ocl_device_getsizet(vocp->voc_ocldid, (cl_device_info )4098);
  full_threads = (int )tmp___4;
  full_threads *= nthreads;
  if (! worksize) {
    tmp___5 = vg_ocl_device_gettype(vocp->voc_ocldid);
    if (tmp___5 & (unsigned long )(1 << 2)) {
      worksize = 2048;
    } else {
      worksize = 256;
    }
  }
  if (! ncols) {
    memsize = vg_ocl_device_getulong(vocp->voc_ocldid, (cl_device_info )4127);
    allocsize = vg_ocl_device_getulong(vocp->voc_ocldid, (cl_device_info )4112);
    memsize /= 2UL;
    ncols = full_threads;
    nrows = 2;
    while (1) {
      if (ncols > nrows) {
        if (! (! (ncols & 1))) {
          break;
        }
      } else {
        break;
      }
      ncols /= 2;
      nrows *= 2;
    }
    wsmult = 1;
    while (1) {
      if (! worksize) {
        goto _L;
      } else
      if (wsmult * 2 <= worksize) {
        _L: /* CIL Label */ 
        if ((cl_ulong )(((ncols * nrows) * 2) * 128) < memsize) {
          if (! ((cl_ulong )(((ncols * nrows) * 2) * 64) < allocsize)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      if (ncols > nrows) {
        nrows *= 2;
      } else {
        ncols *= 2;
      }
      wsmult *= 2;
    }
  }
  round___0 = nrows * ncols;
  if (! invsize) {
    invsize = 2;
    while (1) {
      if (! (round___0 % (invsize << 1))) {
        if (! (round___0 / invsize > full_threads)) {
          break;
        }
      } else {
        break;
      }
      invsize <<= 1;
    }
  }
  if (vcp->vc_verbose > 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Grid size: %dx%d\n",
            ncols, nrows);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse: %d threads, %d ops each\n",
            round___0 / invsize, invsize);
  }
  if (round___0 % invsize) {
    goto _L___0;
  } else
  if (! (! (invsize & (invsize - 1)))) {
    goto _L___0;
  } else
  if (invsize < 2) {
    _L___0: /* CIL Label */ 
    if (vcp->vc_verbose <= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Grid size: %dx%d\n",
              ncols, nrows);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse: %d threads, %d ops each\n",
              round___0 / invsize, invsize);
    }
    if (round___0 % invsize) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse work size must evenly divide points\n");
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse work per task (%d) must be a power of 2\n",
              invsize);
    }
    goto out_fail;
  }
  vocp->voc_ocl_rows = nrows;
  vocp->voc_ocl_cols = ncols;
  vocp->voc_ocl_invsize = invsize;
  return (vocp);
  out_fail: 
  vg_ocl_context_free(vocp);
  return ((vg_ocl_context_t *)((void *)0));
}
}
vg_ocl_context_t *vg_ocl_context_new_from_devstr(vg_context_t *vcp , char const   *devstr ,
                                                 int safemode , int verify ) 
{ 
  int platformidx ;
  int deviceidx ;
  int worksize ;
  int nthreads ;
  int nrows ;
  int ncols ;
  int invsize ;
  char *dsd ;
  char *part ;
  char *part2 ;
  char *save ;
  char *param ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  vg_ocl_context_t *tmp___5 ;

  {
  worksize = 0;
  nthreads = 0;
  nrows = 0;
  ncols = 0;
  invsize = 0;
  dsd = strdup(devstr);
  if (! dsd) {
    return ((vg_ocl_context_t *)((void *)0));
  }
  save = (char *)((void *)0);
  part = strtok_r((char * __restrict  )dsd, (char const   * __restrict  )",", (char ** __restrict  )(& save));
  part2 = strchr((char const   *)part, ':');
  if (! part2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid device specifier \'%s\'\n",
            part);
    free((void *)dsd);
    return ((vg_ocl_context_t *)((void *)0));
  }
  *part2 = (char )'\000';
  platformidx = atoi((char const   *)part);
  deviceidx = atoi((char const   *)(part2 + 1));
  while (1) {
    part = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )",",
                    (char ** __restrict  )(& save));
    if (! ((unsigned long )part != (unsigned long )((void *)0))) {
      break;
    }
    param = strchr((char const   *)part, '=');
    if (! param) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized parameter \'%s\'\n",
              part);
      continue;
    }
    *param = (char )'\000';
    param ++;
    tmp___4 = strcmp((char const   *)part, "grid");
    if (tmp___4) {
      tmp___3 = strcmp((char const   *)part, "invsize");
      if (tmp___3) {
        tmp___2 = strcmp((char const   *)part, "threads");
        if (tmp___2) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized parameter \'%s\'\n",
                  part);
        } else {
          nthreads = atoi((char const   *)param);
          if (nthreads == 0) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid thread count \'%s\'\n",
                    param);
            continue;
          }
        }
      } else {
        invsize = atoi((char const   *)param);
        if (! invsize) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid modular inverse size \'%s\'\n",
                  param);
          continue;
        }
        if (invsize & (invsize - 1)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse size %d must be a power of 2\n",
                  invsize);
          invsize = 0;
          continue;
        }
      }
    } else {
      tmp___0 = strtol((char const   * __restrict  )param, (char ** __restrict  )(& part2),
                       0);
      ncols = (int )tmp___0;
      if (part2) {
        if ((int )*part2 == 120) {
          tmp___1 = strtol((char const   * __restrict  )(part2 + 1), (char ** __restrict  )((void *)0),
                           0);
          nrows = (int )tmp___1;
        }
      }
      if (! nrows) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid grid size \'%s\'\n",
                param);
        nrows = 0;
        ncols = 0;
        continue;
      } else
      if (! ncols) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid grid size \'%s\'\n",
                param);
        nrows = 0;
        ncols = 0;
        continue;
      }
    }
  }
  free((void *)dsd);
  tmp___5 = vg_ocl_context_new(vcp, platformidx, deviceidx, safemode, verify, worksize,
                               nthreads, nrows, ncols, invsize);
  return (tmp___5);
}
}
void vg_ocl_context_free(vg_ocl_context_t *vocp ) 
{ 


  {
  vg_ocl_del(vocp);
  free((void *)vocp);
  return;
}
}
#pragma merger("0","/tmp/cil-0tBpLO9a.i","-ggdb,-O3,-Wall")
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
extern unsigned char *SHA256(unsigned char const   *d , size_t n , unsigned char *md ) ;
extern unsigned char *RIPEMD160(unsigned char const   *d , size_t n , unsigned char *md ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk_warn)(char const   * __restrict  __name , char * __restrict  __resolved ,
                                size_t __resolvedlen )  __asm__("__realpath_chk") __attribute__((__warning__("second argument of realpath must be either NULL or at least PATH_MAX bytes long buffer"))) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                        char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) 
{ 
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;

  {
  tmp___5 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)__resolved, 1);
    if (tmp___2 < 4096UL) {
      tmp___0 = __builtin_object_size((void *)__resolved, 1);
      tmp___1 = __realpath_chk_warn(__name, __resolved, tmp___0);
      return (tmp___1);
    }
    tmp___3 = __builtin_object_size((void *)__resolved, 1);
    tmp___4 = __realpath_chk(__name, __resolved, tmp___3);
    return (tmp___4);
  }
  tmp___6 = __realpath_alias(__name, __resolved);
  return (tmp___6);
}
}
extern BIGNUM const   *BN_value_one(void) ;
extern BIGNUM *BN_new(void) ;
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
extern int BN_add(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
extern int BN_mul(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b , BN_CTX *ctx ) ;
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
extern void BN_free(BIGNUM *a ) ;
extern int BN_lshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
extern int BN_exp(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BN_CTX *ctx ) ;
extern void BN_clear(BIGNUM *a ) ;
extern int BN_set_bit(BIGNUM *a , int n ) ;
extern char *BN_bn2dec(BIGNUM const   *a ) ;
extern size_t EC_POINT_point2oct(EC_GROUP const   *group , EC_POINT const   *p , point_conversion_form_t form ,
                                 unsigned char *buf , size_t len , BN_CTX *ctx ) ;
extern EC_KEY *EC_KEY_new_by_curve_name(int nid ) ;
extern int EC_KEY_precompute_mult(EC_KEY *key , BN_CTX *ctx ) ;
extern int EC_KEY_check_key(EC_KEY const   *key ) ;
extern int i2d_ECPrivateKey(EC_KEY *key , unsigned char **out ) ;
extern int i2o_ECPublicKey(EC_KEY *key , unsigned char **out ) ;
extern void (*pcre_free)(void * ) ;
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
void vg_context_free(vg_context_t *vcp ) ;
void vg_context_wait_for_completion(vg_context_t *vcp ) ;
void vg_prefix_context_set_case_insensitive(vg_context_t *vcp , int caseinsensitive ) ;
vg_context_t *vg_regex_context_new(int addrtype , int privtype ) ;
void vg_exec_context_consolidate_key(vg_exec_context_t *vxcp ) ;
char const   *vg_b58_alphabet ;
signed char const   vg_b58_reverse_map[256] ;
void dumphex(unsigned char const   *src , size_t len ) ;
void dumpbn(BIGNUM const   *bn ) ;
void vg_encode_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup , int addrtype ,
                       char *result ) ;
void vg_encode_script_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup ,
                              int addrtype , char *result ) ;
void vg_encode_privkey(EC_KEY const   *pkey , int addrtype , char *result ) ;
int vg_set_privkey(BIGNUM const   *bnpriv , EC_KEY *pkey ) ;
int vg_protect_encode_privkey(char *out , EC_KEY const   *pkey , int keytype , int parameter_group ,
                              char const   *pass ) ;
static void avl_delete_fix___0(avl_root_t *rootp , avl_item_t *itemp , avl_item_t *parentp ) 
{ 
  avl_item_t *childp ;

  {
  if ((unsigned long )parentp->ai_left == (unsigned long )((void *)0)) {
    if ((unsigned long )parentp->ai_right == (unsigned long )((void *)0)) {
      if (! ((unsigned long )itemp == (unsigned long )((void *)0))) {
        __assert_fail("itemp == NULL", "avl.h", 188U, "avl_delete_fix");
      }
      parentp->ai_balance = (avl_balance_t )1;
      itemp = parentp;
      parentp = itemp->ai_up;
    }
  }
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_right) {
      itemp = parentp->ai_left;
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )2;
          parentp->ai_balance = (avl_balance_t )0;
          break;
        } else {
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    } else {
      itemp = parentp->ai_right;
      if ((unsigned int )parentp->ai_balance == 2U) {
        if ((unsigned int )itemp->ai_balance == 2U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )0;
          parentp->ai_balance = (avl_balance_t )2;
          break;
        } else {
          childp = itemp->ai_left;
          _avl_rotate_rl(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            parentp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            itemp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )2;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
static void avl_insert_fix___0(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *childp ;
  avl_item_t *parentp ;
  struct _avl_item_s *tmp___0 ;

  {
  parentp = itemp->ai_up;
  tmp___0 = (struct _avl_item_s *)((void *)0);
  itemp->ai_right = tmp___0;
  itemp->ai_left = tmp___0;
  if (! (! itemp->ai_indexed)) {
    __assert_fail("!itemp->ai_indexed", "avl.h", 275U, "avl_insert_fix");
  }
  itemp->ai_indexed = 1;
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          break;
        } else {
          if (! ((unsigned int )itemp->ai_balance != 1U)) {
            __assert_fail("itemp->ai_balance != CENT", "avl.h", 290U, "avl_insert_fix");
          }
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          break;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
        return;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 2U) {
      if ((unsigned int )itemp->ai_balance == 2U) {
        _avl_rotate_rr(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        break;
      } else {
        if (! ((unsigned int )itemp->ai_balance != 1U)) {
          __assert_fail("itemp->ai_balance != CENT", "avl.h", 316U, "avl_insert_fix");
        }
        childp = itemp->ai_left;
        _avl_rotate_rl(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        if ((unsigned int )childp->ai_balance == 2U) {
          parentp->ai_balance = (avl_balance_t )0;
        }
        if ((unsigned int )childp->ai_balance == 0U) {
          itemp->ai_balance = (avl_balance_t )2;
        }
        childp->ai_balance = (avl_balance_t )1;
        break;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 1U) {
      parentp->ai_balance = (avl_balance_t )2;
    } else {
      parentp->ai_balance = (avl_balance_t )1;
      break;
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
static void avl_remove___0(avl_root_t *rootp , avl_item_t *itemp ) 
{ 
  avl_item_t *relocp ;
  avl_item_t *replacep ;
  avl_item_t *parentp ;

  {
  parentp = (avl_item_t *)((void *)0);
  if (! itemp->ai_indexed) {
    __assert_fail("itemp->ai_indexed", "avl.h", 376U, "avl_remove");
  }
  itemp->ai_indexed = 0;
  if ((unsigned long )itemp->ai_left == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )itemp->ai_right == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    parentp = itemp->ai_up;
    replacep = itemp->ai_left;
    if ((unsigned long )replacep == (unsigned long )((void *)0)) {
      replacep = itemp->ai_right;
    }
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = parentp;
    }
    if ((unsigned long )parentp == (unsigned long )((void *)0)) {
      rootp->ar_root = replacep;
    } else {
      if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
        parentp->ai_left = replacep;
      } else {
        parentp->ai_right = replacep;
      }
      avl_delete_fix___0(rootp, replacep, parentp);
    }
    return;
  }
  relocp = avl_next(itemp);
  if (! relocp) {
    __assert_fail("relocp", "avl.h", 405U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_up != (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_up != NULL", "avl.h", 406U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_left == (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_left == NULL", "avl.h", 407U, "avl_remove");
  }
  replacep = relocp->ai_right;
  relocp->ai_left = itemp->ai_left;
  if ((unsigned long )relocp->ai_left != (unsigned long )((void *)0)) {
    (relocp->ai_left)->ai_up = relocp;
  }
  if ((unsigned long )itemp->ai_up == (unsigned long )((void *)0)) {
    rootp->ar_root = relocp;
  } else
  if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left) {
    (itemp->ai_up)->ai_left = relocp;
  } else {
    (itemp->ai_up)->ai_right = relocp;
  }
  if ((unsigned long )relocp == (unsigned long )(relocp->ai_up)->ai_left) {
    if (! ((unsigned long )relocp->ai_up != (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up != itemp", "avl.h", 421U, "avl_remove");
    }
    (relocp->ai_up)->ai_left = replacep;
    parentp = relocp->ai_up;
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = relocp->ai_up;
    }
    relocp->ai_right = itemp->ai_right;
  } else {
    if (! ((unsigned long )relocp->ai_up == (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up == itemp", "avl.h", 428U, "avl_remove");
    }
    relocp->ai_right = replacep;
    parentp = relocp;
  }
  if ((unsigned long )relocp->ai_right != (unsigned long )((void *)0)) {
    (relocp->ai_right)->ai_up = relocp;
  }
  relocp->ai_up = itemp->ai_up;
  relocp->ai_balance = itemp->ai_balance;
  avl_delete_fix___0(rootp, replacep, parentp);
  return;
}
}
EC_KEY *vg_exec_context_new_key(void) 
{ 
  EC_KEY *tmp___0 ;

  {
  tmp___0 = EC_KEY_new_by_curve_name(714);
  return (tmp___0);
}
}
static pthread_mutex_t vg_thread_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static pthread_cond_t vg_thread_rdcond  =    {{{0ULL},
     {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static pthread_cond_t vg_thread_wrcond  =    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static pthread_cond_t vg_thread_upcond  =    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static void __vg_exec_context_yield(vg_exec_context_t *vxcp ) 
{ 


  {
  vxcp->vxc_lockmode = 0;
  while ((vxcp->vxc_vc)->vc_thread_excl) {
    if (vxcp->vxc_stop) {
      if (! (vxcp->vxc_vc)->vc_thread_excl) {
        __assert_fail("vxcp->vxc_vc->vc_thread_excl", "pattern.c", 64U, "__vg_exec_context_yield");
      }
      vxcp->vxc_stop = 0;
      pthread_cond_signal(& vg_thread_upcond);
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& vg_thread_rdcond), (pthread_mutex_t * __restrict  )(& vg_thread_lock));
  }
  if (! (! vxcp->vxc_stop)) {
    __assert_fail("!vxcp->vxc_stop", "pattern.c", 70U, "__vg_exec_context_yield");
  }
  if (! (! vxcp->vxc_lockmode)) {
    __assert_fail("!vxcp->vxc_lockmode", "pattern.c", 71U, "__vg_exec_context_yield");
  }
  vxcp->vxc_lockmode = 1;
  return;
}
}
int vg_exec_context_upgrade_lock(vg_exec_context_t *vxcp ) 
{ 
  vg_exec_context_t *tp ;
  vg_context_t *vcp ;
  int tmp___5 ;

  {
  if (vxcp->vxc_lockmode == 2) {
    return (0);
  }
  pthread_mutex_lock(& vg_thread_lock);
  if (! (vxcp->vxc_lockmode == 1)) {
    __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 86U, "vg_exec_context_upgrade_lock");
  }
  vxcp->vxc_lockmode = 0;
  vcp = vxcp->vxc_vc;
  tmp___5 = vcp->vc_thread_excl;
  (vcp->vc_thread_excl) ++;
  if (tmp___5) {
    if (! vxcp->vxc_stop) {
      __assert_fail("vxcp->vxc_stop", "pattern.c", 91U, "vg_exec_context_upgrade_lock");
    }
    vxcp->vxc_stop = 0;
    pthread_cond_signal(& vg_thread_upcond);
    pthread_cond_wait((pthread_cond_t * __restrict  )(& vg_thread_wrcond), (pthread_mutex_t * __restrict  )(& vg_thread_lock));
    tp = vcp->vc_threads;
    while ((unsigned long )tp != (unsigned long )((void *)0)) {
      if (! (! tp->vxc_lockmode)) {
        __assert_fail("!tp->vxc_lockmode", "pattern.c", 97U, "vg_exec_context_upgrade_lock");
      }
      if (! (! tp->vxc_stop)) {
        __assert_fail("!tp->vxc_stop", "pattern.c", 98U, "vg_exec_context_upgrade_lock");
      }
      tp = tp->vxc_next;
    }
  } else {
    tp = vcp->vc_threads;
    while ((unsigned long )tp != (unsigned long )((void *)0)) {
      if (tp->vxc_lockmode) {
        if (! (tp->vxc_lockmode != 2)) {
          __assert_fail("tp->vxc_lockmode != 2", "pattern.c", 104U, "vg_exec_context_upgrade_lock");
        }
        tp->vxc_stop = 1;
      }
      tp = tp->vxc_next;
    }
    while (1) {
      tp = vcp->vc_threads;
      while ((unsigned long )tp != (unsigned long )((void *)0)) {
        if (tp->vxc_lockmode) {
          if (! (tp->vxc_lockmode != 2)) {
            __assert_fail("tp->vxc_lockmode != 2", "pattern.c", 114U, "vg_exec_context_upgrade_lock");
          }
          pthread_cond_wait((pthread_cond_t * __restrict  )(& vg_thread_upcond), (pthread_mutex_t * __restrict  )(& vg_thread_lock));
          break;
        }
        tp = tp->vxc_next;
      }
      if (! tp) {
        break;
      }
    }
  }
  vxcp->vxc_lockmode = 2;
  pthread_mutex_unlock(& vg_thread_lock);
  return (1);
}
}
void vg_exec_context_downgrade_lock(vg_exec_context_t *vxcp ) 
{ 


  {
  pthread_mutex_lock(& vg_thread_lock);
  if (! (vxcp->vxc_lockmode == 2)) {
    __assert_fail("vxcp->vxc_lockmode == 2", "pattern.c", 132U, "vg_exec_context_downgrade_lock");
  }
  if (! (! vxcp->vxc_stop)) {
    __assert_fail("!vxcp->vxc_stop", "pattern.c", 133U, "vg_exec_context_downgrade_lock");
  }
  ((vxcp->vxc_vc)->vc_thread_excl) --;
  if (! (vxcp->vxc_vc)->vc_thread_excl) {
    vxcp->vxc_lockmode = 1;
    pthread_cond_broadcast(& vg_thread_rdcond);
    pthread_mutex_unlock(& vg_thread_lock);
    return;
  }
  pthread_cond_signal(& vg_thread_wrcond);
  __vg_exec_context_yield(vxcp);
  pthread_mutex_unlock(& vg_thread_lock);
  return;
}
}
int vg_exec_context_init(vg_context_t *vcp , vg_exec_context_t *vxcp ) 
{ 


  {
  pthread_mutex_lock(& vg_thread_lock);
  memset((void *)vxcp, 0, sizeof(*vxcp));
  vxcp->vxc_vc = vcp;
  BN_init(& vxcp->vxc_bntarg);
  BN_init(& vxcp->vxc_bnbase);
  BN_init(& vxcp->vxc_bntmp);
  BN_init(& vxcp->vxc_bntmp2);
  BN_set_word(& vxcp->vxc_bnbase, 58UL);
  vxcp->vxc_bnctx = BN_CTX_new();
  if (! vxcp->vxc_bnctx) {
    __assert_fail("vxcp->vxc_bnctx", "pattern.c", 162U, "vg_exec_context_init");
  }
  vxcp->vxc_key = vg_exec_context_new_key();
  if (! vxcp->vxc_key) {
    __assert_fail("vxcp->vxc_key", "pattern.c", 164U, "vg_exec_context_init");
  }
  EC_KEY_precompute_mult(vxcp->vxc_key, vxcp->vxc_bnctx);
  vxcp->vxc_lockmode = 0;
  vxcp->vxc_stop = 0;
  vxcp->vxc_next = vcp->vc_threads;
  vcp->vc_threads = vxcp;
  __vg_exec_context_yield(vxcp);
  pthread_mutex_unlock(& vg_thread_lock);
  return (1);
}
}
void vg_exec_context_del(vg_exec_context_t *vxcp ) 
{ 
  vg_exec_context_t *tp ;
  vg_exec_context_t **pprev ;

  {
  if (vxcp->vxc_lockmode == 2) {
    vg_exec_context_downgrade_lock(vxcp);
  }
  pthread_mutex_lock(& vg_thread_lock);
  if (! (vxcp->vxc_lockmode == 1)) {
    __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 186U, "vg_exec_context_del");
  }
  vxcp->vxc_lockmode = 0;
  pprev = & (vxcp->vxc_vc)->vc_threads;
  tp = *pprev;
  while (1) {
    if ((unsigned long )tp != (unsigned long )vxcp) {
      if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    pprev = & tp->vxc_next;
    tp = *pprev;
  }
  if (! ((unsigned long )tp == (unsigned long )vxcp)) {
    __assert_fail("tp == vxcp", "pattern.c", 193U, "vg_exec_context_del");
  }
  *pprev = tp->vxc_next;
  if (tp->vxc_stop) {
    pthread_cond_signal(& vg_thread_upcond);
  }
  BN_clear_free(& vxcp->vxc_bntarg);
  BN_clear_free(& vxcp->vxc_bnbase);
  BN_clear_free(& vxcp->vxc_bntmp);
  BN_clear_free(& vxcp->vxc_bntmp2);
  BN_CTX_free(vxcp->vxc_bnctx);
  vxcp->vxc_bnctx = (BN_CTX *)((void *)0);
  pthread_mutex_unlock(& vg_thread_lock);
  return;
}
}
void vg_exec_context_yield(vg_exec_context_t *vxcp ) 
{ 


  {
  if (vxcp->vxc_lockmode == 2) {
    vg_exec_context_downgrade_lock(vxcp);
  } else
  if (vxcp->vxc_stop) {
    if (! (vxcp->vxc_lockmode == 1)) {
      __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 215U, "vg_exec_context_yield");
    }
    pthread_mutex_lock(& vg_thread_lock);
    __vg_exec_context_yield(vxcp);
    pthread_mutex_unlock(& vg_thread_lock);
  }
  if (! (vxcp->vxc_lockmode == 1)) {
    __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 221U, "vg_exec_context_yield");
  }
  return;
}
}
void vg_exec_context_consolidate_key(vg_exec_context_t *vxcp ) 
{ 
  BIGNUM const   *tmp___0 ;

  {
  if (vxcp->vxc_delta) {
    BN_clear(& vxcp->vxc_bntmp);
    BN_set_word(& vxcp->vxc_bntmp, (unsigned long )vxcp->vxc_delta);
    tmp___0 = EC_KEY_get0_private_key((EC_KEY const   *)vxcp->vxc_key);
    BN_add(& vxcp->vxc_bntmp2, tmp___0, (BIGNUM const   *)(& vxcp->vxc_bntmp));
    vg_set_privkey((BIGNUM const   *)(& vxcp->vxc_bntmp2), vxcp->vxc_key);
    vxcp->vxc_delta = 0;
  }
  return;
}
}
void vg_exec_context_calc_address(vg_exec_context_t *vxcp ) 
{ 
  EC_POINT *pubkey ;
  EC_GROUP const   *pgroup ;
  unsigned char eckey_buf[96] ;
  unsigned char hash1[32] ;
  unsigned char hash2[20] ;
  int len ;
  EC_POINT const   *tmp___0 ;
  size_t tmp___1 ;

  {
  vg_exec_context_consolidate_key(vxcp);
  pgroup = EC_KEY_get0_group((EC_KEY const   *)vxcp->vxc_key);
  pubkey = EC_POINT_new(pgroup);
  tmp___0 = EC_KEY_get0_public_key((EC_KEY const   *)vxcp->vxc_key);
  EC_POINT_copy(pubkey, tmp___0);
  if ((vxcp->vxc_vc)->vc_pubkey_base) {
    EC_POINT_add(pgroup, pubkey, (EC_POINT const   *)pubkey, (EC_POINT const   *)(vxcp->vxc_vc)->vc_pubkey_base,
                 vxcp->vxc_bnctx);
  }
  tmp___1 = EC_POINT_point2oct(pgroup, (EC_POINT const   *)pubkey, (point_conversion_form_t )4,
                               eckey_buf, sizeof(eckey_buf), vxcp->vxc_bnctx);
  len = (int )tmp___1;
  SHA256((unsigned char const   *)(eckey_buf), (size_t )len, hash1);
  RIPEMD160((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  memcpy((void * __restrict  )(& vxcp->vxc_binres[1]), (void const   * __restrict  )(hash2),
         (size_t )20);
  EC_POINT_free(pubkey);
  return;
}
}
static pthread_mutex_t timing_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
int vg_output_timing(vg_context_t *vcp ,
                     int cycle , struct timeval *last ) 
{ 
  pthread_t me ;
  struct timeval tvnow ;
  struct timeval tv ;
  timing_info_t *tip ;
  timing_info_t *mytip ;
  unsigned long long rate ;
  unsigned long long myrate ;
  unsigned long long mytime ;
  unsigned long long total ;
  unsigned long long sincelast ;
  int p ;
  int i ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  myrate = 0ULL;
  gettimeofday((struct timeval * __restrict  )(& tvnow), (void * __restrict  )((void *)0));
  while (1) {
    tv.tv_sec = tvnow.tv_sec - last->tv_sec;
    tv.tv_usec = tvnow.tv_usec - last->tv_usec;
    if (tv.tv_usec < 0L) {
      (tv.tv_sec) --;
      tv.tv_usec += 1000000L;
    }
    break;
  }
  memcpy((void * __restrict  )last, (void const   * __restrict  )(& tvnow), sizeof(*last));
  mytime = (unsigned long long )tv.tv_usec + 1000000ULL * (unsigned long long )tv.tv_sec;
  if (! mytime) {
    mytime = 1ULL;
  }
  rate = 0ULL;
  pthread_mutex_lock(& timing_mutex);
  me = pthread_self();
  tip = vcp->vc_timing_head;
  mytip = (timing_info_t *)((void *)0);
  while ((unsigned long )tip != (unsigned long )((void *)0)) {
    tmp___0 = pthread_equal(tip->ti_thread, me);
    if (tmp___0) {
      mytip = tip;
      p = (tip->ti_hist_last + 1) % 5;
      tip->ti_hist_time[p] = mytime;
      tip->ti_hist_work[p] = (unsigned long )cycle;
      tip->ti_hist_last = p;
      mytime = 0ULL;
      myrate = 0ULL;
      i = 0;
      while (i < 5) {
        mytime += tip->ti_hist_time[i];
        myrate += (unsigned long long )tip->ti_hist_work[i];
        i ++;
      }
      myrate = (myrate * 1000000ULL) / mytime;
      tip->ti_last_rate = (unsigned long )myrate;
      rate += myrate;
    } else {
      rate += (unsigned long long )tip->ti_last_rate;
    }
    tip = tip->ti_next;
  }
  if (! mytip) {
    tmp___1 = malloc(sizeof(*tip));
    mytip = (timing_info_t *)tmp___1;
    mytip->ti_next = vcp->vc_timing_head;
    mytip->ti_thread = me;
    vcp->vc_timing_head = mytip;
    mytip->ti_hist_last = 0;
    mytip->ti_hist_time[0] = mytime;
    mytip->ti_hist_work[0] = (unsigned long )cycle;
    i = 1;
    while (i < 5) {
      mytip->ti_hist_time[i] = 1ULL;
      mytip->ti_hist_work[i] = 0UL;
      i ++;
    }
    myrate = ((unsigned long long )cycle * 1000000ULL) / mytime;
    mytip->ti_last_rate = (unsigned long )myrate;
    rate += myrate;
  }
  vcp->vc_timing_total += (unsigned long long )cycle;
  if (vcp->vc_timing_prevfound != vcp->vc_found) {
    vcp->vc_timing_prevfound = vcp->vc_found;
    vcp->vc_timing_sincelast = 0ULL;
  }
  vcp->vc_timing_sincelast += (unsigned long long )cycle;
  if ((unsigned long )mytip != (unsigned long )vcp->vc_timing_head) {
    pthread_mutex_unlock(& timing_mutex);
    return ((int )myrate);
  }
  total = vcp->vc_timing_total;
  sincelast = vcp->vc_timing_sincelast;
  pthread_mutex_unlock(& timing_mutex);
  (*(vcp->vc_output_timing))(vcp, (double )sincelast, rate, total);
  return ((int )myrate);
}
}
void vg_context_thread_exit(vg_context_t *vcp ) 
{ 
  timing_info_t *tip ;
  timing_info_t **ptip ;
  pthread_t me ;
  int tmp___0 ;

  {
  pthread_mutex_lock(& timing_mutex);
  me = pthread_self();
  ptip = & vcp->vc_timing_head;
  tip = *ptip;
  while ((unsigned long )tip != (unsigned long )((void *)0)) {
    tmp___0 = pthread_equal(tip->ti_thread, me);
    if (! tmp___0) {
      goto __Cont;
    }
    *ptip = tip->ti_next;
    free((void *)tip);
    break;
    __Cont: /* CIL Label */ 
    ptip = & tip->ti_next;
    tip = *ptip;
  }
  pthread_mutex_unlock(& timing_mutex);
  return;
}
}
static void vg_timing_info_free(vg_context_t *vcp ) 
{ 
  timing_info_t *tp ;

  {
  while ((unsigned long )vcp->vc_timing_head != (unsigned long )((void *)0)) {
    tp = vcp->vc_timing_head;
    vcp->vc_timing_head = tp->ti_next;
    free((void *)tp);
  }
  return;
}
}
void vg_output_timing_console(vg_context_t *vcp , double count , unsigned long long rate ,
                              unsigned long long total ) 
{ 
  double prob ;
  double time___0 ;
  double targ ;
  char *unit ;
  char linebuf[80] ;
  int rem ;
  int p ;
  int i ;
  double targs[6] ;
  double tmp___0 ;
  double tmp___2 ;

  {
  targs[0] = 0.5;
  targs[1] = 0.75;
  targs[2] = 0.8;
  targs[3] = 0.9;
  targs[4] = 0.95;
  targs[5] = 1.0;
  targ = (double )rate;
  unit = (char *)"key/s";
  if (targ > (double )1000) {
    unit = (char *)"Kkey/s";
    targ /= 1000.0;
    if (targ > (double )1000) {
      unit = (char *)"Mkey/s";
      targ /= 1000.0;
    }
  }
  rem = (int )sizeof(linebuf);
  p = snprintf((char * __restrict  )(linebuf), (size_t )rem, (char const   * __restrict  )"[%.2f %s][total %lld]",
               targ, unit, total);
  if (! (p > 0)) {
    __assert_fail("p > 0", "pattern.c", 421U, "vg_output_timing_console");
  }
  rem -= p;
  if (rem < 0) {
    rem = 0;
  }
  if (vcp->vc_chance >= 1.0) {
    tmp___0 = exp(- count / vcp->vc_chance);
    prob = (double )1.0f - tmp___0;
    if (prob <= 0.999) {
      p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[Prob %.1f%%]",
                   prob * (double )100);
      if (! (p > 0)) {
        __assert_fail("p > 0", "pattern.c", 432U, "vg_output_timing_console");
      }
      rem -= p;
      if (rem < 0) {
        rem = 0;
      }
      p = (int )(sizeof(linebuf) - (unsigned long )rem);
    }
    i = 0;
    while ((unsigned long )i < sizeof(targs) / sizeof(targs[0])) {
      targ = targs[i];
      if (targ < 1.0) {
        if (prob <= targ) {
          break;
        }
      }
      i ++;
    }
    if (targ < 1.0) {
      tmp___2 = log(1.0 - targ);
      time___0 = (- vcp->vc_chance * tmp___2 - count) / (double )rate;
      unit = (char *)"s";
      if (time___0 > (double )60) {
        time___0 /= (double )60;
        unit = (char *)"min";
        if (time___0 > (double )60) {
          time___0 /= (double )60;
          unit = (char *)"h";
          if (time___0 > (double )24) {
            time___0 /= (double )24;
            unit = (char *)"d";
            if (time___0 > (double )365) {
              time___0 /= (double )365;
              unit = (char *)"y";
            }
          }
        }
      }
      if (time___0 > (double )1000000) {
        p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[%d%% in %e%s]",
                     (int )((double )100 * targ), time___0, unit);
      } else {
        p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[%d%% in %.1f%s]",
                     (int )((double )100 * targ), time___0, unit);
      }
      if (! (p > 0)) {
        __assert_fail("p > 0", "pattern.c", 475U, "vg_output_timing_console");
      }
      rem -= p;
      if (rem < 0) {
        rem = 0;
      }
      p = (int )(sizeof(linebuf) - (unsigned long )rem);
    }
  }
  if (vcp->vc_found) {
    if (vcp->vc_remove_on_match) {
      p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[Found %lld/%ld]",
                   vcp->vc_found, vcp->vc_npatterns_start);
    } else {
      p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[Found %lld]",
                   vcp->vc_found);
    }
    if (! (p > 0)) {
      __assert_fail("p > 0", "pattern.c", 490U, "vg_output_timing_console");
    }
    rem -= p;
    if (rem < 0) {
      rem = 0;
    }
  }
  if (rem) {
    memset((void *)(& linebuf[sizeof(linebuf) - (unsigned long )rem]), 32, (size_t )rem);
    linebuf[sizeof(linebuf) - 1UL] = (char )'\000';
  }
  printf((char const   * __restrict  )"\r%s", linebuf);
  fflush(stdout);
  return;
}
}
void vg_output_match_console(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern ) 
{ 
  unsigned char key_buf[512] ;
  unsigned char *pend ;
  char addr_buf[64] ;
  char addr2_buf[64] ;
  char privkey_buf[128] ;
  char const   *keytype ;
  int len ;
  int isscript ;
  EC_POINT *ppnt ;
  int free_ppnt ;
  EC_GROUP const   *tmp___0 ;
  EC_POINT const   *tmp___1 ;
  EC_GROUP const   *tmp___2 ;
  EC_POINT const   *tmp___3 ;
  int tmp___6 ;
  EC_GROUP const   *tmp___7 ;
  EC_GROUP const   *tmp___8 ;
  BIGNUM const   *tmp___9 ;
  FILE *fp ;
  FILE *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
  keytype = "Privkey";
  isscript = (unsigned int )vcp->vc_format == 1U;
  free_ppnt = 0;
  if (vcp->vc_pubkey_base) {
    tmp___0 = EC_KEY_get0_group((EC_KEY const   *)pkey);
    ppnt = EC_POINT_new(tmp___0);
    tmp___1 = EC_KEY_get0_public_key((EC_KEY const   *)pkey);
    EC_POINT_copy(ppnt, tmp___1);
    tmp___2 = EC_KEY_get0_group((EC_KEY const   *)pkey);
    EC_POINT_add(tmp___2, ppnt, (EC_POINT const   *)ppnt, (EC_POINT const   *)vcp->vc_pubkey_base,
                 (BN_CTX *)((void *)0));
    free_ppnt = 1;
    keytype = "PrivkeyPart";
  } else {
    tmp___3 = EC_KEY_get0_public_key((EC_KEY const   *)pkey);
    ppnt = (EC_POINT *)tmp___3;
  }
  tmp___6 = EC_KEY_check_key((EC_KEY const   *)pkey);
  if (! tmp___6) {
    __assert_fail("EC_KEY_check_key(pkey)", "pattern.c", 530U, "vg_output_match_console");
  }
  tmp___7 = EC_KEY_get0_group((EC_KEY const   *)pkey);
  vg_encode_address((EC_POINT const   *)ppnt, tmp___7, vcp->vc_pubkeytype, addr_buf);
  if (isscript) {
    tmp___8 = EC_KEY_get0_group((EC_KEY const   *)pkey);
    vg_encode_script_address((EC_POINT const   *)ppnt, tmp___8, vcp->vc_addrtype,
                             addr2_buf);
  }
  if (vcp->vc_key_protect_pass) {
    len = vg_protect_encode_privkey(privkey_buf, (EC_KEY const   *)pkey, vcp->vc_privtype,
                                    -1, vcp->vc_key_protect_pass);
    if (len) {
      keytype = "Protkey";
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not password-protect key\n");
      vcp->vc_key_protect_pass = (char const   *)((void *)0);
    }
  }
  if (! vcp->vc_key_protect_pass) {
    vg_encode_privkey((EC_KEY const   *)pkey, vcp->vc_privtype, privkey_buf);
  }
  if (! vcp->vc_result_file) {
    printf((char const   * __restrict  )"\r%79s\rPattern: %s\n", "", pattern);
  } else
  if (vcp->vc_verbose > 0) {
    printf((char const   * __restrict  )"\r%79s\rPattern: %s\n", "", pattern);
  }
  if (vcp->vc_verbose > 0) {
    if (vcp->vc_verbose > 1) {
      pend = key_buf;
      len = i2o_ECPublicKey(pkey, & pend);
      printf((char const   * __restrict  )"Pubkey (hex): ");
      dumphex((unsigned char const   *)(key_buf), (size_t )len);
      printf((char const   * __restrict  )"Privkey (hex): ");
      tmp___9 = EC_KEY_get0_private_key((EC_KEY const   *)pkey);
      dumpbn(tmp___9);
      pend = key_buf;
      len = i2d_ECPrivateKey(pkey, & pend);
      printf((char const   * __restrict  )"Privkey (ASN1): ");
      dumphex((unsigned char const   *)(key_buf), (size_t )len);
    }
  }
  if (! vcp->vc_result_file) {
    goto _L;
  } else
  if (vcp->vc_verbose > 0) {
    _L: /* CIL Label */ 
    if (isscript) {
      printf((char const   * __restrict  )"P2SHAddress: %s\n", addr2_buf);
    }
    printf((char const   * __restrict  )"Address: %s\n%s: %s\n", addr_buf, keytype,
           privkey_buf);
  }
  if (vcp->vc_result_file) {
    tmp___10 = fopen((char const   * __restrict  )vcp->vc_result_file, (char const   * __restrict  )"a");
    fp = tmp___10;
    if (! fp) {
      tmp___11 = __errno_location();
      tmp___12 = strerror(*tmp___11);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not open result file: %s\n",
              tmp___12);
    } else {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Pattern: %s\n",
              pattern);
      if (isscript) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"P2SHAddress: %s\n",
                addr2_buf);
      }
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Address: %s\n%s: %s\n",
              addr_buf, keytype, privkey_buf);
      fclose(fp);
    }
  }
  if (free_ppnt) {
    EC_POINT_free(ppnt);
  }
  return;
}
}
void vg_context_free(vg_context_t *vcp ) 
{ 


  {
  vg_timing_info_free(vcp);
  (*(vcp->vc_free))(vcp);
  return;
}
}
int vg_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                            int npatterns ) 
{ 
  int tmp___0 ;

  {
  (vcp->vc_pattern_generation) ++;
  tmp___0 = (*(vcp->vc_add_patterns))(vcp, patterns, npatterns);
  return (tmp___0);
}
}
void vg_context_clear_all_patterns(vg_context_t *vcp ) 
{ 


  {
  (*(vcp->vc_clear_all_patterns))(vcp);
  (vcp->vc_pattern_generation) ++;
  return;
}
}
int vg_context_hash160_sort(vg_context_t *vcp , void *buf ) 
{ 
  int tmp___0 ;

  {
  if (! vcp->vc_hash160_sort) {
    return (0);
  }
  tmp___0 = (*(vcp->vc_hash160_sort))(vcp, buf);
  return (tmp___0);
}
}
int vg_context_start_threads(vg_context_t *vcp ) 
{ 
  vg_exec_context_t *vxcp ;
  int res ;

  {
  vxcp = vcp->vc_threads;
  while ((unsigned long )vxcp != (unsigned long )((void *)0)) {
    res = pthread_create((pthread_t * __restrict  )(& vxcp->vxc_pthread), (pthread_attr_t const   * __restrict  )((void *)0),
                         (void *(*)(void * ))vxcp->vxc_threadfunc, (void * __restrict  )vxcp);
    if (res) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not create thread: %d\n",
              res);
      vg_context_stop_threads(vcp);
      return (-1);
    }
    vxcp->vxc_thread_active = 1;
    vxcp = vxcp->vxc_next;
  }
  return (0);
}
}
void vg_context_stop_threads(vg_context_t *vcp ) 
{ 


  {
  vcp->vc_halt = 1;
  vg_context_wait_for_completion(vcp);
  vcp->vc_halt = 0;
  return;
}
}
void vg_context_wait_for_completion(vg_context_t *vcp ) 
{ 
  vg_exec_context_t *vxcp ;

  {
  vxcp = vcp->vc_threads;
  while ((unsigned long )vxcp != (unsigned long )((void *)0)) {
    if (! vxcp->vxc_thread_active) {
      goto __Cont;
    }
    pthread_join(vxcp->vxc_pthread, (void **)((void *)0));
    vxcp->vxc_thread_active = 0;
    __Cont: /* CIL Label */ 
    vxcp = vxcp->vxc_next;
  }
  return;
}
}
static int get_prefix_ranges(int addrtype , char const   *pfx , BIGNUM **result ,
                             BN_CTX *bnctx ) 
{ 
  int i ;
  int p ;
  int c ;
  int zero_prefix ;
  int check_upper ;
  int b58pow ;
  int b58ceil ;
  int b58top ;
  int ret ;
  BIGNUM bntarg ;
  BIGNUM bnceil ;
  BIGNUM bnfloor ;
  BIGNUM bnbase ;
  BIGNUM *bnap ;
  BIGNUM *bnbp ;
  BIGNUM *bntp ;
  BIGNUM *bnhigh ;
  BIGNUM *bnlow ;
  BIGNUM *bnhigh2 ;
  BIGNUM *bnlow2 ;
  BIGNUM bntmp ;
  BIGNUM bntmp2 ;
  size_t tmp___0 ;
  BIGNUM const   *tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  BIGNUM const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  zero_prefix = 0;
  check_upper = 0;
  b58top = 0;
  ret = -1;
  bnhigh = (BIGNUM *)((void *)0);
  bnlow = (BIGNUM *)((void *)0);
  bnhigh2 = (BIGNUM *)((void *)0);
  bnlow2 = (BIGNUM *)((void *)0);
  BN_init(& bntarg);
  BN_init(& bnceil);
  BN_init(& bnfloor);
  BN_init(& bnbase);
  BN_init(& bntmp);
  BN_init(& bntmp2);
  BN_set_word(& bnbase, 58UL);
  tmp___0 = strlen(pfx);
  p = (int )tmp___0;
  i = 0;
  while (i < p) {
    c = (int )vg_b58_reverse_map[(int )*(pfx + i)];
    if (c == -1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid character \'%c\' in prefix \'%s\'\n",
              (int const   )*(pfx + i), pfx);
      goto out;
    }
    if (i == zero_prefix) {
      if (c == 0) {
        zero_prefix ++;
        if (zero_prefix > 19) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' is too long\n",
                  pfx);
          goto out;
        }
        goto __Cont;
      }
      b58top = c;
      BN_set_word(& bntarg, (unsigned long )c);
    } else {
      BN_set_word(& bntmp2, (unsigned long )c);
      BN_mul(& bntmp, (BIGNUM const   *)(& bntarg), (BIGNUM const   *)(& bnbase),
             bnctx);
      BN_add(& bntarg, (BIGNUM const   *)(& bntmp), (BIGNUM const   *)(& bntmp2));
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  BN_clear(& bntmp);
  BN_set_bit(& bntmp, 200 - zero_prefix * 8);
  tmp___1 = BN_value_one();
  BN_sub(& bnceil, (BIGNUM const   *)(& bntmp), tmp___1);
  BN_set_bit(& bnfloor, 192 - zero_prefix * 8);
  bnlow = BN_new();
  bnhigh = BN_new();
  if (b58top) {
    BN_copy(& bntmp, (BIGNUM const   *)(& bnceil));
    bnap = & bntmp;
    bnbp = & bntmp2;
    b58pow = 0;
    while (1) {
      tmp___2 = BN_cmp((BIGNUM const   *)bnap, (BIGNUM const   *)(& bnbase));
      if (! (tmp___2 > 0)) {
        break;
      }
      b58pow ++;
      BN_div(bnbp, (BIGNUM *)((void *)0), (BIGNUM const   *)bnap, (BIGNUM const   *)(& bnbase),
             bnctx);
      bntp = bnap;
      bnap = bnbp;
      bnbp = bntp;
    }
    tmp___3 = BN_get_word((BIGNUM const   *)bnap);
    b58ceil = (int )tmp___3;
    if (b58pow - (p - zero_prefix) < 6) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' is too long\n",
              pfx);
      goto out;
    }
    BN_set_word(& bntmp2, (unsigned long )(b58pow - (p - zero_prefix)));
    BN_exp(& bntmp, (BIGNUM const   *)(& bnbase), (BIGNUM const   *)(& bntmp2), bnctx);
    BN_mul(bnlow, (BIGNUM const   *)(& bntmp), (BIGNUM const   *)(& bntarg), bnctx);
    tmp___4 = BN_value_one();
    BN_sub(& bntmp2, (BIGNUM const   *)(& bntmp), tmp___4);
    BN_add(bnhigh, (BIGNUM const   *)bnlow, (BIGNUM const   *)(& bntmp2));
    if (b58top <= b58ceil) {
      check_upper = 1;
      bnlow2 = BN_new();
      bnhigh2 = BN_new();
      BN_mul(bnlow2, (BIGNUM const   *)bnlow, (BIGNUM const   *)(& bnbase), bnctx);
      BN_mul(& bntmp2, (BIGNUM const   *)bnhigh, (BIGNUM const   *)(& bnbase), bnctx);
      BN_set_word(& bntmp, 57UL);
      BN_add(bnhigh2, (BIGNUM const   *)(& bntmp2), (BIGNUM const   *)(& bntmp));
      tmp___6 = BN_cmp((BIGNUM const   *)(& bnceil), (BIGNUM const   *)bnlow2);
      if (tmp___6 < 0) {
        check_upper = 0;
        BN_free(bnhigh2);
        bnhigh2 = (BIGNUM *)((void *)0);
        BN_free(bnlow2);
        bnlow2 = (BIGNUM *)((void *)0);
      } else {
        tmp___5 = BN_cmp((BIGNUM const   *)(& bnceil), (BIGNUM const   *)bnhigh2);
        if (tmp___5 < 0) {
          BN_copy(bnhigh2, (BIGNUM const   *)(& bnceil));
        }
      }
      tmp___8 = BN_cmp((BIGNUM const   *)(& bnfloor), (BIGNUM const   *)bnhigh);
      if (tmp___8 >= 0) {
        if (! check_upper) {
          __assert_fail("check_upper", "pattern.c", 820U, "get_prefix_ranges");
        }
        check_upper = 0;
        BN_free(bnhigh);
        bnhigh = bnhigh2;
        bnhigh2 = (BIGNUM *)((void *)0);
        BN_free(bnlow);
        bnlow = bnlow2;
        bnlow2 = (BIGNUM *)((void *)0);
      } else {
        tmp___7 = BN_cmp((BIGNUM const   *)(& bnfloor), (BIGNUM const   *)bnlow);
        if (tmp___7 > 0) {
          BN_copy(bnlow, (BIGNUM const   *)(& bnfloor));
        }
      }
    }
  } else {
    BN_copy(bnhigh, (BIGNUM const   *)(& bnceil));
    BN_clear(bnlow);
  }
  BN_clear(& bntmp);
  BN_set_word(& bntmp, (unsigned long )addrtype);
  BN_lshift(& bntmp2, (BIGNUM const   *)(& bntmp), 192);
  if (check_upper) {
    tmp___10 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh2);
    if (tmp___10 > 0) {
      check_upper = 0;
      BN_free(bnhigh2);
      bnhigh2 = (BIGNUM *)((void *)0);
      BN_free(bnlow2);
      bnlow2 = (BIGNUM *)((void *)0);
    } else {
      tmp___9 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow2);
      if (tmp___9 > 0) {
        BN_copy(bnlow2, (BIGNUM const   *)(& bntmp2));
      }
    }
  }
  tmp___12 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh);
  if (tmp___12 > 0) {
    if (! check_upper) {
      goto not_possible;
    }
    check_upper = 0;
    BN_free(bnhigh);
    bnhigh = bnhigh2;
    bnhigh2 = (BIGNUM *)((void *)0);
    BN_free(bnlow);
    bnlow = bnlow2;
    bnlow2 = (BIGNUM *)((void *)0);
  } else {
    tmp___11 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow);
    if (tmp___11 > 0) {
      BN_copy(bnlow, (BIGNUM const   *)(& bntmp2));
    }
  }
  BN_set_word(& bntmp, (unsigned long )(addrtype + 1));
  BN_lshift(& bntmp2, (BIGNUM const   *)(& bntmp), 192);
  if (check_upper) {
    tmp___14 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow2);
    if (tmp___14 < 0) {
      check_upper = 0;
      BN_free(bnhigh2);
      bnhigh2 = (BIGNUM *)((void *)0);
      BN_free(bnlow2);
      bnlow2 = (BIGNUM *)((void *)0);
    } else {
      tmp___13 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh2);
      if (tmp___13 < 0) {
        BN_copy(bnlow2, (BIGNUM const   *)(& bntmp2));
      }
    }
  }
  tmp___16 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow);
  if (tmp___16 < 0) {
    if (! check_upper) {
      goto not_possible;
    }
    check_upper = 0;
    BN_free(bnhigh);
    bnhigh = bnhigh2;
    bnhigh2 = (BIGNUM *)((void *)0);
    BN_free(bnlow);
    bnlow = bnlow2;
    bnlow2 = (BIGNUM *)((void *)0);
  } else {
    tmp___15 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh);
    if (tmp___15 < 0) {
      BN_copy(bnhigh, (BIGNUM const   *)(& bntmp2));
    }
  }
  if (! check_upper) {
    if ((unsigned long )bnlow2 == (unsigned long )((void *)0)) {
      if (! ((unsigned long )bnhigh2 == (unsigned long )((void *)0))) {
        __assert_fail("check_upper || ((bnlow2 == NULL) && (bnhigh2 == NULL))", "pattern.c",
                      903U, "get_prefix_ranges");
      }
    } else {
      __assert_fail("check_upper || ((bnlow2 == NULL) && (bnhigh2 == NULL))", "pattern.c",
                    903U, "get_prefix_ranges");
    }
  }
  *(result + 0) = bnlow;
  *(result + 1) = bnhigh;
  *(result + 2) = bnlow2;
  *(result + 3) = bnhigh2;
  bnlow = (BIGNUM *)((void *)0);
  bnhigh = (BIGNUM *)((void *)0);
  bnlow2 = (BIGNUM *)((void *)0);
  bnhigh2 = (BIGNUM *)((void *)0);
  ret = 0;
  if (0) {
    not_possible: 
    ret = -2;
  }
  out: 
  BN_clear_free(& bntarg);
  BN_clear_free(& bnceil);
  BN_clear_free(& bnfloor);
  BN_clear_free(& bnbase);
  BN_clear_free(& bntmp);
  BN_clear_free(& bntmp2);
  if (bnhigh) {
    BN_free(bnhigh);
  }
  if (bnlow) {
    BN_free(bnlow);
  }
  if (bnhigh2) {
    BN_free(bnhigh2);
  }
  if (bnlow2) {
    BN_free(bnlow2);
  }
  return (ret);
}
}
static void free_ranges(BIGNUM **ranges ) 
{ 


  {
  BN_free(*(ranges + 0));
  BN_free(*(ranges + 1));
  *(ranges + 0) = (BIGNUM *)((void *)0);
  *(ranges + 1) = (BIGNUM *)((void *)0);
  if (*(ranges + 2)) {
    BN_free(*(ranges + 2));
    BN_free(*(ranges + 3));
    *(ranges + 2) = (BIGNUM *)((void *)0);
    *(ranges + 3) = (BIGNUM *)((void *)0);
  }
  return;
}
}
int const   vpk_nwords  =    (int const   )(((25UL + sizeof(unsigned long )) - 1UL) / sizeof(unsigned long ));
static void vg_prefix_free(vg_prefix_t *vp ) 
{ 


  {
  if (vp->vp_low) {
    BN_free(vp->vp_low);
  }
  if (vp->vp_high) {
    BN_free(vp->vp_high);
  }
  free((void *)vp);
  return;
}
}
static vg_prefix_t *vg_prefix_avl_search(avl_root_t *rootp , BIGNUM *targ ) 
{ 
  vg_prefix_t *vp ;
  avl_item_t *itemp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  itemp = rootp->ar_root;
  while (itemp) {
    vp = (vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item));
    tmp___1 = BN_cmp((BIGNUM const   *)vp->vp_low, (BIGNUM const   *)targ);
    if (tmp___1 > 0) {
      itemp = itemp->ai_left;
    } else {
      tmp___0 = BN_cmp((BIGNUM const   *)vp->vp_high, (BIGNUM const   *)targ);
      if (tmp___0 < 0) {
        itemp = itemp->ai_right;
      } else {
        return (vp);
      }
    }
  }
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_avl_insert(avl_root_t *rootp , vg_prefix_t *vpnew ) 
{ 
  vg_prefix_t *vp ;
  avl_item_t *itemp ;
  avl_item_t **ptrp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  itemp = (avl_item_t *)((void *)0);
  ptrp = & rootp->ar_root;
  while (*ptrp) {
    itemp = *ptrp;
    vp = (vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item));
    tmp___1 = BN_cmp((BIGNUM const   *)vp->vp_low, (BIGNUM const   *)vpnew->vp_high);
    if (tmp___1 > 0) {
      ptrp = & itemp->ai_left;
    } else {
      tmp___0 = BN_cmp((BIGNUM const   *)vp->vp_high, (BIGNUM const   *)vpnew->vp_low);
      if (tmp___0 < 0) {
        ptrp = & itemp->ai_right;
      } else {
        return (vp);
      }
    }
  }
  vpnew->vp_item.ai_up = itemp;
  itemp = & vpnew->vp_item;
  *ptrp = itemp;
  avl_insert_fix___0(rootp, itemp);
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_first(avl_root_t *rootp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = avl_first(rootp);
  if (itemp) {
    return ((vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item)));
  }
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_next(vg_prefix_t *vp ) 
{ 
  avl_item_t *itemp ;

  {
  itemp = & vp->vp_item;
  itemp = avl_next(itemp);
  if (itemp) {
    return ((vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item)));
  }
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_add(avl_root_t *rootp , char const   *pattern , BIGNUM *low ,
                                  BIGNUM *high ) 
{ 
  vg_prefix_t *vp ;
  vg_prefix_t *vp2 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  tmp___2 = BN_cmp((BIGNUM const   *)low, (BIGNUM const   *)high);
  if (! (tmp___2 < 0)) {
    __assert_fail("BN_cmp(low, high) < 0", "pattern.c", 1047U, "vg_prefix_add");
  }
  tmp___3 = malloc(sizeof(*vp));
  vp = (vg_prefix_t *)tmp___3;
  if (vp) {
    avl_item_init(& vp->vp_item);
    vp->vp_sibling = (struct _vg_prefix_s *)((void *)0);
    vp->vp_pattern = pattern;
    vp->vp_low = low;
    vp->vp_high = high;
    vp2 = vg_prefix_avl_insert(rootp, vp);
    if ((unsigned long )vp2 != (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' ignored, overlaps \'%s\'\n",
              pattern, vp2->vp_pattern);
      vg_prefix_free(vp);
      vp = (vg_prefix_t *)((void *)0);
    }
  }
  return (vp);
}
}
static void vg_prefix_delete(avl_root_t *rootp , vg_prefix_t *vp ) 
{ 
  vg_prefix_t *sibp ;
  vg_prefix_t *delp ;

  {
  avl_remove___0(rootp, & vp->vp_item);
  sibp = vp->vp_sibling;
  while (1) {
    if (sibp) {
      if (! ((unsigned long )sibp != (unsigned long )vp)) {
        break;
      }
    } else {
      break;
    }
    avl_remove___0(rootp, & sibp->vp_item);
    delp = sibp;
    sibp = sibp->vp_sibling;
    vg_prefix_free(delp);
  }
  vg_prefix_free(vp);
  return;
}
}
static vg_prefix_t *vg_prefix_add_ranges(avl_root_t *rootp , char const   *pattern ,
                                         BIGNUM **ranges , vg_prefix_t *master ) 
{ 
  vg_prefix_t *vp ;
  vg_prefix_t *vp2 ;

  {
  vp2 = (vg_prefix_t *)((void *)0);
  if (! *(ranges + 0)) {
    __assert_fail("ranges[0]", "pattern.c", 1089U, "vg_prefix_add_ranges");
  }
  vp = vg_prefix_add(rootp, pattern, *(ranges + 0), *(ranges + 1));
  if (! vp) {
    return ((vg_prefix_t *)((void *)0));
  }
  if (*(ranges + 2)) {
    vp2 = vg_prefix_add(rootp, pattern, *(ranges + 2), *(ranges + 3));
    if (! vp2) {
      vg_prefix_delete(rootp, vp);
      return ((vg_prefix_t *)((void *)0));
    }
  }
  if (! master) {
    vp->vp_sibling = vp2;
    if (vp2) {
      vp2->vp_sibling = vp;
    }
  } else
  if (vp2) {
    vp->vp_sibling = vp2;
    if (master->vp_sibling) {
      vp2->vp_sibling = master->vp_sibling;
    } else {
      vp2->vp_sibling = master;
    }
    master->vp_sibling = vp;
  } else {
    if (master->vp_sibling) {
      vp->vp_sibling = master->vp_sibling;
    } else {
      vp->vp_sibling = master;
    }
    master->vp_sibling = vp;
  }
  return (vp);
}
}
static void vg_prefix_range_sum(vg_prefix_t *vp , BIGNUM *result , BIGNUM *tmp1 ) 
{ 
  vg_prefix_t *startp ;

  {
  startp = vp;
  BN_clear(result);
  while (1) {
    BN_sub(tmp1, (BIGNUM const   *)vp->vp_high, (BIGNUM const   *)vp->vp_low);
    BN_add(result, (BIGNUM const   *)result, (BIGNUM const   *)tmp1);
    vp = vp->vp_sibling;
    if (vp) {
      if (! ((unsigned long )vp != (unsigned long )startp)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static unsigned char const   b58_case_map[256]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
static int prefix_case_iter_init(prefix_case_iter_t *cip , char const   *pfx ) 
{ 
  int i ;

  {
  cip->ci_nbits = (char)0;
  cip->ci_value = 0;
  i = 0;
  while (*(pfx + i)) {
    if ((unsigned long )i > sizeof(cip->ci_prefix)) {
      return (0);
    }
    if (! b58_case_map[(int )*(pfx + i)]) {
      cip->ci_prefix[i] = (char )*(pfx + i);
      goto __Cont;
    }
    if ((int const   )b58_case_map[(int )*(pfx + i)] == 2) {
      cip->ci_prefix[i] = (char )((int const   )*(pfx + i) ^ 32);
      goto __Cont;
    }
    cip->ci_prefix[i] = (char )((int const   )*(pfx + i) | 32);
    cip->ci_case_map[(int )cip->ci_nbits] = (char )i;
    cip->ci_nbits = (char )((int )cip->ci_nbits + 1);
    __Cont: /* CIL Label */ 
    i ++;
  }
  cip->ci_prefix[i] = (char )'\000';
  return (1);
}
}
static int prefix_case_iter_next(prefix_case_iter_t *cip ) 
{ 
  unsigned long val ;
  unsigned long max ;
  unsigned long mask ;
  int i ;
  int nbits ;

  {
  nbits = (int )cip->ci_nbits;
  max = (1UL << nbits) - 1UL;
  val = (unsigned long )(cip->ci_value + 1);
  if (val > max) {
    return (0);
  }
  i = 0;
  mask = 1UL;
  while (i < nbits) {
    if (val & mask) {
      cip->ci_prefix[(int )cip->ci_case_map[i]] = (char )((int )cip->ci_prefix[(int )cip->ci_case_map[i]] & 223);
    } else {
      cip->ci_prefix[(int )cip->ci_case_map[i]] = (char )((int )cip->ci_prefix[(int )cip->ci_case_map[i]] | 32);
    }
    i ++;
    mask <<= 1;
  }
  cip->ci_value = (int )val;
  return (1);
}
}
void vg_prefix_context_set_case_insensitive(vg_context_t *vcp , int caseinsensitive ) 
{ 


  {
  ((vg_prefix_context_t *)vcp)->vcp_caseinsensitive = caseinsensitive;
  return;
}
}
static void vg_prefix_context_clear_all_patterns(vg_context_t *vcp ) 
{ 
  vg_prefix_context_t *vcpp ;
  vg_prefix_t *vp ;
  unsigned long npfx_left ;
  int tmp___0 ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  npfx_left = 0UL;
  while (1) {
    tmp___0 = avl_root_empty(& vcpp->vcp_avlroot);
    if (tmp___0) {
      break;
    }
    vp = (vg_prefix_t *)((unsigned char *)vcpp->vcp_avlroot.ar_root - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item));
    vg_prefix_delete(& vcpp->vcp_avlroot, vp);
    npfx_left ++;
  }
  if (! (npfx_left == vcpp->base.vc_npatterns)) {
    __assert_fail("npfx_left == vcpp->base.vc_npatterns", "pattern.c", 1233U, "vg_prefix_context_clear_all_patterns");
  }
  vcpp->base.vc_npatterns = 0UL;
  vcpp->base.vc_npatterns_start = 0UL;
  vcpp->base.vc_found = 0ULL;
  BN_clear(& vcpp->vcp_difficulty);
  return;
}
}
static void vg_prefix_context_free(vg_context_t *vcp ) 
{ 
  vg_prefix_context_t *vcpp ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  vg_prefix_context_clear_all_patterns(vcp);
  BN_clear_free(& vcpp->vcp_difficulty);
  free((void *)vcpp);
  return;
}
}
static void vg_prefix_context_next_difficulty(vg_prefix_context_t *vcpp , BIGNUM *bntmp ,
                                              BIGNUM *bntmp2 , BN_CTX *bnctx ) 
{ 
  char *dbuf ;

  {
  BN_clear(bntmp);
  BN_set_bit(bntmp, 192);
  BN_div(bntmp2, (BIGNUM *)((void *)0), (BIGNUM const   *)bntmp, (BIGNUM const   *)(& vcpp->vcp_difficulty),
         bnctx);
  dbuf = BN_bn2dec((BIGNUM const   *)bntmp2);
  if (vcpp->base.vc_verbose > 0) {
    if (vcpp->base.vc_npatterns > 1UL) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Next match difficulty: %s (%ld prefixes)\n",
              dbuf, vcpp->base.vc_npatterns);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Difficulty: %s\n",
              dbuf);
    }
  }
  vcpp->base.vc_chance = atof((char const   *)dbuf);
  CRYPTO_free((void *)dbuf);
  return;
}
}
static int vg_prefix_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                                          int npatterns ) 
{ 
  vg_prefix_context_t *vcpp ;
  prefix_case_iter_t caseiter ;
  vg_prefix_t *vp ;
  vg_prefix_t *vp2 ;
  BN_CTX *bnctx ;
  BIGNUM bntmp ;
  BIGNUM bntmp2 ;
  BIGNUM bntmp3 ;
  BIGNUM *ranges[4] ;
  int ret ;
  int i ;
  int impossible ;
  int case_impossible ;
  unsigned long npfx ;
  char *dbuf ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *ats ;
  char const   *bw ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  ret = 0;
  impossible = 0;
  bnctx = BN_CTX_new();
  BN_init(& bntmp);
  BN_init(& bntmp2);
  BN_init(& bntmp3);
  npfx = 0UL;
  i = 0;
  while (i < npatterns) {
    if (! vcpp->vcp_caseinsensitive) {
      vp = (vg_prefix_t *)((void *)0);
      ret = get_prefix_ranges(vcpp->base.vc_addrtype, *(patterns + i), ranges, bnctx);
      if (! ret) {
        vp = vg_prefix_add_ranges(& vcpp->vcp_avlroot, *(patterns + i), ranges, (vg_prefix_t *)((void *)0));
      }
    } else {
      tmp___0 = prefix_case_iter_init(& caseiter, *(patterns + i));
      if (! tmp___0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' is too long\n",
                *(patterns + i));
        goto __Cont;
      }
      if ((int )caseiter.ci_nbits > 16) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Prefix \'%s\' has 2^%d case-varied derivatives\n",
                *(patterns + i), (int )caseiter.ci_nbits);
      }
      case_impossible = 0;
      vp = (vg_prefix_t *)((void *)0);
      while (1) {
        ret = get_prefix_ranges(vcpp->base.vc_addrtype, (char const   *)(caseiter.ci_prefix),
                                ranges, bnctx);
        if (ret == -2) {
          case_impossible ++;
          ret = 0;
          goto __Cont___0;
        }
        if (ret) {
          break;
        }
        vp2 = vg_prefix_add_ranges(& vcpp->vcp_avlroot, *(patterns + i), ranges, vp);
        if (! vp2) {
          ret = -1;
          break;
        }
        if (! vp) {
          vp = vp2;
        }
        __Cont___0: /* CIL Label */ 
        tmp___1 = prefix_case_iter_next(& caseiter);
        if (! tmp___1) {
          break;
        }
      }
      if (! vp) {
        if (case_impossible) {
          ret = -2;
        }
      }
      if (ret) {
        if (vp) {
          vg_prefix_delete(& vcpp->vcp_avlroot, vp);
          vp = (vg_prefix_t *)((void *)0);
        }
      }
    }
    if (ret == -2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' not possible\n",
              *(patterns + i));
      impossible ++;
    }
    if (! vp) {
      goto __Cont;
    }
    npfx ++;
    vg_prefix_range_sum(vp, & bntmp, & bntmp2);
    BN_add(& bntmp2, (BIGNUM const   *)(& vcpp->vcp_difficulty), (BIGNUM const   *)(& bntmp));
    BN_copy(& vcpp->vcp_difficulty, (BIGNUM const   *)(& bntmp2));
    if (vcp->vc_verbose > 1) {
      BN_clear(& bntmp2);
      BN_set_bit(& bntmp2, 192);
      BN_div(& bntmp3, (BIGNUM *)((void *)0), (BIGNUM const   *)(& bntmp2), (BIGNUM const   *)(& bntmp),
             bnctx);
      dbuf = BN_bn2dec((BIGNUM const   *)(& bntmp3));
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix difficulty: %20s %s\n",
              dbuf, *(patterns + i));
      CRYPTO_free((void *)dbuf);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  vcpp->base.vc_npatterns += npfx;
  vcpp->base.vc_npatterns_start += npfx;
  if (! npfx) {
    if (impossible) {
      ats = "bitcoin";
      bw = "\"1\"";
      switch (vcpp->base.vc_addrtype) {
      case 5: 
      ats = "bitcoin script";
      bw = "\"3\"";
      break;
      case 111: 
      ats = "testnet";
      bw = "\"m\" or \"n\"";
      break;
      case 52: 
      ats = "namecoin";
      bw = "\"M\" or \"N\"";
      break;
      default: 
      break;
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Hint: valid %s addresses begin with %s\n",
              ats, bw);
    }
  }
  if (npfx) {
    vg_prefix_context_next_difficulty(vcpp, & bntmp, & bntmp2, bnctx);
  }
  ret = npfx != 0UL;
  BN_clear_free(& bntmp);
  BN_clear_free(& bntmp2);
  BN_clear_free(& bntmp3);
  BN_CTX_free(bnctx);
  return (ret);
}
}
double vg_prefix_get_difficulty(int addrtype , char const   *pattern ) 
{ 
  BN_CTX *bnctx ;
  BIGNUM result ;
  BIGNUM bntmp ;
  BIGNUM *ranges[4] ;
  char *dbuf ;
  int ret ;
  double diffret ;

  {
  diffret = 0.0;
  bnctx = BN_CTX_new();
  BN_init(& result);
  BN_init(& bntmp);
  ret = get_prefix_ranges(addrtype, pattern, ranges, bnctx);
  if (ret == 0) {
    BN_sub(& bntmp, (BIGNUM const   *)ranges[1], (BIGNUM const   *)ranges[0]);
    BN_add(& result, (BIGNUM const   *)(& result), (BIGNUM const   *)(& bntmp));
    if (ranges[2]) {
      BN_sub(& bntmp, (BIGNUM const   *)ranges[3], (BIGNUM const   *)ranges[2]);
      BN_add(& result, (BIGNUM const   *)(& result), (BIGNUM const   *)(& bntmp));
    }
    free_ranges(ranges);
    BN_clear(& bntmp);
    BN_set_bit(& bntmp, 192);
    BN_div(& result, (BIGNUM *)((void *)0), (BIGNUM const   *)(& bntmp), (BIGNUM const   *)(& result),
           bnctx);
    dbuf = BN_bn2dec((BIGNUM const   *)(& result));
    diffret = strtod((char const   * __restrict  )dbuf, (char ** __restrict  )((void *)0));
    CRYPTO_free((void *)dbuf);
  }
  BN_clear_free(& result);
  BN_clear_free(& bntmp);
  BN_CTX_free(bnctx);
  return (diffret);
}
}
static int vg_prefix_test(vg_exec_context_t *vxcp ) 
{ 
  vg_prefix_context_t *vcpp ;
  vg_prefix_t *vp ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  vcpp = (vg_prefix_context_t *)vxcp->vxc_vc;
  res = 0;
  BN_bin2bn((unsigned char const   *)(vxcp->vxc_binres), 25, & vxcp->vxc_bntarg);
  research: 
  vp = vg_prefix_avl_search(& vcpp->vcp_avlroot, & vxcp->vxc_bntarg);
  if (vp) {
    tmp___0 = vg_exec_context_upgrade_lock(vxcp);
    if (tmp___0) {
      goto research;
    }
    vg_exec_context_consolidate_key(vxcp);
    (*(vcpp->base.vc_output_match))(& vcpp->base, vxcp->vxc_key, vp->vp_pattern);
    (vcpp->base.vc_found) ++;
    if (vcpp->base.vc_only_one) {
      return (2);
    }
    if (vcpp->base.vc_remove_on_match) {
      vg_prefix_range_sum(vp, & vxcp->vxc_bntarg, & vxcp->vxc_bntmp);
      BN_sub(& vxcp->vxc_bntmp, (BIGNUM const   *)(& vcpp->vcp_difficulty), (BIGNUM const   *)(& vxcp->vxc_bntarg));
      BN_copy(& vcpp->vcp_difficulty, (BIGNUM const   *)(& vxcp->vxc_bntmp));
      vg_prefix_delete(& vcpp->vcp_avlroot, vp);
      (vcpp->base.vc_npatterns) --;
      tmp___1 = avl_root_empty(& vcpp->vcp_avlroot);
      if (! tmp___1) {
        vg_prefix_context_next_difficulty(vcpp, & vxcp->vxc_bntmp, & vxcp->vxc_bntmp2,
                                          vxcp->vxc_bnctx);
      }
      (vcpp->base.vc_pattern_generation) ++;
    }
    res = 1;
  }
  tmp___2 = avl_root_empty(& vcpp->vcp_avlroot);
  if (tmp___2) {
    return (2);
  }
  return (res);
}
}
static int vg_prefix_hash160_sort(vg_context_t *vcp , void *buf ) 
{ 
  vg_prefix_context_t *vcpp ;
  vg_prefix_t *vp ;
  unsigned char *cbuf ;
  unsigned char bnbuf[25] ;
  int nbytes ;
  int ncopy ;
  int nskip ;
  int npfx ;
  int tmp___0 ;
  int tmp___1 ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  cbuf = (unsigned char *)buf;
  npfx = 0;
  vp = vg_prefix_first(& vcpp->vcp_avlroot);
  while ((unsigned long )vp != (unsigned long )((void *)0)) {
    npfx ++;
    if (! buf) {
      goto __Cont;
    }
    nbytes = BN_bn2bin((BIGNUM const   *)vp->vp_low, bnbuf);
    if (nbytes >= 24) {
      ncopy = 20;
    } else {
      if (nbytes > 4) {
        tmp___0 = nbytes - 4;
      } else {
        tmp___0 = 0;
      }
      ncopy = tmp___0;
    }
    if (nbytes >= 24) {
      nskip = nbytes - 24;
    } else {
      nskip = 0;
    }
    if (ncopy < 20) {
      memset((void *)cbuf, 0, (size_t )(20 - ncopy));
    }
    memcpy((void * __restrict  )(cbuf + (20 - ncopy)), (void const   * __restrict  )(bnbuf + nskip),
           (size_t )ncopy);
    cbuf += 20;
    nbytes = BN_bn2bin((BIGNUM const   *)vp->vp_high, bnbuf);
    if (nbytes >= 24) {
      ncopy = 20;
    } else {
      if (nbytes > 4) {
        tmp___1 = nbytes - 4;
      } else {
        tmp___1 = 0;
      }
      ncopy = tmp___1;
    }
    if (nbytes >= 24) {
      nskip = nbytes - 24;
    } else {
      nskip = 0;
    }
    if (ncopy < 20) {
      memset((void *)cbuf, 0, (size_t )(20 - ncopy));
    }
    memcpy((void * __restrict  )(cbuf + (20 - ncopy)), (void const   * __restrict  )(bnbuf + nskip),
           (size_t )ncopy);
    cbuf += 20;
    __Cont: /* CIL Label */ 
    vp = vg_prefix_next(vp);
  }
  return (npfx);
}
}
vg_context_t *vg_prefix_context_new(int addrtype , int privtype , int caseinsensitive ) 
{ 
  vg_prefix_context_t *vcpp ;
  void *tmp___0 ;

  {
  tmp___0 = malloc(sizeof(*vcpp));
  vcpp = (vg_prefix_context_t *)tmp___0;
  if (vcpp) {
    memset((void *)vcpp, 0, sizeof(*vcpp));
    vcpp->base.vc_addrtype = addrtype;
    vcpp->base.vc_privtype = privtype;
    vcpp->base.vc_npatterns = 0UL;
    vcpp->base.vc_npatterns_start = 0UL;
    vcpp->base.vc_found = 0ULL;
    vcpp->base.vc_chance = 0.0;
    vcpp->base.vc_free = & vg_prefix_context_free;
    vcpp->base.vc_add_patterns = & vg_prefix_context_add_patterns;
    vcpp->base.vc_clear_all_patterns = & vg_prefix_context_clear_all_patterns;
    vcpp->base.vc_test = & vg_prefix_test;
    vcpp->base.vc_hash160_sort = & vg_prefix_hash160_sort;
    avl_root_init(& vcpp->vcp_avlroot);
    BN_init(& vcpp->vcp_difficulty);
    vcpp->vcp_caseinsensitive = caseinsensitive;
  }
  return (& vcpp->base);
}
}
static int vg_regex_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                                         int npatterns ) 
{ 
  vg_regex_context_t *vcrp ;
  char const   *pcre_errptr ;
  int pcre_erroffset ;
  unsigned long i ;
  unsigned long nres ;
  unsigned long count ;
  void **mem ;
  void *tmp___0 ;
  char const   *spaces ;

  {
  vcrp = (vg_regex_context_t *)vcp;
  if (! npatterns) {
    return (1);
  }
  if ((unsigned long )npatterns > vcrp->vcr_nalloc - vcrp->base.vc_npatterns) {
    count = (unsigned long )npatterns + vcrp->base.vc_npatterns;
    if (count < 2UL * vcrp->vcr_nalloc) {
      count = 2UL * vcrp->vcr_nalloc;
    }
    if (count < 16UL) {
      count = 16UL;
    }
    tmp___0 = malloc((3UL * count) * sizeof(void *));
    mem = (void **)tmp___0;
    if (! mem) {
      return (0);
    }
    i = 0UL;
    while (i < vcrp->base.vc_npatterns) {
      *(mem + i) = (void *)*(vcrp->vcr_regex + i);
      *(mem + (count + i)) = (void *)*(vcrp->vcr_regex_extra + i);
      *(mem + (2UL * count + i)) = (void *)*(vcrp->vcr_regex_pat + i);
      i ++;
    }
    if (vcrp->vcr_nalloc) {
      free((void *)vcrp->vcr_regex);
    }
    vcrp->vcr_regex = (pcre **)mem;
    vcrp->vcr_regex_extra = (pcre_extra **)(mem + count);
    vcrp->vcr_regex_pat = (char const   **)(mem + 2UL * count);
    vcrp->vcr_nalloc = count;
  }
  nres = vcrp->base.vc_npatterns;
  i = 0UL;
  while (i < (unsigned long )npatterns) {
    *(vcrp->vcr_regex + nres) = pcre_compile(*(patterns + i), 0, & pcre_errptr, & pcre_erroffset,
                                             (unsigned char const   *)((void *)0));
    if (! *(vcrp->vcr_regex + nres)) {
      spaces = "                ";
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", *(patterns + i));
      while (pcre_erroffset > 16) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", spaces);
        pcre_erroffset -= 16;
      }
      if (pcre_erroffset > 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", spaces + (16 - pcre_erroffset));
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"^\nRegex error: %s\n",
              pcre_errptr);
      goto __Cont;
    }
    *(vcrp->vcr_regex_extra + nres) = pcre_study((pcre const   *)*(vcrp->vcr_regex + nres),
                                                 0, & pcre_errptr);
    if (pcre_errptr) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Regex error: %s\n",
              pcre_errptr);
      (*pcre_free)((void *)*(vcrp->vcr_regex + nres));
      goto __Cont;
    }
    *(vcrp->vcr_regex_pat + nres) = *(patterns + i);
    nres ++;
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (nres == vcrp->base.vc_npatterns) {
    return (0);
  }
  vcrp->base.vc_npatterns_start += nres - vcrp->base.vc_npatterns;
  vcrp->base.vc_npatterns = nres;
  return (1);
}
}
static void vg_regex_context_clear_all_patterns(vg_context_t *vcp ) 
{ 
  vg_regex_context_t *vcrp ;
  int i ;

  {
  vcrp = (vg_regex_context_t *)vcp;
  i = 0;
  while ((unsigned long )i < vcrp->base.vc_npatterns) {
    if (*(vcrp->vcr_regex_extra + i)) {
      (*pcre_free)((void *)*(vcrp->vcr_regex_extra + i));
    }
    (*pcre_free)((void *)*(vcrp->vcr_regex + i));
    i ++;
  }
  vcrp->base.vc_npatterns = 0UL;
  vcrp->base.vc_npatterns_start = 0UL;
  vcrp->base.vc_found = 0ULL;
  return;
}
}
static void vg_regex_context_free(vg_context_t *vcp ) 
{ 
  vg_regex_context_t *vcrp ;

  {
  vcrp = (vg_regex_context_t *)vcp;
  vg_regex_context_clear_all_patterns(vcp);
  if (vcrp->vcr_nalloc) {
    free((void *)vcrp->vcr_regex);
  }
  free((void *)vcrp);
  return;
}
}
static int vg_regex_test(vg_exec_context_t *vxcp ) 
{ 
  vg_regex_context_t *vcrp ;
  unsigned char hash1[32] ;
  unsigned char hash2[32] ;
  int i ;
  int zpfx ;
  int p ;
  int d ;
  int nres ;
  int re_vec[9] ;
  char b58[40] ;
  BIGNUM bnrem ;
  BIGNUM *bn ;
  BIGNUM *bndiv ;
  BIGNUM *bnptmp ;
  int res ;
  pcre *re ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  vcrp = (vg_regex_context_t *)vxcp->vxc_vc;
  res = 0;
  BN_init(& bnrem);
  SHA256((unsigned char const   *)(vxcp->vxc_binres), (size_t )21, hash1);
  SHA256((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  memcpy((void * __restrict  )(& vxcp->vxc_binres[21]), (void const   * __restrict  )(hash2),
         (size_t )4);
  bn = & vxcp->vxc_bntmp;
  bndiv = & vxcp->vxc_bntmp2;
  BN_bin2bn((unsigned char const   *)(vxcp->vxc_binres), 25, bn);
  zpfx = 0;
  while (1) {
    if (zpfx < 25) {
      if (! ((int )vxcp->vxc_binres[zpfx] == 0)) {
        break;
      }
    } else {
      break;
    }
    zpfx ++;
  }
  p = (int )(sizeof(b58) - 1UL);
  b58[p] = (char )'\000';
  while (! (bn->top == 0)) {
    BN_div(bndiv, & bnrem, (BIGNUM const   *)bn, (BIGNUM const   *)(& vxcp->vxc_bnbase),
           vxcp->vxc_bnctx);
    bnptmp = bn;
    bn = bndiv;
    bndiv = bnptmp;
    tmp___0 = BN_get_word((BIGNUM const   *)(& bnrem));
    d = (int )tmp___0;
    p --;
    b58[p] = (char )*(vg_b58_alphabet + d);
  }
  while (1) {
    tmp___1 = zpfx;
    zpfx --;
    if (! tmp___1) {
      break;
    }
    p --;
    b58[p] = (char )*(vg_b58_alphabet + 0);
  }
  restart_loop: 
  nres = (int )vcrp->base.vc_npatterns;
  if (! nres) {
    res = 2;
    goto out;
  }
  i = 0;
  while (i < nres) {
    d = pcre_exec((pcre const   *)*(vcrp->vcr_regex + i), (pcre_extra const   *)*(vcrp->vcr_regex_extra + i),
                  (char const   *)(& b58[p]), (int )((sizeof(b58) - 1UL) - (unsigned long )p),
                  0, 0, re_vec, (int )(sizeof(re_vec) / sizeof(re_vec[0])));
    if (d <= 0) {
      if (d != -1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"PCRE error: %d\n",
                d);
        res = 2;
        goto out;
      }
      goto __Cont;
    }
    re = *(vcrp->vcr_regex + i);
    tmp___2 = vg_exec_context_upgrade_lock(vxcp);
    if (tmp___2) {
      if ((unsigned long )i >= vcrp->base.vc_npatterns) {
        goto restart_loop;
      } else
      if ((unsigned long )*(vcrp->vcr_regex + i) != (unsigned long )re) {
        goto restart_loop;
      }
    }
    vg_exec_context_consolidate_key(vxcp);
    (*(vcrp->base.vc_output_match))(& vcrp->base, vxcp->vxc_key, *(vcrp->vcr_regex_pat + i));
    (vcrp->base.vc_found) ++;
    if (vcrp->base.vc_only_one) {
      res = 2;
      goto out;
    }
    if (vcrp->base.vc_remove_on_match) {
      (*pcre_free)((void *)*(vcrp->vcr_regex + i));
      if (*(vcrp->vcr_regex_extra + i)) {
        (*pcre_free)((void *)*(vcrp->vcr_regex_extra + i));
      }
      nres --;
      vcrp->base.vc_npatterns = (unsigned long )nres;
      if (! nres) {
        res = 2;
        goto out;
      }
      *(vcrp->vcr_regex + i) = *(vcrp->vcr_regex + nres);
      *(vcrp->vcr_regex_extra + i) = *(vcrp->vcr_regex_extra + nres);
      *(vcrp->vcr_regex_pat + i) = *(vcrp->vcr_regex_pat + nres);
      vcrp->base.vc_npatterns = (unsigned long )nres;
      (vcrp->base.vc_pattern_generation) ++;
    }
    res = 1;
    __Cont: /* CIL Label */ 
    i ++;
  }
  out: 
  BN_clear_free(& bnrem);
  return (res);
}
}
vg_context_t *vg_regex_context_new(int addrtype , int privtype ) 
{ 
  vg_regex_context_t *vcrp ;
  void *tmp___0 ;

  {
  tmp___0 = malloc(sizeof(*vcrp));
  vcrp = (vg_regex_context_t *)tmp___0;
  if (vcrp) {
    memset((void *)vcrp, 0, sizeof(*vcrp));
    vcrp->base.vc_addrtype = addrtype;
    vcrp->base.vc_privtype = privtype;
    vcrp->base.vc_npatterns = 0UL;
    vcrp->base.vc_npatterns_start = 0UL;
    vcrp->base.vc_found = 0ULL;
    vcrp->base.vc_chance = 0.0;
    vcrp->base.vc_free = & vg_regex_context_free;
    vcrp->base.vc_add_patterns = & vg_regex_context_add_patterns;
    vcrp->base.vc_clear_all_patterns = & vg_regex_context_clear_all_patterns;
    vcrp->base.vc_test = & vg_regex_test;
    vcrp->base.vc_hash160_sort = (int (*)(vg_context_t *vcp , void *buf ))((void *)0);
    vcrp->vcr_regex = (pcre **)((void *)0);
    vcrp->vcr_nalloc = 0UL;
  }
  return (& vcrp->base);
}
}
#pragma merger("0","/tmp/cil-CUvp5pCS.i","-ggdb,-O3,-Wall")
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
extern void OPENSSL_cleanse(void *ptr , size_t len ) ;
extern int BN_num_bits(BIGNUM const   *a ) ;
extern BIO *BIO_new(BIO_METHOD *type ) ;
extern int BIO_free(BIO *a ) ;
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
extern BIO_METHOD *BIO_s_mem(void) ;
extern BIO *BIO_new_mem_buf(void *buf , int len ) ;
extern int EVP_read_pw_string(char *buf , int length , char const   *prompt , int verify ) ;
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
extern int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl ,
                            unsigned char const   *in , int inl ) ;
extern int EVP_CipherFinal(EVP_CIPHER_CTX *ctx , unsigned char *outm , int *outl ) ;
extern EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void) ;
extern void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a ) ;
extern int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c , int pad ) ;
extern EVP_MD const   *EVP_sha256(void) ;
extern EVP_CIPHER const   *EVP_aes_256_cbc(void) ;
extern int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey , struct ec_key_st *key ) ;
extern struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey ) ;
extern EVP_PKEY *EVP_PKEY_new(void) ;
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
extern int PKCS5_PBKDF2_HMAC(char const   *pass , int passlen , unsigned char const   *salt ,
                             int saltlen , int iter , EVP_MD const   *digest , int keylen ,
                             unsigned char *out ) ;
extern unsigned char *HMAC(EVP_MD const   *evp_md , void const   *key , int key_len ,
                           unsigned char const   *d , size_t n , unsigned char *md ,
                           unsigned int *md_len ) ;
extern int RAND_bytes(unsigned char *buf , int num ) ;
extern int EC_GROUP_cmp(EC_GROUP const   *a , EC_GROUP const   *b , BN_CTX *ctx ) ;
extern EC_KEY *EC_KEY_copy(EC_KEY *dst , EC_KEY const   *src ) ;
extern EC_KEY *EC_KEY_dup(EC_KEY const   *src ) ;
extern int EC_KEY_set_private_key(EC_KEY *key , BIGNUM const   *prv ) ;
extern int EC_KEY_set_public_key(EC_KEY *key , EC_POINT const   *pub ) ;
extern void X509_SIG_free(X509_SIG *a ) ;
extern void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a ) ;
extern EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8 ) ;
extern PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey ) ;
extern X509_SIG *PEM_read_bio_PKCS8(BIO *bp , X509_SIG **x , pem_password_cb *cb ,
                                    void *u ) ;
extern int PEM_write_bio_PKCS8(BIO *bp , X509_SIG *x ) ;
extern PKCS8_PRIV_KEY_INFO *PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *bp , PKCS8_PRIV_KEY_INFO **x ,
                                                             pem_password_cb *cb ,
                                                             void *u ) ;
extern int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *bp , PKCS8_PRIV_KEY_INFO *x ) ;
extern PKCS8_PRIV_KEY_INFO *PKCS8_decrypt(X509_SIG *p8 , char const   *pass , int passlen ) ;
extern X509_SIG *PKCS8_encrypt(int pbe_nid , EVP_CIPHER const   *cipher , char const   *pass ,
                               int passlen , unsigned char *salt , int saltlen , int iter ,
                               PKCS8_PRIV_KEY_INFO *p8 ) ;
void vg_b58_encode_check(void *buf , size_t len , char *result ) ;
int vg_decode_privkey(char const   *b58encoded , EC_KEY *pkey , int *addrtype ) ;
int vg_protect_decode_privkey(EC_KEY *pkey , int *keytype , char const   *encoded ,
                              char const   *pass ) ;
int vg_pkcs8_encode_privkey(char *out , int outlen , EC_KEY const   *pkey , char const   *pass ) ;
int vg_pkcs8_decode_privkey(EC_KEY *pkey , char const   *pem_in , char const   *pass ) ;
int vg_decode_privkey_any(EC_KEY *pkey , int *addrtype , char const   *input , char const   *pass ) ;
int vg_read_password(char *buf , size_t size ) ;
int vg_check_password_complexity(char const   *pass , int verbose ) ;
int vg_read_file(FILE *fp , char ***result , int *rescount ) ;
char const   *vg_b58_alphabet  =    "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
signed char const   vg_b58_reverse_map[256]  = 
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )9,      (signed char const   )10,      (signed char const   )11, 
        (signed char const   )12,      (signed char const   )13,      (signed char const   )14,      (signed char const   )15, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )-1, 
        (signed char const   )22,      (signed char const   )23,      (signed char const   )24,      (signed char const   )25, 
        (signed char const   )26,      (signed char const   )27,      (signed char const   )28,      (signed char const   )29, 
        (signed char const   )30,      (signed char const   )31,      (signed char const   )32,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )33,      (signed char const   )34,      (signed char const   )35, 
        (signed char const   )36,      (signed char const   )37,      (signed char const   )38,      (signed char const   )39, 
        (signed char const   )40,      (signed char const   )41,      (signed char const   )42,      (signed char const   )43, 
        (signed char const   )-1,      (signed char const   )44,      (signed char const   )45,      (signed char const   )46, 
        (signed char const   )47,      (signed char const   )48,      (signed char const   )49,      (signed char const   )50, 
        (signed char const   )51,      (signed char const   )52,      (signed char const   )53,      (signed char const   )54, 
        (signed char const   )55,      (signed char const   )56,      (signed char const   )57,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
void fdumphex(FILE *fp , unsigned char const   *src , size_t len ) 
{ 
  size_t i ;

  {
  i = (size_t )0;
  while (i < len) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%02x", (int const   )*(src + i));
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void fdumpbn(FILE *fp , BIGNUM const   *bn ) 
{ 
  char *buf ;
  char const   *tmp___0 ;

  {
  buf = BN_bn2hex(bn);
  if (buf) {
    tmp___0 = (char const   *)buf;
  } else {
    tmp___0 = "0";
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", tmp___0);
  if (buf) {
    CRYPTO_free((void *)buf);
  }
  return;
}
}
void dumphex(unsigned char const   *src , size_t len ) 
{ 


  {
  fdumphex(stdout, src, len);
  return;
}
}
void dumpbn(BIGNUM const   *bn ) 
{ 


  {
  fdumpbn(stdout, bn);
  return;
}
}
void vg_b58_encode_check(void *buf , size_t len , char *result ) 
{ 
  unsigned char hash1[32] ;
  unsigned char hash2[32] ;
  int d ;
  int p ;
  BN_CTX *bnctx ;
  BIGNUM *bn ;
  BIGNUM *bndiv ;
  BIGNUM *bntmp ;
  BIGNUM bna ;
  BIGNUM bnb ;
  BIGNUM bnbase ;
  BIGNUM bnrem ;
  unsigned char *binres ;
  int brlen ;
  int zpfx ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  bnctx = BN_CTX_new();
  BN_init(& bna);
  BN_init(& bnb);
  BN_init(& bnbase);
  BN_init(& bnrem);
  BN_set_word(& bnbase, 58UL);
  bn = & bna;
  bndiv = & bnb;
  brlen = (int )(2UL * len + 4UL);
  tmp___0 = malloc((size_t )brlen);
  binres = (unsigned char *)tmp___0;
  memcpy((void * __restrict  )binres, (void const   * __restrict  )buf, len);
  SHA256((unsigned char const   *)binres, len, hash1);
  SHA256((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  memcpy((void * __restrict  )(binres + len), (void const   * __restrict  )(hash2),
         (size_t )4);
  BN_bin2bn((unsigned char const   *)binres, (int )(len + 4UL), bn);
  zpfx = 0;
  while (1) {
    if ((size_t )zpfx < len + 4UL) {
      if (! ((int )*(binres + zpfx) == 0)) {
        break;
      }
    } else {
      break;
    }
    zpfx ++;
  }
  p = brlen;
  while (! (bn->top == 0)) {
    BN_div(bndiv, & bnrem, (BIGNUM const   *)bn, (BIGNUM const   *)(& bnbase), bnctx);
    bntmp = bn;
    bn = bndiv;
    bndiv = bntmp;
    tmp___1 = BN_get_word((BIGNUM const   *)(& bnrem));
    d = (int )tmp___1;
    p --;
    *(binres + p) = (unsigned char )*(vg_b58_alphabet + d);
  }
  while (1) {
    tmp___2 = zpfx;
    zpfx --;
    if (! tmp___2) {
      break;
    }
    p --;
    *(binres + p) = (unsigned char )*(vg_b58_alphabet + 0);
  }
  memcpy((void * __restrict  )result, (void const   * __restrict  )(binres + p), (size_t )(brlen - p));
  *(result + (brlen - p)) = (char )'\000';
  free((void *)binres);
  BN_clear_free(& bna);
  BN_clear_free(& bnb);
  BN_clear_free(& bnbase);
  BN_clear_free(& bnrem);
  BN_CTX_free(bnctx);
  return;
}
}
int vg_b58_decode_check(char const   *input , void *buf , size_t len ) 
{ 
  int i ;
  int l ;
  int c ;
  unsigned char *xbuf ;
  BIGNUM bn ;
  BIGNUM bnw ;
  BIGNUM bnbase ;
  BN_CTX *bnctx ;
  unsigned char hash1[32] ;
  unsigned char hash2[32] ;
  int zpfx ;
  int res ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  xbuf = (unsigned char *)((void *)0);
  res = 0;
  BN_init(& bn);
  BN_init(& bnw);
  BN_init(& bnbase);
  BN_set_word(& bnbase, 58UL);
  bnctx = BN_CTX_new();
  tmp___0 = strlen(input);
  l = (int )tmp___0;
  i = 0;
  while (i < l) {
    if ((int const   )*(input + i) == 13) {
      goto __Cont;
    } else
    if ((int const   )*(input + i) == 10) {
      goto __Cont;
    } else
    if ((int const   )*(input + i) == 32) {
      goto __Cont;
    } else
    if ((int const   )*(input + i) == 9) {
      goto __Cont;
    }
    c = (int )vg_b58_reverse_map[(int )*(input + i)];
    if (c < 0) {
      goto out;
    }
    BN_clear(& bnw);
    BN_set_word(& bnw, (unsigned long )c);
    BN_mul(& bn, (BIGNUM const   *)(& bn), (BIGNUM const   *)(& bnbase), bnctx);
    BN_add(& bn, (BIGNUM const   *)(& bn), (BIGNUM const   *)(& bnw));
    __Cont: /* CIL Label */ 
    i ++;
  }
  i = 0;
  zpfx = 0;
  while (*(input + i)) {
    if ((int const   )*(input + i) == 13) {
      goto __Cont___0;
    } else
    if ((int const   )*(input + i) == 10) {
      goto __Cont___0;
    } else
    if ((int const   )*(input + i) == 32) {
      goto __Cont___0;
    } else
    if ((int const   )*(input + i) == 9) {
      goto __Cont___0;
    }
    if ((int const   )*(input + i) != (int const   )*(vg_b58_alphabet + 0)) {
      break;
    }
    zpfx ++;
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  tmp___1 = BN_num_bits((BIGNUM const   *)(& bn));
  c = (tmp___1 + 7) / 8;
  l = zpfx + c;
  if (l < 5) {
    goto out;
  }
  tmp___2 = malloc((size_t )l);
  xbuf = (unsigned char *)tmp___2;
  if (! xbuf) {
    goto out;
  }
  if (zpfx) {
    memset((void *)xbuf, 0, (size_t )zpfx);
  }
  if (c) {
    BN_bn2bin((BIGNUM const   *)(& bn), xbuf + zpfx);
  }
  l -= 4;
  SHA256((unsigned char const   *)xbuf, (size_t )l, hash1);
  SHA256((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  tmp___3 = memcmp((void const   *)(hash2), (void const   *)(xbuf + l), (size_t )4);
  if (tmp___3) {
    goto out;
  }
  if (len) {
    if (len > (size_t )l) {
      len = (size_t )l;
    }
    memcpy((void * __restrict  )buf, (void const   * __restrict  )xbuf, len);
  }
  res = l;
  out: 
  if (xbuf) {
    free((void *)xbuf);
  }
  BN_clear_free(& bn);
  BN_clear_free(& bnw);
  BN_clear_free(& bnbase);
  BN_CTX_free(bnctx);
  return (res);
}
}
void vg_encode_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup , int addrtype ,
                       char *result ) 
{ 
  unsigned char eckey_buf[128] ;
  unsigned char *pend ;
  unsigned char binres[21] ;
  unsigned int tmp___0 ;
  unsigned char hash1[32] ;

  {
  binres[0] = (unsigned char)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 21U)) {
    binres[tmp___0] = (unsigned char)0;
    tmp___0 ++;
  }
  pend = eckey_buf;
  EC_POINT_point2oct(pgroup, ppoint, (point_conversion_form_t )4, eckey_buf, sizeof(eckey_buf),
                     (BN_CTX *)((void *)0));
  pend = eckey_buf + 65;
  binres[0] = (unsigned char )addrtype;
  SHA256((unsigned char const   *)(eckey_buf), (size_t )(pend - eckey_buf), hash1);
  RIPEMD160((unsigned char const   *)(hash1), sizeof(hash1), & binres[1]);
  vg_b58_encode_check((void *)(binres), sizeof(binres), result);
  return;
}
}
void vg_encode_script_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup ,
                              int addrtype , char *result ) 
{ 
  unsigned char script_buf[69] ;
  unsigned char *eckey_buf ;
  unsigned char binres[21] ;
  unsigned int tmp___0 ;
  unsigned char hash1[32] ;

  {
  eckey_buf = script_buf + 2;
  binres[0] = (unsigned char)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 21U)) {
    binres[tmp___0] = (unsigned char)0;
    tmp___0 ++;
  }
  script_buf[0] = (unsigned char)81;
  script_buf[1] = (unsigned char)65;
  script_buf[67] = (unsigned char)81;
  script_buf[68] = (unsigned char)174;
  EC_POINT_point2oct(pgroup, ppoint, (point_conversion_form_t )4, eckey_buf, (size_t )65,
                     (BN_CTX *)((void *)0));
  binres[0] = (unsigned char )addrtype;
  SHA256((unsigned char const   *)(script_buf), (size_t )69, hash1);
  RIPEMD160((unsigned char const   *)(hash1), sizeof(hash1), & binres[1]);
  vg_b58_encode_check((void *)(binres), sizeof(binres), result);
  return;
}
}
void vg_encode_privkey(EC_KEY const   *pkey , int addrtype , char *result ) 
{ 
  unsigned char eckey_buf[128] ;
  BIGNUM const   *bn ;
  int nbytes ;
  int tmp___0 ;

  {
  bn = EC_KEY_get0_private_key(pkey);
  eckey_buf[0] = (unsigned char )addrtype;
  tmp___0 = BN_num_bits(bn);
  nbytes = (tmp___0 + 7) / 8;
  if (! (nbytes <= 32)) {
    __assert_fail("nbytes <= 32", "util.c", 301U, "vg_encode_privkey");
  }
  if (nbytes < 32) {
    memset((void *)(eckey_buf + 1), 0, (size_t )(32 - nbytes));
  }
  BN_bn2bin(bn, & eckey_buf[33 - nbytes]);
  vg_b58_encode_check((void *)(eckey_buf), (size_t )33, result);
  return;
}
}
int vg_set_privkey(BIGNUM const   *bnpriv , EC_KEY *pkey ) 
{ 
  EC_GROUP const   *pgroup ;
  EC_POINT *ppnt ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___6 ;

  {
  pgroup = EC_KEY_get0_group((EC_KEY const   *)pkey);
  ppnt = EC_POINT_new(pgroup);
  if (ppnt) {
    tmp___0 = EC_KEY_set_private_key(pkey, bnpriv);
    if (tmp___0) {
      tmp___1 = EC_POINT_mul(pgroup, ppnt, bnpriv, (EC_POINT const   *)((void *)0),
                             (BIGNUM const   *)((void *)0), (BN_CTX *)((void *)0));
      if (tmp___1) {
        tmp___2 = EC_KEY_set_public_key(pkey, (EC_POINT const   *)ppnt);
        if (tmp___2) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  res = tmp___3;
  if (ppnt) {
    EC_POINT_free(ppnt);
  }
  if (! res) {
    return (0);
  }
  tmp___6 = EC_KEY_check_key((EC_KEY const   *)pkey);
  if (! tmp___6) {
    __assert_fail("EC_KEY_check_key(pkey)", "util.c", 330U, "vg_set_privkey");
  }
  return (1);
}
}
int vg_decode_privkey(char const   *b58encoded , EC_KEY *pkey , int *addrtype ) 
{ 
  BIGNUM bnpriv ;
  unsigned char ecpriv[48] ;
  int res ;

  {
  res = vg_b58_decode_check(b58encoded, (void *)(ecpriv), sizeof(ecpriv));
  if (res != 33) {
    return (0);
  }
  BN_init(& bnpriv);
  BN_bin2bn((unsigned char const   *)(ecpriv + 1), res - 1, & bnpriv);
  res = vg_set_privkey((BIGNUM const   *)(& bnpriv), pkey);
  BN_clear_free(& bnpriv);
  *addrtype = (int )ecpriv[0];
  return (1);
}
}
static vg_protkey_parameters_t const   protkey_parameters[17]  = 
  {      {0, 4096, & EVP_sha256, & EVP_aes_256_cbc}, 
        {0, 0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)}, 
        {1,
      4096, & EVP_sha256, & EVP_aes_256_cbc}};
static int vg_protect_crypt(int parameter_group , unsigned char *data_in , int data_in_len ,
                            unsigned char *data_out , char const   *pass , int enc ) 
{ 
  EVP_CIPHER_CTX *ctx ;
  unsigned char *salt ;
  unsigned char keymaterial[144] ;
  unsigned char hmac[64] ;
  int hmac_len ;
  int hmac_keylen ;
  int salt_len ;
  int plaintext_len ;
  int ciphertext_len ;
  int pkcs7_padding ;
  vg_protkey_parameters_t const   *params ;
  EVP_CIPHER const   *cipher ;
  EVP_MD const   *pbkdf_digest ;
  EVP_MD const   *hmac_digest ;
  unsigned int hlen ;
  int opos ;
  int olen ;
  int oincr ;
  int nbytes ;
  int ipos ;
  int ret ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;

  {
  ctx = (EVP_CIPHER_CTX *)((void *)0);
  hmac_len = 0;
  hmac_keylen = 0;
  plaintext_len = 32;
  pkcs7_padding = 1;
  ret = 0;
  ctx = EVP_CIPHER_CTX_new();
  if (! ctx) {
    goto out;
  }
  if (parameter_group < 0) {
    if (enc) {
      parameter_group = 0;
    } else {
      parameter_group = (int )*(data_in + 0);
    }
  } else
  if (! enc) {
    if (parameter_group != (int )*(data_in + 0)) {
      goto out;
    }
  }
  if ((unsigned long )parameter_group > sizeof(protkey_parameters) / sizeof(protkey_parameters[0])) {
    goto out;
  }
  params = & protkey_parameters[parameter_group];
  if (! params->iterations) {
    goto out;
  } else
  if (! params->pbkdf_hash_getter) {
    goto out;
  }
  pbkdf_digest = (*(params->pbkdf_hash_getter))();
  cipher = (*(params->cipher_getter))();
  if (params->mode == 0) {
    salt_len = 4;
    hmac_len = 8;
    hmac_keylen = 16;
    ciphertext_len = (((plaintext_len + (int )cipher->block_size) - 1) / (int )cipher->block_size) * (int )cipher->block_size;
    pkcs7_padding = 0;
    hmac_digest = EVP_sha256();
  } else {
    salt_len = 8;
    ciphertext_len = ((plaintext_len + (int )cipher->block_size) / (int )cipher->block_size) * (int )cipher->block_size;
    hmac_digest = (EVP_MD const   *)((void *)0);
  }
  if (! enc) {
    if (data_in_len != ((1 + ciphertext_len) + hmac_len) + salt_len) {
      goto out;
    }
  }
  if (! pass) {
    ret = plaintext_len;
    goto out;
  } else
  if (! data_out) {
    ret = plaintext_len;
    goto out;
  }
  if (! enc) {
    salt = ((data_in + 1) + ciphertext_len) + hmac_len;
  } else
  if (salt_len) {
    salt = ((data_out + 1) + ciphertext_len) + hmac_len;
    RAND_bytes(salt, salt_len);
  } else {
    salt = (unsigned char *)((void *)0);
  }
  tmp___0 = strlen(pass);
  PKCS5_PBKDF2_HMAC(pass, (int )(tmp___0 + 1UL), (unsigned char const   *)salt, salt_len,
                    (int )params->iterations, pbkdf_digest, (int )((cipher->key_len + cipher->iv_len) + (int const   )hmac_keylen),
                    keymaterial);
  tmp___1 = EVP_CipherInit(ctx, cipher, (unsigned char const   *)(keymaterial), (unsigned char const   *)(keymaterial + cipher->key_len),
                           enc);
  if (! tmp___1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not configure cipher\n");
    goto out;
  }
  if (! pkcs7_padding) {
    EVP_CIPHER_CTX_set_padding(ctx, 0);
  }
  if (! enc) {
    opos = 0;
    olen = plaintext_len;
    nbytes = ciphertext_len;
    ipos = 1;
  } else {
    *(data_out + 0) = (unsigned char )parameter_group;
    opos = 1;
    olen = (((1 + ciphertext_len) + hmac_len) + salt_len) - opos;
    nbytes = plaintext_len;
    ipos = 0;
  }
  oincr = olen;
  tmp___2 = EVP_CipherUpdate(ctx, data_out + opos, & oincr, (unsigned char const   *)(data_in + ipos),
                             nbytes);
  if (! tmp___2) {
    goto invalid_pass;
  }
  opos += oincr;
  olen -= oincr;
  oincr = olen;
  tmp___3 = EVP_CipherFinal(ctx, data_out + opos, & oincr);
  if (! tmp___3) {
    goto invalid_pass;
  }
  opos += oincr;
  if (hmac_len) {
    hlen = (unsigned int )sizeof(hmac);
    if (enc) {
      tmp___4 = data_in;
    } else {
      tmp___4 = data_out;
    }
    HMAC(hmac_digest, (void const   *)((keymaterial + cipher->key_len) + cipher->iv_len),
         hmac_keylen, (unsigned char const   *)tmp___4, (size_t )plaintext_len, hmac,
         & hlen);
    if (enc) {
      memcpy((void * __restrict  )((data_out + 1) + ciphertext_len), (void const   * __restrict  )(hmac),
             (size_t )hmac_len);
    } else {
      tmp___5 = memcmp((void const   *)(hmac), (void const   *)((data_in + 1) + ciphertext_len),
                       (size_t )hmac_len);
      if (tmp___5) {
        goto invalid_pass;
      }
    }
  }
  if (enc) {
    if (opos != 1 + ciphertext_len) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: plaintext size mismatch\n");
      goto out;
    }
    opos += hmac_len + salt_len;
  } else
  if (opos != plaintext_len) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: plaintext size mismatch\n");
    goto out;
  }
  ret = opos;
  if (0) {
    invalid_pass: 
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Invalid password\n");
  }
  out: 
  OPENSSL_cleanse((void *)(hmac), sizeof(hmac));
  OPENSSL_cleanse((void *)(keymaterial), sizeof(keymaterial));
  if (ctx) {
    EVP_CIPHER_CTX_free(ctx);
  }
  return (ret);
}
}
int vg_protect_encode_privkey(char *out , EC_KEY const   *pkey , int keytype , int parameter_group ,
                              char const   *pass ) 
{ 
  unsigned char ecpriv[64] ;
  unsigned char ecenc[128] ;
  BIGNUM const   *privkey ;
  int nbytes ;
  int restype ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  if (keytype & 1) {
    restype = 79;
  } else {
    restype = 32;
  }
  privkey = EC_KEY_get0_private_key(pkey);
  tmp___0 = BN_num_bits(privkey);
  nbytes = (tmp___0 + 7) / 8;
  if (nbytes < 32) {
    memset((void *)(ecpriv), 0, (size_t )(32 - nbytes));
  }
  BN_bn2bin(privkey, (ecpriv + 32) - nbytes);
  nbytes = vg_protect_crypt(parameter_group, ecpriv, 32, & ecenc[1], pass, 1);
  if (nbytes <= 0) {
    return (0);
  }
  OPENSSL_cleanse((void *)(ecpriv), sizeof(ecpriv));
  ecenc[0] = (unsigned char )restype;
  vg_b58_encode_check((void *)(ecenc), (size_t )(nbytes + 1), out);
  tmp___1 = strlen((char const   *)out);
  nbytes = (int )tmp___1;
  return (nbytes);
}
}
int vg_protect_decode_privkey(EC_KEY *pkey , int *keytype , char const   *encoded ,
                              char const   *pass ) 
{ 
  unsigned char ecpriv[64] ;
  unsigned char ecenc[128] ;
  BIGNUM bn ;
  int restype ;
  int res ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
  res = vg_b58_decode_check(encoded, (void *)(ecenc), sizeof(ecenc));
  if (res < 2) {
    return (0);
  } else
  if ((unsigned long )res > sizeof(ecenc)) {
    return (0);
  }
  switch ((int )ecenc[0]) {
  case 32: 
  restype = 128;
  break;
  case 79: 
  restype = 239;
  break;
  default: 
  return (0);
  }
  if (pkey) {
    tmp___0 = ecpriv;
  } else {
    tmp___0 = (unsigned char *)((void *)0);
  }
  tmp___1 = vg_protect_crypt(-1, ecenc + 1, res - 1, tmp___0, pass, 0);
  if (! tmp___1) {
    return (0);
  }
  res = 1;
  if (pkey) {
    BN_init(& bn);
    BN_bin2bn((unsigned char const   *)(ecpriv), 32, & bn);
    res = vg_set_privkey((BIGNUM const   *)(& bn), pkey);
    BN_clear_free(& bn);
    OPENSSL_cleanse((void *)(ecpriv), sizeof(ecpriv));
  }
  *keytype = restype;
  return (res);
}
}
int vg_pkcs8_encode_privkey(char *out , int outlen , EC_KEY const   *pkey , char const   *pass ) 
{ 
  EC_KEY *pkey_copy ;
  EVP_PKEY *evp_key ;
  PKCS8_PRIV_KEY_INFO *pkcs8 ;
  X509_SIG *pkcs8_enc ;
  BUF_MEM *memptr ;
  BIO *bio ;
  int res ;
  int tmp___0 ;
  BIO_METHOD *tmp___1 ;
  size_t tmp___2 ;
  EVP_CIPHER const   *tmp___3 ;

  {
  pkey_copy = (EC_KEY *)((void *)0);
  evp_key = (EVP_PKEY *)((void *)0);
  pkcs8 = (PKCS8_PRIV_KEY_INFO *)((void *)0);
  pkcs8_enc = (X509_SIG *)((void *)0);
  bio = (BIO *)((void *)0);
  res = 0;
  pkey_copy = EC_KEY_dup(pkey);
  if (! pkey_copy) {
    goto out;
  }
  evp_key = EVP_PKEY_new();
  if (! evp_key) {
    goto out;
  } else {
    tmp___0 = EVP_PKEY_set1_EC_KEY(evp_key, pkey_copy);
    if (! tmp___0) {
      goto out;
    }
  }
  pkcs8 = EVP_PKEY2PKCS8(evp_key);
  if (! pkcs8) {
    goto out;
  }
  tmp___1 = BIO_s_mem();
  bio = BIO_new(tmp___1);
  if (! bio) {
    goto out;
  }
  if (! pass) {
    res = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bio, pkcs8);
  } else {
    tmp___2 = strlen(pass);
    tmp___3 = EVP_aes_256_cbc();
    pkcs8_enc = PKCS8_encrypt(-1, tmp___3, pass, (int )tmp___2, (unsigned char *)((void *)0),
                              0, 4096, pkcs8);
    if (! pkcs8_enc) {
      goto out;
    }
    res = PEM_write_bio_PKCS8(bio, pkcs8_enc);
  }
  BIO_ctrl(bio, 115, 0L, (void *)((char *)(& memptr)));
  res = (int )memptr->length;
  if (res < outlen) {
    memcpy((void * __restrict  )out, (void const   * __restrict  )memptr->data, (size_t )res);
    *(out + res) = (char )'\000';
  } else {
    memcpy((void * __restrict  )out, (void const   * __restrict  )memptr->data, (size_t )(outlen - 1));
    *(out + (outlen - 1)) = (char )'\000';
  }
  out: 
  if (bio) {
    BIO_free(bio);
  }
  if (pkey_copy) {
    EC_KEY_free(pkey_copy);
  }
  if (evp_key) {
    EVP_PKEY_free(evp_key);
  }
  if (pkcs8) {
    PKCS8_PRIV_KEY_INFO_free(pkcs8);
  }
  if (pkcs8_enc) {
    X509_SIG_free(pkcs8_enc);
  }
  return (res);
}
}
int vg_pkcs8_decode_privkey(EC_KEY *pkey , char const   *pem_in , char const   *pass ) 
{ 
  EC_KEY *pkey_in ;
  EC_KEY *test_key ;
  EVP_PKEY *evp_key ;
  PKCS8_PRIV_KEY_INFO *pkcs8 ;
  X509_SIG *pkcs8_enc ;
  BIO *bio ;
  int res ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  EC_GROUP const   *tmp___2 ;
  EC_GROUP const   *tmp___3 ;
  int tmp___4 ;
  EC_KEY *tmp___5 ;

  {
  pkey_in = (EC_KEY *)((void *)0);
  test_key = (EC_KEY *)((void *)0);
  evp_key = (EVP_PKEY *)((void *)0);
  pkcs8 = (PKCS8_PRIV_KEY_INFO *)((void *)0);
  pkcs8_enc = (X509_SIG *)((void *)0);
  bio = (BIO *)((void *)0);
  res = 0;
  tmp___0 = strlen(pem_in);
  bio = BIO_new_mem_buf((void *)((char *)pem_in), (int )tmp___0);
  if (! bio) {
    goto out;
  }
  pkcs8_enc = PEM_read_bio_PKCS8(bio, (X509_SIG **)((void *)0), (pem_password_cb *)((void *)0),
                                 (void *)0);
  if (pkcs8_enc) {
    if (! pass) {
      return (-1);
    }
    tmp___1 = strlen(pass);
    pkcs8 = PKCS8_decrypt(pkcs8_enc, pass, (int )tmp___1);
  } else {
    BIO_ctrl(bio, 1, 0L, (void *)0);
    pkcs8 = PEM_read_bio_PKCS8_PRIV_KEY_INFO(bio, (PKCS8_PRIV_KEY_INFO **)((void *)0),
                                             (pem_password_cb *)((void *)0), (void *)0);
  }
  if (! pkcs8) {
    goto out;
  }
  evp_key = EVP_PKCS82PKEY(pkcs8);
  if (! evp_key) {
    goto out;
  }
  pkey_in = EVP_PKEY_get1_EC_KEY(evp_key);
  if (! pkey_in) {
    goto out;
  }
  test_key = EC_KEY_new_by_curve_name(714);
  if (! test_key) {
    goto out;
  } else {
    tmp___2 = EC_KEY_get0_group((EC_KEY const   *)test_key);
    tmp___3 = EC_KEY_get0_group((EC_KEY const   *)pkey_in);
    tmp___4 = EC_GROUP_cmp(tmp___3, tmp___2, (BN_CTX *)((void *)0));
    if (tmp___4) {
      goto out;
    }
  }
  tmp___5 = EC_KEY_copy(pkey, (EC_KEY const   *)pkey_in);
  if (! tmp___5) {
    goto out;
  }
  res = 1;
  out: 
  if (bio) {
    BIO_free(bio);
  }
  if (test_key) {
    EC_KEY_free(pkey_in);
  }
  if (evp_key) {
    EVP_PKEY_free(evp_key);
  }
  if (pkcs8) {
    PKCS8_PRIV_KEY_INFO_free(pkcs8);
  }
  if (pkcs8_enc) {
    X509_SIG_free(pkcs8_enc);
  }
  return (res);
}
}
int vg_decode_privkey_any(EC_KEY *pkey , int *addrtype , char const   *input , char const   *pass ) 
{ 
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp___0 = vg_decode_privkey(input, pkey, addrtype);
  if (tmp___0) {
    return (1);
  }
  tmp___2 = vg_protect_decode_privkey(pkey, addrtype, input, (char const   *)((void *)0));
  if (tmp___2) {
    if (! pass) {
      return (-1);
    }
    tmp___1 = vg_protect_decode_privkey(pkey, addrtype, input, pass);
    return (tmp___1);
  }
  res = vg_pkcs8_decode_privkey(pkey, input, pass);
  if (res > 0) {
    *addrtype = 128;
  }
  return (res);
}
}
int vg_read_password(char *buf , size_t size ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = EVP_read_pw_string(buf, (int )size, "Enter new password:", 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static unsigned char ascii_class[128]  = 
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)5,      (unsigned char)4,      (unsigned char)5,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)4,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)4,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)0};
int vg_check_password_complexity(char const   *pass , int verbose ) 
{ 
  int i ;
  int len ;
  int classes[6] ;
  unsigned int tmp___0 ;
  char const   *crackunit ;
  int char_complexity ;
  double crackops ;
  double cracktime ;
  int weak ;
  int rate ;
  int weak_threshold ;
  size_t tmp___1 ;
  char const   *tmp___2 ;

  {
  classes[0] = 0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 6U)) {
    classes[tmp___0] = 0;
    tmp___0 ++;
  }
  crackunit = "seconds";
  char_complexity = 0;
  rate = 250000000;
  weak_threshold = 31536000;
  tmp___1 = strlen(pass);
  len = (int )tmp___1;
  i = 0;
  while (i < len) {
    if ((unsigned long )*(pass + i) > sizeof(ascii_class)) {
      (classes[5]) ++;
    } else
    if (! (! ascii_class[(int )*(pass + i)])) {
      (classes[(int )ascii_class[(int )*(pass + i)] - 1]) ++;
    }
    i ++;
  }
  if (classes[0]) {
    char_complexity += 26;
  }
  if (classes[1]) {
    char_complexity += 26;
  }
  if (classes[2]) {
    char_complexity += 10;
  }
  if (classes[3]) {
    char_complexity += 14;
  }
  if (classes[4]) {
    char_complexity += 19;
  }
  if (classes[5]) {
    char_complexity += 32;
  }
  crackops = pow((double )char_complexity, (double )len);
  cracktime = (crackops * ((double )1 - (double )1 / 2.7182818284590452354)) / (double )rate;
  weak = cracktime < (double )weak_threshold;
  if (cracktime > 60.0) {
    cracktime /= 60.0;
    crackunit = "minutes";
    if (cracktime > 60.0) {
      cracktime /= 60.0;
      crackunit = "hours";
      if (cracktime > 24.0) {
        cracktime /= (double )24;
        crackunit = "days";
        if (cracktime > 365.0) {
          cracktime /= 365.0;
          crackunit = "years";
        }
      }
    }
  }
  if (weak) {
    if (verbose > 0) {
      goto _L___5;
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
  if (verbose > 1) {
    _L___5: /* CIL Label */ 
    if (cracktime < 1.0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Estimated password crack time: >1 %s\n",
              crackunit);
    } else
    if (cracktime < (double )1000000) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Estimated password crack time: %.1f %s\n",
              cracktime, crackunit);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Estimated password crack time: %e %s\n",
              cracktime, crackunit);
    }
    if (! classes[0]) {
      if (! classes[1]) {
        if (classes[2]) {
          if (! classes[3]) {
            if (! classes[4]) {
              if (! classes[5]) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Password contains only numbers\n");
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (! classes[2]) {
      if (! classes[3]) {
        if (! classes[4]) {
          if (! classes[5]) {
            if (! classes[0]) {
              goto _L;
            } else
            if (! classes[1]) {
              _L: /* CIL Label */ 
              if (classes[0]) {
                tmp___2 = "lower";
              } else {
                tmp___2 = "upper";
              }
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Password contains only %scase letters\n",
                      tmp___2);
            } else {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Password contains only letters\n");
            }
          }
        }
      }
    }
  }
  return (! weak);
}
}
int vg_read_file(FILE *fp , char ***result , int *rescount ) 
{ 
  int ret ;
  char **patterns ;
  char *buf ;
  char *obuf ;
  char *pat ;
  int blksize ;
  int nalloc ;
  int npatterns ;
  int count ;
  int pos ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;

  {
  ret = 1;
  buf = (char *)((void *)0);
  blksize = 16384;
  nalloc = 16;
  npatterns = 0;
  tmp___0 = malloc(sizeof(char *) * (unsigned long )nalloc);
  patterns = (char **)tmp___0;
  count = 0;
  pos = 0;
  while (1) {
    obuf = buf;
    tmp___1 = malloc((size_t )blksize);
    buf = (char *)tmp___1;
    if (! buf) {
      ret = 0;
      break;
    }
    if (pos < count) {
      memcpy((void * __restrict  )buf, (void const   * __restrict  )(obuf + pos),
             (size_t )(count - pos));
    }
    pos = count - pos;
    tmp___2 = fread((void * __restrict  )(buf + pos), (size_t )1, (size_t )(blksize - pos),
                    (FILE * __restrict  )fp);
    count = (int )tmp___2;
    if (count < 0) {
      tmp___3 = __errno_location();
      tmp___4 = strerror(*tmp___3);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error reading file: %s\n",
              tmp___4);
      ret = 0;
    }
    if (count <= 0) {
      break;
    }
    count += pos;
    pat = buf;
    while (pos < count) {
      if ((int )*(buf + pos) == 13) {
        goto _L;
      } else
      if ((int )*(buf + pos) == 10) {
        _L: /* CIL Label */ 
        *(buf + pos) = (char )'\000';
        if (pat) {
          if (npatterns == nalloc) {
            nalloc *= 2;
            tmp___5 = realloc((void *)patterns, sizeof(char *) * (unsigned long )nalloc);
            patterns = (char **)tmp___5;
          }
          *(patterns + npatterns) = pat;
          npatterns ++;
          pat = (char *)((void *)0);
        }
      } else
      if (! pat) {
        pat = buf + pos;
      }
      pos ++;
    }
    if (pat) {
      pos = (int )(pat - buf);
    } else {
      pos = count;
    }
  }
  *result = patterns;
  *rescount = npatterns;
  return (ret);
}
}
