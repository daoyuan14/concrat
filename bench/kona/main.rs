use ::libc;
use ::c2rust_asm_casts;
use c2rust_asm_casts::AsmCastTrait;
use std::arch::asm;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    fn socket(
        __domain: libc::c_int,
        __type: libc::c_int,
        __protocol: libc::c_int,
    ) -> libc::c_int;
    fn connect(
        __fd: libc::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> libc::c_int;
    fn send(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
    ) -> ssize_t;
    fn setsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *const libc::c_void,
        __optlen: socklen_t,
    ) -> libc::c_int;
    fn getaddrinfo(
        __name: *const libc::c_char,
        __service: *const libc::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> libc::c_int;
    fn freeaddrinfo(__ai: *mut addrinfo);
    fn gai_strerror(__ecode: libc::c_int) -> *const libc::c_char;
    fn dlopen(__file: *const libc::c_char, __mode: libc::c_int) -> *mut libc::c_void;
    fn dlsym(
        __handle: *mut libc::c_void,
        __name: *const libc::c_char,
    ) -> *mut libc::c_void;
    fn dlerror() -> *mut libc::c_char;
    fn mmap(
        __addr: *mut libc::c_void,
        __len: size_t,
        __prot: libc::c_int,
        __flags: libc::c_int,
        __fd: libc::c_int,
        __offset: __off_t,
    ) -> *mut libc::c_void;
    fn munmap(__addr: *mut libc::c_void, __len: size_t) -> libc::c_int;
    fn msync(
        __addr: *mut libc::c_void,
        __len: size_t,
        __flags: libc::c_int,
    ) -> libc::c_int;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn strtoll(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_longlong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn perror(__s: *const libc::c_char);
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn ceil(_: libc::c_double) -> libc::c_double;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn __errno_location() -> *mut libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;
    fn pread(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
    fn execvp(
        __file: *const libc::c_char,
        __argv: *const *mut libc::c_char,
    ) -> libc::c_int;
    fn fork() -> __pid_t;
    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    fn wait(__stat_loc: *mut libc::c_int) -> __pid_t;
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fileno(__stream: *mut FILE) -> libc::c_int;
    fn clock() -> clock_t;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut size_t,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn fnmatch(
        __pattern: *const libc::c_char,
        __name: *const libc::c_char,
        __flags: libc::c_int,
    ) -> libc::c_int;
    fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut libc::c_char,
        __hostlen: socklen_t,
        __serv: *mut libc::c_char,
        __servlen: socklen_t,
        __flags: libc::c_int,
    ) -> libc::c_int;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
    fn acos(_: libc::c_double) -> libc::c_double;
    fn asin(_: libc::c_double) -> libc::c_double;
    fn atan(_: libc::c_double) -> libc::c_double;
    fn cos(_: libc::c_double) -> libc::c_double;
    fn sin(_: libc::c_double) -> libc::c_double;
    fn tan(_: libc::c_double) -> libc::c_double;
    fn cosh(_: libc::c_double) -> libc::c_double;
    fn sinh(_: libc::c_double) -> libc::c_double;
    fn tanh(_: libc::c_double) -> libc::c_double;
    fn exp(_: libc::c_double) -> libc::c_double;
    fn log(_: libc::c_double) -> libc::c_double;
    fn pow(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn sqrt(_: libc::c_double) -> libc::c_double;
    fn floor(_: libc::c_double) -> libc::c_double;
    fn round(_: libc::c_double) -> libc::c_double;
    fn time(__timer: *mut time_t) -> time_t;
    fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn gethostname(__name: *mut libc::c_char, __len: size_t) -> libc::c_int;
    fn gettimeofday(__tv: *mut timeval, __tz: *mut libc::c_void) -> libc::c_int;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn modf(_: libc::c_double, _: *mut libc::c_double) -> libc::c_double;
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn bind(__fd: libc::c_int, __addr: *const sockaddr, __len: socklen_t) -> libc::c_int;
    fn listen(__fd: libc::c_int, __n: libc::c_int) -> libc::c_int;
    fn accept(
        __fd: libc::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> libc::c_int;
    fn abort() -> !;
    fn atexit(__func: Option::<unsafe extern "C" fn() -> ()>) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn usleep(__useconds: __useconds_t) -> libc::c_int;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    static mut optarg: *mut libc::c_char;
    static mut optind: libc::c_int;
    static mut optopt: libc::c_int;
    fn getopt(
        ___argc: libc::c_int,
        ___argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
    ) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
    fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
    fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: libc::c_int,
    ) -> libc::c_int;
    fn sigemptyset(__set: *mut sigset_t) -> libc::c_int;
    fn sigaction(
        __sig: libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> libc::c_int;
    fn llabs(_: libc::c_longlong) -> libc::c_longlong;
    fn mremap(
        __addr: *mut libc::c_void,
        __old_len: size_t,
        __new_len: size_t,
        __flags: libc::c_int,
        _: ...
    ) -> *mut libc::c_void;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn recv(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
    ) -> ssize_t;
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fabs(_: libc::c_double) -> libc::c_double;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __int8_t = libc::c_schar;
pub type __int16_t = libc::c_short;
pub type __int32_t = libc::c_int;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type size_t = libc::c_ulong;
pub type pid_t = __pid_t;
pub type ssize_t = __ssize_t;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct addrinfo {
    pub ai_flags: libc::c_int,
    pub ai_family: libc::c_int,
    pub ai_socktype: libc::c_int,
    pub ai_protocol: libc::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut libc::c_char,
    pub ai_next: *mut addrinfo,
}
pub type __gnuc_va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type L = libc::c_longlong;
pub type V = *mut libc::c_void;
pub type I = libc::c_longlong;
pub type F = libc::c_double;
pub type C = libc::c_char;
pub type S = *mut C;
pub type cS = *const C;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct k0 {
    pub _c: I,
    pub t: I,
    pub n: I,
    pub k: [*mut k0; 1],
}
pub type K = *mut k0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct m1 {
    pub a: libc::c_char,
    pub b: libc::c_char,
    pub c: [libc::c_char; 5],
    pub d: libc::c_char,
    pub n: I,
}
pub type M1 = m1;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type __clock_t = libc::c_long;
pub type clock_t = __clock_t;
pub type UI = libc::c_ulonglong;
pub type UC = libc::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pda {
    pub i: I,
    pub s: I,
    pub n: I,
    pub c: S,
}
pub type Pda = pda;
pub type PDA = *mut Pda;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct af {
    pub verb_over: V,
    pub verb_scan: V,
    pub verb_eachpair: V,
}
pub type AF = af;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tr {
    pub adverbClass: I,
    pub arity: I,
    pub func: V,
    pub text: S,
    pub alt_funcs: AF,
}
pub type TR = tr;
pub type __uint16_t = libc::c_ushort;
pub type __suseconds_t = libc::c_long;
pub type uint16_t = __uint16_t;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type in_addr_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_port_t = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
pub type va_list___0 = __gnuc_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node {
    pub k: V,
    pub b: I,
    pub c: [*mut node; 2],
}
pub type Node = node;
pub type N = *mut Node;
pub type __useconds_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___sigset_t_991265788 {
    pub __val: [libc::c_ulong; 16],
}
pub type __sigset_t = __anonstruct___sigset_t_991265788;
pub type sigset_t = __sigset_t;
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_fd_set_356711149 {
    pub __fds_bits: [__fd_mask; 16],
}
pub type fd_set = __anonstruct_fd_set_356711149;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [libc::c_char; 118],
    pub __ss_align: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct m0 {
    pub m1: M1,
    pub r: I,
    pub k: K,
    pub a: I,
}
pub type M0 = m0;
pub type sig_atomic_t = __sig_atomic_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
}
pub type __sigval_t = sigval;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__kill_244518854 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__timer_490064738 {
    pub si_tid: libc::c_int,
    pub si_overrun: libc::c_int,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__rt_619254530 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigchld_284671705 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__addr_bnd_5259977 {
    pub _lower: *mut libc::c_void,
    pub _upper: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion__bounds_548943257 {
    pub _addr_bnd: __anonstruct__addr_bnd_5259977,
    pub _pkey: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigfault_738185185 {
    pub si_addr: *mut libc::c_void,
    pub si_addr_lsb: libc::c_short,
    pub _bounds: __anonunion__bounds_548943257,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigpoll_386613454 {
    pub si_band: libc::c_long,
    pub si_fd: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigsys_44812255 {
    pub _call_addr: *mut libc::c_void,
    pub _syscall: libc::c_int,
    pub _arch: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion__sifields_515865865 {
    pub _pad: [libc::c_int; 28],
    pub _kill: __anonstruct__kill_244518854,
    pub _timer: __anonstruct__timer_490064738,
    pub _rt: __anonstruct__rt_619254530,
    pub _sigchld: __anonstruct__sigchld_284671705,
    pub _sigfault: __anonstruct__sigfault_738185185,
    pub _sigpoll: __anonstruct__sigpoll_386613454,
    pub _sigsys: __anonstruct__sigsys_44812255,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_siginfo_t_306704184 {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub __pad0: libc::c_int,
    pub _sifields: __anonunion__sifields_515865865,
}
pub type siginfo_t = __anonstruct_siginfo_t_306704184;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion___sigaction_handler_363639592 {
    pub sa_handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    pub sa_sigaction: Option::<
        unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigaction {
    pub __sigaction_handler: __anonunion___sigaction_handler_363639592,
    pub sa_mask: __sigset_t,
    pub sa_flags: libc::c_int,
    pub sa_restorer: Option::<unsafe extern "C" fn() -> ()>,
}
pub type uI = libc::c_ulonglong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_x_721633472 {
    pub i: I,
    pub f: F,
}
pub type __uint8_t = libc::c_uchar;
pub type uint8_t = __uint8_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion___in6_u_979734923 {
    pub __u6_addr8: [uint8_t; 16],
    pub __u6_addr16: [uint16_t; 8],
    pub __u6_addr32: [uint32_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in6_addr {
    pub __in6_u: __anonunion___in6_u_979734923,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u_554368621 {
    pub f: F,
    pub i: I,
}
#[inline]
unsafe extern "C" fn atol(mut __nptr: *const libc::c_char) -> libc::c_long {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp;
}
#[inline]
unsafe extern "C" fn vprintf(
    mut __fmt: *const libc::c_char,
    mut __arg: ::std::ffi::VaList,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = vfprintf(stdout, __fmt, __arg.as_va_list());
    return tmp;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    let mut tmp: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___0: __int32_t = 0;
    if __c >= -(128 as libc::c_int) {
        if __c < 256 as libc::c_int {
            tmp = __ctype_tolower_loc();
            tmp___0 = *(*tmp).offset(__c as isize);
        } else {
            tmp___0 = __c;
        }
    } else {
        tmp___0 = __c;
    }
    return tmp___0;
}
#[inline]
unsafe extern "C" fn stat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __xstat(1 as libc::c_int, __path, __statbuf);
    return tmp;
}
unsafe extern "C" fn freopen_stdin() -> V {
    let mut tmp: *mut FILE = 0 as *mut FILE;
    tmp = freopen(
        0 as *const libc::c_char,
        b"r\0" as *const u8 as *const libc::c_char,
        stdin,
    );
    return tmp as V;
}
pub unsafe extern "C" fn _0m(mut a: K) -> K {
    let mut current_block: u64;
    let mut t: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut b___1: I = 0;
    let mut s: I = 0;
    let mut v: S = 0 as *mut C;
    let mut z: K = 0 as *mut k0;
    let mut m: S = 0 as *mut C;
    let mut tmp___1: I = 0;
    let mut sb: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut ff: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut fn_0: I = 0;
    let mut i: I = 0;
    let mut j: I = 0;
    let mut buf___1: [C; 256] = [0; 256];
    let mut tmp___7: libc::c_int = 0;
    let mut y: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: ssize_t = 0;
    let mut ss: [libc::c_char; 300] = [0; 300];
    let mut adr: S = 0 as *mut C;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut j___0: I = 0;
    let mut k: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: V = 0 as *mut libc::c_void;
    let mut f: I = 0;
    let mut tmp___16: S = 0 as *mut C;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___20: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: S = 0 as *mut C;
    let mut tmp___23: I = 0;
    let mut tmp___24: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___25: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___26: K = 0 as *mut k0;
    let mut tmp___27: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: K = 0 as *mut k0;
    let mut tmp___30: I = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: libc::c_int = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut c: I = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut d___0: I = 0;
    let mut e: I = 0;
    let mut i___1: I = 0;
    let mut _i___0: I = 0;
    let mut k___0: K = 0 as *mut k0;
    let mut i___2: I = 0;
    let mut _i___1: I = 0;
    let mut i___3: I = 0;
    let mut _i___2: I = 0;
    let mut i___4: I = 0;
    let mut _i___3: I = 0;
    let mut r___0: I = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: K = 0 as *mut k0;
    t = (*a).t;
    if 4 as libc::c_longlong != t {
        if t < 0 as libc::c_longlong {
            tmp___0 = -t;
        } else {
            tmp___0 = t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    b___1 = 0 as libc::c_int as I;
    s = 0 as libc::c_int as I;
    v = 0 as S;
    z = 0 as K;
    fll = 0 as libc::c_int as I;
    fbr = fll;
    if t < 0 as libc::c_longlong {
        tmp___1 = -t;
    } else {
        tmp___1 = t;
    }
    if 3 as libc::c_longlong == tmp___1 {
        m = CSK(a);
    }
    ff = 0 as libc::c_int as I;
    if t < 0 as libc::c_longlong {
        tmp___4 = -t;
    } else {
        tmp___4 = t;
    }
    if 3 as libc::c_longlong == tmp___4 {
        tmp___5 = strcmp(
            m as *const libc::c_char,
            b"/dev/fd/0\0" as *const u8 as *const libc::c_char,
        );
        if tmp___5 != 0 {
            tmp___6 = strcmp(
                m as *const libc::c_char,
                b"/dev/stdin\0" as *const u8 as *const libc::c_char,
            );
            if tmp___6 != 0 {
                tmp___3 = stat(m as *const libc::c_char, &mut sb as *mut stat);
                if tmp___3 == -(1 as libc::c_int) {
                    tmp___2 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                    return tmp___2;
                }
                if sb.st_mode & 61440 as libc::c_uint == 4096 as libc::c_uint {
                    ff = 1 as libc::c_int as I;
                }
            }
        }
    }
    if ff != 0 {
        z = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
        tmp___7 = open(m as *const libc::c_char, 0 as libc::c_int);
        fn_0 = tmp___7 as I;
        loop {
            tmp___10 = read(
                fn_0 as libc::c_int,
                &mut buf___1 as *mut [C; 256] as *mut libc::c_void,
                256 as libc::c_int as size_t,
            );
            if !(tmp___10 > 0 as libc::c_long) {
                break;
            }
            j = 256 as libc::c_int as I;
            y = 0 as K;
            i = 0 as libc::c_int as I;
            while i < 256 as libc::c_longlong {
                if i > j {
                    buf___1[j as usize] = '\u{0}' as i32 as C;
                    break;
                } else {
                    if buf___1[i as usize] as libc::c_int == 10 as libc::c_int {
                        j = i;
                    }
                    i += 1;
                }
            }
            tmp___8 = strlen(buf___1.as_mut_ptr() as *const libc::c_char);
            n = tmp___8 as I;
            if n < 2 as libc::c_longlong {
                tmp___9 = 3 as libc::c_int;
            } else {
                tmp___9 = -(3 as libc::c_int);
            }
            y = newK(tmp___9 as I, n);
            memcpy(
                ((*y).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                &mut buf___1 as *mut [C; 256] as *const libc::c_void,
                n as size_t,
            );
            kap(&mut z, &mut y as *mut K as V);
            cd(y);
        }
    } else {
        if 4 as libc::c_longlong == t {
            if **(((*a).k).as_mut_ptr() as *mut S) == 0 {
                tmp___11 = fgets(
                    ss.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 300]>() as libc::c_ulong
                        as libc::c_int,
                    stdin,
                );
                adr = tmp___11;
                if adr as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___12 = newK(6 as libc::c_int as I, 1 as libc::c_int as I);
                    return tmp___12;
                }
                i___0 = 0 as libc::c_int as I;
                while i___0 < 300 as libc::c_longlong {
                    if ss[i___0 as usize] as libc::c_int == 10 as libc::c_int {
                        break;
                    }
                    i___0 += 1;
                }
                k = 0 as libc::c_int as I;
                j___0 = 0 as libc::c_int as I;
                while j___0 <= i___0 {
                    if ss[j___0 as usize] as libc::c_int != 4 as libc::c_int {
                        tmp___13 = k;
                        k += 1;
                        ss[tmp___13 as usize] = ss[j___0 as usize];
                    }
                    j___0 += 1;
                }
                z = newK(-(3 as libc::c_int) as I, k - 1 as libc::c_longlong);
                j___0 = 0 as libc::c_int as I;
                while j___0 < k - 1 as libc::c_longlong {
                    *(((*z).k).as_mut_ptr() as *mut C)
                        .offset(j___0 as isize) = ss[j___0 as usize];
                    j___0 += 1;
                }
                current_block = 11443913330715786601;
            } else {
                current_block = 18273357469590673084;
            }
        } else {
            current_block = 18273357469590673084;
        }
        match current_block {
            11443913330715786601 => {}
            _ => {
                if t < 0 as libc::c_longlong {
                    tmp___30 = -t;
                } else {
                    tmp___30 = t;
                }
                if 3 as libc::c_longlong == tmp___30 {
                    tmp___31 = strcmp(
                        m as *const libc::c_char,
                        b"/dev/fd/0\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___31 != 0 {
                        tmp___32 = strcmp(
                            m as *const libc::c_char,
                            b"/dev/stdin\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___32 != 0 {
                            current_block = 12115659611556352937;
                        } else {
                            current_block = 8125940200833653259;
                        }
                    } else {
                        current_block = 8125940200833653259;
                    }
                } else {
                    current_block = 12115659611556352937;
                }
                match current_block {
                    12115659611556352937 => {
                        if 4 as libc::c_longlong == t {
                            tmp___33 = strcmp(
                                *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
                                b"/dev/fd/0\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___33 != 0 {
                                tmp___34 = strcmp(
                                    *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
                                    b"/dev/stdin\0" as *const u8 as *const libc::c_char,
                                );
                                if tmp___34 != 0 {
                                    current_block = 11636384128342106077;
                                } else {
                                    current_block = 8125940200833653259;
                                }
                            } else {
                                current_block = 8125940200833653259;
                            }
                        } else {
                            current_block = 11636384128342106077;
                        }
                        match current_block {
                            8125940200833653259 => {}
                            _ => {
                                tmp___16 = CSK(a);
                                tmp___17 = open(
                                    tmp___16 as *const libc::c_char,
                                    0 as libc::c_int,
                                );
                                f = tmp___17 as I;
                                if f < 0 as libc::c_longlong {
                                    tmp___18 = kerr(
                                        b"domain\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___18;
                                }
                                tmp___22 = CSK(a);
                                tmp___23 = stat_sz(tmp___22, &mut s);
                                if tmp___23 != 0 {
                                    tmp___19 = __errno_location();
                                    tmp___20 = strerror(*tmp___19);
                                    tmp___21 = kerr(tmp___20 as cS);
                                    return tmp___21;
                                }
                                tmp___27 = mmap(
                                    0 as *mut libc::c_void,
                                    s as size_t,
                                    1 as libc::c_int,
                                    1 as libc::c_int,
                                    f as libc::c_int,
                                    0 as libc::c_int as __off_t,
                                );
                                v = tmp___27 as S;
                                if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong
                                    == v as libc::c_ulong
                                {
                                    tmp___24 = __errno_location();
                                    tmp___25 = strerror(*tmp___24);
                                    tmp___26 = kerr(tmp___25 as cS);
                                    return tmp___26;
                                }
                                tmp___28 = close(f as libc::c_int);
                                r = tmp___28 as I;
                                if r != 0 {
                                    tmp___29 = kerr(
                                        b"file\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___29;
                                }
                                current_block = 9270770154621591809;
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    8125940200833653259 => {
                        b___1 = getdelim_(
                            &mut v,
                            &mut s,
                            -(1 as libc::c_int) as I,
                            stdin,
                        );
                        tmp___15 = freopen_stdin();
                        if tmp___15 as libc::c_ulong
                            == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            tmp___14 = kerr(
                                b"file\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___14;
                        }
                        if b___1 == -(1 as libc::c_longlong) {
                            z = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                            current_block = 11443913330715786601;
                        } else {
                            current_block = 9270770154621591809;
                        }
                    }
                    _ => {}
                }
                match current_block {
                    11443913330715786601 => {}
                    _ => {
                        if s != 0 {
                            tmp___35 = 1 as libc::c_int;
                        } else {
                            tmp___35 = 0 as libc::c_int;
                        }
                        c = tmp___35 as I;
                        d___0 = 0 as libc::c_int as I;
                        i___1 = 0 as libc::c_int as I;
                        _i___0 = s;
                        while i___1 < _i___0 {
                            if 10 as libc::c_int
                                == *v.offset(i___1 as isize) as libc::c_int
                            {
                                if i___1 < s - 1 as libc::c_longlong {
                                    c += 1;
                                }
                            }
                            i___1 += 1;
                        }
                        z = newK(0 as libc::c_int as I, c);
                        if !z.is_null() {
                            i___2 = 0 as libc::c_int as I;
                            _i___1 = s;
                            while i___2 < _i___1 {
                                if 10 as libc::c_int
                                    != *v.offset(i___2 as isize) as libc::c_int
                                {
                                    let ref mut fresh0 = *((*z).k)
                                        .as_mut_ptr()
                                        .offset(d___0 as isize);
                                    *fresh0 = (1 as libc::c_int as V)
                                        .offset(
                                            *((*z).k).as_mut_ptr().offset(d___0 as isize) as L as isize,
                                        ) as *mut k0;
                                } else {
                                    d___0 += 1;
                                }
                                i___2 += 1;
                            }
                            i___3 = 0 as libc::c_int as I;
                            _i___2 = c;
                            loop {
                                if !(i___3 < _i___2) {
                                    current_block = 17518666747792551745;
                                    break;
                                }
                                e = *((*z).k).as_mut_ptr().offset(i___3 as isize) as L;
                                k___0 = newK(-(3 as libc::c_int) as I, e);
                                if k___0.is_null() {
                                    cd(z);
                                    z = 0 as K;
                                    current_block = 11443913330715786601;
                                    break;
                                } else {
                                    let ref mut fresh1 = *((*z).k)
                                        .as_mut_ptr()
                                        .offset(i___3 as isize);
                                    *fresh1 = k___0;
                                    i___3 += 1;
                                }
                            }
                            match current_block {
                                11443913330715786601 => {}
                                _ => {
                                    e = 0 as libc::c_int as I;
                                    i___4 = 0 as libc::c_int as I;
                                    _i___3 = c;
                                    while i___4 < _i___3 {
                                        k___0 = *((*z).k).as_mut_ptr().offset(i___4 as isize);
                                        memcpy(
                                            ((*k___0).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                                            v.offset(e as isize) as *const libc::c_void,
                                            (*k___0).n as size_t,
                                        );
                                        e += 1 as libc::c_longlong + (*k___0).n;
                                        i___4 += 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if !v.is_null() {
        if b___1 != 0 {
            free(v as *mut libc::c_void);
        } else {
            tmp___36 = munmap(v as *mut libc::c_void, s as size_t);
            r___0 = tmp___36 as I;
            if r___0 != 0 {
                tmp___37 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
                return tmp___37;
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn _0d(mut a: K, mut b___1: K) -> K {
    let mut t: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    t = (*a).t;
    if 4 as libc::c_longlong == t {
        tmp = _0d_write(a, b___1);
        return tmp;
    } else {
        if t < 0 as libc::c_longlong {
            tmp___0 = -t;
        } else {
            tmp___0 = t;
        }
        if 3 as libc::c_longlong == tmp___0 {
            tmp = _0d_write(a, b___1);
            return tmp;
        }
    }
    if t == 0 {
        tmp___1 = _0d_read(a, b___1);
        return tmp___1;
    }
    tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
    return tmp___2;
}
unsafe extern "C" fn ok_0dw(mut b___1: K) -> I {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    t = (*b___1).t;
    n = (*b___1).n;
    if t < 0 as libc::c_longlong {
        tmp___0 = -t;
    } else {
        tmp___0 = t;
    }
    if 3 as libc::c_longlong != tmp___0 {
        if t == 0 {
            i = 0 as libc::c_int as I;
            _i___0 = n;
            while i < _i___0 {
                k = *((*b___1).k).as_mut_ptr().offset(i as isize);
                if (*k).t < 0 as libc::c_longlong {
                    tmp = -(*k).t;
                } else {
                    tmp = (*k).t;
                }
                if 3 as libc::c_longlong != tmp {
                    if t != 0 {
                        return 0 as libc::c_int as I
                    } else {
                        if (*k).n != 0 {
                            return 0 as libc::c_int as I;
                        }
                    }
                }
                i += 1;
            }
        } else {
            return 0 as libc::c_int as I
        }
    }
    return 1 as libc::c_int as I;
}
unsafe extern "C" fn _0d_write(mut a: K, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut t: I = 0;
    let mut n: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___1: S = 0 as *mut C;
    let mut s: I = 0;
    let mut f: I = 0;
    let mut sb: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut msg: S = 0 as *mut C;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: ssize_t = 0;
    let mut msg___0: S = 0 as *mut C;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: size_t = 0;
    let mut tmp___11: ssize_t = 0;
    let mut r: I = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: I = 0;
    let mut r___0: I = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: libc::c_int = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___20: I = 0;
    let mut r___1: I = 0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: ssize_t = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___23: ssize_t = 0;
    let mut tmp___24: I = 0;
    let mut tmp___25: ssize_t = 0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut tmp___27: I = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: K = 0 as *mut k0;
    let mut tmp___30: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___31: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___32: K = 0 as *mut k0;
    let mut tmp___33: libc::c_int = 0;
    let mut v: S = 0 as *mut C;
    let mut tmp___34: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___35: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___36: K = 0 as *mut k0;
    let mut tmp___37: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r___2: I = 0;
    let mut tmp___38: libc::c_int = 0;
    let mut tmp___39: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___40: I = 0;
    let mut tmp___41: I = 0;
    let mut tmp___42: I = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: K = 0 as *mut k0;
    let mut tmp___45: libc::c_int = 0;
    let mut tmp___46: libc::c_int = 0;
    let mut tmp___47: K = 0 as *mut k0;
    t = (*b___1).t;
    n = (*b___1).n;
    tmp___0 = ok_0dw(b___1);
    if tmp___0 == 0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___1 = CSK(a);
    m = tmp___1;
    s = 0 as libc::c_int as I;
    f = 0 as libc::c_int as I;
    tmp___19 = stat(m as *const libc::c_char, &mut sb as *mut stat);
    if tmp___19 != -(1 as libc::c_int) {
        if sb.st_mode & 61440 as libc::c_uint == 4096 as libc::c_uint {
            tmp___2 = open(m as *const libc::c_char, 1 as libc::c_int);
            f = tmp___2 as I;
            if f < 0 as libc::c_longlong {
                tmp___3 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                return tmp___3;
            }
            if t < 0 as libc::c_longlong {
                tmp___15 = -t;
            } else {
                tmp___15 = t;
            }
            if 3 as libc::c_longlong == tmp___15 {
                msg = ((*b___1).k).as_mut_ptr() as *mut C;
                tmp___5 = strlen(msg as *const libc::c_char);
                tmp___6 = write(
                    f as libc::c_int,
                    msg as *const libc::c_void,
                    tmp___5.wrapping_add(1 as libc::c_ulong),
                );
                if tmp___6 == -(1 as libc::c_long) {
                    tmp___4 = kerr(b"write\0" as *const u8 as *const libc::c_char);
                    return tmp___4;
                }
            } else if 0 as libc::c_longlong == t {
                i = 0 as libc::c_int as I;
                _i___0 = n;
                while i < _i___0 {
                    if (**((*b___1).k).as_mut_ptr().offset(i as isize)).t
                        < 0 as libc::c_longlong
                    {
                        tmp___8 = -(**((*b___1).k).as_mut_ptr().offset(i as isize)).t;
                    } else {
                        tmp___8 = (**((*b___1).k).as_mut_ptr().offset(i as isize)).t;
                    }
                    if tmp___8 != 3 as libc::c_longlong {
                        tmp___7 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                        return tmp___7;
                    }
                    msg___0 = ((**((*b___1).k).as_mut_ptr().offset(i as isize)).k)
                        .as_mut_ptr() as *mut C;
                    tmp___10 = strlen(msg___0 as *const libc::c_char);
                    tmp___11 = write(
                        f as libc::c_int,
                        msg___0 as *const libc::c_void,
                        tmp___10.wrapping_add(1 as libc::c_ulong),
                    );
                    if tmp___11 == -(1 as libc::c_long) {
                        tmp___9 = kerr(b"write\0" as *const u8 as *const libc::c_char);
                        return tmp___9;
                    }
                    i += 1;
                }
            } else {
                tmp___12 = close(f as libc::c_int);
                r = tmp___12 as I;
                if r != 0 {
                    tmp___13 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                    return tmp___13;
                }
                tmp___14 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                return tmp___14;
            }
            tmp___16 = close(f as libc::c_int);
            r___0 = tmp___16 as I;
            if r___0 != 0 {
                tmp___17 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                return tmp___17;
            }
            tmp___18 = _n();
            return tmp___18;
        }
    }
    if t < 0 as libc::c_longlong {
        tmp___20 = -t;
    } else {
        tmp___20 = t;
    }
    if 3 as libc::c_longlong == tmp___20 {
        s = n;
    } else {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            s
                += 1 as libc::c_longlong
                    + (**((*b___1).k).as_mut_ptr().offset(i___0 as isize)).n;
            i___0 += 1;
        }
    }
    if *m.offset(0 as libc::c_int as isize) == 0 {
        current_block = 16186740905345617099;
    } else {
        tmp___45 = strcmp(
            m as *const libc::c_char,
            b"/dev/fd/1\0" as *const u8 as *const libc::c_char,
        );
        if tmp___45 != 0 {
            tmp___46 = strcmp(
                m as *const libc::c_char,
                b"/dev/stdout\0" as *const u8 as *const libc::c_char,
            );
            if tmp___46 != 0 {
                if *m.offset(0 as libc::c_int as isize) != 0 {
                    tmp___28 = open(
                        m as *const libc::c_char,
                        578 as libc::c_int,
                        436 as libc::c_int,
                    );
                    f = tmp___28 as I;
                }
                if f < 0 as libc::c_longlong {
                    tmp___29 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                    return tmp___29;
                }
                tmp___33 = ftruncate(f as libc::c_int, s as __off_t);
                if tmp___33 != 0 {
                    tmp___30 = __errno_location();
                    tmp___31 = strerror(*tmp___30);
                    tmp___32 = kerr(tmp___31 as cS);
                    return tmp___32;
                }
                tmp___37 = mmap(
                    0 as *mut libc::c_void,
                    s as size_t,
                    2 as libc::c_int,
                    1 as libc::c_int,
                    f as libc::c_int,
                    0 as libc::c_int as __off_t,
                );
                v = tmp___37 as S;
                if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong
                    == v as libc::c_ulong
                {
                    tmp___34 = __errno_location();
                    tmp___35 = strerror(*tmp___34);
                    tmp___36 = kerr(tmp___35 as cS);
                    return tmp___36;
                }
                tmp___38 = close(f as libc::c_int);
                r___2 = tmp___38 as I;
                if r___2 != 0 {
                    tmp___39 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                    return tmp___39;
                }
                c = 0 as libc::c_int as I;
                if t < 0 as libc::c_longlong {
                    tmp___42 = -t;
                } else {
                    tmp___42 = t;
                }
                if 3 as libc::c_longlong == tmp___42 {
                    memcpy(
                        v as *mut libc::c_void,
                        ((*b___1).k).as_mut_ptr() as *mut C as *const libc::c_void,
                        s as size_t,
                    );
                } else {
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = n;
                    while i___2 < _i___3 {
                        k = *((*b___1).k).as_mut_ptr().offset(i___2 as isize);
                        if (*k).t < 0 as libc::c_longlong {
                            tmp___40 = -(*k).t;
                        } else {
                            tmp___40 = (*k).t;
                        }
                        if 3 as libc::c_longlong == tmp___40 {
                            memcpy(
                                v.offset(c as isize) as *mut libc::c_void,
                                ((*k).k).as_mut_ptr() as *mut C as *const libc::c_void,
                                (*k).n as size_t,
                            );
                            c += (*k).n;
                        }
                        tmp___41 = c;
                        c += 1;
                        *v.offset(tmp___41 as isize) = '\n' as i32 as C;
                        i___2 += 1;
                    }
                }
                tmp___43 = munmap(v as *mut libc::c_void, s as size_t);
                r___2 = tmp___43 as I;
                if r___2 != 0 {
                    tmp___44 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
                    return tmp___44;
                }
                current_block = 5482373152242628851;
            } else {
                current_block = 16186740905345617099;
            }
        } else {
            current_block = 16186740905345617099;
        }
    }
    match current_block {
        16186740905345617099 => {
            f = 1 as libc::c_int as I;
            if t < 0 as libc::c_longlong {
                tmp___27 = -t;
            } else {
                tmp___27 = t;
            }
            if 3 as libc::c_longlong == tmp___27 {
                tmp___22 = write(
                    f as libc::c_int,
                    ((*b___1).k).as_mut_ptr() as *mut C as *const libc::c_void,
                    s as size_t,
                );
                if tmp___22 == -(1 as libc::c_long) {
                    tmp___21 = kerr(b"write\0" as *const u8 as *const libc::c_char);
                    show(tmp___21);
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    k = *((*b___1).k).as_mut_ptr().offset(i___1 as isize);
                    if (*k).t < 0 as libc::c_longlong {
                        tmp___24 = -(*k).t;
                    } else {
                        tmp___24 = (*k).t;
                    }
                    if 3 as libc::c_longlong == tmp___24 {
                        tmp___23 = write(
                            f as libc::c_int,
                            ((*k).k).as_mut_ptr() as *mut C as *const libc::c_void,
                            (*k).n as size_t,
                        );
                        r___1 = tmp___23 as I;
                    }
                    tmp___25 = write(
                        f as libc::c_int,
                        b"\n\0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        1 as libc::c_int as size_t,
                    );
                    r___1 = tmp___25 as I;
                    if r___1 == -(1 as libc::c_longlong) {
                        tmp___26 = kerr(b"write\0" as *const u8 as *const libc::c_char);
                        show(tmp___26);
                    }
                    i___1 += 1;
                }
            }
        }
        _ => {}
    }
    tmp___47 = _n();
    return tmp___47;
}
unsafe extern "C" fn _0d_read(mut a: K, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut z: K = 0 as *mut k0;
    let mut res: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut cn: I = 0;
    let mut dn: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut fc: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    let mut w___0: I = 0;
    let mut x___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut ff: K = 0 as *mut k0;
    let mut k: K = 0 as *mut k0;
    let mut fb: I = 0;
    let mut fn_0: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut s: I = 0;
    let mut tmp___16: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___17: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: S = 0 as *mut C;
    let mut tmp___20: I = 0;
    let mut tmp___22: I = 0;
    let mut tmp___23: I = 0;
    let mut f: I = 0;
    let mut tmp___24: S = 0 as *mut C;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut tmp___27: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___28: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___29: K = 0 as *mut k0;
    let mut tmp___30: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut e: I = 0;
    let mut g: C = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___33: I = 0;
    let mut tmp___34: *mut k0 = 0 as *mut k0;
    let mut tmp___35: I = 0;
    let mut m: S = 0 as *mut C;
    let mut u: I = 0;
    let mut y: I = 0;
    let mut p: I = 0;
    let mut q: K = 0 as *mut k0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___36: I = 0;
    let mut tmp___37: libc::c_int = 0;
    let mut tmp___38: K = 0 as *mut k0;
    z = 0 as K;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if an != 2 as libc::c_longlong {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    c = *((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    d___0 = *((*a).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    cn = (*c).n;
    dn = (*d___0).n;
    if 3 as libc::c_longlong == (*d___0).t {
        tmp___0 = _0d_rdDsv(a, b___1);
        return tmp___0;
    }
    if -(3 as libc::c_longlong) == (*d___0).t {
        tmp___1 = _0d_rdDsvWc(a, b___1);
        return tmp___1;
    }
    if (*c).t < 0 as libc::c_longlong {
        tmp___3 = -(*c).t;
    } else {
        tmp___3 = (*c).t;
    }
    if 3 as libc::c_longlong != tmp___3 {
        tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    } else {
        if (*d___0).t < 0 as libc::c_longlong {
            tmp___4 = -(*d___0).t;
        } else {
            tmp___4 = (*d___0).t;
        }
        if 1 as libc::c_longlong != tmp___4 {
            tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
    }
    if cn == 0 {
        tmp___5 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___5;
    } else {
        if cn != dn {
            tmp___5 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___5;
        }
    }
    if bt < 0 as libc::c_longlong {
        tmp___7 = -bt;
    } else {
        tmp___7 = bt;
    }
    if 3 as libc::c_longlong != tmp___7 {
        if 4 as libc::c_longlong != bt {
            if 0 as libc::c_longlong != bt {
                tmp___6 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    fc = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = cn;
    while i < _i___0 {
        if !(32 as libc::c_int
            == *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize) as libc::c_int)
        {
            tmp___9 = stringHasChar(
                b"IFCS\0" as *const u8 as *const libc::c_char as S,
                *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize),
            );
            if tmp___9 != 0 {
                fc += 1;
            } else {
                tmp___8 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___8;
            }
        }
        i += 1;
    }
    w___0 = 1 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = dn;
    while i___0 < _i___1 {
        x___0 = *(((*d___0).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
        if x___0 <= 0 as libc::c_longlong {
            tmp___10 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___10;
        }
        w___0 += x___0;
        i___0 += 1;
    }
    ff = b___1;
    fb = 0 as libc::c_int as I;
    fn_0 = 0 as libc::c_int as I;
    if bt == 0 {
        if 3 as libc::c_longlong != bn {
            tmp___11 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___11;
        }
        ff = *((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        if (*ff).t < 0 as libc::c_longlong {
            tmp___13 = -(*ff).t;
        } else {
            tmp___13 = (*ff).t;
        }
        if 3 as libc::c_longlong != tmp___13 {
            if 4 as libc::c_longlong != (*ff).t {
                tmp___12 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___12;
            }
        }
        k = *((*b___1).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        if 1 as libc::c_longlong != (*k).t {
            if 2 as libc::c_longlong != (*k).t {
                tmp___14 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___14;
            }
        }
        if (*k).t - 1 as libc::c_longlong != 0 {
            fb = *(((*k).k).as_mut_ptr() as *mut F) as I;
        } else {
            fb = *(((*k).k).as_mut_ptr() as *mut I);
        }
        k = *((*b___1).k).as_mut_ptr().offset(2 as libc::c_int as isize);
        if 1 as libc::c_longlong != (*k).t {
            if 2 as libc::c_longlong != (*k).t {
                tmp___15 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___15;
            }
        }
        if (*k).t - 1 as libc::c_longlong != 0 {
            fn_0 = *(((*k).k).as_mut_ptr() as *mut F) as I;
        } else {
            fn_0 = *(((*k).k).as_mut_ptr() as *mut I);
        }
    }
    tmp___19 = CSK(ff);
    tmp___20 = stat_sz(tmp___19, &mut s);
    if tmp___20 != 0 {
        tmp___16 = __errno_location();
        tmp___17 = strerror(*tmp___16);
        tmp___18 = kerr(tmp___17 as cS);
        return tmp___18;
    }
    if bt != 0 {
        fn_0 = s;
    }
    if fn_0 < 0 as libc::c_longlong {
        fn_0 = 0 as libc::c_int as I;
    }
    if fb < 0 as libc::c_longlong {
        fb = 0 as libc::c_int as I;
    }
    if 0 as libc::c_longlong > s - 1 as libc::c_longlong {
        tmp___23 = 0 as libc::c_int as I;
    } else {
        tmp___23 = s - 1 as libc::c_longlong;
    }
    if fb < tmp___23 {
        fb = fb;
    } else {
        if 0 as libc::c_longlong > s - 1 as libc::c_longlong {
            tmp___22 = 0 as libc::c_int as I;
        } else {
            tmp___22 = s - 1 as libc::c_longlong;
        }
        fb = tmp___22;
    }
    if fb + fn_0 > s {
        fn_0 = s - fb;
    }
    tmp___24 = CSK(ff);
    tmp___25 = open(tmp___24 as *const libc::c_char, 0 as libc::c_int);
    f = tmp___25 as I;
    if f < 0 as libc::c_longlong {
        tmp___26 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___26;
    }
    tmp___30 = mmap(
        0 as *mut libc::c_void,
        fn_0 as size_t,
        1 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        fb as __off_t,
    );
    v = tmp___30 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___27 = __errno_location();
        tmp___28 = strerror(*tmp___27);
        tmp___29 = kerr(tmp___28 as cS);
        return tmp___29;
    }
    tmp___31 = close(f as libc::c_int);
    r = tmp___31 as I;
    if r != 0 {
        tmp___32 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___32;
    }
    r = 0 as libc::c_int as I;
    t = 0 as libc::c_int as I;
    i___1 = 0 as libc::c_int as I;
    _i___2 = fn_0;
    while i___1 < _i___2 {
        if *v.offset((fb + i___1) as isize) as libc::c_int == 10 as libc::c_int {
            if t == w___0 - 1 as libc::c_longlong {
                r += 1;
                t = 0 as libc::c_int as I;
            } else {
                t = 0 as libc::c_int as I;
            }
        } else {
            t += 1;
        }
        i___1 += 1;
    }
    z = newK(0 as libc::c_int as I, fc);
    if !z.is_null() {
        e = 0 as libc::c_int as I;
        i___2 = 0 as libc::c_int as I;
        _i___3 = cn;
        loop {
            if !(i___2 < _i___3) {
                current_block = 4466262843398566590;
                break;
            }
            g = *(((*c).k).as_mut_ptr() as *mut C).offset(i___2 as isize);
            if !(32 as libc::c_int == g as libc::c_int) {
                tmp___33 = e;
                e += 1;
                tmp___35 = charpos(
                    b"CIF S\0" as *const u8 as *const libc::c_char as S,
                    g,
                );
                tmp___34 = newK(-tmp___35, r);
                let ref mut fresh2 = *((*z).k).as_mut_ptr().offset(tmp___33 as isize);
                *fresh2 = tmp___34;
                if tmp___34.is_null() {
                    cd(z);
                    z = 0 as K;
                    current_block = 14540882151398205778;
                    break;
                }
            }
            i___2 += 1;
        }
        match current_block {
            14540882151398205778 => {}
            _ => {
                u = 0 as libc::c_int as I;
                p = 0 as libc::c_int as I;
                while u <= fn_0 - w___0 {
                    while u + t < fn_0 {
                        if !(10 as libc::c_int
                            != *v.offset((u + t) as isize) as libc::c_int)
                        {
                            break;
                        }
                        t += 1;
                    }
                    if t == w___0 - 1 as libc::c_longlong {
                        if 10 as libc::c_int
                            == *v.offset((u + t) as isize) as libc::c_int
                        {
                            y = u;
                            x___0 = 0 as libc::c_int as I;
                            e = x___0;
                            q = 0 as K;
                            i___3 = 0 as libc::c_int as I;
                            _i___4 = cn;
                            while i___3 < _i___4 {
                                x___0 = *(((*d___0).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize);
                                tmp___36 = e;
                                e += 1;
                                k = *((*z).k).as_mut_ptr().offset(tmp___36 as isize);
                                match *(((*c).k).as_mut_ptr() as *mut C)
                                    .offset(i___3 as isize) as libc::c_int
                                {
                                    32 => {
                                        e -= 1;
                                    }
                                    73 => {
                                        m = strdupn(v.offset(y as isize), x___0);
                                        if m.is_null() {
                                            return 0 as K;
                                        }
                                        q = formKiCS(m);
                                        if !q.is_null() {
                                            *(((*k).k).as_mut_ptr() as *mut I)
                                                .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut I);
                                        } else {
                                            *(((*k).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    p as isize,
                                                ) = (-(0x7fffffffffffffff as libc::c_long)
                                                - 1 as libc::c_int as libc::c_long) as I;
                                        }
                                        free(m as *mut libc::c_void);
                                    }
                                    70 => {
                                        m = strdupn(v.offset(y as isize), x___0);
                                        if m.is_null() {
                                            return 0 as K;
                                        }
                                        q = formKfCS(m);
                                        if !q.is_null() {
                                            *(((*k).k).as_mut_ptr() as *mut F)
                                                .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut F);
                                        } else {
                                            *(((*k).k).as_mut_ptr() as *mut F)
                                                .offset(
                                                    p as isize,
                                                ) = 0 as libc::c_int as libc::c_double / 0.0f64;
                                        }
                                        free(m as *mut libc::c_void);
                                    }
                                    67 => {
                                        q = newK(-(3 as libc::c_int) as I, x___0);
                                        if q.is_null() {
                                            return 0 as K;
                                        }
                                        memcpy(
                                            ((*q).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                                            v.offset(y as isize) as *const libc::c_void,
                                            x___0 as size_t,
                                        );
                                        let ref mut fresh3 = *((*k).k)
                                            .as_mut_ptr()
                                            .offset(p as isize);
                                        *fresh3 = q;
                                        q = 0 as K;
                                    }
                                    83 => {
                                        m = strdupn(v.offset(y as isize), x___0);
                                        if m.is_null() {
                                            return 0 as K;
                                        }
                                        let ref mut fresh4 = *(((*k).k).as_mut_ptr() as *mut S)
                                            .offset(p as isize);
                                        *fresh4 = sp(m);
                                        free(m as *mut libc::c_void);
                                    }
                                    _ => {}
                                }
                                y += x___0;
                                i___3 += 1;
                            }
                            p += 1;
                        }
                    }
                    u += t + 1 as libc::c_longlong;
                    t = 0 as libc::c_int as I;
                }
            }
        }
    }
    tmp___37 = munmap(v as *mut libc::c_void, s as size_t);
    res = tmp___37 as I;
    if res != 0 {
        tmp___38 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___38;
    }
    return z;
}
unsafe extern "C" fn _0d_rdDsv(mut a: K, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut z: K = 0 as *mut k0;
    let mut res: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut cn: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut x___0: *mut C = 0 as *mut C;
    let mut w___0: C = 0;
    let mut fb: I = 0;
    let mut fn_0: I = 0;
    let mut s: I = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: S = 0 as *mut C;
    let mut tmp___6: I = 0;
    let mut f: I = 0;
    let mut tmp___7: S = 0 as *mut C;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut tmp___10: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut fc: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut e: I = 0;
    let mut g: C = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: *mut k0 = 0 as *mut k0;
    let mut tmp___20: I = 0;
    let mut m: S = 0 as *mut C;
    let mut u: I = 0;
    let mut t: I = 0;
    let mut p: I = 0;
    let mut n: I = 0;
    let mut h: I = 0;
    let mut tok: *mut C = 0 as *mut C;
    let mut y: [C; 2] = [0; 2];
    let mut k: K = 0 as *mut k0;
    let mut q: K = 0 as *mut k0;
    let mut tmp___21: I = 0;
    let mut tmp___22: I = 0;
    let mut tmp___23: size_t = 0;
    let mut tmp___24: I = 0;
    let mut tmp___25: I = 0;
    let mut tmp___26: size_t = 0;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: K = 0 as *mut k0;
    z = 0 as K;
    an = (*a).n;
    bt = (*b___1).t;
    if an != 2 as libc::c_longlong {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    c = *((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    d___0 = *((*a).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    cn = (*c).n;
    if bt < 0 as libc::c_longlong {
        tmp___1 = -bt;
    } else {
        tmp___1 = bt;
    }
    if 3 as libc::c_longlong != tmp___1 {
        if 4 as libc::c_longlong != bt {
            if 0 as libc::c_longlong != bt {
                tmp___0 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___0;
            }
        }
    }
    x___0 = ((*d___0).k).as_mut_ptr() as *mut C;
    w___0 = *x___0;
    fb = 0 as libc::c_int as I;
    fn_0 = 0 as libc::c_int as I;
    tmp___5 = CSK(b___1);
    tmp___6 = stat_sz(tmp___5, &mut s);
    if tmp___6 != 0 {
        tmp___2 = __errno_location();
        tmp___3 = strerror(*tmp___2);
        tmp___4 = kerr(tmp___3 as cS);
        return tmp___4;
    }
    if bt != 0 {
        fn_0 = s;
    }
    tmp___7 = CSK(b___1);
    tmp___8 = open(tmp___7 as *const libc::c_char, 0 as libc::c_int);
    f = tmp___8 as I;
    if f < 0 as libc::c_longlong {
        tmp___9 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___9;
    }
    tmp___13 = mmap(
        0 as *mut libc::c_void,
        fn_0 as size_t,
        1 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        fb as __off_t,
    );
    v = tmp___13 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        printf(b"mmap failed\n\0" as *const u8 as *const libc::c_char);
        tmp___10 = __errno_location();
        tmp___11 = strerror(*tmp___10);
        tmp___12 = kerr(tmp___11 as cS);
        return tmp___12;
    }
    tmp___14 = close(f as libc::c_int);
    r = tmp___14 as I;
    if r != 0 {
        tmp___15 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___15;
    }
    fc = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = cn;
    while i < _i___0 {
        if !(32 as libc::c_int
            == *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize) as libc::c_int)
        {
            tmp___17 = stringHasChar(
                b"IFCS\0" as *const u8 as *const libc::c_char as S,
                *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize),
            );
            if tmp___17 != 0 {
                fc += 1;
            } else {
                tmp___16 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___16;
            }
        }
        i += 1;
    }
    r = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = fn_0;
    while i___0 < _i___1 {
        if *v.offset((fb + i___0) as isize) as libc::c_int == 10 as libc::c_int {
            r += 1;
        }
        i___0 += 1;
    }
    if *v.offset((fn_0 - 1 as libc::c_longlong) as isize) as libc::c_int
        != 10 as libc::c_int
    {
        r += 1;
    }
    z = newK(0 as libc::c_int as I, fc);
    if !z.is_null() {
        e = 0 as libc::c_int as I;
        i___1 = 0 as libc::c_int as I;
        _i___2 = cn;
        loop {
            if !(i___1 < _i___2) {
                current_block = 1417769144978639029;
                break;
            }
            g = *(((*c).k).as_mut_ptr() as *mut C).offset(i___1 as isize);
            if !(32 as libc::c_int == g as libc::c_int) {
                tmp___18 = e;
                e += 1;
                tmp___20 = charpos(
                    b"CIF S\0" as *const u8 as *const libc::c_char as S,
                    g,
                );
                tmp___19 = newK(-tmp___20, r);
                let ref mut fresh5 = *((*z).k).as_mut_ptr().offset(tmp___18 as isize);
                *fresh5 = tmp___19;
                if tmp___19.is_null() {
                    cd(z);
                    z = 0 as K;
                    current_block = 448448760264375298;
                    break;
                }
            }
            i___1 += 1;
        }
        match current_block {
            448448760264375298 => {}
            _ => {
                u = 0 as libc::c_int as I;
                t = 0 as libc::c_int as I;
                p = 0 as libc::c_int as I;
                n = 0 as libc::c_int as I;
                h = 0 as libc::c_int as I;
                y[0 as libc::c_int as usize] = w___0;
                while u <= fn_0 {
                    while u + t <= fn_0 {
                        if !(10 as libc::c_int
                            != *v.offset((u + t) as isize) as libc::c_int)
                        {
                            break;
                        }
                        if !(*v.offset((u + t) as isize) as L
                            != 0 as *mut libc::c_void as L)
                        {
                            break;
                        }
                        t += 1;
                    }
                    let mut current_block_179: u64;
                    if *v.offset((u + t) as isize) as libc::c_int == 10 as libc::c_int {
                        current_block_179 = 11790934359944326792;
                    } else if *v.offset((u + t) as isize) as L
                            == 0 as *mut libc::c_void as L
                        {
                        current_block_179 = 11790934359944326792;
                    } else {
                        current_block_179 = 9812798724717783973;
                    }
                    match current_block_179 {
                        11790934359944326792 => {
                            q = 0 as K;
                            h = 0 as libc::c_int as I;
                            e = h;
                            m = strdupn(v.offset(u as isize), t);
                            if m.is_null() {
                                return 0 as K;
                            }
                            if *m.offset(0 as libc::c_int as isize) as L
                                != 0 as *mut libc::c_void as L
                            {
                                tok = strsep(
                                    &mut m as *mut S as *mut *mut libc::c_char,
                                    y.as_mut_ptr() as *const libc::c_char,
                                );
                                tmp___21 = e;
                                e += 1;
                                k = *((*z).k).as_mut_ptr().offset(tmp___21 as isize);
                                tmp___22 = h;
                                h += 1;
                                match *(((*c).k).as_mut_ptr() as *mut C)
                                    .offset(tmp___22 as isize) as libc::c_int
                                {
                                    32 => {
                                        e -= 1;
                                    }
                                    73 => {
                                        q = formKiCS(tok);
                                        if !q.is_null() {
                                            *(((*k).k).as_mut_ptr() as *mut I)
                                                .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut I);
                                        } else {
                                            *(((*k).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    p as isize,
                                                ) = (-(0x7fffffffffffffff as libc::c_long)
                                                - 1 as libc::c_int as libc::c_long) as I;
                                        }
                                    }
                                    70 => {
                                        q = formKfCS(tok);
                                        if !q.is_null() {
                                            *(((*k).k).as_mut_ptr() as *mut F)
                                                .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut F);
                                        } else {
                                            *(((*k).k).as_mut_ptr() as *mut F)
                                                .offset(
                                                    p as isize,
                                                ) = 0 as libc::c_int as libc::c_double / 0.0f64;
                                        }
                                    }
                                    67 => {
                                        tmp___23 = strlen(tok as *const libc::c_char);
                                        n = tmp___23 as I;
                                        q = newK(-(3 as libc::c_int) as I, n);
                                        if q.is_null() {
                                            return 0 as K;
                                        }
                                        memcpy(
                                            ((*q).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                                            tok as *const libc::c_void,
                                            n as size_t,
                                        );
                                        let ref mut fresh6 = *((*k).k)
                                            .as_mut_ptr()
                                            .offset(p as isize);
                                        *fresh6 = q;
                                        q = 0 as K;
                                    }
                                    83 => {
                                        let ref mut fresh7 = *(((*k).k).as_mut_ptr() as *mut S)
                                            .offset(p as isize);
                                        *fresh7 = sp(tok);
                                    }
                                    _ => {}
                                }
                                while tok as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tok = strsep(
                                        &mut m as *mut S as *mut *mut libc::c_char,
                                        y.as_mut_ptr() as *const libc::c_char,
                                    );
                                    if tok as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___24 = e;
                                        e += 1;
                                        k = *((*z).k).as_mut_ptr().offset(tmp___24 as isize);
                                        tmp___25 = h;
                                        h += 1;
                                        match *(((*c).k).as_mut_ptr() as *mut C)
                                            .offset(tmp___25 as isize) as libc::c_int
                                        {
                                            32 => {
                                                e -= 1;
                                            }
                                            73 => {
                                                q = formKiCS(tok);
                                                if !q.is_null() {
                                                    *(((*k).k).as_mut_ptr() as *mut I)
                                                        .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut I);
                                                } else {
                                                    *(((*k).k).as_mut_ptr() as *mut I)
                                                        .offset(
                                                            p as isize,
                                                        ) = (-(0x7fffffffffffffff as libc::c_long)
                                                        - 1 as libc::c_int as libc::c_long) as I;
                                                }
                                            }
                                            70 => {
                                                q = formKfCS(tok);
                                                if !q.is_null() {
                                                    *(((*k).k).as_mut_ptr() as *mut F)
                                                        .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut F);
                                                } else {
                                                    *(((*k).k).as_mut_ptr() as *mut F)
                                                        .offset(
                                                            p as isize,
                                                        ) = 0 as libc::c_int as libc::c_double / 0.0f64;
                                                }
                                            }
                                            67 => {
                                                tmp___26 = strlen(tok as *const libc::c_char);
                                                n = tmp___26 as I;
                                                q = newK(-(3 as libc::c_int) as I, n);
                                                if q.is_null() {
                                                    return 0 as K;
                                                }
                                                memcpy(
                                                    ((*q).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                                                    tok as *const libc::c_void,
                                                    n as size_t,
                                                );
                                                let ref mut fresh8 = *((*k).k)
                                                    .as_mut_ptr()
                                                    .offset(p as isize);
                                                *fresh8 = q;
                                                q = 0 as K;
                                            }
                                            83 => {
                                                let ref mut fresh9 = *(((*k).k).as_mut_ptr() as *mut S)
                                                    .offset(p as isize);
                                                *fresh9 = sp(tok);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                            free(m as *mut libc::c_void);
                        }
                        _ => {}
                    }
                    p += 1;
                    u += t + 1 as libc::c_longlong;
                    t = 0 as libc::c_int as I;
                }
            }
        }
    }
    tmp___27 = munmap(v as *mut libc::c_void, s as size_t);
    res = tmp___27 as I;
    if res != 0 {
        tmp___28 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___28;
    }
    return z;
}
unsafe extern "C" fn _0d_rdDsvWc(mut a: K, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut z: K = 0 as *mut k0;
    let mut res: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut cn: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut x___0: *mut C = 0 as *mut C;
    let mut w___0: C = 0;
    let mut fb: I = 0;
    let mut fn_0: I = 0;
    let mut s: I = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: S = 0 as *mut C;
    let mut tmp___6: I = 0;
    let mut f: I = 0;
    let mut tmp___7: S = 0 as *mut C;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut tmp___10: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut fc: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut e: I = 0;
    let mut g: C = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: *mut k0 = 0 as *mut k0;
    let mut tmp___20: I = 0;
    let mut m: S = 0 as *mut C;
    let mut u: I = 0;
    let mut t: I = 0;
    let mut p: I = 0;
    let mut n: I = 0;
    let mut h: I = 0;
    let mut tok: *mut C = 0 as *mut C;
    let mut y: [C; 2] = [0; 2];
    let mut k: K = 0 as *mut k0;
    let mut tmp___21: I = 0;
    let mut tmp___22: I = 0;
    let mut tmp___23: I = 0;
    let mut tmp___24: I = 0;
    let mut tmp___25: I = 0;
    let mut tmp___26: I = 0;
    let mut tmp___27: I = 0;
    let mut q: K = 0 as *mut k0;
    let mut tmp___28: I = 0;
    let mut tmp___29: I = 0;
    let mut tmp___30: size_t = 0;
    let mut tmp___31: I = 0;
    let mut tmp___32: I = 0;
    let mut tmp___33: size_t = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: K = 0 as *mut k0;
    z = 0 as K;
    an = (*a).n;
    bt = (*b___1).t;
    if an != 2 as libc::c_longlong {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    c = *((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    d___0 = *((*a).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    cn = (*c).n;
    if bt < 0 as libc::c_longlong {
        tmp___1 = -bt;
    } else {
        tmp___1 = bt;
    }
    if 3 as libc::c_longlong != tmp___1 {
        if 4 as libc::c_longlong != bt {
            if 0 as libc::c_longlong != bt {
                tmp___0 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___0;
            }
        }
    }
    x___0 = ((*d___0).k).as_mut_ptr() as *mut C;
    w___0 = *x___0;
    fb = 0 as libc::c_int as I;
    fn_0 = 0 as libc::c_int as I;
    tmp___5 = CSK(b___1);
    tmp___6 = stat_sz(tmp___5, &mut s);
    if tmp___6 != 0 {
        tmp___2 = __errno_location();
        tmp___3 = strerror(*tmp___2);
        tmp___4 = kerr(tmp___3 as cS);
        return tmp___4;
    }
    if bt != 0 {
        fn_0 = s;
    }
    tmp___7 = CSK(b___1);
    tmp___8 = open(tmp___7 as *const libc::c_char, 0 as libc::c_int);
    f = tmp___8 as I;
    if f < 0 as libc::c_longlong {
        tmp___9 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___9;
    }
    tmp___13 = mmap(
        0 as *mut libc::c_void,
        fn_0 as size_t,
        1 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        fb as __off_t,
    );
    v = tmp___13 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        printf(b"mmap failed\n\0" as *const u8 as *const libc::c_char);
        tmp___10 = __errno_location();
        tmp___11 = strerror(*tmp___10);
        tmp___12 = kerr(tmp___11 as cS);
        return tmp___12;
    }
    tmp___14 = close(f as libc::c_int);
    r = tmp___14 as I;
    if r != 0 {
        tmp___15 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___15;
    }
    fc = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = cn;
    while i < _i___0 {
        if !(32 as libc::c_int
            == *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize) as libc::c_int)
        {
            tmp___17 = stringHasChar(
                b"IFCS\0" as *const u8 as *const libc::c_char as S,
                *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize),
            );
            if tmp___17 != 0 {
                fc += 1;
            } else {
                tmp___16 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___16;
            }
        }
        i += 1;
    }
    r = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = fn_0;
    while i___0 < _i___1 {
        if *v.offset((fb + i___0) as isize) as libc::c_int == 10 as libc::c_int {
            r += 1;
        }
        i___0 += 1;
    }
    if *v.offset((fn_0 - 1 as libc::c_longlong) as isize) as libc::c_int
        != 10 as libc::c_int
    {
        r += 1;
    }
    z = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    if !z.is_null() {
        let ref mut fresh10 = *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        *fresh10 = newK(-(4 as libc::c_int) as I, fc);
        let ref mut fresh11 = *((*z).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        *fresh11 = newK(0 as libc::c_int as I, fc);
        e = 0 as libc::c_int as I;
        i___1 = 0 as libc::c_int as I;
        _i___2 = cn;
        loop {
            if !(i___1 < _i___2) {
                current_block = 17372050596571538954;
                break;
            }
            g = *(((*c).k).as_mut_ptr() as *mut C).offset(i___1 as isize);
            if !(32 as libc::c_int == g as libc::c_int) {
                tmp___18 = e;
                e += 1;
                tmp___20 = charpos(
                    b"CIF S\0" as *const u8 as *const libc::c_char as S,
                    g,
                );
                tmp___19 = newK(-tmp___20, r - 1 as libc::c_longlong);
                let ref mut fresh12 = *((**((*z).k)
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .k)
                    .as_mut_ptr()
                    .offset(tmp___18 as isize);
                *fresh12 = tmp___19;
                if tmp___19.is_null() {
                    cd(z);
                    z = 0 as K;
                    current_block = 5957905166125253327;
                    break;
                }
            }
            i___1 += 1;
        }
        match current_block {
            5957905166125253327 => {}
            _ => {
                u = 0 as libc::c_int as I;
                t = 0 as libc::c_int as I;
                p = 0 as libc::c_int as I;
                n = 0 as libc::c_int as I;
                h = 0 as libc::c_int as I;
                y[0 as libc::c_int as usize] = w___0;
                while u <= fn_0 {
                    while u + t <= fn_0 {
                        if !(10 as libc::c_int
                            != *v.offset((u + t) as isize) as libc::c_int)
                        {
                            break;
                        }
                        if !(*v.offset((u + t) as isize) as L
                            != 0 as *mut libc::c_void as L)
                        {
                            break;
                        }
                        t += 1;
                    }
                    tmp___27 = n;
                    n += 1;
                    if 0 as libc::c_longlong == tmp___27 {
                        let mut current_block_149: u64;
                        if *v.offset((u + t) as isize) as libc::c_int
                            == 10 as libc::c_int
                        {
                            current_block_149 = 8570569067498838499;
                        } else if *v.offset((u + t) as isize) as L
                                == 0 as *mut libc::c_void as L
                            {
                            current_block_149 = 8570569067498838499;
                        } else {
                            current_block_149 = 4299703460566765016;
                        }
                        match current_block_149 {
                            8570569067498838499 => {
                                h = 0 as libc::c_int as I;
                                e = h;
                                m = strdupn(v.offset(u as isize), t);
                                if m.is_null() {
                                    return 0 as K;
                                }
                                if *m.offset(0 as libc::c_int as isize) as L
                                    != 0 as *mut libc::c_void as L
                                {
                                    tok = strsep(
                                        &mut m as *mut S as *mut *mut libc::c_char,
                                        y.as_mut_ptr() as *const libc::c_char,
                                    );
                                    tmp___21 = e;
                                    e += 1;
                                    k = *((*z).k).as_mut_ptr().offset(tmp___21 as isize);
                                    tmp___23 = h;
                                    h += 1;
                                    if *(((*c).k).as_mut_ptr() as *mut C)
                                        .offset(tmp___23 as isize) as libc::c_int
                                        == 32 as libc::c_int
                                    {
                                        e -= 1;
                                    } else {
                                        tmp___22 = p;
                                        p += 1;
                                        let ref mut fresh13 = *(((**((*z).k)
                                            .as_mut_ptr()
                                            .offset(0 as libc::c_int as isize))
                                            .k)
                                            .as_mut_ptr() as *mut S)
                                            .offset(tmp___22 as isize);
                                        *fresh13 = sp(tok);
                                    }
                                    while tok as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tok = strsep(
                                            &mut m as *mut S as *mut *mut libc::c_char,
                                            y.as_mut_ptr() as *const libc::c_char,
                                        );
                                        if tok as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___24 = e;
                                            e += 1;
                                            k = *((*z).k).as_mut_ptr().offset(tmp___24 as isize);
                                            tmp___26 = h;
                                            h += 1;
                                            if *(((*c).k).as_mut_ptr() as *mut C)
                                                .offset(tmp___26 as isize) as libc::c_int
                                                == 32 as libc::c_int
                                            {
                                                e -= 1;
                                            } else {
                                                tmp___25 = p;
                                                p += 1;
                                                let ref mut fresh14 = *(((**((*z).k)
                                                    .as_mut_ptr()
                                                    .offset(0 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr() as *mut S)
                                                    .offset(tmp___25 as isize);
                                                *fresh14 = sp(tok);
                                            }
                                        }
                                    }
                                }
                                free(m as *mut libc::c_void);
                                p = 0 as libc::c_int as I;
                            }
                            _ => {}
                        }
                    }
                    if n > 1 as libc::c_longlong {
                        let mut current_block_227: u64;
                        if *v.offset((u + t) as isize) as libc::c_int
                            == 10 as libc::c_int
                        {
                            current_block_227 = 16528315778843178523;
                        } else if *v.offset((u + t) as isize) as L
                                == 0 as *mut libc::c_void as L
                            {
                            current_block_227 = 16528315778843178523;
                        } else {
                            current_block_227 = 8120009455218959897;
                        }
                        match current_block_227 {
                            16528315778843178523 => {
                                q = 0 as K;
                                h = 0 as libc::c_int as I;
                                e = h;
                                m = strdupn(v.offset(u as isize), t);
                                if m.is_null() {
                                    return 0 as K;
                                }
                                if *m.offset(0 as libc::c_int as isize) as L
                                    != 0 as *mut libc::c_void as L
                                {
                                    tok = strsep(
                                        &mut m as *mut S as *mut *mut libc::c_char,
                                        y.as_mut_ptr() as *const libc::c_char,
                                    );
                                    tmp___28 = e;
                                    e += 1;
                                    k = *((**((*z).k)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr()
                                        .offset(tmp___28 as isize);
                                    tmp___29 = h;
                                    h += 1;
                                    match *(((*c).k).as_mut_ptr() as *mut C)
                                        .offset(tmp___29 as isize) as libc::c_int
                                    {
                                        32 => {
                                            e -= 1;
                                        }
                                        73 => {
                                            q = formKiCS(tok);
                                            if !q.is_null() {
                                                *(((*k).k).as_mut_ptr() as *mut I)
                                                    .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut I);
                                            } else {
                                                *(((*k).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        p as isize,
                                                    ) = (-(0x7fffffffffffffff as libc::c_long)
                                                    - 1 as libc::c_int as libc::c_long) as I;
                                            }
                                        }
                                        70 => {
                                            q = formKfCS(tok);
                                            if !q.is_null() {
                                                *(((*k).k).as_mut_ptr() as *mut F)
                                                    .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut F);
                                            } else {
                                                *(((*k).k).as_mut_ptr() as *mut F)
                                                    .offset(
                                                        p as isize,
                                                    ) = 0 as libc::c_int as libc::c_double / 0.0f64;
                                            }
                                        }
                                        67 => {
                                            tmp___30 = strlen(tok as *const libc::c_char);
                                            n = tmp___30 as I;
                                            q = newK(-(3 as libc::c_int) as I, n);
                                            if n == 0 {
                                                n += 1;
                                            }
                                            memcpy(
                                                ((*q).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                                                tok as *const libc::c_void,
                                                n as size_t,
                                            );
                                            let ref mut fresh15 = *((*k).k)
                                                .as_mut_ptr()
                                                .offset(p as isize);
                                            *fresh15 = q;
                                            q = 0 as K;
                                        }
                                        83 => {
                                            let ref mut fresh16 = *(((*k).k).as_mut_ptr() as *mut S)
                                                .offset(p as isize);
                                            *fresh16 = sp(tok);
                                        }
                                        _ => {}
                                    }
                                    while tok as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tok = strsep(
                                            &mut m as *mut S as *mut *mut libc::c_char,
                                            y.as_mut_ptr() as *const libc::c_char,
                                        );
                                        if tok as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___31 = e;
                                            e += 1;
                                            k = *((**((*z).k)
                                                .as_mut_ptr()
                                                .offset(1 as libc::c_int as isize))
                                                .k)
                                                .as_mut_ptr()
                                                .offset(tmp___31 as isize);
                                            tmp___32 = h;
                                            h += 1;
                                            match *(((*c).k).as_mut_ptr() as *mut C)
                                                .offset(tmp___32 as isize) as libc::c_int
                                            {
                                                32 => {
                                                    e -= 1;
                                                }
                                                73 => {
                                                    q = formKiCS(tok);
                                                    if !q.is_null() {
                                                        *(((*k).k).as_mut_ptr() as *mut I)
                                                            .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut I);
                                                    } else {
                                                        *(((*k).k).as_mut_ptr() as *mut I)
                                                            .offset(
                                                                p as isize,
                                                            ) = (-(0x7fffffffffffffff as libc::c_long)
                                                            - 1 as libc::c_int as libc::c_long) as I;
                                                    }
                                                }
                                                70 => {
                                                    q = formKfCS(tok);
                                                    if !q.is_null() {
                                                        *(((*k).k).as_mut_ptr() as *mut F)
                                                            .offset(p as isize) = *(((*q).k).as_mut_ptr() as *mut F);
                                                    } else {
                                                        *(((*k).k).as_mut_ptr() as *mut F)
                                                            .offset(
                                                                p as isize,
                                                            ) = 0 as libc::c_int as libc::c_double / 0.0f64;
                                                    }
                                                }
                                                67 => {
                                                    tmp___33 = strlen(tok as *const libc::c_char);
                                                    n = tmp___33 as I;
                                                    q = newK(-(3 as libc::c_int) as I, n);
                                                    if n == 0 {
                                                        n += 1;
                                                    }
                                                    memcpy(
                                                        ((*q).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                                                        tok as *const libc::c_void,
                                                        n as size_t,
                                                    );
                                                    let ref mut fresh17 = *((*k).k)
                                                        .as_mut_ptr()
                                                        .offset(p as isize);
                                                    *fresh17 = q;
                                                    q = 0 as K;
                                                }
                                                83 => {
                                                    let ref mut fresh18 = *(((*k).k).as_mut_ptr() as *mut S)
                                                        .offset(p as isize);
                                                    *fresh18 = sp(tok);
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                                free(m as *mut libc::c_void);
                                p += 1;
                            }
                            _ => {}
                        }
                    }
                    u += t + 1 as libc::c_longlong;
                    t = 0 as libc::c_int as I;
                }
            }
        }
    }
    tmp___34 = munmap(v as *mut libc::c_void, s as size_t);
    res = tmp___34 as I;
    if res != 0 {
        tmp___35 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___35;
    }
    return z;
}
pub unsafe extern "C" fn _1m(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___1: S = 0 as *mut C;
    let mut sm: I = 0;
    let mut tmp___2: size_t = 0;
    let mut e: S = 0 as *mut C;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___4: S = 0 as *mut C;
    let mut tmp___5: S = 0 as *mut C;
    let mut c: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut f: I = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut s: I = 0;
    let mut r: I = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut tmp___12: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut b___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: K = 0 as *mut k0;
    if 4 as libc::c_longlong != (*x___0).t {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___0 = -(*x___0).t;
        } else {
            tmp___0 = (*x___0).t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___1 = CSK(x___0);
    m = tmp___1;
    tmp___2 = strlen(m as *const libc::c_char);
    sm = tmp___2 as I;
    if sm > 1 as libc::c_longlong {
        if 46 as libc::c_int
            == *m.offset((sm - 2 as libc::c_longlong) as isize) as libc::c_int
        {
            if *(b"K\0" as *const u8 as *const libc::c_char) as libc::c_int
                == *m.offset((sm - 1 as libc::c_longlong) as isize) as libc::c_int
            {
                tmp___3 = strdupn(m, sm);
                tmp___5 = tmp___3;
            } else {
                tmp___4 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
                tmp___5 = tmp___4;
            }
        } else {
            tmp___4 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
            tmp___5 = tmp___4;
        }
    } else {
        tmp___4 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
        tmp___5 = tmp___4;
    }
    e = tmp___5;
    if e.is_null() {
        return 0 as K;
    }
    tmp___6 = open(e as *const libc::c_char, 2 as libc::c_int);
    f = tmp___6 as I;
    if f >= 0 as libc::c_longlong {
        stat(e as *const libc::c_char, &mut c as *mut stat);
    } else {
        tmp___7 = open(m as *const libc::c_char, 2 as libc::c_int);
        f = tmp___7 as I;
        stat(m as *const libc::c_char, &mut c as *mut stat);
    }
    free(e as *mut libc::c_void);
    if f < 0 as libc::c_longlong {
        tmp___8 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___8;
    }
    s = c.st_size as I;
    if (s as libc::c_ulonglong)
        < (4 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as libc::c_ulonglong
    {
        tmp___9 = close(f as libc::c_int);
        r = tmp___9 as I;
        if r != 0 {
            tmp___10 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
            return tmp___10;
        }
        tmp___11 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp___11;
    }
    tmp___15 = mmap(
        0 as *mut libc::c_void,
        s as size_t,
        3 as libc::c_int,
        16386 as libc::c_int,
        f as libc::c_int,
        0 as libc::c_int as __off_t,
    );
    v = tmp___15 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___12 = __errno_location();
        tmp___13 = strerror(*tmp___12);
        tmp___14 = kerr(tmp___13 as cS);
        return tmp___14;
    }
    b___1 = 0 as libc::c_int as I;
    tmp___16 = _1m_r(f, v as V, v as V, v.offset(s as isize) as V, &mut b___1);
    z = tmp___16;
    tmp___17 = close(f as libc::c_int);
    r = tmp___17 as I;
    if r != 0 {
        tmp___18 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___18;
    }
    tmp___19 = munmap(v as *mut libc::c_void, s as size_t);
    r = tmp___19 as I;
    if r != 0 {
        tmp___20 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___20;
    }
    return z;
}
unsafe extern "C" fn _1m_r(
    mut f: I,
    mut fixed: V,
    mut v: V,
    mut aft: V,
    mut b___1: *mut I,
) -> K {
    let mut s: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut w___0: *mut I = 0 as *mut I;
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut r: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut u: S = 0 as *mut C;
    let mut length: I = 0;
    let mut offset: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut mod___0: I = 0;
    let mut tmp___6: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: libc::c_ulonglong = 0;
    s = aft.offset_from(v) as libc::c_long as I;
    if (s as libc::c_ulonglong)
        < (4 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as libc::c_ulonglong
    {
        tmp = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    w___0 = v as *mut I;
    t = *w___0.offset(2 as libc::c_int as isize);
    n = *w___0.offset(3 as libc::c_int as isize);
    if t < -(4 as libc::c_longlong) {
        tmp___0 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    } else {
        if t > 7 as libc::c_longlong {
            tmp___0 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        } else {
            if n < 0 as libc::c_longlong {
                tmp___0 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
                return tmp___0;
            }
        }
    }
    if t < 0 as libc::c_longlong {
        tmp___2 = -t;
    } else {
        tmp___2 = t;
    }
    if 4 as libc::c_longlong == tmp___2 {
        tmp___1 = _2m_r(v, aft, b___1);
        return tmp___1;
    } else {
        if 7 as libc::c_longlong == t {
            tmp___1 = _2m_r(v, aft, b___1);
            return tmp___1;
        } else {
            if 1 as libc::c_longlong <= t {
                if t <= 3 as libc::c_longlong {
                    tmp___1 = _2m_r(v, aft, b___1);
                    return tmp___1;
                }
            }
            if 6 as libc::c_longlong == t {
                tmp___1 = _2m_r(v, aft, b___1);
                return tmp___1;
            }
        }
    }
    r = (4 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
        as I;
    if 0 as libc::c_longlong != t {
        if 5 as libc::c_longlong != t {
            tmp___3 = bp(t);
            r = (r as libc::c_ulonglong)
                .wrapping_add(
                    ((tmp___3 * n + (-(3 as libc::c_longlong) == t) as libc::c_int as I)
                        as libc::c_ulonglong)
                        .wrapping_sub(
                            ((t > 0 as libc::c_longlong) as libc::c_int as libc::c_ulong)
                                .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
                                as libc::c_ulonglong,
                        ),
                ) as I;
        }
    }
    if r % 8 as libc::c_longlong > 0 as libc::c_longlong {
        r += 8 as libc::c_longlong - r % 8 as libc::c_longlong;
    }
    if s < r {
        tmp___4 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp___4;
    }
    let mut current_block_92: u64;
    if 0 as libc::c_longlong == t {
        current_block_92 = 7817757182227319199;
    } else if 5 as libc::c_longlong == t {
        current_block_92 = 7817757182227319199;
    } else {
        length = r;
        if t > 0 as libc::c_longlong {
            tmp___5 = 3 as libc::c_int;
        } else {
            tmp___5 = 4 as libc::c_int;
        }
        offset = (v.offset_from(fixed) as libc::c_long as libc::c_ulong)
            .wrapping_add(
                (tmp___5 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong),
            ) as I;
        mod___0 = offset;
        length += mod___0;
        offset -= mod___0;
        tmp___9 = mmap(
            0 as *mut libc::c_void,
            length as size_t,
            3 as libc::c_int,
            16386 as libc::c_int,
            f as libc::c_int,
            offset as __off_t,
        );
        u = tmp___9 as S;
        if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong
            == u as libc::c_ulong
        {
            tmp___6 = __errno_location();
            tmp___7 = strerror(*tmp___6);
            tmp___8 = kerr(tmp___7 as cS);
            return tmp___8;
        }
        mMap += length as F;
        mUsed += length as F;
        if mUsed > mMax {
            mMax = mUsed;
        }
        z = (u as V)
            .offset(mod___0 as isize)
            .offset(
                -((3 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong) as isize),
            ) as K;
        mrc(z, 1 as libc::c_int as I);
        current_block_92 = 17787701279558130514;
    }
    match current_block_92 {
        7817757182227319199 => {
            z = newK(t, n);
            i = 0 as libc::c_int as I;
            _i___0 = n;
            while i < _i___0 {
                x___0 = _1m_r(f, fixed, v.offset(r as isize), aft, &mut r);
                if x___0.is_null() {
                    cd(z);
                    return 0 as K;
                }
                let ref mut fresh19 = *((*z).k).as_mut_ptr().offset(i as isize);
                *fresh19 = x___0;
                i += 1;
            }
        }
        _ => {}
    }
    if r as libc::c_ulonglong
        > (4 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as libc::c_ulonglong
    {
        tmp___10 = r as libc::c_ulonglong;
    } else {
        tmp___10 = (4 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as libc::c_ulonglong;
    }
    *b___1 = (*b___1 as libc::c_ulonglong).wrapping_add(tmp___10) as I;
    return z;
}
pub unsafe extern "C" fn _1d(mut x___0: K, mut y: K) -> K {
    let mut t: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    t = (*x___0).t;
    if 4 as libc::c_longlong == t {
        tmp = _1d_write(x___0, y, 0 as libc::c_int as I);
        return tmp;
    } else {
        if -(3 as libc::c_longlong) == t {
            tmp = _1d_write(x___0, y, 0 as libc::c_int as I);
            return tmp;
        }
    }
    if t == 0 {
        tmp___0 = _1d_read(x___0, y);
        return tmp___0;
    }
    if 3 as libc::c_longlong == t {
        tmp___1 = _1d_char(x___0, y);
        return tmp___1;
    }
    tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
    return tmp___2;
}
unsafe extern "C" fn _1d_write(mut x___0: K, mut y: K, mut dosync: I) -> K {
    let mut n: I = 0;
    let mut tmp: I = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    let mut sm: I = 0;
    let mut tmp___1: size_t = 0;
    let mut e: S = 0 as *mut C;
    let mut tmp___2: S = 0 as *mut C;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___4: S = 0 as *mut C;
    let mut f: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: libc::c_int = 0;
    let mut v: S = 0 as *mut C;
    let mut tmp___13: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    tmp = disk(y);
    n = tmp;
    tmp___0 = CSK(x___0);
    m = tmp___0;
    tmp___1 = strlen(m as *const libc::c_char);
    sm = tmp___1 as I;
    if sm > 1 as libc::c_longlong {
        if 46 as libc::c_int
            == *m.offset((sm - 2 as libc::c_longlong) as isize) as libc::c_int
        {
            if *(b"K\0" as *const u8 as *const libc::c_char) as libc::c_int
                == *m.offset((sm - 1 as libc::c_longlong) as isize) as libc::c_int
            {
                tmp___2 = strdupn(m, sm);
                tmp___4 = tmp___2;
            } else {
                tmp___3 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
                tmp___4 = tmp___3;
            }
        } else {
            tmp___3 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
            tmp___4 = tmp___3;
        }
    } else {
        tmp___3 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
        tmp___4 = tmp___3;
    }
    e = tmp___4;
    if e.is_null() {
        return 0 as K;
    }
    tmp___5 = open(e as *const libc::c_char, 578 as libc::c_int, 4095 as libc::c_int);
    f = tmp___5 as I;
    free(e as *mut libc::c_void);
    if f < 0 as libc::c_longlong {
        tmp___6 = __errno_location();
        tmp___7 = strerror(*tmp___6);
        tmp___8 = kerr(tmp___7 as cS);
        return tmp___8;
    }
    tmp___12 = ftruncate(f as libc::c_int, n as __off_t);
    if tmp___12 != 0 {
        tmp___9 = __errno_location();
        tmp___10 = strerror(*tmp___9);
        tmp___11 = kerr(tmp___10 as cS);
        return tmp___11;
    }
    tmp___16 = mmap(
        0 as *mut libc::c_void,
        n as size_t,
        2 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        0 as libc::c_int as __off_t,
    );
    v = tmp___16 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___13 = __errno_location();
        tmp___14 = strerror(*tmp___13);
        tmp___15 = kerr(tmp___14 as cS);
        return tmp___15;
    }
    tmp___17 = close(f as libc::c_int);
    r = tmp___17 as I;
    if r != 0 {
        tmp___18 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___18;
    }
    wrep(y, v as V, 1 as libc::c_int as I);
    if dosync != 0 {
        msync(v as *mut libc::c_void, n as size_t, 6 as libc::c_int);
    }
    tmp___19 = munmap(v as *mut libc::c_void, n as size_t);
    r = tmp___19 as I;
    if r != 0 {
        tmp___20 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___20;
    }
    tmp___21 = _n();
    return tmp___21;
}
pub unsafe extern "C" fn wrep(mut x___0: K, mut v: V, mut y: I) -> I {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut w___0: *mut I = 0 as *mut I;
    let mut m: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut d___0: V = 0 as *mut libc::c_void;
    let mut e: I = 0;
    let mut r: I = 0;
    let mut s: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut point: V = 0 as *mut libc::c_void;
    let mut delta: I = 0;
    let mut tmp___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___1: size_t = 0;
    let mut k: K = 0 as *mut k0;
    let mut s___0: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut s___1: V = 0 as *mut libc::c_void;
    let mut b___1: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: size_t = 0;
    t = (*x___0).t;
    n = (*x___0).n;
    w___0 = v as *mut I;
    if y != 0 {
        tmp = 2 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    m = tmp as I;
    if y != 0 {
        *w___0 = -(3 as libc::c_int) as I;
        *w___0.offset(1 as libc::c_int as isize) = 1 as libc::c_int as I;
        *w___0.offset(2 as libc::c_int as isize) = t;
        *w___0.offset(3 as libc::c_int as isize) = n;
    } else {
        memcpy(
            w___0 as *mut libc::c_void,
            &mut (*x___0).t as *mut I as *const libc::c_void,
            (::std::mem::size_of::<I>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<I>() as libc::c_ulong),
        );
    }
    d___0 = w___0.offset(2 as libc::c_int as isize).offset(m as isize) as V;
    e = ((2 as libc::c_longlong + m) as libc::c_ulonglong)
        .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong)
        as I;
    if 0 as libc::c_longlong != t {
        if 5 as libc::c_longlong != t {
            if -(4 as libc::c_longlong) != t {
                e = rep(x___0, y);
            }
        }
    }
    r = 0 as libc::c_int as I;
    let mut current_block_95: u64;
    if 0 as libc::c_longlong == t {
        current_block_95 = 8058245720594617764;
    } else if 5 as libc::c_longlong == t {
        current_block_95 = 8058245720594617764;
    } else {
        if -(4 as libc::c_longlong) == t {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                tmp___1 = strlen(
                    *(((*x___0).k).as_mut_ptr() as *mut S).offset(i___0 as isize)
                        as *const libc::c_char,
                );
                s = (1 as libc::c_ulong).wrapping_add(tmp___1) as I;
                memcpy(
                    d___0.offset(r as isize),
                    *(((*x___0).k).as_mut_ptr() as *mut S).offset(i___0 as isize)
                        as *const libc::c_void,
                    s as size_t,
                );
                r += s;
                i___0 += 1;
            }
            if r % 8 as libc::c_longlong > 0 as libc::c_longlong {
                r += 8 as libc::c_longlong - r % 8 as libc::c_longlong;
            }
        } else {
            let mut current_block_93: u64;
            if 7 as libc::c_longlong == t {
                current_block_93 = 1532364226519578350;
            } else if 8 as libc::c_longlong == t {
                current_block_93 = 1532364226519578350;
            } else {
                s___1 = ((*x___0).k).as_mut_ptr() as V;
                tmp___4 = bp(t);
                if t < 0 as libc::c_longlong {
                    tmp___5 = -t;
                } else {
                    tmp___5 = t;
                }
                b___1 = n * tmp___4
                    + (3 as libc::c_longlong == tmp___5) as libc::c_int as I;
                if t > 0 as libc::c_longlong {
                    d___0 = d___0
                        .offset(-(::std::mem::size_of::<I>() as libc::c_ulong as isize));
                }
                if 4 as libc::c_longlong == t {
                    s___1 = *(((*x___0).k).as_mut_ptr() as *mut S) as V;
                    tmp___6 = strlen(
                        *(((*x___0).k).as_mut_ptr() as *mut S) as *const libc::c_char,
                    );
                    b___1 = (1 as libc::c_ulong).wrapping_add(tmp___6) as I;
                }
                if b___1 % 8 as libc::c_longlong > 0 as libc::c_longlong {
                    b___1 = 8 as libc::c_longlong * (b___1 / 8 as libc::c_longlong)
                        + (1 as libc::c_longlong + b___1 % 8 as libc::c_longlong);
                }
                memcpy(d___0, s___1 as *const libc::c_void, b___1 as size_t);
                current_block_93 = 15587532755333643506;
            }
            match current_block_93 {
                1532364226519578350 => {
                    if 1 as libc::c_longlong == (*x___0).n {
                        if 1 as libc::c_longlong
                            == (*(*(((*x___0).k).as_mut_ptr() as *mut V)
                                .offset(2 as libc::c_int as isize) as K))
                                .n - 1 as libc::c_longlong
                        {
                            if offsetColon as libc::c_ulong
                                == *(((**((*x___0).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr() as *mut S)
                                    .offset(0 as libc::c_int as isize) as V as libc::c_ulong
                            {
                                k = *(((*(*(((*x___0).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K))
                                    .k)
                                    .as_mut_ptr() as *mut S as *mut V) as K;
                                tmp___2 = sva(k as V);
                                s___0 = tmp___2;
                                if 1 as libc::c_longlong == s___0 {
                                    *w___0.offset(m as isize) = '\u{7}' as i32 as I;
                                } else {
                                    *w___0.offset(m as isize) = '\u{8}' as i32 as I;
                                }
                                *w___0
                                    .offset(
                                        (1 as libc::c_longlong + m) as isize,
                                    ) = offsetColon as L;
                            } else {
                                tmp___3 = kerr(
                                    b"syntax\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___3 as L;
                            }
                        } else {
                            tmp___3 = kerr(
                                b"syntax\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___3 as L;
                        }
                    } else {
                        tmp___3 = kerr(b"syntax\0" as *const u8 as *const libc::c_char);
                        return tmp___3 as L;
                    }
                }
                _ => {}
            }
        }
        current_block_95 = 16789764818708874114;
    }
    match current_block_95 {
        8058245720594617764 => {
            i = 0 as libc::c_int as I;
            _i___0 = n;
            while i < _i___0 {
                point = d___0.offset(r as isize);
                tmp___0 = wrep(*((*x___0).k).as_mut_ptr().offset(i as isize), point, y);
                delta = tmp___0;
                r += delta;
                i += 1;
            }
        }
        _ => {}
    }
    return e + r;
}
unsafe extern "C" fn disk(mut x___0: K) -> I {
    let mut tmp: I = 0;
    tmp = rep(x___0, 1 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn rep(mut x___0: K, mut y: I) -> I {
    let mut m: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut r: I = 0;
    let mut n: I = 0;
    let mut q: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: I = 0;
    if y != 0 {
        tmp = 4 as libc::c_int;
    } else {
        tmp = 2 as libc::c_int;
    }
    m = (::std::mem::size_of::<I>() as libc::c_ulong).wrapping_mul(tmp as libc::c_ulong)
        as I;
    r = m;
    n = (*x___0).n;
    q = 0 as libc::c_int as I;
    match (*x___0).t {
        0 | 5 => {
            i = 0 as libc::c_int as I;
            _i___0 = (*x___0).n;
            while i < _i___0 {
                tmp___0 = rep(*((*x___0).k).as_mut_ptr().offset(i as isize), y);
                r += tmp___0;
                i += 1;
            }
        }
        -4 => {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                tmp___1 = strlen(
                    *(((*x___0).k).as_mut_ptr() as *mut S).offset(i___0 as isize)
                        as *const libc::c_char,
                );
                r = (r as libc::c_ulonglong)
                    .wrapping_add(
                        (1 as libc::c_ulong).wrapping_add(tmp___1) as libc::c_ulonglong,
                    ) as I;
                i___0 += 1;
            }
            if r % 8 as libc::c_longlong > 0 as libc::c_longlong {
                r += 8 as libc::c_longlong - r % 8 as libc::c_longlong;
            }
        }
        -3 => {
            r = (r as libc::c_ulonglong)
                .wrapping_add(
                    ((1 as libc::c_longlong + n) as libc::c_ulonglong)
                        .wrapping_mul(
                            ::std::mem::size_of::<C>() as libc::c_ulong
                                as libc::c_ulonglong,
                        ),
                ) as I;
            if r % 8 as libc::c_longlong > 0 as libc::c_longlong {
                r += 8 as libc::c_longlong - r % 8 as libc::c_longlong;
            }
        }
        -2 => {
            r = (r as libc::c_ulonglong)
                .wrapping_add(
                    (n as libc::c_ulonglong)
                        .wrapping_mul(
                            ::std::mem::size_of::<F>() as libc::c_ulong
                                as libc::c_ulonglong,
                        ),
                ) as I;
        }
        -1 => {
            r = (r as libc::c_ulonglong)
                .wrapping_add(
                    (n as libc::c_ulonglong)
                        .wrapping_mul(
                            ::std::mem::size_of::<I>() as libc::c_ulong
                                as libc::c_ulonglong,
                        ),
                ) as I;
        }
        4 => {
            tmp___2 = strlen(
                *(((*x___0).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            q = (1 as libc::c_ulong).wrapping_add(tmp___2) as I;
            if q as libc::c_ulonglong
                >= ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong
            {
                r = (r as libc::c_ulonglong)
                    .wrapping_add(
                        (q as libc::c_ulonglong)
                            .wrapping_sub(
                                ::std::mem::size_of::<I>() as libc::c_ulong
                                    as libc::c_ulonglong,
                            ),
                    ) as I;
            }
        }
        7 | 8 | _ => {}
    }
    if r > m {
        tmp___3 = r;
    } else {
        tmp___3 = m;
    }
    return tmp___3;
}
pub unsafe extern "C" fn rrep(
    mut v: V,
    mut aft: V,
    mut b___1: *mut I,
    mut y: I,
    mut x___0: I,
) -> K {
    let mut m: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut s: I = 0;
    let mut w___0: *mut I = 0 as *mut I;
    let mut r: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut f: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: libc::c_ulonglong = 0;
    if y != 0 {
        tmp = 2 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    m = tmp as I;
    s = aft.offset_from(v) as libc::c_long as I;
    w___0 = v as *mut I;
    r = ((2 as libc::c_longlong + m) as libc::c_ulonglong)
        .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong)
        as I;
    if s < r {
        tmp___0 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    if y != 0 {
        if -(3 as libc::c_longlong) != *w___0.offset(0 as libc::c_int as isize) {
            tmp___1 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
            return tmp___1;
        }
    }
    membswpI(
        &mut t as *mut I as V,
        w___0.offset(m as isize) as V,
        ::std::mem::size_of::<I>() as libc::c_ulong as I,
        x___0,
    );
    if t <= 0 as libc::c_longlong {
        membswpI(
            &mut n as *mut I as V,
            w___0.offset(1 as libc::c_int as isize).offset(m as isize) as V,
            ::std::mem::size_of::<I>() as libc::c_ulong as I,
            x___0,
        );
    } else if 5 as libc::c_longlong == t {
        membswpI(
            &mut n as *mut I as V,
            w___0.offset(1 as libc::c_int as isize).offset(m as isize) as V,
            ::std::mem::size_of::<I>() as libc::c_ulong as I,
            x___0,
        );
    } else if !(10 as libc::c_longlong == t) {
        n = 1 as libc::c_int as I;
    }
    if -(1 as libc::c_longlong) == t {
        r = (r as libc::c_ulonglong)
            .wrapping_add(
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                    ),
            ) as I;
    } else if -(2 as libc::c_longlong) == t {
        r = (r as libc::c_ulonglong)
            .wrapping_add(
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
                    ),
            ) as I;
    } else if -(3 as libc::c_longlong) == t {
        r = (r as libc::c_ulonglong)
            .wrapping_add(
                ((1 as libc::c_longlong + n) as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<C>() as libc::c_ulong as libc::c_ulonglong,
                    ),
            ) as I;
    }
    if s < r {
        tmp___2 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    }
    if -(4 as libc::c_longlong) <= t {
        if t <= 6 as libc::c_longlong {
            tmp___3 = newK(t, n);
            tmp___5 = tmp___3;
        } else {
            tmp___4 = Kv();
            tmp___5 = tmp___4;
        }
    } else {
        tmp___4 = Kv();
        tmp___5 = tmp___4;
    }
    z = tmp___5;
    if z.is_null() {
        return 0 as K;
    }
    c = 0 as libc::c_int as I;
    match t {
        0 | 5 => {
            while (v.offset(r as isize) as libc::c_ulong) < aft as libc::c_ulong {
                if !(c < n) {
                    break;
                }
                tmp___6 = rrep(v.offset(r as isize), aft, &mut r, y, x___0);
                k = tmp___6;
                tmp___7 = OOM_CD(0 as libc::c_int as I, z, k, -(1 as libc::c_int) as V);
                if tmp___7 == 0 {
                    return 0 as K;
                }
                tmp___8 = c;
                c += 1;
                memcpy(
                    &mut *((*z).k).as_mut_ptr().offset(tmp___8 as isize) as *mut *mut k0
                        as *mut libc::c_void,
                    &mut k as *mut K as *const libc::c_void,
                    ::std::mem::size_of::<K>() as libc::c_ulong,
                );
            }
            if c != n {
                cd(z);
                tmp___9 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
                return tmp___9;
            }
        }
        -4 => {
            while (v.offset(r as isize) as libc::c_ulong) < aft as libc::c_ulong {
                if !(c < n) {
                    break;
                }
                tmp___10 = c;
                c += 1;
                tmp___11 = rrep_4(
                    (((*z).k).as_mut_ptr() as *mut S).offset(tmp___10 as isize),
                    v.offset(r as isize) as S,
                    aft as S,
                );
                r += tmp___11;
            }
            if c != n {
                tmp___12 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
                return tmp___12;
            }
        }
        -3 => {
            memcpy(
                ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                w___0.offset(2 as libc::c_int as isize).offset(m as isize)
                    as *const libc::c_void,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<C>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
        }
        -2 => {
            membswpF(
                ((*z).k).as_mut_ptr() as *mut F as V,
                w___0.offset(2 as libc::c_int as isize).offset(m as isize) as V,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
                    ) as I,
                x___0,
            );
        }
        -1 => {
            membswpI(
                ((*z).k).as_mut_ptr() as *mut I as V,
                w___0.offset(2 as libc::c_int as isize).offset(m as isize) as V,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                    ) as I,
                x___0,
            );
        }
        1 => {
            membswpI(
                ((*z).k).as_mut_ptr() as *mut I as V,
                w___0.offset(1 as libc::c_int as isize).offset(m as isize) as V,
                ::std::mem::size_of::<I>() as libc::c_ulong as I,
                x___0,
            );
        }
        2 => {
            membswpF(
                ((*z).k).as_mut_ptr() as *mut F as V,
                w___0.offset(1 as libc::c_int as isize).offset(m as isize) as V,
                ::std::mem::size_of::<F>() as libc::c_ulong as I,
                x___0,
            );
        }
        3 => {
            memcpy(
                ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                w___0.offset(1 as libc::c_int as isize).offset(m as isize)
                    as *const libc::c_void,
                ::std::mem::size_of::<C>() as libc::c_ulong,
            );
        }
        4 => {
            tmp___13 = rrep_4(
                ((*z).k).as_mut_ptr() as *mut S,
                w___0.offset(1 as libc::c_int as isize).offset(m as isize) as S,
                aft as S,
            );
            r = (r as libc::c_ulonglong)
                .wrapping_add(
                    (tmp___13 as libc::c_ulonglong)
                        .wrapping_sub(
                            ::std::mem::size_of::<I>() as libc::c_ulong
                                as libc::c_ulonglong,
                        ),
                ) as I;
        }
        6 => {}
        7 | 8 => {
            f = newK(-(4 as libc::c_int) as I, 2 as libc::c_int as I);
            tmp___14 = OOM_CD(0 as libc::c_int as I, z, f, -(1 as libc::c_int) as V);
            if tmp___14 == 0 {
                return 0 as K;
            }
            let ref mut fresh20 = *(((*z).k).as_mut_ptr() as *mut V)
                .offset(2 as libc::c_int as isize);
            *fresh20 = f as V;
            if x___0 != 0 {
                *w___0
                    .offset(
                        (1 as libc::c_longlong + m) as isize,
                    ) = bswapI(*w___0.offset((1 as libc::c_longlong + m) as isize));
            }
            let ref mut fresh21 = *((*f).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh21 = *w___0.offset((1 as libc::c_longlong + m) as isize) as V
                as *mut k0;
            r = r;
        }
        _ => {
            tmp___15 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
            return tmp___15;
        }
    }
    if r as libc::c_ulonglong
        > ((2 as libc::c_longlong + m) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            )
    {
        tmp___16 = r as libc::c_ulonglong;
    } else {
        tmp___16 = ((2 as libc::c_longlong + m) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            );
    }
    *b___1 = (*b___1 as libc::c_ulonglong).wrapping_add(tmp___16) as I;
    *b___1 = 8 as libc::c_longlong
        * (*b___1 / 8 as libc::c_longlong
            + (*b___1 % 8 as libc::c_longlong > 0 as libc::c_longlong) as libc::c_int
                as I);
    return z;
}
unsafe extern "C" fn rrep_4(mut z: *mut S, mut a: S, mut t: S) -> I {
    let mut d___0: S = 0 as *mut C;
    let mut c: I = 0;
    let mut e: S = 0 as *mut C;
    let mut tmp: S = 0 as *mut C;
    d___0 = a;
    while (a as libc::c_ulong) < t as libc::c_ulong {
        if *a == 0 {
            break;
        }
        a = a.offset(1);
    }
    c = a.offset_from(d___0) as libc::c_long as I;
    tmp = strdupn(d___0, c);
    e = tmp;
    *z = sp(e);
    free(e as *mut libc::c_void);
    return c + (a as libc::c_ulong != t as libc::c_ulong) as libc::c_int as I;
}
unsafe extern "C" fn _1d_read(mut a: K, mut b___1: K) -> K {
    let mut types: S = 0 as *mut C;
    let mut fixed: [I; 8] = [0; 8];
    let mut typelist: [I; 15] = [0; 15];
    let mut g: C = 0;
    let mut z: K = 0 as *mut k0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut cn: I = 0;
    let mut dn: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut fc: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___10: I = 0;
    let mut w___0: I = 0;
    let mut x___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut ff: K = 0 as *mut k0;
    let mut k: K = 0 as *mut k0;
    let mut fb: I = 0;
    let mut fn_0: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: I = 0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut s: I = 0;
    let mut tmp___17: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: S = 0 as *mut C;
    let mut tmp___21: I = 0;
    let mut tmp___23: I = 0;
    let mut tmp___24: I = 0;
    let mut f: I = 0;
    let mut tmp___25: S = 0 as *mut C;
    let mut tmp___26: libc::c_int = 0;
    let mut tmp___27: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut fb_off_by: I = 0;
    let mut map_length: I = 0;
    let mut map_offset: I = 0;
    let mut tmp___28: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___29: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___30: K = 0 as *mut k0;
    let mut tmp___31: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___32: libc::c_int = 0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut e: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___34: I = 0;
    let mut tmp___35: I = 0;
    let mut i___2: I = 0;
    let mut j: I = 0;
    let mut p: V = 0 as *mut libc::c_void;
    let mut q: K = 0 as *mut k0;
    let mut tmp___36: I = 0;
    let mut u: S = 0 as *mut C;
    let mut res: I = 0;
    let mut tmp___37: libc::c_int = 0;
    let mut tmp___38: K = 0 as *mut k0;
    types = b"cbsijfdmIFCSDZM\0" as *const u8 as *const libc::c_char as S;
    fixed[0 as libc::c_int as usize] = ::std::mem::size_of::<C>() as libc::c_ulong as I;
    fixed[1 as libc::c_int
        as usize] = ::std::mem::size_of::<int8_t>() as libc::c_ulong as I;
    fixed[2 as libc::c_int
        as usize] = ::std::mem::size_of::<int16_t>() as libc::c_ulong as I;
    fixed[3 as libc::c_int
        as usize] = ::std::mem::size_of::<int32_t>() as libc::c_ulong as I;
    fixed[4 as libc::c_int as usize] = ::std::mem::size_of::<I>() as libc::c_ulong as I;
    fixed[5 as libc::c_int
        as usize] = ::std::mem::size_of::<libc::c_float>() as libc::c_ulong as I;
    fixed[6 as libc::c_int as usize] = ::std::mem::size_of::<F>() as libc::c_ulong as I;
    fixed[7 as libc::c_int as usize] = 9 as libc::c_int as I;
    typelist[0 as libc::c_int as usize] = -(3 as libc::c_int) as I;
    typelist[1 as libc::c_int as usize] = -(1 as libc::c_int) as I;
    typelist[2 as libc::c_int as usize] = -(1 as libc::c_int) as I;
    typelist[3 as libc::c_int as usize] = -(1 as libc::c_int) as I;
    typelist[4 as libc::c_int as usize] = -(1 as libc::c_int) as I;
    typelist[5 as libc::c_int as usize] = -(2 as libc::c_int) as I;
    typelist[6 as libc::c_int as usize] = -(2 as libc::c_int) as I;
    typelist[7 as libc::c_int as usize] = 9 as libc::c_int as I;
    typelist[8 as libc::c_int as usize] = 9 as libc::c_int as I;
    typelist[9 as libc::c_int as usize] = 9 as libc::c_int as I;
    typelist[10 as libc::c_int as usize] = 0 as libc::c_int as I;
    typelist[11 as libc::c_int as usize] = -(4 as libc::c_int) as I;
    typelist[12 as libc::c_int as usize] = 9 as libc::c_int as I;
    typelist[13 as libc::c_int as usize] = 9 as libc::c_int as I;
    typelist[14 as libc::c_int as usize] = 9 as libc::c_int as I;
    z = 0 as K;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if an != 2 as libc::c_longlong {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    c = *((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    d___0 = *((*a).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    cn = (*c).n;
    dn = (*d___0).n;
    if (*c).t < 0 as libc::c_longlong {
        tmp___1 = -(*c).t;
    } else {
        tmp___1 = (*c).t;
    }
    if 3 as libc::c_longlong != tmp___1 {
        tmp___0 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    } else {
        if (*d___0).t < 0 as libc::c_longlong {
            tmp___2 = -(*d___0).t;
        } else {
            tmp___2 = (*d___0).t;
        }
        if 1 as libc::c_longlong != tmp___2 {
            tmp___0 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        }
    }
    if cn == 0 {
        tmp___3 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___3;
    } else {
        if cn != dn {
            tmp___3 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___3;
        }
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if 3 as libc::c_longlong != tmp___5 {
        if 4 as libc::c_longlong != bt {
            if 0 as libc::c_longlong != bt {
                tmp___4 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___4;
            }
        }
    }
    fc = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = cn;
    while i < _i___0 {
        g = *(((*c).k).as_mut_ptr() as *mut C).offset(i as isize);
        if !(32 as libc::c_int == g as libc::c_int) {
            tmp___7 = stringHasChar(types, g);
            if tmp___7 != 0 {
                fc += 1;
            } else {
                tmp___6 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
            tmp___9 = __ctype_b_loc();
            if *(*tmp___9).offset(g as libc::c_int as isize) as libc::c_int
                & 512 as libc::c_int != 0
            {
                tmp___10 = charpos(types, g);
                if fixed[tmp___10 as usize]
                    != *(((*d___0).k).as_mut_ptr() as *mut I).offset(i as isize)
                {
                    tmp___8 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                    return tmp___8;
                }
            }
        }
        i += 1;
    }
    w___0 = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = dn;
    while i___0 < _i___1 {
        x___0 = *(((*d___0).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
        if x___0 <= 0 as libc::c_longlong {
            tmp___11 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___11;
        }
        w___0 += x___0;
        i___0 += 1;
    }
    ff = b___1;
    fb = 0 as libc::c_int as I;
    fn_0 = 0 as libc::c_int as I;
    if bt == 0 {
        if 3 as libc::c_longlong != bn {
            tmp___12 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___12;
        }
        ff = *((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        if (*ff).t < 0 as libc::c_longlong {
            tmp___14 = -(*ff).t;
        } else {
            tmp___14 = (*ff).t;
        }
        if 3 as libc::c_longlong != tmp___14 {
            if 4 as libc::c_longlong != (*ff).t {
                tmp___13 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___13;
            }
        }
        k = *((*b___1).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        if 1 as libc::c_longlong != (*k).t {
            if 2 as libc::c_longlong != (*k).t {
                tmp___15 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___15;
            }
        }
        if (*k).t - 1 as libc::c_longlong != 0 {
            fb = *(((*k).k).as_mut_ptr() as *mut F) as I;
        } else {
            fb = *(((*k).k).as_mut_ptr() as *mut I);
        }
        k = *((*b___1).k).as_mut_ptr().offset(2 as libc::c_int as isize);
        if 1 as libc::c_longlong != (*k).t {
            if 2 as libc::c_longlong != (*k).t {
                tmp___16 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___16;
            }
        }
        if (*k).t - 1 as libc::c_longlong != 0 {
            fn_0 = *(((*k).k).as_mut_ptr() as *mut F) as I;
        } else {
            fn_0 = *(((*k).k).as_mut_ptr() as *mut I);
        }
    }
    tmp___20 = CSK(ff);
    tmp___21 = stat_sz(tmp___20, &mut s);
    if tmp___21 != 0 {
        tmp___17 = __errno_location();
        tmp___18 = strerror(*tmp___17);
        tmp___19 = kerr(tmp___18 as cS);
        return tmp___19;
    }
    if bt != 0 {
        fn_0 = s;
    }
    if fn_0 < 0 as libc::c_longlong {
        fn_0 = 0 as libc::c_int as I;
    }
    if fb < 0 as libc::c_longlong {
        fb = 0 as libc::c_int as I;
    }
    if 0 as libc::c_longlong > s - 1 as libc::c_longlong {
        tmp___24 = 0 as libc::c_int as I;
    } else {
        tmp___24 = s - 1 as libc::c_longlong;
    }
    if fb < tmp___24 {
        fb = fb;
    } else {
        if 0 as libc::c_longlong > s - 1 as libc::c_longlong {
            tmp___23 = 0 as libc::c_int as I;
        } else {
            tmp___23 = s - 1 as libc::c_longlong;
        }
        fb = tmp___23;
    }
    if fb + fn_0 > s {
        fn_0 = s - fb;
    }
    tmp___25 = CSK(ff);
    tmp___26 = open(tmp___25 as *const libc::c_char, 0 as libc::c_int);
    f = tmp___26 as I;
    if f < 0 as libc::c_longlong {
        tmp___27 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___27;
    }
    fb_off_by = fb % PG;
    map_length = fn_0 + fb_off_by;
    map_offset = fb - fb_off_by;
    tmp___31 = mmap(
        0 as *mut libc::c_void,
        map_length as size_t,
        1 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        map_offset as __off_t,
    );
    v = tmp___31 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___28 = __errno_location();
        tmp___29 = strerror(*tmp___28);
        tmp___30 = kerr(tmp___29 as cS);
        return tmp___30;
    }
    tmp___32 = close(f as libc::c_int);
    r = tmp___32 as I;
    if r != 0 {
        tmp___33 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___33;
    }
    r = fn_0 / w___0;
    z = newK(0 as libc::c_int as I, fc);
    if z.is_null() {
        return 0 as K;
    }
    e = 0 as libc::c_int as I;
    i___1 = 0 as libc::c_int as I;
    _i___2 = cn;
    while i___1 < _i___2 {
        g = *(((*c).k).as_mut_ptr() as *mut C).offset(i___1 as isize);
        if !(32 as libc::c_int == g as libc::c_int) {
            tmp___34 = e;
            e += 1;
            tmp___35 = charpos(types, g);
            let ref mut fresh22 = *((*z).k).as_mut_ptr().offset(tmp___34 as isize);
            *fresh22 = newK(typelist[tmp___35 as usize], r);
        }
        i___1 += 1;
    }
    p = v.offset(fb_off_by as isize) as V;
    j = 0 as libc::c_int as I;
    while j < r {
        e = 0 as libc::c_int as I;
        i___2 = 0 as libc::c_int as I;
        while i___2 < cn {
            x___0 = *(((*d___0).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
            tmp___36 = e;
            e += 1;
            q = *((*z).k).as_mut_ptr().offset(tmp___36 as isize);
            g = *(((*c).k).as_mut_ptr() as *mut C).offset(i___2 as isize);
            match g as libc::c_int {
                32 => {
                    e -= 1;
                }
                99 => {
                    *(((*q).k).as_mut_ptr() as *mut C)
                        .offset(j as isize) = *(p as *mut C);
                }
                98 => {
                    *(((*q).k).as_mut_ptr() as *mut I)
                        .offset(j as isize) = *(p as *mut int8_t) as I;
                }
                115 => {
                    *(((*q).k).as_mut_ptr() as *mut I)
                        .offset(j as isize) = *(p as *mut int16_t) as I;
                }
                105 => {
                    *(((*q).k).as_mut_ptr() as *mut I)
                        .offset(j as isize) = *(p as *mut int32_t) as I;
                }
                106 => {
                    *(((*q).k).as_mut_ptr() as *mut I)
                        .offset(j as isize) = *(p as *mut I);
                }
                102 => {
                    *(((*q).k).as_mut_ptr() as *mut F)
                        .offset(j as isize) = *(p as *mut libc::c_float) as F;
                }
                100 => {
                    *(((*q).k).as_mut_ptr() as *mut F)
                        .offset(j as isize) = *(p as *mut F);
                }
                67 => {
                    k = newK(-(3 as libc::c_int) as I, x___0);
                    if k.is_null() {
                        return 0 as K;
                    }
                    memcpy(
                        ((*k).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                        p as *const libc::c_void,
                        x___0 as size_t,
                    );
                    let ref mut fresh23 = *((*q).k).as_mut_ptr().offset(j as isize);
                    *fresh23 = k;
                }
                83 => {
                    u = spn(p as S, x___0);
                    if u.is_null() {
                        return 0 as K;
                    }
                    let ref mut fresh24 = *(((*q).k).as_mut_ptr() as *mut S)
                        .offset(j as isize);
                    *fresh24 = u;
                }
                109 | 73 | 70 | 68 | 90 | 77 | _ => {}
            }
            p = p.offset(x___0 as isize);
            i___2 += 1;
        }
        j += 1;
    }
    tmp___37 = munmap(v as *mut libc::c_void, map_length as size_t);
    res = tmp___37 as I;
    if res != 0 {
        tmp___38 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___38;
    }
    return z;
}
unsafe extern "C" fn _1d_char(mut x___0: K, mut y: K) -> K {
    let mut a: C = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    a = *(((*x___0).k).as_mut_ptr() as *mut C);
    if 99 as libc::c_int == a as libc::c_int {
        tmp = readVector(y, -(3 as libc::c_int) as I);
        return tmp;
    }
    if 100 as libc::c_int == a as libc::c_int {
        tmp___0 = readVector(y, -(2 as libc::c_int) as I);
        return tmp___0;
    }
    if 105 as libc::c_int == a as libc::c_int {
        tmp___1 = readVector(y, -(1 as libc::c_int) as I);
        return tmp___1;
    }
    tmp___2 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
    return tmp___2;
}
pub unsafe extern "C" fn _2m(mut a: K) -> K {
    let mut t: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___1: S = 0 as *mut C;
    let mut sm: I = 0;
    let mut tmp___2: size_t = 0;
    let mut e: S = 0 as *mut C;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___4: S = 0 as *mut C;
    let mut tmp___5: S = 0 as *mut C;
    let mut s: I = 0;
    let mut f: I = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: I = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut tmp___17: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___21: libc::c_int = 0;
    let mut tmp___22: K = 0 as *mut k0;
    let mut b___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: K = 0 as *mut k0;
    t = (*a).t;
    if 4 as libc::c_longlong != t {
        if t < 0 as libc::c_longlong {
            tmp___0 = -t;
        } else {
            tmp___0 = t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___1 = CSK(a);
    m = tmp___1;
    tmp___2 = strlen(m as *const libc::c_char);
    sm = tmp___2 as I;
    if sm > 1 as libc::c_longlong {
        if 46 as libc::c_int
            == *m.offset((sm - 2 as libc::c_longlong) as isize) as libc::c_int
        {
            if *(b"K\0" as *const u8 as *const libc::c_char) as libc::c_int
                == *m.offset((sm - 1 as libc::c_longlong) as isize) as libc::c_int
            {
                tmp___3 = strdupn(m, sm);
                tmp___5 = tmp___3;
            } else {
                tmp___4 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
                tmp___5 = tmp___4;
            }
        } else {
            tmp___4 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
            tmp___5 = tmp___4;
        }
    } else {
        tmp___4 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
        tmp___5 = tmp___4;
    }
    e = tmp___5;
    if e.is_null() {
        return 0 as K;
    }
    tmp___6 = open(e as *const libc::c_char, 0 as libc::c_int);
    f = tmp___6 as I;
    if f >= 0 as libc::c_longlong {
        tmp___10 = stat_sz(e, &mut s);
        if tmp___10 != 0 {
            tmp___7 = __errno_location();
            tmp___8 = strerror(*tmp___7);
            tmp___9 = kerr(tmp___8 as cS);
            return tmp___9;
        }
    } else {
        tmp___11 = open(m as *const libc::c_char, 0 as libc::c_int);
        f = tmp___11 as I;
        tmp___15 = stat_sz(m, &mut s);
        if tmp___15 != 0 {
            tmp___12 = __errno_location();
            tmp___13 = strerror(*tmp___12);
            tmp___14 = kerr(tmp___13 as cS);
            return tmp___14;
        }
    }
    free(e as *mut libc::c_void);
    if f < 0 as libc::c_longlong {
        tmp___16 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___16;
    }
    tmp___20 = mmap(
        0 as *mut libc::c_void,
        s as size_t,
        1 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        0 as libc::c_int as __off_t,
    );
    v = tmp___20 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___17 = __errno_location();
        tmp___18 = strerror(*tmp___17);
        tmp___19 = kerr(tmp___18 as cS);
        return tmp___19;
    }
    tmp___21 = close(f as libc::c_int);
    r = tmp___21 as I;
    if r != 0 {
        tmp___22 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___22;
    }
    b___1 = 0 as libc::c_int as I;
    tmp___23 = _2m_r(v as V, v.offset(s as isize) as V, &mut b___1);
    z = tmp___23;
    tmp___24 = munmap(v as *mut libc::c_void, s as size_t);
    r = tmp___24 as I;
    if r != 0 {
        tmp___25 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___25;
    }
    return z;
}
pub unsafe extern "C" fn _2m_r(mut v: V, mut aft: V, mut b___1: *mut I) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = rrep(v, aft, b___1, 1 as libc::c_int as I, 0 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn _2d(mut a: K, mut b___1: K) -> K {
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut v: L = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut e: cS = 0 as *const C;
    let mut x___0: V = 0 as *mut libc::c_void;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut y: V = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: S = 0 as *mut C;
    let mut tmp___7: S = 0 as *mut C;
    let mut tmp___8: S = 0 as *mut C;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut w___0: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: I = 0;
    if 4 as libc::c_longlong != (*a).t {
        if (*a).t < 0 as libc::c_longlong {
            tmp___0 = -(*a).t;
        } else {
            tmp___0 = (*a).t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    if (*b___1).t != 0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if (*b___1).n != 2 as libc::c_longlong {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        } else {
            c = *((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize);
            if 4 as libc::c_longlong != (*c).t {
                if (*c).t < 0 as libc::c_longlong {
                    tmp___1 = -(*c).t;
                } else {
                    tmp___1 = (*c).t;
                }
                if 3 as libc::c_longlong != tmp___1 {
                    tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp;
                }
            }
            d___0 = *((*b___1).k).as_mut_ptr().offset(1 as libc::c_int as isize);
            if 1 as libc::c_longlong != (*d___0).t {
                tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    v = *(((*d___0).k).as_mut_ptr() as *mut I);
    if v < 0 as libc::c_longlong {
        tmp___2 = kerr(b"valence\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    } else {
        if v > 7 as libc::c_longlong {
            tmp___2 = kerr(b"valence\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
    }
    tmp___3 = CSK(a);
    tmp___4 = dlopen(tmp___3 as *const libc::c_char, 1 as libc::c_int);
    x___0 = tmp___4;
    tmp___5 = dlerror();
    e = tmp___5 as cS;
    if !e.is_null() {
        tmp___6 = CSK(a);
        printf(
            b"error loading %s\nerr=%s\n\0" as *const u8 as *const libc::c_char,
            tmp___6,
            e,
        );
        return 0 as K;
    }
    if x___0.is_null() {
        tmp___7 = CSK(a);
        printf(b"error loading %s \n\0" as *const u8 as *const libc::c_char, tmp___7);
        return 0 as K;
    }
    tmp___8 = CSK(c);
    y = dlsym(x___0, tmp___8 as *const libc::c_char);
    tmp___9 = dlerror();
    e = tmp___9 as cS;
    if !e.is_null() {
        if *e != 0 {
            tmp___10 = kerr(e);
            return tmp___10;
        }
    }
    if y.is_null() {
        tmp___11 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___11;
    }
    tmp___12 = Kv();
    z = tmp___12;
    tmp___13 = newK(-(4 as libc::c_int) as I, 3 as libc::c_int as I);
    w___0 = tmp___13;
    tmp___14 = OOM_CD(0 as libc::c_int as I, z, w___0, -(1 as libc::c_int) as V);
    if tmp___14 == 0 {
        return 0 as K;
    }
    (*z).n = 2 as libc::c_int as I;
    let ref mut fresh25 = *((*w___0).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh25 = v as V as *mut k0;
    let ref mut fresh26 = *((*w___0).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh26 = y as *mut k0;
    let ref mut fresh27 = *(((*z).k).as_mut_ptr() as *mut V)
        .offset(2 as libc::c_int as isize);
    *fresh27 = w___0 as V;
    return z;
}
pub unsafe extern "C" fn dm1(mut msg: S, mut m: *mut M1) {
    printf(b"=== %s ===\n\0" as *const u8 as *const libc::c_char, msg);
    printf(b"a: %d\n\0" as *const u8 as *const libc::c_char, (*m).a as libc::c_int);
    printf(b"n: %lld\n\0" as *const u8 as *const libc::c_char, (*m).n);
    printf(b"d: %d\n\0" as *const u8 as *const libc::c_char, (*m).d as libc::c_int);
}
unsafe extern "C" fn sendall(mut s: I, mut b___1: S, mut k: I) -> I {
    let mut t: I = 0;
    let mut r: I = 0;
    let mut n: I = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: I = 0;
    t = 0 as libc::c_int as I;
    r = k;
    n = 0 as libc::c_int as I;
    while t < k {
        tmp = send(
            s as libc::c_int,
            b___1.offset(t as isize) as *const libc::c_void,
            r as size_t,
            0 as libc::c_int,
        );
        n = tmp as I;
        if -(1 as libc::c_longlong) == n {
            break;
        }
        t += n;
        r -= n;
    }
    if -(1 as libc::c_longlong) == n {
        tmp___0 = n;
    } else {
        tmp___0 = 0 as libc::c_int as I;
    }
    return tmp___0;
}
pub unsafe extern "C" fn ksender(mut sockfd: I, mut y: K, mut t: I) -> I {
    let mut r: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut m: *mut M1 = 0 as *mut M1;
    r = 0 as libc::c_int as I;
    k = _bd(y);
    if k.is_null() {
        return 0 as libc::c_int as I;
    }
    m = ((*k).k).as_mut_ptr() as *mut C as V as *mut M1;
    (*m).d = t as libc::c_char;
    r = sendall(sockfd, ((*k).k).as_mut_ptr() as *mut C, (*k).n);
    if -(1 as libc::c_longlong) == r {
        perror(b"conn: send error\0" as *const u8 as *const libc::c_char);
    }
    cd(k);
    return r;
}
unsafe extern "C" fn _3d_(mut x___0: K, mut y: K) -> K {
    let mut current_block: u64;
    let mut res: I = 0;
    let mut sym: S = 0 as *mut C;
    let mut lenS: I = 0;
    let mut tmp: size_t = 0;
    let mut cod: S = 0 as *mut C;
    let mut lenC: I = 0;
    let mut tmp___0: size_t = 0;
    let mut i: I = 0;
    let mut q: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut sym___0: S = 0 as *mut C;
    let mut lenS___0: I = 0;
    let mut tmp___2: size_t = 0;
    let mut cod___0: S = 0 as *mut C;
    let mut tmp___3: K = 0 as *mut k0;
    let mut lenC___0: I = 0;
    let mut tmp___4: size_t = 0;
    let mut i___0: I = 0;
    let mut q___0: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut sym___1: S = 0 as *mut C;
    let mut lenS___1: I = 0;
    let mut tmp___6: size_t = 0;
    let mut cod___1: S = 0 as *mut C;
    let mut lenC___1: I = 0;
    let mut tmp___7: size_t = 0;
    let mut i___1: I = 0;
    let mut q___1: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut sym___2: S = 0 as *mut C;
    let mut lenS___2: I = 0;
    let mut tmp___9: size_t = 0;
    let mut cod___2: S = 0 as *mut C;
    let mut tmp___10: K = 0 as *mut k0;
    let mut lenC___2: I = 0;
    let mut tmp___11: size_t = 0;
    let mut i___2: I = 0;
    let mut q___2: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    res = -(1 as libc::c_int) as I;
    if (*y).t == -(3 as libc::c_longlong) {
        res = ksender(*(((*x___0).k).as_mut_ptr() as *mut I), y, 0 as libc::c_int as I);
    } else {
        if (*y).t == 0 as libc::c_longlong {
            if (*y).n == 4 as libc::c_longlong {
                if (**((*y).k).as_mut_ptr().offset(3 as libc::c_int as isize)).t
                    == 7 as libc::c_longlong
                {
                    if (**((*y).k).as_mut_ptr().offset(3 as libc::c_int as isize)).n
                        == 3 as libc::c_longlong
                    {
                        if (**((*y).k).as_mut_ptr().offset(1 as libc::c_int as isize)).t
                            == 0 as libc::c_longlong
                        {
                            if (**((*y).k)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize))
                                .n == 0 as libc::c_longlong
                            {
                                if *((**((**((*y).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize) as libc::c_ulong
                                    == offsetColon as libc::c_ulong
                                {
                                    sym = *(((**((*y).k)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr() as *mut S);
                                    tmp = strlen(sym as *const libc::c_char);
                                    lenS = tmp as I;
                                    cod = ((**((**((*y).k)
                                        .as_mut_ptr()
                                        .offset(3 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr() as *mut C;
                                    tmp___0 = strlen(cod as *const libc::c_char);
                                    lenC = tmp___0 as I;
                                    let vla = (lenS + lenC + 4 as libc::c_longlong) as usize;
                                    let mut str: Vec::<C> = ::std::vec::from_elem(0, vla);
                                    i = 0 as libc::c_int as I;
                                    i = 0 as libc::c_int as I;
                                    while i < lenS {
                                        *str
                                            .as_mut_ptr()
                                            .offset(i as isize) = *sym.offset(i as isize);
                                        i += 1;
                                    }
                                    i = 0 as libc::c_int as I;
                                    while i < lenC {
                                        *str
                                            .as_mut_ptr()
                                            .offset(
                                                (i + lenS + 2 as libc::c_longlong) as isize,
                                            ) = *cod.offset(i as isize);
                                        i += 1;
                                    }
                                    *str.as_mut_ptr().offset(lenS as isize) = ':' as i32 as C;
                                    *str
                                        .as_mut_ptr()
                                        .offset(
                                            (lenS + 1 as libc::c_longlong) as isize,
                                        ) = '{' as i32 as C;
                                    *str
                                        .as_mut_ptr()
                                        .offset(
                                            (lenS + lenC + 2 as libc::c_longlong) as isize,
                                        ) = '}' as i32 as C;
                                    *str
                                        .as_mut_ptr()
                                        .offset(
                                            (lenS + lenC + 3 as libc::c_longlong) as isize,
                                        ) = '\u{0}' as i32 as C;
                                    tmp___1 = Ks(str.as_mut_ptr());
                                    q = tmp___1;
                                    res = ksender(
                                        *(((*x___0).k).as_mut_ptr() as *mut I),
                                        q,
                                        0 as libc::c_int as I,
                                    );
                                    cd(q);
                                    current_block = 18139099716546303047;
                                } else {
                                    current_block = 7052434393081847747;
                                }
                            } else {
                                current_block = 7052434393081847747;
                            }
                        } else {
                            current_block = 7052434393081847747;
                        }
                    } else {
                        current_block = 7052434393081847747;
                    }
                } else {
                    current_block = 7052434393081847747;
                }
            } else {
                current_block = 7052434393081847747;
            }
        } else {
            current_block = 7052434393081847747;
        }
        match current_block {
            18139099716546303047 => {}
            _ => {
                if (*y).t == 0 as libc::c_longlong {
                    if (*y).n == 4 as libc::c_longlong {
                        if (**((*y).k).as_mut_ptr().offset(3 as libc::c_int as isize)).t
                            == 7 as libc::c_longlong
                        {
                            if (**((*y).k)
                                .as_mut_ptr()
                                .offset(3 as libc::c_int as isize))
                                .n == 1 as libc::c_longlong
                            {
                                if (**((*y).k)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize))
                                    .t == 0 as libc::c_longlong
                                {
                                    if (**((*y).k)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize))
                                        .n == 0 as libc::c_longlong
                                    {
                                        if *((**((**((*y).k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .k)
                                            .as_mut_ptr()
                                            .offset(0 as libc::c_int as isize) as libc::c_ulong
                                            == offsetColon as libc::c_ulong
                                        {
                                            sym___0 = *(((**((*y).k)
                                                .as_mut_ptr()
                                                .offset(0 as libc::c_int as isize))
                                                .k)
                                                .as_mut_ptr() as *mut S);
                                            tmp___2 = strlen(sym___0 as *const libc::c_char);
                                            lenS___0 = tmp___2 as I;
                                            tmp___3 = _5m(
                                                *((*y).k).as_mut_ptr().offset(3 as libc::c_int as isize),
                                            );
                                            cod___0 = ((*tmp___3).k).as_mut_ptr() as *mut C;
                                            tmp___4 = strlen(cod___0 as *const libc::c_char);
                                            lenC___0 = tmp___4 as I;
                                            let vla_0 = (lenS___0 + lenC___0 + 2 as libc::c_longlong)
                                                as usize;
                                            let mut str___0: Vec::<C> = ::std::vec::from_elem(0, vla_0);
                                            i___0 = 0 as libc::c_int as I;
                                            i___0 = 0 as libc::c_int as I;
                                            while i___0 < lenS___0 {
                                                *str___0
                                                    .as_mut_ptr()
                                                    .offset(i___0 as isize) = *sym___0.offset(i___0 as isize);
                                                i___0 += 1;
                                            }
                                            i___0 = 0 as libc::c_int as I;
                                            while i___0 < lenC___0 {
                                                *str___0
                                                    .as_mut_ptr()
                                                    .offset(
                                                        (i___0 + lenS___0 + 1 as libc::c_longlong) as isize,
                                                    ) = *cod___0.offset(i___0 as isize);
                                                i___0 += 1;
                                            }
                                            *str___0
                                                .as_mut_ptr()
                                                .offset(lenS___0 as isize) = ':' as i32 as C;
                                            *str___0
                                                .as_mut_ptr()
                                                .offset(
                                                    (lenS___0 + lenC___0 + 1 as libc::c_longlong) as isize,
                                                ) = '\u{0}' as i32 as C;
                                            tmp___5 = Ks(str___0.as_mut_ptr());
                                            q___0 = tmp___5;
                                            res = ksender(
                                                *(((*x___0).k).as_mut_ptr() as *mut I),
                                                q___0,
                                                0 as libc::c_int as I,
                                            );
                                            cd(q___0);
                                            current_block = 18139099716546303047;
                                        } else {
                                            current_block = 14244865397154871861;
                                        }
                                    } else {
                                        current_block = 14244865397154871861;
                                    }
                                } else {
                                    current_block = 14244865397154871861;
                                }
                            } else {
                                current_block = 14244865397154871861;
                            }
                        } else {
                            current_block = 14244865397154871861;
                        }
                    } else {
                        current_block = 14244865397154871861;
                    }
                } else {
                    current_block = 14244865397154871861;
                }
                match current_block {
                    18139099716546303047 => {}
                    _ => {
                        if (*y).t == 0 as libc::c_longlong {
                            if (*y).n == 3 as libc::c_longlong {
                                if (**((*y).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .t == 7 as libc::c_longlong
                                {
                                    if (**((*y).k)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize))
                                        .n == 3 as libc::c_longlong
                                    {
                                        if (**((*y).k)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize))
                                            .t == 0 as libc::c_longlong
                                        {
                                            if (**((*y).k)
                                                .as_mut_ptr()
                                                .offset(1 as libc::c_int as isize))
                                                .n == 0 as libc::c_longlong
                                            {
                                                sym___1 = *(((**((*y).k)
                                                    .as_mut_ptr()
                                                    .offset(0 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr() as *mut S);
                                                tmp___6 = strlen(sym___1 as *const libc::c_char);
                                                lenS___1 = tmp___6 as I;
                                                cod___1 = ((**((**((*y).k)
                                                    .as_mut_ptr()
                                                    .offset(2 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr()
                                                    .offset(2 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr() as *mut C;
                                                tmp___7 = strlen(cod___1 as *const libc::c_char);
                                                lenC___1 = tmp___7 as I;
                                                let vla_1 = (2 as libc::c_longlong * lenS___1 + lenC___1
                                                    + 4 as libc::c_longlong) as usize;
                                                let mut str___1: Vec::<C> = ::std::vec::from_elem(0, vla_1);
                                                i___1 = 0 as libc::c_int as I;
                                                i___1 = 0 as libc::c_int as I;
                                                while i___1 < lenS___1 {
                                                    *str___1
                                                        .as_mut_ptr()
                                                        .offset(i___1 as isize) = *sym___1.offset(i___1 as isize);
                                                    i___1 += 1;
                                                }
                                                i___1 = 0 as libc::c_int as I;
                                                while i___1 < lenC___1 {
                                                    *str___1
                                                        .as_mut_ptr()
                                                        .offset(
                                                            (i___1 + lenS___1 + 2 as libc::c_longlong) as isize,
                                                        ) = *cod___1.offset(i___1 as isize);
                                                    i___1 += 1;
                                                }
                                                i___1 = 0 as libc::c_int as I;
                                                while i___1 < lenS___1 {
                                                    *str___1
                                                        .as_mut_ptr()
                                                        .offset(
                                                            (i___1 + lenS___1 + lenC___1 + 3 as libc::c_longlong)
                                                                as isize,
                                                        ) = *sym___1.offset(i___1 as isize);
                                                    i___1 += 1;
                                                }
                                                *str___1
                                                    .as_mut_ptr()
                                                    .offset(lenS___1 as isize) = ':' as i32 as C;
                                                *str___1
                                                    .as_mut_ptr()
                                                    .offset(
                                                        (lenS___1 + 1 as libc::c_longlong) as isize,
                                                    ) = '{' as i32 as C;
                                                *str___1
                                                    .as_mut_ptr()
                                                    .offset(
                                                        (lenS___1 + lenC___1 + 2 as libc::c_longlong) as isize,
                                                    ) = '}' as i32 as C;
                                                *str___1
                                                    .as_mut_ptr()
                                                    .offset(
                                                        (2 as libc::c_longlong * lenS___1 + lenC___1
                                                            + 3 as libc::c_longlong) as isize,
                                                    ) = '\u{0}' as i32 as C;
                                                tmp___8 = Ks(str___1.as_mut_ptr());
                                                q___1 = tmp___8;
                                                res = ksender(
                                                    *(((*x___0).k).as_mut_ptr() as *mut I),
                                                    q___1,
                                                    0 as libc::c_int as I,
                                                );
                                                cd(q___1);
                                                current_block = 18139099716546303047;
                                            } else {
                                                current_block = 12432372503027333213;
                                            }
                                        } else {
                                            current_block = 12432372503027333213;
                                        }
                                    } else {
                                        current_block = 12432372503027333213;
                                    }
                                } else {
                                    current_block = 12432372503027333213;
                                }
                            } else {
                                current_block = 12432372503027333213;
                            }
                        } else {
                            current_block = 12432372503027333213;
                        }
                        match current_block {
                            18139099716546303047 => {}
                            _ => {
                                if (*y).t == 0 as libc::c_longlong {
                                    if (*y).n == 3 as libc::c_longlong {
                                        if (**((*y).k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .t == 7 as libc::c_longlong
                                        {
                                            if (**((*y).k)
                                                .as_mut_ptr()
                                                .offset(2 as libc::c_int as isize))
                                                .n == 1 as libc::c_longlong
                                            {
                                                if (**((*y).k)
                                                    .as_mut_ptr()
                                                    .offset(1 as libc::c_int as isize))
                                                    .t == 0 as libc::c_longlong
                                                {
                                                    if (**((*y).k)
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize))
                                                        .n == 0 as libc::c_longlong
                                                    {
                                                        sym___2 = *(((**((*y).k)
                                                            .as_mut_ptr()
                                                            .offset(0 as libc::c_int as isize))
                                                            .k)
                                                            .as_mut_ptr() as *mut S);
                                                        tmp___9 = strlen(sym___2 as *const libc::c_char);
                                                        lenS___2 = tmp___9 as I;
                                                        tmp___10 = _5m(
                                                            *((*y).k).as_mut_ptr().offset(2 as libc::c_int as isize),
                                                        );
                                                        cod___2 = ((*tmp___10).k).as_mut_ptr() as *mut C;
                                                        tmp___11 = strlen(cod___2 as *const libc::c_char);
                                                        lenC___2 = tmp___11 as I;
                                                        let vla_2 = (2 as libc::c_longlong * lenS___2 + lenC___2
                                                            + 2 as libc::c_longlong) as usize;
                                                        let mut str___2: Vec::<C> = ::std::vec::from_elem(0, vla_2);
                                                        i___2 = 0 as libc::c_int as I;
                                                        i___2 = 0 as libc::c_int as I;
                                                        while i___2 < lenS___2 {
                                                            *str___2
                                                                .as_mut_ptr()
                                                                .offset(i___2 as isize) = *sym___2.offset(i___2 as isize);
                                                            i___2 += 1;
                                                        }
                                                        i___2 = 0 as libc::c_int as I;
                                                        while i___2 < lenC___2 {
                                                            *str___2
                                                                .as_mut_ptr()
                                                                .offset(
                                                                    (i___2 + lenS___2 + 1 as libc::c_longlong) as isize,
                                                                ) = *cod___2.offset(i___2 as isize);
                                                            i___2 += 1;
                                                        }
                                                        i___2 = 0 as libc::c_int as I;
                                                        while i___2 < lenS___2 {
                                                            *str___2
                                                                .as_mut_ptr()
                                                                .offset(
                                                                    (i___2 + lenS___2 + lenC___2 + 1 as libc::c_longlong)
                                                                        as isize,
                                                                ) = *sym___2.offset(i___2 as isize);
                                                            i___2 += 1;
                                                        }
                                                        *str___2
                                                            .as_mut_ptr()
                                                            .offset(lenS___2 as isize) = ':' as i32 as C;
                                                        *str___2
                                                            .as_mut_ptr()
                                                            .offset(
                                                                (2 as libc::c_longlong * lenS___2 + lenC___2
                                                                    + 1 as libc::c_longlong) as isize,
                                                            ) = '\u{0}' as i32 as C;
                                                        tmp___12 = Ks(str___2.as_mut_ptr());
                                                        q___2 = tmp___12;
                                                        res = ksender(
                                                            *(((*x___0).k).as_mut_ptr() as *mut I),
                                                            q___2,
                                                            0 as libc::c_int as I,
                                                        );
                                                        cd(q___2);
                                                    } else {
                                                        tmp___13 = kerr(
                                                            b"nyi\0" as *const u8 as *const libc::c_char,
                                                        );
                                                        return tmp___13;
                                                    }
                                                } else {
                                                    tmp___13 = kerr(
                                                        b"nyi\0" as *const u8 as *const libc::c_char,
                                                    );
                                                    return tmp___13;
                                                }
                                            } else {
                                                tmp___13 = kerr(
                                                    b"nyi\0" as *const u8 as *const libc::c_char,
                                                );
                                                return tmp___13;
                                            }
                                        } else {
                                            tmp___13 = kerr(
                                                b"nyi\0" as *const u8 as *const libc::c_char,
                                            );
                                            return tmp___13;
                                        }
                                    } else {
                                        tmp___13 = kerr(
                                            b"nyi\0" as *const u8 as *const libc::c_char,
                                        );
                                        return tmp___13;
                                    }
                                } else {
                                    tmp___13 = kerr(
                                        b"nyi\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___13;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if -(1 as libc::c_longlong) == res {
        tmp___14 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___14;
    }
    tmp___15 = _n();
    return tmp___15;
}
pub unsafe extern "C" fn popen_charvec(mut cmd: *mut C) -> K {
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut z: K = 0 as *mut k0;
    let mut l: K = 0 as *mut k0;
    let mut s: S = 0 as *mut C;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    s = 0 as S;
    n = 0 as libc::c_int as I;
    f = popen(cmd as *const libc::c_char, b"r\0" as *const u8 as *const libc::c_char);
    if f.is_null() {
        tmp = _n();
        return tmp;
    }
    z = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
    loop {
        tmp___0 = getline_(&mut s, &mut n, f);
        if !(tmp___0 >= 0 as libc::c_longlong) {
            break;
        }
        l = newK(-(3 as libc::c_int) as I, n - 1 as libc::c_longlong);
        strncpy(
            ((*l).k).as_mut_ptr() as *mut C as *mut libc::c_char,
            s as *const libc::c_char,
            (n - 1 as libc::c_longlong) as size_t,
        );
        kap(&mut z, &mut l as *mut K as V);
    }
    free(s as *mut libc::c_void);
    pclose(f);
    return z;
}
unsafe extern "C" fn parse(mut s: S, mut argv: *mut S, mut c: C) {
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: *mut S = 0 as *mut S;
    while *s as libc::c_int != 0 as libc::c_int {
        loop {
            if !(*s as libc::c_int == c as libc::c_int) {
                if !(*s as libc::c_int == 9 as libc::c_int) {
                    if !(*s as libc::c_int == 10 as libc::c_int) {
                        break;
                    }
                }
            }
            tmp = s;
            s = s.offset(1);
            *tmp = '\u{0}' as i32 as C;
        }
        tmp___0 = argv;
        argv = argv.offset(1);
        *tmp___0 = s;
        while *s as libc::c_int != 0 as libc::c_int {
            if !(*s as libc::c_int != c as libc::c_int) {
                break;
            }
            if !(*s as libc::c_int != 9 as libc::c_int) {
                break;
            }
            if !(*s as libc::c_int != 10 as libc::c_int) {
                break;
            }
            s = s.offset(1);
        }
    }
    *argv = 0 as *mut libc::c_void as S;
}
unsafe extern "C" fn execute(mut argvP: *mut S, mut fWait: I) {
    let mut pid: pid_t = 0;
    let mut status: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: __pid_t = 0;
    pid = fork();
    if pid < 0 as libc::c_int {
        printf(
            b"*** ERROR: forking child process failed\n\0" as *const u8
                as *const libc::c_char,
        );
        exit(1 as libc::c_int);
    } else {
        if pid == 0 as libc::c_int {
            tmp = execvp(
                *argvP as *const libc::c_char,
                argvP as *const *mut libc::c_char,
            );
            if tmp < 0 as libc::c_int {
                printf(
                    b"*** ERROR: exec failed\n\0" as *const u8 as *const libc::c_char,
                );
                exit(1 as libc::c_int);
            }
        } else if fWait != 0 {
            loop {
                tmp___0 = wait(&mut status as *mut I as *mut libc::c_int);
                if !(tmp___0 != pid) {
                    break;
                }
            }
        }
    };
}
pub unsafe extern "C" fn _4d_(mut srvr: S, mut port___0: S, mut y: K) -> K {
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut servinfo: *mut addrinfo = 0 as *mut addrinfo;
    let mut p: *mut addrinfo = 0 as *mut addrinfo;
    let mut rv: libc::c_int = 0;
    let mut sockfd: libc::c_int = 0;
    let mut errstr: S = 0 as *mut C;
    let mut r: I = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut tmp___6: size_t = 0;
    let mut i: I = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: size_t = 0;
    let mut tmp___11: ssize_t = 0;
    let mut buf___1: [C; 20000] = [0; 20000];
    let mut size: I = 0;
    let mut data: S = 0 as *mut C;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut n1: I = 0;
    let mut tmp___13: ssize_t = 0;
    let mut tmp___14: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_family = 0 as libc::c_int;
    hints.ai_socktype = 1 as libc::c_int;
    rv = getaddrinfo(
        srvr as *const libc::c_char,
        port___0 as *const libc::c_char,
        &mut hints as *mut addrinfo as *const addrinfo,
        &mut servinfo as *mut *mut addrinfo,
    );
    if rv != 0 {
        tmp = gai_strerror(rv);
        fprintf(stderr, b"conn: %s\n\0" as *const u8 as *const libc::c_char, tmp);
        tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    p = servinfo;
    while p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        sockfd = socket((*p).ai_family, (*p).ai_socktype, (*p).ai_protocol);
        if !(sockfd == -(1 as libc::c_int)) {
            tmp___4 = connect(sockfd, (*p).ai_addr as *const sockaddr, (*p).ai_addrlen);
            if !(tmp___4 == -(1 as libc::c_int)) {
                break;
            }
            tmp___1 = __errno_location();
            errstr = strerror(*tmp___1);
            tmp___2 = close(sockfd);
            r = tmp___2 as I;
            if r != 0 {
                tmp___3 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                return tmp___3;
            }
        }
        p = (*p).ai_next;
    }
    if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        fprintf(
            stderr,
            b"conn: failed to connect (%s)\n\0" as *const u8 as *const libc::c_char,
            errstr,
        );
        freeaddrinfo(servinfo);
        tmp___5 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___5;
    }
    tmp___6 = strlen(((*y).k).as_mut_ptr() as *mut C as *const libc::c_char);
    n = tmp___6 as I;
    let vla = (n + 5 as libc::c_longlong) as usize;
    let mut msg: Vec::<C> = ::std::vec::from_elem(0, vla);
    i = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    while i < n + 1 as libc::c_longlong {
        *msg
            .as_mut_ptr()
            .offset(i as isize) = *(((*y).k).as_mut_ptr() as *mut C).offset(i as isize);
        i += 1;
    }
    *msg.as_mut_ptr().offset(n as isize) = '\r' as i32 as C;
    *msg.as_mut_ptr().offset((n + 1 as libc::c_longlong) as isize) = '\n' as i32 as C;
    *msg.as_mut_ptr().offset((n + 2 as libc::c_longlong) as isize) = '\r' as i32 as C;
    *msg.as_mut_ptr().offset((n + 3 as libc::c_longlong) as isize) = '\n' as i32 as C;
    *msg.as_mut_ptr().offset((n + 4 as libc::c_longlong) as isize) = '\u{0}' as i32 as C;
    tmp___10 = strlen(msg.as_mut_ptr() as *const libc::c_char);
    tmp___11 = write(
        sockfd,
        msg.as_mut_ptr() as *mut C as *const libc::c_void,
        tmp___10,
    );
    if tmp___11 == -(1 as libc::c_long) {
        tmp___7 = close(sockfd);
        r = tmp___7 as I;
        if r != 0 {
            tmp___8 = kerr(b"file\0" as *const u8 as *const libc::c_char);
            return tmp___8;
        }
        tmp___9 = kerr(b"write\0" as *const u8 as *const libc::c_char);
        return tmp___9;
    }
    size = 30000 as libc::c_int as I;
    tmp___12 = malloc(size as size_t);
    data = tmp___12 as S;
    n1 = 1 as libc::c_int as I;
    n = 0 as libc::c_int as I;
    loop {
        tmp___13 = read(
            sockfd,
            &mut buf___1 as *mut [C; 20000] as *mut libc::c_void,
            20000 as libc::c_int as size_t,
        );
        n1 = tmp___13 as I;
        if n1 == 0 as libc::c_longlong {
            break;
        }
        if n1 < 0 as libc::c_longlong {
            tmp___14 = __errno_location();
            printf(b"errno: %d\n\0" as *const u8 as *const libc::c_char, *tmp___14);
            return 0 as K;
        }
        if n + n1 > size - 1 as libc::c_longlong {
            size += 20000 as libc::c_longlong;
            tmp___15 = realloc(data as *mut libc::c_void, size as size_t);
            data = tmp___15 as S;
        }
        i = 0 as libc::c_int as I;
        while i < n1 + 1 as libc::c_longlong {
            *data.offset((n + i) as isize) = buf___1[i as usize];
            i += 1;
        }
        n += n1;
        if n1 == 0 {
            break;
        }
    }
    tmp___16 = close(sockfd);
    r = tmp___16 as I;
    if r != 0 {
        tmp___17 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___17;
    }
    if n == 1 as libc::c_longlong {
        tmp___18 = 3 as libc::c_int;
    } else {
        tmp___18 = -(3 as libc::c_int);
    }
    tmp___19 = newK(tmp___18 as I, n);
    z = tmp___19;
    memcpy(
        ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
        data as *const libc::c_void,
        n as size_t,
    );
    freeaddrinfo(servinfo);
    free(data as *mut libc::c_void);
    if n != 0 {
        tmp___21 = z;
    } else {
        tmp___20 = _n();
        tmp___21 = tmp___20;
    }
    return tmp___21;
}
unsafe extern "C" fn run(mut x___0: K) -> K {
    let mut line___0: S = 0 as *mut C;
    let mut argvL: [S; 64] = [0 as *mut C; 64];
    let mut argvP: [S; 64] = [0 as *mut C; 64];
    let mut i: I = 0;
    let mut fWait: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: K = 0 as *mut k0;
    line___0 = ((*x___0).k).as_mut_ptr() as *mut C;
    fWait = 1 as libc::c_int as I;
    parse(line___0, argvL.as_mut_ptr(), ';' as i32 as C);
    i = 0 as libc::c_int as I;
    while argvL[i as usize] as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        parse(argvL[i as usize], argvP.as_mut_ptr(), ' ' as i32 as C);
        if argvL[1 as libc::c_int as usize] as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp = strcmp(
                argvP[0 as libc::c_int as usize] as *const libc::c_char,
                b"echo\0" as *const u8 as *const libc::c_char,
            );
            if tmp != 0 as libc::c_int {
                fWait = 0 as libc::c_int as I;
            }
        }
        execute(argvP.as_mut_ptr(), fWait);
        i += 1;
    }
    tmp___0 = _n();
    return tmp___0;
}
pub unsafe extern "C" fn _3d(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    if (*x___0).t < 0 as libc::c_longlong {
        tmp___0 = -(*x___0).t;
    } else {
        tmp___0 = (*x___0).t;
    }
    if 3 as libc::c_longlong == tmp___0 {
        tmp = _5d_(x___0, y, 0 as libc::c_int as I);
        return tmp;
    }
    if 4 as libc::c_longlong == (*x___0).t {
        if **(((*x___0).k).as_mut_ptr() as *mut S) == 0 {
            tmp___1 = run(y);
            tmp___3 = tmp___1;
        } else {
            tmp___2 = _5d_(x___0, y, 0 as libc::c_int as I);
            tmp___3 = tmp___2;
        }
        return tmp___3;
    }
    if 1 as libc::c_longlong != (*x___0).t {
        tmp___4 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___4;
    }
    tmp___5 = _3d_(x___0, y);
    return tmp___5;
}
pub unsafe extern "C" fn _4d(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut sockfd: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut port___0: [C; 6] = [0; 6];
    let mut n: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    if 4 as libc::c_longlong == (*x___0).t {
        if **(((*x___0).k).as_mut_ptr() as *mut S) == 0 {
            if -(3 as libc::c_longlong) == (*y).t {
                tmp = popen_charvec(((*y).k).as_mut_ptr() as *mut C);
                return tmp;
            }
        }
    }
    if 1 as libc::c_longlong == (*x___0).t {
        sockfd = *(((*x___0).k).as_mut_ptr() as *mut I);
        tmp___1 = ksender(sockfd, y, 1 as libc::c_int as I);
        if -(1 as libc::c_longlong) == tmp___1 {
            tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        }
        z = 0 as K;
        while 2 as libc::c_longlong != fer {
            z = read_tape(sockfd, sockfd, 1 as libc::c_int as I);
            if !z.is_null() {
                break;
            }
        }
        if z as libc::c_ulong == -(1 as libc::c_int) as K as libc::c_ulong {
            tmp___2 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
        if z.is_null() {
            return 0 as K;
        }
        return z;
    }
    if -(4 as libc::c_longlong) == (*x___0).t {
        if 2 as libc::c_longlong == (*x___0).n {
            tmp___3 = _4d_(
                *(((*x___0).k).as_mut_ptr() as *mut S).offset(0 as libc::c_int as isize),
                *(((*x___0).k).as_mut_ptr() as *mut S).offset(1 as libc::c_int as isize),
                y,
            );
            return tmp___3;
        }
    }
    if 0 as libc::c_longlong == (*x___0).t {
        if 2 as libc::c_longlong == (*x___0).n {
            if 4 as libc::c_longlong
                == (**((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t
            {
                if 1 as libc::c_longlong
                    == (**((*x___0).k).as_mut_ptr().offset(1 as libc::c_int as isize)).t
                {
                    if 0 as libc::c_longlong
                        <= *(((**((*x___0).k)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize))
                            .k)
                            .as_mut_ptr() as *mut I)
                    {
                        tmp___4 = snprintf(
                            port___0.as_mut_ptr() as *mut libc::c_char,
                            6 as libc::c_int as size_t,
                            b"%lld\0" as *const u8 as *const libc::c_char,
                            *(((**((*x___0).k)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr() as *mut I),
                        );
                        n = tmp___4;
                        if n >= 6 as libc::c_int {
                            tmp___5 = kerr(
                                b"write\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___5;
                        }
                        tmp___6 = _4d_(
                            *(((**((*x___0).k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr() as *mut S),
                            port___0.as_mut_ptr(),
                            y,
                        );
                        return tmp___6;
                    }
                }
            }
        }
    }
    tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
    return tmp___7;
}
pub unsafe extern "C" fn _4m(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = Ki((*x___0).t);
    return tmp;
}
pub unsafe extern "C" fn _5m(mut x___0: K) -> K {
    let mut z: K = 0 as *mut k0;
    z = newK(-(3 as libc::c_int) as I, 0 as libc::c_int as I);
    if z.is_null() {
        return 0 as K;
    }
    printAtDepth(
        &mut z as *mut K as V,
        x___0,
        0 as libc::c_int as I,
        0 as libc::c_int as I,
        0 as libc::c_int as I,
        0 as libc::c_int as I,
    );
    return z;
}
unsafe extern "C" fn _5d_(mut x___0: K, mut y: K, mut dosync: I) -> K {
    let mut tmp: I = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    let mut sm: I = 0;
    let mut tmp___1: size_t = 0;
    let mut e: S = 0 as *mut C;
    let mut tmp___2: S = 0 as *mut C;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___4: S = 0 as *mut C;
    let mut c: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut f: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut s: I = 0;
    let mut ft: I = 0;
    let mut fn_0: I = 0;
    let mut g: I = 0;
    let mut tmp___8: ssize_t = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: ssize_t = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut b___1: I = 0;
    let mut tmp___12: I = 0;
    let mut n: I = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut v: S = 0 as *mut C;
    let mut tmp___14: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut res: I = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut w___0: *mut I = 0 as *mut I;
    let mut r: I = 0;
    let mut d___0: V = 0 as *mut libc::c_void;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___20: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___21: size_t = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut tmp___24: K = 0 as *mut k0;
    if 4 as libc::c_longlong != (*x___0).t {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp = -(*x___0).t;
        } else {
            tmp = (*x___0).t;
        }
        if 3 as libc::c_longlong != tmp {
            return 0 as K;
        }
    }
    tmp___0 = CSK(x___0);
    m = tmp___0;
    tmp___1 = strlen(m as *const libc::c_char);
    sm = tmp___1 as I;
    if sm > 1 as libc::c_longlong {
        if 46 as libc::c_int
            == *m.offset((sm - 2 as libc::c_longlong) as isize) as libc::c_int
        {
            if *(b"K\0" as *const u8 as *const libc::c_char) as libc::c_int
                == *m.offset((sm - 1 as libc::c_longlong) as isize) as libc::c_int
            {
                tmp___2 = strdupn(m, sm);
                tmp___4 = tmp___2;
            } else {
                tmp___3 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
                tmp___4 = tmp___3;
            }
        } else {
            tmp___3 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
            tmp___4 = tmp___3;
        }
    } else {
        tmp___3 = glueSS(m, b"K\0" as *const u8 as *const libc::c_char as S);
        tmp___4 = tmp___3;
    }
    e = tmp___4;
    if e.is_null() {
        return 0 as K;
    }
    tmp___5 = open(e as *const libc::c_char, 2 as libc::c_int, 4095 as libc::c_int);
    f = tmp___5 as I;
    if f >= 0 as libc::c_longlong {
        stat(e as *const libc::c_char, &mut c as *mut stat);
    } else {
        tmp___6 = open(m as *const libc::c_char, 2 as libc::c_int, 4095 as libc::c_int);
        f = tmp___6 as I;
        stat(m as *const libc::c_char, &mut c as *mut stat);
    }
    free(e as *mut libc::c_void);
    if f < 0 as libc::c_longlong {
        tmp___7 = _1d_write(x___0, y, 1 as libc::c_int as I);
        return tmp___7;
    }
    s = c.st_size as I;
    if (s as libc::c_ulonglong)
        < (4 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as libc::c_ulonglong
    {
        return 0 as K;
    }
    tmp___8 = pread(
        f as libc::c_int,
        &mut ft as *mut I as *mut libc::c_void,
        ::std::mem::size_of::<I>() as libc::c_ulong,
        (2 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as __off_t,
    );
    g = tmp___8 as I;
    if g == 0 {
        tmp___9 = kerr(b"pread\0" as *const u8 as *const libc::c_char);
        show(tmp___9);
    }
    tmp___10 = pread(
        f as libc::c_int,
        &mut fn_0 as *mut I as *mut libc::c_void,
        ::std::mem::size_of::<I>() as libc::c_ulong,
        (2 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<I>() as libc::c_ulong) as __off_t,
    );
    g = tmp___10 as I;
    if g == 0 {
        tmp___11 = kerr(b"pread\0" as *const u8 as *const libc::c_char);
        show(tmp___11);
    }
    if (*y).t > 0 as libc::c_longlong {
        if (*y).t != 5 as libc::c_longlong {
            return 0 as K;
        }
    }
    if ft != (*y).t {
        return 0 as K;
    }
    tmp___12 = disk(y);
    b___1 = (tmp___12 as libc::c_ulonglong)
        .wrapping_sub(
            (4 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
                as libc::c_ulonglong,
        )
        .wrapping_sub(
            (-(3 as libc::c_longlong) == (*y).t) as libc::c_int as libc::c_ulonglong,
        ) as I;
    n = s + b___1;
    tmp___13 = ftruncate(f as libc::c_int, n as __off_t);
    if tmp___13 != 0 {
        return 0 as K;
    }
    tmp___17 = mmap(
        0 as *mut libc::c_void,
        n as size_t,
        2 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        0 as libc::c_int as __off_t,
    );
    v = tmp___17 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___14 = __errno_location();
        tmp___15 = strerror(*tmp___14);
        tmp___16 = kerr(tmp___15 as cS);
        return tmp___16;
    }
    tmp___18 = close(f as libc::c_int);
    res = tmp___18 as I;
    if res != 0 {
        tmp___19 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___19;
    }
    w___0 = v as *mut I;
    *w___0.offset(3 as libc::c_int as isize) = fn_0 + (*y).n;
    r = 0 as libc::c_int as I;
    d___0 = v.offset(s as isize) as V;
    let mut current_block_123: u64;
    if 0 as libc::c_longlong == (*y).t {
        current_block_123 = 819887322739448252;
    } else if 5 as libc::c_longlong == (*y).t {
        current_block_123 = 819887322739448252;
    } else {
        if -(4 as libc::c_longlong) == (*y).t {
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*y).n;
            while i___0 < _i___1 {
                tmp___21 = strlen(
                    *(((*y).k).as_mut_ptr() as *mut S).offset(i___0 as isize)
                        as *const libc::c_char,
                );
                s = (1 as libc::c_ulong).wrapping_add(tmp___21) as I;
                memcpy(
                    d___0.offset(r as isize),
                    *(((*y).k).as_mut_ptr() as *mut S).offset(i___0 as isize)
                        as *const libc::c_void,
                    s as size_t,
                );
                r += s;
                i___0 += 1;
            }
        } else if -(3 as libc::c_longlong) == (*y).t {
            memcpy(
                d___0.offset(-(1 as libc::c_int as isize)),
                ((*y).k).as_mut_ptr() as *const libc::c_void,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<C>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
            *(d___0 as S).offset((*y).n as isize) = 0 as libc::c_int as C;
        } else if -(2 as libc::c_longlong) == (*y).t {
            memcpy(
                d___0,
                ((*y).k).as_mut_ptr() as *const libc::c_void,
                ((*y).n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
        } else if -(1 as libc::c_longlong) == (*y).t {
            memcpy(
                d___0,
                ((*y).k).as_mut_ptr() as *const libc::c_void,
                ((*y).n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
        }
        current_block_123 = 14913924298693586572;
    }
    match current_block_123 {
        819887322739448252 => {
            i = 0 as libc::c_int as I;
            _i___0 = (*y).n;
            while i < _i___0 {
                tmp___20 = wrep(
                    *((*y).k).as_mut_ptr().offset(i as isize),
                    d___0.offset(r as isize),
                    1 as libc::c_int as I,
                );
                r += tmp___20;
                i += 1;
            }
        }
        _ => {}
    }
    if dosync != 0 {
        msync(v as *mut libc::c_void, n as size_t, 6 as libc::c_int);
    }
    tmp___22 = munmap(v as *mut libc::c_void, n as size_t);
    res = tmp___22 as I;
    if res != 0 {
        tmp___23 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___23;
    }
    tmp___24 = Ki(fn_0 + (*y).n);
    return tmp___24;
}
pub unsafe extern "C" fn _5d(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = _5d_(x___0, y, 1 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn _6m(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = readVector(x___0, -(3 as libc::c_int) as I);
    return tmp;
}
unsafe extern "C" fn readVector(mut x___0: K, mut t: I) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut s: I = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: S = 0 as *mut C;
    let mut tmp___5: I = 0;
    let mut f: I = 0;
    let mut tmp___6: S = 0 as *mut C;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut v: S = 0 as *mut C;
    let mut tmp___9: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: I = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___15: I = 0;
    let mut tmp___16: libc::c_double = 0.;
    let mut tmp___17: K = 0 as *mut k0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: K = 0 as *mut k0;
    if 4 as libc::c_longlong != (*x___0).t {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___0 = -(*x___0).t;
        } else {
            tmp___0 = (*x___0).t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___4 = CSK(x___0);
    tmp___5 = stat_sz(tmp___4, &mut s);
    if tmp___5 != 0 {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        tmp___3 = kerr(tmp___2 as cS);
        return tmp___3;
    }
    tmp___6 = CSK(x___0);
    tmp___7 = open(tmp___6 as *const libc::c_char, 0 as libc::c_int);
    f = tmp___7 as I;
    if f < 0 as libc::c_longlong {
        tmp___8 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___8;
    }
    tmp___12 = mmap(
        0 as *mut libc::c_void,
        s as size_t,
        1 as libc::c_int,
        1 as libc::c_int,
        f as libc::c_int,
        0 as libc::c_int as __off_t,
    );
    v = tmp___12 as S;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == v as libc::c_ulong {
        tmp___9 = __errno_location();
        tmp___10 = strerror(*tmp___9);
        tmp___11 = kerr(tmp___10 as cS);
        return tmp___11;
    }
    tmp___13 = close(f as libc::c_int);
    r = tmp___13 as I;
    if r != 0 {
        tmp___14 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___14;
    }
    tmp___15 = bp(t);
    tmp___16 = ceil(s as F / tmp___15 as F);
    tmp___17 = newK(t, tmp___16 as I);
    z = tmp___17;
    memcpy(
        ((*z).k).as_mut_ptr() as *mut libc::c_void,
        v as *const libc::c_void,
        s as size_t,
    );
    tmp___18 = munmap(v as *mut libc::c_void, s as size_t);
    r = tmp___18 as I;
    if r != 0 {
        tmp___19 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
        return tmp___19;
    }
    return z;
}
pub unsafe extern "C" fn _6d(mut a: K, mut b___1: K) -> K {
    let mut append: I = 0;
    let mut c: K = 0 as *mut k0;
    let mut tmp: I = 0;
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___2: S = 0 as *mut C;
    let mut f: I = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut e: I = 0;
    let mut tmp___6: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    let mut tmp___10: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: K = 0 as *mut k0;
    let mut r: I = 0;
    let mut tmp___13: ssize_t = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: K = 0 as *mut k0;
    let mut tmp___18: libc::c_int = 0;
    let mut v: S = 0 as *mut C;
    let mut tmp___19: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___20: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___23: libc::c_int = 0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut tmp___27: K = 0 as *mut k0;
    append = 0 as libc::c_int as I;
    c = a;
    let mut current_block_9: u64;
    if 0 as libc::c_longlong == (*a).t {
        if 1 as libc::c_longlong == (*a).n {
            append = 1 as libc::c_int as I;
            c = *((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize);
            current_block_9 = 6669252993407410313;
        } else {
            current_block_9 = 2731210477330322003;
        }
    } else {
        current_block_9 = 2731210477330322003;
    }
    match current_block_9 {
        2731210477330322003 => {
            if -(4 as libc::c_longlong) == (*c).t {
                if 1 as libc::c_longlong == (*c).n {
                    append = 1 as libc::c_int as I;
                }
            }
        }
        _ => {}
    }
    if 4 as libc::c_longlong != (*c).t {
        if (*c).t < 0 as libc::c_longlong {
            tmp = -(*c).t;
        } else {
            tmp = (*c).t;
        }
        if 3 as libc::c_longlong != tmp {
            if append == 0 {
                if -(4 as libc::c_longlong) == (*c).t {
                    return 0 as K;
                }
            }
        }
    }
    t = (*b___1).t;
    n = (*b___1).n;
    if t < 0 as libc::c_longlong {
        tmp___1 = -t;
    } else {
        tmp___1 = t;
    }
    if 3 as libc::c_longlong != tmp___1 {
        tmp___0 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    tmp___2 = CSK(c);
    m = tmp___2;
    if *m.offset(0 as libc::c_int as isize) != 0 {
        if append != 0 {
            tmp___3 = 0 as libc::c_int;
        } else {
            tmp___3 = 512 as libc::c_int;
        }
        tmp___4 = open(
            m as *const libc::c_char,
            66 as libc::c_int | tmp___3,
            4095 as libc::c_int,
        );
        tmp___5 = tmp___4;
    } else {
        tmp___5 = 1 as libc::c_int;
    }
    f = tmp___5 as I;
    e = 0 as libc::c_int as I;
    if append != 0 {
        if *m.offset(0 as libc::c_int as isize) != 0 {
            tmp___9 = stat_sz(m, &mut e);
            if tmp___9 != 0 {
                tmp___6 = __errno_location();
                tmp___7 = strerror(*tmp___6);
                tmp___8 = kerr(tmp___7 as cS);
                return tmp___8;
            }
        }
    }
    if f < 0 as libc::c_longlong {
        tmp___10 = __errno_location();
        tmp___11 = strerror(*tmp___10);
        tmp___12 = kerr(tmp___11 as cS);
        return tmp___12;
    }
    if 1 as libc::c_longlong == f {
        tmp___13 = write(
            f as libc::c_int,
            ((*b___1).k).as_mut_ptr() as *mut C as *const libc::c_void,
            n as size_t,
        );
        r = tmp___13 as I;
        if r == 0 {
            tmp___14 = kerr(b"write\0" as *const u8 as *const libc::c_char);
            show(tmp___14);
        }
    } else {
        tmp___18 = ftruncate(f as libc::c_int, (e + n) as __off_t);
        if tmp___18 != 0 {
            tmp___15 = __errno_location();
            tmp___16 = strerror(*tmp___15);
            tmp___17 = kerr(tmp___16 as cS);
            return tmp___17;
        }
        tmp___22 = mmap(
            0 as *mut libc::c_void,
            (e + n) as size_t,
            2 as libc::c_int,
            1 as libc::c_int,
            f as libc::c_int,
            0 as libc::c_int as __off_t,
        );
        v = tmp___22 as S;
        if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong
            == v as libc::c_ulong
        {
            tmp___19 = __errno_location();
            tmp___20 = strerror(*tmp___19);
            tmp___21 = kerr(tmp___20 as cS);
            return tmp___21;
        }
        tmp___23 = close(f as libc::c_int);
        r = tmp___23 as I;
        if r != 0 {
            tmp___24 = kerr(b"file\0" as *const u8 as *const libc::c_char);
            return tmp___24;
        }
        memcpy(
            v.offset(e as isize) as *mut libc::c_void,
            ((*b___1).k).as_mut_ptr() as *mut C as *const libc::c_void,
            n as size_t,
        );
        msync(v.offset(e as isize) as *mut libc::c_void, n as size_t, 6 as libc::c_int);
        tmp___25 = munmap(v as *mut libc::c_void, (e + n) as size_t);
        r = tmp___25 as I;
        if r != 0 {
            tmp___26 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
            return tmp___26;
        }
    }
    tmp___27 = _n();
    return tmp___27;
}
pub unsafe extern "C" fn _3m(mut x___0: K) -> K {
    let mut i: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut host: S = 0 as *mut C;
    let mut tmp___4: S = 0 as *mut C;
    let mut errstr: S = 0 as *mut C;
    let mut port___0: [libc::c_char; 256] = [0; 256];
    let mut sockfd: libc::c_int = 0;
    let mut rv: libc::c_int = 0;
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut servinfo: *mut addrinfo = 0 as *mut addrinfo;
    let mut p: *mut addrinfo = 0 as *mut addrinfo;
    let mut r: I = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut yes: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    if 1 as libc::c_longlong == (*x___0).t {
        tmp = close(*(((*x___0).k).as_mut_ptr() as *mut I) as libc::c_int);
        i = tmp as I;
        if i != 0 {
            tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            tmp___2 = tmp___0;
        } else {
            tmp___1 = _n();
            tmp___2 = tmp___1;
        }
        return tmp___2;
    } else {
        if (*x___0).t != 0 {
            tmp___3 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___3;
        } else {
            if (*x___0).n != 2 as libc::c_longlong {
                tmp___3 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___3;
            } else {
                if (**((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t
                    != 4 as libc::c_longlong
                {
                    tmp___3 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___3;
                } else {
                    if (**((*x___0).k).as_mut_ptr().offset(1 as libc::c_int as isize)).t
                        != 1 as libc::c_longlong
                    {
                        tmp___3 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                        return tmp___3;
                    }
                }
            }
        }
    }
    tmp___4 = CSK(*((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize));
    host = tmp___4;
    snprintf(
        port___0.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"%lld\0" as *const u8 as *const libc::c_char,
        *(((**((*x___0).k).as_mut_ptr().offset(1 as libc::c_int as isize)).k)
            .as_mut_ptr() as *mut I),
    );
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_family = 0 as libc::c_int;
    hints.ai_socktype = 1 as libc::c_int;
    rv = getaddrinfo(
        host as *const libc::c_char,
        port___0.as_mut_ptr() as *const libc::c_char,
        &mut hints as *mut addrinfo as *const addrinfo,
        &mut servinfo as *mut *mut addrinfo,
    );
    if rv != 0 {
        tmp___5 = gai_strerror(rv);
        fprintf(stderr, b"conn: %s\n\0" as *const u8 as *const libc::c_char, tmp___5);
        tmp___6 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___6;
    }
    p = servinfo;
    while p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        sockfd = socket((*p).ai_family, (*p).ai_socktype, (*p).ai_protocol);
        if !(sockfd == -(1 as libc::c_int)) {
            tmp___10 = connect(sockfd, (*p).ai_addr as *const sockaddr, (*p).ai_addrlen);
            if !(tmp___10 == -(1 as libc::c_int)) {
                break;
            }
            tmp___7 = __errno_location();
            errstr = strerror(*tmp___7);
            tmp___8 = close(sockfd);
            r = tmp___8 as I;
            if r != 0 {
                tmp___9 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                return tmp___9;
            }
        }
        p = (*p).ai_next;
    }
    if p.is_null() {
        fprintf(
            stderr,
            b"conn: failed to connect (%s)\n\0" as *const u8 as *const libc::c_char,
            errstr,
        );
        freeaddrinfo(servinfo);
        tmp___11 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___11;
    }
    yes = 1 as libc::c_int as I;
    setsockopt(
        sockfd,
        6 as libc::c_int,
        1 as libc::c_int,
        &mut yes as *mut I as *const libc::c_void,
        ::std::mem::size_of::<I>() as libc::c_ulong as socklen_t,
    );
    freeaddrinfo(servinfo);
    wipe_tape(sockfd as I);
    tmp___12 = Ki(sockfd as I);
    return tmp___12;
}
#[inline]
unsafe extern "C" fn __bswap_32(mut __bsx: __uint32_t) -> __uint32_t {
    return (__bsx & 4278190080 as libc::c_uint) >> 24 as libc::c_int
        | (__bsx & 16711680 as libc::c_uint) >> 8 as libc::c_int
        | (__bsx & 65280 as libc::c_uint) << 8 as libc::c_int
        | (__bsx & 255 as libc::c_uint) << 24 as libc::c_int;
}
#[inline]
unsafe extern "C" fn __bswap_64(mut __bsx: __uint64_t) -> __uint64_t {
    return ((__bsx as libc::c_ulonglong & 18374686479671623680 as libc::c_ulonglong)
        >> 56 as libc::c_int
        | (__bsx as libc::c_ulonglong & 71776119061217280 as libc::c_ulonglong)
            >> 40 as libc::c_int
        | (__bsx as libc::c_ulonglong & 280375465082880 as libc::c_ulonglong)
            >> 24 as libc::c_int
        | (__bsx as libc::c_ulonglong & 1095216660480 as libc::c_ulonglong)
            >> 8 as libc::c_int
        | (__bsx as libc::c_ulonglong & 4278190080 as libc::c_ulonglong)
            << 8 as libc::c_int
        | (__bsx as libc::c_ulonglong & 16711680 as libc::c_ulonglong)
            << 24 as libc::c_int
        | (__bsx as libc::c_ulonglong & 65280 as libc::c_ulonglong) << 40 as libc::c_int
        | (__bsx as libc::c_ulonglong & 255 as libc::c_ulonglong) << 56 as libc::c_int)
        as __uint64_t;
}
pub unsafe extern "C" fn membswp32(mut d___0: V, mut s: V, mut n: I) -> V {
    let mut q: *mut uint32_t = 0 as *mut uint32_t;
    let mut p: *mut uint32_t = 0 as *mut uint32_t;
    let mut i: I = 0;
    let mut tmp: *mut uint32_t = 0 as *mut uint32_t;
    let mut tmp___0: *mut uint32_t = 0 as *mut uint32_t;
    q = d___0 as *mut uint32_t;
    p = s as *mut uint32_t;
    i = 0 as libc::c_int as I;
    while i < n {
        tmp = q;
        q = q.offset(1);
        tmp___0 = p;
        p = p.offset(1);
        *tmp = __bswap_32(*tmp___0);
        i += 4 as libc::c_longlong;
    }
    return d___0;
}
pub unsafe extern "C" fn membswp64(mut d___0: V, mut s: V, mut n: I) -> V {
    let mut q: *mut uint64_t = 0 as *mut uint64_t;
    let mut p: *mut uint64_t = 0 as *mut uint64_t;
    let mut i: I = 0;
    let mut tmp: *mut uint64_t = 0 as *mut uint64_t;
    let mut tmp___0: *mut uint64_t = 0 as *mut uint64_t;
    q = d___0 as *mut uint64_t;
    p = s as *mut uint64_t;
    i = 0 as libc::c_int as I;
    while i < n {
        tmp = q;
        q = q.offset(1);
        tmp___0 = p;
        p = p.offset(1);
        *tmp = __bswap_64(*tmp___0);
        i += 8 as libc::c_longlong;
    }
    return d___0;
}
pub unsafe extern "C" fn bswapI(mut n: I) -> I {
    let mut tmp: __uint64_t = 0;
    tmp = __bswap_64(n as __uint64_t);
    return tmp as I;
}
pub unsafe extern "C" fn membswpI(mut d___0: V, mut s: V, mut n: I, mut x___0: I) -> V {
    let mut tmp: V = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    if x___0 != 0 {
        tmp = membswp64(d___0, s, n);
        return tmp;
    }
    tmp___0 = memcpy(d___0, s as *const libc::c_void, n as size_t);
    return tmp___0;
}
pub unsafe extern "C" fn membswpF(mut d___0: V, mut s: V, mut n: I, mut x___0: I) -> V {
    let mut tmp: V = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if x___0 != 0 {
        tmp = membswp64(d___0, s, n);
        tmp___1 = tmp;
    } else {
        tmp___0 = memcpy(d___0, s as *const libc::c_void, n as size_t);
        tmp___1 = tmp___0;
    }
    return tmp___1;
}
pub static mut fLoad: I = 0 as libc::c_int as I;
pub static mut fError: I = 1 as libc::c_int as I;
pub static mut fWksp: I = 0 as libc::c_int as I;
pub static mut fBreak: S = b"t\0" as *const u8 as *const libc::c_char as S;
pub unsafe extern "C" fn boilerplate() {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = fileno(stdout);
    tmp___0 = isatty(tmp);
    if tmp___0 != 0 {
        tmp___1 = fileno(stdin);
        tmp___2 = isatty(tmp___1);
        if tmp___2 == 0 {
            return;
        }
    } else {
        return
    }
    printf(
        b"kona      \\ for help. \\\\ to exit.\n\n\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn filexist(mut s: S) -> K {
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut b___1: [C; 4097] = [0; 4097];
    let mut p: S = 0 as *mut C;
    let mut n: I = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut kp: K = 0 as *mut k0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    n = 0 as libc::c_int as I;
    strcpy(b___1.as_mut_ptr() as *mut libc::c_char, s as *const libc::c_char);
    loop {
        tmp = strstr(
            b___1.as_mut_ptr() as *const libc::c_char,
            b".k\0" as *const u8 as *const libc::c_char,
        );
        if !tmp.is_null() {
            f = fopen(
                b___1.as_mut_ptr() as *const libc::c_char,
                b"r\0" as *const u8 as *const libc::c_char,
            );
            if !f.is_null() {
                p = b___1.as_mut_ptr();
                break;
            }
        }
        strcat(
            b___1.as_mut_ptr() as *mut libc::c_char,
            b".k\0" as *const u8 as *const libc::c_char,
        );
        f = fopen(
            b___1.as_mut_ptr() as *const libc::c_char,
            b"r\0" as *const u8 as *const libc::c_char,
        );
        if !f.is_null() {
            p = b___1.as_mut_ptr();
            break;
        } else if n == 0 {
            tmp___0 = strlen(khome.as_mut_ptr() as *const libc::c_char);
            n = tmp___0 as I;
            tmp___1 = strlen(s as *const libc::c_char);
            if (n as libc::c_ulonglong)
                .wrapping_add(tmp___1 as libc::c_ulonglong)
                .wrapping_add(2 as libc::c_ulonglong) > 4096 as libc::c_ulonglong
            {
                return 0 as K;
            }
            strcpy(
                b___1.as_mut_ptr() as *mut libc::c_char,
                khome.as_mut_ptr() as *const libc::c_char,
            );
            strcpy(
                b___1.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
                s as *const libc::c_char,
            );
        } else {
            return 0 as K
        }
    }
    fclose(f);
    tmp___2 = strlen(p as *const libc::c_char);
    tmp___3 = newK(-(3 as libc::c_int) as I, tmp___2 as I);
    kp = tmp___3;
    tmp___4 = OOM_CD(0 as libc::c_int as I, kp, -(1 as libc::c_int) as V);
    if tmp___4 == 0 {
        return 0 as K;
    }
    strcpy(
        ((*kp).k).as_mut_ptr() as *mut C as *mut libc::c_char,
        p as *const libc::c_char,
    );
    return kp;
}
unsafe extern "C" fn loadf(mut s: S) -> *mut FILE {
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut p: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    f = 0 as *mut FILE;
    tmp = filexist(s);
    p = tmp;
    if !p.is_null() {
        f = fopen(
            ((*p).k).as_mut_ptr() as *mut C as *const libc::c_char,
            b"r\0" as *const u8 as *const libc::c_char,
        );
    }
    if p.is_null() {
        tmp___0 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        show(tmp___0);
    } else if f.is_null() {
        tmp___0 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        show(tmp___0);
    }
    cd(p);
    return f;
}
pub unsafe extern "C" fn load(mut s: S) -> K {
    let mut ofLoad: I = 0;
    let mut ofCmplt: I = 0;
    let mut old_: S = 0 as *mut C;
    let mut r: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut tmp___0: *mut FILE = 0 as *mut FILE;
    let mut tmp___1: libc::c_int = 0;
    ofLoad = fLoad;
    ofCmplt = fCmplt;
    fLoad = 1 as libc::c_int as I;
    fCmplt = 0 as libc::c_int as I;
    old_ = d_;
    tmp = filexist(s);
    if tmp.is_null() {
        printf(b"%s: file not found\n\0" as *const u8 as *const libc::c_char, s);
        r = _n();
    } else if scrLim > 124 as libc::c_longlong {
        printf(b"limit\n\0" as *const u8 as *const libc::c_char);
        r = kerr(b"stack\0" as *const u8 as *const libc::c_char);
    } else {
        scrLim += 1;
        tmp___0 = loadf(s);
        f = tmp___0;
        if f.is_null() {
            printf(b"%s.k: file not found\n\0" as *const u8 as *const libc::c_char, s);
            r = kerr(b"file\0" as *const u8 as *const libc::c_char);
        } else {
            lines(f);
            tmp___1 = fclose(f);
            if tmp___1 != 0 {
                r = kerr(b"file\0" as *const u8 as *const libc::c_char);
            } else {
                scrLim -= 1;
                if fCmplt == 1 as libc::c_longlong {
                    kerr(b"open-in-next-line\0" as *const u8 as *const libc::c_char);
                    oerr();
                }
                kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
                fer1 = 0 as libc::c_int as I;
                fer = fer1;
                r = _n();
            }
        }
    }
    fLoad = ofLoad;
    fCmplt = ofCmplt;
    d_ = old_;
    return r;
}
pub unsafe extern "C" fn stepopt(mut s: S, mut n: I) -> I {
    if n == 1 as libc::c_longlong {
        if *s as libc::c_int == 10 as libc::c_int {
            return 0 as libc::c_int as I;
        }
    }
    if n == 1 as libc::c_longlong {
        if *s as libc::c_int == 47 as libc::c_int {
            return 1 as libc::c_int as I;
        }
    }
    if n == 2 as libc::c_longlong {
        if *s as libc::c_int == 47 as libc::c_int {
            if *s.offset(1 as libc::c_int as isize) as libc::c_int == 10 as libc::c_int {
                return 1 as libc::c_int as I;
            }
        }
    }
    if n == 1 as libc::c_longlong {
        if *s as libc::c_int == 92 as libc::c_int {
            return 2 as libc::c_int as I;
        }
    }
    if n == 2 as libc::c_longlong {
        if *s as libc::c_int == 92 as libc::c_int {
            if *s.offset(1 as libc::c_int as isize) as libc::c_int == 10 as libc::c_int {
                return 2 as libc::c_int as I
            } else {
                return 3 as libc::c_int as I
            }
        } else {
            return 3 as libc::c_int as I
        }
    } else {
        return 3 as libc::c_int as I
    };
}
pub unsafe extern "C" fn precision(mut n: UI) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    if n > PPMAX as UI {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    PPON = (n != 0 as libc::c_ulonglong) as libc::c_int as C;
    if PPON != 0 {
        PP = n as I;
    } else {
        PP = PPMAX;
    }
    tmp___0 = _n();
    return tmp___0;
}
unsafe extern "C" fn precision_() -> K {
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    if PPON != 0 {
        tmp = PP;
    } else {
        tmp = 0 as libc::c_int as I;
    }
    tmp___0 = Ki(tmp);
    return tmp___0;
}
pub unsafe extern "C" fn backslash(mut s: S, mut n: I, mut dict: *mut K) -> K {
    let mut t: S = 0 as *mut C;
    let mut b___1: C = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut p: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: I = 0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut r: I = 0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: I = 0;
    let mut tmp___22: K = 0 as *mut k0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: K = 0 as *mut k0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut tmp___27: K = 0 as *mut k0;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___30: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___32: K = 0 as *mut k0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut tmp___34: K = 0 as *mut k0;
    let mut tmp___35: libc::c_int = 0;
    if 1 as libc::c_longlong == n {
        printf(
            b"Backslash Commands:\n\\0        datatypes help\n\\+        verb help\n\\'        adverb help\n\\:        I/O verb help\n\\_        reserved word help\n\\.        assignment/amend, function, control flow help\n\\b [s|t]  show/set break mode (stop|trace|none)\n\\d [d|^]  change k directory (^=previous)\n\\e [n]    show/set error flag (0=off,1=on,2=exit)\n\\l f      load script f or f.k\n\\p [n]    show/set print precision (0=full)\n\\r [s]    show/set random seed (0=random)\n\\s f      step script f or f.k\n\\t [n]    show/set timer interval in msec (0=disable)\n          calls niladic .m.ts\n\\t e      measure runtime of some k expression\n\\v [d|^]  show k directory (^=previous)\n\\w        show workspace resources used\n\\[cmd]    system command (also \\[ cmd]), \\echo hello\n\\\\        exit (or ctrl+d)\n\0"
                as *const u8 as *const libc::c_char,
        );
        tmp = _n();
        return tmp;
    } else {
        b___1 = *s.offset(2 as libc::c_int as isize);
        's_460: {
            if b___1 != 0 {
                tmp___29 = __ctype_b_loc();
                if !(*(*tmp___29).offset(b___1 as libc::c_int as isize) as libc::c_int
                    & 8192 as libc::c_int != 0)
                {
                    break 's_460;
                }
            }
            if b___1 != 0 {
                tmp___0 = 3 as libc::c_int;
            } else {
                tmp___0 = 2 as libc::c_int;
            }
            t = s.offset(tmp___0 as isize);
            match *s.offset(1 as libc::c_int as isize) as libc::c_int {
                92 => {
                    exit(0 as libc::c_int);
                }
                39 => {
                    printf(
                        b"Adverbs / \\ ' /: \\: ':\nUse adverbs in conjunction with verbs/functions\nOver and scan behave differently depending on whether their left argument\nis monadic or dyadic.\n/  over dyad    +/1 2 3  or 4+/1 2 3    */1+!5\n\\  scan dyad    +\\3 4 5  or 6+\\3 4 5    *\\10#2\n/  over monad   apply until fixed    f/x    (%%[;2.0])/9999.0 \n/  over monad   apply n times      n f/x    4 (2+)/0 \n/  over monad   apply while true   b f/x    {x<10} {x+1}/ 3\n\\  scan monad   trace until repeat   f\\x    (1!)\\1 2 3 4\n\\  scan monad   trace n times      n f\\x    10(|+\\)\\1 1\n/  over         {x+y+z}/[1 2 3;4;7 8 9]  f/[x;y;z]\n\\  scan         {x+y+z}[1 2 3;4;7 8 9]  f\\[x;y;z]\n/  join         \",\"/(\"a\";\"b\")\n\\  split        \",\"\\\"a,b\"\n'  each         \"abc\" ,' \"def\"    join each  \n'  each         !:' 2 3 4    enumerate each  \n/: eachright    2 #/: (\"alpha\";\"bravo\";\"charlie\")    take each right\n\\: eachleft     0 1 2 3 #\\: \"abc\"     take each left\n': eachpair     apply pairwise  -':1 3 4 8 10\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    tmp___1 = _n();
                    return tmp___1;
                }
                43 => {
                    printf(
                        b"Verbs +-*%%|&^!<>=~@?_,#$.:\nVerbs work on all sensible types (ints, floats, strings, symbols, lists)\nDyadic or monadic is determined from context, default is dyadic\nAdd : after a verb to force the monadic form, + is plus, +: is flip\n+ monadic  flip. transpose a matrix (a depth-2 list)\n+ dyadic   plus. add numbers together\n- monadic  negate. invert sign\n- dyadic   minus. subtraction\n* monadic  first. first element from the list\n* dyadic   times. multiply two numbers\n%% monadic  reciprocal. 1 over x \n%% dyadic   divide. x divided by y (not mod) \n| monadic  reverse. reverse order of list\n| dyadic   max/or. MAX(x,y) or OR(x,y) \n& monadic  where. &0 0 1 0 3 yields 2 4 4 4. \n& dyadic   min/and. MIN(x,y) or AND(x,y) \n^ monadic  shape. #elts at each depth (min over) \n^ dyadic   power. x to the exponent y \n! monadic  enumerate. !4 yields 0 1 2 3\n! dyadic   mod/rotate. 5!3 yields 2;  1 ! 4 5 6 yields 5 6 4 \n< monadic  grade up. indices of list sorted ascending \n< dyadic   less. boolean is x less than y\n> monadic  grade down. indices of list sorted descending\n> dyadic   more. boolean is x greater than y\n= monadic  group. =3 4 3 4 4 yields (0 2;1 3 4)  \n= dyadic   equals. 1 2 3 = 1 2 4 yields 1 1 0 (tolerantly) \n~ monadic  not. ~ 0 1 0 2 0 yields 1 0 1 0 1 \n~ dyadic   match. 1 2 ~ 1 2 yields 1 (types must match)\n@ monadic  atom. boolean is arg an atom (as opposed to a list) \n@ dyadic   at. elts from x at indices y\n@ triadic  monadic amend. see \\. \n@ tetradic dyadic amend. see \\.\n? monadic  unique. distinct elts from a list \n? dyadic   find. x?y yields index of y in list x (or #x)\n? dyadic   invert. {x^2} ? 2 yields sqrt(2) \n? triadic  invert-guess. secant method with clues ?[{2^x};17;4]\n_ monadic  floor. tolerant floor function \n_ dyadic   drop/cut. lose x elts from list y / separate into pieces \n, monadic  enlist. put x inside a 1-element list \n, dyadic   join. \"ab\",\"cd\" yields \"abcd\"\n# monadic  count. number of elements in list \n# dyadic   take/reshape. fill x elts from y \n$ monadic  format. cast to string \n$ dyadic   form/format. cast \n. monadic  execute/make dictionary. .\"1+1\" yields 2 \n. dyadic   value. 1 2 3 . ,2 yields 3. see \\. \n. triadic  monadic amend. see \\. \n. tetradic dyadic amend. see \\. \n:          overloaded with many operations. \n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    tmp___2 = _n();
                    return tmp___2;
                }
                46 => {
                    printf(
                        b"Assign/Amend, Functions, Control Flow \n\nAssign/Amend (see https://github.com/kevinlawler/kona/wiki/Amend)\na:1 is assignment\na::1 is global assignment (works in functions)\na+:1 is like a+=1, works in general\na-: negates a in place, works in general\na[]:1 sets all the entries of a to 1\na[0]:1 sets the 0th entry of a to 1\na[0;1]+:2 increments the 0th entry's 1st entry by 2\n.[a;();+;1] returns a+1 but does not affect a on the K Tree\n.[`a;();+;1] updates a in place, returns `a\n\nAmend Equivalence\n@[a;b;c;d] is .[a;,b;c;d]\na:1        is .[`a;();:;1]\na+:1       is .[`a;();+;1]\na-:        is .[`a;();-:]\na[]:1      is .[`a;_n;:;1]\na[0]:1     is .[`a;0;:;1] or .[`a;,0;:;1] \na[0;1]+:2  is .[`a;0 1;+;2]\n\nError Trap\n@[a;b;:] and .[a;b;:] are error trap\n\nFunctions\nf:{[a;b;c] a+b+c} defines a function. f[1;2;3] yields 6\nFunctions may be anonymous.\nFunctions may have default arguments x,y,z.\nSo {x^2} 3 conveniently yields 9\n\nControl Flow\n:[x1;t1;x2;t2;...;xn;tn;else] evaluate xi until true and return ti, otherwise return else \n    :[0;10;0;20;1;30;40] yields 30\nif[x;e1;...;en] if x then evaluate all e. if[j>i;a:1;b:2] \ndo[m;e1;...;en] do all e m times. do[100;f[i];i+:1] \nwhile[x;e1;...;en] while x do e.  while[a>b; f a; a-:1] \n/ starts a comment. Must begin a line or have a space before\n\\ is trace when beginning an expression inside a function (todo)\n: is early return when beginning an expression inside a function\n' is signal (todo)\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    tmp___3 = _n();
                    return tmp___3;
                }
                95 => {
                    printf(
                        b"Constants:\n(Note: the K epoch is 2035-01-01T00:00:00)\n_T       [current UTC Julian day count]+[fraction complete]\n_a       arguments\n_c       message source address\n_d       K-Tree path / current working dictionary\n_f       anonymous reference to current function\n_h       host name\n_i       index of current amendment\n_k       build date as string\n_n       nil\n_p       host port\n_s       space used allocated mmapped max\n_t       current UTC time (int)\n_v       current global variable under amendment\n_w       message source handle\n\nMonadic Verbs:\n_acos    inverse cosine\n_asin    inverse sine\n_atan    inverse tangent\n_ceil    ceiling (intolerant)\n_ceiling ceiling (tolerant)\n_cos     cosine\n_cosh    hyperbolic cosine\n_exp     exponential\n_floor   largest previous integer (intolerant)\n_log     natural logarithm\n_sin     sine\n_sinh    hyperbolic sine\n_sqr     square\n_sqrt    square root\n_tan     tangent\n_tanh    hyperbolic tangent\n_abs     absolute value\n_bd      convert to binary representation\n_ci      char-of-int (octal if unprintable char)\n_db      construct from binary representation\n_dj      date from Julian day count\n_exit    exit with status x\n_getenv  get an environment variable\n_gtime   in UTC, ints: YYYMMDD,HHMMSS (_gtime _t)\n_host    host name IP address (int)\n_ic      int-of-char\n_inv     inverse of a matrix\n_jd      Julian day count from date _jd 20110315\n_lt      convert output of _t to local time\n_ltime   localized version of _gtime\n_size    size of file (bytes)\n\nDyadic Verbs:\n_bin     index of element using binary search\n_binl    search for several elements\n_di      delete element at index\n_dot     dot product\n_draw    draw x random numbers from 0 to y-1, negative y indicates without replacement\n_dv      delete value\n_dvl     delete several values\n_hash    hash, (x;_hash x)?y\n_hat     caret/without, x _hat y\n_in      true if x is in y\n_lin     _in for several values\n_lsq     matrix division\n_mul     matrix multiplication\n_setenv  set environment variable\n_sm      string match\n_ss      positions of substring y in string x\n_sv      scalar from vector with base change\n_vs      vector from scalar with base change\n_vsx     vector from scalar with base change - extended\n\nTriadic Verbs:\n_ssr     string search & replace\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    tmp___4 = _n();
                    return tmp___4;
                }
                48 => {
                    printf(
                        b"Datatypes  -4 -3 -2 -1 0 1 2 3 4 5 6 7\nMonadic 4: reveals type, 4:1 2 3 yields -1\n-4 vector symbol     `a`b`c or ,`a\n-3 vector character  \"abc\" or ,\"c\" \n-2 vector float      1.0 2.0 3.33 or ,1.0\n-1 vector integer    1 2 3 or ,1\n 0 list   general    (`a;1 2 3) or (`a;(1 2 3;(3 4;\"c\")))\n 1 scalar integer    1\n 2 scalar float      1.0\n 3 scalar character  \"c\" \n 4 scalar symbol     `s\n 5 dictionary        .((`a;10;);(`b;20;))  or  .()  or  .,(`a;5;) \n 6 nil               _n or (;;) (list of 3 nils)  \n 7 verbs/functions   +  +: {1+x}  +[1;]  (|+)  {[a;b]1+a+b}  {x+y}[1;]\nEmpty Lists:\n-4 0#`\n-3 \"\"\n-2 0#0.0\n-1 !0\n 0 ()\nSpecial numeric types:\n 0N null integer\n 0n null float\n-0I infinity integer negative\n 0I infinity integer positive\n-0i infinity float   negative\n 0i infinity float   positive\nDictionaries:\nStart by making a dictionary d[`k]:4\nd[]   values\n!d    keys\nd[`k] value at k\nd@`k  value at k\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    tmp___5 = _n();
                    return tmp___5;
                }
                58 => {
                    printf(
                        b"I/O Verbs 0: 1: 2: 3: 4: 5: 6:\n\nDisk\n0: dyadic   write text file `f 0: \"hello\" \n0: monadic  read text file  0: `f\n1: dyadic   write binary file `f 1: 4 5 6 \n1: monadic  read binary file  1: `f (mmapped)\n2: monadic  read binary file  2: `f (copied to memory)\n3: dyadic   append to binary file, w/o sync `f 3: ,7\n5: dyadic   append to binary file `f 5: ,7\n6: dyadic   write raw byte string `f 6: \"\\01\\02\\03\"\n6: monadic  read raw byte string  6: `f\n\nNetwork\nStart k listening for IPC on port 1234  ./k -i 1234\n3: monadic  open handle    h: 3:(`\"192.168.1.101\";1234) \n3: monadic  close handle   3: h \n            exec .m.c expression\n3: dyadic   asynchronous send, returns _n      h 3: \"a:2\"\n            calls monadic .m.s msg handler\n4: dyadic   synchronous send, returns result   h 4: \"1+1\"\n            calls monadic .m.g msg handler\n\nOther\n0: dyadic   write to console `0: \"hello\\n\" \n2: dyadic   dynamically load C function  a:`libfile 2:(`func,3); a[1;2;3]\n4: monadic  type of data [-4,7],  4: \"c\" /returns 3\n5: monadic  printed representation. 5:1 2 3 /returns \"1 2 3\"\n\n0: and 1: both have versions for reading fields\nIn all cases `f can instead be (`f;start;length)\nRead fixed-width fields: \"cbsijfd IFCSDTZMm\" (\" \" is ignore)\n(types;widths)0:`f    (\"IFC\";3 5 4)0:`f  /read rows like \"20 30.1 golf\\n\" \n(types;widths)1:`f \n\"c\" 1:`f for c in \"cid\", read bytes/ints/doubles\nLoad delimited text file (no column names):\n(types;delim)0:`f    \nLoad delimited text file (with column names):\n(types;,delim)0:`f   \nc 1-byte char, b 1-byte int, s 2-byte int, i 4-byte int, f 4-byte float,\nd 8-byte double, \" \" 1-byte skip, I int, F float, C string, S string (sym), DTZMm Y? \n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    tmp___6 = _n();
                    return tmp___6;
                }
                96 => {
                    tmp___7 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                    return tmp___7;
                }
                97 => {
                    tmp___8 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                    return tmp___8;
                }
                98 => {
                    tmp___9 = backslash_b(s, n);
                    return tmp___9;
                }
                99 => {
                    tmp___10 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                    return tmp___10;
                }
                100 => {
                    tmp___11 = backslash_d(s, n, dict);
                    return tmp___11;
                }
                101 => {
                    tmp___12 = backslash_e(s, n);
                    return tmp___12;
                }
                105 => {
                    tmp___13 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                    return tmp___13;
                }
                108 => {
                    tmp___14 = load(t);
                    return tmp___14;
                }
                109 => {
                    tmp___15 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                    return tmp___15;
                }
                112 => {
                    if *t != 0 {
                        tmp___17 = StoI(t, &mut p);
                        if tmp___17 == 0 {
                            tmp___16 = kerr(
                                b"type\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___16;
                        }
                        tmp___18 = precision(p as UI);
                        return tmp___18;
                    } else {
                        tmp___19 = precision_();
                        return tmp___19;
                    }
                }
                114 => {
                    if *t != 0 {
                        tmp___21 = StoI(t, &mut r);
                        if tmp___21 == 0 {
                            tmp___20 = kerr(
                                b"type\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___20;
                        }
                        seedPRNG(r);
                        tmp___22 = _n();
                        return tmp___22;
                    } else {
                        seedPRNG(SEED);
                        tmp___23 = Ki(SEED);
                        return tmp___23;
                    }
                }
                115 => {
                    tmp___24 = backslash_s(t);
                    return tmp___24;
                }
                116 => {
                    tmp___25 = backslash_t(t);
                    return tmp___25;
                }
                118 => {
                    tmp___26 = backslash_v(s, n, dict);
                    return tmp___26;
                }
                119 => {
                    tmp___27 = backslash_w(s);
                    return tmp___27;
                }
                _ => {}
            }
            printf(b"domain error\n\0" as *const u8 as *const libc::c_char);
            tmp___28 = _n();
            return tmp___28;
        }
    }
    tmp___30 = __ctype_b_loc();
    if *(*tmp___30).offset(*s.offset(1 as libc::c_int as isize) as libc::c_int as isize)
        as libc::c_int & 8192 as libc::c_int != 0
    {
        s = s.offset(1);
    }
    tmp___35 = system(s as *const libc::c_char);
    if tmp___35 != 0 {
        tmp___32 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        tmp___34 = tmp___32;
    } else {
        tmp___33 = _n();
        tmp___34 = tmp___33;
    }
    return tmp___34;
}
unsafe extern "C" fn backslash_b(mut s: S, mut n: I) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    if n == 2 as libc::c_longlong {
        printf(b"%s\n\0" as *const u8 as *const libc::c_char, fBreak);
        tmp = _n();
        return tmp;
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"n\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            fBreak = b"n\0" as *const u8 as *const libc::c_char as S;
            tmp___0 = _n();
            return tmp___0;
        }
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"t\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            fBreak = b"t\0" as *const u8 as *const libc::c_char as S;
            tmp___1 = _n();
            return tmp___1;
        }
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"s\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            fBreak = b"s\0" as *const u8 as *const libc::c_char as S;
            tmp___2 = _n();
            return tmp___2;
        }
    }
    printf(b"valid options are: n, s, t\n\0" as *const u8 as *const libc::c_char);
    tmp___3 = _n();
    return tmp___3;
}
unsafe extern "C" fn backslash_d(mut s: S, mut n: I, mut dict: *mut K) -> K {
    let mut z: [C; 256] = [0; 256];
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: S = 0 as *mut C;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: S = 0 as *mut C;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: size_t = 0;
    let mut c: I = 0;
    let mut i: I = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: S = 0 as *mut C;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: size_t = 0;
    let mut tmp___11: S = 0 as *mut C;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: S = 0 as *mut C;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___17: S = 0 as *mut C;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: S = 0 as *mut C;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    if n == 2 as libc::c_longlong {
        printf(b"%s\n\0" as *const u8 as *const libc::c_char, d_);
        tmp = _n();
        return tmp;
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int == 46 as libc::c_int {
            tmp___0 = sp(b"\0" as *const u8 as *const libc::c_char as S);
            d_ = tmp___0;
            tmp___1 = _n();
            return tmp___1;
        }
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int == 94 as libc::c_int {
            tmp___3 = strlen(d_ as *const libc::c_char);
            if tmp___3 == 0 as libc::c_ulong {
                tmp___2 = _n();
                return tmp___2;
            }
            tmp___6 = strlen(d_ as *const libc::c_char);
            if tmp___6 == 2 as libc::c_ulong {
                tmp___4 = sp(b"\0" as *const u8 as *const libc::c_char as S);
                d_ = tmp___4;
                tmp___5 = _n();
                return tmp___5;
            }
            tmp___10 = strlen(d_ as *const libc::c_char);
            if tmp___10 > 3 as libc::c_ulong {
                c = 0 as libc::c_int as I;
                i = 0 as libc::c_int as I;
                i = 0 as libc::c_int as I;
                loop {
                    tmp___7 = strlen(d_ as *const libc::c_char);
                    if !((i as libc::c_ulonglong) < tmp___7 as libc::c_ulonglong) {
                        break;
                    }
                    if *d_.offset(i as isize) as libc::c_int == 46 as libc::c_int {
                        c = i;
                    }
                    i += 1;
                }
                strcpy(z.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
                z[c as usize] = '\u{0}' as i32 as C;
                tmp___8 = sp(z.as_mut_ptr());
                d_ = tmp___8;
                tmp___9 = _n();
                return tmp___9;
            }
        }
    }
    if n == 5 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int == 46 as libc::c_int {
            if *s.offset(4 as libc::c_int as isize) as libc::c_int == 107 as libc::c_int
            {
                tmp___11 = sp(b".k\0" as *const u8 as *const libc::c_char as S);
                d_ = tmp___11;
                tmp___12 = _n();
                return tmp___12;
            }
        }
    }
    if n == 5 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int == 46 as libc::c_int {
            if *s.offset(4 as libc::c_int as isize) as libc::c_int != 107 as libc::c_int
            {
                printf(
                    b"absolute backslash-d should begin with .k\n\0" as *const u8
                        as *const libc::c_char,
                );
                tmp___13 = _n();
                return tmp___13;
            }
        }
    }
    tmp___16 = __ctype_b_loc();
    if *(*tmp___16).offset(*s.offset(3 as libc::c_int as isize) as libc::c_int as isize)
        as libc::c_int & 1024 as libc::c_int != 0
    {
        denameD(dict, s.offset(3 as libc::c_int as isize), 1 as libc::c_int as I);
        strcpy(z.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
        strcat(
            z.as_mut_ptr() as *mut libc::c_char,
            b".\0" as *const u8 as *const libc::c_char,
        );
        strcat(
            z.as_mut_ptr() as *mut libc::c_char,
            s.offset(3 as libc::c_int as isize) as *const libc::c_char,
        );
        tmp___14 = sp(z.as_mut_ptr());
        d_ = tmp___14;
        tmp___15 = _n();
        return tmp___15;
    }
    if n >= 6 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int == 46 as libc::c_int {
            if *s.offset(4 as libc::c_int as isize) as libc::c_int == 107 as libc::c_int
            {
                if *s.offset(5 as libc::c_int as isize) as libc::c_int
                    == 46 as libc::c_int
                {
                    denameD(
                        &mut KTREE,
                        s.offset(3 as libc::c_int as isize),
                        1 as libc::c_int as I,
                    );
                    tmp___17 = sp(s.offset(3 as libc::c_int as isize));
                    d_ = tmp___17;
                    tmp___18 = _n();
                    return tmp___18;
                }
            }
        }
    }
    if *s.offset(3 as libc::c_int as isize) as libc::c_int == 46 as libc::c_int {
        denameD(&mut KTREE, s.offset(3 as libc::c_int as isize), 1 as libc::c_int as I);
        tmp___19 = sp(s.offset(3 as libc::c_int as isize));
        d_ = tmp___19;
        tmp___20 = _n();
        return tmp___20;
    }
    tmp___21 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
    return tmp___21;
}
unsafe extern "C" fn backslash_v(mut s: S, mut n: I, mut dict: *mut K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut z: [C; 256] = [0; 256];
    let mut c: I = 0;
    let mut i: I = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___4: *mut K = 0 as *mut K;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    if n > 2 as libc::c_longlong {
        if *s.offset(2 as libc::c_int as isize) as libc::c_int == 13 as libc::c_int {
            tmp = kerr(b"syntax\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    z[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
    if 2 as libc::c_longlong == n {
        strcpy(z.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
    }
    if 4 as libc::c_longlong == n {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"^\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            tmp___2 = strlen(d_ as *const libc::c_char);
            if tmp___2 > 3 as libc::c_ulong {
                c = 0 as libc::c_int as I;
                i = 0 as libc::c_int as I;
                i = 0 as libc::c_int as I;
                loop {
                    tmp___0 = strlen(d_ as *const libc::c_char);
                    if !((i as libc::c_ulonglong) < tmp___0 as libc::c_ulonglong) {
                        break;
                    }
                    if *d_.offset(i as isize) as libc::c_int
                        == *(b".\0" as *const u8 as *const libc::c_char) as libc::c_int
                    {
                        c = i;
                    }
                    i += 1;
                }
                strcpy(z.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
                z[c as usize] = *(b"\0\0" as *const u8 as *const libc::c_char);
            } else {
                tmp___1 = _n();
                return tmp___1;
            }
        }
    }
    tmp___3 = __ctype_b_loc();
    if *(*tmp___3).offset(*s.offset(3 as libc::c_int as isize) as libc::c_int as isize)
        as libc::c_int & 1024 as libc::c_int != 0
    {
        strcpy(z.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
        strcat(
            z.as_mut_ptr() as *mut libc::c_char,
            b".\0" as *const u8 as *const libc::c_char,
        );
        strcat(
            z.as_mut_ptr() as *mut libc::c_char,
            s.offset(3 as libc::c_int as isize) as *const libc::c_char,
        );
    }
    if z[0 as libc::c_int as usize] != 0 {
        tmp___4 = denameD(&mut KTREE, z.as_mut_ptr(), 0 as libc::c_int as I);
        x___0 = *tmp___4;
        if 6 as libc::c_longlong == (*x___0).t {
            tmp___5 = _n();
            tmp___7 = tmp___5;
        } else {
            tmp___6 = enumerate(x___0);
            tmp___7 = tmp___6;
        }
        return tmp___7;
    }
    tmp___8 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
    return tmp___8;
}
unsafe extern "C" fn backslash_e(mut s: S, mut n: I) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    if n == 2 as libc::c_longlong {
        printf(b"%lld\n\0" as *const u8 as *const libc::c_char, fError);
        tmp = _n();
        return tmp;
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"0\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            fError = 0 as libc::c_int as I;
            tmp___0 = _n();
            return tmp___0;
        }
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"1\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            fError = 1 as libc::c_int as I;
            tmp___1 = _n();
            return tmp___1;
        }
    }
    if n == 4 as libc::c_longlong {
        if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == *(b"2\0" as *const u8 as *const libc::c_char) as libc::c_int
        {
            fError = 2 as libc::c_int as I;
            tmp___2 = _n();
            return tmp___2;
        }
    }
    printf(b"valid options are: 0, 1, 2\n\0" as *const u8 as *const libc::c_char);
    tmp___3 = _n();
    return tmp___3;
}
unsafe extern "C" fn backslash_s(mut s: S) -> K {
    let mut t: S = 0 as *mut C;
    let mut u: S = 0 as *mut C;
    let mut w___0: S = 0 as *mut C;
    let mut c: I = 0;
    let mut d___0: I = 0;
    let mut n: I = 0;
    let mut m: I = 0;
    let mut l: I = 0;
    let mut r: I = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut tmp: *mut FILE = 0 as *mut FILE;
    let mut k: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: S = 0 as *mut C;
    let mut tmp___3: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    u = 0 as S;
    c = 0 as libc::c_int as I;
    m = 0 as libc::c_int as I;
    l = 0 as libc::c_int as I;
    tmp = loadf(s);
    f = tmp;
    k = 0 as K;
    y = 0 as K;
    z = 0 as K;
    if f.is_null() {
        tmp___0 = _n();
        return tmp___0;
    }
    's_93: loop {
        c = wds(&mut y, f);
        if !((0 as libc::c_longlong) < c) {
            break;
        }
        n = (*y).n;
        t = ((*y).k).as_mut_ptr() as *mut C;
        w___0 = t;
        loop {
            tmp___1 = __ctype_b_loc();
            tmp___2 = w___0;
            w___0 = w___0.offset(1);
            if *(*tmp___1).offset(*tmp___2 as libc::c_int as isize) as libc::c_int
                & 8192 as libc::c_int == 0
            {
                break;
            }
            l += 1;
        }
        if !(l == n) {
            if !(n == 0) {
                printf(b"%s \0" as *const u8 as *const libc::c_char, t);
                tmp___3 = getline_(&mut u, &mut m, stdin);
                if -(1 as libc::c_longlong) == tmp___3 {
                    break;
                }
                d___0 = stepopt(u, m);
                if d___0 == 1 as libc::c_longlong {
                    if !y.is_null() {
                        cd(y);
                    }
                    y = 0 as K;
                    continue;
                } else {
                    if d___0 == 2 as libc::c_longlong {
                        break;
                    }
                    tmp___4 = wd(t, n as libc::c_int);
                    k = ex(tmp___4);
                    show(k);
                    if !k.is_null() {
                        cd(k);
                        k = 0 as K;
                    }
                    if !y.is_null() {
                        cd(y);
                        y = 0 as K;
                    }
                    loop {
                        prompt(1 as libc::c_int as I);
                        tmp___5 = wds_(&mut z, stdin, 1 as libc::c_int as I);
                        if 0 as libc::c_longlong > tmp___5 {
                            break 's_93;
                        }
                        w___0 = ((*z).k).as_mut_ptr() as *mut C;
                        l = (*z).n;
                        d___0 = stepopt(w___0, l);
                        if d___0 == 1 as libc::c_longlong {
                            if !z.is_null() {
                                cd(z);
                            }
                            z = 0 as K;
                            continue 's_93;
                        } else {
                            if d___0 == 2 as libc::c_longlong {
                                break 's_93;
                            }
                            tmp___6 = wd(w___0, l as libc::c_int);
                            k = ex(tmp___6);
                            show(k);
                            if !k.is_null() {
                                cd(k);
                                k = 0 as K;
                            }
                            if !z.is_null() {
                                cd(z);
                                z = 0 as K;
                            }
                            if d___0 == 0 as libc::c_longlong {
                                continue;
                            }
                            if !(d___0 == 3 as libc::c_longlong) {
                                continue 's_93;
                            }
                        }
                    }
                }
            }
        }
        if !y.is_null() {
            cd(y);
        }
        y = 0 as K;
    }
    tmp___7 = fclose(f);
    r = tmp___7 as I;
    if r != 0 {
        tmp___8 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        return tmp___8;
    }
    free(u as *mut libc::c_void);
    if !k.is_null() {
        cd(k);
    }
    if !y.is_null() {
        cd(y);
    }
    if !z.is_null() {
        cd(z);
    }
    tmp___9 = _n();
    return tmp___9;
}
unsafe extern "C" fn backslash_t(mut s: S) -> K {
    let mut r: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut d___0: I = 0;
    let mut tmp___1: clock_t = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: clock_t = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    if *s != 0 {
        tmp___0 = StoI(s, &mut r);
        if tmp___0 != 0 {
            tmr_ival = r;
            tmp = _n();
            return tmp;
        }
        tmp___1 = clock();
        d___0 = tmp___1 as I;
        tmp___2 = X(s);
        z = tmp___2;
        tmp___3 = clock();
        d___0 = ((tmp___3 as I - d___0) as F
            / (1000000 as libc::c_long as F / 1000 as libc::c_int as F)) as I;
        cd(z);
        tmp___4 = Ki(d___0);
        return tmp___4;
    }
    tmp___5 = Ki(tmr_ival);
    return tmp___5;
}
unsafe extern "C" fn backslash_w(mut s: S) -> K {
    let mut tmp: K = 0 as *mut k0;
    fWksp = 1 as libc::c_int as I;
    tmp = _n();
    return tmp;
}
pub unsafe extern "C" fn expander(mut s: *mut S, mut n: I) -> I {
    let mut t: S = 0 as *mut C;
    let mut q: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    q = n;
    if 1 as libc::c_longlong > q {
        tmp = 1 as libc::c_int as I;
    } else {
        tmp = q;
    }
    tmp___0 = realloc(*s as *mut libc::c_void, tmp as size_t);
    t = tmp___0 as S;
    if t.is_null() {
        kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
        return -(1 as libc::c_int) as I;
    }
    *s = t;
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn appender(
    mut s: *mut S,
    mut n: *mut I,
    mut t: S,
    mut k: I,
) -> I {
    let mut tmp: I = 0;
    tmp = expander(s, *n + k + 1 as libc::c_longlong);
    if tmp != 0 {
        return -(1 as libc::c_int) as I;
    }
    memcpy(
        (*s).offset(*n as isize) as *mut libc::c_void,
        t as *const libc::c_void,
        k as size_t,
    );
    *n += k;
    *(*s).offset(*n as isize) = '\u{0}' as i32 as C;
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn getline_(mut s: *mut S, mut n: *mut I, mut f: *mut FILE) -> I {
    let mut tmp: I = 0;
    tmp = getdelim_(s, n, '\n' as i32 as I, f);
    return tmp;
}
pub unsafe extern "C" fn getdelim_(
    mut s: *mut S,
    mut n: *mut I,
    mut d___0: I,
    mut f: *mut FILE,
) -> I {
    let mut m: I = 0;
    let mut z: S = 0 as *mut C;
    let mut o: size_t = 0;
    let mut tmp: __ssize_t = 0;
    let mut tmp___0: I = 0;
    o = *n as size_t;
    tmp = getdelim(
        s as *mut *mut libc::c_char,
        &mut o as *mut size_t,
        d___0 as libc::c_int,
        f,
    );
    if tmp == -(1 as libc::c_long) {
        *n = 0 as libc::c_int as I;
        return -(1 as libc::c_int) as I;
    }
    *n = o as I;
    m = strlenn(*s, *n);
    if (1 as libc::c_longlong) < m {
        if 10 as libc::c_int
            == *(*s).offset((m - 1 as libc::c_longlong) as isize) as libc::c_int
        {
            if 13 as libc::c_int
                == *(*s).offset((m - 2 as libc::c_longlong) as isize) as libc::c_int
            {
                m -= 1;
                *(*s).offset(m as isize) = '\u{0}' as i32 as C;
                *(*s).offset((m - 1 as libc::c_longlong) as isize) = '\n' as i32 as C;
            }
        }
    }
    z = strdupn(*s, m);
    free(*s as *mut libc::c_void);
    *s = z;
    tmp___0 = m;
    *n = tmp___0;
    return tmp___0;
}
static mut mt: [libc::c_ulonglong; 312] = [0; 312];
static mut mti: libc::c_int = 313 as libc::c_int;
pub unsafe extern "C" fn init_genrand64(mut seed: libc::c_ulonglong) {
    mt[0 as libc::c_int as usize] = seed;
    mti = 1 as libc::c_int;
    while mti < 312 as libc::c_int {
        mt[mti
            as usize] = (6364136223846793005 as libc::c_ulonglong)
            .wrapping_mul(
                mt[(mti - 1 as libc::c_int) as usize]
                    ^ mt[(mti - 1 as libc::c_int) as usize] >> 62 as libc::c_int,
            )
            .wrapping_add(mti as libc::c_ulonglong);
        mti += 1;
    }
}
static mut mag01: [libc::c_ulonglong; 2] = [
    0 as libc::c_ulonglong,
    13043109905998158313 as libc::c_ulonglong,
];
pub unsafe extern "C" fn genrand64_int64() -> libc::c_ulonglong {
    let mut i: libc::c_int = 0;
    let mut x___0: libc::c_ulonglong = 0;
    let mut tmp: libc::c_int = 0;
    if mti >= 312 as libc::c_int {
        if mti == 313 as libc::c_int {
            init_genrand64(5489 as libc::c_ulonglong);
        }
        i = 0 as libc::c_int;
        while i < 156 as libc::c_int {
            x___0 = mt[i as usize] & 18446744071562067968 as libc::c_ulonglong
                | mt[(i + 1 as libc::c_int) as usize] & 2147483647 as libc::c_ulonglong;
            mt[i
                as usize] = mt[(i + 156 as libc::c_int) as usize]
                ^ x___0 >> 1 as libc::c_int
                ^ mag01[(x___0 & 1 as libc::c_ulonglong) as libc::c_int as usize];
            i += 1;
        }
        while i < 311 as libc::c_int {
            x___0 = mt[i as usize] & 18446744071562067968 as libc::c_ulonglong
                | mt[(i + 1 as libc::c_int) as usize] & 2147483647 as libc::c_ulonglong;
            mt[i
                as usize] = mt[(i + -(156 as libc::c_int)) as usize]
                ^ x___0 >> 1 as libc::c_int
                ^ mag01[(x___0 & 1 as libc::c_ulonglong) as libc::c_int as usize];
            i += 1;
        }
        x___0 = mt[311 as libc::c_int as usize]
            & 18446744071562067968 as libc::c_ulonglong
            | mt[0 as libc::c_int as usize] & 2147483647 as libc::c_ulonglong;
        mt[311 as libc::c_int
            as usize] = mt[155 as libc::c_int as usize] ^ x___0 >> 1 as libc::c_int
            ^ mag01[(x___0 & 1 as libc::c_ulonglong) as libc::c_int as usize];
        mti = 0 as libc::c_int;
    }
    tmp = mti;
    mti += 1;
    x___0 = mt[tmp as usize];
    x___0 ^= x___0 >> 29 as libc::c_int & 6148914691236517205 as libc::c_ulonglong;
    x___0 ^= x___0 << 17 as libc::c_int & 8202884508482404352 as libc::c_ulonglong;
    x___0 ^= x___0 << 37 as libc::c_int & 18444473444759240704 as libc::c_ulonglong;
    x___0 ^= x___0 >> 43 as libc::c_int;
    return x___0;
}
pub unsafe extern "C" fn genrand64_real2() -> libc::c_double {
    let mut tmp: libc::c_ulonglong = 0;
    tmp = genrand64_int64();
    return (tmp >> 11 as libc::c_int) as libc::c_double
        * (1.0f64 / 9007199254740992.0f64);
}
unsafe extern "C" fn formed_group(mut c: C) -> I {
    let mut s: S = 0 as *mut C;
    let mut tmp: I = 0;
    s = b"\n \\/\"\0" as *const u8 as *const libc::c_char as S;
    tmp = charpos(s, c);
    return tmp;
}
pub static mut formed_dfa: S = b"023451021151021451033333044444556515555555\0"
    as *const u8 as *const libc::c_char as S;
pub static mut left: S = b"([{\0" as *const u8 as *const libc::c_char as S;
pub static mut right: S = b")]}\0" as *const u8 as *const libc::c_char as S;
pub static mut lineA: S = 0 as *const C as *mut C;
pub static mut lineB: S = 0 as *const C as *mut C;
pub static mut fdc: I = 1 as libc::c_int as I;
pub static mut fll: I = 0 as libc::c_int as I;
unsafe extern "C" fn flop(mut c: C) -> C {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    if c as libc::c_int == 40 as libc::c_int {
        tmp___1 = ')' as i32;
    } else {
        if c as libc::c_int == 91 as libc::c_int {
            tmp___0 = ']' as i32;
        } else {
            if c as libc::c_int == 123 as libc::c_int {
                tmp = '}' as i32;
            } else {
                tmp = c as libc::c_int;
            }
            tmp___0 = tmp;
        }
        tmp___1 = tmp___0;
    }
    return tmp___1 as C;
}
pub unsafe extern "C" fn parsedepth(mut p: PDA) -> I {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: I = 0;
    if !p.is_null() {
        if (*p).s >= 5 as libc::c_longlong {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
        tmp___0 = (*p).n + tmp as I;
    } else {
        tmp___0 = 0 as libc::c_int as I;
    }
    return tmp___0;
}
pub unsafe extern "C" fn complete(
    mut a: S,
    mut n: I,
    mut q: *mut PDA,
    mut marks: *mut I,
) -> I {
    let mut p: PDA = 0 as *mut Pda;
    let mut t: C = 0;
    let mut r: I = 0;
    let mut tmp: I = 0;
    let mut before_pn: I = 0;
    let mut before_sq: I = 0;
    let mut before_sc: I = 0;
    let mut tmp___0: C = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: C = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: I = 0;
    let mut bot: C = 0;
    let mut tmp___6: C = 0;
    let mut m: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: libc::c_int = 0;
    if (*q).is_null() {
        *q = newPDA();
    }
    p = *q;
    if p.is_null() {
        return -(1 as libc::c_int) as I;
    }
    tmp = formed_group('\u{0}' as i32 as C);
    r = tmp + 1 as libc::c_longlong;
    while (*p).i < n {
        before_pn = (*p).n;
        before_sq = ((*p).s >= 5 as libc::c_longlong) as libc::c_int as I;
        before_sc = ((*p).s == 4 as libc::c_longlong) as libc::c_int as I;
        t = *a.offset((*p).i as isize);
        if (*p).s < 4 as libc::c_longlong {
            if t != 0 {
                tmp___4 = strchr(left as *const libc::c_char, t as libc::c_int);
                if !tmp___4.is_null() {
                    tmp___0 = flop(t);
                    tmp___1 = push(p, tmp___0);
                    if tmp___1 != 0 {
                        return -(1 as libc::c_int) as I;
                    }
                    if (*p).n > 99 as libc::c_longlong {
                        return 3 as libc::c_int as I;
                    }
                } else {
                    tmp___3 = strchr(right as *const libc::c_char, t as libc::c_int);
                    if !tmp___3.is_null() {
                        tmp___2 = peek(p);
                        if tmp___2 as libc::c_int != t as libc::c_int {
                            return 2 as libc::c_int as I
                        } else {
                            pop(p);
                        }
                    }
                }
            }
        }
        tmp___5 = formed_group(*a.offset((*p).i as isize));
        (*p)
            .s = (*formed_dfa.offset((r * (*p).s + tmp___5) as isize) as libc::c_int
            - 48 as libc::c_int) as I;
        if !marks.is_null() {
            tmp___6 = bottom(p);
            bot = tmp___6;
            if bot as libc::c_int == 41 as libc::c_int {
                tmp___13 = 4 as libc::c_int as I;
            } else {
                if bot as libc::c_int == 93 as libc::c_int {
                    tmp___12 = 2 as libc::c_int as I;
                } else {
                    if bot as libc::c_int == 125 as libc::c_int {
                        tmp___11 = 5 as libc::c_int as I;
                    } else {
                        if (*p).s == 4 as libc::c_longlong {
                            tmp___10 = 1 as libc::c_int as I;
                        } else {
                            if (*p).s >= 5 as libc::c_longlong {
                                tmp___9 = 6 as libc::c_int as I;
                            } else {
                                let mut current_block_59: u64;
                                if before_pn != 0 {
                                    current_block_59 = 7626729182071680876;
                                } else if before_sq != 0 {
                                    current_block_59 = 7626729182071680876;
                                } else {
                                    tmp___8 = 0 as libc::c_int as I;
                                    current_block_59 = 1623252117315916725;
                                }
                                match current_block_59 {
                                    7626729182071680876 => {
                                        if *marks.offset(((*p).i - 1 as libc::c_longlong) as isize)
                                            < 0 as libc::c_longlong
                                        {
                                            tmp___7 = -*marks
                                                .offset(((*p).i - 1 as libc::c_longlong) as isize);
                                        } else {
                                            tmp___7 = *marks
                                                .offset(((*p).i - 1 as libc::c_longlong) as isize);
                                        }
                                        tmp___8 = tmp___7;
                                    }
                                    _ => {}
                                }
                                tmp___9 = tmp___8;
                            }
                            tmp___10 = tmp___9;
                        }
                        tmp___11 = tmp___10;
                    }
                    tmp___12 = tmp___11;
                }
                tmp___13 = tmp___12;
            }
            m = tmp___13;
            let mut current_block_86: u64;
            if (*p).n != 0 {
                if before_pn == 0 {
                    m *= -(1 as libc::c_longlong);
                    current_block_86 = 8062065914618164218;
                } else {
                    current_block_86 = 11153429426059332696;
                }
            } else {
                current_block_86 = 11153429426059332696;
            }
            match current_block_86 {
                11153429426059332696 => {
                    let mut current_block_85: u64;
                    if 6 as libc::c_longlong == m {
                        if before_sq == 0 {
                            m *= -(1 as libc::c_longlong);
                            current_block_85 = 5207889489643863322;
                        } else {
                            current_block_85 = 9575541817475782585;
                        }
                    } else {
                        current_block_85 = 9575541817475782585;
                    }
                    match current_block_85 {
                        9575541817475782585 => {
                            if 1 as libc::c_longlong == m {
                                if before_sc == 0 {
                                    m *= -(1 as libc::c_longlong);
                                }
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            *marks.offset((*p).i as isize) = m;
        }
        (*p).i += 1;
    }
    if !((*p).s >= 5 as libc::c_longlong) {
        if (*p).n == 0 {
            tmp___14 = 0 as libc::c_int;
        } else {
            tmp___14 = 1 as libc::c_int;
        }
    } else {
        tmp___14 = 1 as libc::c_int;
    }
    return tmp___14 as I;
}
unsafe extern "C" fn mark_symbol(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut adot: I = 0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut c: C = 0;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    if *m.offset(i as isize) != 0 {
        return 0 as libc::c_int as I
    } else {
        if 96 as libc::c_int != *s.offset(i as isize) as libc::c_int {
            return 0 as libc::c_int as I;
        }
    }
    adot = 0 as libc::c_int as I;
    j = 0 as libc::c_int as I;
    while i + 2 as libc::c_longlong + j < n {
        if !(-(6 as libc::c_longlong) == *m.offset((i + 1 as libc::c_longlong) as isize))
        {
            break;
        }
        if !(6 as libc::c_longlong
            == *m.offset((i + 2 as libc::c_longlong + j) as isize))
        {
            break;
        }
        j += 1;
    }
    if j != 0 {
        return j + 2 as libc::c_longlong;
    }
    loop {
        k = i + 1 as libc::c_longlong + j;
        if !(k < n) {
            break;
        }
        c = *s.offset(k as isize);
        if j == 0 {
            tmp = __ctype_b_loc();
            if *(*tmp).offset(c as libc::c_int as isize) as libc::c_int
                & 2048 as libc::c_int != 0
            {
                break;
            }
        }
        if adot != 0 {
            tmp___0 = __ctype_b_loc();
            if *(*tmp___0).offset(c as libc::c_int as isize) as libc::c_int
                & 2048 as libc::c_int != 0
            {
                break;
            }
            if 46 as libc::c_int == c as libc::c_int {
                break;
            }
        }
        tmp___1 = __ctype_b_loc();
        if *(*tmp___1).offset(c as libc::c_int as isize) as libc::c_int
            & 8 as libc::c_int == 0
        {
            if 46 as libc::c_int != c as libc::c_int {
                if 95 as libc::c_int != c as libc::c_int {
                    break;
                }
            }
        }
        adot = (46 as libc::c_int == c as libc::c_int) as libc::c_int as I;
        j += 1;
    }
    if 1 as libc::c_longlong == j {
        if adot != 0 {
            return 1 as libc::c_int as I;
        }
    }
    return j + 1 as libc::c_longlong;
}
unsafe extern "C" fn isalnum_(mut c: C) -> I {
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: libc::c_int = 0;
    tmp = __ctype_b_loc();
    if *(*tmp).offset(c as libc::c_int as isize) as libc::c_int & 8 as libc::c_int != 0 {
        tmp___0 = 1 as libc::c_int;
    } else if 95 as libc::c_int == c as libc::c_int {
        tmp___0 = 1 as libc::c_int;
    } else {
        tmp___0 = 0 as libc::c_int;
    }
    return tmp___0 as I;
}
unsafe extern "C" fn isalnumdot_(mut c: C) -> I {
    let mut tmp: I = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = isalnum_(c);
    if tmp != 0 {
        tmp___0 = 1 as libc::c_int;
    } else if 46 as libc::c_int == c as libc::c_int {
        tmp___0 = 1 as libc::c_int;
    } else {
        tmp___0 = 0 as libc::c_int;
    }
    return tmp___0 as I;
}
unsafe extern "C" fn mark_name(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut current_block: u64;
    let mut c: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: I = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    c = 0 as libc::c_int as I;
    if *m.offset(i as isize) != 0 {
        return 0 as libc::c_int as I;
    }
    if i != 0 {
        tmp = isalnum_(*s.offset((i - 1 as libc::c_longlong) as isize));
        if tmp != 0 {
            return 0 as libc::c_int as I;
        }
    }
    if i < n - 1 as libc::c_longlong {
        if *s.offset(i as isize) as libc::c_int == 95 as libc::c_int {
            tmp___0 = __ctype_b_loc();
            if *(*tmp___0)
                .offset(
                    *s.offset((i + 1 as libc::c_longlong) as isize) as libc::c_int
                        as isize,
                ) as libc::c_int & 1024 as libc::c_int != 0
            {
                if i == n - 2 as libc::c_longlong {
                    return 2 as libc::c_int as I
                } else {
                    if *m.offset((i + 2 as libc::c_longlong) as isize) != 0 {
                        return 2 as libc::c_int as I
                    } else {
                        tmp___1 = isalnumdot_(
                            *s.offset((i + 2 as libc::c_longlong) as isize),
                        );
                        if tmp___1 == 0 {
                            return 2 as libc::c_int as I;
                        }
                    }
                }
            }
        }
    }
    while i + c < n {
        tmp___5 = isalnumdot_(*s.offset((i + c) as isize));
        if tmp___5 == 0 {
            break;
        }
        if i + c < n - 1 as libc::c_longlong {
            if 46 as libc::c_int == *s.offset((i + c) as isize) as libc::c_int {
                tmp___3 = __ctype_b_loc();
                if *(*tmp___3)
                    .offset(
                        *s.offset((i + c + 1 as libc::c_longlong) as isize)
                            as libc::c_int as isize,
                    ) as libc::c_int & 1024 as libc::c_int != 0
                {
                    c += 2 as libc::c_longlong;
                    current_block = 10891380440665537214;
                } else {
                    current_block = 12639275180678129113;
                }
            } else {
                current_block = 12639275180678129113;
            }
        } else {
            current_block = 12639275180678129113;
        }
        match current_block {
            12639275180678129113 => {
                tmp___2 = __ctype_b_loc();
                if !(*(*tmp___2)
                    .offset(*s.offset((i + c) as isize) as libc::c_int as isize)
                    as libc::c_int & 1024 as libc::c_int != 0)
                {
                    break;
                }
                c += 1;
            }
            _ => {}
        }
        if i + c >= n {
            break;
        }
        while i + c < n {
            tmp___4 = isalnum_(*s.offset((i + c) as isize));
            if tmp___4 == 0 {
                break;
            }
            c += 1;
        }
        if i + c >= n {
            break;
        }
        if 46 as libc::c_int == *s.offset((i + c) as isize) as libc::c_int {
            c += 1;
        }
    }
    if (1 as libc::c_longlong) < i {
        if 46 as libc::c_int
            == *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
        {
            if 0 as libc::c_longlong == *m.offset((i - 2 as libc::c_longlong) as isize) {
                if 46 as libc::c_int
                    != *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                {
                    c = 0 as libc::c_int as I;
                }
            }
        }
    }
    return c;
}
unsafe extern "C" fn mark_number(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut current_block: u64;
    let mut c: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___6: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___7: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut __res: libc::c_int = 0;
    let mut tmp___9: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___10: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___11: I = 0;
    let mut tmp___12: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___13: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    c = 0 as libc::c_int as I;
    if *m.offset(i as isize) != 0 {
        return 0 as libc::c_int as I;
    }
    if i != 0 {
        if 45 as libc::c_int == *s.offset(i as isize) as libc::c_int {
            tmp___0 = __ctype_b_loc();
            if *(*tmp___0)
                .offset(
                    *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        as isize,
                ) as libc::c_int & 8192 as libc::c_int == 0
            {
                if *m.offset((i - 1 as libc::c_longlong) as isize)
                    < 0 as libc::c_longlong
                {
                    tmp = -*m.offset((i - 1 as libc::c_longlong) as isize);
                } else {
                    tmp = *m.offset((i - 1 as libc::c_longlong) as isize);
                }
                match tmp {
                    9 | 8 | 7 | 4 | 2 => return 0 as libc::c_int as I,
                    _ => {}
                }
            }
        }
    }
    if 45 as libc::c_int == *s.offset(i as isize) as libc::c_int {
        if i < n - 2 as libc::c_longlong {
            if 46 as libc::c_int
                == *s.offset((i + 1 as libc::c_longlong) as isize) as libc::c_int
            {
                tmp___2 = __ctype_b_loc();
                if *(*tmp___2)
                    .offset(
                        *s.offset((i + 2 as libc::c_longlong) as isize) as libc::c_int
                            as isize,
                    ) as libc::c_int & 2048 as libc::c_int != 0
                {
                    c += 1;
                    current_block = 5529461102203738653;
                } else {
                    current_block = 6811298686087359504;
                }
            } else {
                current_block = 6811298686087359504;
            }
        } else {
            current_block = 6811298686087359504;
        }
        match current_block {
            5529461102203738653 => {}
            _ => {
                if i < n - 1 as libc::c_longlong {
                    tmp___1 = __ctype_b_loc();
                    if *(*tmp___1)
                        .offset(
                            *s.offset((i + 1 as libc::c_longlong) as isize)
                                as libc::c_int as isize,
                        ) as libc::c_int & 2048 as libc::c_int != 0
                    {
                        c += 1;
                    } else {
                        return 0 as libc::c_int as I
                    }
                } else {
                    return 0 as libc::c_int as I
                }
            }
        }
    }
    while i + c < n {
        if !(*m.offset((i + c) as isize) == 0) {
            break;
        }
        tmp___3 = __ctype_b_loc();
        if *(*tmp___3).offset(*s.offset((i + c) as isize) as libc::c_int as isize)
            as libc::c_int & 2048 as libc::c_int == 0
        {
            break;
        }
        c += 1;
    }
    if i + c < n {
        if 46 as libc::c_int == *s.offset((i + c) as isize) as libc::c_int {
            if c != 0 {
                c += 1;
            } else if i + c < n - 1 as libc::c_longlong {
                tmp___4 = __ctype_b_loc();
                if *(*tmp___4)
                    .offset(
                        *s.offset((i + c + 1 as libc::c_longlong) as isize)
                            as libc::c_int as isize,
                    ) as libc::c_int & 2048 as libc::c_int != 0
                {
                    c += 1;
                } else {
                    return 0 as libc::c_int as I
                }
            } else {
                return 0 as libc::c_int as I
            }
        }
    }
    while i + c < n {
        if !(*m.offset((i + c) as isize) == 0) {
            break;
        }
        tmp___5 = __ctype_b_loc();
        if *(*tmp___5).offset(*s.offset((i + c) as isize) as libc::c_int as isize)
            as libc::c_int & 2048 as libc::c_int == 0
        {
            break;
        }
        c += 1;
    }
    if i + c < n {
        if ::std::mem::size_of::<C>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = tolower(*s.offset((i + c) as isize) as libc::c_int);
        } else {
            tmp___9 = __ctype_tolower_loc();
            __res = *(*tmp___9)
                .offset(*s.offset((i + c) as isize) as libc::c_int as isize);
        }
        if 101 as libc::c_int == __res {
            if c == 0 {
                return 0 as libc::c_int as I
            } else {
                if i + c < n - 2 as libc::c_longlong {
                    if 45 as libc::c_int
                        == *s.offset((i + c + 1 as libc::c_longlong) as isize)
                            as libc::c_int
                    {
                        tmp___7 = __ctype_b_loc();
                        if *(*tmp___7)
                            .offset(
                                *s.offset((i + c + 2 as libc::c_longlong) as isize)
                                    as libc::c_int as isize,
                            ) as libc::c_int & 2048 as libc::c_int != 0
                        {
                            c += 2 as libc::c_longlong;
                            current_block = 3634396408142324656;
                        } else {
                            current_block = 13049354517555079011;
                        }
                    } else {
                        current_block = 13049354517555079011;
                    }
                } else {
                    current_block = 13049354517555079011;
                }
                match current_block {
                    3634396408142324656 => {}
                    _ => {
                        if i + c < n - 1 as libc::c_longlong {
                            tmp___6 = __ctype_b_loc();
                            if *(*tmp___6)
                                .offset(
                                    *s.offset((i + c + 1 as libc::c_longlong) as isize)
                                        as libc::c_int as isize,
                                ) as libc::c_int & 2048 as libc::c_int != 0
                            {
                                c += 1;
                            } else {
                                return 0 as libc::c_int as I
                            }
                        } else {
                            return 0 as libc::c_int as I
                        }
                    }
                }
            }
        }
    }
    while i + c < n {
        if !(*m.offset((i + c) as isize) == 0) {
            break;
        }
        tmp___10 = __ctype_b_loc();
        if *(*tmp___10).offset(*s.offset((i + c) as isize) as libc::c_int as isize)
            as libc::c_int & 2048 as libc::c_int == 0
        {
            break;
        }
        c += 1;
    }
    if i + c < n {
        let mut current_block_88: u64;
        if 1 as libc::c_longlong == c {
            if 48 as libc::c_int == *s.offset(i as isize) as libc::c_int {
                current_block_88 = 1485638654003476598;
            } else {
                current_block_88 = 16007575661589459624;
            }
        } else {
            current_block_88 = 16007575661589459624;
        }
        match current_block_88 {
            16007575661589459624 => {
                if 2 as libc::c_longlong == c {
                    if 45 as libc::c_int == *s.offset(i as isize) as libc::c_int {
                        if 48 as libc::c_int
                            == *s.offset((i + 1 as libc::c_longlong) as isize)
                                as libc::c_int
                        {
                            current_block_88 = 1485638654003476598;
                        } else {
                            current_block_88 = 16667286137552459707;
                        }
                    } else {
                        current_block_88 = 16667286137552459707;
                    }
                } else {
                    current_block_88 = 16667286137552459707;
                }
            }
            _ => {}
        }
        match current_block_88 {
            1485638654003476598 => {
                tmp___11 = stringHasChar(
                    b"NIni\0" as *const u8 as *const libc::c_char as S,
                    *s.offset((i + c) as isize),
                );
                if tmp___11 != 0 {
                    if i + c == n - 1 as libc::c_longlong {
                        c += 1;
                    } else {
                        tmp___12 = __ctype_b_loc();
                        if *(*tmp___12)
                            .offset(
                                *s.offset((i + c + 1 as libc::c_longlong) as isize)
                                    as libc::c_int as isize,
                            ) as libc::c_int & 1024 as libc::c_int == 0
                        {
                            c += 1;
                        }
                    }
                }
            }
            _ => {}
        }
    }
    if c != 0 {
        while i + c < n {
            if !(*m.offset((i + c) as isize) == 0) {
                break;
            }
            tmp___13 = __ctype_b_loc();
            if *(*tmp___13).offset(*s.offset((i + c) as isize) as libc::c_int as isize)
                as libc::c_int & 8192 as libc::c_int == 0
            {
                break;
            }
            c += 1;
        }
    }
    return c;
}
unsafe extern "C" fn mark_adverb(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut current_block: u64;
    let mut c: C = 0;
    let mut j: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    if *m.offset(i as isize) != 0 {
        return 0 as libc::c_int as I;
    }
    c = *s.offset(i as isize);
    if i == 0 as libc::c_longlong {
        's_86: {
            if !(c as libc::c_int == 39 as libc::c_int) {
                if !(c as libc::c_int == 92 as libc::c_int) {
                    break 's_86;
                }
            }
            tmp___0 = strlen(s as *const libc::c_char);
            if tmp___0 > 3 as libc::c_ulong {
                j = 3 as libc::c_int as I;
                while *s.offset(j as isize) as libc::c_int != 0 as libc::c_int {
                    tmp = j;
                    j += 1;
                    if *s.offset(tmp as isize) as libc::c_int == 41 as libc::c_int {
                        return 0 as libc::c_int as I;
                    }
                }
            }
            return 1 as libc::c_int as I;
        }
        return 0 as libc::c_int as I;
    }
    tmp___1 = strcmp(
        s as *const libc::c_char,
        b";\\\\\0" as *const u8 as *const libc::c_char,
    );
    if tmp___1 == 0 {
        return 1 as libc::c_int as I;
    }
    if c as libc::c_int == 92 as libc::c_int {
        if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
            == 59 as libc::c_int
        {
            return 0 as libc::c_int as I;
        }
    }
    if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
        != 32 as libc::c_int
    {
        if c as libc::c_int == 47 as libc::c_int {
            current_block = 9559337354937733350;
        } else if c as libc::c_int == 92 as libc::c_int {
            current_block = 9559337354937733350;
        } else if c as libc::c_int == 39 as libc::c_int {
            current_block = 9559337354937733350;
        } else {
            current_block = 7245201122033322888;
        }
        match current_block {
            7245201122033322888 => {}
            _ => {
                if i < n - 1 as libc::c_longlong {
                    if *s.offset((i + 1 as libc::c_longlong) as isize) as libc::c_int
                        == 58 as libc::c_int
                    {
                        return 2 as libc::c_int as I;
                    }
                }
                return 1 as libc::c_int as I;
            }
        }
    }
    return 0 as libc::c_int as I;
}
unsafe extern "C" fn mark_verb(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut c: I = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: I = 0;
    c = 0 as libc::c_int as I;
    while i + c < n - 1 as libc::c_longlong {
        if !(-(9 as libc::c_longlong) == *m.offset(i as isize)) {
            break;
        }
        c += 1;
        if !(9 as libc::c_longlong == *m.offset((c + i) as isize)) {
            break;
        }
    }
    if c != 0 {
        if 58 as libc::c_int == *s.offset((i + c) as isize) as libc::c_int {
            c += 1;
            return c;
        }
    }
    if *m.offset(i as isize) != 0 {
        return 0 as libc::c_int as I;
    }
    c = 0 as libc::c_int as I;
    if 95 as libc::c_int == *s.offset(i as isize) as libc::c_int {
        while i + c < n {
            tmp___0 = __ctype_b_loc();
            if *(*tmp___0)
                .offset(
                    *s.offset((i + 1 as libc::c_longlong + c) as isize) as libc::c_int
                        as isize,
                ) as libc::c_int & 1024 as libc::c_int == 0
            {
                break;
            }
            c += 1;
        }
    }
    if c > 1 as libc::c_longlong {
        return 1 as libc::c_longlong + c;
    }
    if *s.offset(i as isize) as libc::c_int == 92 as libc::c_int {
        if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
            == 32 as libc::c_int
        {
            return 1 as libc::c_int as I
        } else {
            if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                == 59 as libc::c_int
            {
                return 1 as libc::c_int as I
            } else {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 40 as libc::c_int
                {
                    return 1 as libc::c_int as I;
                }
            }
        }
    }
    c = 0 as libc::c_int as I;
    tmp___2 = isCharVerb(*s.offset(i as isize));
    if tmp___2 != 0 {
        c += 1;
    }
    return c;
}
unsafe extern "C" fn mark_conditional(mut s: S, mut n: I, mut k: I, mut m: *mut I) -> I {
    let mut t: [S; 3] = [0 as *mut C; 3];
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut c: I = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    t[0 as libc::c_int as usize] = b"if\0" as *const u8 as *const libc::c_char as S;
    t[1 as libc::c_int as usize] = b"do\0" as *const u8 as *const libc::c_char as S;
    t[2 as libc::c_int as usize] = b"while\0" as *const u8 as *const libc::c_char as S;
    if *s.offset(k as isize) as libc::c_int == 58 as libc::c_int {
        if *s.offset((k + 1 as libc::c_longlong) as isize) as libc::c_int
            == 91 as libc::c_int
        {
            if *s.offset((k + 2 as libc::c_longlong) as isize) as libc::c_int
                != 59 as libc::c_int
            {
                if *m.offset(k as isize) == 0 {
                    return 1 as libc::c_int as I;
                }
            }
        }
    }
    if *m.offset(k as isize) == -(8 as libc::c_longlong) {
        i = 0 as libc::c_int as I;
        _i___0 = (::std::mem::size_of::<[S; 3]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<S>() as libc::c_ulong) as I;
        while i < _i___0 {
            tmp = strlen(t[i as usize] as *const libc::c_char);
            c = tmp as I;
            tmp___0 = strncmp(
                s.offset(k as isize) as *const libc::c_char,
                t[i as usize] as *const libc::c_char,
                c as size_t,
            );
            if tmp___0 == 0 {
                if *s.offset((k + c) as isize) as libc::c_int == 91 as libc::c_int {
                    return c;
                }
            }
            i += 1;
        }
    }
    return 0 as libc::c_int as I;
}
unsafe extern "C" fn mark_end(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut c: C = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    c = *s.offset(i as isize);
    if *m.offset(i as isize) != 0 {
        tmp___0 = 0 as libc::c_int;
    } else {
        if c as libc::c_int == 59 as libc::c_int {
            tmp = 1 as libc::c_int;
        } else if c as libc::c_int == 10 as libc::c_int {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
        tmp___0 = tmp;
    }
    return tmp___0 as I;
}
unsafe extern "C" fn mark_ignore(mut s: S, mut n: I, mut i: I, mut m: *mut I) -> I {
    let mut c: C = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: libc::c_int = 0;
    c = *s.offset(i as isize);
    if *m.offset(i as isize) != 0 {
        tmp___2 = 0 as libc::c_int;
    } else {
        tmp___1 = __ctype_b_loc();
        if *(*tmp___1).offset(c as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int != 0
        {
            tmp___0 = 1 as libc::c_int;
        } else {
            tmp___0 = 0 as libc::c_int;
        }
        tmp___2 = tmp___0;
    }
    return tmp___2 as I;
}
unsafe extern "C" fn overcount(mut m: *mut I, mut n: I) -> I {
    let mut c: I = 0;
    let mut p: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    c = 0 as libc::c_int as I;
    p = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        if *m.offset(i as isize) <= -(3 as libc::c_longlong) {
            if *m.offset(i as isize) == p {
                if !(p == -(7 as libc::c_longlong)) {
                    if !(p == -(9 as libc::c_longlong)) {
                        p = *m.offset(i as isize);
                        c += 1;
                    }
                }
            } else {
                p = *m.offset(i as isize);
                c += 1;
            }
        }
        i += 1;
    }
    return c;
}
unsafe extern "C" fn syntaxChk(mut s: S) -> I {
    let mut current_block: u64;
    let mut n: I = 0;
    let mut tmp: size_t = 0;
    let mut i: I = 0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    if *s.offset(0 as libc::c_int as isize) as libc::c_int == 9 as libc::c_int {
        return 5 as libc::c_int as I
    } else {
        if *s.offset(0 as libc::c_int as isize) as libc::c_int == 12 as libc::c_int {
            return 5 as libc::c_int as I;
        }
    }
    tmp = strlen(s as *const libc::c_char);
    n = tmp as I;
    if n == 1 as libc::c_longlong {
        if *s.offset(0 as libc::c_int as isize) as libc::c_int == 39 as libc::c_int {
            return 10 as libc::c_int as I
        } else {
            return 0 as libc::c_int as I
        }
    }
    k = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    while i < n {
        if *s.offset(i as isize) as libc::c_int != 32 as libc::c_int {
            break;
        }
        i += 1;
    }
    if i >= n - 1 as libc::c_longlong {
        return 0 as libc::c_int as I;
    }
    j = i + 1 as libc::c_longlong;
    while j < n {
        if *s.offset(j as isize) as libc::c_int != 32 as libc::c_int {
            break;
        }
        j += 1;
    }
    if *s.offset(i as isize) as libc::c_int == 92 as libc::c_int {
        if *s.offset(j as isize) as libc::c_int == 92 as libc::c_int {
            return 0 as libc::c_int as I;
        }
    }
    if *s.offset(i as isize) as libc::c_int == 39 as libc::c_int {
        if *s.offset(j as isize) as libc::c_int != 34 as libc::c_int {
            return 20 as libc::c_int as I;
        }
    }
    if j == n {
        return 20 as libc::c_int as I;
    }
    i = 0 as libc::c_int as I;
    while i < n {
        if *s.offset(i as isize) as libc::c_int == 34 as libc::c_int {
            break;
        }
        if i > 0 as libc::c_longlong {
            if *s.offset(i as isize) as libc::c_int == 11 as libc::c_int {
                return 30 as libc::c_int as I
            } else if *s.offset(i as isize) as libc::c_int == 12 as libc::c_int {
                return 30 as libc::c_int as I
            } else if *s.offset(i as isize) as libc::c_int == 39 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 59 as libc::c_int
                {
                    return 30 as libc::c_int as I;
                }
            }
        }
        if i > 1 as libc::c_longlong {
            if *s.offset(i as isize) as libc::c_int == 39 as libc::c_int {
                if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                    == 92 as libc::c_int
                {
                    return 30 as libc::c_int as I;
                }
            }
        }
        i += 1;
    }
    if n > 1 as libc::c_longlong {
        if *s.offset((n - 1 as libc::c_longlong) as isize) as libc::c_int
            == 39 as libc::c_int
        {
            if *s.offset((n - 2 as libc::c_longlong) as isize) as libc::c_int
                == 58 as libc::c_int
            {
                return 50 as libc::c_int as I;
            }
        }
    }
    if n > 1 as libc::c_longlong {
        i = 1 as libc::c_int as I;
        while i < n {
            if *s.offset(i as isize) as libc::c_int == 34 as libc::c_int {
                break;
            }
            if *s.offset(i as isize) as libc::c_int == 58 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 96 as libc::c_int
                {
                    return 55 as libc::c_int as I;
                }
            }
            if *s.offset(i as isize) as libc::c_int == 44 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 92 as libc::c_int
                {
                    return 60 as libc::c_int as I
                } else {
                    if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 95 as libc::c_int
                    {
                        return 60 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 63 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 45 as libc::c_int
                {
                    return 70 as libc::c_int as I
                } else {
                    if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 92 as libc::c_int
                    {
                        return 70 as libc::c_int as I;
                    }
                }
            }
            i += 1;
        }
    }
    if n > 2 as libc::c_longlong {
        i = 2 as libc::c_int as I;
        while i < n {
            if *s.offset(i as isize) as libc::c_int == 92 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 58 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        != 47 as libc::c_int
                    {
                        if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                            != 92 as libc::c_int
                        {
                            if *s.offset((i + 1 as libc::c_longlong) as isize)
                                as libc::c_int != 110 as libc::c_int
                            {
                                return 80 as libc::c_int as I;
                            }
                        }
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 47 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 43 as libc::c_int
                {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 39 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 62 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 37 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 42 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 63 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 38 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 92 as libc::c_int
                    {
                    current_block = 10666562849561035477;
                } else {
                    current_block = 2463987395154258233;
                }
                match current_block {
                    2463987395154258233 => {}
                    _ => {
                        if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                            == 47 as libc::c_int
                        {
                            return 90 as libc::c_int as I;
                        }
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 47 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 47 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 45 as libc::c_int
                    {
                        return 100 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 47 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 47 as libc::c_int
                {
                    if *s.offset((i + 1 as libc::c_longlong) as isize) as libc::c_int
                        == 44 as libc::c_int
                    {
                        return 999 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 95 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 44 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 126 as libc::c_int
                    {
                        return 110 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 47 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 35 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 48 as libc::c_int
                    {
                        return 120 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 92 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 92 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 60 as libc::c_int
                    {
                        return 123 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 36 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 44 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 36 as libc::c_int
                    {
                        return 130 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 58 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 48 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 48 as libc::c_int
                    {
                        return 136 as libc::c_int as I;
                    }
                }
            }
            if *s.offset(i as isize) as libc::c_int == 47 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 47 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 47 as libc::c_int
                    {
                        return 140 as libc::c_int as I;
                    }
                }
            }
            i += 1;
        }
    }
    if n > 3 as libc::c_longlong {
        i = 3 as libc::c_int as I;
        while i < n {
            if *s.offset(i as isize) as libc::c_int == 92 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 32 as libc::c_int
                {
                    let mut current_block_159: u64;
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 92 as libc::c_int
                    {
                        current_block_159 = 1549966222713882367;
                    } else if *s.offset((i - 2 as libc::c_longlong) as isize)
                            as libc::c_int == 47 as libc::c_int
                        {
                        current_block_159 = 1549966222713882367;
                    } else {
                        current_block_159 = 3990161529967994542;
                    }
                    match current_block_159 {
                        1549966222713882367 => {
                            if *s.offset((i - 3 as libc::c_longlong) as isize)
                                as libc::c_int == 92 as libc::c_int
                            {
                                return 141 as libc::c_int as I;
                            }
                        }
                        _ => {}
                    }
                }
            }
            tmp___0 = __ctype_b_loc();
            let mut current_block_172: u64;
            if *(*tmp___0).offset(*s.offset(i as isize) as libc::c_int as isize)
                as libc::c_int & 1024 as libc::c_int != 0
            {
                current_block_172 = 10117618654675100273;
            } else if *s.offset(i as isize) as libc::c_int == 96 as libc::c_int {
                current_block_172 = 10117618654675100273;
            } else {
                current_block_172 = 3813860224257983916;
            }
            match current_block_172 {
                10117618654675100273 => {
                    if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                        == 58 as libc::c_int
                    {
                        if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                            == 58 as libc::c_int
                        {
                            if *s.offset((i - 3 as libc::c_longlong) as isize)
                                as libc::c_int == 58 as libc::c_int
                            {
                                return 142 as libc::c_int as I;
                            }
                        }
                    }
                }
                _ => {}
            }
            i += 1;
        }
    }
    if n > 3 as libc::c_longlong {
        i = 2 as libc::c_int as I;
        while i < n - 1 as libc::c_longlong {
            if *s.offset(i as isize) as libc::c_int == 47 as libc::c_int {
                if *s.offset((i - 1 as libc::c_longlong) as isize) as libc::c_int
                    == 58 as libc::c_int
                {
                    if *s.offset((i - 2 as libc::c_longlong) as isize) as libc::c_int
                        == 47 as libc::c_int
                    {
                        if *s.offset((i + 1 as libc::c_longlong) as isize) as libc::c_int
                            != 58 as libc::c_int
                        {
                            return 150 as libc::c_int as I;
                        }
                    }
                }
            }
            i += 1;
        }
    }
    return k;
}
pub unsafe extern "C" fn mark(mut m: *mut I, mut k: I, mut t: I) -> I {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    i = 0 as libc::c_int as I;
    _i___0 = k;
    while i < _i___0 {
        if i != 0 {
            *m.offset(i as isize) = t;
        } else {
            *m.offset(i as isize) = -t;
        }
        i += 1;
    }
    return k;
}
pub unsafe extern "C" fn wd(mut s: S, mut n: libc::c_int) -> K {
    let mut tmp: *mut K = 0 as *mut K;
    let mut tmp___0: K = 0 as *mut k0;
    lineA = s;
    fdc = 0 as libc::c_int as I;
    tmp = denameD(&mut KTREE, d_, 1 as libc::c_int as I);
    tmp___0 = wd_(s, n, tmp, 0 as K);
    return tmp___0;
}
pub unsafe extern "C" fn wd_(
    mut s: S,
    mut n: libc::c_int,
    mut dict: *mut K,
    mut func: K,
) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut z: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: K = 0 as *mut k0;
    let mut p: PDA = 0 as *mut Pda;
    let mut km: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut m: *mut I = 0 as *mut I;
    let mut e: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: I = 0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut i___1: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut i___2: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: I = 0;
    let mut i___3: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___20: I = 0;
    let mut tmp___21: I = 0;
    let mut tmp___22: I = 0;
    let mut i___4: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___23: I = 0;
    let mut tmp___24: I = 0;
    let mut tmp___25: I = 0;
    let mut i___5: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___26: I = 0;
    let mut tmp___27: I = 0;
    let mut tmp___28: I = 0;
    let mut i___6: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___29: I = 0;
    let mut tmp___30: I = 0;
    let mut tmp___31: I = 0;
    let mut i___7: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___32: I = 0;
    let mut tmp___33: I = 0;
    let mut tmp___34: I = 0;
    let mut i___8: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___35: K = 0 as *mut k0;
    let mut y: I = 0;
    let mut ks2: K = 0 as *mut k0;
    let mut tmp___36: K = 0 as *mut k0;
    let mut tmp___37: I = 0;
    let mut s2: S = 0 as *mut C;
    let mut i___9: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___38: I = 0;
    let mut tmp___39: I = 0;
    let mut oc: I = 0;
    let mut tmp___40: I = 0;
    let mut kw: K = 0 as *mut k0;
    let mut tmp___41: K = 0 as *mut k0;
    let mut tmp___42: I = 0;
    let mut w___0: *mut V = 0 as *mut V;
    let mut c: I = 0;
    let mut j: I = 0;
    let mut tmp___43: size_t = 0;
    let mut i___10: I = 0;
    let mut _i___10: I = 0;
    let mut tmp___44: I = 0;
    let mut kw2: K = 0 as *mut k0;
    let mut tmp___45: K = 0 as *mut k0;
    let mut tmp___46: I = 0;
    let mut tmp___47: I = 0;
    let mut tmp___48: I = 0;
    let mut tmp___49: I = 0;
    let mut tmp___50: I = 0;
    if s.is_null() {
        return 0 as K;
    }
    tmp___0 = strstr(
        s as *const libc::c_char,
        b":\\t\0" as *const u8 as *const libc::c_char,
    );
    if !tmp___0.is_null() {
        tmp = kerr(b"\\t  syntax\0" as *const u8 as *const libc::c_char);
        show(tmp);
        return 0 as K;
    }
    tmp___1 = syntaxChk(s);
    z = tmp___1;
    if z == 999 as libc::c_longlong {
        tmp___2 = kerr(b"nonce\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    }
    if z != 0 {
        tmp___3 = kerr(b"syntax\0" as *const u8 as *const libc::c_char);
        return tmp___3;
    }
    i = 0 as libc::c_int as I;
    while i < n as I {
        tmp___4 = __ctype_b_loc();
        if *(*tmp___4).offset(*s.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & 8192 as libc::c_int == 0
        {
            break;
        }
        i += 1;
    }
    if 92 as libc::c_int == *s.offset(i as isize) as libc::c_int {
        tmp___5 = backslash(s.offset(i as isize), n as I, dict);
        return tmp___5;
    }
    p = 0 as PDA;
    tmp___6 = newK(-(1 as libc::c_int) as I, (1 as libc::c_int + n) as I);
    km = tmp___6;
    if km.is_null() {
        return 0 as K;
    }
    m = ((*km).k).as_mut_ptr() as *mut I;
    tmp___7 = complete(s, n as I, &mut p, m);
    e = tmp___7;
    if !p.is_null() {
        pdafree(p);
        p = 0 as PDA;
    }
    lineB = s;
    if e != 0 {
        cd(km);
        tmp___8 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
        return tmp___8;
    }
    tmp___9 = Kv();
    v = tmp___9;
    tmp___10 = OOM_CD(0 as libc::c_int as I, v, km, -(1 as libc::c_int) as V);
    if tmp___10 == 0 {
        return 0 as K;
    }
    (*v).n = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___0 = n as I;
    while i___0 < _i___0 {
        tmp___11 = mark_end(s, n as I, i___0, m);
        tmp___12 = mark(m.offset(i___0 as isize), tmp___11, 3 as libc::c_int as I);
        tmp___13 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___12);
        i___0 += tmp___13;
        i___0 += 1;
    }
    i___1 = 0 as libc::c_int as I;
    _i___1 = n as I;
    while i___1 < _i___1 {
        tmp___14 = mark_symbol(s, n as I, i___1, m);
        tmp___15 = mark(m.offset(i___1 as isize), tmp___14, 7 as libc::c_int as I);
        tmp___16 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___15);
        i___1 += tmp___16;
        i___1 += 1;
    }
    i___2 = 0 as libc::c_int as I;
    _i___2 = n as I;
    while i___2 < _i___2 {
        tmp___17 = mark_name(s, n as I, i___2, m);
        tmp___18 = mark(m.offset(i___2 as isize), tmp___17, 8 as libc::c_int as I);
        tmp___19 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___18);
        i___2 += tmp___19;
        i___2 += 1;
    }
    i___3 = 0 as libc::c_int as I;
    _i___3 = n as I;
    while i___3 < _i___3 {
        tmp___20 = mark_number(s, n as I, i___3, m);
        tmp___21 = mark(m.offset(i___3 as isize), tmp___20, 9 as libc::c_int as I);
        tmp___22 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___21);
        i___3 += tmp___22;
        i___3 += 1;
    }
    i___4 = 0 as libc::c_int as I;
    _i___4 = n as I;
    while i___4 < _i___4 {
        tmp___23 = mark_adverb(s, n as I, i___4, m);
        tmp___24 = mark(m.offset(i___4 as isize), tmp___23, 11 as libc::c_int as I);
        tmp___25 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___24);
        i___4 += tmp___25;
        i___4 += 1;
    }
    i___5 = 0 as libc::c_int as I;
    _i___5 = n as I;
    while i___5 < _i___5 {
        tmp___26 = mark_conditional(s, n as I, i___5, m);
        tmp___27 = mark(m.offset(i___5 as isize), tmp___26, 12 as libc::c_int as I);
        tmp___28 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___27);
        i___5 += tmp___28;
        i___5 += 1;
    }
    i___6 = 0 as libc::c_int as I;
    _i___6 = n as I;
    while i___6 < _i___6 {
        tmp___29 = mark_verb(s, n as I, i___6, m);
        tmp___30 = mark(m.offset(i___6 as isize), tmp___29, 10 as libc::c_int as I);
        tmp___31 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___30);
        i___6 += tmp___31;
        i___6 += 1;
    }
    i___7 = 0 as libc::c_int as I;
    _i___7 = n as I;
    while i___7 < _i___7 {
        tmp___32 = mark_ignore(s, n as I, i___7, m);
        tmp___33 = mark(m.offset(i___7 as isize), tmp___32, 1 as libc::c_int as I);
        tmp___34 = maX(0 as libc::c_int as I, -(1 as libc::c_longlong) + tmp___33);
        i___7 += tmp___34;
        i___7 += 1;
    }
    i___8 = 0 as libc::c_int as I;
    _i___8 = n as I;
    while i___8 < _i___8 {
        if *m.offset(i___8 as isize) == 0 as libc::c_longlong {
            cd(v);
            cd(km);
            tmp___35 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
            return tmp___35;
        }
        i___8 += 1;
    }
    y = 0 as libc::c_int as I;
    tmp___36 = newK(-(3 as libc::c_int) as I, n as I);
    ks2 = tmp___36;
    tmp___37 = OOM_CD(0 as libc::c_int as I, v, km, ks2, -(1 as libc::c_int) as V);
    if tmp___37 == 0 {
        return 0 as K;
    }
    s2 = ((*ks2).k).as_mut_ptr() as S;
    memcpy(s2 as *mut libc::c_void, s as *const libc::c_void, n as size_t);
    i___9 = 0 as libc::c_int as I;
    _i___9 = n as I;
    while i___9 < _i___9 {
        if *m.offset(i___9 as isize) < 0 as libc::c_longlong {
            tmp___38 = -*m.offset(i___9 as isize);
        } else {
            tmp___38 = *m.offset(i___9 as isize);
        }
        if tmp___38 > 1 as libc::c_longlong {
            *m.offset(y as isize) = *m.offset(i___9 as isize);
            *s2.offset(y as isize) = *s2.offset(i___9 as isize);
            y += 1;
        }
        i___9 += 1;
    }
    tmp___39 = 0 as libc::c_int as I;
    *m.offset(y as isize) = tmp___39;
    *s2.offset(y as isize) = tmp___39 as C;
    tmp___40 = overcount(m, n as I);
    oc = tmp___40;
    tmp___41 = newK(-(4 as libc::c_int) as I, 1 as libc::c_longlong + oc);
    kw = tmp___41;
    tmp___42 = OOM_CD(0 as libc::c_int as I, v, km, ks2, kw, -(1 as libc::c_int) as V);
    if tmp___42 == 0 {
        return 0 as K;
    }
    w___0 = ((*kw).k).as_mut_ptr() as *mut V;
    c = 0 as libc::c_int as I;
    j = 0 as libc::c_int as I;
    if fll == 0 {
        tmp___43 = strlen(s2 as *const libc::c_char);
        fll = tmp___43 as I;
    } else {
        fll = -(1 as libc::c_int) as I;
    }
    i___10 = 0 as libc::c_int as I;
    _i___10 = y;
    while i___10 < _i___10 {
        j = capture(
            s2,
            y,
            i___10,
            m,
            w___0,
            &mut c,
            (((*v).k).as_mut_ptr() as *mut V as *mut K)
                .offset(3 as libc::c_int as isize),
            dict,
            func,
        );
        i___10 += -(1 as libc::c_longlong) + j;
        if j == 0 {
            tmp___44 = OOM_CD(
                0 as libc::c_int as I,
                0 as libc::c_int,
                v,
                km,
                ks2,
                kw,
                -(1 as libc::c_int) as V,
            );
            if tmp___44 == 0 {
                return 0 as K;
            }
        }
        i___10 += 1;
    }
    cd(km);
    cd(ks2);
    if oc > c {
        tmp___47 = sz(0 as libc::c_int as I, 1 as libc::c_longlong + oc);
        tmp___48 = lsz(tmp___47);
        tmp___49 = sz(0 as libc::c_int as I, 1 as libc::c_longlong + c);
        tmp___50 = lsz(tmp___49);
        if tmp___48 > tmp___50 {
            tmp___45 = newK(-(4 as libc::c_int) as I, 1 as libc::c_longlong + c);
            kw2 = tmp___45;
            tmp___46 = OOM_CD(
                0 as libc::c_int as I,
                v,
                kw,
                kw2,
                -(1 as libc::c_int) as V,
            );
            if tmp___46 == 0 {
                return 0 as K;
            }
            memcpy(
                ((*kw2).k).as_mut_ptr() as *mut libc::c_void,
                ((*kw).k).as_mut_ptr() as *const libc::c_void,
                (::std::mem::size_of::<V>() as libc::c_ulong as libc::c_ulonglong)
                    .wrapping_mul(c as libc::c_ulonglong) as size_t,
            );
            cd(kw);
            kw = kw2;
        }
    }
    let ref mut fresh28 = *(((*v).k).as_mut_ptr() as *mut V)
        .offset(2 as libc::c_int as isize);
    *fresh28 = kw as V;
    let ref mut fresh29 = *(((*(*(((*v).k).as_mut_ptr() as *mut V)
        .offset(2 as libc::c_int as isize) as K))
        .k)
        .as_mut_ptr() as *mut S as *mut V)
        .offset(c as isize);
    *fresh29 = 0 as V;
    return v;
}
unsafe extern "C" fn isodigit(mut c: C) -> I {
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: libc::c_int = 0;
    tmp = __ctype_b_loc();
    if *(*tmp).offset(c as libc::c_int as isize) as libc::c_int & 2048 as libc::c_int
        != 0
    {
        if (c as libc::c_int) < 56 as libc::c_int {
            tmp___0 = 1 as libc::c_int;
        } else {
            tmp___0 = 0 as libc::c_int;
        }
    } else {
        tmp___0 = 0 as libc::c_int;
    }
    return tmp___0 as I;
}
unsafe extern "C" fn odigitlen3(mut s: S) -> I {
    let mut i: I = 0;
    let mut tmp: I = 0;
    i = 0 as libc::c_int as I;
    while *s.offset(i as isize) != 0 {
        tmp = isodigit(*s.offset(i as isize));
        if !(tmp != 0) {
            break;
        }
        if !(i < 3 as libc::c_longlong) {
            break;
        }
        i += 1;
    }
    return i;
}
unsafe extern "C" fn unescape(mut s: S, mut k: *mut I) -> C {
    let mut c: C = 0;
    let mut y: I = 0;
    let mut tmp: I = 0;
    let mut a: I = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___4: I = 0;
    *k = 1 as libc::c_int as I;
    c = *s;
    if 92 as libc::c_int != c as libc::c_int {
        return c;
    }
    tmp = odigitlen3(s.offset(1 as libc::c_int as isize));
    y = tmp;
    a = 0 as libc::c_int as I;
    if y == 0 {
        *k = 2 as libc::c_int as I;
        c = *s.offset(1 as libc::c_int as isize);
        if 98 as libc::c_int == c as libc::c_int {
            tmp___3 = '\u{8}' as i32;
        } else {
            if 110 as libc::c_int == c as libc::c_int {
                tmp___2 = '\n' as i32;
            } else {
                if 114 as libc::c_int == c as libc::c_int {
                    tmp___1 = '\r' as i32;
                } else {
                    if 116 as libc::c_int == c as libc::c_int {
                        tmp___0 = '\t' as i32;
                    } else {
                        tmp___0 = c as libc::c_int;
                    }
                    tmp___1 = tmp___0;
                }
                tmp___2 = tmp___1;
            }
            tmp___3 = tmp___2;
        }
        return tmp___3 as C;
    }
    *k += y;
    i = 0 as libc::c_int as I;
    _i___0 = y;
    while i < _i___0 {
        a = a * 8 as libc::c_longlong
            + *s.offset((1 as libc::c_longlong + i) as isize) as I
            - 48 as libc::c_longlong;
        i += 1;
    }
    if a < 255 as libc::c_longlong {
        tmp___4 = a;
    } else {
        tmp___4 = 255 as libc::c_int as I;
    }
    return tmp___4 as UC as C;
}
unsafe extern "C" fn unescaped_size(mut s: S, mut n: I) -> I {
    let mut k: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    k = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        k += 1;
        if 92 as libc::c_int == *s.offset(i as isize) as libc::c_int {
            tmp = odigitlen3(s.offset(i as isize).offset(1 as libc::c_int as isize));
            tmp___0 = maX(1 as libc::c_int as I, tmp);
            i += tmp___0;
        }
        i += 1;
    }
    return k;
}
unsafe extern "C" fn unescaped_fill(mut d___0: S, mut s: S, mut n: I) -> I {
    let mut k: I = 0;
    let mut q: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: I = 0;
    k = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        tmp = k;
        k += 1;
        *d___0.offset(tmp as isize) = unescape(s.offset(i as isize), &mut q);
        i += q - 1 as libc::c_longlong;
        i += 1;
    }
    return k;
}
pub static mut param_dfa: S = b"155045113245553245155355\0" as *const u8
    as *const libc::c_char as S;
unsafe extern "C" fn param_gp(mut c: C) -> I {
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    tmp___9 = __ctype_b_loc();
    if *(*tmp___9).offset(c as libc::c_int as isize) as libc::c_int & 1024 as libc::c_int
        != 0
    {
        tmp___8 = 0 as libc::c_int;
    } else {
        tmp___7 = __ctype_b_loc();
        if *(*tmp___7).offset(c as libc::c_int as isize) as libc::c_int
            & 2048 as libc::c_int != 0
        {
            tmp___6 = 1 as libc::c_int;
        } else if 95 as libc::c_int == c as libc::c_int {
            tmp___6 = 1 as libc::c_int;
        } else {
            if 59 as libc::c_int == c as libc::c_int {
                tmp___5 = 2 as libc::c_int;
            } else {
                tmp___4 = __ctype_b_loc();
                if *(*tmp___4).offset(c as libc::c_int as isize) as libc::c_int
                    & 8192 as libc::c_int != 0
                {
                    tmp___3 = 3 as libc::c_int;
                } else {
                    if 93 as libc::c_int == c as libc::c_int {
                        tmp___2 = 4 as libc::c_int;
                    } else {
                        tmp___2 = 5 as libc::c_int;
                    }
                    tmp___3 = tmp___2;
                }
                tmp___5 = tmp___3;
            }
            tmp___6 = tmp___5;
        }
        tmp___8 = tmp___6;
    }
    return tmp___8 as I;
}
unsafe extern "C" fn param_validate(mut s: S, mut n: I) -> I {
    let mut u: S = 0 as *mut C;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: S = 0 as *mut C;
    let mut p: I = 0;
    let mut r: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: S = 0 as *mut C;
    let mut tmp___3: I = 0;
    let mut tmp___4: libc::c_int = 0;
    u = s.offset(n as isize);
    while (s as libc::c_ulong) < u as libc::c_ulong {
        tmp = __ctype_b_loc();
        if !(*(*tmp).offset(*s as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int != 0)
        {
            break;
        }
        if !(10 as libc::c_int != *s as libc::c_int) {
            break;
        }
        s = s.offset(1);
    }
    if s as libc::c_ulong == u as libc::c_ulong {
        return 0 as libc::c_int as I
    } else {
        tmp___0 = s;
        s = s.offset(1);
        if 91 as libc::c_int != *tmp___0 as libc::c_int {
            return 0 as libc::c_int as I;
        }
    }
    p = 0 as libc::c_int as I;
    tmp___1 = param_gp('.' as i32 as C);
    r = tmp___1 + 1 as libc::c_longlong;
    while (s as libc::c_ulong) < u as libc::c_ulong {
        if !(4 as libc::c_longlong > p) {
            break;
        }
        tmp___2 = s;
        s = s.offset(1);
        tmp___3 = param_gp(*tmp___2);
        p = (*param_dfa.offset((r * p + tmp___3) as isize) as libc::c_int
            - 48 as libc::c_int) as I;
    }
    if 4 as libc::c_longlong == p {
        tmp___4 = 1 as libc::c_int;
    } else {
        tmp___4 = 2 as libc::c_int;
    }
    return tmp___4 as I;
}
unsafe extern "C" fn inKtreeR(mut p: *mut K, mut t: S, mut create: I) -> *mut K {
    let mut c: I = 0;
    let mut a: I = 0;
    let mut u: S = 0 as *mut C;
    let mut tmp: S = 0 as *mut C;
    let mut k: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut e: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut a___0: K = 0 as *mut k0;
    let mut tmp___4: *mut K = 0 as *mut K;
    if *t == 0 {
        return p;
    }
    if 46 as libc::c_int == *t as libc::c_int {
        t = t.offset(1);
    }
    c = 0 as libc::c_int as I;
    a = (**p).t;
    while *t.offset(c as isize) != 0 {
        if !(46 as libc::c_int != *t.offset(c as isize) as libc::c_int) {
            break;
        }
        c += 1;
    }
    tmp = strdupn(t, c);
    u = tmp;
    tmp___0 = sp(u);
    k = tmp___0;
    free(u as *mut libc::c_void);
    t = t.offset(c as isize);
    if 95 as libc::c_int == *k as libc::c_int {
        tmp___1 = kerr(b"reserved\0" as *const u8 as *const libc::c_char);
        return tmp___1 as *mut K;
    }
    if !(6 as libc::c_longlong == a) {
        if !(5 as libc::c_longlong == a) {
            tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___2 as *mut K;
        }
    }
    e = 0 as K;
    if create != 0 {
        e = lookupEntryOrCreate(p, k);
        if e.is_null() {
            tmp___3 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
            return tmp___3 as *mut K;
        }
    } else {
        a___0 = *p;
        if 5 as libc::c_longlong == (*a___0).t {
            e = DE(a___0, k);
        }
        if e.is_null() {
            return 0 as *mut K;
        }
    }
    if 46 as libc::c_int == *t as libc::c_int {
        if *t.offset(1 as libc::c_int as isize) == 0 {
            t = t.offset(1);
            p = EAP(e);
        } else if 46 as libc::c_int
                == *t.offset(1 as libc::c_int as isize) as libc::c_int
            {
            t = t.offset(1);
            p = EAP(e);
        } else {
            p = EVP(e);
        }
    } else {
        p = EVP(e);
    }
    tmp___4 = inKtreeR(p, t, create);
    return tmp___4;
}
pub unsafe extern "C" fn inKtree(mut d___0: *mut K, mut t: S, mut create: I) -> *mut K {
    let mut tmp: I = 0;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut tmp___1: *mut K = 0 as *mut K;
    tmp = simpleString(t);
    if tmp == 0 {
        return 0 as *mut K;
    }
    if 46 as libc::c_int == *t as libc::c_int {
        tmp___0 = &mut KTREE;
    } else if *t == 0 {
        tmp___0 = &mut KTREE;
    } else {
        tmp___0 = d___0;
    }
    tmp___1 = inKtreeR(tmp___0, t, create);
    return tmp___1;
}
pub unsafe extern "C" fn capture(
    mut s: S,
    mut n: I,
    mut k: I,
    mut m: *mut I,
    mut w___0: *mut V,
    mut d___0: *mut I,
    mut locals: *mut K,
    mut dict: *mut K,
    mut func: K,
) -> I {
    let mut current_block: u64;
    let mut z: V = 0 as *mut libc::c_void;
    let mut p: *mut V = 0 as *mut V;
    let mut r: I = 0;
    let mut v: I = 0;
    let mut y: I = 0;
    let mut a: I = 0;
    let mut b___1: I = 0;
    let mut c: I = 0;
    let mut l: I = 0;
    let mut frc: I = 0;
    let mut u: S = 0 as *mut C;
    let mut e: S = 0 as *mut C;
    let mut g: K = 0 as *mut k0;
    let mut h: K = 0 as *mut k0;
    let mut hh: K = 0 as *mut k0;
    let mut M: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut ko: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut o: *mut V = 0 as *mut V;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut zp: *mut V = 0 as *mut V;
    let mut tmp___10: I = 0;
    let mut tmp___11: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut f: *mut K = 0 as *mut K;
    let mut q: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut temp: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: *mut K = 0 as *mut K;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: I = 0;
    let mut tmp___20: I = 0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: I = 0;
    let mut zdict: *mut K = 0 as *mut K;
    let mut ydict: *mut K = 0 as *mut K;
    let mut j: K = 0 as *mut k0;
    let mut state: I = 0;
    let mut tmp___23: I = 0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut a___0: S = 0 as *mut C;
    let mut tmp___25: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut b___2: S = 0 as *mut C;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___27: I = 0;
    let mut t: K = 0 as *mut k0;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: I = 0;
    let mut tmp___30: I = 0;
    let mut n___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___31: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___32: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___33: I = 0;
    let mut tmp___34: I = 0;
    let mut tmp___35: K = 0 as *mut k0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___36: K = 0 as *mut k0;
    let mut tmp___37: K = 0 as *mut k0;
    let mut tmp___38: K = 0 as *mut k0;
    let mut tmp___39: I = 0;
    let mut tmp___40: I = 0;
    let mut tmp___41: I = 0;
    let mut tmp___42: libc::c_int = 0;
    let mut tmp___43: K = 0 as *mut k0;
    let mut tmp___44: libc::c_int = 0;
    let mut tmp___45: K = 0 as *mut k0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___46: V = 0 as *mut libc::c_void;
    let mut tmp___47: I = 0;
    let mut tmp___48: I = 0;
    let mut tmp___49: K = 0 as *mut k0;
    let mut q___0: K = 0 as *mut k0;
    let mut tmp___50: K = 0 as *mut k0;
    let mut tmp___51: K = 0 as *mut k0;
    let mut tmp___52: I = 0;
    let mut tmp___53: K = 0 as *mut k0;
    let mut tmp___54: *mut K = 0 as *mut K;
    let mut q___1: V = 0 as *mut libc::c_void;
    let mut tmp___55: K = 0 as *mut k0;
    let mut tmp___56: K = 0 as *mut k0;
    let mut tmp___57: I = 0;
    let mut tmp___58: K = 0 as *mut k0;
    let mut tmp___59: *mut K = 0 as *mut K;
    let mut tmp___60: *mut K = 0 as *mut K;
    let mut tmp___61: *mut K = 0 as *mut K;
    let mut tmp___62: K = 0 as *mut k0;
    let mut tmp___63: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___64: *mut K = 0 as *mut K;
    let mut i___5: I = 0;
    let mut tmp___65: size_t = 0;
    let mut tmp___66: *mut K = 0 as *mut K;
    let mut tmp___67: *mut K = 0 as *mut K;
    let mut err: L = 0;
    let mut tmp___68: K = 0 as *mut k0;
    let mut tmp___69: libc::c_int = 0;
    let mut tmp___70: *mut K = 0 as *mut K;
    let mut tmp___71: I = 0;
    let mut tmp___72: size_t = 0;
    let mut tmp___73: K = 0 as *mut k0;
    let mut tmp___74: K = 0 as *mut k0;
    let mut i___6: L = 0;
    let mut tmp___75: I = 0;
    let mut tmp___76: K = 0 as *mut k0;
    let mut grab: I = 0;
    let mut i___7: L = 0;
    let mut is_colon: I = 0;
    let mut name_bracket_assign: I = 0;
    let mut modifier_colon: I = 0;
    let mut tmp___77: libc::c_int = 0;
    let mut tmp___78: I = 0;
    let mut tmp___79: I = 0;
    let mut tmp___80: I = 0;
    let mut tmp___81: K = 0 as *mut k0;
    let mut y_present: I = 0;
    let mut tmp___82: I = 0;
    let mut tmp___83: libc::c_int = 0;
    let mut tmp___87: I = 0;
    let mut tmp___88: I = 0;
    let mut tmp___89: I = 0;
    let mut tmp___90: K = 0 as *mut k0;
    let mut tmp___91: L = 0;
    let mut tmp___92: libc::c_int = 0;
    let mut jj: libc::c_long = 0;
    let mut tmp___93: libc::c_long = 0;
    let mut tmp___94: libc::c_long = 0;
    let mut tmp___95: libc::c_int = 0;
    let mut tmp___96: K = 0 as *mut k0;
    let mut tmp___97: L = 0;
    let mut tmp___98: libc::c_int = 0;
    let mut tmp___99: L = 0;
    let mut tmp___100: K = 0 as *mut k0;
    let mut tmp___101: K = 0 as *mut k0;
    let mut tmp___102: *mut K = 0 as *mut K;
    if fll != 0 {
        if fll != n {
            fll = -(1 as libc::c_int) as I;
        }
    }
    z = 0 as V;
    p = w___0.offset(*d___0 as isize);
    r = 1 as libc::c_int as I;
    v = 0 as libc::c_int as I;
    y = 0 as libc::c_int as I;
    b___1 = 0 as libc::c_int as I;
    frc = 0 as libc::c_int as I;
    u = b"\0" as *const u8 as *const libc::c_char as S;
    h = 0 as K;
    hh = 0 as K;
    if k >= n {
        return r
    } else {
        if !(*m.offset(k as isize) < -(1 as libc::c_longlong)) {
            return r;
        }
    }
    M = *m.offset(k as isize);
    while k + r < n {
        if !(-M == *m.offset((k + r) as isize)) {
            break;
        }
        r += 1;
    }
    let mut current_block_34: u64;
    if M == -(7 as libc::c_longlong) {
        current_block_34 = 13073662206918422867;
    } else if M == -(9 as libc::c_longlong) {
        current_block_34 = 13073662206918422867;
    } else {
        current_block_34 = 1428307939028130064;
    }
    match current_block_34 {
        13073662206918422867 => {
            while k + v < n {
                if *m.offset((k + v) as isize) < 0 as libc::c_longlong {
                    tmp___0 = -*m.offset((k + v) as isize);
                } else {
                    tmp___0 = *m.offset((k + v) as isize);
                }
                if !(-M == tmp___0) {
                    break;
                }
                tmp = v;
                v += 1;
                if *m.offset((k + tmp) as isize) <= -(3 as libc::c_longlong) {
                    y += 1;
                }
            }
        }
        _ => {}
    }
    match -M {
        12 => {
            z = offsetColon;
        }
        4 => {
            fbr = 1 as libc::c_int as I;
            fdc = 1 as libc::c_int as I;
            tmp___1 = wd_(
                s.offset(k as isize).offset(1 as libc::c_int as isize),
                (r - 2 as libc::c_longlong) as libc::c_int,
                dict,
                func,
            );
            z = tmp___1 as V;
            if z.is_null() {
                tmp___2 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
                return tmp___2 as L;
            }
        }
        2 => {
            fbr = 1 as libc::c_int as I;
            's_598: {
                if !(*d___0 == 0) {
                    tmp___4 = bk(*p.offset(-(1 as libc::c_int) as isize));
                    if !(tmp___4 != 0) {
                        break 's_598;
                    }
                }
                if !func.is_null() {
                    if k == 0 {
                        return r
                    } else {
                        tmp___3 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
                        return tmp___3 as L;
                    }
                } else {
                    tmp___3 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
                    return tmp___3 as L;
                }
            }
            a = 0 as libc::c_int as I;
            while a < -(1 as libc::c_longlong) + *d___0 {
                tmp___5 = adverbClass(
                    *p.offset((-(1 as libc::c_longlong) - a) as isize),
                );
                if tmp___5 == 0 {
                    break;
                }
                a += 1;
            }
            g = Kv();
            tmp___6 = newK(-(4 as libc::c_int) as I, a + 2 as libc::c_longlong);
            ko = tmp___6;
            tmp___7 = OOM_CD(0 as libc::c_int as I, g, ko, -(1 as libc::c_int) as V);
            if tmp___7 == 0 {
                return 0 as libc::c_int as I;
            }
            (*g).n = 0 as libc::c_int as I;
            let ref mut fresh30 = *(((*g).k).as_mut_ptr() as *mut V)
                .offset(2 as libc::c_int as isize);
            *fresh30 = ko as V;
            o = ((*(*(((*g).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
                as K))
                .k)
                .as_mut_ptr() as *mut S as *mut V;
            if *s
                .offset(k as isize)
                .offset(1 as libc::c_int as isize)
                .offset(0 as libc::c_int as isize) as libc::c_int == 120 as libc::c_int
            {
                if *s
                    .offset(k as isize)
                    .offset(1 as libc::c_int as isize)
                    .offset(1 as libc::c_int as isize) as libc::c_int
                    == 59 as libc::c_int
                {
                    fbr = 0 as libc::c_int as I;
                }
            }
            tmp___8 = wd_(
                s.offset(k as isize).offset(1 as libc::c_int as isize),
                (r - 2 as libc::c_longlong) as libc::c_int,
                dict,
                func,
            );
            z = tmp___8 as V;
            if z.is_null() {
                cd(g);
                tmp___9 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
                return tmp___9 as L;
            }
            if *m.offset((k - 1 as libc::c_longlong) as isize) < 0 as libc::c_longlong {
                tmp___11 = -*m.offset((k - 1 as libc::c_longlong) as isize);
            } else {
                tmp___11 = *m.offset((k - 1 as libc::c_longlong) as isize);
            }
            if 12 as libc::c_longlong == tmp___11 {
                zp = ((*(*(((*(z as K)).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .k)
                    .as_mut_ptr() as *mut S as *mut V;
                while !(*zp).is_null() {
                    tmp___10 = bk(*zp);
                    if tmp___10 != 0 {
                        break;
                    }
                    zp = zp.offset(1);
                }
                match *s.offset((k - 1 as libc::c_longlong) as isize) as libc::c_int {
                    58 => {
                        b___1 = 4 as libc::c_int as I;
                    }
                    102 => {
                        b___1 = 5 as libc::c_int as I;
                    }
                    101 => {
                        b___1 = 6 as libc::c_int as I;
                    }
                    111 => {
                        b___1 = 7 as libc::c_int as I;
                    }
                    _ => {}
                }
                (*(z as K)).n = b___1;
                cd(g);
            } else {
                i = 0 as libc::c_int as I;
                _i___0 = a + 1 as libc::c_longlong;
                while i < _i___0 {
                    let ref mut fresh31 = *o.offset(i as isize);
                    *fresh31 = *p.offset((-(1 as libc::c_longlong) - a + i) as isize);
                    i += 1;
                }
                let ref mut fresh32 = *o.offset((a + 1 as libc::c_longlong) as isize);
                *fresh32 = 0 as V;
                f = *p.offset((-(1 as libc::c_longlong) - a) as isize) as *mut K;
                tmp___20 = sva(f as V);
                if tmp___20 == 0 {
                    if *m.offset((k - 1 as libc::c_longlong - a) as isize)
                        < 0 as libc::c_longlong
                    {
                        tmp___18 = -*m.offset((k - 1 as libc::c_longlong - a) as isize);
                    } else {
                        tmp___18 = *m.offset((k - 1 as libc::c_longlong - a) as isize);
                    }
                    if !(11 as libc::c_longlong == tmp___18) {
                        if *m.offset((k - a) as isize) < 0 as libc::c_longlong {
                            tmp___19 = -*m.offset((k - a) as isize);
                        } else {
                            tmp___19 = *m.offset((k - a) as isize);
                        }
                        if !(11 as libc::c_longlong == tmp___19) {
                            if *m.offset((k - 1 as libc::c_longlong - a) as isize)
                                < 0 as libc::c_longlong
                            {
                                tmp___17 = -*m
                                    .offset((k - 1 as libc::c_longlong - a) as isize);
                            } else {
                                tmp___17 = *m
                                    .offset((k - 1 as libc::c_longlong - a) as isize);
                            }
                            if 8 as libc::c_longlong != tmp___17 {
                                tmp___12 = ci(*f);
                                tmp___13 = newE(LS, tmp___12);
                                q = tmp___13;
                                kap(
                                    (((*g).k).as_mut_ptr() as *mut V as *mut K)
                                        .offset(3 as libc::c_int as isize),
                                    &mut q as *mut K as V,
                                );
                                cd(q);
                                tmp___14 = DI(
                                    *locals,
                                    (**locals).n - 1 as libc::c_longlong,
                                );
                                temp = tmp___14;
                                if !temp.is_null() {
                                    cd(
                                        *((*temp).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                                    );
                                    let ref mut fresh33 = *((*temp).k)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize);
                                    *fresh33 = 0 as *mut k0;
                                }
                                tmp___15 = EVP(q);
                                *o = tmp___15 as V;
                            } else if 7 as libc::c_longlong == (**f).t {
                                if 3 as libc::c_longlong == (**f).n {
                                    tmp___16 = 1 as libc::c_int;
                                } else {
                                    tmp___16 = 0 as libc::c_int;
                                }
                            } else {
                                tmp___16 = 0 as libc::c_int;
                            }
                        }
                    }
                }
                let ref mut fresh34 = *(((*g).k).as_mut_ptr() as *mut V)
                    .offset(5 as libc::c_int as isize);
                *fresh34 = z;
                z = g as V;
            }
            *d___0 -= 1 as libc::c_longlong + a;
            p = w___0.offset(*d___0 as isize);
        }
        5 => {
            fbr = 1 as libc::c_int as I;
            fdc = 1 as libc::c_int as I;
            tmp___21 = Kv();
            z = tmp___21 as V;
            g = newK(-(3 as libc::c_int) as I, r - 2 as libc::c_longlong);
            tmp___22 = OOM_CD(0 as libc::c_int as I, z, g, -(1 as libc::c_int) as V);
            if tmp___22 == 0 {
                return 0 as libc::c_int as I;
            }
            let ref mut fresh35 = *(((*(z as K)).k).as_mut_ptr() as *mut V)
                .offset(2 as libc::c_int as isize);
            *fresh35 = g as V;
            (*(z as K)).n = 3 as libc::c_int as I;
            memcpy(
                ((*g).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                s.offset(k as isize).offset(1 as libc::c_int as isize)
                    as *const libc::c_void,
                (r - 2 as libc::c_longlong) as size_t,
            );
            if !func.is_null() {
                let ref mut fresh36 = *(((*(z as K)).k).as_mut_ptr() as *mut V)
                    .offset(0 as libc::c_int as isize);
                *fresh36 = *(((*func).k).as_mut_ptr() as *mut V)
                    .offset(0 as libc::c_int as isize);
            } else {
                let ref mut fresh37 = *(((*(z as K)).k).as_mut_ptr() as *mut V)
                    .offset(0 as libc::c_int as isize);
                *fresh37 = d_ as V;
            }
            zdict = (((*(z as K)).k).as_mut_ptr() as *mut V as *mut K)
                .offset(4 as libc::c_int as isize);
            ydict = (((*(z as K)).k).as_mut_ptr() as *mut V as *mut K)
                .offset(3 as libc::c_int as isize);
            tmp___23 = param_validate(
                s.offset(k as isize).offset(1 as libc::c_int as isize),
                r - 2 as libc::c_longlong,
            );
            state = tmp___23;
            if state > 1 as libc::c_longlong {
                tmp___24 = kerr(b"parameter\0" as *const u8 as *const libc::c_char);
                return tmp___24 as L;
            }
            if state != 0 {
                tmp___25 = strchr(
                    s.offset(k as isize).offset(1 as libc::c_int as isize)
                        as *const libc::c_char,
                    '[' as i32,
                );
                a___0 = tmp___25;
                tmp___26 = strchr(a___0 as *const libc::c_char, ']' as i32);
                b___2 = tmp___26;
                j = wd_(
                    a___0.offset(1 as libc::c_int as isize),
                    (b___2.offset_from(a___0) as libc::c_long - 1 as libc::c_long)
                        as libc::c_int,
                    zdict,
                    z as K,
                );
                tmp___27 = OOM_CD(0 as libc::c_int as I, z, j, -(1 as libc::c_int) as V);
                if tmp___27 == 0 {
                    return 0 as libc::c_int as I;
                }
                cd(j);
            } else {
                tmp___28 = Kd();
                t = tmp___28;
                tmp___29 = OOM_CD(0 as libc::c_int as I, z, t, -(1 as libc::c_int) as V);
                if tmp___29 == 0 {
                    return 0 as libc::c_int as I;
                }
                j = wd_(
                    s.offset(k as isize).offset(1 as libc::c_int as isize),
                    (r - 2 as libc::c_longlong) as libc::c_int,
                    &mut t,
                    0 as K,
                );
                tmp___30 = OOM_CD(
                    0 as libc::c_int as I,
                    z,
                    t,
                    j,
                    -(1 as libc::c_int) as V,
                );
                if tmp___30 == 0 {
                    return 0 as libc::c_int as I;
                }
                n___0 = 0 as libc::c_int as I;
                i___0 = 0 as libc::c_int as I;
                _i___1 = 3 as libc::c_int as I;
                while i___0 < _i___1 {
                    tmp___31 = DE(t, IFP[(2 as libc::c_longlong - i___0) as usize]);
                    if !tmp___31.is_null() {
                        n___0 = 3 as libc::c_longlong - i___0;
                        break;
                    } else {
                        i___0 += 1;
                    }
                }
                i___1 = 0 as libc::c_int as I;
                _i___2 = n___0;
                while i___1 < _i___2 {
                    denameD(zdict, IFP[i___1 as usize], 1 as libc::c_int as I);
                    i___1 += 1;
                }
                cd(t);
                cd(j);
            }
            j = wd_(
                s.offset(k as isize).offset(1 as libc::c_int as isize),
                (r - 2 as libc::c_longlong) as libc::c_int,
                ydict,
                z as K,
            );
            tmp___32 = OOM_CD(0 as libc::c_int as I, z, j, -(1 as libc::c_int) as V);
            if tmp___32 == 0 {
                return 0 as libc::c_int as I;
            }
            cd(j);
        }
        9 => {
            r = v;
            a = 1 as libc::c_int as I;
            i___2 = 0 as libc::c_int as I;
            _i___3 = r;
            while i___2 < _i___3 {
                tmp___33 = stringHasChar(
                    b".Eein\0" as *const u8 as *const libc::c_char as S,
                    *s.offset((k + i___2) as isize),
                );
                if tmp___33 != 0 {
                    a = 2 as libc::c_int as I;
                    break;
                } else {
                    i___2 += 1;
                }
            }
            if 1 as libc::c_longlong == y {
                tmp___34 = a;
            } else {
                tmp___34 = -a;
            }
            tmp___35 = newK(tmp___34, y);
            z = tmp___35 as V;
            if z.is_null() {
                return 0 as libc::c_int as I;
            }
            i___3 = 0 as libc::c_int as I;
            _i___4 = r;
            while i___3 < _i___4 {
                if !(*m.offset((k + i___3) as isize) >= 0 as libc::c_longlong) {
                    l = 1 as libc::c_int as I;
                    while *m.offset((l + k + i___3) as isize) == 9 as libc::c_longlong {
                        l += 1;
                    }
                    u = strdupn(s.offset(k as isize).offset(i___3 as isize), l);
                    if u.is_null() {
                        cd(z as K);
                        tmp___36 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
                        return tmp___36 as L;
                    }
                    if 1 as libc::c_longlong == a {
                        tmp___37 = formKiCS(u);
                        g = tmp___37;
                    } else {
                        tmp___38 = formKfCS(u);
                        g = tmp___38;
                    }
                    free(u as *mut libc::c_void);
                    tmp___39 = OOM_CD(
                        0 as libc::c_int as I,
                        z,
                        g,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___39 == 0 {
                        return 0 as libc::c_int as I;
                    }
                    if 1 as libc::c_longlong == a {
                        tmp___40 = b___1;
                        b___1 += 1;
                        *(((*(z as K)).k).as_mut_ptr() as *mut I)
                            .offset(
                                tmp___40 as isize,
                            ) = *(((*g).k).as_mut_ptr() as *mut I);
                    } else {
                        tmp___41 = b___1;
                        b___1 += 1;
                        *(((*(z as K)).k).as_mut_ptr() as *mut F)
                            .offset(
                                tmp___41 as isize,
                            ) = *(((*g).k).as_mut_ptr() as *mut F);
                    }
                    cd(g);
                }
                i___3 += 1;
            }
        }
        6 => {
            a = unescaped_size(
                s.offset(k as isize).offset(1 as libc::c_int as isize),
                r - 2 as libc::c_longlong,
            );
            if 1 as libc::c_longlong == a {
                tmp___42 = 3 as libc::c_int;
            } else {
                tmp___42 = -(3 as libc::c_int);
            }
            tmp___43 = newK(tmp___42 as I, a);
            z = tmp___43 as V;
            unescaped_fill(
                ((*(z as K)).k).as_mut_ptr() as *mut C,
                s.offset(k as isize).offset(1 as libc::c_int as isize),
                r - 2 as libc::c_longlong,
            );
        }
        7 => {
            r = v;
            if 1 as libc::c_longlong == y {
                tmp___44 = 4 as libc::c_int;
            } else {
                tmp___44 = -(4 as libc::c_int);
            }
            tmp___45 = newK(tmp___44 as I, y);
            z = tmp___45 as V;
            i___4 = 0 as libc::c_int as I;
            _i___5 = r;
            while i___4 < _i___5 {
                if !(*m.offset((k + i___4) as isize) >= 0 as libc::c_longlong) {
                    a = 0 as libc::c_int as I;
                    while *m.offset((k + i___4 + 1 as libc::c_longlong + a) as isize)
                        > 0 as libc::c_longlong
                    {
                        a += 1;
                    }
                    tmp___46 = alloc((1 as libc::c_longlong + a) as size_t);
                    u = tmp___46 as S;
                    if 34 as libc::c_int
                        == *s.offset((k + i___4 + 1 as libc::c_longlong) as isize)
                            as libc::c_int
                    {
                        c = 2 as libc::c_int as I;
                    } else {
                        c = 0 as libc::c_int as I;
                    }
                    tmp___47 = unescaped_fill(
                        u,
                        s
                            .offset(k as isize)
                            .offset(i___4 as isize)
                            .offset(1 as libc::c_int as isize)
                            .offset((c / 2 as libc::c_longlong) as isize),
                        a - c,
                    );
                    *u.offset(tmp___47 as isize) = 0 as libc::c_int as C;
                    tmp___48 = b___1;
                    b___1 += 1;
                    let ref mut fresh38 = *(((*(z as K)).k).as_mut_ptr() as *mut S)
                        .offset(tmp___48 as isize);
                    *fresh38 = sp(u);
                    free(u as *mut libc::c_void);
                    i___4 += a;
                }
                i___4 += 1;
            }
        }
        8 => {
            e = strdupn(s.offset(k as isize), r);
            u = sp(e);
            free(e as *mut libc::c_void);
            if u.is_null() {
                tmp___49 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
                return tmp___49 as L;
            }
            if 2 as libc::c_longlong == r {
                if 95 as libc::c_int == *u as libc::c_int {
                    tmp___71 = stringHasChar(n_s, *u.offset(1 as libc::c_int as isize));
                    if tmp___71 != 0 {
                        if 102 as libc::c_int
                            == *u.offset(1 as libc::c_int as isize) as libc::c_int
                        {
                            if !func.is_null() {
                                tmp___50 = ci(func);
                                z = tmp___50 as V;
                            } else {
                                tmp___51 = _n();
                                z = tmp___51 as V;
                            }
                        } else {
                            tmp___52 = charpos(
                                n_s,
                                *u.offset(1 as libc::c_int as isize),
                            );
                            tmp___53 = ::std::mem::transmute::<
                                _,
                                fn() -> K,
                            >(
                                (Some(
                                    (::std::mem::transmute::<
                                        V,
                                        Option::<unsafe extern "C" fn() -> K>,
                                    >(*vn_.as_mut_ptr().offset(tmp___52 as isize)))
                                        .expect("non-null function pointer"),
                                ))
                                    .expect("non-null function pointer"),
                            )();
                            z = tmp___53 as V;
                        }
                        current_block = 6870505108764293916;
                    } else {
                        current_block = 14410602989940996469;
                    }
                } else {
                    current_block = 14410602989940996469;
                }
            } else {
                current_block = 14410602989940996469;
            }
            match current_block {
                6870505108764293916 => {}
                _ => {
                    if !func.is_null() {
                        if *u.offset(0 as libc::c_int as isize) as libc::c_int
                            == 95 as libc::c_int
                        {
                            if *u.offset(1 as libc::c_int as isize) as libc::c_int
                                != 110 as libc::c_int
                            {
                                return 0 as libc::c_int as I;
                            }
                        }
                        tmp___54 = denameS(
                            b".k\0" as *const u8 as *const libc::c_char as S,
                            u,
                            0 as libc::c_int as I,
                        );
                        h = *tmp___54;
                        if 7 as libc::c_longlong == (*h).t {
                            hh = match_0(
                                *(((*h).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K,
                                *(((*func).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K,
                            );
                        }
                        if dict as libc::c_ulong
                            == (((*func).k).as_mut_ptr() as *mut V as *mut K)
                                .offset(4 as libc::c_int as isize) as libc::c_ulong
                        {
                            tmp___55 = newEntry(u);
                            q___1 = tmp___55 as V;
                            if q___1.is_null() {
                                return 0 as libc::c_int as I;
                            }
                            tmp___56 = kap(dict, &mut q___1 as *mut V as V);
                            tmp___57 = OOM_CD(
                                0 as libc::c_int as I,
                                q___1,
                                tmp___56,
                                -(1 as libc::c_int) as V,
                            );
                            if tmp___57 == 0 {
                                return 0 as libc::c_int as I;
                            }
                            tmp___58 = EV(q___1 as K);
                            z = tmp___58 as V;
                            cd(q___1 as K);
                        } else {
                            q___0 = DE(*dict, u);
                            if !q___0.is_null() {
                                tmp___59 = EVP(q___0);
                                z = tmp___59 as V;
                            } else {
                                if -(10 as libc::c_longlong) == *m.offset((k + r) as isize)
                                {
                                    if 58 as libc::c_int
                                        == *s.offset((k + r + 1 as libc::c_longlong) as isize)
                                            as libc::c_int
                                    {
                                        if -(10 as libc::c_longlong)
                                            == *m.offset((k + r + 1 as libc::c_longlong) as isize)
                                        {
                                            if 58 as libc::c_int
                                                == *s.offset((k + r) as isize) as libc::c_int
                                            {
                                                r += 1;
                                            }
                                            tmp___60 = denameS(
                                                *(((*func).k).as_mut_ptr() as *mut V)
                                                    .offset(0 as libc::c_int as isize) as S,
                                                u,
                                                1 as libc::c_int as I,
                                            );
                                            z = tmp___60 as V;
                                            current_block = 6870505108764293916;
                                        } else {
                                            current_block = 6627896859650280368;
                                        }
                                    } else {
                                        current_block = 6627896859650280368;
                                    }
                                } else {
                                    current_block = 6627896859650280368;
                                }
                                match current_block {
                                    6870505108764293916 => {}
                                    _ => {
                                        if dict as libc::c_ulong
                                            == (((*func).k).as_mut_ptr() as *mut V as *mut K)
                                                .offset(3 as libc::c_int as isize) as libc::c_ulong
                                        {
                                            if 58 as libc::c_int
                                                == *s.offset((k + r) as isize) as libc::c_int
                                            {
                                                if -(10 as libc::c_longlong) == *m.offset((k + r) as isize)
                                                {
                                                    tmp___61 = denameD(dict, u, 1 as libc::c_int as I);
                                                    z = tmp___61 as V;
                                                    current_block = 6870505108764293916;
                                                } else {
                                                    current_block = 17835568485694087998;
                                                }
                                            } else {
                                                current_block = 17835568485694087998;
                                            }
                                        } else {
                                            current_block = 17835568485694087998;
                                        }
                                        match current_block {
                                            6870505108764293916 => {}
                                            _ => {
                                                if 7 as libc::c_longlong == (*h).t {
                                                    if *(((*hh).k).as_mut_ptr() as *mut I) != 0 {
                                                        tmp___62 = ci(func);
                                                        z = tmp___62 as V;
                                                        frc = 1 as libc::c_int as I;
                                                    } else {
                                                        tmp___63 = strstr(
                                                            s as *const libc::c_char,
                                                            b"do[\0" as *const u8 as *const libc::c_char,
                                                        );
                                                        tmp___64 = denameS(
                                                            *(((*func).k).as_mut_ptr() as *mut V)
                                                                .offset(0 as libc::c_int as isize) as S,
                                                            u,
                                                            (tmp___63 as libc::c_ulong
                                                                != 0 as *mut libc::c_void as libc::c_ulong) as libc::c_int
                                                                as I,
                                                        );
                                                        z = tmp___64 as V;
                                                    }
                                                } else {
                                                    tmp___63 = strstr(
                                                        s as *const libc::c_char,
                                                        b"do[\0" as *const u8 as *const libc::c_char,
                                                    );
                                                    tmp___64 = denameS(
                                                        *(((*func).k).as_mut_ptr() as *mut V)
                                                            .offset(0 as libc::c_int as isize) as S,
                                                        u,
                                                        (tmp___63 as libc::c_ulong
                                                            != 0 as *mut libc::c_void as libc::c_ulong) as libc::c_int
                                                            as I,
                                                    );
                                                    z = tmp___64 as V;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if fll > 0 as libc::c_longlong {
                            fdc = 0 as libc::c_int as I;
                        }
                        i___5 = k;
                        loop {
                            tmp___65 = strlen(s as *const libc::c_char);
                            if !((i___5 as libc::c_ulonglong)
                                < tmp___65 as libc::c_ulonglong)
                            {
                                break;
                            }
                            if fbr == 0 {
                                if *s.offset(i___5 as isize) as libc::c_int
                                    == 59 as libc::c_int
                                {
                                    break;
                                }
                            }
                            if *s.offset(i___5 as isize) as libc::c_int
                                == 58 as libc::c_int
                            {
                                fdc = 1 as libc::c_int as I;
                                break;
                            } else {
                                if fbr != 0 {
                                    if *s.offset(i___5 as isize) as libc::c_int
                                        == 120 as libc::c_int
                                    {
                                        fdc = 1 as libc::c_int as I;
                                        break;
                                    } else if *s.offset(i___5 as isize) as libc::c_int
                                            == 121 as libc::c_int
                                        {
                                        fdc = 1 as libc::c_int as I;
                                        break;
                                    } else if *s.offset(i___5 as isize) as libc::c_int
                                            == 122 as libc::c_int
                                        {
                                        fdc = 1 as libc::c_int as I;
                                        break;
                                    }
                                }
                                i___5 += 1;
                            }
                        }
                        tmp___66 = inKtree(dict, u, 0 as libc::c_int as I);
                        z = tmp___66 as V;
                        if fStop != 0 {
                            if z.is_null() {
                                tmp___67 = denameD(&mut stopDict, u, 0 as libc::c_int as I);
                                z = tmp___67 as V;
                            }
                        }
                        if fdc == 0 {
                            if z.is_null() {
                                tmp___68 = kerr(
                                    b"value\0" as *const u8 as *const libc::c_char,
                                );
                                err = tmp___68 as L;
                                oerr();
                                printf(
                                    b"%s\n%c\n\0" as *const u8 as *const libc::c_char,
                                    u,
                                    '^' as i32,
                                );
                                return err;
                            }
                        }
                        if fStop == 0 {
                            if z.is_null() {
                                if fll != 0 {
                                    if fdc != 0 {
                                        tmp___69 = 1 as libc::c_int;
                                    } else {
                                        tmp___69 = 0 as libc::c_int;
                                    }
                                } else {
                                    tmp___69 = 0 as libc::c_int;
                                }
                                tmp___70 = denameD(dict, u, tmp___69 as I);
                                z = tmp___70 as V;
                            }
                        }
                    }
                }
            }
        }
        10 => {
            if *s.offset(k as isize) as libc::c_int == 92 as libc::c_int {
                z = 124 as libc::c_int as V;
            } else {
                if *s.offset(k as isize) as libc::c_int == 58 as libc::c_int {
                    if k == 0 as libc::c_longlong {
                        tmp___72 = strlen(s as *const libc::c_char);
                        if tmp___72 > 1 as libc::c_ulong {
                            if *s.offset((k + 1 as libc::c_longlong) as isize)
                                as libc::c_int != 58 as libc::c_int
                            {
                                z = 125 as libc::c_int as V;
                                current_block = 6870505108764293916;
                            } else {
                                current_block = 13953215331790988034;
                            }
                        } else {
                            current_block = 13953215331790988034;
                        }
                    } else {
                        current_block = 13953215331790988034;
                    }
                    match current_block {
                        6870505108764293916 => {}
                        _ => {
                            if k > 0 as libc::c_longlong {
                                if k != n - 1 as libc::c_longlong {
                                    if *s.offset((k - 1 as libc::c_longlong) as isize)
                                        as libc::c_int == 59 as libc::c_int
                                    {
                                        if *s.offset((k + 1 as libc::c_longlong) as isize)
                                            as libc::c_int != 59 as libc::c_int
                                        {
                                            if *s.offset((k + 1 as libc::c_longlong) as isize)
                                                as libc::c_int != 95 as libc::c_int
                                            {
                                                if *s.offset((k + 1 as libc::c_longlong) as isize)
                                                    as libc::c_int != 91 as libc::c_int
                                                {
                                                    z = 125 as libc::c_int as V;
                                                    current_block = 6870505108764293916;
                                                } else {
                                                    current_block = 4159081388949020429;
                                                }
                                            } else {
                                                current_block = 4159081388949020429;
                                            }
                                        } else {
                                            current_block = 4159081388949020429;
                                        }
                                    } else {
                                        current_block = 4159081388949020429;
                                    }
                                } else {
                                    current_block = 4159081388949020429;
                                }
                            } else {
                                current_block = 4159081388949020429;
                            }
                        }
                    }
                } else {
                    current_block = 4159081388949020429;
                }
                match current_block {
                    6870505108764293916 => {}
                    _ => {
                        if 95 as libc::c_int == *s.offset(k as isize) as libc::c_int {
                            if r > 1 as libc::c_longlong {
                                if k + r < n {
                                    if 58 as libc::c_int
                                        == *s.offset((k + r) as isize) as libc::c_int
                                    {
                                        if -(10 as libc::c_longlong) == *m.offset((k + r) as isize)
                                        {
                                            tmp___73 = kerr(
                                                b"parse\0" as *const u8 as *const libc::c_char,
                                            );
                                            return tmp___73 as L;
                                        }
                                    }
                                }
                                u = strdupn(s.offset(k as isize), r);
                                if u.is_null() {
                                    tmp___74 = kerr(
                                        b"parse\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___74 as L;
                                }
                                i___6 = DT_SPECIAL_VERB_OFFSET;
                                while i___6 < DT_SIZE {
                                    if !(DT[i___6 as usize].text).is_null() {
                                        tmp___75 = SC(u, DT[i___6 as usize].text);
                                        if tmp___75 == 0 {
                                            break;
                                        }
                                    }
                                    i___6 += 1;
                                }
                                if i___6 < DT_SIZE {
                                    z = i___6 as V;
                                }
                                free(u as *mut libc::c_void);
                                if z.is_null() {
                                    tmp___76 = kerr(
                                        b"reserved\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___76 as L;
                                }
                                current_block = 6870505108764293916;
                            } else {
                                current_block = 12304281332906078777;
                            }
                        } else {
                            current_block = 12304281332906078777;
                        }
                        match current_block {
                            6870505108764293916 => {}
                            _ => {
                                grab = 0 as libc::c_int as I;
                                i___7 = 0 as libc::c_int as L;
                                is_colon = (58 as libc::c_int
                                    == *s.offset(k as isize) as libc::c_int) as libc::c_int
                                    as I;
                                name_bracket_assign = 0 as libc::c_int as I;
                                if k + r < n {
                                    if 58 as libc::c_int
                                        == *s.offset((k + r) as isize) as libc::c_int
                                    {
                                        if -(10 as libc::c_longlong) == *m.offset((k + r) as isize)
                                        {
                                            tmp___77 = 1 as libc::c_int;
                                        } else {
                                            tmp___77 = 0 as libc::c_int;
                                        }
                                    } else {
                                        tmp___77 = 0 as libc::c_int;
                                    }
                                } else {
                                    tmp___77 = 0 as libc::c_int;
                                }
                                modifier_colon = tmp___77 as I;
                                if k - i___7 > 0 as libc::c_longlong {
                                    if is_colon != 0 {
                                        if *m.offset((k - i___7 - 1 as libc::c_longlong) as isize)
                                            < 0 as libc::c_longlong
                                        {
                                            tmp___78 = -*m
                                                .offset((k - i___7 - 1 as libc::c_longlong) as isize);
                                        } else {
                                            tmp___78 = *m
                                                .offset((k - i___7 - 1 as libc::c_longlong) as isize);
                                        }
                                        if 10 as libc::c_longlong == tmp___78 {
                                            i___7 += 1;
                                        }
                                    }
                                }
                                if k - i___7 > 0 as libc::c_longlong {
                                    if *m.offset((k - i___7 - 1 as libc::c_longlong) as isize)
                                        < 0 as libc::c_longlong
                                    {
                                        tmp___79 = -*m
                                            .offset((k - i___7 - 1 as libc::c_longlong) as isize);
                                    } else {
                                        tmp___79 = *m
                                            .offset((k - i___7 - 1 as libc::c_longlong) as isize);
                                    }
                                    if 2 as libc::c_longlong == tmp___79 {
                                        while *m.offset((k - i___7) as isize)
                                            != -(2 as libc::c_longlong)
                                        {
                                            i___7 += 1;
                                        }
                                    }
                                }
                                if k - i___7 > 0 as libc::c_longlong {
                                    if *m.offset((k - i___7 - 1 as libc::c_longlong) as isize)
                                        < 0 as libc::c_longlong
                                    {
                                        tmp___80 = -*m
                                            .offset((k - i___7 - 1 as libc::c_longlong) as isize);
                                    } else {
                                        tmp___80 = *m
                                            .offset((k - i___7 - 1 as libc::c_longlong) as isize);
                                    }
                                    if 8 as libc::c_longlong == tmp___80 {
                                        name_bracket_assign = 1 as libc::c_int as I;
                                    }
                                }
                                if is_colon == 0 {
                                    if (k + 1 as libc::c_longlong) < n {
                                        if 58 as libc::c_int
                                            == *s.offset((k + 1 as libc::c_longlong) as isize)
                                                as libc::c_int
                                        {
                                            if !(-(10 as libc::c_longlong)
                                                == *m.offset((k + 1 as libc::c_longlong) as isize))
                                            {
                                                name_bracket_assign = 0 as libc::c_int as I;
                                            }
                                        } else {
                                            name_bracket_assign = 0 as libc::c_int as I;
                                        }
                                    } else {
                                        name_bracket_assign = 0 as libc::c_int as I;
                                    }
                                }
                                if i___7 != 0 {
                                    if is_colon != 0 {
                                        if modifier_colon == 0 {
                                            if name_bracket_assign == 0 {
                                                tmp___81 = kerr(
                                                    b"parse\0" as *const u8 as *const libc::c_char,
                                                );
                                                return tmp___81 as L;
                                            }
                                        }
                                    }
                                }
                                if (k + r + 1 as libc::c_longlong) < n {
                                    let mut current_block_557: u64;
                                    if *s.offset((k + r + 1 as libc::c_longlong) as isize)
                                        as libc::c_int == 58 as libc::c_int
                                    {
                                        if -(10 as libc::c_longlong)
                                            == *m.offset((k + r + 1 as libc::c_longlong) as isize)
                                        {
                                            tmp___83 = 0 as libc::c_int;
                                            current_block_557 = 7146699462007542795;
                                        } else {
                                            current_block_557 = 1986223602761955293;
                                        }
                                    } else {
                                        current_block_557 = 1986223602761955293;
                                    }
                                    match current_block_557 {
                                        1986223602761955293 => {
                                            if *m.offset((k + r + 1 as libc::c_longlong) as isize)
                                                < 0 as libc::c_longlong
                                            {
                                                tmp___82 = -*m
                                                    .offset((k + r + 1 as libc::c_longlong) as isize);
                                            } else {
                                                tmp___82 = *m
                                                    .offset((k + r + 1 as libc::c_longlong) as isize);
                                            }
                                            if 3 as libc::c_longlong != tmp___82 {
                                                tmp___83 = 1 as libc::c_int;
                                            } else {
                                                tmp___83 = 0 as libc::c_int;
                                            }
                                        }
                                        _ => {}
                                    }
                                } else {
                                    tmp___83 = 0 as libc::c_int;
                                }
                                y_present = tmp___83 as I;
                                if *d___0 == 0 {
                                    current_block = 17043050094449505183;
                                } else {
                                    if *m.offset((k - 1 as libc::c_longlong) as isize)
                                        < 0 as libc::c_longlong
                                    {
                                        tmp___87 = -*m.offset((k - 1 as libc::c_longlong) as isize);
                                    } else {
                                        tmp___87 = *m.offset((k - 1 as libc::c_longlong) as isize);
                                    }
                                    if 3 as libc::c_longlong == tmp___87 {
                                        current_block = 17043050094449505183;
                                    } else {
                                        if *m.offset((k - 1 as libc::c_longlong) as isize)
                                            < 0 as libc::c_longlong
                                        {
                                            tmp___88 = -*m.offset((k - 1 as libc::c_longlong) as isize);
                                        } else {
                                            tmp___88 = *m.offset((k - 1 as libc::c_longlong) as isize);
                                        }
                                        if 11 as libc::c_longlong == tmp___88 {
                                            current_block = 17043050094449505183;
                                        } else {
                                            if *m.offset((k - 1 as libc::c_longlong) as isize)
                                                < 0 as libc::c_longlong
                                            {
                                                tmp___89 = -*m.offset((k - 1 as libc::c_longlong) as isize);
                                            } else {
                                                tmp___89 = *m.offset((k - 1 as libc::c_longlong) as isize);
                                            }
                                            if 10 as libc::c_longlong == tmp___89 {
                                                current_block = 17043050094449505183;
                                            } else {
                                                a = 2 as libc::c_int as I;
                                                current_block = 5682333073795846871;
                                            }
                                        }
                                    }
                                }
                                match current_block {
                                    17043050094449505183 => {
                                        if k + r >= n {
                                            a = 2 as libc::c_int as I;
                                        } else if -(3 as libc::c_longlong)
                                                == *m.offset((k + r) as isize)
                                            {
                                            a = 2 as libc::c_int as I;
                                        } else if -(11 as libc::c_longlong)
                                                == *m.offset((k + r) as isize)
                                            {
                                            a = 2 as libc::c_int as I;
                                        } else if -(2 as libc::c_longlong)
                                                == *m.offset((k + r) as isize)
                                            {
                                            a = 2 as libc::c_int as I;
                                        } else {
                                            a = 1 as libc::c_int as I;
                                        }
                                    }
                                    _ => {}
                                }
                                let mut current_block_619: u64;
                                if is_colon != 0 {
                                    if modifier_colon == 0 {
                                        a = 2 as libc::c_int as I;
                                        if k > 0 as libc::c_longlong {
                                            if -(3 as libc::c_longlong)
                                                != *m.offset((k - 1 as libc::c_longlong) as isize)
                                            {
                                                if *s.offset((k + 1 as libc::c_longlong) as isize) == 0 {
                                                    if name_bracket_assign == 0 {
                                                        tmp___90 = kerr(
                                                            b"parse\0" as *const u8 as *const libc::c_char,
                                                        );
                                                        return tmp___90 as L;
                                                    }
                                                }
                                            }
                                        }
                                        current_block_619 = 15340942182342897967;
                                    } else {
                                        current_block_619 = 18208930628249628297;
                                    }
                                } else {
                                    current_block_619 = 18208930628249628297;
                                }
                                match current_block_619 {
                                    18208930628249628297 => {
                                        if name_bracket_assign != 0 {
                                            if y_present != 0 {
                                                a = 2 as libc::c_int as I;
                                            } else {
                                                a = 1 as libc::c_int as I;
                                            }
                                        } else if modifier_colon != 0 {
                                            let ref mut fresh39 = *m.offset((k + r) as isize);
                                            *fresh39 *= -(1 as libc::c_longlong);
                                            r += 1;
                                            a = 1 as libc::c_int as I;
                                            grab = 1 as libc::c_int as I;
                                        }
                                    }
                                    _ => {}
                                }
                                i___7 = 0 as libc::c_int as L;
                                if r - grab == 1 as libc::c_longlong {
                                    tmp___91 = charsVerb(*s.offset(k as isize));
                                    if 1 as libc::c_longlong == a {
                                        tmp___92 = 0 as libc::c_int;
                                    } else {
                                        tmp___92 = 1 as libc::c_int;
                                    }
                                    z = (DT_VERB_OFFSET + 2 as libc::c_longlong * tmp___91
                                        + tmp___92 as L) as V;
                                    if z as libc::c_ulong
                                        == 61 as libc::c_int as V as libc::c_ulong
                                    {
                                        if *s.offset(k as isize) as libc::c_int != 58 as libc::c_int
                                        {
                                            z = 124 as libc::c_int as V;
                                        }
                                    }
                                } else {
                                    tmp___93 = atol(
                                        s.offset(k as isize) as *const libc::c_char,
                                    );
                                    jj = tmp___93;
                                    i___7 = DT_SPECIAL_VERB_OFFSET;
                                    while i___7 < DT_SIZE {
                                        if !(DT[i___7 as usize].text).is_null() {
                                            tmp___94 = atol(
                                                DT[i___7 as usize].text as *const libc::c_char,
                                            );
                                            if !(jj != tmp___94) {
                                                break;
                                            }
                                        }
                                        i___7 += 1;
                                    }
                                    if i___7 < DT_SIZE {
                                        if 1 as libc::c_longlong == a {
                                            tmp___95 = 0 as libc::c_int;
                                        } else {
                                            tmp___95 = 1 as libc::c_int;
                                        }
                                        z = (i___7 + tmp___95 as L) as V;
                                    } else {
                                        tmp___96 = kerr(
                                            b"parse\0" as *const u8 as *const libc::c_char,
                                        );
                                        return tmp___96 as L;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        11 => {
            tmp___97 = charsAdverb(*s.offset(k as isize));
            if r > 1 as libc::c_longlong {
                tmp___98 = 3 as libc::c_int;
            } else {
                tmp___98 = 0 as libc::c_int;
            }
            z = (DT_ADVERB_OFFSET + tmp___97 + tmp___98 as L) as V;
        }
        3 => {
            tmp___99 = DT_OFFSET(
                ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(end as unsafe extern "C" fn() -> K)),
            );
            z = tmp___99 as V;
        }
        _ => {}
    }
    let mut current_block_677: u64;
    match -M {
        8 => {
            if 95 as libc::c_int != *u as libc::c_int {
                if frc == 0 {
                    current_block_677 = 304940235864442923;
                } else {
                    current_block_677 = 11614974265592115102;
                }
            } else {
                current_block_677 = 11614974265592115102;
            }
        }
        4 | 2 | 5 | 9 | 6 | 7 => {
            current_block_677 = 11614974265592115102;
        }
        _ => {
            current_block_677 = 304940235864442923;
        }
    }
    match current_block_677 {
        11614974265592115102 => {
            tmp___100 = newE(LS, z as K);
            z = tmp___100 as V;
            if z.is_null() {
                tmp___101 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
                return tmp___101 as L;
            }
            kap(locals, &mut z as *mut V as V);
            cd(z as K);
            tmp___102 = EVP(z as K);
            z = tmp___102 as V;
        }
        _ => {}
    }
    cd(hh);
    *p = z;
    *d___0 += 1;
    return r;
}
pub static mut gtime_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _gtime(mut x___0: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if gtime_KVAR.is_null() {
        gtime_KVAR = X(
            b"{(_dj _ x % 86400; 100 _sv 24 60 60 _vsx x ! 86400)}\0" as *const u8
                as *const libc::c_char as S,
        );
        if gtime_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut gtime_KVAR as *mut K as V);
        cd(gtime_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 1 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh40 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh40 = x___0;
    tmp___0 = vf_ex(&mut gtime_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh41 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh41 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut inv_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _inv(mut x___0: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if inv_KVAR.is_null() {
        inv_KVAR = X(
            b"{((2##*x)#1,&#*x)_lsq x}\0" as *const u8 as *const libc::c_char as S,
        );
        if inv_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut inv_KVAR as *mut K as V);
        cd(inv_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 1 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh42 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh42 = x___0;
    tmp___0 = vf_ex(&mut inv_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh43 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh43 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut binl_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _binl(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if binl_KVAR.is_null() {
        binl_KVAR = X(b"{x _bin/: y}\0" as *const u8 as *const libc::c_char as S);
        if binl_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut binl_KVAR as *mut K as V);
        cd(binl_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh44 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh44 = x___0;
    let ref mut fresh45 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh45 = y;
    tmp___0 = vf_ex(&mut binl_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh46 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh46 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut dvl_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _dvl(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if dvl_KVAR.is_null() {
        dvl_KVAR = X(b"{x@&(#y)=y?/:x}\0" as *const u8 as *const libc::c_char as S);
        if dvl_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut dvl_KVAR as *mut K as V);
        cd(dvl_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh47 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh47 = x___0;
    let ref mut fresh48 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh48 = y;
    tmp___0 = vf_ex(&mut dvl_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh49 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh49 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut di_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _di(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if di_KVAR.is_null() {
        di_KVAR = X(
            b"{r::[@x;_n;(#x)#1];:[@x;. _f[. x;(!x)?/:y];x@&@[r;y;:;0]]}\0" as *const u8
                as *const libc::c_char as S,
        );
        if di_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut di_KVAR as *mut K as V);
        cd(di_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh50 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh50 = x___0;
    let ref mut fresh51 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh51 = y;
    tmp___0 = vf_ex(&mut di_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh52 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh52 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut dv_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _dv(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if dv_KVAR.is_null() {
        dv_KVAR = X(b"{x _dvl ,y}\0" as *const u8 as *const libc::c_char as S);
        if dv_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut dv_KVAR as *mut K as V);
        cd(dv_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh53 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh53 = x___0;
    let ref mut fresh54 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh54 = y;
    tmp___0 = vf_ex(&mut dv_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh55 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh55 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut in_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _in(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if in_KVAR.is_null() {
        in_KVAR = X(
            b"{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}\0" as *const u8
                as *const libc::c_char as S,
        );
        if in_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut in_KVAR as *mut K as V);
        cd(in_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh56 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh56 = x___0;
    let ref mut fresh57 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh57 = y;
    tmp___0 = vf_ex(&mut in_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh58 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh58 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut lin_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _lin(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if lin_KVAR.is_null() {
        lin_KVAR = X(
            b"{{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}[;y]'x}\0" as *const u8
                as *const libc::c_char as S,
        );
        if lin_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut lin_KVAR as *mut K as V);
        cd(lin_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh59 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh59 = x___0;
    let ref mut fresh60 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh60 = y;
    tmp___0 = vf_ex(&mut lin_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh61 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh61 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut mul_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _mul(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if mul_KVAR.is_null() {
        mul_KVAR = X(b"{x _dot\\:y}\0" as *const u8 as *const libc::c_char as S);
        if mul_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut mul_KVAR as *mut K as V);
        cd(mul_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh62 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh62 = x___0;
    let ref mut fresh63 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh63 = y;
    tmp___0 = vf_ex(&mut mul_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh64 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh64 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut sv_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _sv(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if sv_KVAR.is_null() {
        sv_KVAR = X(b"{{z+y*x}/[0;x;y]}\0" as *const u8 as *const libc::c_char as S);
        if sv_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut sv_KVAR as *mut K as V);
        cd(sv_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh65 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh65 = x___0;
    let ref mut fresh66 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh66 = y;
    tmp___0 = vf_ex(&mut sv_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh67 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh67 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut hat_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _hat(mut x___0: K, mut y: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if hat_KVAR.is_null() {
        hat_KVAR = X(
            b"{:[(1~4:x)|(2~4:x); _f[!x;y];:[@y;_f[x;,y]; x _dvl y]]}\0" as *const u8
                as *const libc::c_char as S,
        );
        if hat_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut hat_KVAR as *mut K as V);
        cd(hat_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh68 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh68 = x___0;
    let ref mut fresh69 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh69 = y;
    tmp___0 = vf_ex(&mut hat_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh70 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh70 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub static mut ssr_KVAR: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn _ssr(mut x___0: K, mut y: K, mut w___0: K) -> K {
    let mut a: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    a = kreci;
    if ssr_KVAR.is_null() {
        ssr_KVAR = X(
            b"{if[_n~x;:_n];i:1+2*!_.5*#x:(0,/(0,+/~+\\(>':0,\"[\"=y)-<':(\"]\"=y$:),0)+/:x _ss y)_ x;,/ :[7=4:z;@[x;i;z];4:z$:;@[x;i;:[;z]];@[x;i;:;z]]}\0"
                as *const u8 as *const libc::c_char as S,
        );
        if ssr_KVAR.is_null() {
            return 0 as K;
        }
        kap(&mut KFIXED, &mut ssr_KVAR as *mut K as V);
        cd(ssr_KVAR);
    }
    tmp = newK(0 as libc::c_int as I, 3 as libc::c_int as I);
    k = tmp;
    if k.is_null() {
        return 0 as K;
    }
    let ref mut fresh71 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh71 = x___0;
    let ref mut fresh72 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh72 = y;
    let ref mut fresh73 = *((*k).k).as_mut_ptr().offset(2 as libc::c_int as isize);
    *fresh73 = w___0;
    tmp___0 = vf_ex(&mut ssr_KVAR as *mut K as V, k);
    z = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*k).n;
    while i < _i___0 {
        let ref mut fresh74 = *((*k).k).as_mut_ptr().offset(i as isize);
        *fresh74 = 0 as *mut k0;
        i += 1;
    }
    cd(k);
    kreci = a + 1 as libc::c_longlong;
    return z;
}
pub unsafe extern "C" fn kdef(mut n: I) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    match n {
        98 => {
            tmp = X(
                b"{(_dj _ x % 86400; 100 _sv 24 60 60 _vsx x ! 86400)}\0" as *const u8
                    as *const libc::c_char as S,
            );
            return tmp;
        }
        101 => {
            tmp___0 = X(
                b"{((2##*x)#1,&#*x)_lsq x}\0" as *const u8 as *const libc::c_char as S,
            );
            return tmp___0;
        }
        107 => {
            tmp___1 = X(b"{x _bin/: y}\0" as *const u8 as *const libc::c_char as S);
            return tmp___1;
        }
        108 => {
            tmp___2 = X(
                b"{r::[@x;_n;(#x)#1];:[@x;. _f[. x;(!x)?/:y];x@&@[r;y;:;0]]}\0"
                    as *const u8 as *const libc::c_char as S,
            );
            return tmp___2;
        }
        111 => {
            tmp___3 = X(b"{x _dvl ,y}\0" as *const u8 as *const libc::c_char as S);
            return tmp___3;
        }
        112 => {
            tmp___4 = X(b"{x@&(#y)=y?/:x}\0" as *const u8 as *const libc::c_char as S);
            return tmp___4;
        }
        113 => {
            tmp___5 = X(
                b"{:[(1~4:x)|(2~4:x); _f[!x;y];:[@y;_f[x;,y]; x _dvl y]]}\0" as *const u8
                    as *const libc::c_char as S,
            );
            return tmp___5;
        }
        114 => {
            tmp___6 = X(
                b"{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}\0" as *const u8
                    as *const libc::c_char as S,
            );
            return tmp___6;
        }
        115 => {
            tmp___7 = X(
                b"{{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}[;y]'x}\0"
                    as *const u8 as *const libc::c_char as S,
            );
            return tmp___7;
        }
        117 => {
            tmp___8 = X(b"{x _dot\\:y}\0" as *const u8 as *const libc::c_char as S);
            return tmp___8;
        }
        121 => {
            tmp___9 = X(b"{{z+y*x}/[0;x;y]}\0" as *const u8 as *const libc::c_char as S);
            return tmp___9;
        }
        123 => {
            tmp___10 = X(
                b"{if[_n~x;:_n];i:1+2*!_.5*#x:(0,/(0,+/~+\\(>':0,\"[\"=y)-<':(\"]\"=y$:),0)+/:x _ss y)_ x;,/ :[7=4:z;@[x;i;z];4:z$:;@[x;i;:[;z]];@[x;i;:;z]]}\0"
                    as *const u8 as *const libc::c_char as S,
            );
            return tmp___10;
        }
        _ => {}
    }
    return 0 as K;
}
pub unsafe extern "C" fn sqr(mut x___0: F) -> F {
    let mut tmp: libc::c_double = 0.;
    tmp = pow(x___0, 2 as libc::c_int as libc::c_double);
    return tmp;
}
pub unsafe extern "C" fn math(
    mut f: Option::<unsafe extern "C" fn(F) -> F>,
    mut a: K,
) -> K {
    let mut at___0: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut t: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut e: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    at___0 = (*a).t;
    n = (*a).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    if tmp___0 > 2 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___3 = -at___0;
    } else {
        tmp___3 = at___0;
    }
    if 1 as libc::c_longlong == tmp___3 {
        tmp___2 = 2 as libc::c_longlong * at___0;
    } else {
        tmp___2 = at___0;
    }
    t = tmp___2;
    tmp___4 = newK(t, n);
    z = tmp___4;
    if 0 as libc::c_longlong == at___0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            e = *((*a).k).as_mut_ptr().offset(i as isize);
            let ref mut fresh75 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh75 = math(f, e);
            if (*((*z).k).as_mut_ptr().offset(i as isize)).is_null() {
                cd(z);
                return 0 as K;
            }
            i += 1;
        }
    } else {
        if at___0 < 0 as libc::c_longlong {
            tmp___6 = -at___0;
        } else {
            tmp___6 = at___0;
        }
        if 1 as libc::c_longlong == tmp___6 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                *(((*z).k).as_mut_ptr() as *mut F)
                    .offset(
                        i___0 as isize,
                    ) = (Some(f.expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(*(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize) as F);
                i___0 += 1;
            }
        } else {
            if at___0 < 0 as libc::c_longlong {
                tmp___5 = -at___0;
            } else {
                tmp___5 = at___0;
            }
            if 2 as libc::c_longlong == tmp___5 {
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___1 as isize,
                        ) = (Some(f.expect("non-null function pointer")))
                        .expect(
                            "non-null function pointer",
                        )(*(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize));
                    i___1 += 1;
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn _kona_exit(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    if (*a).t < 0 as libc::c_longlong {
        tmp___0 = -(*a).t;
    } else {
        tmp___0 = (*a).t;
    }
    if 1 as libc::c_longlong != tmp___0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    exit(*(((*a).k).as_mut_ptr() as *mut I) as libc::c_int);
}
pub unsafe extern "C" fn _acos(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(acos as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _asin(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(asin as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _atan(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(atan as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _ceil(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(ceil as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _cos(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(cos as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _cosh(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(cosh as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _exp(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(exp as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _floor(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(floor as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _log(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(log as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _sin(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(sin as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _sinh(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(sinh as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _sqr(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(sqr as unsafe extern "C" fn(F) -> F), a);
    return tmp;
}
pub unsafe extern "C" fn _sqrt(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(sqrt as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _tan(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(tan as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub unsafe extern "C" fn _tanh(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = math(Some(tanh as unsafe extern "C" fn(libc::c_double) -> libc::c_double), a);
    return tmp;
}
pub static mut n_s: S = b"Tacdfhikmnpstuvw\0" as *const u8 as *const libc::c_char as S;
pub static mut vn_: [V; 17] = unsafe {
    [
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_T as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_a as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_c as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_d as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_f as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_h as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_i as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_k as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_m as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_n as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_p as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_s as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_t as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_u as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_v as unsafe extern "C" fn() -> K)),
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(_w as unsafe extern "C" fn() -> K)),
        0 as *const libc::c_void as V,
    ]
};
pub unsafe extern "C" fn _abs(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t < 0 as libc::c_longlong {
        tmp___0 = -t;
    } else {
        tmp___0 = t;
    }
    if tmp___0 > 2 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___1 = newK(t, n);
    z = tmp___1;
    if 0 as libc::c_longlong == t {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh76 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh76 = _abs(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else {
        if t < 0 as libc::c_longlong {
            tmp___3 = -t;
        } else {
            tmp___3 = t;
        }
        if 1 as libc::c_longlong == tmp___3 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                if *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize)
                    < 0 as libc::c_longlong
                {
                    *(((*z).k).as_mut_ptr() as *mut I)
                        .offset(
                            i___0 as isize,
                        ) = -*(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
                } else {
                    *(((*z).k).as_mut_ptr() as *mut I)
                        .offset(
                            i___0 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
                }
                i___0 += 1;
            }
        } else {
            if t < 0 as libc::c_longlong {
                tmp___2 = -t;
            } else {
                tmp___2 = t;
            }
            if 2 as libc::c_longlong == tmp___2 {
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    if *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize)
                        < 0 as libc::c_int as F
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = -*(((*a).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize);
                    }
                    i___1 += 1;
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn net(mut x___0: K) -> I {
    let mut tmp: I = 0;
    tmp = rep(x___0, 0 as libc::c_int as I);
    return (::std::mem::size_of::<M1>() as libc::c_ulong as libc::c_ulonglong)
        .wrapping_add(tmp as libc::c_ulonglong) as I;
}
pub unsafe extern "C" fn _bd(mut x___0: K) -> K {
    let mut s: I = 0;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut m: *mut M1 = 0 as *mut M1;
    let mut u: I = 0;
    tmp = net(x___0);
    s = tmp;
    tmp___0 = newK(-(3 as libc::c_int) as I, s);
    z = tmp___0;
    if z.is_null() {
        return 0 as K;
    }
    m = ((*z).k).as_mut_ptr() as V as *mut M1;
    u = 1 as libc::c_int as I;
    (*m).a = *(&mut u as *mut I as S);
    (*m)
        .n = (s as libc::c_ulonglong)
        .wrapping_sub(::std::mem::size_of::<M1>() as libc::c_ulong as libc::c_ulonglong)
        as I;
    wrep(
        x___0,
        (m as V).offset(::std::mem::size_of::<M1>() as libc::c_ulong as isize),
        0 as libc::c_int as I,
    );
    return z;
}
pub unsafe extern "C" fn _ceiling(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = floor_ceil(
        a,
        Some(ceil as unsafe extern "C" fn(libc::c_double) -> libc::c_double),
    );
    return tmp;
}
pub unsafe extern "C" fn _ci(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t < 0 as libc::c_longlong {
        tmp___0 = -t;
    } else {
        tmp___0 = t;
    }
    if tmp___0 > 1 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___1 = newK(t * 3 as libc::c_longlong, n);
    z = tmp___1;
    if t == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh77 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh77 = _ci(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(
                    i___0 as isize,
                ) = (*(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize)
                % 256 as libc::c_longlong) as UC as C;
            i___0 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn _db(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut m: *mut M1 = 0 as *mut M1;
    let mut tmp___1: K = 0 as *mut k0;
    let mut p: V = 0 as *mut libc::c_void;
    let mut b___1: I = 0;
    let mut u: I = 0;
    let mut a: C = 0;
    let mut tmp___2: K = 0 as *mut k0;
    if -(3 as libc::c_longlong) != (*x___0).t {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if ((*x___0).n as libc::c_ulonglong)
        < ::std::mem::size_of::<M1>() as libc::c_ulong as libc::c_ulonglong
    {
        tmp___0 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    m = ((*x___0).k).as_mut_ptr() as *mut C as V as *mut M1;
    if ((*m).n as libc::c_ulonglong)
        .wrapping_add(::std::mem::size_of::<M1>() as libc::c_ulong as libc::c_ulonglong)
        != (*x___0).n as libc::c_ulonglong
    {
        tmp___1 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___1;
    }
    p = (m as V).offset(::std::mem::size_of::<M1>() as libc::c_ulong as isize);
    b___1 = 0 as libc::c_int as I;
    u = 1 as libc::c_int as I;
    a = *(&mut u as *mut I as S);
    tmp___2 = rrep(
        p,
        p.offset((*m).n as isize),
        &mut b___1,
        0 as libc::c_int as I,
        ((*m).a as libc::c_int != a as libc::c_int) as libc::c_int as I,
    );
    return tmp___2;
}
pub unsafe extern "C" fn _dj(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t < 0 as libc::c_longlong {
        tmp___0 = -t;
    } else {
        tmp___0 = t;
    }
    if tmp___0 > 1 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___1 = newK(t, n);
    z = tmp___1;
    if t == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh78 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh78 = _dj(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___0 as isize,
                ) = date_from_jdn(
                *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize),
            );
            i___0 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn _getenv(mut a: K) -> K {
    let mut u: S = 0 as *mut C;
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut z: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut tmp___1: size_t = 0;
    tmp = CSK(a);
    tmp___0 = getenv(tmp as *const libc::c_char);
    u = tmp___0;
    if !u.is_null() {
        tmp___1 = strlen(u as *const libc::c_char);
        c = tmp___1 as I;
        z = newK(-(3 as libc::c_int) as I, c);
        if z.is_null() {
            return 0 as K;
        }
        memcpy(
            ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
            u as *const libc::c_void,
            c as size_t,
        );
    } else {
        z = _n();
    }
    return z;
}
pub unsafe extern "C" fn _host(mut a: K) -> K {
    let mut t: I = 0;
    let mut b___1: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut c: *mut addrinfo = 0 as *mut addrinfo;
    let mut q: I = 0;
    let mut tmp: __uint32_t = 0;
    let mut tmp___0: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut s: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut host: [C; 1024] = [0; 1024];
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___4: S = 0 as *mut C;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___9: K = 0 as *mut k0;
    t = (*a).t;
    if 4 as libc::c_longlong == t {
        memset(
            &mut b___1 as *mut addrinfo as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
        );
        b___1.ai_family = 2 as libc::c_int;
        b___1.ai_socktype = 1 as libc::c_int;
        tmp___2 = getaddrinfo(
            *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            0 as *const libc::c_char,
            &mut b___1 as *mut addrinfo as *const addrinfo,
            &mut c as *mut *mut addrinfo,
        );
        if tmp___2 == 0 {
            tmp = __bswap_32((*((*c).ai_addr as *mut sockaddr_in)).sin_addr.s_addr);
            q = tmp as I;
            freeaddrinfo(c);
            tmp___0 = __errno_location();
            *tmp___0 = 0 as libc::c_int;
            tmp___1 = Ki(q);
            return tmp___1;
        }
    } else if 1 as libc::c_longlong == t {
        memset(
            &mut s as *mut sockaddr_in as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
        );
        s.sin_family = 2 as libc::c_int as sa_family_t;
        s.sin_addr.s_addr = __bswap_32(*(((*a).k).as_mut_ptr() as *mut I) as __uint32_t);
        tmp___6 = getnameinfo(
            &mut s as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
            ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
            host.as_mut_ptr() as *mut libc::c_char,
            ::std::mem::size_of::<[C; 1024]>() as libc::c_ulong as socklen_t,
            0 as *mut libc::c_char,
            0 as libc::c_int as socklen_t,
            0 as libc::c_int,
        );
        if tmp___6 == 0 {
            tmp___3 = __errno_location();
            *tmp___3 = 0 as libc::c_int;
            tmp___4 = sp(host.as_mut_ptr());
            tmp___5 = Ks(tmp___4);
            return tmp___5;
        }
    } else {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    tmp___8 = __errno_location();
    *tmp___8 = 0 as libc::c_int;
    tmp___9 = kerr(b"value\0" as *const u8 as *const libc::c_char);
    return tmp___9;
}
pub unsafe extern "C" fn _ic(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t != 0 {
        if t < 0 as libc::c_longlong {
            tmp___0 = -t;
        } else {
            tmp___0 = t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___1 = newK(t / 3 as libc::c_longlong, n);
    z = tmp___1;
    if t == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh79 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh79 = _ic(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___0 as isize,
                ) = *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize) as UC as I;
            i___0 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn _jd(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut x___0: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t < 0 as libc::c_longlong {
        tmp___0 = -t;
    } else {
        tmp___0 = t;
    }
    if tmp___0 > 1 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___1 = newK(t, n);
    z = tmp___1;
    if t == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh80 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh80 = _jd(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            x___0 = *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___0 as isize,
                ) = jdn_from_date(
                x___0 / 10000 as libc::c_longlong,
                x___0 / 100 as libc::c_longlong % 100 as libc::c_longlong,
                x___0 % 100 as libc::c_longlong,
            );
            i___0 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn _lt(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut b___1: time_t = 0;
    let mut c: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut d___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t < 0 as libc::c_longlong {
        tmp___0 = -t;
    } else {
        tmp___0 = t;
    }
    if (1 as libc::c_longlong) < tmp___0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    b___1 = 0 as libc::c_int as time_t;
    localtime_r(&mut b___1 as *mut time_t as *const time_t, &mut c as *mut tm);
    d___0 = c.tm_gmtoff as I;
    tmp___1 = newK(t, n);
    z = tmp___1;
    if t == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh81 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh81 = _lt(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___0 as isize,
                ) = *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize) + d___0;
            i___0 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn _ltime(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = _lt(a);
    tmp___0 = _gtime(tmp);
    return tmp___0;
}
pub unsafe extern "C" fn stat_sz(mut u: S, mut n: *mut I) -> I {
    let mut s: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut tmp: libc::c_int = 0;
    tmp = stat(u as *const libc::c_char, &mut s as *mut stat);
    if tmp != 0 {
        return -(1 as libc::c_int) as I;
    }
    *n = s.st_size as I;
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn _size(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: S = 0 as *mut C;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    t = (*a).t;
    n = 0 as libc::c_int as I;
    if 4 as libc::c_longlong != t {
        if t < 0 as libc::c_longlong {
            tmp___0 = -t;
        } else {
            tmp___0 = t;
        }
        if 3 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___4 = CSK(a);
    tmp___5 = stat_sz(tmp___4, &mut n);
    if tmp___5 != 0 {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        tmp___3 = kerr(tmp___2 as cS);
        return tmp___3;
    }
    tmp___6 = Kf(n as F);
    return tmp___6;
}
pub unsafe extern "C" fn _bin(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    if (*x___0).t > 0 as libc::c_longlong {
        tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___0 = binr(x___0, 0 as libc::c_int as I, (*x___0).n - 1 as libc::c_longlong, y);
    tmp___1 = Ki(tmp___0);
    return tmp___1;
}
pub unsafe extern "C" fn _draw(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut n: I = 0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut s: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: libc::c_int = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___4: F = 0.;
    let mut d___0: I = 0;
    let mut tmp___5: F = 0.;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    c = *(((*b___1).k).as_mut_ptr() as *mut I);
    n = 1 as libc::c_int as I;
    j = 0 as libc::c_int as I;
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    if 1 as libc::c_longlong != tmp___0 {
        tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if 1 as libc::c_longlong != bt {
            tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    i = 0 as libc::c_int as I;
    _i___0 = an;
    while i < _i___0 {
        n *= *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize);
        if n < 0 as libc::c_longlong {
            tmp___1 = kerr(b"int\0" as *const u8 as *const libc::c_char);
            return tmp___1;
        }
        i += 1;
    }
    if c < 0 as libc::c_longlong {
        if n > -c {
            tmp___2 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
    }
    if c != 0 {
        tmp___3 = -(1 as libc::c_int);
    } else {
        tmp___3 = -(2 as libc::c_int);
    }
    y = newK(tmp___3 as I, n);
    if c == 0 {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            *(((*y).k).as_mut_ptr() as *mut F).offset(i___0 as isize) = RF();
            i___0 += 1;
        }
    } else if c > 0 as libc::c_longlong {
        i___1 = 0 as libc::c_int as I;
        _i___2 = n;
        while i___1 < _i___2 {
            tmp___4 = RF();
            *(((*y).k).as_mut_ptr() as *mut I)
                .offset(i___1 as isize) = (c as F * tmp___4) as I;
            i___1 += 1;
        }
    } else if c < 0 as libc::c_longlong {
        d___0 = -c;
        vitter(((*y).k).as_mut_ptr() as *mut I, (*y).n, d___0);
        j = n - 1 as libc::c_longlong;
        while j > 0 as libc::c_longlong {
            tmp___5 = RF();
            k = ((1 as libc::c_longlong + j) as F * tmp___5) as I;
            s = *(((*y).k).as_mut_ptr() as *mut I).offset(j as isize);
            *(((*y).k).as_mut_ptr() as *mut I)
                .offset(
                    j as isize,
                ) = *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize);
            *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize) = s;
            j -= 1;
        }
    }
    z = take_reshape(a, y);
    cd(y);
    return z;
}
unsafe extern "C" fn vitter_a(mut a: *mut I, mut n: I, mut N___0: I, mut j: I) {
    let mut S___0: I = 0;
    let mut i: I = 0;
    let mut top: F = 0.;
    let mut Nreal: F = 0.;
    let mut V___0: F = 0.;
    let mut quot: F = 0.;
    let mut tmp: I = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: F = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: I = 0;
    i = 0 as libc::c_int as I;
    top = (N___0 - n) as F;
    Nreal = N___0 as F;
    while n >= 2 as libc::c_longlong {
        V___0 = RF();
        S___0 = 0 as libc::c_int as I;
        quot = top / Nreal;
        while quot > V___0 {
            S___0 += 1;
            top -= 1 as libc::c_int as F;
            Nreal -= 1 as libc::c_int as F;
            quot = quot * top / Nreal;
        }
        j += S___0 + 1 as libc::c_longlong;
        tmp = i;
        i += 1;
        *a.offset(tmp as isize) = j;
        Nreal -= 1 as libc::c_int as F;
        n -= 1;
    }
    tmp___0 = round(Nreal);
    tmp___1 = RF();
    tmp___2 = floor(tmp___0 * tmp___1);
    S___0 = tmp___2 as I;
    j += S___0 + 1 as libc::c_longlong;
    tmp___3 = i;
    i += 1;
    *a.offset(tmp___3 as isize) = j;
}
pub unsafe extern "C" fn vitter(mut a: *mut I, mut n: I, mut N___0: I) {
    let mut i: I = 0;
    let mut j: I = 0;
    let mut t: I = 0;
    let mut qu1: I = 0;
    let mut S___0: I = 0;
    let mut negalphainv: I = 0;
    let mut threshold: I = 0;
    let mut nreal: F = 0.;
    let mut Nreal: F = 0.;
    let mut ninv: F = 0.;
    let mut nmin1inv: F = 0.;
    let mut Vprime: F = 0.;
    let mut tmp: F = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut qu1real: F = 0.;
    let mut negSreal: F = 0.;
    let mut U: F = 0.;
    let mut X___0: F = 0.;
    let mut y1___0: F = 0.;
    let mut y2: F = 0.;
    let mut top: F = 0.;
    let mut bottom___0: F = 0.;
    let mut limit: F = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: F = 0.;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_double = 0.;
    let mut tmp___6: F = 0.;
    let mut tmp___7: libc::c_double = 0.;
    let mut tmp___8: libc::c_double = 0.;
    let mut tmp___9: libc::c_double = 0.;
    let mut tmp___10: F = 0.;
    let mut tmp___11: libc::c_double = 0.;
    let mut tmp___12: I = 0;
    let mut tmp___13: libc::c_double = 0.;
    let mut tmp___14: I = 0;
    i = 0 as libc::c_int as I;
    j = -(1 as libc::c_int) as I;
    qu1 = -n + 1 as libc::c_longlong + N___0;
    negalphainv = -(13 as libc::c_int) as I;
    threshold = -negalphainv * n;
    nreal = n as F;
    Nreal = N___0 as F;
    ninv = 1.0f64 / n as libc::c_double;
    nmin1inv = 1.0f64 / (n - 1 as libc::c_longlong) as libc::c_double;
    tmp = RF();
    tmp___0 = log(tmp);
    tmp___1 = exp(tmp___0 * ninv);
    Vprime = tmp___1;
    qu1real = -nreal + 1.0f64 + Nreal;
    while n > 1 as libc::c_longlong {
        if !(threshold < N___0) {
            break;
        }
        nmin1inv = 1.0f64 / (-1.0f64 + nreal);
        loop {
            loop {
                X___0 = Nreal * (-Vprime + 1.0f64);
                tmp___2 = floor(X___0);
                S___0 = tmp___2 as I;
                if S___0 < qu1 {
                    break;
                }
                tmp___3 = RF();
                tmp___4 = log(tmp___3);
                Vprime = exp(tmp___4 * ninv);
            }
            U = RF();
            negSreal = -S___0 as F;
            tmp___5 = log(U * Nreal / qu1real);
            y1___0 = exp(tmp___5 * nmin1inv);
            Vprime = y1___0 * (-X___0 / Nreal + 1.0f64)
                * (qu1real / (negSreal + qu1real));
            if Vprime <= 1.0f64 {
                break;
            }
            y2 = 1.0f64;
            top = -1.0f64 + Nreal;
            if -(1 as libc::c_longlong) + n > S___0 {
                bottom___0 = -nreal + Nreal;
                limit = (-S___0 + N___0) as F;
            } else {
                bottom___0 = -1.0f64 + negSreal + Nreal;
                limit = qu1 as F;
            }
            t = N___0 - 1 as libc::c_longlong;
            while t as F >= limit {
                y2 = y2 * top / bottom___0;
                top -= 1 as libc::c_int as F;
                bottom___0 -= 1 as libc::c_int as F;
                t -= 1;
            }
            tmp___8 = log(y2);
            tmp___9 = exp(tmp___8 * nmin1inv);
            if Nreal / (-X___0 + Nreal) >= y1___0 * tmp___9 {
                tmp___6 = RF();
                tmp___7 = log(tmp___6);
                Vprime = exp(tmp___7 * nmin1inv);
                break;
            } else {
                tmp___10 = RF();
                tmp___11 = log(tmp___10);
                Vprime = exp(tmp___11 * ninv);
            }
        }
        j += S___0 + 1 as libc::c_longlong;
        tmp___12 = i;
        i += 1;
        *a.offset(tmp___12 as isize) = j;
        N___0 = -S___0 + (-(1 as libc::c_longlong) + N___0);
        Nreal = negSreal + (-1.0f64 + Nreal);
        n -= 1;
        nreal -= 1 as libc::c_int as F;
        ninv = nmin1inv;
        qu1 = -S___0 + qu1;
        qu1real = negSreal + qu1real;
        threshold += negalphainv;
    }
    if n > 1 as libc::c_longlong {
        vitter_a(a.offset(i as isize), n, N___0, j);
    } else {
        tmp___13 = floor(N___0 as F * Vprime);
        S___0 = tmp___13 as I;
        j += S___0 + 1 as libc::c_longlong;
        tmp___14 = i;
        i += 1;
        *a.offset(tmp___14 as isize) = j;
    };
}
pub unsafe extern "C" fn _lsq(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut TOL: F = 0.;
    let mut s: F = 0.;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut r: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut m: I = 0;
    let mut tmp___7: I = 0;
    let mut u: *mut *mut F = 0 as *mut *mut F;
    let mut tmp___8: V = 0 as *mut libc::c_void;
    let mut tmp___9: V = 0 as *mut libc::c_void;
    let mut w___0: *mut F = 0 as *mut F;
    let mut tmp___10: V = 0 as *mut libc::c_void;
    let mut v: *mut *mut F = 0 as *mut *mut F;
    let mut tmp___11: V = 0 as *mut libc::c_void;
    let mut tmp___12: V = 0 as *mut libc::c_void;
    let mut t: *mut F = 0 as *mut F;
    let mut tmp___13: V = 0 as *mut libc::c_void;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut wmax: F = 0.;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut thresh: F = 0.;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut k: I = 0;
    let mut _k___0: I = 0;
    let mut tmp___14: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut j___0: I = 0;
    let mut _j___0: I = 0;
    let mut tmp___15: F = 0.;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut j___1: I = 0;
    let mut _j___1: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    TOL = 1.0e-6f64;
    if at___0 > 0 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if at___0 < -(2 as libc::c_longlong) {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        } else {
            if bt != 0 {
                tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if an == 0 {
        tmp___0 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    } else {
        if bn == 0 {
            tmp___0 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        }
    }
    r = (**((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize)).n;
    if r <= 0 as libc::c_longlong {
        tmp___1 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___1;
    }
    i = 0 as libc::c_int as I;
    _i___0 = bn;
    while i < _i___0 {
        y = *((*b___1).k).as_mut_ptr().offset(i as isize);
        if (*y).t != -(1 as libc::c_longlong) {
            if (*y).t != -(2 as libc::c_longlong) {
                tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___2;
            }
        }
        if r != (*y).n {
            tmp___3 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___3;
        }
        i += 1;
    }
    if at___0 == 0 {
        i___0 = 0 as libc::c_int as I;
        _i___1 = an;
        while i___0 < _i___1 {
            y = *((*a).k).as_mut_ptr().offset(i___0 as isize);
            if (*y).t != -(1 as libc::c_longlong) {
                if (*y).t != -(2 as libc::c_longlong) {
                    tmp___4 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___4;
                }
            }
            if r != (*y).n {
                tmp___5 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___5;
            }
            i___0 += 1;
        }
    } else if r != an {
        tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___6;
    }
    n = bn;
    if r > n {
        tmp___7 = r;
    } else {
        tmp___7 = n;
    }
    m = tmp___7;
    tmp___8 = alloc(
        (m as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<*mut F>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    u = tmp___8 as *mut *mut F;
    tmp___9 = alloc(
        ((n * m) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    let ref mut fresh82 = *u.offset(0 as libc::c_int as isize);
    *fresh82 = tmp___9 as *mut F;
    tmp___10 = alloc(
        (n as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    w___0 = tmp___10 as *mut F;
    tmp___11 = alloc(
        (n as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<*mut F>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    v = tmp___11 as *mut *mut F;
    tmp___12 = alloc(
        ((n * n) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    let ref mut fresh83 = *v.offset(0 as libc::c_int as isize);
    *fresh83 = tmp___12 as *mut F;
    tmp___13 = alloc(
        (n as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    t = tmp___13 as *mut F;
    i___1 = 0 as libc::c_int as I;
    _i___2 = m;
    while i___1 < _i___2 {
        let ref mut fresh84 = *u.offset(i___1 as isize);
        *fresh84 = (*u.offset(0 as libc::c_int as isize)).offset((n * i___1) as isize);
        i___1 += 1;
    }
    i___2 = 0 as libc::c_int as I;
    _i___3 = n;
    while i___2 < _i___3 {
        let ref mut fresh85 = *v.offset(i___2 as isize);
        *fresh85 = (*v.offset(0 as libc::c_int as isize)).offset((n * i___2) as isize);
        i___2 += 1;
    }
    i___3 = 0 as libc::c_int as I;
    _i___4 = n * m;
    while i___3 < _i___4 {
        *(*u.offset(0 as libc::c_int as isize))
            .offset(i___3 as isize) = 0 as libc::c_int as F;
        i___3 += 1;
    }
    i___4 = 0 as libc::c_int as I;
    _i___5 = r;
    while i___4 < _i___5 {
        j = 0 as libc::c_int as I;
        _j = n;
        while j < _j {
            y = *((*b___1).k).as_mut_ptr().offset(j as isize);
            if -(2 as libc::c_longlong) == (*y).t {
                *(*u.offset(i___4 as isize))
                    .offset(
                        j as isize,
                    ) = *(((*y).k).as_mut_ptr() as *mut F).offset(i___4 as isize);
            } else {
                *(*u.offset(i___4 as isize))
                    .offset(
                        j as isize,
                    ) = *(((*y).k).as_mut_ptr() as *mut I).offset(i___4 as isize) as F;
            }
            j += 1;
        }
        i___4 += 1;
    }
    svdcmp(u, m, n, w___0, v, t);
    wmax = 0.0f64;
    i___5 = 0 as libc::c_int as I;
    _i___6 = n;
    while i___5 < _i___6 {
        if *w___0.offset(i___5 as isize) > wmax {
            wmax = *w___0.offset(i___5 as isize);
        }
        i___5 += 1;
    }
    thresh = TOL * wmax;
    i___6 = 0 as libc::c_int as I;
    _i___7 = n;
    while i___6 < _i___7 {
        if *w___0.offset(i___6 as isize) < thresh {
            *w___0.offset(i___6 as isize) = 0.0f64;
        }
        i___6 += 1;
    }
    if at___0 == 0 {
        z = newK(0 as libc::c_int as I, an);
        i___7 = 0 as libc::c_int as I;
        _i___8 = an;
        while i___7 < _i___8 {
            let ref mut fresh86 = *((*z).k).as_mut_ptr().offset(i___7 as isize);
            *fresh86 = newK(-(2 as libc::c_int) as I, n);
            i___7 += 1;
        }
    } else {
        z = newK(-(2 as libc::c_int) as I, n);
    }
    k = 0 as libc::c_int as I;
    if at___0 != 0 {
        tmp___14 = 1 as libc::c_int as I;
    } else {
        tmp___14 = an;
    }
    _k___0 = tmp___14;
    while k < _k___0 {
        if at___0 != 0 {
            y = a;
        } else {
            y = *((*a).k).as_mut_ptr().offset(k as isize);
        }
        if at___0 != 0 {
            x___0 = z;
        } else {
            x___0 = *((*z).k).as_mut_ptr().offset(k as isize);
        }
        i___8 = 0 as libc::c_int as I;
        _i___9 = n;
        while i___8 < _i___9 {
            s = 0.0f64;
            if *w___0.offset(i___8 as isize) != 0. {
                j___0 = 0 as libc::c_int as I;
                _j___0 = m;
                while j___0 < _j___0 {
                    if -(2 as libc::c_longlong) == (*y).t {
                        tmp___15 = *(((*y).k).as_mut_ptr() as *mut F)
                            .offset(j___0 as isize);
                    } else {
                        tmp___15 = *(((*y).k).as_mut_ptr() as *mut I)
                            .offset(j___0 as isize) as F;
                    }
                    s += *(*u.offset(j___0 as isize)).offset(i___8 as isize) * tmp___15;
                    j___0 += 1;
                }
                s /= *w___0.offset(i___8 as isize);
            }
            *t.offset(i___8 as isize) = s;
            i___8 += 1;
        }
        i___9 = 0 as libc::c_int as I;
        _i___10 = n;
        while i___9 < _i___10 {
            s = 0.0f64;
            j___1 = 0 as libc::c_int as I;
            _j___1 = n;
            while j___1 < _j___1 {
                s
                    += *(*v.offset(i___9 as isize)).offset(j___1 as isize)
                        * *t.offset(j___1 as isize);
                *(((*x___0).k).as_mut_ptr() as *mut F).offset(i___9 as isize) = s;
                j___1 += 1;
            }
            i___9 += 1;
        }
        k += 1;
    }
    free(*u.offset(0 as libc::c_int as isize) as *mut libc::c_void);
    free(u as *mut libc::c_void);
    free(w___0 as *mut libc::c_void);
    free(*v.offset(0 as libc::c_int as isize) as *mut libc::c_void);
    free(v as *mut libc::c_void);
    free(t as *mut libc::c_void);
    return z;
}
unsafe extern "C" fn radius(mut u: F, mut v: F) -> F {
    let mut Au: F = 0.;
    let mut Av: F = 0.;
    let mut Aw: F = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    if u < 0 as libc::c_int as F {
        Au = -u;
    } else {
        Au = u;
    }
    if v < 0 as libc::c_int as F {
        Av = -v;
    } else {
        Av = v;
    }
    if Au > Av {
        Aw = Av / Au;
        tmp = sqrt(1.0f64 + Aw * Aw);
        return Au * tmp;
    }
    if Av != 0.0f64 {
        Aw = Au / Av;
        tmp___0 = sqrt(1.0f64 + Aw * Aw);
        return Av * tmp___0;
    }
    return 0.0f64;
}
unsafe extern "C" fn svdcmp(
    mut a: *mut *mut F,
    mut m: I,
    mut n: I,
    mut w___0: *mut F,
    mut v: *mut *mut F,
    mut t: *mut F,
) {
    let mut flag: I = 0;
    let mut i: I = 0;
    let mut its: I = 0;
    let mut j: I = 0;
    let mut jj: I = 0;
    let mut k: I = 0;
    let mut l: I = 0;
    let mut nm: I = 0;
    let mut nm1: I = 0;
    let mut mm1: I = 0;
    let mut c: F = 0.;
    let mut f: F = 0.;
    let mut h: F = 0.;
    let mut s: F = 0.;
    let mut x___0: F = 0.;
    let mut y: F = 0.;
    let mut z: F = 0.;
    let mut anorm: F = 0.;
    let mut g: F = 0.;
    let mut scale: F = 0.;
    let mut rv1: *mut F = 0 as *mut F;
    let mut tmp: F = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___6: libc::c_double = 0.;
    let mut tmp___7: libc::c_double = 0.;
    let mut tmp___8: libc::c_double = 0.;
    let mut tmp___9: libc::c_double = 0.;
    let mut tmp___10: libc::c_double = 0.;
    let mut tmp___11: F = 0.;
    let mut tmp___13: libc::c_double = 0.;
    let mut tmp___14: libc::c_double = 0.;
    let mut tmp___15: libc::c_double = 0.;
    let mut tmp___16: libc::c_double = 0.;
    let mut tmp___18: libc::c_double = 0.;
    let mut tmp___19: libc::c_double = 0.;
    let mut tmp___20: libc::c_double = 0.;
    let mut tmp___21: libc::c_double = 0.;
    let mut tmp___22: libc::c_double = 0.;
    let mut tmp___25: F = 0.;
    let mut tmp___26: F = 0.;
    let mut tmp___27: F = 0.;
    let mut tmp___28: F = 0.;
    let mut tmp___29: F = 0.;
    let mut tmp___30: F = 0.;
    let mut tmp___31: F = 0.;
    let mut tmp___32: F = 0.;
    let mut tmp___33: F = 0.;
    let mut tmp___34: F = 0.;
    let mut tmp___35: F = 0.;
    nm1 = n - 1 as libc::c_longlong;
    mm1 = m - 1 as libc::c_longlong;
    anorm = 0.0f64;
    g = 0.0f64;
    scale = 0.0f64;
    rv1 = t;
    i = 0 as libc::c_int as I;
    while i < n {
        l = i + 1 as libc::c_longlong;
        *rv1.offset(i as isize) = scale * g;
        scale = 0.0f64;
        s = scale;
        g = s;
        if i < m {
            k = i;
            while k < m {
                if *(*a.offset(k as isize)).offset(i as isize) < 0 as libc::c_int as F {
                    tmp = -*(*a.offset(k as isize)).offset(i as isize);
                } else {
                    tmp = *(*a.offset(k as isize)).offset(i as isize);
                }
                scale += tmp;
                k += 1;
            }
            if scale != 0. {
                k = i;
                while k < m {
                    let ref mut fresh87 = *(*a.offset(k as isize)).offset(i as isize);
                    *fresh87 /= scale;
                    s
                        += *(*a.offset(k as isize)).offset(i as isize)
                            * *(*a.offset(k as isize)).offset(i as isize);
                    k += 1;
                }
                f = *(*a.offset(i as isize)).offset(i as isize);
                if f >= 0.0f64 {
                    tmp___4 = sqrt(s);
                    if tmp___4 < 0 as libc::c_int as libc::c_double {
                        tmp___1 = sqrt(s);
                        tmp___3 = -tmp___1;
                    } else {
                        tmp___2 = sqrt(s);
                        tmp___3 = tmp___2;
                    }
                    tmp___10 = tmp___3;
                } else {
                    tmp___9 = sqrt(s);
                    if tmp___9 < 0 as libc::c_int as libc::c_double {
                        tmp___6 = sqrt(s);
                        tmp___8 = -tmp___6;
                    } else {
                        tmp___7 = sqrt(s);
                        tmp___8 = tmp___7;
                    }
                    tmp___10 = -tmp___8;
                }
                g = -tmp___10;
                h = f * g - s;
                *(*a.offset(i as isize)).offset(i as isize) = f - g;
                if i != nm1 {
                    j = l;
                    while j < n {
                        s = 0.0f64;
                        k = i;
                        while k < m {
                            s
                                += *(*a.offset(k as isize)).offset(i as isize)
                                    * *(*a.offset(k as isize)).offset(j as isize);
                            k += 1;
                        }
                        f = s / h;
                        k = i;
                        while k < m {
                            let ref mut fresh88 = *(*a.offset(k as isize))
                                .offset(j as isize);
                            *fresh88 += f * *(*a.offset(k as isize)).offset(i as isize);
                            k += 1;
                        }
                        j += 1;
                    }
                }
                k = i;
                while k < m {
                    let ref mut fresh89 = *(*a.offset(k as isize)).offset(i as isize);
                    *fresh89 *= scale;
                    k += 1;
                }
            }
        }
        *w___0.offset(i as isize) = scale * g;
        scale = 0.0f64;
        s = scale;
        g = s;
        if i < m {
            if i != nm1 {
                k = l;
                while k < n {
                    if *(*a.offset(i as isize)).offset(k as isize)
                        < 0 as libc::c_int as F
                    {
                        tmp___11 = -*(*a.offset(i as isize)).offset(k as isize);
                    } else {
                        tmp___11 = *(*a.offset(i as isize)).offset(k as isize);
                    }
                    scale += tmp___11;
                    k += 1;
                }
                if scale != 0. {
                    k = l;
                    while k < n {
                        let ref mut fresh90 = *(*a.offset(i as isize))
                            .offset(k as isize);
                        *fresh90 /= scale;
                        s
                            += *(*a.offset(i as isize)).offset(k as isize)
                                * *(*a.offset(i as isize)).offset(k as isize);
                        k += 1;
                    }
                    f = *(*a.offset(i as isize)).offset(l as isize);
                    if f >= 0.0f64 {
                        tmp___16 = sqrt(s);
                        if tmp___16 < 0 as libc::c_int as libc::c_double {
                            tmp___13 = sqrt(s);
                            tmp___15 = -tmp___13;
                        } else {
                            tmp___14 = sqrt(s);
                            tmp___15 = tmp___14;
                        }
                        tmp___22 = tmp___15;
                    } else {
                        tmp___21 = sqrt(s);
                        if tmp___21 < 0 as libc::c_int as libc::c_double {
                            tmp___18 = sqrt(s);
                            tmp___20 = -tmp___18;
                        } else {
                            tmp___19 = sqrt(s);
                            tmp___20 = tmp___19;
                        }
                        tmp___22 = -tmp___20;
                    }
                    g = -tmp___22;
                    h = f * g - s;
                    *(*a.offset(i as isize)).offset(l as isize) = f - g;
                    k = l;
                    while k < n {
                        *rv1
                            .offset(
                                k as isize,
                            ) = *(*a.offset(i as isize)).offset(k as isize) / h;
                        k += 1;
                    }
                    if i != mm1 {
                        j = l;
                        while j < m {
                            s = 0.0f64;
                            k = l;
                            while k < n {
                                s
                                    += *(*a.offset(j as isize)).offset(k as isize)
                                        * *(*a.offset(i as isize)).offset(k as isize);
                                k += 1;
                            }
                            k = l;
                            while k < n {
                                let ref mut fresh91 = *(*a.offset(j as isize))
                                    .offset(k as isize);
                                *fresh91 += s * *rv1.offset(k as isize);
                                k += 1;
                            }
                            j += 1;
                        }
                    }
                    k = l;
                    while k < n {
                        let ref mut fresh92 = *(*a.offset(i as isize))
                            .offset(k as isize);
                        *fresh92 *= scale;
                        k += 1;
                    }
                }
            }
        }
        if *w___0.offset(i as isize) < 0 as libc::c_int as F {
            tmp___27 = -*w___0.offset(i as isize);
        } else {
            tmp___27 = *w___0.offset(i as isize);
        }
        if *rv1.offset(i as isize) < 0 as libc::c_int as F {
            tmp___28 = -*rv1.offset(i as isize);
        } else {
            tmp___28 = *rv1.offset(i as isize);
        }
        if anorm > tmp___27 + tmp___28 {
            anorm = anorm;
        } else {
            if *w___0.offset(i as isize) < 0 as libc::c_int as F {
                tmp___25 = -*w___0.offset(i as isize);
            } else {
                tmp___25 = *w___0.offset(i as isize);
            }
            if *rv1.offset(i as isize) < 0 as libc::c_int as F {
                tmp___26 = -*rv1.offset(i as isize);
            } else {
                tmp___26 = *rv1.offset(i as isize);
            }
            anorm = tmp___25 + tmp___26;
        }
        i += 1;
    }
    i = n - 1 as libc::c_longlong;
    while i >= 0 as libc::c_longlong {
        if i < nm1 {
            if g != 0. {
                j = l;
                while j < n {
                    *(*v.offset(j as isize))
                        .offset(
                            i as isize,
                        ) = *(*a.offset(i as isize)).offset(j as isize)
                        / *(*a.offset(i as isize)).offset(l as isize) / g;
                    j += 1;
                }
                j = l;
                while j < n {
                    s = 0.0f64;
                    k = l;
                    while k < n {
                        s
                            += *(*a.offset(i as isize)).offset(k as isize)
                                * *(*v.offset(k as isize)).offset(j as isize);
                        k += 1;
                    }
                    k = l;
                    while k < n {
                        let ref mut fresh93 = *(*v.offset(k as isize))
                            .offset(j as isize);
                        *fresh93 += s * *(*v.offset(k as isize)).offset(i as isize);
                        k += 1;
                    }
                    j += 1;
                }
            }
            j = l;
            while j < n {
                tmp___29 = 0.0f64;
                *(*v.offset(j as isize)).offset(i as isize) = tmp___29;
                *(*v.offset(i as isize)).offset(j as isize) = tmp___29;
                j += 1;
            }
        }
        *(*v.offset(i as isize)).offset(i as isize) = 1.0f64;
        g = *rv1.offset(i as isize);
        l = i;
        i -= 1;
    }
    i = n - 1 as libc::c_longlong;
    while i >= 0 as libc::c_longlong {
        l = i + 1 as libc::c_longlong;
        g = *w___0.offset(i as isize);
        if i < nm1 {
            j = l;
            while j < n {
                *(*a.offset(i as isize)).offset(j as isize) = 0.0f64;
                j += 1;
            }
        }
        if g != 0. {
            g = 1.0f64 / g;
            if i != nm1 {
                j = l;
                while j < n {
                    s = 0.0f64;
                    k = l;
                    while k < m {
                        s
                            += *(*a.offset(k as isize)).offset(i as isize)
                                * *(*a.offset(k as isize)).offset(j as isize);
                        k += 1;
                    }
                    f = s / *(*a.offset(i as isize)).offset(i as isize) * g;
                    k = i;
                    while k < m {
                        let ref mut fresh94 = *(*a.offset(k as isize))
                            .offset(j as isize);
                        *fresh94 += f * *(*a.offset(k as isize)).offset(i as isize);
                        k += 1;
                    }
                    j += 1;
                }
            }
            j = i;
            while j < m {
                let ref mut fresh95 = *(*a.offset(j as isize)).offset(i as isize);
                *fresh95 *= g;
                j += 1;
            }
        } else {
            j = i;
            while j < m {
                *(*a.offset(j as isize)).offset(i as isize) = 0.0f64;
                j += 1;
            }
        }
        let ref mut fresh96 = *(*a.offset(i as isize)).offset(i as isize);
        *fresh96 += 1 as libc::c_int as F;
        i -= 1;
    }
    k = n - 1 as libc::c_longlong;
    while k >= 0 as libc::c_longlong {
        its = 0 as libc::c_int as I;
        while its < 30 as libc::c_longlong {
            flag = 1 as libc::c_int as I;
            l = k;
            while l >= 0 as libc::c_longlong {
                nm = l - 1 as libc::c_longlong;
                if *rv1.offset(l as isize) < 0 as libc::c_int as F {
                    tmp___30 = -*rv1.offset(l as isize);
                } else {
                    tmp___30 = *rv1.offset(l as isize);
                }
                if tmp___30 + anorm == anorm {
                    flag = 0 as libc::c_int as I;
                    break;
                } else {
                    if *w___0.offset(nm as isize) < 0 as libc::c_int as F {
                        tmp___31 = -*w___0.offset(nm as isize);
                    } else {
                        tmp___31 = *w___0.offset(nm as isize);
                    }
                    if tmp___31 + anorm == anorm {
                        break;
                    }
                    l -= 1;
                }
            }
            if flag != 0 {
                c = 0.0f64;
                s = 1.0f64;
                i = l;
                while i <= k {
                    f = s * *rv1.offset(i as isize);
                    if f < 0 as libc::c_int as F {
                        tmp___32 = -f;
                    } else {
                        tmp___32 = f;
                    }
                    if tmp___32 + anorm != anorm {
                        g = *w___0.offset(i as isize);
                        h = radius(f, g);
                        *w___0.offset(i as isize) = h;
                        h = 1.0f64 / h;
                        c = g * h;
                        s = -f * h;
                        j = 0 as libc::c_int as I;
                        while j < m {
                            y = *(*a.offset(j as isize)).offset(nm as isize);
                            z = *(*a.offset(j as isize)).offset(i as isize);
                            *(*a.offset(j as isize)).offset(nm as isize) = y * c + z * s;
                            *(*a.offset(j as isize)).offset(i as isize) = z * c - y * s;
                            j += 1;
                        }
                    }
                    i += 1;
                }
            }
            z = *w___0.offset(k as isize);
            if l == k {
                if z < 0.0f64 {
                    *w___0.offset(k as isize) = -z;
                    j = 0 as libc::c_int as I;
                    while j < n {
                        *(*v.offset(j as isize))
                            .offset(
                                k as isize,
                            ) = -*(*v.offset(j as isize)).offset(k as isize);
                        j += 1;
                    }
                }
                break;
            } else {
                if its == 30 as libc::c_longlong {
                    kerr(b"limit\0" as *const u8 as *const libc::c_char);
                    return;
                }
                x___0 = *w___0.offset(l as isize);
                nm = k - 1 as libc::c_longlong;
                y = *w___0.offset(nm as isize);
                g = *rv1.offset(nm as isize);
                h = *rv1.offset(k as isize);
                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0f64 * h * y);
                g = radius(f, 1.0f64);
                if f >= 0.0f64 {
                    if g < 0 as libc::c_int as F {
                        tmp___33 = -g;
                    } else {
                        tmp___33 = g;
                    }
                    tmp___35 = tmp___33;
                } else {
                    if g < 0 as libc::c_int as F {
                        tmp___34 = -g;
                    } else {
                        tmp___34 = g;
                    }
                    tmp___35 = -tmp___34;
                }
                f = ((x___0 - z) * (x___0 + z) + h * (y / (f + tmp___35) - h)) / x___0;
                s = 1.0f64;
                c = s;
                j = l;
                while j <= nm {
                    i = j + 1 as libc::c_longlong;
                    g = *rv1.offset(i as isize);
                    y = *w___0.offset(i as isize);
                    h = s * g;
                    g = c * g;
                    z = radius(f, h);
                    *rv1.offset(j as isize) = z;
                    c = f / z;
                    s = h / z;
                    f = x___0 * c + g * s;
                    g = g * c - x___0 * s;
                    h = y * s;
                    y *= c;
                    jj = 0 as libc::c_int as I;
                    while jj < n {
                        x___0 = *(*v.offset(jj as isize)).offset(j as isize);
                        z = *(*v.offset(jj as isize)).offset(i as isize);
                        *(*v.offset(jj as isize)).offset(j as isize) = x___0 * c + z * s;
                        *(*v.offset(jj as isize)).offset(i as isize) = z * c - x___0 * s;
                        jj += 1;
                    }
                    z = radius(f, h);
                    *w___0.offset(j as isize) = z;
                    if z != 0. {
                        z = 1.0f64 / z;
                        c = f * z;
                        s = h * z;
                    }
                    f = c * g + s * y;
                    x___0 = c * y - s * g;
                    jj = 0 as libc::c_int as I;
                    while jj < m {
                        y = *(*a.offset(jj as isize)).offset(j as isize);
                        z = *(*a.offset(jj as isize)).offset(i as isize);
                        *(*a.offset(jj as isize)).offset(j as isize) = y * c + z * s;
                        *(*a.offset(jj as isize)).offset(i as isize) = z * c - y * s;
                        jj += 1;
                    }
                    j += 1;
                }
                *rv1.offset(l as isize) = 0.0f64;
                *rv1.offset(k as isize) = f;
                *w___0.offset(k as isize) = x___0;
                its += 1;
            }
        }
        k -= 1;
    }
}
pub unsafe extern "C" fn _setenv(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut bt: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut r: I = 0;
    let mut tmp___0: S = 0 as *mut C;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    at___0 = (*a).t;
    bt = (*b___1).t;
    if at___0 != 4 as libc::c_longlong {
        if bt != -(3 as libc::c_longlong) {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___0 = CSK(b___1);
    tmp___1 = setenv(
        *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
        tmp___0 as *const libc::c_char,
        1 as libc::c_int,
    );
    r = tmp___1 as I;
    if r != 0 {
        tmp___2 = __errno_location();
        tmp___3 = strerror(*tmp___2);
        tmp___4 = kerr(tmp___3 as cS);
        return tmp___4;
    }
    tmp___5 = _n();
    return tmp___5;
}
pub unsafe extern "C" fn _sm(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut x___0: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut y: I = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___12: *mut k0 = 0 as *mut k0;
    let mut tmp___13: *mut k0 = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut f: I = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: S = 0 as *mut C;
    let mut tmp___20: S = 0 as *mut C;
    let mut tmp___21: libc::c_int = 0;
    let mut tmp___22: K = 0 as *mut k0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if 0 as libc::c_longlong != at___0 {
        if at___0 < 0 as libc::c_longlong {
            tmp___0 = -at___0;
        } else {
            tmp___0 = at___0;
        }
        if 3 as libc::c_longlong != tmp___0 {
            if at___0 < 0 as libc::c_longlong {
                tmp___1 = -at___0;
            } else {
                tmp___1 = at___0;
            }
            if 4 as libc::c_longlong != tmp___1 {
                tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if 0 as libc::c_longlong != bt {
        if bt < 0 as libc::c_longlong {
            tmp___3 = -bt;
        } else {
            tmp___3 = bt;
        }
        if 3 as libc::c_longlong != tmp___3 {
            if bt < 0 as libc::c_longlong {
                tmp___4 = -bt;
            } else {
                tmp___4 = bt;
            }
            if 4 as libc::c_longlong != tmp___4 {
                tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___2;
            }
        }
    }
    if at___0 <= 0 as libc::c_longlong {
        if -(3 as libc::c_longlong) != at___0 {
            tmp___5 = 1 as libc::c_int;
        } else {
            tmp___5 = 0 as libc::c_int;
        }
    } else {
        tmp___5 = 0 as libc::c_int;
    }
    x___0 = tmp___5 as I;
    if bt <= 0 as libc::c_longlong {
        if -(3 as libc::c_longlong) != bt {
            tmp___6 = 1 as libc::c_int;
        } else {
            tmp___6 = 0 as libc::c_int;
        }
    } else {
        tmp___6 = 0 as libc::c_int;
    }
    y = tmp___6 as I;
    if x___0 != 0 {
        if y != 0 {
            if an != bn {
                tmp___7 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___7;
            }
        }
    }
    's_486: {
        if !(x___0 != 0) {
            if !(y != 0) {
                break 's_486;
            }
        }
        if x___0 != 0 {
            tmp___8 = promote(a);
            a = tmp___8;
        } else {
            a = a;
        }
        if y != 0 {
            tmp___9 = promote(b___1);
            b___1 = tmp___9;
        } else {
            b___1 = b___1;
        }
        if x___0 != 0 {
            tmp___10 = (*a).n;
        } else {
            tmp___10 = (*b___1).n;
        }
        tmp___11 = newK(0 as libc::c_int as I, tmp___10);
        z = tmp___11;
        i = 0 as libc::c_int as I;
        _i___0 = (*z).n;
        while i < _i___0 {
            if y != 0 {
                tmp___12 = *((*b___1).k).as_mut_ptr().offset(i as isize);
            } else {
                tmp___12 = b___1;
            }
            if x___0 != 0 {
                tmp___13 = *((*a).k).as_mut_ptr().offset(i as isize);
            } else {
                tmp___13 = a;
            }
            let ref mut fresh97 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh97 = _sm(tmp___13, tmp___12);
            i += 1;
        }
        cd(a);
        tmp___14 = demote(z);
        return tmp___14;
    }
    tmp___19 = CSK(a);
    tmp___20 = CSK(b___1);
    tmp___21 = fnmatch(
        tmp___20 as *const libc::c_char,
        tmp___19 as *const libc::c_char,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
    if tmp___21 != 0 {
        tmp___18 = 0 as libc::c_int;
    } else {
        tmp___18 = 1 as libc::c_int;
    }
    f = tmp___18 as I;
    tmp___22 = Ki(f);
    return tmp___22;
}
pub unsafe extern "C" fn _ss(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut x___0: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut y: I = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___15: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___17: *mut k0 = 0 as *mut k0;
    let mut tmp___18: *mut k0 = 0 as *mut k0;
    let mut tmp___19: *mut k0 = 0 as *mut k0;
    let mut tmp___20: I = 0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut t: S = 0 as *mut C;
    let mut tmp___22: S = 0 as *mut C;
    let mut p: S = 0 as *mut C;
    let mut tmp___23: S = 0 as *mut C;
    let mut lp: I = 0;
    let mut tmp___24: size_t = 0;
    let mut tmp___25: K = 0 as *mut k0;
    let mut r: *mut I = 0 as *mut I;
    let mut tmp___26: V = 0 as *mut libc::c_void;
    let mut n: I = 0;
    let mut tmp___28: size_t = 0;
    let mut tmp___29: libc::c_ulonglong = 0;
    let mut tmp___30: I = 0;
    let mut m: I = 0;
    let mut c: C = 0;
    let mut d___0: C = 0;
    let mut occ: [I; 256] = [0; 256];
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut v: [C; 256] = [0; 256];
    let mut w___0: [C; 256] = [0; 256];
    let mut q: S = 0 as *mut C;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___31: S = 0 as *mut C;
    let mut tmp___32: K = 0 as *mut k0;
    let mut any: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___34: K = 0 as *mut k0;
    let mut f: *mut I = 0 as *mut I;
    let mut tmp___35: V = 0 as *mut libc::c_void;
    let mut s: *mut I = 0 as *mut I;
    let mut tmp___36: V = 0 as *mut libc::c_void;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___37: I = 0;
    let mut i___4: I = 0;
    let mut j: I = 0;
    let mut flag: I = 0;
    let mut i___5: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___38: S = 0 as *mut C;
    let mut tmp___39: S = 0 as *mut C;
    let mut i___6: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___40: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___41: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___42: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut c___0: C = 0;
    let mut tmp___43: S = 0 as *mut C;
    let mut tmp___44: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if 0 as libc::c_longlong != at___0 {
        if at___0 < 0 as libc::c_longlong {
            tmp___0 = -at___0;
        } else {
            tmp___0 = at___0;
        }
        if 3 as libc::c_longlong != tmp___0 {
            if at___0 < 0 as libc::c_longlong {
                tmp___1 = -at___0;
            } else {
                tmp___1 = at___0;
            }
            if 4 as libc::c_longlong != tmp___1 {
                tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if 0 as libc::c_longlong != bt {
        if bt < 0 as libc::c_longlong {
            tmp___3 = -bt;
        } else {
            tmp___3 = bt;
        }
        if 3 as libc::c_longlong != tmp___3 {
            if bt < 0 as libc::c_longlong {
                tmp___4 = -bt;
            } else {
                tmp___4 = bt;
            }
            if 4 as libc::c_longlong != tmp___4 {
                tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___2;
            }
        }
    }
    if at___0 <= 0 as libc::c_longlong {
        if -(3 as libc::c_longlong) != at___0 {
            tmp___5 = 1 as libc::c_int;
        } else {
            tmp___5 = 0 as libc::c_int;
        }
    } else {
        tmp___5 = 0 as libc::c_int;
    }
    x___0 = tmp___5 as I;
    if bt <= 0 as libc::c_longlong {
        if -(3 as libc::c_longlong) != bt {
            tmp___6 = 1 as libc::c_int;
        } else {
            tmp___6 = 0 as libc::c_int;
        }
    } else {
        tmp___6 = 0 as libc::c_int;
    }
    y = tmp___6 as I;
    if x___0 != 0 {
        if y != 0 {
            if an != bn {
                tmp___7 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___7;
            }
        }
    }
    let mut current_block_76: u64;
    if 4 as libc::c_longlong == at___0 {
        current_block_76 = 6114940136869367015;
    } else {
        if at___0 < 0 as libc::c_longlong {
            tmp___9 = -at___0;
        } else {
            tmp___9 = at___0;
        }
        if 3 as libc::c_longlong == tmp___9 {
            current_block_76 = 6114940136869367015;
        } else {
            current_block_76 = 6712462580143783635;
        }
    }
    match current_block_76 {
        6114940136869367015 => {
            if an == 0 {
                tmp___8 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___8;
            }
        }
        _ => {}
    }
    's_688: {
        if !(x___0 != 0) {
            if !(y != 0) {
                break 's_688;
            }
        }
        if x___0 != 0 {
            tmp___10 = promote(a);
            a = tmp___10;
        } else {
            tmp___11 = ci(a);
            a = tmp___11;
        }
        if y != 0 {
            tmp___12 = promote(b___1);
            b___1 = tmp___12;
        } else {
            tmp___13 = ci(b___1);
            b___1 = tmp___13;
        }
        tmp___14 = OOM_CD(0 as libc::c_int as I, a, b___1, -(1 as libc::c_int) as V);
        if tmp___14 == 0 {
            return 0 as K;
        }
        if x___0 != 0 {
            tmp___15 = (*a).n;
        } else {
            tmp___15 = (*b___1).n;
        }
        tmp___16 = newK(0 as libc::c_int as I, tmp___15);
        z = tmp___16;
        i = 0 as libc::c_int as I;
        _i___0 = (*z).n;
        while i < _i___0 {
            if y != 0 {
                tmp___18 = *((*b___1).k).as_mut_ptr().offset(i as isize);
            } else {
                tmp___18 = b___1;
            }
            if x___0 != 0 {
                tmp___19 = *((*a).k).as_mut_ptr().offset(i as isize);
            } else {
                tmp___19 = a;
            }
            tmp___17 = _ss(tmp___19, tmp___18);
            let ref mut fresh98 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh98 = tmp___17;
            tmp___20 = OOM_CD(
                0 as libc::c_int as I,
                a,
                b___1,
                z,
                tmp___17,
                -(1 as libc::c_int) as V,
            );
            if tmp___20 == 0 {
                return 0 as K;
            }
            i += 1;
        }
        cd(a);
        cd(b___1);
        tmp___21 = demote(z);
        return tmp___21;
    }
    tmp___22 = CSK(a);
    t = tmp___22;
    tmp___23 = CSK(b___1);
    p = tmp___23;
    tmp___24 = strlen(p as *const libc::c_char);
    lp = tmp___24 as I;
    if lp == 0 {
        tmp___25 = kerr(b"length\0" as *const u8 as *const libc::c_char);
        return tmp___25;
    }
    tmp___26 = alloc(
        (lp as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    r = tmp___26 as *mut I;
    if (*a).t < 0 as libc::c_longlong {
        tmp___30 = -(*a).t;
    } else {
        tmp___30 = (*a).t;
    }
    if 3 as libc::c_longlong == tmp___30 {
        tmp___29 = (*a).n as libc::c_ulonglong;
    } else {
        tmp___28 = strlen(t as *const libc::c_char);
        tmp___29 = tmp___28 as libc::c_ulonglong;
    }
    n = tmp___29 as I;
    m = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = 256 as libc::c_int as I;
    while i___0 < _i___1 {
        occ[i___0 as usize] = -(1 as libc::c_int) as I;
        i___0 += 1;
    }
    q = p;
    while *q != 0 {
        *r.offset(m as isize) = q.offset_from(p) as libc::c_long as I;
        if 63 as libc::c_int == *q as libc::c_int {
            q = q.offset(1);
            i___1 = 0 as libc::c_int as I;
            _i___2 = 256 as libc::c_int as I;
            while i___1 < _i___2 {
                occ[i___1 as usize] = m;
                i___1 += 1;
            }
        } else if 91 as libc::c_int != *q as libc::c_int {
            tmp___31 = q;
            q = q.offset(1);
            occ[*tmp___31 as I as usize] = m;
        } else {
            q = rangematch(
                q.offset(1 as libc::c_int as isize),
                0 as libc::c_int as C,
                v.as_mut_ptr(),
            );
            if q.is_null() {
                free(p as *mut libc::c_void);
                tmp___32 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                return tmp___32;
            }
            any = 0 as libc::c_int as I;
            i___2 = 0 as libc::c_int as I;
            _i___3 = 256 as libc::c_int as I;
            while i___2 < _i___3 {
                if v[i___2 as usize] != 0 {
                    occ[i___2 as usize] = m;
                    any = 1 as libc::c_int as I;
                }
                i___2 += 1;
            }
            if any == 0 {
                free(p as *mut libc::c_void);
                tmp___33 = newK(-(1 as libc::c_int) as I, 0 as libc::c_int as I);
                return tmp___33;
            }
        }
        m += 1;
    }
    tmp___34 = newK(-(1 as libc::c_int) as I, 0 as libc::c_int as I);
    z___0 = tmp___34;
    tmp___35 = alloc(
        ((m + 1 as libc::c_longlong) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    f = tmp___35 as *mut I;
    tmp___36 = alloc(
        ((m + 1 as libc::c_longlong) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    s = tmp___36 as *mut I;
    i___3 = 0 as libc::c_int as I;
    _i___4 = m + 1 as libc::c_longlong;
    while i___3 < _i___4 {
        tmp___37 = 0 as libc::c_int as I;
        *s.offset(i___3 as isize) = tmp___37;
        *f.offset(i___3 as isize) = tmp___37;
        i___3 += 1;
    }
    i___4 = m;
    j = m + 1 as libc::c_longlong;
    *f.offset(i___4 as isize) = j;
    while i___4 > 0 as libc::c_longlong {
        while j <= m {
            flag = 0 as libc::c_int as I;
            c = *p.offset(*r.offset((i___4 - 1 as libc::c_longlong) as isize) as isize);
            d___0 = *p.offset(*r.offset((j - 1 as libc::c_longlong) as isize) as isize);
            if 63 as libc::c_int == c as libc::c_int {
                break;
            }
            if 63 as libc::c_int == d___0 as libc::c_int {
                break;
            }
            if c as libc::c_int == d___0 as libc::c_int {
                if 91 as libc::c_int != c as libc::c_int {
                    if 91 as libc::c_int != d___0 as libc::c_int {
                        break;
                    }
                }
            }
            if 91 as libc::c_int != c as libc::c_int {
                if 91 as libc::c_int == d___0 as libc::c_int {
                    tmp___39 = rangematch(
                        p
                            .offset(
                                *r.offset((j - 1 as libc::c_longlong) as isize) as isize,
                            )
                            .offset(1 as libc::c_int as isize),
                        c,
                        0 as S,
                    );
                    if !tmp___39.is_null() {
                        break;
                    }
                }
            }
            if 91 as libc::c_int == c as libc::c_int {
                if 91 as libc::c_int != d___0 as libc::c_int {
                    tmp___38 = rangematch(
                        p
                            .offset(
                                *r.offset((i___4 - 1 as libc::c_longlong) as isize) as isize,
                            )
                            .offset(1 as libc::c_int as isize),
                        d___0,
                        0 as S,
                    );
                    if !tmp___38.is_null() {
                        break;
                    }
                }
            }
            if 91 as libc::c_int == c as libc::c_int {
                if 91 as libc::c_int == d___0 as libc::c_int {
                    rangematch(
                        p
                            .offset(
                                *r.offset((i___4 - 1 as libc::c_longlong) as isize) as isize,
                            )
                            .offset(1 as libc::c_int as isize),
                        0 as libc::c_int as C,
                        v.as_mut_ptr(),
                    );
                    rangematch(
                        p
                            .offset(
                                *r.offset((j - 1 as libc::c_longlong) as isize) as isize,
                            )
                            .offset(1 as libc::c_int as isize),
                        0 as libc::c_int as C,
                        w___0.as_mut_ptr(),
                    );
                    i___5 = 0 as libc::c_int as I;
                    _i___5 = 256 as libc::c_int as I;
                    while i___5 < _i___5 {
                        if v[i___5 as usize] != 0 {
                            if w___0[i___5 as usize] != 0 {
                                flag = 1 as libc::c_int as I;
                                break;
                            }
                        }
                        i___5 += 1;
                    }
                    if flag != 0 {
                        break;
                    }
                }
            }
            if *s.offset(j as isize) == 0 as libc::c_longlong {
                *s.offset(j as isize) = j - i___4;
            }
            j = *f.offset(j as isize);
        }
        i___4 -= 1;
        j -= 1;
        *f.offset(i___4 as isize) = j;
    }
    j = *f.offset(0 as libc::c_int as isize);
    i___6 = 0 as libc::c_int as I;
    _i___6 = m;
    while i___6 < _i___6 {
        if *s.offset(i___6 as isize) == 0 as libc::c_longlong {
            *s.offset(i___6 as isize) = j;
        }
        if i___6 == j {
            j = *f.offset(j as isize);
        }
        i___6 += 1;
    }
    i___4 = 0 as libc::c_int as I;
    while i___4 <= n - m {
        if 4 as libc::c_longlong == (*b___1).t {
            while i___4 < n - m {
                tmp___40 = __ctype_b_loc();
                if *(*tmp___40)
                    .offset(*t.offset((i___4 + m) as isize) as libc::c_int as isize)
                    as libc::c_int & 8 as libc::c_int == 0
                {
                    if !(i___4 != 0) {
                        break;
                    }
                    tmp___41 = __ctype_b_loc();
                    if *(*tmp___41)
                        .offset(
                            *t.offset((i___4 - 1 as libc::c_longlong) as isize)
                                as libc::c_int as isize,
                        ) as libc::c_int & 8 as libc::c_int == 0
                    {
                        break;
                    }
                }
                i___4 += 1;
            }
            if i___4 == n - m {
                if i___4 != 0 {
                    tmp___42 = __ctype_b_loc();
                    if *(*tmp___42)
                        .offset(
                            *t.offset((i___4 - 1 as libc::c_longlong) as isize)
                                as libc::c_int as isize,
                        ) as libc::c_int & 8 as libc::c_int != 0
                    {
                        break;
                    }
                }
            }
        }
        j = m - 1 as libc::c_longlong;
        while j >= 0 as libc::c_longlong {
            c___0 = *p.offset(*r.offset(j as isize) as isize);
            if !(63 as libc::c_int == c___0 as libc::c_int) {
                if 91 as libc::c_int != c___0 as libc::c_int {
                    if c___0 as libc::c_int
                        != *t.offset((i___4 + j) as isize) as libc::c_int
                    {
                        break;
                    }
                }
                if 91 as libc::c_int == c___0 as libc::c_int {
                    tmp___43 = rangematch(
                        p
                            .offset(*r.offset(j as isize) as isize)
                            .offset(1 as libc::c_int as isize),
                        *t.offset((i___4 + j) as isize),
                        0 as S,
                    );
                    if tmp___43.is_null() {
                        break;
                    }
                }
            }
            j -= 1;
        }
        if j < 0 as libc::c_longlong {
            kap(&mut z___0, &mut i___4 as *mut I as V);
            i___4 += m;
        } else {
            if *s.offset((j + 1 as libc::c_longlong) as isize)
                > j - occ[*t.offset((i___4 + j) as isize) as I as usize]
            {
                tmp___44 = *s.offset((j + 1 as libc::c_longlong) as isize);
            } else {
                tmp___44 = j - occ[*t.offset((i___4 + j) as isize) as I as usize];
            }
            i___4 += tmp___44;
        }
    }
    free(r as *mut libc::c_void);
    free(f as *mut libc::c_void);
    free(s as *mut libc::c_void);
    return z___0;
}
unsafe extern "C" fn rangematch(mut p: S, mut t: C, mut r: S) -> S {
    let mut n: I = 0;
    let mut k: I = 0;
    let mut c: C = 0;
    let mut d___0: C = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    k = 0 as libc::c_int as I;
    n = (94 as libc::c_int == *p as libc::c_int) as libc::c_int as I;
    if n != 0 {
        p = p.offset(1);
    }
    if !r.is_null() {
        i = 0 as libc::c_int as I;
        _i___0 = 256 as libc::c_int as I;
        while i < _i___0 {
            *r.offset(i as isize) = n as C;
            i += 1;
        }
    }
    if 93 as libc::c_int == *p as libc::c_int {
        if 93 as libc::c_int == t as libc::c_int {
            k = 1 as libc::c_int as I;
        }
        if !r.is_null() {
            *r
                .offset(
                    ']' as i32 as UC as libc::c_int as isize,
                ) = (n == 0) as libc::c_int as C;
        }
        p = p.offset(1);
    }
    loop {
        tmp = p;
        p = p.offset(1);
        c = *tmp;
        if !(93 as libc::c_int != c as libc::c_int) {
            break;
        }
        if c == 0 {
            return 0 as S;
        }
        if 45 as libc::c_int == *p as libc::c_int {
            d___0 = *p.offset(1 as libc::c_int as isize);
            if d___0 != 0 {
                if 93 as libc::c_int != d___0 as libc::c_int {
                    p = p.offset(2 as libc::c_int as isize);
                    if d___0 == 0 {
                        return 0 as S;
                    }
                    if c as UC as libc::c_int <= t as UC as libc::c_int {
                        if t as UC as libc::c_int <= d___0 as UC as libc::c_int {
                            k = 1 as libc::c_int as I;
                        }
                    }
                    if !r.is_null() {
                        i___0 = 0 as libc::c_int as I;
                        _i___1 = (1 as libc::c_int + d___0 as UC as libc::c_int
                            - c as UC as libc::c_int) as I;
                        while i___0 < _i___1 {
                            *r
                                .offset(
                                    (i___0 + c as UC as I) as isize,
                                ) = (n == 0) as libc::c_int as C;
                            i___0 += 1;
                        }
                    }
                    continue;
                }
            }
        }
        if c as libc::c_int == t as libc::c_int {
            k = 1 as libc::c_int as I;
        }
        if !r.is_null() {
            *r.offset(c as UC as libc::c_int as isize) = (n == 0) as libc::c_int as C;
        }
    }
    if t != 0 {
        if k == n {
            tmp___0 = 0 as S;
        } else {
            tmp___0 = p;
        }
    } else {
        tmp___0 = p;
    }
    return tmp___0;
}
pub unsafe extern "C" fn Ireverse(mut x___0: K) {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut t: I = 0;
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n / 2 as libc::c_longlong;
    while i < _i___0 {
        t = *(((*x___0).k).as_mut_ptr() as *mut I)
            .offset(((*x___0).n - i - 1 as libc::c_longlong) as isize);
        *(((*x___0).k).as_mut_ptr() as *mut I)
            .offset(
                ((*x___0).n - i - 1 as libc::c_longlong) as isize,
            ) = *(((*x___0).k).as_mut_ptr() as *mut I).offset(i as isize);
        *(((*x___0).k).as_mut_ptr() as *mut I).offset(i as isize) = t;
        i += 1;
    }
}
pub unsafe extern "C" fn _vsx(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___2: *mut k0 = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___6: *mut k0 = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut a: I = 0;
    let mut b___1: I = 0;
    let mut c: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut a___0: I = 0;
    let mut n: I = 0;
    let mut s: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut d___0: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    if (1 as libc::c_longlong) < tmp___0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___1 = -(*x___0).t;
        } else {
            tmp___1 = (*x___0).t;
        }
        if 1 as libc::c_longlong != tmp___1 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    z = 0 as K;
    if 0 as libc::c_longlong == (*y).t {
        z = newK(0 as libc::c_int as I, (*y).n);
        if z.is_null() {
            return 0 as K;
        }
        i = 0 as libc::c_int as I;
        _i___0 = (*y).n;
        while i < _i___0 {
            tmp___2 = _vsx(x___0, *((*y).k).as_mut_ptr().offset(i as isize));
            let ref mut fresh99 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh99 = tmp___2;
            tmp___3 = OOM_CD(
                0 as libc::c_int as I,
                z,
                tmp___2,
                -(1 as libc::c_int) as V,
            );
            if tmp___3 == 0 {
                return 0 as K;
            }
            i += 1;
        }
    } else if -(1 as libc::c_longlong) == (*y).t {
        z = newK(0 as libc::c_int as I, (*y).n);
        tmp___4 = Ki(0 as libc::c_int as I);
        k = tmp___4;
        tmp___5 = OOM_CD(0 as libc::c_int as I, k, z, -(1 as libc::c_int) as V);
        if tmp___5 == 0 {
            return 0 as K;
        }
        i___0 = 0 as libc::c_int as I;
        _i___1 = (*y).n;
        while i___0 < _i___1 {
            *(((*k).k).as_mut_ptr()
                as *mut I) = *(((*y).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            tmp___6 = _vsx(x___0, k);
            let ref mut fresh100 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh100 = tmp___6;
            tmp___7 = OOM_CD(
                0 as libc::c_int as I,
                z,
                k,
                tmp___6,
                -(1 as libc::c_int) as V,
            );
            if tmp___7 == 0 {
                return 0 as K;
            }
            i___0 += 1;
        }
        cd(k);
        z = demote(z);
    } else if 1 as libc::c_longlong == (*x___0).t {
        if *(((*x___0).k).as_mut_ptr() as *mut I) < 2 as libc::c_longlong {
            tmp___8 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___8;
        }
        z = newK(-(1 as libc::c_int) as I, 0 as libc::c_int as I);
        if z.is_null() {
            return 0 as K;
        }
        a = *(((*x___0).k).as_mut_ptr() as *mut I);
        b___1 = *(((*y).k).as_mut_ptr() as *mut I);
        c = b___1 / a;
        loop {
            if (*z).n != 0 {
                if !(b___1 != c) {
                    break;
                }
            }
            kap(&mut z, &mut b___1 as *mut I as V);
            b___1 = c;
            c = b___1 / a;
        }
        i___1 = 0 as libc::c_int as I;
        _i___2 = (*z).n;
        while i___1 < _i___2 {
            let ref mut fresh101 = *(((*z).k).as_mut_ptr() as *mut I)
                .offset(i___1 as isize);
            *fresh101 %= a;
            i___1 += 1;
        }
        Ireverse(z);
    } else if -(1 as libc::c_longlong) == (*x___0).t {
        i___2 = 0 as libc::c_int as I;
        _i___3 = (*x___0).n;
        while i___2 < _i___3 {
            if *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___2 as isize)
                < 1 as libc::c_longlong
            {
                tmp___9 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                return tmp___9;
            }
            i___2 += 1;
        }
        z = newK(-(1 as libc::c_int) as I, (*x___0).n);
        if z.is_null() {
            return 0 as K;
        }
        a___0 = *(((*y).k).as_mut_ptr() as *mut I);
        n = (*z).n;
        if a___0 < 0 as libc::c_longlong {
            s = 1 as libc::c_int as I;
            i___3 = 0 as libc::c_int as I;
            _i___4 = (*x___0).n;
            while i___3 < _i___4 {
                s *= *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___3 as isize);
                i___3 += 1;
            }
            a___0 = s - -a___0 % s;
        }
        i___4 = 0 as libc::c_int as I;
        _i___5 = n;
        while i___4 < _i___5 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___4 as isize,
                ) = *(((*x___0).k).as_mut_ptr() as *mut I)
                .offset(((*x___0).n - 1 as libc::c_longlong - i___4) as isize);
            i___4 += 1;
        }
        if n != 0 {
            if *(((*z).k).as_mut_ptr() as *mut I) != 0 {
                *(((*z).k).as_mut_ptr()
                    as *mut I) = a___0 / *(((*z).k).as_mut_ptr() as *mut I);
            } else {
                *(((*z).k).as_mut_ptr() as *mut I) = 0 as libc::c_int as I;
            }
        }
        i___5 = 0 as libc::c_int as I;
        _i___6 = n - 1 as libc::c_longlong;
        while i___5 < _i___6 {
            d___0 = *(((*z).k).as_mut_ptr() as *mut I)
                .offset((i___5 + 1 as libc::c_longlong) as isize);
            if d___0 != 0 {
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        (i___5 + 1 as libc::c_longlong) as isize,
                    ) = *(((*z).k).as_mut_ptr() as *mut I).offset(i___5 as isize)
                    / d___0;
            } else {
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        (i___5 + 1 as libc::c_longlong) as isize,
                    ) = 0 as libc::c_int as I;
            }
            i___5 += 1;
        }
        i___6 = 0 as libc::c_int as I;
        _i___7 = n - 1 as libc::c_longlong;
        while i___6 < _i___7 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    (n - 1 as libc::c_longlong - i___6) as isize,
                ) = *(((*z).k).as_mut_ptr() as *mut I)
                .offset((n - 2 as libc::c_longlong - i___6) as isize)
                - *(((*z).k).as_mut_ptr() as *mut I)
                    .offset((n - 1 as libc::c_longlong - i___6) as isize)
                    * *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___6 as isize);
            i___6 += 1;
        }
        if n != 0 {
            *(((*z).k).as_mut_ptr()
                as *mut I) = a___0
                - *(((*z).k).as_mut_ptr() as *mut I)
                    * *(((*x___0).k).as_mut_ptr() as *mut I)
                        .offset(((*x___0).n - 1 as libc::c_longlong) as isize);
        }
        Ireverse(z);
        return z;
    }
    return z;
}
pub unsafe extern "C" fn _vs(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___2: *mut k0 = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___6: *mut k0 = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut a: I = 0;
    let mut b___1: I = 0;
    let mut c: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut a___0: I = 0;
    let mut n: I = 0;
    let mut s: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___11: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut d___0: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    if (1 as libc::c_longlong) < tmp___0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___1 = -(*x___0).t;
        } else {
            tmp___1 = (*x___0).t;
        }
        if 1 as libc::c_longlong != tmp___1 {
            tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    z = 0 as K;
    if 0 as libc::c_longlong == (*y).t {
        z = newK(0 as libc::c_int as I, (*y).n);
        if z.is_null() {
            return 0 as K;
        }
        i = 0 as libc::c_int as I;
        _i___0 = (*y).n;
        while i < _i___0 {
            tmp___2 = _vs(x___0, *((*y).k).as_mut_ptr().offset(i as isize));
            let ref mut fresh102 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh102 = tmp___2;
            tmp___3 = OOM_CD(
                0 as libc::c_int as I,
                z,
                tmp___2,
                -(1 as libc::c_int) as V,
            );
            if tmp___3 == 0 {
                return 0 as K;
            }
            i += 1;
        }
    } else if -(1 as libc::c_longlong) == (*y).t {
        z = newK(0 as libc::c_int as I, (*y).n);
        tmp___4 = Ki(0 as libc::c_int as I);
        k = tmp___4;
        tmp___5 = OOM_CD(0 as libc::c_int as I, k, z, -(1 as libc::c_int) as V);
        if tmp___5 == 0 {
            return 0 as K;
        }
        i___0 = 0 as libc::c_int as I;
        _i___1 = (*y).n;
        while i___0 < _i___1 {
            *(((*k).k).as_mut_ptr()
                as *mut I) = *(((*y).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            tmp___6 = _vs(x___0, k);
            let ref mut fresh103 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh103 = tmp___6;
            tmp___7 = OOM_CD(
                0 as libc::c_int as I,
                z,
                k,
                tmp___6,
                -(1 as libc::c_int) as V,
            );
            if tmp___7 == 0 {
                return 0 as K;
            }
            i___0 += 1;
        }
        cd(k);
        z = demote(z);
    } else if 1 as libc::c_longlong == (*x___0).t {
        if *(((*x___0).k).as_mut_ptr() as *mut I) < 2 as libc::c_longlong {
            tmp___8 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___8;
        }
        if *(((*y).k).as_mut_ptr() as *mut I) == 0 as libc::c_longlong {
            tmp___9 = X(b"!0\0" as *const u8 as *const libc::c_char as S);
            return tmp___9;
        }
        z = newK(-(1 as libc::c_int) as I, 0 as libc::c_int as I);
        if z.is_null() {
            return 0 as K;
        }
        a = *(((*x___0).k).as_mut_ptr() as *mut I);
        b___1 = *(((*y).k).as_mut_ptr() as *mut I);
        c = b___1 / a;
        loop {
            if (*z).n != 0 {
                if !(b___1 != c) {
                    break;
                }
            }
            kap(&mut z, &mut b___1 as *mut I as V);
            b___1 = c;
            c = b___1 / a;
        }
        i___1 = 0 as libc::c_int as I;
        _i___2 = (*z).n;
        while i___1 < _i___2 {
            let ref mut fresh104 = *(((*z).k).as_mut_ptr() as *mut I)
                .offset(i___1 as isize);
            *fresh104 %= a;
            i___1 += 1;
        }
        Ireverse(z);
    } else if -(1 as libc::c_longlong) == (*x___0).t {
        i___2 = 0 as libc::c_int as I;
        _i___3 = (*x___0).n;
        while i___2 < _i___3 {
            let mut current_block_91: u64;
            if i___2 == 0 {
                if *(((*x___0).k).as_mut_ptr() as *mut I) == 0 {
                    current_block_91 = 4104378020253397960;
                } else {
                    current_block_91 = 12027283704867122503;
                }
            } else {
                current_block_91 = 12027283704867122503;
            }
            match current_block_91 {
                12027283704867122503 => {
                    if *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___2 as isize)
                        < 1 as libc::c_longlong
                    {
                        tmp___10 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                        return tmp___10;
                    }
                }
                _ => {}
            }
            i___2 += 1;
        }
        z = newK(-(1 as libc::c_int) as I, (*x___0).n);
        if z.is_null() {
            return 0 as K;
        }
        a___0 = *(((*y).k).as_mut_ptr() as *mut I);
        n = (*z).n;
        if a___0 < 0 as libc::c_longlong {
            s = 1 as libc::c_int as I;
            i___3 = 0 as libc::c_int as I;
            _i___4 = (*x___0).n;
            while i___3 < _i___4 {
                if *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___3 as isize) != 0 {
                    tmp___11 = *(((*x___0).k).as_mut_ptr() as *mut I)
                        .offset(i___3 as isize);
                } else {
                    tmp___11 = -(1 as libc::c_int) as I;
                }
                s *= tmp___11;
                i___3 += 1;
            }
            a___0 = s - -a___0 % s;
        }
        i___4 = 0 as libc::c_int as I;
        _i___5 = n;
        while i___4 < _i___5 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___4 as isize,
                ) = *(((*x___0).k).as_mut_ptr() as *mut I)
                .offset(((*x___0).n - 1 as libc::c_longlong - i___4) as isize);
            i___4 += 1;
        }
        if n != 0 {
            if *(((*z).k).as_mut_ptr() as *mut I) != 0 {
                *(((*z).k).as_mut_ptr()
                    as *mut I) = a___0 / *(((*z).k).as_mut_ptr() as *mut I);
            } else {
                *(((*z).k).as_mut_ptr() as *mut I) = 0 as libc::c_int as I;
            }
        }
        i___5 = 0 as libc::c_int as I;
        _i___6 = n - 1 as libc::c_longlong;
        while i___5 < _i___6 {
            d___0 = *(((*z).k).as_mut_ptr() as *mut I)
                .offset((i___5 + 1 as libc::c_longlong) as isize);
            if d___0 != 0 {
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        (i___5 + 1 as libc::c_longlong) as isize,
                    ) = *(((*z).k).as_mut_ptr() as *mut I).offset(i___5 as isize)
                    / d___0;
            } else {
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        (i___5 + 1 as libc::c_longlong) as isize,
                    ) = 0 as libc::c_int as I;
            }
            i___5 += 1;
        }
        i___6 = 0 as libc::c_int as I;
        _i___7 = n - 1 as libc::c_longlong;
        while i___6 < _i___7 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    (n - 1 as libc::c_longlong - i___6) as isize,
                ) = *(((*z).k).as_mut_ptr() as *mut I)
                .offset((n - 2 as libc::c_longlong - i___6) as isize)
                - *(((*z).k).as_mut_ptr() as *mut I)
                    .offset((n - 1 as libc::c_longlong - i___6) as isize)
                    * *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___6 as isize);
            i___6 += 1;
        }
        if n != 0 {
            *(((*z).k).as_mut_ptr()
                as *mut I) = a___0
                - *(((*z).k).as_mut_ptr() as *mut I)
                    * *(((*x___0).k).as_mut_ptr() as *mut I)
                        .offset(((*x___0).n - 1 as libc::c_longlong) as isize);
        }
        Ireverse(z);
        return z;
    }
    return z;
}
pub unsafe extern "C" fn _t() -> K {
    let mut tmp: time_t = 0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = time(0 as *mut time_t);
    tmp___0 = Ki(tmp as I + k_epoch_offset);
    return tmp___0;
}
pub unsafe extern "C" fn _T() -> K {
    let mut t: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tr: time_t = 0;
    let mut u: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    gettimeofday(&mut t as *mut timeval, 0 as *mut libc::c_void);
    tr = t.tv_sec;
    gmtime_r(&mut tr as *mut time_t as *const time_t, &mut u as *mut tm);
    tmp = jdn_from_date(
        (1900 as libc::c_int + u.tm_year) as I,
        (1 as libc::c_int + u.tm_mon) as I,
        u.tm_mday as I,
    );
    tmp___0 = Kf(
        tmp as libc::c_double
            + ((u.tm_hour * 60 as libc::c_int * 60 as libc::c_int
                + u.tm_min * 60 as libc::c_int + u.tm_sec) as libc::c_double
                + t.tv_usec as libc::c_double / 1.0e6f64) / 86400.0f64,
    );
    return tmp___0;
}
pub unsafe extern "C" fn _n() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(NIL);
    return tmp;
}
pub unsafe extern "C" fn _h() -> K {
    let mut c: [C; 256] = [0; 256];
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___4: K = 0 as *mut k0;
    tmp___2 = gethostname(c.as_mut_ptr(), 256 as libc::c_int as size_t);
    if tmp___2 != 0 {
        tmp = __errno_location();
        tmp___0 = strerror(*tmp);
        tmp___1 = kerr(tmp___0 as cS);
        return tmp___1;
    }
    tmp___3 = sp(c.as_mut_ptr());
    tmp___4 = Ks(tmp___3);
    return tmp___4;
}
pub unsafe extern "C" fn _d() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = Ks(d_);
    return tmp;
}
pub unsafe extern "C" fn _v() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(KONA_GSET);
    return tmp;
}
pub unsafe extern "C" fn _i() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(KONA_IDX);
    return tmp;
}
pub unsafe extern "C" fn _f() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn _s() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = mstat();
    return tmp;
}
pub unsafe extern "C" fn _p() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(KONA_PORT);
    return tmp;
}
pub unsafe extern "C" fn _w() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(KONA_WHO);
    return tmp;
}
pub unsafe extern "C" fn _u() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
    return tmp;
}
pub unsafe extern "C" fn _a() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(KONA_ARGS);
    return tmp;
}
static mut x: K = 0 as *const k0 as K;
static mut d: S = b"2022-08-03\0" as *const u8 as *const libc::c_char as S;
pub unsafe extern "C" fn _k() -> K {
    let mut tmp: size_t = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    if x.is_null() {
        tmp = strlen(d as *const libc::c_char);
        x = newK(-(3 as libc::c_int) as I, tmp as I);
        tmp___0 = OOM_CD(0 as libc::c_int as I, x, -(1 as libc::c_int) as V);
        if tmp___0 == 0 {
            return 0 as K;
        }
        strcpy(
            ((*x).k).as_mut_ptr() as *mut C as *mut libc::c_char,
            d as *const libc::c_char,
        );
    }
    tmp___1 = ci(x);
    return tmp___1;
}
pub unsafe extern "C" fn _m() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
    return tmp;
}
pub unsafe extern "C" fn _c() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(KONA_CLIENT);
    return tmp;
}
unsafe extern "C" fn CIX(mut a: K, mut i: I, mut x___0: K) -> I {
    let mut at___0: I = 0;
    let mut t: I = 0;
    let mut r: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: libc::c_double = 0.;
    at___0 = (*a).t;
    t = (*x___0).t;
    r = 0 as libc::c_int as I;
    k = 0 as K;
    if at___0 == 0 {
        k = ci(*((*a).k).as_mut_ptr().offset(i as isize));
    } else {
        k = newK(-at___0, 1 as libc::c_int as I);
    }
    match (*k).t {
        1 => {
            *(((*k).k).as_mut_ptr()
                as *mut I) = *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize);
        }
        2 => {
            *(((*k).k).as_mut_ptr()
                as *mut F) = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
        }
        3 => {
            *(((*k).k).as_mut_ptr()
                as *mut C) = *(((*a).k).as_mut_ptr() as *mut C).offset(i as isize);
        }
        4 => {
            let ref mut fresh105 = *(((*k).k).as_mut_ptr() as *mut S);
            *fresh105 = *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize);
        }
        _ => {}
    }
    let mut current_block_54: u64;
    if 1 as libc::c_longlong == (*k).t {
        if 2 as libc::c_longlong == t {
            if 9223372036854775807 as libc::c_longlong
                == *(((*k).k).as_mut_ptr() as *mut I)
            {
                tmp___1 = 1 as libc::c_int as libc::c_double / 0.0f64;
            } else {
                if -(9223372036854775807 as libc::c_longlong)
                    == *(((*k).k).as_mut_ptr() as *mut I)
                {
                    tmp___0 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                } else {
                    if (-(0x7fffffffffffffff as libc::c_long)
                        - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                        == *(((*k).k).as_mut_ptr() as *mut I)
                    {
                        tmp = 0 as libc::c_int as libc::c_double / 0.0f64;
                    } else {
                        tmp = *(((*k).k).as_mut_ptr() as *mut I) as libc::c_double;
                    }
                    tmp___0 = tmp;
                }
                tmp___1 = tmp___0;
            }
            r = FC(tmp___1, *(((*x___0).k).as_mut_ptr() as *mut F));
            current_block_54 = 8151474771948790331;
        } else {
            current_block_54 = 12060532719390455784;
        }
    } else {
        current_block_54 = 12060532719390455784;
    }
    match current_block_54 {
        12060532719390455784 => {
            if 2 as libc::c_longlong == (*k).t {
                if 1 as libc::c_longlong == t {
                    if 9223372036854775807 as libc::c_longlong
                        == *(((*x___0).k).as_mut_ptr() as *mut I)
                    {
                        tmp___4 = 1 as libc::c_int as libc::c_double / 0.0f64;
                    } else {
                        if -(9223372036854775807 as libc::c_longlong)
                            == *(((*x___0).k).as_mut_ptr() as *mut I)
                        {
                            tmp___3 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                        } else {
                            if (-(0x7fffffffffffffff as libc::c_long)
                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                == *(((*x___0).k).as_mut_ptr() as *mut I)
                            {
                                tmp___2 = 0 as libc::c_int as libc::c_double / 0.0f64;
                            } else {
                                tmp___2 = *(((*x___0).k).as_mut_ptr() as *mut I)
                                    as libc::c_double;
                            }
                            tmp___3 = tmp___2;
                        }
                        tmp___4 = tmp___3;
                    }
                    r = FC(*(((*k).k).as_mut_ptr() as *mut F), tmp___4);
                } else {
                    r = KC(k, x___0);
                }
            } else {
                r = KC(k, x___0);
            }
        }
        _ => {}
    }
    if !k.is_null() {
        cd(k);
    }
    return r;
}
unsafe extern "C" fn binr(mut a: K, mut b___1: I, mut c: I, mut x___0: K) -> I {
    let mut i: I = 0;
    let mut r: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    i = b___1 + (c - b___1) / 2 as libc::c_longlong;
    tmp = CIX(a, i, x___0);
    r = tmp;
    if 0 as libc::c_longlong == r {
        if i > 0 as libc::c_longlong {
            tmp___0 = CIX(a, i - 1 as libc::c_longlong, x___0);
            if tmp___0 != 0 {
                return i
            } else {
                r = 1 as libc::c_int as I;
            }
        } else {
            return i
        }
    }
    if b___1 >= c {
        if -(1 as libc::c_longlong) == r {
            tmp___1 = 1 as libc::c_longlong + i;
        } else {
            tmp___1 = i;
        }
        return tmp___1;
    }
    if (0 as libc::c_longlong) < r {
        tmp___2 = binr(a, b___1, i - 1 as libc::c_longlong, x___0);
        tmp___4 = tmp___2;
    } else {
        tmp___3 = binr(a, i + 1 as libc::c_longlong, c, x___0);
        tmp___4 = tmp___3;
    }
    return tmp___4;
}
pub unsafe extern "C" fn RF() -> F {
    let mut tmp: libc::c_double = 0.;
    tmp = genrand64_real2();
    return tmp;
}
pub static mut k_epoch_offset: I = -(2051222400 as libc::c_long) as I;
pub unsafe extern "C" fn _dot_t() -> K {
    let mut t: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp: K = 0 as *mut k0;
    gettimeofday(&mut t as *mut timeval, 0 as *mut libc::c_void);
    tmp = Kf(k_epoch_offset as F + t.tv_sec as F + t.tv_usec as F / 1.0e6f64);
    return tmp;
}
unsafe extern "C" fn jdn_from_date(mut year: I, mut month: I, mut day: I) -> I {
    let mut a: I = 0;
    let mut y: I = 0;
    let mut m: I = 0;
    a = (14 as libc::c_longlong - month) / 12 as libc::c_longlong;
    y = year + 4800 as libc::c_longlong - a;
    m = month + 12 as libc::c_longlong * a - 3 as libc::c_longlong;
    return day
        + (153 as libc::c_longlong * m + 2 as libc::c_longlong) / 5 as libc::c_longlong
        + y * 365 as libc::c_longlong + y / 4 as libc::c_longlong
        - y / 100 as libc::c_longlong + y / 400 as libc::c_longlong
        - 32045 as libc::c_longlong - 2464329 as libc::c_longlong;
}
unsafe extern "C" fn date_from_jdn(mut j: I) -> I {
    let mut b___1: I = 0;
    let mut c: I = 0;
    let mut d___0: I = 0;
    let mut e: I = 0;
    let mut m: I = 0;
    let mut year: I = 0;
    let mut month: I = 0;
    let mut day: I = 0;
    let mut a: I = 0;
    a = j + 32044 as libc::c_longlong + 2464329 as libc::c_longlong;
    b___1 = (4 as libc::c_longlong * a + 3 as libc::c_longlong)
        / 146097 as libc::c_longlong;
    c = a - b___1 * 146097 as libc::c_longlong / 4 as libc::c_longlong;
    d___0 = (4 as libc::c_longlong * c + 3 as libc::c_longlong)
        / 1461 as libc::c_longlong;
    e = c - 1461 as libc::c_longlong * d___0 / 4 as libc::c_longlong;
    m = (5 as libc::c_longlong * e + 2 as libc::c_longlong) / 153 as libc::c_longlong;
    day = e
        - (153 as libc::c_longlong * m + 2 as libc::c_longlong) / 5 as libc::c_longlong
        + 1 as libc::c_longlong;
    month = m + 3 as libc::c_longlong
        - 12 as libc::c_longlong * (m / 10 as libc::c_longlong);
    year = b___1 * 100 as libc::c_longlong + d___0 - 4800 as libc::c_longlong
        + m / 10 as libc::c_longlong;
    return year * 10000 as libc::c_longlong + month * 100 as libc::c_longlong + day;
}
pub static mut IFP: [S; 3] = [0 as *const C as *mut C; 3];
pub static mut offsetSSR: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut offsetWhat: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut offsetAt: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut offsetDot: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut offsetColon: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut LS: S = 0 as *const C as *mut C;
pub static mut NIL: K = 0 as *const k0 as *mut k0;
pub static mut IPC_PORT: S = 0 as *const C as *mut C;
pub static mut HTTP_PORT: S = 0 as *const C as *mut C;
pub static mut d_: S = 0 as *const C as *mut C;
pub static mut SEED: I = 0;
pub static mut KTREE: K = 0 as *const k0 as *mut k0;
pub static mut SYMBOLS: N = 0 as *const Node as *mut Node;
pub static mut DT_END_OFFSET: L = 0;
pub static mut DT_ADVERB_OFFSET: L = 0;
pub static mut DT_VERB_OFFSET: L = 0;
pub static mut DT_SPECIAL_VERB_OFFSET: L = 0;
pub static mut offsetOver: L = 0;
pub static mut offsetScan: L = 0;
pub static mut offsetEach: L = 0;
pub static mut offsetEachright: L = 0;
pub static mut offsetEachleft: L = 0;
pub static mut offsetEachpair: L = 0;
pub static mut errmsg: [C; 256] = [0; 256];
pub static mut offsetJoin: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut offset3m: V = 0 as *const libc::c_void as *mut libc::c_void;
pub static mut HOST_IFACE: S = 0 as *const C as *mut C;
pub static mut stopDict: K = 0 as *const k0 as K;
pub static mut fStop: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn kerr(mut s: cS) -> K {
    let mut tmp: libc::c_int = 0;
    tmp = strcmp(s, b"(nil)\0" as *const u8 as *const libc::c_char);
    if tmp != 0 {
        fer = 2 as libc::c_int as I;
    }
    snprintf(
        errmsg.as_mut_ptr() as *mut libc::c_char,
        256 as libc::c_int as size_t,
        b"%s\0" as *const u8 as *const libc::c_char,
        s,
    );
    return 0 as K;
}
pub static mut PP: I = 7 as libc::c_int as I;
pub static mut PPMAX: I = 19 as libc::c_int as I;
pub static mut PPON: C = 1 as libc::c_int as C;
pub unsafe extern "C" fn maX(mut a: I, mut b___1: I) -> I {
    let mut tmp: I = 0;
    if a > b___1 {
        tmp = a;
    } else {
        tmp = b___1;
    }
    return tmp;
}
pub unsafe extern "C" fn miN(mut a: I, mut b___1: I) -> I {
    let mut tmp: I = 0;
    if a < b___1 {
        tmp = a;
    } else {
        tmp = b___1;
    }
    return tmp;
}
pub unsafe extern "C" fn X(mut s: S) -> K {
    let mut tmp: size_t = 0;
    let mut tmp___0: K = 0 as *mut k0;
    kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
    fnci = 0 as libc::c_int as I;
    tmp = strlen(s as *const libc::c_char);
    tmp___0 = XN(s, tmp as I);
    return tmp___0;
}
unsafe extern "C" fn XN(mut s: S, mut n: I) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = wd(s, n as libc::c_int);
    tmp___0 = ex(tmp);
    return tmp___0;
}
pub unsafe extern "C" fn KX(mut x___0: K) -> K {
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = CSK(x___0);
    tmp___0 = XN(tmp, (*x___0).n);
    return tmp___0;
}
pub unsafe extern "C" fn FF(mut f: F) -> F {
    let mut F___0: F = 0.;
    let mut tmp: libc::c_double = 0.;
    tmp = modf(f, &mut F___0);
    return tmp;
}
pub unsafe extern "C" fn simpleString(mut a: S) -> I {
    let mut n: I = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    tmp = strlen(a as *const libc::c_char);
    n = tmp as I;
    if n != 0 {
        tmp___0 = __ctype_b_loc();
        if *(*tmp___0).offset(*a as libc::c_int as isize) as libc::c_int
            & 2048 as libc::c_int != 0
        {
            return 0 as libc::c_int as I;
        }
    }
    if 1 as libc::c_longlong == n {
        if *a as libc::c_int == 46 as libc::c_int {
            return 0 as libc::c_int as I;
        }
    }
    if n > 1 as libc::c_longlong {
        if *a.offset((n - 1 as libc::c_longlong) as isize) as libc::c_int
            == 46 as libc::c_int
        {
            if *a.offset((n - 2 as libc::c_longlong) as isize) as libc::c_int
                == 46 as libc::c_int
            {
                return 0 as libc::c_int as I;
            }
        }
    }
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        tmp___1 = __ctype_b_loc();
        if *(*tmp___1).offset(*a.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & 8 as libc::c_int == 0
        {
            if *a.offset(i as isize) as libc::c_int != 95 as libc::c_int {
                if *a.offset(i as isize) as libc::c_int != 46 as libc::c_int {
                    return 0 as libc::c_int as I;
                }
            }
        }
        i += 1;
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = n - 1 as libc::c_longlong;
    while i___0 < _i___1 {
        if *a.offset(i___0 as isize) as libc::c_int == 46 as libc::c_int {
            tmp___2 = __ctype_b_loc();
            if *(*tmp___2)
                .offset(
                    *a.offset((i___0 + 1 as libc::c_longlong) as isize) as libc::c_int
                        as isize,
                ) as libc::c_int & 2048 as libc::c_int != 0
            {
                return 0 as libc::c_int as I;
            }
        }
        i___0 += 1;
    }
    i___1 = 0 as libc::c_int as I;
    _i___2 = n - 2 as libc::c_longlong;
    while i___1 < _i___2 {
        if *a.offset(i___1 as isize) as libc::c_int == 46 as libc::c_int {
            if *a.offset((i___1 + 1 as libc::c_longlong) as isize) as libc::c_int
                == 46 as libc::c_int
            {
                if *a.offset((i___1 + 2 as libc::c_longlong) as isize) as libc::c_int
                    == 46 as libc::c_int
                {
                    return 0 as libc::c_int as I;
                }
            }
        }
        i___1 += 1;
    }
    return 1 as libc::c_int as I;
}
pub unsafe extern "C" fn end() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn bk(mut p: V) -> I {
    return (p as L == DT_END_OFFSET) as libc::c_int as I;
}
pub static mut ac: [C; 4] = [
    '/' as i32 as C,
    '\\' as i32 as C,
    '\'' as i32 as C,
    '\u{0}' as i32 as C,
];
pub unsafe extern "C" fn over() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn scan() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn each() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn tr_st(mut x___0: K) -> K {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: K = 0 as *mut k0;
    tmp = strcmp(
        fBreak as *const libc::c_char,
        b"t\0" as *const u8 as *const libc::c_char,
    );
    if 0 as libc::c_int == tmp {
        show(x___0);
    }
    tmp___0 = strcmp(
        fBreak as *const libc::c_char,
        b"s\0" as *const u8 as *const libc::c_char,
    );
    if 0 as libc::c_int == tmp___0 {
        printf(b"stop\n\0" as *const u8 as *const libc::c_char);
        printf(b"%s\n\0" as *const u8 as *const libc::c_char, lineA);
        stopDict = ci(
            *(((*prnt).k).as_mut_ptr() as *mut V).offset(7 as libc::c_int as isize) as K,
        );
        fStop = 1 as libc::c_int as I;
        check();
        cd(stopDict);
        stopDict = 0 as K;
        fStop = 0 as libc::c_int as I;
    }
    tmp___1 = ci(x___0);
    return tmp___1;
}
pub unsafe extern "C" fn rtrn(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    fer = 1 as libc::c_int as I;
    tmp = ci(x___0);
    return tmp;
}
pub unsafe extern "C" fn eachright() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn eachleft() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn eachpair() -> K {
    return 0 as K;
}
pub unsafe extern "C" fn resume(mut x___0: K) -> K {
    return 0 as K;
}
pub static mut vc: [C; 21] = [
    '+' as i32 as C,
    '-' as i32 as C,
    '*' as i32 as C,
    '%' as i32 as C,
    '|' as i32 as C,
    '&' as i32 as C,
    '^' as i32 as C,
    '!' as i32 as C,
    '<' as i32 as C,
    '>' as i32 as C,
    '=' as i32 as C,
    '~' as i32 as C,
    '@' as i32 as C,
    '?' as i32 as C,
    '_' as i32 as C,
    ',' as i32 as C,
    '#' as i32 as C,
    '$' as i32 as C,
    '.' as i32 as C,
    ':' as i32 as C,
    '\u{0}' as i32 as C,
];
pub static mut IFS: [S; 3] = [
    b"x\0" as *const u8 as *const libc::c_char as S,
    b"y\0" as *const u8 as *const libc::c_char as S,
    b"z\0" as *const u8 as *const libc::c_char as S,
];
pub unsafe extern "C" fn stringHasChar(mut s: S, mut c: C) -> I {
    let mut i: I = 0;
    let mut tmp: I = 0;
    i = 0 as libc::c_int as I;
    while *s.offset(i as isize) != 0 {
        tmp = i;
        i += 1;
        if c as libc::c_int == *s.offset(tmp as isize) as libc::c_int {
            return 1 as libc::c_int as I;
        }
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn charpos(mut s: S, mut c: C) -> I {
    let mut i: I = 0;
    i = 0 as libc::c_int as I;
    while *s.offset(i as isize) != 0 {
        if !(c as libc::c_int != *s.offset(i as isize) as libc::c_int) {
            break;
        }
        i += 1;
    }
    return i;
}
pub unsafe extern "C" fn isCharVerb(mut c: C) -> I {
    let mut tmp: I = 0;
    tmp = stringHasChar(vc.as_mut_ptr(), c);
    return tmp;
}
pub unsafe extern "C" fn charsVerb(mut c: C) -> L {
    let mut tmp: I = 0;
    tmp = charpos(vc.as_mut_ptr(), c);
    return tmp;
}
pub unsafe extern "C" fn verbsChar(mut p: V) -> C {
    let mut tmp: libc::c_int = 0;
    if p as L >= DT_VERB_OFFSET {
        if (p as L) < DT_SPECIAL_VERB_OFFSET {
            tmp = vc[((p as L - DT_VERB_OFFSET) / 2 as libc::c_longlong) as usize]
                as libc::c_int;
        } else {
            tmp = '\u{0}' as i32;
        }
    } else {
        tmp = '\u{0}' as i32;
    }
    return tmp as C;
}
pub unsafe extern "C" fn adverbsChar(mut p: V) -> C {
    let mut tmp: libc::c_int = 0;
    if p as L >= DT_ADVERB_OFFSET {
        tmp = ac[((p as L - DT_ADVERB_OFFSET) % 3 as libc::c_longlong) as usize]
            as libc::c_int;
    } else {
        tmp = '\u{0}' as i32;
    }
    return tmp as C;
}
pub unsafe extern "C" fn charsAdverb(mut c: C) -> L {
    let mut tmp: I = 0;
    tmp = charpos(ac.as_mut_ptr(), c);
    return tmp;
}
pub unsafe extern "C" fn sva(mut p: V) -> I {
    let mut q: UI = 0;
    q = p as UI;
    if q < DT_SIZE as UI {
        return DT[q as usize].arity;
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn adverbClass(mut p: V) -> I {
    let mut q: UI = 0;
    q = p as UI;
    if q < DT_SIZE as UI {
        return DT[q as usize].adverbClass;
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn kdefClass(mut n: I) -> I {
    let mut tmp: libc::c_int = 0;
    if n == 98 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 101 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 107 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 108 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 111 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 112 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 113 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 114 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 115 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 117 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 121 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else if n == 123 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as I;
}
unsafe extern "C" fn specialValence(mut p: V) -> I {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if p as libc::c_ulong == offsetSSR as libc::c_ulong {
        tmp___0 = 3 as libc::c_int;
    } else if p as libc::c_ulong == offsetWhat as libc::c_ulong {
        tmp___0 = 3 as libc::c_int;
    } else {
        if p as libc::c_ulong == offsetAt as libc::c_ulong {
            tmp = 4 as libc::c_int;
        } else if p as libc::c_ulong == offsetDot as libc::c_ulong {
            tmp = 4 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
        tmp___0 = tmp;
    }
    return tmp___0 as I;
}
pub unsafe extern "C" fn valence(mut p: V) -> I {
    let mut current_block: u64;
    let mut a: I = 0;
    let mut i: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut v: K = 0 as *mut k0;
    let mut w___0: *mut V = 0 as *mut V;
    let mut t: I = 0;
    let mut b___1: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut k: *mut V = 0 as *mut V;
    let mut q: *mut V = 0 as *mut V;
    let mut j: I = 0;
    let mut s: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    a = specialValence(p);
    if a != 0 {
        a = a;
    } else {
        tmp = sva(p);
        a = tmp;
    }
    if a != 0 {
        return a;
    }
    tmp___0 = adverbClass(p);
    if tmp___0 != 0 {
        return 0 as libc::c_int as I;
    }
    v = *(p as *mut K);
    if v.is_null() {
        return 0 as libc::c_int as I
    } else {
        if (*v).t != 7 as libc::c_longlong {
            return 0 as libc::c_int as I;
        }
    }
    w___0 = ((*(*(((*v).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
        as K))
        .k)
        .as_mut_ptr() as *mut S as *mut V;
    t = (*v).n;
    b___1 = *(((*v).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize) as K;
    c = 0 as libc::c_int as I;
    if !b___1.is_null() {
        i___0 = 0 as libc::c_int as I;
        _i___0 = (*b___1).n;
        while i___0 < _i___0 {
            if !(*((*b___1).k).as_mut_ptr().offset(i___0 as isize)).is_null() {
                c += 1;
            }
            i___0 += 1;
        }
        return (*b___1).n - c;
    }
    if 1 as libc::c_longlong == t {
        i = (*(*(((*v).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
            as K))
            .n - 1 as libc::c_longlong;
        k = *(((*(*(((*v).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
            as K))
            .k)
            .as_mut_ptr() as *mut S as *mut V)
            .offset((i - 1 as libc::c_longlong) as isize) as *mut V;
        if k as L == offsetEachright {
            return 2 as libc::c_int as I
        } else {
            if k as L == offsetEachleft {
                return 2 as libc::c_int as I;
            }
        }
        if i > 1 as libc::c_longlong {
            if k as L == offsetEach {
                current_block = 7877091754914514782;
            } else {
                current_block = 4095794711493547479;
            }
        } else {
            current_block = 4095794711493547479;
        }
        match current_block {
            4095794711493547479 => {
                if !(k as L == offsetOver) {
                    if !(k as L == offsetScan) {
                        tmp___6 = adverbClass(k as V);
                        if tmp___6 != 0 {
                            return 2 as libc::c_int as I;
                        }
                        tmp___8 = sva(k as V);
                        if tmp___8 > 1 as libc::c_longlong {
                            if i > 1 as libc::c_longlong {
                                tmp___9 = VA(
                                    *(((*(*(((*v).k).as_mut_ptr() as *mut V)
                                        .offset(2 as libc::c_int as isize) as K))
                                        .k)
                                        .as_mut_ptr() as *mut S as *mut V)
                                        .offset((i - 2 as libc::c_longlong) as isize),
                                );
                                if tmp___9 == 0 {
                                    tmp___7 = valence(k as V);
                                    return tmp___7 - 1 as libc::c_longlong;
                                }
                            }
                        }
                        tmp___10 = valence(k as V);
                        return tmp___10;
                    }
                }
            }
            _ => {}
        }
        j = 0 as libc::c_int as I;
        loop {
            tmp___1 = j;
            j += 1;
            q = *(((*(*(((*v).k).as_mut_ptr() as *mut V)
                .offset(2 as libc::c_int as isize) as K))
                .k)
                .as_mut_ptr() as *mut S as *mut V)
                .offset((i - 2 as libc::c_longlong - tmp___1) as isize) as *mut V;
            if q as L == offsetEach {
                continue;
            }
            if q as L == offsetOver {
                continue;
            }
            if !(q as L == offsetScan) {
                break;
            }
        }
        s = sva(q as V);
        if s != 0 {
            tmp___3 = specialValence(q as V);
            if tmp___3 == 0 {
                if i - 2 as libc::c_longlong - j >= 0 as libc::c_longlong {
                    tmp___2 = 1 as libc::c_int;
                } else {
                    tmp___2 = 0 as libc::c_int;
                }
                return s - tmp___2 as I;
            }
        }
        if j < i - 2 as libc::c_longlong {
            tmp___4 = valence(q as V);
            return tmp___4 - 1 as libc::c_longlong;
        } else {
            tmp___5 = valence(q as V);
            return tmp___5;
        }
    } else {
        if 2 as libc::c_longlong == t {
            return *w___0.offset(0 as libc::c_int as isize) as L;
        }
        if 3 as libc::c_longlong == t {
            return (*(*(((*v).k).as_mut_ptr() as *mut V)
                .offset(4 as libc::c_int as isize) as K))
                .n;
        }
        return 0 as libc::c_int as I;
    };
}
pub unsafe extern "C" fn VA(mut p: V) -> I {
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = sva(p);
    if tmp != 0 {
        tmp___1 = 1 as libc::c_int;
    } else {
        tmp___0 = adverbClass(p);
        if tmp___0 != 0 {
            tmp___1 = 1 as libc::c_int;
        } else {
            tmp___1 = 0 as libc::c_int;
        }
    }
    return tmp___1 as I;
}
unsafe extern "C" fn isescape(mut c: UC) -> I {
    let mut tmp: libc::c_int = 0;
    if c as libc::c_int == 34 as libc::c_int {
        tmp = 1 as libc::c_int;
    } else if c as libc::c_int == 92 as libc::c_int {
        tmp = 1 as libc::c_int;
    } else if c as libc::c_int == 8 as libc::c_int {
        tmp = 1 as libc::c_int;
    } else if c as libc::c_int == 10 as libc::c_int {
        tmp = 1 as libc::c_int;
    } else if c as libc::c_int == 13 as libc::c_int {
        tmp = 1 as libc::c_int;
    } else if c as libc::c_int == 9 as libc::c_int {
        tmp = 1 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as I;
}
static mut b: [C; 512] = [0; 512];
unsafe extern "C" fn needspt0(mut f: F) -> I {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = f.is_nan() as i32;
    if tmp != 0 {
        return 0 as libc::c_int as I
    } else {
        if -(1 as libc::c_int as libc::c_double / 0.0f64) == f {
            return 0 as libc::c_int as I
        } else {
            if 1 as libc::c_int as libc::c_double / 0.0f64 == f {
                return 0 as libc::c_int as I;
            }
        }
    }
    snprintf(
        b.as_mut_ptr() as *mut libc::c_char,
        512 as libc::c_int as size_t,
        b"%.*g\0" as *const u8 as *const libc::c_char,
        PP as libc::c_int,
        f,
    );
    tmp___0 = stringHasChar(b.as_mut_ptr(), '.' as i32 as C);
    if tmp___0 != 0 {
        tmp___2 = 0 as libc::c_int;
    } else {
        tmp___1 = stringHasChar(b.as_mut_ptr(), 'e' as i32 as C);
        if tmp___1 != 0 {
            tmp___2 = 0 as libc::c_int;
        } else {
            tmp___2 = 1 as libc::c_int;
        }
    }
    return tmp___2 as I;
}
static mut b___0: [C; 512] = [0; 512];
unsafe extern "C" fn splitprint(
    mut u: V,
    mut s: *const libc::c_char,
    mut args_0: ...
) -> libc::c_int {
    let mut args___0: ::std::ffi::VaListImpl;
    let mut n: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: libc::c_int = 0;
    args___0 = args_0.clone();
    if u.is_null() {
        vprintf(s, args___0.as_va_list());
    } else {
        tmp = vsnprintf(
            b___0.as_mut_ptr() as *mut libc::c_char,
            512 as libc::c_int as size_t,
            s,
            args___0.as_va_list(),
        );
        n = tmp as I;
        tmp___0 = kapn(u as *mut K, b___0.as_mut_ptr() as V, n);
        if !tmp___0.is_null() {
            tmp___1 = 0 as libc::c_int;
        } else {
            tmp___1 = 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn printAtDepth(
    mut u: V,
    mut a: K,
    mut d___0: I,
    mut x___0: I,
    mut vdep: I,
    mut b___1: I,
) {
    let mut t: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut m: I = 0;
    let mut s: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut enclose: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut f: I = 0;
    let mut g: F = 0.;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut c: UC = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut ss: I = 0;
    let mut sl: I = 0;
    let mut str: S = 0 as *mut C;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___11: size_t = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: I = 0;
    let mut i___6: I = 0;
    let mut k: I = 0;
    let mut s___0: S = 0 as *mut C;
    let mut v: *mut V = 0 as *mut V;
    let mut p: *mut V = 0 as *mut V;
    let mut q: I = 0;
    let mut tmp___14: size_t = 0;
    let mut i___7: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___15: C = 0;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: C = 0;
    let mut tmp___18: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___19: *const libc::c_char = 0 as *const libc::c_char;
    if a.is_null() {
        return;
    }
    t = (*a).t;
    if x___0 != 0 {
        i = 0 as libc::c_int as I;
        _i___0 = d___0;
        while i < _i___0 {
            splitprint(u, b" \0" as *const u8 as *const libc::c_char);
            i += 1;
        }
    }
    if 5 as libc::c_longlong == t {
        splitprint(u, b".\0" as *const u8 as *const libc::c_char);
        d___0 += 1;
        t = 0 as libc::c_int as I;
    }
    if t <= 0 as libc::c_longlong {
        if (*a).n == 1 as libc::c_longlong {
            splitprint(u, b",\0" as *const u8 as *const libc::c_char);
        }
    }
    m = 0 as libc::c_int as I;
    if 0 as libc::c_longlong == t {
        if b___1 == 0 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*a).n;
            while i___0 < _i___1 {
                s = *((*a).k).as_mut_ptr().offset(i___0 as isize);
                if !s.is_null() {
                    if (*s).t <= 0 as libc::c_longlong {
                        if (*s).n != 0 {
                            m = 1 as libc::c_int as I;
                            break;
                        } else if -(3 as libc::c_longlong) == (*s).t {
                            m = 1 as libc::c_int as I;
                            break;
                        }
                    }
                }
                if !s.is_null() {
                    if (*s).t == 5 as libc::c_longlong {
                        m = 1 as libc::c_int as I;
                        break;
                    }
                }
                i___0 += 1;
            }
        }
    }
    let mut current_block_45: u64;
    if 0 as libc::c_longlong == t {
        if (*a).n != 1 as libc::c_longlong {
            tmp = 1 as libc::c_int;
            current_block_45 = 2606304779496145856;
        } else {
            current_block_45 = 3363862764112823842;
        }
    } else {
        current_block_45 = 3363862764112823842;
    }
    match current_block_45 {
        3363862764112823842 => {
            if t == 7 as libc::c_longlong {
                if vdep != 0 {
                    tmp = 1 as libc::c_int;
                } else {
                    tmp = 0 as libc::c_int;
                }
            } else {
                tmp = 0 as libc::c_int;
            }
        }
        _ => {}
    }
    enclose = tmp as I;
    if enclose != 0 {
        if b___1 != 0 {
            tmp___0 = b"[\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___0 = b"(\0" as *const u8 as *const libc::c_char;
        }
        splitprint(u, tmp___0);
    }
    if 0 as libc::c_longlong == t {
        i___1 = 0 as libc::c_int as I;
        _i___2 = (*a).n;
        while i___1 < _i___2 {
            printAtDepth(
                u,
                *((*a).k).as_mut_ptr().offset(i___1 as isize),
                d___0 + 1 as libc::c_longlong,
                i___1 * m,
                0 as libc::c_int as I,
                0 as libc::c_int as I,
            );
            if i___1 < _i___2 - 1 as libc::c_longlong {
                if m != 0 {
                    tmp___1 = b"\n\0" as *const u8 as *const libc::c_char;
                } else {
                    tmp___1 = b";\0" as *const u8 as *const libc::c_char;
                }
                tmp___2 = tmp___1;
            } else {
                tmp___2 = b"\0" as *const u8 as *const libc::c_char;
            }
            splitprint(u, tmp___2);
            i___1 += 1;
        }
    }
    if t < 0 as libc::c_longlong {
        tmp___3 = -t;
    } else {
        tmp___3 = t;
    }
    if 1 as libc::c_longlong == tmp___3 {
        if (*a).n == 0 {
            splitprint(u, b"!0\0" as *const u8 as *const libc::c_char);
        } else {
            i___2 = 0 as libc::c_int as I;
            _i___3 = (*a).n;
            while i___2 < _i___3 {
                f = *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
                if f
                    == (-(0x7fffffffffffffff as libc::c_long)
                        - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                {
                    splitprint(u, b"0N\0" as *const u8 as *const libc::c_char);
                } else if f == -(9223372036854775807 as libc::c_longlong) {
                    splitprint(u, b"-0I\0" as *const u8 as *const libc::c_char);
                } else if f == 9223372036854775807 as libc::c_longlong {
                    splitprint(u, b"0I\0" as *const u8 as *const libc::c_char);
                } else {
                    splitprint(u, b"%lld\0" as *const u8 as *const libc::c_char, f);
                }
                if i___2 < _i___3 - 1 as libc::c_longlong {
                    splitprint(u, b" \0" as *const u8 as *const libc::c_char);
                }
                i___2 += 1;
            }
        }
    }
    if t < 0 as libc::c_longlong {
        tmp___6 = -t;
    } else {
        tmp___6 = t;
    }
    if 2 as libc::c_longlong == tmp___6 {
        if (*a).n == 0 {
            splitprint(u, b"0#0.0\0" as *const u8 as *const libc::c_char);
        } else {
            i___3 = 0 as libc::c_int as I;
            _i___4 = (*a).n;
            while i___3 < _i___4 {
                g = *(((*a).k).as_mut_ptr() as *mut F).offset(i___3 as isize);
                tmp___4 = g.is_nan() as i32;
                if tmp___4 != 0 {
                    splitprint(u, b"0n\0" as *const u8 as *const libc::c_char);
                } else if g == -(1 as libc::c_int as libc::c_double / 0.0f64) {
                    splitprint(u, b"-0i\0" as *const u8 as *const libc::c_char);
                } else if g == 1 as libc::c_int as libc::c_double / 0.0f64 {
                    splitprint(u, b"0i\0" as *const u8 as *const libc::c_char);
                } else {
                    splitprint(
                        u,
                        b"%.*g\0" as *const u8 as *const libc::c_char,
                        PP as libc::c_int,
                        g,
                    );
                }
                if i___3 < _i___4 - 1 as libc::c_longlong {
                    splitprint(u, b" \0" as *const u8 as *const libc::c_char);
                } else {
                    tmp___5 = needspt0(g);
                    if tmp___5 != 0 {
                        splitprint(u, b".0\0" as *const u8 as *const libc::c_char);
                    }
                }
                i___3 += 1;
            }
        }
    }
    if t < 0 as libc::c_longlong {
        tmp___10 = -t;
    } else {
        tmp___10 = t;
    }
    if 3 as libc::c_longlong == tmp___10 {
        splitprint(u, b"\"\0" as *const u8 as *const libc::c_char);
        i___4 = 0 as libc::c_int as I;
        _i___5 = (*a).n;
        while i___4 < _i___5 {
            c = *(((*a).k).as_mut_ptr() as *mut C).offset(i___4 as isize) as UC;
            tmp___8 = __ctype_b_loc();
            let mut current_block_167: u64;
            if *(*tmp___8).offset(c as libc::c_int as isize) as libc::c_int
                & 16384 as libc::c_int != 0
            {
                tmp___9 = isescape(c);
                if tmp___9 != 0 {
                    current_block_167 = 2897225933592705563;
                } else {
                    splitprint(
                        u,
                        b"%c\0" as *const u8 as *const libc::c_char,
                        c as libc::c_int,
                    );
                    current_block_167 = 654039154479240366;
                }
            } else {
                current_block_167 = 2897225933592705563;
            }
            match current_block_167 {
                2897225933592705563 => {
                    tmp___7 = isescape(c);
                    if tmp___7 != 0 {
                        match c as libc::c_int {
                            34 => {
                                splitprint(
                                    u,
                                    b"\\\"\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            92 => {
                                splitprint(
                                    u,
                                    b"\\\\\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            8 => {
                                splitprint(u, b"\\b\0" as *const u8 as *const libc::c_char);
                            }
                            10 => {
                                splitprint(u, b"\\n\0" as *const u8 as *const libc::c_char);
                            }
                            13 => {
                                splitprint(u, b"\\r\0" as *const u8 as *const libc::c_char);
                            }
                            9 => {
                                splitprint(u, b"\\t\0" as *const u8 as *const libc::c_char);
                            }
                            _ => {}
                        }
                    } else {
                        splitprint(
                            u,
                            b"\\%.3o\0" as *const u8 as *const libc::c_char,
                            c as libc::c_int,
                        );
                    }
                }
                _ => {}
            }
            i___4 += 1;
        }
        splitprint(u, b"\"\0" as *const u8 as *const libc::c_char);
    }
    if t < 0 as libc::c_longlong {
        tmp___13 = -t;
    } else {
        tmp___13 = t;
    }
    if 4 as libc::c_longlong == tmp___13 {
        if (*a).n == 0 {
            splitprint(u, b"0#`\0" as *const u8 as *const libc::c_char);
        } else {
            ss = 0 as libc::c_int as I;
            i___5 = 0 as libc::c_int as I;
            _i___6 = (*a).n;
            while i___5 < _i___6 {
                str = *(((*a).k).as_mut_ptr() as *mut S).offset(i___5 as isize);
                let mut current_block_232: u64;
                if (str as L as libc::c_double) < -2e9f64 {
                    current_block_232 = 15604263779281913770;
                } else if DT_SIZE < str as L {
                    current_block_232 = 15604263779281913770;
                } else {
                    if -(4 as libc::c_longlong) == t {
                        if (str as L) < 0 as libc::c_longlong {
                            printf(b"\n%p \0" as *const u8 as *const libc::c_char, str);
                        } else {
                            printf(b"%p \0" as *const u8 as *const libc::c_char, str);
                            if str.is_null() {
                                printf(b" \0" as *const u8 as *const libc::c_char);
                            } else if i___5 < (*a).n {
                                if (*(((*a).k).as_mut_ptr() as *mut S)
                                    .offset((i___5 + 1 as libc::c_longlong) as isize)
                                    as libc::c_ulong) < DT_SIZE as S as libc::c_ulong
                                {
                                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                                }
                            }
                        }
                        if (str as L) < 0 as libc::c_longlong {
                            printf(
                                b" %p \0" as *const u8 as *const libc::c_char,
                                *(str as *mut V),
                            );
                            if (0 as libc::c_longlong) < *(str as *mut V) as L {
                                if !((*(str as *mut V) as L) < DT_SIZE) {
                                    printf(
                                        b"%p\n\0" as *const u8 as *const libc::c_char,
                                        *(str as *mut K),
                                    );
                                }
                            } else {
                                printf(
                                    b"%p\n\0" as *const u8 as *const libc::c_char,
                                    *(str as *mut K),
                                );
                            }
                        }
                    }
                    current_block_232 = 2613201931278571586;
                }
                match current_block_232 {
                    15604263779281913770 => {
                        tmp___11 = strlen(str as *const libc::c_char);
                        sl = tmp___11 as I;
                        ss = simpleString(str);
                        splitprint(u, b"`\0" as *const u8 as *const libc::c_char);
                        if ss == 0 {
                            splitprint(u, b"\"\0" as *const u8 as *const libc::c_char);
                        }
                        j = 0 as libc::c_int as I;
                        _j = sl;
                        while j < _j {
                            splitprint(
                                u,
                                b"%c\0" as *const u8 as *const libc::c_char,
                                *str.offset(j as isize) as libc::c_int,
                            );
                            j += 1;
                        }
                        if ss == 0 {
                            splitprint(u, b"\"\0" as *const u8 as *const libc::c_char);
                        }
                        if i___5 < _i___6 - 1 as libc::c_longlong {
                            tmp___12 = b" \0" as *const u8 as *const libc::c_char;
                        } else {
                            tmp___12 = b"\0" as *const u8 as *const libc::c_char;
                        }
                        splitprint(u, tmp___12);
                    }
                    _ => {}
                }
                i___5 += 1;
            }
        }
    }
    if 7 as libc::c_longlong == t {
        if 1 as libc::c_longlong == (*a).n {
            v = ((*(*(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
                as K))
                .k)
                .as_mut_ptr() as *mut S as *mut V;
            i___6 = 0 as libc::c_int as I;
            loop {
                p = *v.offset(i___6 as isize) as *mut V;
                if p.is_null() {
                    break;
                }
                q = p as L;
                let mut current_block_282: u64;
                if q < DT_SIZE {
                    if q >= DT_SPECIAL_VERB_OFFSET {
                        s___0 = DT[q as usize].text;
                        tmp___14 = strlen(s___0 as *const libc::c_char);
                        k = tmp___14 as I;
                        i___7 = 0 as libc::c_int as I;
                        _i___7 = k;
                        while i___7 < _i___7 {
                            splitprint(
                                u,
                                b"%c\0" as *const u8 as *const libc::c_char,
                                *s___0.offset(i___7 as isize) as libc::c_int,
                            );
                            i___7 += 1;
                        }
                        if *s___0.offset((k - 1 as libc::c_longlong) as isize)
                            as libc::c_int == 58 as libc::c_int
                        {
                            if 1 as libc::c_longlong == DT[q as usize].arity {
                                splitprint(
                                    u,
                                    b"%c\0" as *const u8 as *const libc::c_char,
                                    ':' as i32,
                                );
                            }
                        }
                        current_block_282 = 15605369199999130895;
                    } else {
                        current_block_282 = 1228130617790001341;
                    }
                } else {
                    current_block_282 = 1228130617790001341;
                }
                match current_block_282 {
                    1228130617790001341 => {
                        k = sva(p as V);
                        if k != 0 {
                            tmp___15 = verbsChar(p as V);
                            if 2 as libc::c_longlong == k {
                                tmp___16 = b"%c\0" as *const u8 as *const libc::c_char;
                            } else {
                                tmp___16 = b"%c:\0" as *const u8 as *const libc::c_char;
                            }
                            splitprint(u, tmp___16, tmp___15 as libc::c_int);
                        } else {
                            k = adverbClass(p as V);
                            if k != 0 {
                                tmp___17 = adverbsChar(p as V);
                                if 1 as libc::c_longlong == k {
                                    tmp___18 = b"%c\0" as *const u8 as *const libc::c_char;
                                } else {
                                    tmp___18 = b"%c:\0" as *const u8 as *const libc::c_char;
                                }
                                splitprint(u, tmp___18, tmp___17 as libc::c_int);
                            } else {
                                printAtDepth(
                                    u,
                                    *(p as *mut K),
                                    d___0 + 1 as libc::c_longlong,
                                    0 as libc::c_int as I,
                                    1 as libc::c_longlong + vdep,
                                    0 as libc::c_int as I,
                                );
                            }
                        }
                    }
                    _ => {}
                }
                i___6 += 1;
            }
        } else if 2 as libc::c_longlong == (*a).n {
            return
        } else {
            if 3 as libc::c_longlong == (*a).n {
                splitprint(
                    u,
                    b"{%s}\0" as *const u8 as *const libc::c_char,
                    ((*(*(((*a).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut C,
                );
            }
        }
        if !(*(((*a).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize))
            .is_null()
        {
            printAtDepth(
                u,
                *(((*a).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize)
                    as K,
                d___0 + 1 as libc::c_longlong,
                0 as libc::c_int as I,
                0 as libc::c_int as I,
                1 as libc::c_int as I,
            );
        }
    }
    if enclose != 0 {
        if b___1 != 0 {
            tmp___19 = b"]\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___19 = b")\0" as *const u8 as *const libc::c_char;
        }
        splitprint(u, tmp___19);
    }
}
pub unsafe extern "C" fn show(mut a: K) -> K {
    printAtDepth(
        0 as V,
        a,
        0 as libc::c_int as I,
        0 as libc::c_int as I,
        0 as libc::c_int as I,
        0 as libc::c_int as I,
    );
    if !a.is_null() {
        if (*a).t != 6 as libc::c_longlong {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
    return a;
}
pub unsafe extern "C" fn minus_eachpair(mut x___0: K, mut y: K) -> K {
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut u: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    if (*y).n < 2 as libc::c_longlong {
        return 0 as K
    } else {
        if (*y).t == 0 {
            return 0 as K
        } else {
            if (*y).t < 0 as libc::c_longlong {
                tmp = -(*y).t;
            } else {
                tmp = (*y).t;
            }
            if tmp > 2 as libc::c_longlong {
                return 0 as K;
            }
        }
    }
    tmp___0 = newK((*y).t, (*y).n - 1 as libc::c_longlong);
    z = tmp___0;
    if -(2 as libc::c_longlong) == (*y).t {
        i = 0 as libc::c_int as I;
        _i___0 = (*y).n - 1 as libc::c_longlong;
        while i < _i___0 {
            *(((*z).k).as_mut_ptr() as *mut F)
                .offset(
                    i as isize,
                ) = *(((*y).k).as_mut_ptr() as *mut F)
                .offset((i + 1 as libc::c_longlong) as isize)
                - *(((*y).k).as_mut_ptr() as *mut F).offset(i as isize);
            i += 1;
        }
    } else if -(1 as libc::c_longlong) == (*y).t {
        i___0 = 0 as libc::c_int as I;
        _i___1 = (*y).n - 1 as libc::c_longlong;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___0 as isize,
                ) = *(((*y).k).as_mut_ptr() as *mut I)
                .offset((i___0 + 1 as libc::c_longlong) as isize)
                - *(((*y).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            i___0 += 1;
        }
    }
    if !x___0.is_null() {
        u = enlist(x___0);
        tmp___1 = OOM_CD(0 as libc::c_int as I, u, z, -(1 as libc::c_int) as V);
        if tmp___1 == 0 {
            return 0 as K;
        }
        v = join(u, z);
        cd(u);
        cd(z);
        return v;
    }
    return z;
}
pub unsafe extern "C" fn plus_scan(mut x___0: K, mut y: K) -> K {
    let mut tmp: I = 0;
    let mut t: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut n: I = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    let mut j: I = 0;
    let mut tmp___10: F = 0.;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: F = 0.;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___12: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    if !x___0.is_null() {
        if (*x___0).t != 1 as libc::c_longlong {
            if (*x___0).t != 2 as libc::c_longlong {
                return 0 as K;
            }
        }
    }
    if (*y).n < 2 as libc::c_longlong {
        return 0 as K
    } else {
        if (*y).t == 0 {
            return 0 as K
        } else {
            if (*y).t < 0 as libc::c_longlong {
                tmp = -(*y).t;
            } else {
                tmp = (*y).t;
            }
            if tmp > 2 as libc::c_longlong {
                return 0 as K;
            }
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    t = -tmp___0;
    if !x___0.is_null() {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___6 = -(*x___0).t;
        } else {
            tmp___6 = (*x___0).t;
        }
        if t < 0 as libc::c_longlong {
            tmp___7 = -t;
        } else {
            tmp___7 = t;
        }
        if tmp___6 > tmp___7 {
            if (*x___0).t < 0 as libc::c_longlong {
                tmp___3 = -(*x___0).t;
            } else {
                tmp___3 = (*x___0).t;
            }
            tmp___5 = tmp___3;
        } else {
            if t < 0 as libc::c_longlong {
                tmp___4 = -t;
            } else {
                tmp___4 = t;
            }
            tmp___5 = tmp___4;
        }
        t = -tmp___5;
    }
    if !x___0.is_null() {
        tmp___8 = 1 as libc::c_int;
    } else {
        tmp___8 = 0 as libc::c_int;
    }
    n = (*y).n + tmp___8 as I;
    if x___0.is_null() {
        tmp___9 = rc(y);
        if 1 as libc::c_longlong == tmp___9 {
            if (*y).t == t {
                z = ci(y);
            } else if ::std::mem::size_of::<I>() as libc::c_ulong
                    == ::std::mem::size_of::<F>() as libc::c_ulong
                {
                z = ci(y);
            } else {
                z = newK(t, n);
            }
        } else {
            z = newK(t, n);
        }
    } else {
        z = newK(t, n);
    }
    if z.is_null() {
        return 0 as K;
    }
    j = 0 as libc::c_int as I;
    if !x___0.is_null() {
        j = 1 as libc::c_int as I;
        let mut current_block_93: u64;
        if -(2 as libc::c_longlong) == t {
            if 2 as libc::c_longlong == (*x___0).t {
                *(((*z).k).as_mut_ptr()
                    as *mut F) = *(((*x___0).k).as_mut_ptr() as *mut F);
                current_block_93 = 2750570471926810434;
            } else {
                current_block_93 = 1242899383349638679;
            }
        } else {
            current_block_93 = 1242899383349638679;
        }
        match current_block_93 {
            1242899383349638679 => {
                let mut current_block_92: u64;
                if -(2 as libc::c_longlong) == t {
                    if 1 as libc::c_longlong == (*x___0).t {
                        *(((*z).k).as_mut_ptr()
                            as *mut F) = *(((*x___0).k).as_mut_ptr() as *mut I) as F;
                        current_block_92 = 1209030638129645089;
                    } else {
                        current_block_92 = 10828618519824053727;
                    }
                } else {
                    current_block_92 = 10828618519824053727;
                }
                match current_block_92 {
                    10828618519824053727 => {
                        if -(1 as libc::c_longlong) == t {
                            if 1 as libc::c_longlong == (*x___0).t {
                                *(((*z).k).as_mut_ptr()
                                    as *mut I) = *(((*x___0).k).as_mut_ptr() as *mut I);
                            }
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }
    let mut current_block_139: u64;
    if -(2 as libc::c_longlong) == t {
        if -(2 as libc::c_longlong) == (*y).t {
            if j != 0 {
                tmp___10 = *(((*z).k).as_mut_ptr() as *mut F);
            } else {
                tmp___10 = 0 as libc::c_int as F;
            }
            *(((*z).k).as_mut_ptr() as *mut F)
                .offset(j as isize) = *(((*y).k).as_mut_ptr() as *mut F) + tmp___10;
            i = 0 as libc::c_int as I;
            _i___0 = (*y).n - 1 as libc::c_longlong;
            while i < _i___0 {
                *(((*z).k).as_mut_ptr() as *mut F)
                    .offset(
                        (i + j + 1 as libc::c_longlong) as isize,
                    ) = *(((*z).k).as_mut_ptr() as *mut F).offset((i + j) as isize)
                    + *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize);
                i += 1;
            }
            current_block_139 = 1966075811433896587;
        } else {
            current_block_139 = 14625113807810813553;
        }
    } else {
        current_block_139 = 14625113807810813553;
    }
    match current_block_139 {
        14625113807810813553 => {
            let mut current_block_138: u64;
            if -(2 as libc::c_longlong) == t {
                if -(1 as libc::c_longlong) == (*y).t {
                    if j != 0 {
                        tmp___11 = *(((*z).k).as_mut_ptr() as *mut F);
                    } else {
                        tmp___11 = 0 as libc::c_int as F;
                    }
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            j as isize,
                        ) = *(((*y).k).as_mut_ptr() as *mut I) as F + tmp___11;
                    i___0 = 0 as libc::c_int as I;
                    _i___1 = (*y).n - 1 as libc::c_longlong;
                    while i___0 < _i___1 {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                (i___0 + j + 1 as libc::c_longlong) as isize,
                            ) = *(((*z).k).as_mut_ptr() as *mut F)
                            .offset((i___0 + j) as isize)
                            + *(((*y).k).as_mut_ptr() as *mut I)
                                .offset((i___0 + 1 as libc::c_longlong) as isize) as F;
                        i___0 += 1;
                    }
                    current_block_138 = 17212496701767205014;
                } else {
                    current_block_138 = 1311461387238090569;
                }
            } else {
                current_block_138 = 1311461387238090569;
            }
            match current_block_138 {
                1311461387238090569 => {
                    if -(1 as libc::c_longlong) == t {
                        if -(1 as libc::c_longlong) == (*y).t {
                            if j != 0 {
                                tmp___12 = *(((*z).k).as_mut_ptr() as *mut I);
                            } else {
                                tmp___12 = 0 as libc::c_int as I;
                            }
                            *(((*z).k).as_mut_ptr() as *mut I)
                                .offset(
                                    j as isize,
                                ) = *(((*y).k).as_mut_ptr() as *mut I) + tmp___12;
                            i___1 = 0 as libc::c_int as I;
                            _i___2 = (*y).n - 1 as libc::c_longlong;
                            while i___1 < _i___2 {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(
                                        (i___1 + j + 1 as libc::c_longlong) as isize,
                                    ) = *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset((i___1 + j) as isize)
                                    + *(((*y).k).as_mut_ptr() as *mut I)
                                        .offset((i___1 + 1 as libc::c_longlong) as isize);
                                i___1 += 1;
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn plus_over(mut x___0: K, mut y: K) -> K {
    let mut accI: I = 0;
    let mut accF: F = 0.;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    accI = 0 as libc::c_int as I;
    accF = 0 as libc::c_int as F;
    if (*y).t == 0 {
        if (*y).n != 0 {
            return 0 as K;
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp = -(*y).t;
    } else {
        tmp = (*y).t;
    }
    if tmp > 2 as libc::c_longlong {
        return 0 as K
    } else {
        if !x___0.is_null() {
            if (*x___0).t != 1 as libc::c_longlong {
                if (*x___0).t != 2 as libc::c_longlong {
                    return 0 as K;
                }
            }
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    match tmp___0 {
        2 => {
            if (*y).n != 0 {
                accF = *(((*y).k).as_mut_ptr() as *mut F);
            }
            i = 0 as libc::c_int as I;
            _i___0 = (*y).n - 1 as libc::c_longlong;
            while i < _i___0 {
                accF
                    += *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize);
                i += 1;
            }
            z = Kf(accF);
        }
        _ => {
            if (*y).n != 0 {
                accI = *(((*y).k).as_mut_ptr() as *mut I);
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*y).n - 1 as libc::c_longlong;
            while i___0 < _i___1 {
                accI
                    += *(((*y).k).as_mut_ptr() as *mut I)
                        .offset((i___0 + 1 as libc::c_longlong) as isize);
                i___0 += 1;
            }
            z = Ki(accI);
        }
    }
    if z.is_null() {
        return 0 as K;
    }
    if !x___0.is_null() {
        r = plus(x___0, z);
        cd(z);
        z = r;
    }
    return z;
}
pub unsafe extern "C" fn times_over(mut x___0: K, mut y: K) -> K {
    let mut accI: I = 0;
    let mut accF: F = 0.;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    accI = 1 as libc::c_int as I;
    accF = 1 as libc::c_int as F;
    if (*y).t == 0 {
        if (*y).n != 0 {
            return 0 as K;
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp = -(*y).t;
    } else {
        tmp = (*y).t;
    }
    if tmp > 2 as libc::c_longlong {
        return 0 as K
    } else {
        if !x___0.is_null() {
            if (*x___0).t != 1 as libc::c_longlong {
                if (*x___0).t != 2 as libc::c_longlong {
                    return 0 as K;
                }
            }
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    match tmp___0 {
        2 => {
            if (*y).n != 0 {
                accF = *(((*y).k).as_mut_ptr() as *mut F);
            }
            i = 0 as libc::c_int as I;
            _i___0 = (*y).n - 1 as libc::c_longlong;
            while i < _i___0 {
                accF
                    *= *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize);
                i += 1;
            }
            z = Kf(accF);
        }
        _ => {
            if (*y).n != 0 {
                accI = *(((*y).k).as_mut_ptr() as *mut I);
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*y).n - 1 as libc::c_longlong;
            while i___0 < _i___1 {
                accI
                    *= *(((*y).k).as_mut_ptr() as *mut I)
                        .offset((i___0 + 1 as libc::c_longlong) as isize);
                i___0 += 1;
            }
            z = Ki(accI);
        }
    }
    if z.is_null() {
        return 0 as K;
    }
    if !x___0.is_null() {
        r = times(x___0, z);
        cd(z);
        z = r;
    }
    return z;
}
pub unsafe extern "C" fn max_or_over(mut x___0: K, mut y: K) -> K {
    let mut accI: I = 0;
    let mut accF: F = 0.;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    accI = 0 as libc::c_int as I;
    accF = -(1 as libc::c_int as libc::c_double / 0.0f64);
    if (*y).t == 0 {
        if (*y).n != 0 {
            return 0 as K;
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp = -(*y).t;
    } else {
        tmp = (*y).t;
    }
    if tmp > 2 as libc::c_longlong {
        return 0 as K
    } else {
        if !x___0.is_null() {
            if (*x___0).t != 1 as libc::c_longlong {
                if (*x___0).t != 2 as libc::c_longlong {
                    return 0 as K;
                }
            }
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    match tmp___0 {
        2 => {
            if (*y).n != 0 {
                accF = *(((*y).k).as_mut_ptr() as *mut F);
            }
            i = 0 as libc::c_int as I;
            _i___0 = (*y).n - 1 as libc::c_longlong;
            while i < _i___0 {
                if accF
                    > *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize)
                {
                    accF = accF;
                } else {
                    accF = *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize);
                }
                i += 1;
            }
            z = Kf(accF);
        }
        _ => {
            if (*y).n != 0 {
                accI = *(((*y).k).as_mut_ptr() as *mut I);
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*y).n - 1 as libc::c_longlong;
            while i___0 < _i___1 {
                if accI
                    > *(((*y).k).as_mut_ptr() as *mut I)
                        .offset((i___0 + 1 as libc::c_longlong) as isize)
                {
                    accI = accI;
                } else {
                    accI = *(((*y).k).as_mut_ptr() as *mut I)
                        .offset((i___0 + 1 as libc::c_longlong) as isize);
                }
                i___0 += 1;
            }
            z = Ki(accI);
        }
    }
    if z.is_null() {
        return 0 as K;
    }
    if !x___0.is_null() {
        r = max_or(x___0, z);
        cd(z);
        z = r;
    }
    return z;
}
pub unsafe extern "C" fn min_and_over(mut x___0: K, mut y: K) -> K {
    let mut accI: I = 0;
    let mut accF: F = 0.;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    accI = 1 as libc::c_int as I;
    accF = 1 as libc::c_int as libc::c_double / 0.0f64;
    if (*y).t == 0 {
        if (*y).n != 0 {
            return 0 as K;
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp = -(*y).t;
    } else {
        tmp = (*y).t;
    }
    if tmp > 2 as libc::c_longlong {
        return 0 as K
    } else {
        if !x___0.is_null() {
            if (*x___0).t != 1 as libc::c_longlong {
                if (*x___0).t != 2 as libc::c_longlong {
                    return 0 as K;
                }
            }
        }
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___0 = -(*y).t;
    } else {
        tmp___0 = (*y).t;
    }
    match tmp___0 {
        2 => {
            if (*y).n != 0 {
                accF = *(((*y).k).as_mut_ptr() as *mut F);
            }
            i = 0 as libc::c_int as I;
            _i___0 = (*y).n - 1 as libc::c_longlong;
            while i < _i___0 {
                if accF
                    < *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize)
                {
                    accF = accF;
                } else {
                    accF = *(((*y).k).as_mut_ptr() as *mut F)
                        .offset((i + 1 as libc::c_longlong) as isize);
                }
                i += 1;
            }
            z = Kf(accF);
        }
        _ => {
            if (*y).n != 0 {
                accI = *(((*y).k).as_mut_ptr() as *mut I);
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*y).n - 1 as libc::c_longlong;
            while i___0 < _i___1 {
                if accI
                    < *(((*y).k).as_mut_ptr() as *mut I)
                        .offset((i___0 + 1 as libc::c_longlong) as isize)
                {
                    accI = accI;
                } else {
                    accI = *(((*y).k).as_mut_ptr() as *mut I)
                        .offset((i___0 + 1 as libc::c_longlong) as isize);
                }
                i___0 += 1;
            }
            z = Ki(accI);
        }
    }
    if z.is_null() {
        return 0 as K;
    }
    if !x___0.is_null() {
        r = min_and(x___0, z);
        cd(z);
        z = r;
    }
    return z;
}
pub unsafe extern "C" fn join_over(mut x___0: K, mut y: K) -> K {
    let mut i: I = 0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    j = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    while i < (*y).n {
        j += (**((*y).k).as_mut_ptr().offset(i as isize)).n;
        i += 1;
    }
    tmp = newK(0 as libc::c_int as I, j);
    z = tmp;
    if z.is_null() {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    j = 0 as libc::c_int as I;
    while j < (*y).n {
        k = 0 as libc::c_int as I;
        while k < (**((*y).k).as_mut_ptr().offset(j as isize)).n {
            let ref mut fresh106 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh106 = ci(
                *((**((*y).k).as_mut_ptr().offset(j as isize)).k)
                    .as_mut_ptr()
                    .offset(k as isize),
            );
            i += 1;
            k += 1;
        }
        j += 1;
    }
    return z;
}
pub static mut DT: [TR; 130] = unsafe {
    [
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(end as unsafe extern "C" fn() -> K)),
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 1 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(over as unsafe extern "C" fn() -> K)),
                text: b"/\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 1 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(scan as unsafe extern "C" fn() -> K)),
                text: b"\\\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 1 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(each as unsafe extern "C" fn() -> K)),
                text: b"'\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 2 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(eachright as unsafe extern "C" fn() -> K)),
                text: b"/:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 2 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(eachleft as unsafe extern "C" fn() -> K)),
                text: b"\\:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 2 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(eachpair as unsafe extern "C" fn() -> K)),
                text: b"':\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 0 as libc::c_int as I,
                func: 0 as *const libc::c_void as V,
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(flip as unsafe extern "C" fn(K) -> K)),
                text: b"+\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(plus as unsafe extern "C" fn(K, K) -> K)),
                text: b"+\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(plus_over as unsafe extern "C" fn(K, K) -> K)),
                        verb_scan: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(plus_scan as unsafe extern "C" fn(K, K) -> K)),
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(negate as unsafe extern "C" fn(K) -> K)),
                text: b"-\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(minus as unsafe extern "C" fn(K, K) -> K)),
                text: b"-\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as V,
                        verb_eachpair: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(minus_eachpair as unsafe extern "C" fn(K, K) -> K)),
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(first as unsafe extern "C" fn(K) -> K)),
                text: b"*\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(times as unsafe extern "C" fn(K, K) -> K)),
                text: b"*\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(times_over as unsafe extern "C" fn(K, K) -> K)),
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(reciprocal as unsafe extern "C" fn(K) -> K)),
                text: b"%%\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(divide as unsafe extern "C" fn(K, K) -> K)),
                text: b"%%\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(reverse as unsafe extern "C" fn(K) -> K)),
                text: b"|\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(max_or as unsafe extern "C" fn(K, K) -> K)),
                text: b"|\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(max_or_over as unsafe extern "C" fn(K, K) -> K)),
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(where_0 as unsafe extern "C" fn(K) -> K)),
                text: b"&\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(min_and as unsafe extern "C" fn(K, K) -> K)),
                text: b"&\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(min_and_over as unsafe extern "C" fn(K, K) -> K)),
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(shape as unsafe extern "C" fn(K) -> K)),
                text: b"^\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(power as unsafe extern "C" fn(K, K) -> K)),
                text: b"^\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(enumerate as unsafe extern "C" fn(K) -> K)),
                text: b"!\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(rotate_mod as unsafe extern "C" fn(K, K) -> K)),
                text: b"!\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(grade_up as unsafe extern "C" fn(K) -> K)),
                text: b"<\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(less as unsafe extern "C" fn(K, K) -> K)),
                text: b"<\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(grade_down as unsafe extern "C" fn(K) -> K)),
                text: b">\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(more as unsafe extern "C" fn(K, K) -> K)),
                text: b">\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(group as unsafe extern "C" fn(K) -> K)),
                text: b"=\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(equals as unsafe extern "C" fn(K, K) -> K)),
                text: b"=\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(not_attribute as unsafe extern "C" fn(K) -> K)),
                text: b"~\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(match_0 as unsafe extern "C" fn(K, K) -> K)),
                text: b"~\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(atom as unsafe extern "C" fn(K) -> K)),
                text: b"@\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(at as unsafe extern "C" fn(K, K) -> K)),
                text: b"@\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(range as unsafe extern "C" fn(K) -> K)),
                text: b"?\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(what as unsafe extern "C" fn(K, K) -> K)),
                text: b"?\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(floor_verb as unsafe extern "C" fn(K) -> K)),
                text: b"_\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(drop_cut as unsafe extern "C" fn(K, K) -> K)),
                text: b"_\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(enlist as unsafe extern "C" fn(K) -> K)),
                text: b",\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(join as unsafe extern "C" fn(K, K) -> K)),
                text: b",\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: ::std::mem::transmute::<
                            Option::<unsafe extern "C" fn(K, K) -> K>,
                            V,
                        >(Some(join_over as unsafe extern "C" fn(K, K) -> K)),
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(count as unsafe extern "C" fn(K) -> K)),
                text: b"#\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(take_reshape as unsafe extern "C" fn(K, K) -> K)),
                text: b"#\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(format as unsafe extern "C" fn(K) -> K)),
                text: b"$\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(dollar as unsafe extern "C" fn(K, K) -> K)),
                text: b"$\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(dot_monadic as unsafe extern "C" fn(K) -> K)),
                text: b".\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(dot as unsafe extern "C" fn(K, K) -> K)),
                text: b".\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(colon_monadic as unsafe extern "C" fn(K) -> K)),
                text: b":\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(colon_dyadic as unsafe extern "C" fn(K, K) -> K)),
                text: b":\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_0m as unsafe extern "C" fn(K) -> K)),
                text: b"0:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_0d as unsafe extern "C" fn(K, K) -> K)),
                text: b"0:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_1m as unsafe extern "C" fn(K) -> K)),
                text: b"1:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_1d as unsafe extern "C" fn(K, K) -> K)),
                text: b"1:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_2m as unsafe extern "C" fn(K) -> K)),
                text: b"2:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_2d as unsafe extern "C" fn(K, K) -> K)),
                text: b"2:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_3m as unsafe extern "C" fn(K) -> K)),
                text: b"3:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_3d as unsafe extern "C" fn(K, K) -> K)),
                text: b"3:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_4m as unsafe extern "C" fn(K) -> K)),
                text: b"4:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_4d as unsafe extern "C" fn(K, K) -> K)),
                text: b"4:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_5m as unsafe extern "C" fn(K) -> K)),
                text: b"5:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_5d as unsafe extern "C" fn(K, K) -> K)),
                text: b"5:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_6m as unsafe extern "C" fn(K) -> K)),
                text: b"6:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_6d as unsafe extern "C" fn(K, K) -> K)),
                text: b"6:\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_acos as unsafe extern "C" fn(K) -> K)),
                text: b"_acos\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_asin as unsafe extern "C" fn(K) -> K)),
                text: b"_asin\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_atan as unsafe extern "C" fn(K) -> K)),
                text: b"_atan\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_ceil as unsafe extern "C" fn(K) -> K)),
                text: b"_ceil\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_cos as unsafe extern "C" fn(K) -> K)),
                text: b"_cos\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_cosh as unsafe extern "C" fn(K) -> K)),
                text: b"_cosh\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_exp as unsafe extern "C" fn(K) -> K)),
                text: b"_exp\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_floor as unsafe extern "C" fn(K) -> K)),
                text: b"_floor\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_log as unsafe extern "C" fn(K) -> K)),
                text: b"_log\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_sin as unsafe extern "C" fn(K) -> K)),
                text: b"_sin\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_sinh as unsafe extern "C" fn(K) -> K)),
                text: b"_sinh\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_sqr as unsafe extern "C" fn(K) -> K)),
                text: b"_sqr\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_sqrt as unsafe extern "C" fn(K) -> K)),
                text: b"_sqrt\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_tan as unsafe extern "C" fn(K) -> K)),
                text: b"_tan\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_tanh as unsafe extern "C" fn(K) -> K)),
                text: b"_tanh\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_abs as unsafe extern "C" fn(K) -> K)),
                text: b"_abs\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_bd as unsafe extern "C" fn(K) -> K)),
                text: b"_bd\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_ceiling as unsafe extern "C" fn(K) -> K)),
                text: b"_ceiling\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_ci as unsafe extern "C" fn(K) -> K)),
                text: b"_ci\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_db as unsafe extern "C" fn(K) -> K)),
                text: b"_db\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_dj as unsafe extern "C" fn(K) -> K)),
                text: b"_dj\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_kona_exit as unsafe extern "C" fn(K) -> K)),
                text: b"_exit\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_getenv as unsafe extern "C" fn(K) -> K)),
                text: b"_getenv\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_gtime as unsafe extern "C" fn(K) -> K)),
                text: b"_gtime\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_host as unsafe extern "C" fn(K) -> K)),
                text: b"_host\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_ic as unsafe extern "C" fn(K) -> K)),
                text: b"_ic\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_inv as unsafe extern "C" fn(K) -> K)),
                text: b"_inv\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_jd as unsafe extern "C" fn(K) -> K)),
                text: b"_jd\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_lt as unsafe extern "C" fn(K) -> K)),
                text: b"_lt\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_ltime as unsafe extern "C" fn(K) -> K)),
                text: b"_ltime\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_size as unsafe extern "C" fn(K) -> K)),
                text: b"_size\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_bin as unsafe extern "C" fn(K, K) -> K)),
                text: b"_bin\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_binl as unsafe extern "C" fn(K, K) -> K)),
                text: b"_binl\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_di as unsafe extern "C" fn(K, K) -> K)),
                text: b"_di\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_dot as unsafe extern "C" fn(K, K) -> K)),
                text: b"_dot\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_draw as unsafe extern "C" fn(K, K) -> K)),
                text: b"_draw\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_dv as unsafe extern "C" fn(K, K) -> K)),
                text: b"_dv\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_dvl as unsafe extern "C" fn(K, K) -> K)),
                text: b"_dvl\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_hat as unsafe extern "C" fn(K, K) -> K)),
                text: b"_hat\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_in as unsafe extern "C" fn(K, K) -> K)),
                text: b"_in\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_lin as unsafe extern "C" fn(K, K) -> K)),
                text: b"_lin\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_lsq as unsafe extern "C" fn(K, K) -> K)),
                text: b"_lsq\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_mul as unsafe extern "C" fn(K, K) -> K)),
                text: b"_mul\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_setenv as unsafe extern "C" fn(K, K) -> K)),
                text: b"_setenv\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_sm as unsafe extern "C" fn(K, K) -> K)),
                text: b"_sm\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_ss as unsafe extern "C" fn(K, K) -> K)),
                text: b"_ss\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_sv as unsafe extern "C" fn(K, K) -> K)),
                text: b"_sv\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_vsx as unsafe extern "C" fn(K, K) -> K)),
                text: b"_vsx\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 3 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K, K) -> K>,
                    V,
                >(Some(_ssr as unsafe extern "C" fn(K, K, K) -> K)),
                text: b"_ssr\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(tr_st as unsafe extern "C" fn(K) -> K)),
                text: b" \\\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(rtrn as unsafe extern "C" fn(K) -> K)),
                text: b":\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 2 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                    V,
                >(Some(_vs as unsafe extern "C" fn(K, K) -> K)),
                text: b"_vs\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(_hash as unsafe extern "C" fn(K) -> K)),
                text: b"_hash\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: 0 as libc::c_int as I,
                arity: 1 as libc::c_int as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(K) -> K>,
                    V,
                >(Some(resume as unsafe extern "C" fn(K) -> K)),
                text: b":\0" as *const u8 as *const libc::c_char as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
        {
            let mut init = tr {
                adverbClass: -(1 as libc::c_int) as I,
                arity: -(1 as libc::c_int) as I,
                func: ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> K>,
                    V,
                >(Some(TABLE_END as unsafe extern "C" fn() -> K)),
                text: 0 as *const C as S,
                alt_funcs: {
                    let mut init = af {
                        verb_over: 0 as *const libc::c_void as V,
                        verb_scan: 0 as *const libc::c_void as *mut libc::c_void,
                        verb_eachpair: 0 as *const libc::c_void as *mut libc::c_void,
                    };
                    init
                },
            };
            init
        },
    ]
};
pub unsafe extern "C" fn TABLE_END() -> K {
    return 0 as K;
}
pub static mut DT_SIZE: L = 0 as libc::c_int as L;
pub unsafe extern "C" fn DT_OFFSET(mut v: V) -> L {
    let mut i: I = 0;
    i = 0 as libc::c_int as I;
    while v as libc::c_ulong != DT[i as usize].func as libc::c_ulong {
        i += 1;
    }
    return i;
}
pub static mut kreci: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn finally() {
    nfinish();
}
pub static mut KFIXED: K = 0 as *const k0 as *mut k0;
pub static mut master: fd_set = fd_set { __fds_bits: [0; 16] };
pub static mut KONA_GSET: K = 0 as *const k0 as K;
pub static mut KONA_IDX: K = 0 as *const k0 as K;
pub static mut interrupted: libc::c_int = 0 as libc::c_int;
pub unsafe extern "C" fn oerr() -> I {
    let mut tmp: libc::c_int = 0;
    tmp = printf(
        b"%s %s\n\0" as *const u8 as *const libc::c_char,
        errmsg.as_mut_ptr(),
        b"error\0" as *const u8 as *const libc::c_char,
    );
    return tmp as I;
}
pub static mut feci: I = 0 as libc::c_int as I;
pub static mut scrLim: I = 0 as libc::c_int as I;
pub static mut fCheck: I = 0 as libc::c_int as I;
static mut ofCheck: I = 0 as libc::c_int as I;
pub static mut fCmplt: I = 0 as libc::c_int as I;
pub static mut fbr: I = 0 as libc::c_int as I;
static mut flc: I = 0 as libc::c_int as I;
static mut lineC: [C; 100] = [0; 100];
static mut ofnc: [C; 2] = [' ' as i32 as C, '\u{0}' as i32 as C];
static mut ocr: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn prompt(mut n: I) -> I {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        printf(b">\0" as *const u8 as *const libc::c_char);
        i += 1;
    }
    printf(b"  \0" as *const u8 as *const libc::c_char);
    fflush(stdout);
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn wds(mut a: *mut K, mut f: *mut FILE) -> I {
    let mut tmp: I = 0;
    tmp = wds_(a, f, 0 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn wds_(mut a: *mut K, mut f: *mut FILE, mut l: I) -> I {
    let mut current_block: u64;
    let mut s: S = 0 as *mut C;
    let mut t: S = 0 as *mut C;
    let mut b___1: I = 0;
    let mut c: I = 0;
    let mut m: I = 0;
    let mut n: I = 0;
    let mut v: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut p: PDA = 0 as *mut Pda;
    let mut o: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    s = 0 as S;
    t = 0 as S;
    b___1 = 0 as libc::c_int as I;
    c = 0 as libc::c_int as I;
    m = 0 as libc::c_int as I;
    n = 0 as libc::c_int as I;
    v = 0 as libc::c_int as I;
    z = 0 as K;
    p = 0 as PDA;
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    if tmp___0 != 0 {
        if f as libc::c_ulong == stdin as libc::c_ulong {
            tmp___1 = 1 as libc::c_int;
        } else {
            tmp___1 = 0 as libc::c_int;
        }
    } else {
        tmp___1 = 0 as libc::c_int;
    }
    o = tmp___1 as I;
    c = getline_(&mut s, &mut n, f);
    if !(-(1 as libc::c_longlong) == c) {
        appender(&mut t, &mut m, s, n);
        loop {
            v = complete(t, m, &mut p, 0 as *mut I);
            if !(1 as libc::c_longlong == v) {
                current_block = 1538046216550696469;
                break;
            }
            b___1 = parsedepth(p);
            if o != 0 {
                prompt(b___1 + l);
            }
            c = getline_(&mut s, &mut n, f);
            if -(1 as libc::c_longlong) == c {
                current_block = 9708080356267364331;
                break;
            }
            appender(&mut t, &mut m, s, n);
        }
        match current_block {
            9708080356267364331 => {}
            _ => {
                match v {
                    2 => {
                        tmp___2 = kerr(
                            b"unmatched\0" as *const u8 as *const libc::c_char,
                        );
                        show(tmp___2);
                    }
                    3 => {
                        tmp___3 = kerr(b"nest\0" as *const u8 as *const libc::c_char);
                        show(tmp___3);
                    }
                    _ => {
                        z = newK(-(3 as libc::c_int) as I, m - 1 as libc::c_longlong);
                        strncpy(
                            ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_char,
                            t as *const libc::c_char,
                            (m - 1 as libc::c_longlong) as size_t,
                        );
                    }
                }
            }
        }
    }
    free(s as *mut libc::c_void);
    free(t as *mut libc::c_void);
    if !p.is_null() {
        pdafree(p);
    }
    let mut current_block_48: u64;
    if v != 0 {
        current_block_48 = 9689545886245804819;
    } else if c == -(1 as libc::c_longlong) {
        current_block_48 = 9689545886245804819;
    } else {
        *a = z;
        current_block_48 = 17747245473264231573;
    }
    match current_block_48 {
        9689545886245804819 => {
            if !z.is_null() {
                cd(z);
                *a = 0 as K;
            } else {
                *a = z;
            }
        }
        _ => {}
    }
    if v != 0 {
        tmp___4 = -v;
    } else {
        tmp___4 = c;
    }
    return tmp___4;
}
pub static mut KONA_ARGS: K = 0 as *const k0 as *mut k0;
static mut port: [C; 65] = [0; 65];
unsafe extern "C" fn multihomeini(mut x___0: *mut S) {
    let mut s: S = 0 as *mut C;
    let mut p: S = 0 as *mut C;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut h: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    s = *x___0;
    if s.is_null() {
        return;
    }
    tmp = strchr(s as *const libc::c_char, ':' as i32);
    p = tmp;
    if p.is_null() {
        return;
    }
    strcpy(
        port.as_mut_ptr() as *mut libc::c_char,
        p.offset(1 as libc::c_int as isize) as *const libc::c_char,
    );
    HOST_IFACE = spn(s, p.offset_from(s) as libc::c_long as I);
    *x___0 = port.as_mut_ptr();
    tmp___0 = Ks(HOST_IFACE);
    h = tmp___0;
    cd(KONA_CLIENT);
    KONA_CLIENT = _host(h);
    cd(h);
}
pub unsafe extern "C" fn args(mut n: libc::c_int, mut v: *mut S) -> I {
    let mut a: K = 0 as *mut k0;
    let mut k: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut len: I = 0;
    let mut b___1: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_long = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut S = 0 as *mut S;
    let mut h: S = 0 as *mut C;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    b___1 = 1 as libc::c_int as I;
    KONA_ARGS = newK(0 as libc::c_int as I, n as I);
    if KONA_ARGS.is_null() {
        return 0 as libc::c_int as I;
    }
    i = 0 as libc::c_int as I;
    _i___0 = n as I;
    while i < _i___0 {
        tmp = strlen(*v.offset(i as isize) as *const libc::c_char);
        len = tmp as I;
        a = newK(-(3 as libc::c_int) as I, len);
        if a.is_null() {
            cd(KONA_ARGS);
            return 0 as libc::c_int as I;
        }
        strncpy(
            ((*a).k).as_mut_ptr() as *mut C as *mut libc::c_char,
            *v.offset(i as isize) as *const libc::c_char,
            len as size_t,
        );
        let ref mut fresh107 = *((*KONA_ARGS).k).as_mut_ptr().offset(i as isize);
        *fresh107 = a;
        i += 1;
    }
    loop {
        tmp___2 = getopt(
            n,
            v as *const *mut libc::c_char,
            b":b:h:i:e:x:\0" as *const u8 as *const libc::c_char,
        );
        c = tmp___2 as I;
        if !(-(1 as libc::c_longlong) != c) {
            break;
        }
        match c {
            104 => {
                if !IPC_PORT.is_null() {
                    printf(
                        b"-i accepted, cannot also have -h\n\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    HTTP_PORT = optarg;
                }
            }
            105 => {
                if !HTTP_PORT.is_null() {
                    printf(
                        b"-h accepted, cannot also have -i\n\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    IPC_PORT = optarg;
                    tmp___0 = atol(IPC_PORT as *const libc::c_char);
                    *(((*KONA_PORT).k).as_mut_ptr() as *mut I) = tmp___0 as I;
                }
            }
            98 => {
                b___1 = 0 as libc::c_int as I;
            }
            101 => {
                tmp___1 = X(optarg);
                cd(tmp___1);
                exit(0 as libc::c_int);
            }
            120 => {
                k = X(optarg);
                printAtDepth(
                    0 as V,
                    k,
                    0 as libc::c_int as I,
                    0 as libc::c_int as I,
                    0 as libc::c_int as I,
                    0 as libc::c_int as I,
                );
                printf(b"\n\0" as *const u8 as *const libc::c_char);
                cd(k);
                exit(0 as libc::c_int);
            }
            58 | 63 => {
                printf(b"%c\nabort\0" as *const u8 as *const libc::c_char, optopt);
                exit(0 as libc::c_int);
            }
            _ => {}
        }
    }
    if b___1 != 0 {
        boilerplate();
    }
    if !IPC_PORT.is_null() {
        tmp___3 = &mut IPC_PORT;
    } else {
        tmp___3 = &mut HTTP_PORT;
    }
    multihomeini(tmp___3);
    tmp___4 = getenv(b"KINIT\0" as *const u8 as *const libc::c_char);
    h = tmp___4;
    if !h.is_null() {
        load(h);
    }
    while optind < n {
        tmp___5 = optind;
        optind += 1;
        load(*v.offset(tmp___5 as isize));
    }
    prompt(0 as libc::c_int as I);
    return 0 as libc::c_int as I;
}
pub static mut execute_mutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
    __data: __pthread_mutex_s {
        __lock: 0,
        __count: 0,
        __owner: 0,
        __nusers: 0,
        __kind: 0,
        __spins: 0,
        __elision: 0,
        __list: __pthread_list_t {
            __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
        },
    },
};
pub static mut khome: [C; 4097] = [0; 4097];
unsafe extern "C" fn khinit() {
    let mut n: I = 0;
    let mut h: S = 0 as *mut C;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    khome[0 as libc::c_int as usize] = 0 as libc::c_int as C;
    h = getenv(b"KHOME\0" as *const u8 as *const libc::c_char);
    if !h.is_null() {
        tmp = strlen(h as *const libc::c_char);
        n = tmp as I;
        if n + 1 as libc::c_longlong > 4096 as libc::c_longlong {
            return;
        }
        strcpy(khome.as_mut_ptr() as *mut libc::c_char, h as *const libc::c_char);
        strcpy(
            khome.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
            b"/\0" as *const u8 as *const libc::c_char,
        );
    } else {
        h = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
        if !h.is_null() {
            tmp___0 = strlen(h as *const libc::c_char);
            n = tmp___0 as I;
            if n + 3 as libc::c_longlong > 4096 as libc::c_longlong {
                return;
            }
            strcpy(khome.as_mut_ptr() as *mut libc::c_char, h as *const libc::c_char);
            strcpy(
                khome.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
                b"/k/\0" as *const u8 as *const libc::c_char,
            );
        }
    };
}
pub unsafe extern "C" fn kinit() -> I {
    let mut tmp: libc::c_long = 0;
    let mut mta: pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144 {
        __size: [0; 4],
    };
    let mut tmp___0: L = 0;
    let mut tmp___1: L = 0;
    let mut tmp___2: L = 0;
    let mut tmp___3: L = 0;
    let mut tmp___4: L = 0;
    let mut tmp___5: L = 0;
    let mut tmp___6: L = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___7: S = 0 as *mut C;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: S = 0 as *mut C;
    let mut tmp___11: K = 0 as *mut k0;
    atexit(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> ()>,
            Option::<unsafe extern "C" fn() -> ()>,
        >(Some(finally as unsafe extern "C" fn() -> ())),
    );
    tmp = sysconf(30 as libc::c_int);
    PG = tmp as I;
    if PG & PG - 1 as libc::c_longlong != 0 {
        fprintf(
            stderr,
            b"%s:%u: %s\n\0" as *const u8 as *const libc::c_char,
            b"src/kc.c\0" as *const u8 as *const libc::c_char,
            128 as libc::c_int,
            b"Pagesize not power of 2\0" as *const u8 as *const libc::c_char,
        );
        exit(1 as libc::c_int);
    }
    ninit();
    pthread_mutexattr_init(&mut mta);
    pthread_mutexattr_settype(&mut mta, 1 as libc::c_int);
    pthread_mutex_init(
        &mut execute_mutex,
        &mut mta as *mut pthread_mutexattr_t as *const pthread_mutexattr_t,
    );
    pthread_mutexattr_destroy(&mut mta);
    DT_SIZE = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(TABLE_END as unsafe extern "C" fn() -> K)),
    );
    DT_END_OFFSET = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(end as unsafe extern "C" fn() -> K)),
    );
    DT_ADVERB_OFFSET = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(over as unsafe extern "C" fn() -> K)),
    );
    DT_VERB_OFFSET = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K) -> K>,
            V,
        >(Some(flip as unsafe extern "C" fn(K) -> K)),
    );
    DT_SPECIAL_VERB_OFFSET = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K) -> K>,
            V,
        >(Some(_0m as unsafe extern "C" fn(K) -> K)),
    );
    offsetOver = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(over as unsafe extern "C" fn() -> K)),
    );
    offsetScan = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(scan as unsafe extern "C" fn() -> K)),
    );
    offsetEach = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(each as unsafe extern "C" fn() -> K)),
    );
    offsetEachright = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(eachright as unsafe extern "C" fn() -> K)),
    );
    offsetEachleft = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(eachleft as unsafe extern "C" fn() -> K)),
    );
    offsetEachpair = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn() -> K>,
            V,
        >(Some(eachpair as unsafe extern "C" fn() -> K)),
    );
    tmp___0 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K, K) -> K>,
            V,
        >(Some(what as unsafe extern "C" fn(K, K) -> K)),
    );
    offsetWhat = tmp___0 as V;
    tmp___1 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K, K) -> K>,
            V,
        >(Some(at as unsafe extern "C" fn(K, K) -> K)),
    );
    offsetAt = tmp___1 as V;
    tmp___2 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K, K) -> K>,
            V,
        >(Some(dot as unsafe extern "C" fn(K, K) -> K)),
    );
    offsetDot = tmp___2 as V;
    tmp___3 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K, K) -> K>,
            V,
        >(Some(colon_dyadic as unsafe extern "C" fn(K, K) -> K)),
    );
    offsetColon = tmp___3 as V;
    tmp___4 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K, K) -> K>,
            V,
        >(Some(join as unsafe extern "C" fn(K, K) -> K)),
    );
    offsetJoin = tmp___4 as V;
    tmp___5 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K, K, K) -> K>,
            V,
        >(Some(_ssr as unsafe extern "C" fn(K, K, K) -> K)),
    );
    offsetSSR = tmp___5 as V;
    tmp___6 = DT_OFFSET(
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(K) -> K>,
            V,
        >(Some(_3m as unsafe extern "C" fn(K) -> K)),
    );
    offset3m = tmp___6 as V;
    kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
    SYMBOLS = newN();
    seedPRNG(-(271828 as libc::c_int) as I);
    NIL = Kn();
    KFIXED = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
    kap(&mut KFIXED, &mut NIL as *mut K as V);
    cd(NIL);
    d_ = sp(b".k\0" as *const u8 as *const libc::c_char as S);
    LS = sp(b"\0" as *const u8 as *const libc::c_char as S);
    i = 0 as libc::c_int as I;
    _i___0 = 3 as libc::c_int as I;
    while i < _i___0 {
        IFP[i as usize] = sp(IFS[i as usize]);
        i += 1;
    }
    KTREE = Kd();
    tmp___7 = sp(b"k\0" as *const u8 as *const libc::c_char as S);
    tmp___8 = newEntry(tmp___7);
    x___0 = tmp___8;
    kap(&mut KTREE, &mut x___0 as *mut K as V);
    cd(x___0);
    tmp___9 = _dot_t();
    tmp___10 = sp(b"t\0" as *const u8 as *const libc::c_char as S);
    x___0 = newE(tmp___10, tmp___9);
    kap(&mut KTREE, &mut x___0 as *mut K as V);
    cd(x___0);
    KONA_WHO = newK(1 as libc::c_int as I, 1 as libc::c_int as I);
    *(((*KONA_WHO).k).as_mut_ptr() as *mut I) = 0 as libc::c_int as I;
    KONA_PORT = newK(1 as libc::c_int as I, 1 as libc::c_int as I);
    *(((*KONA_PORT).k).as_mut_ptr() as *mut I) = 0 as libc::c_int as I;
    KONA_GSET = _n();
    KONA_IDX = _n();
    tmp___11 = _h();
    KONA_CLIENT = _host(tmp___11);
    khinit();
    return 0 as libc::c_int as I;
}
unsafe extern "C" fn randomBits() -> I {
    let mut s: I = 0;
    let mut f: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut r: I = 0;
    let mut tmp___0: ssize_t = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: K = 0 as *mut k0;
    tmp = open(b"/dev/urandom\0" as *const u8 as *const libc::c_char, 0 as libc::c_int);
    f = tmp as I;
    tmp___0 = read(
        f as libc::c_int,
        &mut s as *mut I as *mut libc::c_void,
        ::std::mem::size_of::<I>() as libc::c_ulong,
    );
    r = tmp___0 as I;
    if r == 0 {
        tmp___1 = kerr(b"read\0" as *const u8 as *const libc::c_char);
        show(tmp___1);
    }
    tmp___2 = close(f as libc::c_int);
    r = tmp___2 as I;
    if r != 0 {
        tmp___3 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        show(tmp___3);
    }
    return s;
}
pub unsafe extern "C" fn seedPRNG(mut s: I) {
    let mut tmp: I = 0;
    if s != 0 {
        SEED = s;
    } else {
        tmp = randomBits();
        SEED = tmp;
    }
    init_genrand64(SEED as libc::c_ulonglong);
}
unsafe extern "C" fn nodeCount_(mut n: N) -> I {
    let mut l: I = 0;
    let mut r: I = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    l = 0 as libc::c_int as I;
    r = 0 as libc::c_int as I;
    if !((*n).k).is_null() {
        tmp = strlen((*n).k as S as *const libc::c_char);
        if tmp != 0 {
            printf(b"%s \0" as *const u8 as *const libc::c_char, (*n).k as S);
        } else {
            printf(b"(nil) \0" as *const u8 as *const libc::c_char);
        }
    }
    if !((*n).c[0 as libc::c_int as usize]).is_null() {
        tmp___0 = nodeCount_((*n).c[0 as libc::c_int as usize]);
        l += tmp___0;
    }
    if !((*n).c[1 as libc::c_int as usize]).is_null() {
        tmp___1 = nodeCount_((*n).c[1 as libc::c_int as usize]);
        r += tmp___1;
    }
    return 1 as libc::c_longlong + l + r;
}
unsafe extern "C" fn nodeCount(mut n: N) -> I {
    let mut tmp: I = 0;
    tmp = nodeCount_(n);
    return tmp - 1 as libc::c_longlong;
}
pub unsafe extern "C" fn check() -> I {
    let mut ofCheck___0: I = 0;
    let mut a: S = 0 as *mut C;
    let mut n: I = 0;
    let mut q: PDA = 0 as *mut Pda;
    ofCheck___0 = fCheck;
    if !fnc.is_null() {
        ofnc[0 as libc::c_int as usize] = *fnc;
    }
    kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
    fCheck += 1;
    prompt(fCheck);
    a = 0 as S;
    n = 0 as libc::c_int as I;
    q = 0 as PDA;
    loop {
        line(stdin, &mut a, &mut n, &mut q);
        if fCheck == ofCheck___0 {
            return 0 as libc::c_int as I;
        }
    };
}
static mut fln: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn lines(mut f: *mut FILE) -> I {
    let mut a: S = 0 as *mut C;
    let mut n: I = 0;
    let mut p: PDA = 0 as *mut Pda;
    let mut tmp: I = 0;
    a = 0 as S;
    n = 0 as libc::c_int as I;
    p = 0 as PDA;
    fln = 1 as libc::c_int as I;
    loop {
        tmp = line(f, &mut a, &mut n, &mut p);
        if !(-(1 as libc::c_longlong) != tmp) {
            break;
        }
        fln = 0 as libc::c_int as I;
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn line(
    mut f: *mut FILE,
    mut a: *mut S,
    mut n: *mut I,
    mut p: *mut PDA,
) -> I {
    let mut current_block: u64;
    let mut s: S = 0 as *mut C;
    let mut b___1: I = 0;
    let mut c: I = 0;
    let mut m: I = 0;
    let mut o: I = 0;
    let mut q: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut d___0: F = 0.;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut i: I = 0;
    let mut j: I = 0;
    let mut jj: I = 0;
    let mut tmp___1: size_t = 0;
    let mut cfnc: I = 0;
    let mut tmp___2: size_t = 0;
    let mut cprm: I = 0;
    let mut cfl: I = 0;
    let mut cfc: I = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: clock_t = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: clock_t = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: size_t = 0;
    let mut v: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: clock_t = 0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: clock_t = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: size_t = 0;
    let mut tmp___19: size_t = 0;
    let mut ptr: S = 0 as *mut C;
    let mut ctl: I = 0;
    let mut cnt: I = 0;
    let mut i___0: I = 0;
    let mut tmp___20: size_t = 0;
    let mut tmp___21: size_t = 0;
    let mut tmp___22: size_t = 0;
    let mut i___1: I = 0;
    let mut _i___0: I = 0;
    let mut cnt___0: I = 0;
    let mut i___2: I = 0;
    let mut tmp___23: size_t = 0;
    let mut ptr___0: S = 0 as *mut C;
    let mut tmp___24: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i___3: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut i___4: I = 0;
    let mut tmp___26: size_t = 0;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut cnt___1: I = 0;
    let mut tmp___29: I = 0;
    s = 0 as S;
    b___1 = 0 as libc::c_int as I;
    c = 0 as libc::c_int as I;
    m = 0 as libc::c_int as I;
    o = 1 as libc::c_int as I;
    q = 1 as libc::c_int as I;
    feci = 0 as libc::c_int as I;
    fer = feci;
    fbr = fer;
    fam = 1 as libc::c_int as I;
    c = getline_(&mut s, &mut m, f);
    if -(1 as libc::c_longlong) == c {
        current_block = 17433832224168034905;
    } else {
        if fCheck != 0 {
            tmp___0 = strlen(s as *const libc::c_char);
            if 1 as libc::c_ulong == tmp___0 {
                if *s.offset(0 as libc::c_int as isize) as libc::c_int
                    == 10 as libc::c_int
                {
                    loop {
                        tmp = strlen(s as *const libc::c_char);
                        if !(1 as libc::c_ulong == tmp) {
                            current_block = 14447253356787937536;
                            break;
                        }
                        if !(*s.offset(0 as libc::c_int as isize) as libc::c_int
                            == 10 as libc::c_int)
                        {
                            current_block = 14447253356787937536;
                            break;
                        }
                        prompt(b___1 + fCheck);
                        c = getline_(&mut s, &mut m, f);
                        if -(1 as libc::c_longlong) == c {
                            current_block = 17433832224168034905;
                            break;
                        }
                    }
                } else {
                    current_block = 14447253356787937536;
                }
            } else {
                current_block = 14447253356787937536;
            }
        } else {
            current_block = 14447253356787937536;
        }
        match current_block {
            17433832224168034905 => {}
            _ => {
                if fln != 0 {
                    if *s.offset(0 as libc::c_int as isize) as libc::c_int
                        == 35 as libc::c_int
                    {
                        if *s.offset(1 as libc::c_int as isize) as libc::c_int
                            == 33 as libc::c_int
                        {
                            current_block = 17433832224168034905;
                        } else {
                            current_block = 14220266465818359136;
                        }
                    } else {
                        current_block = 14220266465818359136;
                    }
                } else {
                    current_block = 14220266465818359136;
                }
                match current_block {
                    17433832224168034905 => {}
                    _ => {
                        if fCheck != 0 {
                            if *s.offset(0 as libc::c_int as isize) as libc::c_int
                                == 58 as libc::c_int
                            {
                                tmp___8 = strstr(
                                    s as *const libc::c_char,
                                    b"`\"\0" as *const u8 as *const libc::c_char,
                                );
                                if tmp___8 as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    if !lineA.is_null() {
                                        current_block = 8494363942521477221;
                                    } else if flc != 0 {
                                        current_block = 8494363942521477221;
                                    } else {
                                        current_block = 18218798608644444571;
                                    }
                                    match current_block {
                                        18218798608644444571 => {}
                                        _ => {
                                            if !(*a).is_null() {
                                                j = 0 as libc::c_int as I;
                                                while j < 10 as libc::c_longlong {
                                                    if cdp[j as usize] as libc::c_int
                                                        == ofnc[0 as libc::c_int as usize] as libc::c_int
                                                    {
                                                        break;
                                                    }
                                                    j += 1;
                                                }
                                                i = 0 as libc::c_int as I;
                                                loop {
                                                    tmp___1 = strlen(lineC.as_mut_ptr() as *const libc::c_char);
                                                    if !((i as libc::c_ulonglong)
                                                        < tmp___1 as libc::c_ulonglong)
                                                    {
                                                        break;
                                                    }
                                                    if lineC[i as usize] as libc::c_int
                                                        == cdp[(j + 1 as libc::c_longlong) as usize] as libc::c_int
                                                    {
                                                        break;
                                                    }
                                                    i += 1;
                                                }
                                                *n = 0 as libc::c_int as I;
                                                appender(
                                                    a,
                                                    n,
                                                    lineC.as_mut_ptr(),
                                                    i + 1 as libc::c_longlong,
                                                );
                                            } else {
                                                cfnc = 0 as libc::c_int as I;
                                                i = 0 as libc::c_int as I;
                                                loop {
                                                    tmp___2 = strlen(lineC.as_mut_ptr() as *const libc::c_char);
                                                    if !((i as libc::c_ulonglong)
                                                        < tmp___2 as libc::c_ulonglong)
                                                    {
                                                        break;
                                                    }
                                                    if lineC[i as usize] as libc::c_int == *fnc as libc::c_int {
                                                        cfnc += 1;
                                                    }
                                                    i += 1;
                                                }
                                                cprm = 0 as libc::c_int as I;
                                                i = 0 as libc::c_int as I;
                                                while cdp[i as usize] as libc::c_int != 97 as libc::c_int {
                                                    cprm += 1;
                                                    i += 1;
                                                }
                                                if cfnc != ocr {
                                                    let mut current_block_58: u64;
                                                    if cfnc == ocr {
                                                        if !(cdp[(cprm - 1 as libc::c_longlong) as usize]
                                                            as libc::c_int == *fnc as libc::c_int)
                                                        {
                                                            current_block_58 = 17198576112875399832;
                                                        } else {
                                                            current_block_58 = 6950488995570599823;
                                                        }
                                                    } else {
                                                        current_block_58 = 17198576112875399832;
                                                    }
                                                    match current_block_58 {
                                                        17198576112875399832 => {
                                                            cfl = 0 as libc::c_int as I;
                                                            cfc = 0 as libc::c_int as I;
                                                            tmp___3 = strlen(lineC.as_mut_ptr() as *const libc::c_char);
                                                            i = tmp___3.wrapping_sub(1 as libc::c_ulong) as I;
                                                            while i > 0 as libc::c_longlong {
                                                                if lineC[i as usize] as libc::c_int == *fnc as libc::c_int {
                                                                    cfl += 1;
                                                                }
                                                                if cfl == ocr {
                                                                    break;
                                                                }
                                                                i -= 1;
                                                            }
                                                            j = 0 as libc::c_int as I;
                                                            while j < 10 as libc::c_longlong {
                                                                if cdp[j as usize] as libc::c_int == *fnc as libc::c_int {
                                                                    cfc += 1;
                                                                }
                                                                if cfc == ocr {
                                                                    break;
                                                                }
                                                                j += 1;
                                                            }
                                                            jj = i - 1 as libc::c_longlong;
                                                            while jj > 0 as libc::c_longlong {
                                                                if lineC[jj as usize] as libc::c_int
                                                                    == cdp[(j + 1 as libc::c_longlong) as usize] as libc::c_int
                                                                {
                                                                    break;
                                                                }
                                                                jj -= 1;
                                                            }
                                                            appender(
                                                                a,
                                                                n,
                                                                lineC.as_mut_ptr(),
                                                                jj + 1 as libc::c_longlong,
                                                            );
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            tmp___4 = strlen(s as *const libc::c_char);
                                            appender(
                                                a,
                                                n,
                                                s.offset(1 as libc::c_int as isize),
                                                tmp___4.wrapping_sub(2 as libc::c_ulong) as I,
                                            );
                                            tmp___5 = clock();
                                            d___0 = tmp___5 as F;
                                            tmp___6 = wd(*a, *n as libc::c_int);
                                            k = ex(tmp___6);
                                            tmp___7 = clock();
                                            d___0 = (tmp___7 as F - d___0)
                                                / 1000000 as libc::c_long as F;
                                            fCheck -= 1;
                                            q = 0 as libc::c_int as I;
                                            current_block = 17234449432159877516;
                                        }
                                    }
                                } else {
                                    current_block = 18218798608644444571;
                                }
                            } else {
                                current_block = 18218798608644444571;
                            }
                        } else {
                            current_block = 18218798608644444571;
                        }
                        match current_block {
                            18218798608644444571 => {
                                if *s.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 92 as libc::c_int
                                {
                                    if *s.offset(1 as libc::c_int as isize) as libc::c_int
                                        == 10 as libc::c_int
                                    {
                                        if fCheck == 0 {
                                            if fLoad != 0 {
                                                c = -(1 as libc::c_int) as I;
                                                current_block = 17433832224168034905;
                                            } else {
                                                current_block = 17917672080766325409;
                                            }
                                        } else {
                                            current_block = 17917672080766325409;
                                        }
                                        match current_block {
                                            17433832224168034905 => {}
                                            _ => {
                                                if fCheck != 0 {
                                                    fCheck -= 1;
                                                    return 0 as libc::c_int as I;
                                                }
                                                if !(*a).is_null() {
                                                    current_block = 17433832224168034905;
                                                } else {
                                                    current_block = 7244994750255146185;
                                                }
                                            }
                                        }
                                    } else {
                                        current_block = 7244994750255146185;
                                    }
                                } else {
                                    current_block = 7244994750255146185;
                                }
                                match current_block {
                                    17433832224168034905 => {}
                                    _ => {
                                        if *s.offset(0 as libc::c_int as isize) as libc::c_int
                                            == 92 as libc::c_int
                                        {
                                            if *s.offset(1 as libc::c_int as isize) as libc::c_int
                                                == 92 as libc::c_int
                                            {
                                                tmp___9 = strlen(s as *const libc::c_char);
                                                if 2 as libc::c_ulong == tmp___9 {
                                                    exit(0 as libc::c_int);
                                                }
                                            }
                                        }
                                        if flc != 0 {
                                            *n = 0 as libc::c_int as I;
                                        }
                                        appender(a, n, s, c);
                                        tmp___10 = complete(*a, *n, p, 0 as *mut I);
                                        v = tmp___10;
                                        b___1 = parsedepth(*p);
                                        if v == 3 as libc::c_longlong {
                                            tmp___11 = kerr(
                                                b"nest\0" as *const u8 as *const libc::c_char,
                                            );
                                            show(tmp___11);
                                            current_block = 17433832224168034905;
                                        } else if v == 2 as libc::c_longlong {
                                            tmp___12 = kerr(
                                                b"unmatched\0" as *const u8 as *const libc::c_char,
                                            );
                                            show(tmp___12);
                                            b___1 = 0 as libc::c_int as I;
                                            current_block = 17433832224168034905;
                                        } else if v == 1 as libc::c_longlong {
                                            fCmplt = 1 as libc::c_int as I;
                                            current_block = 11356323900008263621;
                                        } else {
                                            if v == 0 as libc::c_longlong {
                                                fCmplt = 0 as libc::c_int as I;
                                            }
                                            if !n.is_null() {
                                                if 10 as libc::c_int
                                                    == *(*a).offset((*n - 1 as libc::c_longlong) as isize)
                                                        as libc::c_int
                                                {
                                                    *n -= 1;
                                                    *(*a).offset(*n as isize) = 0 as libc::c_int as C;
                                                }
                                            }
                                            tmp___13 = pthread_mutex_lock(&mut execute_mutex);
                                            if tmp___13 != 0 {
                                                perror(
                                                    b"Lock mutex in line()\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                                abort();
                                            }
                                            tmp___14 = clock();
                                            d___0 = tmp___14 as F;
                                            tmp___15 = wd(*a, *n as libc::c_int);
                                            k = ex(tmp___15);
                                            tmp___16 = clock();
                                            d___0 = (tmp___16 as F - d___0)
                                                / 1000000 as libc::c_long as F;
                                            tmp___17 = pthread_mutex_unlock(&mut execute_mutex);
                                            if tmp___17 != 0 {
                                                perror(
                                                    b"Unlock mutex in line()\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                                abort();
                                            }
                                            current_block = 17234449432159877516;
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        match current_block {
                            11356323900008263621 => {}
                            17433832224168034905 => {}
                            _ => {
                                if o != 0 {
                                    if fam != 0 {
                                        if feci == 0 {
                                            show(k);
                                        }
                                    }
                                }
                                cd(k);
                                current_block = 17433832224168034905;
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        17433832224168034905 => {
            if fCheck != 0 {
                tmp___18 = strlen(s as *const libc::c_char);
                if tmp___18 == 0 as libc::c_ulong {
                    exit(0 as libc::c_int);
                } else {
                    tmp___19 = strlen(s as *const libc::c_char);
                    if (*s.offset(tmp___19.wrapping_sub(1 as libc::c_ulong) as isize)
                        as libc::c_int) < 0 as libc::c_int
                    {
                        exit(0 as libc::c_int);
                    }
                }
            }
            ptr = 0 as S;
            tmp___28 = strcmp(
                errmsg.as_mut_ptr() as *const libc::c_char,
                b"value\0" as *const u8 as *const libc::c_char,
            );
            if tmp___28 != 0 {
                tmp___27 = strcmp(
                    errmsg.as_mut_ptr() as *const libc::c_char,
                    b"(nil)\0" as *const u8 as *const libc::c_char,
                );
                if tmp___27 != 0 {
                    if fer != -(1 as libc::c_longlong) {
                        oerr();
                        ctl = 0 as libc::c_int as I;
                        if fError != 0 {
                            if 2 as libc::c_longlong == fError {
                                exit(1 as libc::c_int);
                            }
                            if !lineA.is_null() {
                                if !fnc.is_null() {
                                    cnt = 0 as libc::c_int as I;
                                    tmp___22 = strlen(fnc as *const libc::c_char);
                                    if tmp___22 == 1 as libc::c_ulong {
                                        i___0 = 0 as libc::c_int as I;
                                        loop {
                                            tmp___20 = strlen(lineA as *const libc::c_char);
                                            if !((i___0 as libc::c_ulonglong)
                                                < tmp___20 as libc::c_ulonglong)
                                            {
                                                break;
                                            }
                                            if *lineA.offset(i___0 as isize) as libc::c_int
                                                == *fnc as libc::c_int
                                            {
                                                cnt += 1;
                                            }
                                            i___0 += 1;
                                        }
                                    } else {
                                        i___0 = 0 as libc::c_int as I;
                                        loop {
                                            tmp___21 = strlen(lineA as *const libc::c_char);
                                            if !((i___0 as libc::c_ulonglong)
                                                < tmp___21.wrapping_sub(1 as libc::c_ulong)
                                                    as libc::c_ulonglong)
                                            {
                                                break;
                                            }
                                            if *lineA.offset(i___0 as isize) as libc::c_int
                                                == *fnc.offset(0 as libc::c_int as isize) as libc::c_int
                                            {
                                                if *lineA.offset((i___0 + 1 as libc::c_longlong) as isize)
                                                    as libc::c_int
                                                    == *fnc.offset(1 as libc::c_int as isize) as libc::c_int
                                                {
                                                    ptr = lineA.offset(i___0 as isize);
                                                    cnt += 1;
                                                }
                                            }
                                            i___0 += 1;
                                        }
                                    }
                                    if cnt == 1 as libc::c_longlong {
                                        ctl = 1 as libc::c_int as I;
                                        printf(
                                            b"%s\n\0" as *const u8 as *const libc::c_char,
                                            lineA,
                                        );
                                        if ptr.is_null() {
                                            ptr = strchr(
                                                lineA as *const libc::c_char,
                                                *fnc as libc::c_int,
                                            );
                                        }
                                        i___1 = 0 as libc::c_int as I;
                                        _i___0 = ptr.offset_from(lineA) as libc::c_long as I;
                                        while i___1 < _i___0 {
                                            printf(b" \0" as *const u8 as *const libc::c_char);
                                            i___1 += 1;
                                        }
                                        printf(b"^\n\0" as *const u8 as *const libc::c_char);
                                    }
                                    if cnt > 1 as libc::c_longlong {
                                        if fnci != 0 {
                                            if fnci < 127 as libc::c_longlong {
                                                ocr = 0 as libc::c_int as I;
                                                i___0 = 0 as libc::c_int as I;
                                                while i___0 < fnci {
                                                    if fncp[i___0 as usize] as libc::c_ulong
                                                        == fncp[(fnci - 1 as libc::c_longlong) as usize]
                                                            as libc::c_ulong
                                                    {
                                                        ocr += 1;
                                                    }
                                                    i___0 += 1;
                                                }
                                                printf(
                                                    b"%s\n\0" as *const u8 as *const libc::c_char,
                                                    lineA,
                                                );
                                                printf(
                                                    b"at execution instance %lld of \"%s\"\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    ocr,
                                                    fnc,
                                                );
                                                fnci = 0 as libc::c_int as I;
                                            }
                                        }
                                    }
                                }
                            }
                            if !lineB.is_null() {
                                if ctl == 0 {
                                    tmp___25 = strcmp(
                                        lineA as *const libc::c_char,
                                        lineB as *const libc::c_char,
                                    );
                                    if tmp___25 != 0 {
                                        if !fnc.is_null() {
                                            cnt___0 = 0 as libc::c_int as I;
                                            printf(
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                lineB,
                                            );
                                            i___2 = 0 as libc::c_int as I;
                                            loop {
                                                tmp___23 = strlen(lineB as *const libc::c_char);
                                                if !((i___2 as libc::c_ulonglong)
                                                    < tmp___23 as libc::c_ulonglong)
                                                {
                                                    break;
                                                }
                                                if *lineB.offset(i___2 as isize) as libc::c_int
                                                    == *fnc as libc::c_int
                                                {
                                                    cnt___0 += 1;
                                                }
                                                i___2 += 1;
                                            }
                                            if cnt___0 == 1 as libc::c_longlong {
                                                tmp___24 = strchr(
                                                    lineB as *const libc::c_char,
                                                    *fnc as libc::c_int,
                                                );
                                                ptr___0 = tmp___24;
                                                i___3 = 0 as libc::c_int as I;
                                                _i___1 = ptr___0.offset_from(lineB) as libc::c_long as I;
                                                while i___3 < _i___1 {
                                                    printf(b" \0" as *const u8 as *const libc::c_char);
                                                    i___3 += 1;
                                                }
                                                printf(b"^\n\0" as *const u8 as *const libc::c_char);
                                            }
                                            if cnt___0 > 1 as libc::c_longlong {
                                                if fnci != 0 {
                                                    if fnci < 127 as libc::c_longlong {
                                                        ocr = 0 as libc::c_int as I;
                                                        i___2 = 0 as libc::c_int as I;
                                                        while i___2 < fnci {
                                                            if fncp[i___2 as usize] as libc::c_ulong
                                                                == fncp[(fnci - 1 as libc::c_longlong) as usize]
                                                                    as libc::c_ulong
                                                            {
                                                                ocr += 1;
                                                            }
                                                            i___2 += 1;
                                                        }
                                                        printf(
                                                            b"at execution instance %lld of %s\n\0" as *const u8
                                                                as *const libc::c_char,
                                                            ocr,
                                                            fnc,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let mut current_block_262: u64;
                            if !lineA.is_null() {
                                current_block_262 = 13342152186512535761;
                            } else if !lineB.is_null() {
                                current_block_262 = 13342152186512535761;
                            } else {
                                current_block_262 = 14114736409816581360;
                            }
                            match current_block_262 {
                                13342152186512535761 => {
                                    if flc == 0 {
                                        i___4 = 0 as libc::c_int as I;
                                        i___4 = 0 as libc::c_int as I;
                                        loop {
                                            tmp___26 = strlen(*a as *const libc::c_char);
                                            if !((i___4 as libc::c_ulonglong)
                                                < (1 as libc::c_ulong).wrapping_add(tmp___26)
                                                    as libc::c_ulonglong)
                                            {
                                                break;
                                            }
                                            lineC[i___4 as usize] = *(*a).offset(i___4 as isize);
                                            i___4 += 1;
                                        }
                                        flc = 1 as libc::c_int as I;
                                    }
                                    check();
                                }
                                _ => {}
                            }
                        }
                    }
                }
            }
            if !(*p).is_null() {
                pdafree(*p);
            }
            *p = 0 as PDA;
            free(*a as *mut libc::c_void);
            *a = 0 as S;
            *n = 0 as libc::c_int as I;
            free(s as *mut libc::c_void);
            s = 0 as S;
        }
        _ => {}
    }
    if fWksp != 0 {
        printf(
            b"used now : %lld (%lld %lld)\n\0" as *const u8 as *const libc::c_char,
            mUsed as I,
            mAlloc as I,
            mMap as I,
        );
        printf(b"max used : %lld\n\0" as *const u8 as *const libc::c_char, mMax as I);
        printf(b"symbols  : \0" as *const u8 as *const libc::c_char);
        tmp___29 = nodeCount(SYMBOLS);
        cnt___1 = tmp___29;
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        printf(b"count    : %lld\n\0" as *const u8 as *const libc::c_char, cnt___1);
        fWksp = 0 as libc::c_int as I;
    }
    if o != 0 {
        if fLoad == 0 {
            if q != 0 {
                prompt(b___1 + fCheck);
            }
        }
    }
    kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
    feci = 0 as libc::c_int as I;
    fom = feci;
    fnci = fom;
    fer1 = fnci;
    fer = fer1;
    fll = fer;
    if fCheck == 0 {
        lineB = 0 as S;
        lineA = lineB;
        fnc = lineA;
    }
    if !cls.is_null() {
        cd(cls);
        cls = 0 as K;
    }
    return c;
}
pub static mut tmr_ival: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn timer_thread(mut arg: V) -> V {
    let mut a: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut h: K = 0 as *mut k0;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: I = 0;
    loop {
        if tmr_ival != 0 {
            tmp = _n();
            a = tmp;
            tmp___0 = denameS(
                b".\0" as *const u8 as *const libc::c_char as S,
                b".m.ts\0" as *const u8 as *const libc::c_char as S,
                0 as libc::c_int as I,
            );
            h = *tmp___0;
            z = 0 as K;
            if 6 as libc::c_longlong != (*h).t {
                tmp___1 = pthread_mutex_lock(&mut execute_mutex);
                if tmp___1 != 0 {
                    perror(
                        b"Lock mutex in timer_thread())\0" as *const u8
                            as *const libc::c_char,
                    );
                    abort();
                }
                z = at(h, a);
                tmp___2 = pthread_mutex_unlock(&mut execute_mutex);
                if tmp___2 != 0 {
                    perror(
                        b"Unlock mutex in timer_thread())\0" as *const u8
                            as *const libc::c_char,
                    );
                    abort();
                }
            }
            if !z.is_null() {
                cd(z);
            }
            cd(a);
        }
        if tmr_ival != 0 {
            tmp___3 = 1000 as libc::c_longlong * tmr_ival;
        } else {
            tmp___3 = 10000 as libc::c_int as I;
        }
        usleep(tmp___3 as __useconds_t);
    };
}
unsafe extern "C" fn handle_SIGINT(mut sig: libc::c_int) {
    interrupted = 1 as libc::c_int;
}
pub unsafe extern "C" fn attend() -> I {
    let mut current_block: u64;
    let mut a: S = 0 as *mut C;
    let mut n: I = 0;
    let mut q: PDA = 0 as *mut Pda;
    let mut read_fds: fd_set = fd_set { __fds_bits: [0; 16] };
    let mut fdmax: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut listener: libc::c_int = 0;
    let mut newfd: libc::c_int = 0;
    let mut remoteaddr: sockaddr_storage = sockaddr_storage {
        ss_family: 0,
        __ss_padding: [0; 118],
        __ss_align: 0,
    };
    let mut addrlen: socklen_t = 0;
    let mut nbytes: libc::c_int = 0;
    let mut yes: I = 0;
    let mut i: libc::c_int = 0;
    let mut rv: libc::c_int = 0;
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut ai: *mut addrinfo = 0 as *mut addrinfo;
    let mut p: *mut addrinfo = 0 as *mut addrinfo;
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut __d0___0: libc::c_int = 0;
    let mut __d1___0: libc::c_int = 0;
    let mut sa: sigaction = sigaction {
        __sigaction_handler: __anonunion___sigaction_handler_363639592 {
            sa_handler: None,
        },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    let mut res: I = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: S = 0 as *mut C;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___11: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: __uint32_t = 0;
    let mut tmp___15: libc::c_int = 0;
    fer = 0 as libc::c_int as I;
    a = 0 as S;
    n = 0 as libc::c_int as I;
    q = 0 as PDA;
    tmp = fileno(stdin);
    fdmax = tmp;
    listener = 0 as libc::c_int;
    yes = 1 as libc::c_int as I;
    let fresh108 = &mut __d0;
    let fresh109;
    let fresh110 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
    let fresh111 = &mut __d1;
    let fresh112;
    let fresh113 = &mut *(master.__fds_bits)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut __fd_mask;
    asm!(
        "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh108,
        fresh110) => fresh109, inlateout("di")
        c2rust_asm_casts::AsmCast::cast_in(fresh111, fresh113) => fresh112,
        inlateout("ax") 0 as libc::c_int => _, options(preserves_flags, att_syntax)
    );
    c2rust_asm_casts::AsmCast::cast_out(fresh108, fresh110, fresh109);
    c2rust_asm_casts::AsmCast::cast_out(fresh111, fresh113, fresh112);
    let fresh114 = &mut __d0___0;
    let fresh115;
    let fresh116 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
    let fresh117 = &mut __d1___0;
    let fresh118;
    let fresh119 = &mut *(read_fds.__fds_bits)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut __fd_mask;
    asm!(
        "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh114,
        fresh116) => fresh115, inlateout("di")
        c2rust_asm_casts::AsmCast::cast_in(fresh117, fresh119) => fresh118,
        inlateout("ax") 0 as libc::c_int => _, options(preserves_flags, att_syntax)
    );
    c2rust_asm_casts::AsmCast::cast_out(fresh114, fresh116, fresh115);
    c2rust_asm_casts::AsmCast::cast_out(fresh117, fresh119, fresh118);
    sa
        .__sigaction_handler
        .sa_handler = Some(handle_SIGINT as unsafe extern "C" fn(libc::c_int) -> ());
    sa.sa_flags = 268435456 as libc::c_int;
    sigemptyset(&mut sa.sa_mask);
    tmp___0 = sigaction(
        2 as libc::c_int,
        &mut sa as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
    res = tmp___0 as I;
    if res != 0 {
        tmp___1 = kerr(b"sigaction\0" as *const u8 as *const libc::c_char);
        show(tmp___1);
        return -(1 as libc::c_int) as I;
    }
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_family = 2 as libc::c_int;
    hints.ai_socktype = 1 as libc::c_int;
    hints.ai_flags = 1 as libc::c_int;
    tmp___2 = fileno(stdin);
    tmp___3 = fileno(stdin);
    master
        .__fds_bits[(tmp___2
        / (8 as libc::c_int
            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
        as usize]
        |= ((1 as libc::c_ulong)
            << tmp___3
                % (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as __fd_mask;
    if !IPC_PORT.is_null() {
        current_block = 6894376226226883884;
    } else if !HTTP_PORT.is_null() {
        current_block = 6894376226226883884;
    } else {
        current_block = 981995395831942902;
    }
    match current_block {
        6894376226226883884 => {
            if !IPC_PORT.is_null() {
                tmp___5 = IPC_PORT;
            } else {
                tmp___5 = HTTP_PORT;
            }
            rv = getaddrinfo(
                HOST_IFACE as *const libc::c_char,
                tmp___5 as *const libc::c_char,
                &mut hints as *mut addrinfo as *const addrinfo,
                &mut ai as *mut *mut addrinfo,
            );
            if rv != 0 {
                tmp___4 = gai_strerror(rv);
                fprintf(
                    stderr,
                    b"server: %s\n\0" as *const u8 as *const libc::c_char,
                    tmp___4,
                );
                exit(1 as libc::c_int);
            }
            p = ai;
            while p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                listener = socket((*p).ai_family, (*p).ai_socktype, (*p).ai_protocol);
                if !(listener < 0 as libc::c_int) {
                    tmp___8 = bind(
                        listener,
                        (*p).ai_addr as *const sockaddr,
                        (*p).ai_addrlen,
                    );
                    if !(tmp___8 < 0 as libc::c_int) {
                        break;
                    }
                    tmp___7 = close(listener);
                    if tmp___7 != 0 {
                        tmp___6 = kerr(b"file\0" as *const u8 as *const libc::c_char);
                        show(tmp___6);
                    }
                }
                p = (*p).ai_next;
            }
            if p.is_null() {
                fprintf(
                    stderr,
                    b"server: failed to bind\n\0" as *const u8 as *const libc::c_char,
                );
                exit(2 as libc::c_int);
            }
            freeaddrinfo(ai);
            tmp___9 = listen(listener, 10 as libc::c_int);
            if -(1 as libc::c_int) == tmp___9 {
                perror(b"listen\0" as *const u8 as *const libc::c_char);
                exit(3 as libc::c_int);
            }
            master
                .__fds_bits[(listener
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                |= ((1 as libc::c_ulong)
                    << listener
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask;
            fdmax = listener;
        }
        _ => {}
    }
    fln = 1 as libc::c_int as I;
    loop {
        scrLim = 0 as libc::c_int as I;
        read_fds = master;
        tmp___12 = select(
            fdmax + 1 as libc::c_int,
            &mut read_fds as *mut fd_set,
            0 as *mut fd_set,
            0 as *mut fd_set,
            0 as *mut timeval,
        );
        if -(1 as libc::c_int) == tmp___12 {
            tmp___11 = __errno_location();
            if *tmp___11 == 4 as libc::c_int {
                interrupted = 0 as libc::c_int;
                tmp___10 = __errno_location();
                *tmp___10 = 0 as libc::c_int;
            } else {
                perror(b"select\0" as *const u8 as *const libc::c_char);
                exit(4 as libc::c_int);
            }
        }
        i = 0 as libc::c_int;
        while i <= fdmax {
            if read_fds
                .__fds_bits[(i
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << i
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                tmp___15 = fileno(stdin);
                if i == tmp___15 {
                    ofCheck = 0 as libc::c_int as I;
                    fCheck = ofCheck;
                    flc = fCheck;
                    tmp___13 = line(stdin, &mut a, &mut n, &mut q);
                    nbytes = tmp___13 as libc::c_int;
                    fln = 0 as libc::c_int as I;
                    if nbytes <= 0 as libc::c_int {
                        if IPC_PORT.is_null() {
                            if HTTP_PORT.is_null() {
                                exit(0 as libc::c_int);
                            } else {
                                master
                                    .__fds_bits[(i
                                    / (8 as libc::c_int
                                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                            as libc::c_int)) as usize]
                                    &= !(((1 as libc::c_ulong)
                                        << i
                                            % (8 as libc::c_int
                                                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                                    as libc::c_int)) as __fd_mask);
                            }
                        } else {
                            master
                                .__fds_bits[(i
                                / (8 as libc::c_int
                                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                        as libc::c_int)) as usize]
                                &= !(((1 as libc::c_ulong)
                                    << i
                                        % (8 as libc::c_int
                                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                                as libc::c_int)) as __fd_mask);
                        }
                    }
                } else if i == listener {
                    addrlen = ::std::mem::size_of::<sockaddr_storage>() as libc::c_ulong
                        as socklen_t;
                    newfd = accept(
                        listener,
                        &mut remoteaddr as *mut sockaddr_storage as *mut sockaddr,
                        &mut addrlen as *mut socklen_t,
                    );
                    if newfd == -(1 as libc::c_int) {
                        perror(b"accept\0" as *const u8 as *const libc::c_char);
                    } else {
                        wipe_tape(newfd as I);
                        master
                            .__fds_bits[(newfd
                            / (8 as libc::c_int
                                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                    as libc::c_int)) as usize]
                            |= ((1 as libc::c_ulong)
                                << newfd
                                    % (8 as libc::c_int
                                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                            as libc::c_int)) as __fd_mask;
                        if newfd > fdmax {
                            fdmax = newfd;
                        }
                        setsockopt(
                            newfd,
                            6 as libc::c_int,
                            1 as libc::c_int,
                            &mut yes as *mut I as *const libc::c_void,
                            ::std::mem::size_of::<I>() as libc::c_ulong as socklen_t,
                        );
                        tmp___14 = __bswap_32(
                            (*(&mut remoteaddr as *mut sockaddr_storage
                                as *mut sockaddr_in))
                                .sin_addr
                                .s_addr,
                        );
                        CP[newfd as usize].a = tmp___14 as I;
                    }
                } else if a.is_null() {
                    read_tape(i as I, i as I, 0 as libc::c_int as I);
                }
            }
            i += 1;
        }
    };
}
pub static mut fncp: [V; 128] = [0 as *const libc::c_void as *mut libc::c_void; 128];
pub static mut fer: I = 0 as libc::c_int as I;
pub static mut fer1: I = 0 as libc::c_int as I;
pub static mut fwh: I = 0 as libc::c_int as I;
pub static mut stk: I = 0 as libc::c_int as I;
pub static mut stk1: I = 0 as libc::c_int as I;
pub static mut prj: I = 0 as libc::c_int as I;
pub static mut prj2: I = 0 as libc::c_int as I;
pub static mut prnt: K = 0 as *const k0 as K;
pub static mut fsf: I = 0 as libc::c_int as I;
pub static mut grnt: K = 0 as *const k0 as K;
pub static mut cls: K = 0 as *const k0 as K;
pub static mut encf: K = 0 as *const k0 as K;
pub static mut encp: I = 0 as libc::c_int as I;
pub static mut frg: I = 0 as libc::c_int as I;
pub static mut fnc: S = 0 as *const C as S;
pub static mut fnci: I = 0 as libc::c_int as I;
pub static mut fom: I = 0 as libc::c_int as I;
pub static mut fam: I = 1 as libc::c_int as I;
pub static mut ft3: I = 0 as libc::c_int as I;
pub static mut cdp: [C; 11] = [
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    'a' as i32 as C,
    '\u{0}' as i32 as C,
];
pub static mut calf: I = -(1 as libc::c_int) as I;
pub static mut alf: *mut C = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\0"
    as *const u8 as *const libc::c_char as *mut C;
pub unsafe extern "C" fn sd_(mut x___0: K, mut f: I) -> K {
    let mut tmp: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut v: *mut V = 0 as *mut V;
    let mut ii: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    if !x___0.is_null() {
        tmp = bk(x___0 as V);
        if tmp != 0 {
            printf(b" is ; or \\n\n\0" as *const u8 as *const libc::c_char);
            return x___0;
        } else {
            if (*x___0).t == 4 as libc::c_longlong {
                printf(
                    b"     %p %p %p  %lld-%lld %lld %lld   \0" as *const u8
                        as *const libc::c_char,
                    x___0,
                    ((*x___0).k).as_mut_ptr(),
                    *((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                    (*x___0)._c >> 8 as libc::c_int,
                    (*x___0)._c << 56 as libc::c_int >> 56 as libc::c_int,
                    (*x___0).t,
                    (*x___0).n,
                );
            } else {
                printf(
                    b"     %p %p            %lld-%lld %lld %lld   \0" as *const u8
                        as *const libc::c_char,
                    x___0,
                    ((*x___0).k).as_mut_ptr(),
                    (*x___0)._c >> 8 as libc::c_int,
                    (*x___0)._c << 56 as libc::c_int >> 56 as libc::c_int,
                    (*x___0).t,
                    (*x___0).n,
                );
            }
            if f > 0 as libc::c_longlong {
                if (*x___0).t == 0 as libc::c_longlong {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                } else if (*x___0).t == 5 as libc::c_longlong {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                }
            }
            if (*x___0).t != 6 as libc::c_longlong {
                if f > 0 as libc::c_longlong {
                    show(x___0);
                } else {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                }
            } else {
                printf(b"\n\0" as *const u8 as *const libc::c_char);
            }
        }
    } else {
        printf(b"     \0" as *const u8 as *const libc::c_char);
        show(x___0);
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        return x___0;
    }
    if f < 2 as libc::c_longlong {
        return 0 as K;
    }
    match (*x___0).t {
        7 => {
            calf += 1;
            printf(
                b"     %c0:    %p     %s\n\0" as *const u8 as *const libc::c_char,
                *alf.offset(calf as isize) as libc::c_int,
                (((*x___0).k).as_mut_ptr() as *mut S).offset(0 as libc::c_int as isize),
                *(((*x___0).k).as_mut_ptr() as *mut S).offset(0 as libc::c_int as isize),
            );
            printf(
                b"     %c1:    %p     %p\n\0" as *const u8 as *const libc::c_char,
                *alf.offset(calf as isize) as libc::c_int,
                (((*x___0).k).as_mut_ptr() as *mut V).offset(1 as libc::c_int as isize),
                *(((*x___0).k).as_mut_ptr() as *mut V).offset(1 as libc::c_int as isize),
            );
            i = 0 as libc::c_int as I;
            _i___0 = 6 as libc::c_int as I;
            while i < _i___0 {
                printf(
                    b"     %c%lld:   \0" as *const u8 as *const libc::c_char,
                    *alf.offset(calf as isize) as libc::c_int,
                    2 as libc::c_longlong + i,
                );
                printf(
                    b" %p\0" as *const u8 as *const libc::c_char,
                    (((*x___0).k).as_mut_ptr() as *mut V)
                        .offset((2 as libc::c_longlong + i) as isize),
                );
                sd_(
                    *(((*x___0).k).as_mut_ptr() as *mut V)
                        .offset((2 as libc::c_longlong + i) as isize) as K,
                    3 as libc::c_int as I,
                );
                i += 1;
            }
            calf -= 1;
        }
        -4 => {
            v = ((*x___0).k).as_mut_ptr() as *mut V;
            if (*v.offset(0 as libc::c_int as isize) as libc::c_ulong
                > 16 as libc::c_int as V as libc::c_ulong) as libc::c_int
                & ((*v.offset(0 as libc::c_int as isize) as libc::c_ulong)
                    < 83886080 as libc::c_int as V as libc::c_ulong) as libc::c_int != 0
            {
                return 0 as K;
            }
            ii = 0 as libc::c_int as I;
            while !(*v.offset(ii as isize)).is_null() {
                printf(
                    b"     .2%c[%lld]: %p\0" as *const u8 as *const libc::c_char,
                    *alf.offset(calf as isize) as libc::c_int,
                    ii,
                    *v.offset(ii as isize),
                );
                if *v.offset(ii as isize) as libc::c_ulong
                    > DT_SIZE as V as libc::c_ulong
                {
                    if calf < 1 as libc::c_longlong {
                        sd_(*(*v.offset(ii as isize) as *mut K), 2 as libc::c_int as I);
                    } else {
                        sd_(*(*v.offset(ii as isize) as *mut K), 1 as libc::c_int as I);
                    }
                } else {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                }
                ii += 1;
            }
        }
        5 | 0 => {
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*x___0).n;
            while i___0 < _i___1 {
                printf(
                    b" %p\0" as *const u8 as *const libc::c_char,
                    &mut *((*x___0).k).as_mut_ptr().offset(i___0 as isize)
                        as *mut *mut k0,
                );
                sd_(
                    *((*x___0).k).as_mut_ptr().offset(i___0 as isize),
                    2 as libc::c_int as I,
                );
                i___0 += 1;
            }
        }
        _ => {}
    }
    return 0 as K;
}
pub unsafe extern "C" fn sd(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = sd_(x___0, 1 as libc::c_int as I);
    return tmp;
}
unsafe extern "C" fn cjoin(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut zn: I = 0;
    let mut v: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut p: S = 0 as *mut C;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    if 3 as libc::c_longlong != (*x___0).t {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___1 = -(*y).t;
    } else {
        tmp___1 = (*y).t;
    }
    if 3 as libc::c_longlong == tmp___1 {
        tmp___0 = ci(y);
        return tmp___0;
    }
    if (*y).t != 0 {
        tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    }
    if (*y).n == 0 {
        tmp___3 = newK(-(3 as libc::c_int) as I, 0 as libc::c_int as I);
        return tmp___3;
    }
    zn = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    _i___0 = (*y).n;
    while i < _i___0 {
        v = *((*y).k).as_mut_ptr().offset(i as isize);
        if -(3 as libc::c_longlong) != (*v).t {
            tmp___4 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___4;
        }
        zn += (*v).n;
        i += 1;
    }
    if (*y).n != 0 {
        tmp___5 = ((*y).n - 1 as libc::c_longlong) * (*x___0).n;
    } else {
        tmp___5 = 0 as libc::c_int as I;
    }
    zn += tmp___5;
    tmp___6 = newK(-(3 as libc::c_int) as I, zn);
    z = tmp___6;
    tmp___7 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
    if tmp___7 == 0 {
        return 0 as K;
    }
    p = ((*z).k).as_mut_ptr() as *mut C;
    i___0 = 0 as libc::c_int as I;
    _i___1 = (*y).n - 1 as libc::c_longlong;
    while i___0 < _i___1 {
        v = *((*y).k).as_mut_ptr().offset(i___0 as isize);
        memcpy(
            p as *mut libc::c_void,
            ((*v).k).as_mut_ptr() as *mut C as *const libc::c_void,
            (*v).n as size_t,
        );
        p = p.offset((*v).n as isize);
        memcpy(
            p as *mut libc::c_void,
            ((*x___0).k).as_mut_ptr() as *mut C as *const libc::c_void,
            (*x___0).n as size_t,
        );
        p = p.offset((*x___0).n as isize);
        i___0 += 1;
    }
    v = *((*y).k).as_mut_ptr().offset(((*y).n - 1 as libc::c_longlong) as isize);
    memcpy(
        p as *mut libc::c_void,
        ((*v).k).as_mut_ptr() as *mut C as *const libc::c_void,
        (*v).n as size_t,
    );
    return z;
}
unsafe extern "C" fn csplit(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut delim: libc::c_int = 0;
    let mut s: S = 0 as *mut C;
    let mut p0: I = 0;
    let mut p1: I = 0;
    let mut zn: I = 0;
    let mut i: I = 0;
    let mut j: I = 0;
    let mut n: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut j___0: I = 0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut d___0: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    if 3 as libc::c_longlong != (*x___0).t {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___1 = -(*y).t;
    } else {
        tmp___1 = (*y).t;
    }
    if 3 as libc::c_longlong != tmp___1 {
        tmp___0 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    delim = *(((*x___0).k).as_mut_ptr() as *mut C) as libc::c_int;
    s = ((*y).k).as_mut_ptr() as *mut C;
    zn = 0 as libc::c_int as I;
    i = 0 as libc::c_int as I;
    while i < (*y).n {
        j = i;
        n = 0 as libc::c_int as I;
        while i < (*y).n {
            if !(delim != *s.offset(i as isize) as libc::c_int) {
                break;
            }
            i += 1;
            n += 1;
        }
        p0 = j;
        p1 = n;
        zn += 1;
        if i < (*y).n {
            if delim == *s.offset(i as isize) as libc::c_int {
                i += 1;
            }
        }
    }
    if (*y).n != 0 {
        if delim == *s.offset(((*y).n - 1 as libc::c_longlong) as isize) as libc::c_int {
            zn += 1;
        }
    }
    if zn == 0 {
        tmp___2 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
        return tmp___2;
    } else {
        if 1 as libc::c_longlong == zn {
            if (*y).n == p1 {
                tmp___3 = enlist(y);
                return tmp___3;
            }
            tmp___4 = newK(-(3 as libc::c_int) as I, p1);
            z = tmp___4;
            tmp___5 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
            if tmp___5 == 0 {
                return 0 as K;
            }
            memcpy(
                ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                s.offset(p0 as isize) as *const libc::c_void,
                p1 as size_t,
            );
            y = enlist(z);
            cd(z);
            return y;
        }
    }
    j___0 = 0 as libc::c_int as I;
    tmp___6 = newK(0 as libc::c_int as I, zn);
    z___0 = tmp___6;
    tmp___7 = OOM_CD(0 as libc::c_int as I, z___0, -(1 as libc::c_int) as V);
    if tmp___7 == 0 {
        return 0 as K;
    }
    i___0 = 0 as libc::c_int as I;
    _i___0 = zn;
    while i___0 < _i___0 {
        p0 = j___0;
        p1 = 0 as libc::c_int as I;
        while j___0 < (*y).n {
            if !(delim != *s.offset(j___0 as isize) as libc::c_int) {
                break;
            }
            j___0 += 1;
            p1 += 1;
        }
        tmp___8 = newK(-(3 as libc::c_int) as I, p1);
        d___0 = tmp___8;
        tmp___9 = OOM_CD(0 as libc::c_int as I, d___0, z___0, -(1 as libc::c_int) as V);
        if tmp___9 == 0 {
            return 0 as K;
        }
        memcpy(
            ((*d___0).k).as_mut_ptr() as *mut C as *mut libc::c_void,
            s.offset(p0 as isize) as *const libc::c_void,
            p1 as size_t,
        );
        let ref mut fresh120 = *((*z___0).k).as_mut_ptr().offset(i___0 as isize);
        *fresh120 = d___0;
        if j___0 < (*y).n {
            if delim == *s.offset(j___0 as isize) as libc::c_int {
                j___0 += 1;
            }
        }
        i___0 += 1;
    }
    return z___0;
}
pub unsafe extern "C" fn overDyad(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut o: *mut V = 0 as *mut V;
    let mut f: Option::<unsafe extern "C" fn(K, K) -> K> = None;
    let mut k: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut g: K = 0 as *mut k0;
    let mut u: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut c: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut i___1: I = 0;
    let mut _i___1: I = 0;
    o = p.offset(-(1 as libc::c_int as isize));
    k = 0 as K;
    i = 0 as libc::c_int as I;
    if !a.is_null() {
        if *o as libc::c_ulong == offsetJoin as libc::c_ulong {
            if (*b___1).t == 0 {
                if (*b___1).n == 0 {
                    if (0 as libc::c_longlong) < (*a).t {
                        tmp = enlist(a);
                        tmp___1 = tmp;
                    } else {
                        tmp___0 = ci(a);
                        tmp___1 = tmp___0;
                    }
                    return tmp___1;
                }
            }
        }
    }
    if (*b___1).t == 0 as libc::c_longlong {
        while i < (*b___1).n {
            if (**((*b___1).k).as_mut_ptr().offset(i as isize)).t != 0 {
                break;
            }
            i += 1;
        }
    }
    let mut current_block_29: u64;
    if *o as libc::c_ulong != offsetJoin as libc::c_ulong {
        current_block_29 = 8667360926754020198;
    } else if *o as libc::c_ulong == offsetJoin as libc::c_ulong {
        if i == (*b___1).n {
            current_block_29 = 8667360926754020198;
        } else {
            current_block_29 = 15512526488502093901;
        }
    } else {
        current_block_29 = 15512526488502093901;
    }
    match current_block_29 {
        8667360926754020198 => {
            tmp___2 = VA(*o);
            if tmp___2 != 0 {
                f = ::std::mem::transmute::<
                    V,
                    Option::<unsafe extern "C" fn(K, K) -> K>,
                >(DT[*o as L as usize].alt_funcs.verb_over);
                if f.is_some() {
                    k = (Some(f.expect("non-null function pointer")))
                        .expect("non-null function pointer")(a, b___1);
                }
            }
        }
        _ => {}
    }
    if !k.is_null() {
        return k;
    }
    g = 0 as K;
    u = 0 as K;
    v = 0 as K;
    z = 0 as K;
    if !a.is_null() {
        u = enlist(a);
        v = join(u, b___1);
        tmp___3 = v;
    } else {
        tmp___3 = b___1;
    }
    y = tmp___3;
    if (*y).t > 0 as libc::c_longlong {
        z = ci(y);
    } else {
        if *o as libc::c_ulong == 42 as libc::c_int as V as libc::c_ulong {
            if a.is_null() {
                if (*y).t == -(1 as libc::c_longlong) {
                    if (*y).n == 0 as libc::c_longlong {
                        z = Ki(1 as libc::c_int as I);
                        current_block = 5165285795812907862;
                    } else {
                        current_block = 16203797167131938757;
                    }
                } else {
                    current_block = 16203797167131938757;
                }
            } else {
                current_block = 16203797167131938757;
            }
        } else {
            current_block = 16203797167131938757;
        }
        match current_block {
            5165285795812907862 => {}
            _ => {
                if (*y).n == 0 as libc::c_longlong {
                    tmp___4 = VA(*o);
                    if tmp___4 != 0 {
                        z = kerr(b"length\0" as *const u8 as *const libc::c_char);
                    }
                } else {
                    tmp___5 = first(y);
                    c = tmp___5;
                    if 0 as libc::c_longlong > (*y).t {
                        i___0 = 0 as libc::c_int as I;
                        _i___0 = (*y).n - 1 as libc::c_longlong;
                        loop {
                            if !(i___0 < _i___0) {
                                current_block = 17688141731389699982;
                                break;
                            }
                            d___0 = c;
                            if g.is_null() {
                                if (*y).t < 0 as libc::c_longlong {
                                    tmp___6 = -(*y).t;
                                } else {
                                    tmp___6 = (*y).t;
                                }
                                g = newK(tmp___6, 1 as libc::c_int as I);
                            }
                            tmp___7 = bp((*y).t);
                            tmp___8 = bp((*y).t);
                            memcpy(
                                ((*g).k).as_mut_ptr() as *mut libc::c_void,
                                (((*y).k).as_mut_ptr() as V)
                                    .offset(
                                        ((i___0 + 1 as libc::c_longlong) * tmp___8) as isize,
                                    ) as *const libc::c_void,
                                tmp___7 as size_t,
                            );
                            c = dv_ex(d___0, p.offset(-(1 as libc::c_int as isize)), g);
                            tmp___9 = rc(g);
                            if 2 as libc::c_longlong == tmp___9 {
                                cd(g);
                                g = 0 as K;
                            }
                            cd(d___0);
                            if c.is_null() {
                                current_block = 5165285795812907862;
                                break;
                            }
                            i___0 += 1;
                        }
                    } else {
                        current_block = 17688141731389699982;
                    }
                    match current_block {
                        5165285795812907862 => {}
                        _ => {
                            if 0 as libc::c_longlong == (*y).t {
                                i___1 = 0 as libc::c_int as I;
                                _i___1 = (*y).n - 1 as libc::c_longlong;
                                loop {
                                    if !(i___1 < _i___1) {
                                        current_block = 6014157347423944569;
                                        break;
                                    }
                                    d___0 = c;
                                    c = dv_ex(
                                        d___0,
                                        p.offset(-(1 as libc::c_int as isize)),
                                        *((*y).k)
                                            .as_mut_ptr()
                                            .offset((i___1 + 1 as libc::c_longlong) as isize),
                                    );
                                    cd(d___0);
                                    if c.is_null() {
                                        current_block = 5165285795812907862;
                                        break;
                                    }
                                    i___1 += 1;
                                }
                            } else {
                                current_block = 6014157347423944569;
                            }
                            match current_block {
                                5165285795812907862 => {}
                                _ => {
                                    z = c;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if !g.is_null() {
        cd(g);
    }
    if !u.is_null() {
        cd(u);
    }
    if !v.is_null() {
        cd(v);
    }
    return z;
}
unsafe extern "C" fn scanDyad(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut o: *mut V = 0 as *mut V;
    let mut f: Option::<unsafe extern "C" fn(K, K) -> K> = None;
    let mut k: K = 0 as *mut k0;
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut u: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    o = p.offset(-(1 as libc::c_int as isize));
    k = 0 as K;
    tmp = VA(*o);
    if tmp != 0 {
        f = ::std::mem::transmute::<
            V,
            Option::<unsafe extern "C" fn(K, K) -> K>,
        >(DT[*o as L as usize].alt_funcs.verb_scan);
        if f.is_some() {
            k = (Some(f.expect("non-null function pointer")))
                .expect("non-null function pointer")(a, b___1);
        }
    }
    if !k.is_null() {
        return k;
    }
    if a.is_null() {
        if !((*o as libc::c_ulong) < DT_SIZE as V as libc::c_ulong) {
            if !(7 as libc::c_longlong == (**(*o as *mut K)).t) {
                if 3 as libc::c_longlong == (**(*o as *mut K)).t {
                    tmp___0 = csplit(*(*o as *mut K), b___1);
                    return tmp___0;
                }
            }
        }
    }
    u = 0 as K;
    if !a.is_null() {
        u = enlist(a);
        tmp___1 = join(u, b___1);
        tmp___3 = tmp___1;
    } else {
        tmp___2 = ci(b___1);
        tmp___3 = tmp___2;
    }
    y = tmp___3;
    cd(u);
    if (*y).t > 0 as libc::c_longlong {
        return y
    } else {
        if (*y).n == 0 as libc::c_longlong {
            return y;
        }
    }
    tmp___4 = newK(0 as libc::c_int as I, (*y).n);
    z = tmp___4;
    let ref mut fresh121 = *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh121 = first(y);
    if 0 as libc::c_longlong > (*y).t {
        i = 0 as libc::c_int as I;
        _i___0 = (*y).n - 1 as libc::c_longlong;
        while i < _i___0 {
            d___0 = *((*z).k).as_mut_ptr().offset(i as isize);
            if (*y).t < 0 as libc::c_longlong {
                tmp___5 = -(*y).t;
            } else {
                tmp___5 = (*y).t;
            }
            g = newK(tmp___5, 1 as libc::c_int as I);
            tmp___6 = bp((*y).t);
            tmp___7 = bp((*y).t);
            memcpy(
                ((*g).k).as_mut_ptr() as *mut libc::c_void,
                (((*y).k).as_mut_ptr() as V)
                    .offset(((i + 1 as libc::c_longlong) * tmp___7) as isize)
                    as *const libc::c_void,
                tmp___6 as size_t,
            );
            c = dv_ex(d___0, p.offset(-(1 as libc::c_int as isize)), g);
            cd(g);
            if c.is_null() {
                return 0 as K;
            }
            let ref mut fresh122 = *((*z).k)
                .as_mut_ptr()
                .offset((i + 1 as libc::c_longlong) as isize);
            *fresh122 = c;
            i += 1;
        }
    }
    if 0 as libc::c_longlong == (*y).t {
        i___0 = 0 as libc::c_int as I;
        _i___1 = (*y).n - 1 as libc::c_longlong;
        while i___0 < _i___1 {
            d___0 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            c = dv_ex(
                d___0,
                p.offset(-(1 as libc::c_int as isize)),
                *((*y).k).as_mut_ptr().offset((i___0 + 1 as libc::c_longlong) as isize),
            );
            if c.is_null() {
                return 0 as K;
            }
            let ref mut fresh123 = *((*z).k)
                .as_mut_ptr()
                .offset((i___0 + 1 as libc::c_longlong) as isize);
            *fresh123 = c;
            i___0 += 1;
        }
    }
    cd(y);
    if !a.is_null() {
        tmp___10 = atomI(b___1);
        if tmp___10 != 0 {
            y = z;
            u = Ki(1 as libc::c_int as I);
            tmp___8 = OOM_CD(0 as libc::c_int as I, z, u, -(1 as libc::c_int) as V);
            if tmp___8 == 0 {
                return 0 as K;
            }
            z = drop_0(u, z);
            tmp___9 = OOM_CD(0 as libc::c_int as I, y, u, z, -(1 as libc::c_int) as V);
            if tmp___9 == 0 {
                return 0 as K;
            }
            cd(y);
            cd(u);
        }
    }
    tmp___11 = collapse(z);
    return tmp___11;
}
unsafe extern "C" fn overMonad(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut u: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut flag: I = 0;
    let mut useN: I = 0;
    let mut n: I = 0;
    let mut useB: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut f: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut aa: *mut K = 0 as *mut K;
    let mut g: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut o: *mut V = 0 as *mut V;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    u = b___1;
    c = 0 as K;
    flag = 0 as libc::c_int as I;
    useN = 0 as libc::c_int as I;
    n = 0 as libc::c_int as I;
    useB = 0 as libc::c_int as I;
    fsf = 0 as libc::c_int as I;
    if !a.is_null() {
        if 1 as libc::c_longlong == (*a).t {
            useN = 1 as libc::c_int as I;
            n = *(((*a).k).as_mut_ptr() as *mut I);
        } else if 7 as libc::c_longlong == (*a).t {
            useB = 1 as libc::c_int as I;
        } else if 6 as libc::c_longlong == (*a).t {
            useB = 1 as libc::c_int as I;
        }
    }
    if n < 0 as libc::c_longlong {
        tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if useN != 0 {
        f = 0 as libc::c_int as I;
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            c = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), u);
            if b___1 as libc::c_ulong != u as libc::c_ulong {
                cd(u);
            }
            if f != 0 {
                if b___1 as libc::c_ulong == c as libc::c_ulong {
                    cd(c);
                }
            }
            f = 1 as libc::c_int as I;
            u = c;
            if u.is_null() {
                return 0 as K;
            }
            i += 1;
        }
        if !c.is_null() {
            c = c;
        } else {
            tmp___0 = ci(b___1);
            c = tmp___0;
        }
    } else if useB != 0 {
        loop {
            aa = &mut a;
            tmp___1 = dv_ex(0 as K, &mut aa as *mut *mut K as V as *mut V, u);
            g = tmp___1;
            if g.is_null() {
                return 0 as K;
            }
            if (*g).t == 1 as libc::c_longlong {
                if *(((*g).k).as_mut_ptr() as *mut I) != 0 {
                    tmp___2 = 1 as libc::c_int;
                } else {
                    tmp___2 = 0 as libc::c_int;
                }
            } else {
                tmp___2 = 0 as libc::c_int;
            }
            t = tmp___2 as I;
            cd(g);
            if t == 0 {
                break;
            }
            c = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), u);
            if b___1 as libc::c_ulong != u as libc::c_ulong {
                cd(u);
            }
            u = c;
            if u.is_null() {
                return 0 as K;
            }
        }
        if !c.is_null() {
            c = c;
        } else {
            tmp___3 = ci(b___1);
            c = tmp___3;
        }
    } else {
        o = p.offset(-(1 as libc::c_int as isize));
        if *o as libc::c_ulong == offsetOver as V as libc::c_ulong {
            loop {
                tmp___4 = matchI(b___1, c);
                if tmp___4 != 0 {
                    flag = 1 as libc::c_int as I;
                } else if u as libc::c_ulong != b___1 as libc::c_ulong {
                    tmp___5 = matchI(u, c);
                    if tmp___5 != 0 {
                        flag = 1 as libc::c_int as I;
                    }
                }
                if u as libc::c_ulong != b___1 as libc::c_ulong {
                    cd(u);
                }
                if flag != 0 {
                    break;
                }
                if !c.is_null() {
                    u = c;
                } else {
                    u = u;
                }
                c = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), u);
                if c.is_null() {
                    return 0 as K;
                }
                if (*b___1).t < 0 as libc::c_longlong {
                    tmp___6 = -(*b___1).t;
                } else {
                    tmp___6 = (*b___1).t;
                }
                if 1 as libc::c_longlong == tmp___6 {
                    if (*c).t < 0 as libc::c_longlong {
                        tmp___7 = -(*c).t;
                    } else {
                        tmp___7 = (*c).t;
                    }
                    if 3 as libc::c_longlong == tmp___7 {
                        flag = 1 as libc::c_int as I;
                    }
                }
            }
        } else {
            's_938: {
                let mut current_block_205: u64;
                if !((*o as libc::c_ulong) < DT_SIZE as V as libc::c_ulong) {
                    if 7 as libc::c_longlong == (**(*o as *mut K)).t {
                        if 3 as libc::c_longlong == (**(*o as *mut K)).n {
                            current_block_205 = 311927823379127878;
                        } else {
                            current_block_205 = 17751516764098382209;
                        }
                    } else {
                        current_block_205 = 17751516764098382209;
                    }
                    match current_block_205 {
                        311927823379127878 => {}
                        _ => {
                            a = *(*o as *mut K);
                            if 3 as libc::c_longlong == (*a).t {
                                tmp___12 = cjoin(a, b___1);
                                return tmp___12;
                            }
                            loop {
                                tmp___13 = matchI(b___1, c);
                                if tmp___13 != 0 {
                                    flag = 1 as libc::c_int as I;
                                } else if u as libc::c_ulong != b___1 as libc::c_ulong {
                                    tmp___14 = matchI(u, c);
                                    if tmp___14 != 0 {
                                        flag = 1 as libc::c_int as I;
                                    }
                                }
                                if u as libc::c_ulong != b___1 as libc::c_ulong {
                                    cd(u);
                                }
                                if flag != 0 {
                                    break;
                                }
                                if !c.is_null() {
                                    u = c;
                                } else {
                                    u = u;
                                }
                                c = dv_ex(0 as K, o, u);
                                if c.is_null() {
                                    return 0 as K;
                                }
                                if (*b___1).t < 0 as libc::c_longlong {
                                    tmp___15 = -(*b___1).t;
                                } else {
                                    tmp___15 = (*b___1).t;
                                }
                                if 1 as libc::c_longlong == tmp___15 {
                                    if (*c).t < 0 as libc::c_longlong {
                                        tmp___16 = -(*c).t;
                                    } else {
                                        tmp___16 = (*c).t;
                                    }
                                    if 3 as libc::c_longlong == tmp___16 {
                                        flag = 1 as libc::c_int as I;
                                    }
                                }
                            }
                            break 's_938;
                        }
                    }
                }
                loop {
                    tmp___8 = matchI(b___1, c);
                    if tmp___8 != 0 {
                        flag = 1 as libc::c_int as I;
                    } else if u as libc::c_ulong != b___1 as libc::c_ulong {
                        tmp___9 = matchI(u, c);
                        if tmp___9 != 0 {
                            flag = 1 as libc::c_int as I;
                        }
                    }
                    if flag != 0 {
                        break;
                    }
                    if u as libc::c_ulong != b___1 as libc::c_ulong {
                        cd(u);
                    }
                    if !c.is_null() {
                        u = c;
                    } else {
                        u = u;
                    }
                    c = dv_ex(0 as K, o, u);
                    if c.is_null() {
                        return 0 as K;
                    }
                    if (*b___1).t < 0 as libc::c_longlong {
                        tmp___10 = -(*b___1).t;
                    } else {
                        tmp___10 = (*b___1).t;
                    }
                    if 1 as libc::c_longlong == tmp___10 {
                        if (*c).t < 0 as libc::c_longlong {
                            tmp___11 = -(*c).t;
                        } else {
                            tmp___11 = (*c).t;
                        }
                        if 3 as libc::c_longlong == tmp___11 {
                            flag = 1 as libc::c_int as I;
                        }
                    }
                }
                cd(c);
                return u;
            }
        }
    }
    return c;
}
unsafe extern "C" fn scanMonad(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut u: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut w___0: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut flag: I = 0;
    let mut useN: I = 0;
    let mut n: I = 0;
    let mut useB: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut t: I = 0;
    let mut aa: *mut K = 0 as *mut K;
    let mut g: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    tmp = enlist(b___1);
    u = tmp;
    c = 0 as K;
    flag = 0 as libc::c_int as I;
    if u.is_null() {
        return 0 as K;
    }
    useN = 0 as libc::c_int as I;
    n = 0 as libc::c_int as I;
    useB = 0 as libc::c_int as I;
    if !a.is_null() {
        if 1 as libc::c_longlong == (*a).t {
            useN = 1 as libc::c_int as I;
            n = *(((*a).k).as_mut_ptr() as *mut I);
        } else if 7 as libc::c_longlong == (*a).t {
            useB = 1 as libc::c_int as I;
        }
    }
    if n < 0 as libc::c_longlong {
        tmp___0 = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    if useN != 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            d___0 = last(u);
            if d___0.is_null() {
                return 0 as K;
            }
            c = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), d___0);
            cd(d___0);
            if c.is_null() {
                return 0 as K;
            }
            v = enlist(c);
            if v.is_null() {
                return 0 as K;
            }
            cd(c);
            w___0 = u;
            u = join(w___0, v);
            cd(w___0);
            cd(v);
            if u.is_null() {
                return 0 as K;
            }
            i += 1;
        }
    } else if useB != 0 {
        loop {
            d___0 = last(u);
            if d___0.is_null() {
                return 0 as K;
            }
            aa = &mut a;
            tmp___1 = dv_ex(0 as K, &mut aa as *mut *mut K as V as *mut V, d___0);
            g = tmp___1;
            if g.is_null() {
                return 0 as K;
            }
            if 1 as libc::c_longlong == (*g).t {
                if *(((*g).k).as_mut_ptr() as *mut I) != 0 {
                    tmp___2 = 1 as libc::c_int;
                } else {
                    tmp___2 = 0 as libc::c_int;
                }
            } else {
                tmp___2 = 0 as libc::c_int;
            }
            t = tmp___2 as I;
            cd(g);
            if t == 0 {
                cd(d___0);
                break;
            } else {
                c = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), d___0);
                cd(d___0);
                if c.is_null() {
                    return 0 as K;
                }
                v = enlist(c);
                if v.is_null() {
                    return 0 as K;
                }
                cd(c);
                w___0 = u;
                u = join(w___0, v);
                cd(w___0);
                cd(v);
                if u.is_null() {
                    return 0 as K;
                }
            }
        }
    } else {
        loop {
            d___0 = last(u);
            if d___0.is_null() {
                return 0 as K;
            }
            tmp___3 = matchI(b___1, c);
            if tmp___3 != 0 {
                flag = 1 as libc::c_int as I;
            } else {
                tmp___4 = matchI(c, d___0);
                if tmp___4 != 0 {
                    flag = 1 as libc::c_int as I;
                }
            }
            if flag == 0 {
                if !c.is_null() {
                    w___0 = enlist(c);
                    v = u;
                    u = join(v, w___0);
                    cd(v);
                    cd(w___0);
                    cd(d___0);
                    d___0 = c;
                }
            }
            if interrupted != 0 {
                interrupted = 0 as libc::c_int;
                tmp___5 = kerr(b"break\0" as *const u8 as *const libc::c_char);
                return tmp___5;
            }
            if flag != 0 {
                cd(c);
                cd(d___0);
                break;
            } else {
                c = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), d___0);
                cd(d___0);
                if c.is_null() {
                    cd(u);
                    return c;
                }
            }
        }
    }
    return u;
}
unsafe extern "C" fn each2(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut prnt0: K = 0 as *mut k0;
    let mut grnt0: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: I = 0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut f: I = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___8: I = 0;
    bt = (*b___1).t;
    bn = (*b___1).n;
    prnt0 = 0 as K;
    grnt0 = 0 as K;
    d___0 = 0 as K;
    if bt > 0 as libc::c_longlong {
        if !a.is_null() {
            if (*a).n > 0 as libc::c_longlong {
                tmp = newK(0 as libc::c_int as I, (*a).n);
                z = tmp;
                if z.is_null() {
                    return 0 as K;
                }
                i = 0 as libc::c_int as I;
                _i___0 = (*a).n;
                while i < _i___0 {
                    d___0 = dv_ex(
                        *((*a).k).as_mut_ptr().offset(i as isize),
                        p.offset(-(1 as libc::c_int as isize)),
                        b___1,
                    );
                    tmp___0 = OOM_CD(
                        0 as libc::c_int as I,
                        d___0,
                        z,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___0 == 0 {
                        return 0 as K;
                    }
                    let ref mut fresh124 = *((*z).k).as_mut_ptr().offset(i as isize);
                    *fresh124 = d___0;
                    i += 1;
                }
                z = demote(z);
                if (*z).t == 1 as libc::c_longlong {
                    (*z).t = -(1 as libc::c_int) as I;
                }
                return z;
            } else {
                d___0 = dv_ex(a, p.offset(-(1 as libc::c_int as isize)), b___1);
                return d___0;
            }
        } else {
            d___0 = dv_ex(a, p.offset(-(1 as libc::c_int as isize)), b___1);
            return d___0;
        }
    } else {
        tmp___1 = newK(0 as libc::c_int as I, bn);
        z___0 = tmp___1;
        if z___0.is_null() {
            return 0 as K;
        }
        if *p as libc::c_ulong == offsetEach as V as libc::c_ulong {
            if *p.offset(-(1 as libc::c_int as isize)) as libc::c_ulong
                == offsetEach as V as libc::c_ulong
            {
                current_block = 13272607202300651548;
            } else if *p.offset(-(1 as libc::c_int as isize)) as libc::c_ulong
                    == offsetOver as V as libc::c_ulong
                {
                current_block = 13272607202300651548;
            } else if *p.offset(-(1 as libc::c_int as isize)) as libc::c_ulong
                    == offsetScan as V as libc::c_ulong
                {
                current_block = 13272607202300651548;
            } else {
                tmp___2 = 0 as libc::c_int;
                current_block = 11777552016271000781;
            }
            match current_block {
                11777552016271000781 => {}
                _ => {
                    if (*p.offset(-(2 as libc::c_int as isize)) as libc::c_ulong)
                        < DT_SIZE as V as libc::c_ulong
                    {
                        tmp___2 = 1 as libc::c_int;
                    } else {
                        tmp___2 = 0 as libc::c_int;
                    }
                }
            }
        } else {
            tmp___2 = 0 as libc::c_int;
        }
        f = tmp___2 as I;
        if 0 as libc::c_longlong > bt {
            i___0 = 0 as libc::c_int as I;
            _i___1 = bn;
            while i___0 < _i___1 {
                if bt < 0 as libc::c_longlong {
                    tmp___3 = -bt;
                } else {
                    tmp___3 = bt;
                }
                g = newK(tmp___3, 1 as libc::c_int as I);
                tmp___4 = OOM_CD(
                    0 as libc::c_int as I,
                    g,
                    z___0,
                    -(1 as libc::c_int) as V,
                );
                if tmp___4 == 0 {
                    return 0 as K;
                }
                tmp___5 = bp(bt);
                tmp___6 = bp(bt);
                memcpy(
                    ((*g).k).as_mut_ptr() as *mut libc::c_void,
                    (((*b___1).k).as_mut_ptr() as V).offset((i___0 * tmp___6) as isize)
                        as *const libc::c_void,
                    tmp___5 as size_t,
                );
                if f != 0 {
                    d___0 = dv_ex(a, p.offset(-(1 as libc::c_int as isize)), g);
                } else {
                    d___0 = dv_ex(0 as K, p.offset(-(1 as libc::c_int as isize)), g);
                }
                cd(g);
                tmp___7 = OOM_CD(
                    0 as libc::c_int as I,
                    d___0,
                    z___0,
                    -(1 as libc::c_int) as V,
                );
                if tmp___7 == 0 {
                    return 0 as K;
                }
                let ref mut fresh125 = *((*z___0).k).as_mut_ptr().offset(i___0 as isize);
                *fresh125 = d___0;
                i___0 += 1;
            }
        }
        if 0 as libc::c_longlong == bt {
            if !prnt.is_null() {
                prnt0 = ci(prnt);
            }
            if !grnt.is_null() {
                grnt0 = ci(grnt);
            }
            i___1 = 0 as libc::c_int as I;
            _i___2 = bn;
            while i___1 < _i___2 {
                if f != 0 {
                    if !a.is_null() {
                        if (*a).n > 1 as libc::c_longlong {
                            d___0 = dv_ex(
                                *((*a).k).as_mut_ptr().offset(i___1 as isize),
                                p.offset(-(1 as libc::c_int as isize)),
                                *((*b___1).k).as_mut_ptr().offset(i___1 as isize),
                            );
                        } else {
                            d___0 = dv_ex(
                                a,
                                p.offset(-(1 as libc::c_int as isize)),
                                *((*b___1).k).as_mut_ptr().offset(i___1 as isize),
                            );
                        }
                    } else {
                        d___0 = dv_ex(
                            a,
                            p.offset(-(1 as libc::c_int as isize)),
                            *((*b___1).k).as_mut_ptr().offset(i___1 as isize),
                        );
                    }
                } else {
                    if !prnt0.is_null() {
                        cd(prnt);
                        prnt = ci(prnt0);
                    }
                    if !grnt0.is_null() {
                        cd(grnt);
                        grnt = ci(grnt0);
                    }
                    d___0 = dv_ex(
                        0 as K,
                        p.offset(-(1 as libc::c_int as isize)),
                        *((*b___1).k).as_mut_ptr().offset(i___1 as isize),
                    );
                }
                let mut current_block_119: u64;
                if d___0.is_null() {
                    current_block_119 = 5514974161987011595;
                } else if z___0.is_null() {
                    current_block_119 = 5514974161987011595;
                } else {
                    current_block_119 = 4983594971376015098;
                }
                match current_block_119 {
                    5514974161987011595 => {
                        if !prnt0.is_null() {
                            cd(prnt0);
                            prnt0 = 0 as K;
                        }
                        if !grnt0.is_null() {
                            cd(grnt0);
                            grnt0 = 0 as K;
                        }
                    }
                    _ => {}
                }
                if !grnt.is_null() {
                    if prnt.is_null() {
                        prnt = ci(grnt);
                    }
                }
                tmp___8 = OOM_CD(
                    0 as libc::c_int as I,
                    d___0,
                    z___0,
                    -(1 as libc::c_int) as V,
                );
                if tmp___8 == 0 {
                    return 0 as K;
                }
                let ref mut fresh126 = *((*z___0).k).as_mut_ptr().offset(i___1 as isize);
                *fresh126 = d___0;
                i___1 += 1;
            }
        }
        z___0 = demote(z___0);
        if (*z___0).t == 1 as libc::c_longlong {
            (*z___0).t = -(1 as libc::c_int) as I;
        }
        if !prnt0.is_null() {
            cd(prnt0);
            prnt0 = 0 as K;
        }
        if !grnt0.is_null() {
            cd(grnt0);
            grnt0 = 0 as K;
        }
        return z___0;
    };
}
unsafe extern "C" fn eachright2(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    if ft3 != 0 {
        if a.is_null() {
            tmp = kerr(b"valence\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    bt = (*b___1).t;
    bn = (*b___1).n;
    if bt > 0 as libc::c_longlong {
        tmp___0 = dv_ex(a, p.offset(-(1 as libc::c_int as isize)), b___1);
        return tmp___0;
    }
    tmp___1 = newK(0 as libc::c_int as I, bn);
    z = tmp___1;
    if 0 as libc::c_longlong > bt {
        i = 0 as libc::c_int as I;
        _i___0 = bn;
        while i < _i___0 {
            if bt < 0 as libc::c_longlong {
                tmp___2 = -bt;
            } else {
                tmp___2 = bt;
            }
            g = newK(tmp___2, 1 as libc::c_int as I);
            tmp___3 = bp(bt);
            tmp___4 = bp(bt);
            memcpy(
                ((*g).k).as_mut_ptr() as *mut libc::c_void,
                (((*b___1).k).as_mut_ptr() as V).offset((i * tmp___4) as isize)
                    as *const libc::c_void,
                tmp___3 as size_t,
            );
            d___0 = dv_ex(a, p.offset(-(1 as libc::c_int as isize)), g);
            cd(g);
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh127 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh127 = d___0;
            i += 1;
        }
    }
    if 0 as libc::c_longlong == bt {
        i___0 = 0 as libc::c_int as I;
        _i___1 = bn;
        while i___0 < _i___1 {
            d___0 = dv_ex(
                a,
                p.offset(-(1 as libc::c_int as isize)),
                *((*b___1).k).as_mut_ptr().offset(i___0 as isize),
            );
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh128 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh128 = d___0;
            i___0 += 1;
        }
    }
    tmp___5 = demote(z);
    return tmp___5;
}
unsafe extern "C" fn eachleft2(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    if a.is_null() {
        tmp = kerr(b"valence\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    at___0 = (*a).t;
    an = (*a).n;
    if at___0 > 0 as libc::c_longlong {
        tmp___0 = dv_ex(a, p.offset(-(1 as libc::c_int as isize)), b___1);
        return tmp___0;
    }
    tmp___1 = newK(0 as libc::c_int as I, an);
    z = tmp___1;
    if 0 as libc::c_longlong > at___0 {
        i = 0 as libc::c_int as I;
        _i___0 = an;
        while i < _i___0 {
            if at___0 < 0 as libc::c_longlong {
                tmp___2 = -at___0;
            } else {
                tmp___2 = at___0;
            }
            g = newK(tmp___2, 1 as libc::c_int as I);
            tmp___3 = bp(at___0);
            tmp___4 = bp(at___0);
            memcpy(
                ((*g).k).as_mut_ptr() as *mut libc::c_void,
                (((*a).k).as_mut_ptr() as V).offset((i * tmp___4) as isize)
                    as *const libc::c_void,
                tmp___3 as size_t,
            );
            d___0 = dv_ex(g, p.offset(-(1 as libc::c_int as isize)), b___1);
            cd(g);
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh129 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh129 = d___0;
            i += 1;
        }
    }
    if 0 as libc::c_longlong == at___0 {
        i___0 = 0 as libc::c_int as I;
        _i___1 = an;
        while i___0 < _i___1 {
            d___0 = dv_ex(
                *((*a).k).as_mut_ptr().offset(i___0 as isize),
                p.offset(-(1 as libc::c_int as isize)),
                b___1,
            );
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh130 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh130 = d___0;
            i___0 += 1;
        }
    }
    tmp___5 = demote(z);
    return tmp___5;
}
unsafe extern "C" fn eachpair2(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut o: *mut V = 0 as *mut V;
    let mut f: Option::<unsafe extern "C" fn(K, K) -> K> = None;
    let mut k: K = 0 as *mut k0;
    let mut tmp: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut u: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut h: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut u___0: K = 0 as *mut k0;
    let mut v___0: K = 0 as *mut k0;
    let mut tmp___18: I = 0;
    let mut u___1: K = 0 as *mut k0;
    o = p.offset(-(1 as libc::c_int as isize));
    k = 0 as K;
    tmp = VA(*o);
    if tmp != 0 {
        f = ::std::mem::transmute::<
            V,
            Option::<unsafe extern "C" fn(K, K) -> K>,
        >(DT[*o as L as usize].alt_funcs.verb_eachpair);
        if f.is_some() {
            k = (Some(f.expect("non-null function pointer")))
                .expect("non-null function pointer")(a, b___1);
        }
    }
    if !k.is_null() {
        return k;
    }
    bt = (*b___1).t;
    bn = (*b___1).n;
    if !a.is_null() {
        if bt > 0 as libc::c_longlong {
            if bn > 1 as libc::c_longlong {
                u = enlist(a);
                tmp___0 = OOM_CD(
                    0 as libc::c_int as I,
                    u,
                    b___1,
                    -(1 as libc::c_int) as V,
                );
                if tmp___0 == 0 {
                    return 0 as K;
                }
                v = join(u, b___1);
                cd(u);
                return v;
            }
        }
    }
    if bt <= 0 as libc::c_longlong {
        if bn == 0 as libc::c_longlong {
            if a.is_null() {
                tmp___1 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___1;
            }
        }
        if bn == 0 as libc::c_longlong {
            if !a.is_null() {
                tmp___2 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                return tmp___2;
            }
        }
        if bn < 2 as libc::c_longlong {
            tmp___3 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
            return tmp___3;
        }
    }
    tmp___4 = newK(0 as libc::c_int as I, bn - 1 as libc::c_longlong);
    z = tmp___4;
    d___0 = 0 as K;
    if z.is_null() {
        return 0 as K;
    }
    if bt < 0 as libc::c_longlong {
        i = 0 as libc::c_int as I;
        _i___0 = bn - 1 as libc::c_longlong;
        while i < _i___0 {
            if bt < 0 as libc::c_longlong {
                tmp___5 = -bt;
            } else {
                tmp___5 = bt;
            }
            h = newK(tmp___5, 1 as libc::c_int as I);
            if bt < 0 as libc::c_longlong {
                tmp___6 = -bt;
            } else {
                tmp___6 = bt;
            }
            g = newK(tmp___6, 1 as libc::c_int as I);
            tmp___7 = bp(bt);
            tmp___8 = bp(bt);
            memcpy(
                ((*h).k).as_mut_ptr() as *mut libc::c_void,
                (((*b___1).k).as_mut_ptr() as V).offset((i * tmp___8) as isize)
                    as *const libc::c_void,
                tmp___7 as size_t,
            );
            tmp___9 = bp(bt);
            tmp___10 = bp(bt);
            memcpy(
                ((*g).k).as_mut_ptr() as *mut libc::c_void,
                (((*b___1).k).as_mut_ptr() as V)
                    .offset(((i + 1 as libc::c_longlong) * tmp___10) as isize)
                    as *const libc::c_void,
                tmp___9 as size_t,
            );
            d___0 = dv_ex(g, p.offset(-(1 as libc::c_int as isize)), h);
            cd(g);
            cd(h);
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh131 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh131 = d___0;
            i += 1;
        }
    }
    if bt == 0 as libc::c_longlong {
        i___0 = 0 as libc::c_int as I;
        _i___1 = bn - 1 as libc::c_longlong;
        while i___0 < _i___1 {
            d___0 = dv_ex(
                *((*b___1).k)
                    .as_mut_ptr()
                    .offset((i___0 + 1 as libc::c_longlong) as isize),
                p.offset(-(1 as libc::c_int as isize)),
                *((*b___1).k).as_mut_ptr().offset(i___0 as isize),
            );
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh132 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh132 = d___0;
            i___0 += 1;
        }
    }
    if bt > 0 as libc::c_longlong {
        if a.is_null() {
            if bt < 0 as libc::c_longlong {
                tmp___11 = -bt;
            } else {
                tmp___11 = bt;
            }
            h = newK(tmp___11, 1 as libc::c_int as I);
            if bt < 0 as libc::c_longlong {
                tmp___12 = -bt;
            } else {
                tmp___12 = bt;
            }
            g = newK(tmp___12, 1 as libc::c_int as I);
            tmp___13 = bp(bt);
            tmp___14 = bp(bt);
            memcpy(
                ((*h).k).as_mut_ptr() as *mut libc::c_void,
                (((*b___1).k).as_mut_ptr() as V).offset(0 as libc::c_longlong as isize)
                    as *const libc::c_void,
                tmp___13 as size_t,
            );
            tmp___15 = bp(bt);
            tmp___16 = bp(bt);
            memcpy(
                ((*g).k).as_mut_ptr() as *mut libc::c_void,
                (((*b___1).k).as_mut_ptr() as V).offset(0 as libc::c_longlong as isize)
                    as *const libc::c_void,
                tmp___15 as size_t,
            );
            d___0 = dv_ex(g, p.offset(-(1 as libc::c_int as isize)), h);
            cd(g);
            cd(h);
            cd(z);
            if d___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh133 = *((*z).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh133 = d___0;
            return d___0;
        }
    }
    z = demote(z);
    if !a.is_null() {
        if bn == 1 as libc::c_longlong {
            cd(z);
            tmp___17 = ci(a);
            return tmp___17;
        }
        u___0 = enlist(a);
        tmp___18 = OOM_CD(0 as libc::c_int as I, u___0, z, -(1 as libc::c_int) as V);
        if tmp___18 == 0 {
            return 0 as K;
        }
        v___0 = join(u___0, z);
        cd(u___0);
        cd(z);
        return v___0;
    } else {
        if (*z).t == 1 as libc::c_longlong {
            u___1 = enlist(z);
            cd(z);
            return u___1;
        }
    }
    return z;
}
pub unsafe extern "C" fn dv_ex(mut a: K, mut p: *mut V, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut o: *mut V = 0 as *mut V;
    let mut k: I = 0;
    let mut w___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut adverb: V = 0 as *mut libc::c_void;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut k___0: K = 0 as *mut k0;
    let mut tmp___12: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut gn: I = 0;
    let mut q: [V; 4] = [0 as *mut libc::c_void; 4];
    let mut u: K = 0 as *mut k0;
    let mut tmp___22: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut tmp___24: I = 0;
    let mut g: K = 0 as *mut k0;
    let mut tmp___25: K = 0 as *mut k0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut flag: I = 0;
    let mut p1: *mut V = 0 as *mut V;
    let mut p2: K = 0 as *mut k0;
    let mut tmp___27: K = 0 as *mut k0;
    if p.is_null() {
        return 0 as K
    } else {
        if (*p).is_null() {
            return 0 as K;
        }
    }
    if b___1.is_null() {
        return 0 as K;
    }
    o = p.offset(-(1 as libc::c_int as isize));
    k = 0 as libc::c_int as I;
    if *p as libc::c_ulong == offsetScan as V as libc::c_ulong {
        if *o as libc::c_ulong > DT_SIZE as V as libc::c_ulong {
            w___0 = *(*o as *mut K);
            if 7 as libc::c_longlong == (*w___0).t {
                if 3 as libc::c_longlong
                    == (*(*(((*w___0).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .n
                {
                    if *(((*(*(((*w___0).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut V)
                        .offset(0 as libc::c_int as isize) as libc::c_ulong
                        == 22 as libc::c_int as V as libc::c_ulong
                    {
                        if *(((*(*(((*w___0).k).as_mut_ptr() as *mut V)
                            .offset(2 as libc::c_int as isize) as K))
                            .k)
                            .as_mut_ptr() as *mut V)
                            .offset(1 as libc::c_int as isize) as libc::c_ulong
                            == offsetScan as V as libc::c_ulong
                        {
                            k = 1 as libc::c_int as I;
                        }
                    }
                }
            }
        }
    }
    if k == 0 as libc::c_longlong {
        tmp___5 = adverbClass(*p);
        if tmp___5 != 0 {
            tmp___3 = adverbClass(*o);
            if tmp___3 != 0 {
                tmp___2 = 1 as libc::c_int as I;
            } else {
                tmp___1 = valence(*o);
                tmp___2 = tmp___1;
            }
            k = tmp___2;
        } else {
            tmp___4 = valence(*p);
            k = tmp___4;
        }
    }
    adverb = *p;
    if k > 2 as libc::c_longlong {
        k = 2 as libc::c_int as I;
    }
    if *p as libc::c_ulong == offsetEach as V as libc::c_ulong {
        if k == 1 as libc::c_longlong {
            if !a.is_null() {
                if !b___1.is_null() {
                    if (*a).t > 0 as libc::c_longlong {
                        if (*a).t < 5 as libc::c_longlong {
                            if (*b___1).t > 0 as libc::c_longlong {
                                if (*b___1).t < 5 as libc::c_longlong {
                                    k = 2 as libc::c_int as I;
                                    current_block = 13853033528615664019;
                                } else {
                                    current_block = 18198230555377148307;
                                }
                            } else {
                                current_block = 18198230555377148307;
                            }
                        } else {
                            current_block = 18198230555377148307;
                        }
                    } else {
                        current_block = 18198230555377148307;
                    }
                    match current_block {
                        13853033528615664019 => {}
                        _ => {
                            if (*a).t == -(1 as libc::c_longlong) {
                                if (*b___1).t == -(1 as libc::c_longlong) {
                                    k = 2 as libc::c_int as I;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if 2 as libc::c_longlong == k {
        current_block = 10150553051795437704;
    } else {
        if k == 0 as libc::c_longlong {
            if adverb as UI == offsetScan as UI {
                if 0 as libc::c_longlong
                    == (**(*p.offset(-(1 as libc::c_int) as isize) as *mut K)).t
                {
                    current_block = 10150553051795437704;
                } else if 3 as libc::c_longlong
                        == (**(*p.offset(-(1 as libc::c_int) as isize) as *mut K)).t
                    {
                    current_block = 10150553051795437704;
                } else {
                    current_block = 16461086007676469871;
                }
            } else {
                current_block = 16461086007676469871;
            }
        } else {
            current_block = 16461086007676469871;
        }
        match current_block {
            10150553051795437704 => {}
            _ => {
                if 2 as libc::c_longlong > k {
                    if adverb as UI == offsetOver as UI {
                        if fom == 0 {
                            tmp___15 = overMonad(a, p, b___1);
                            return tmp___15;
                        } else {
                            tmp___16 = overMonad(
                                *((*b___1).k)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize),
                                p,
                                *((*b___1).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                            );
                            return tmp___16;
                        }
                    }
                    if adverb as UI == offsetScan as UI {
                        tmp___17 = scanMonad(a, p, b___1);
                        return tmp___17;
                    }
                    if adverb as UI == offsetEach as UI {
                        tmp___18 = each2(a, p, b___1);
                        return tmp___18;
                    }
                }
                current_block = 15650704408606443395;
            }
        }
    }
    match current_block {
        10150553051795437704 => {
            if adverb as UI == offsetOver as UI {
                tmp___6 = overDyad(a, p, b___1);
                return tmp___6;
            }
            if adverb as UI == offsetScan as UI {
                tmp___7 = scanDyad(a, p, b___1);
                return tmp___7;
            }
            if adverb as UI == offsetEach as UI {
                if a.is_null() {
                    adverb = offsetEachright as V;
                } else {
                    if (*a).t <= 0 as libc::c_longlong {
                        if (*b___1).t <= 0 as libc::c_longlong {
                            if (*a).n != (*b___1).n {
                                tmp___8 = kerr(
                                    b"length\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___8;
                            }
                        }
                    }
                    if (*a).t > 0 as libc::c_longlong {
                        if (*b___1).t > 0 as libc::c_longlong {
                            tmp___9 = dv_ex(
                                a,
                                p.offset(-(1 as libc::c_int as isize)),
                                b___1,
                            );
                            return tmp___9;
                        }
                    }
                    if (*a).t > 0 as libc::c_longlong {
                        adverb = offsetEachright as V;
                    } else if (*b___1).t > 0 as libc::c_longlong {
                        adverb = offsetEachleft as V;
                    } else {
                        a = promote(a);
                        b___1 = promote(b___1);
                        tmp___10 = OOM_CD(
                            0 as libc::c_int as I,
                            a,
                            b___1,
                            -(1 as libc::c_int) as V,
                        );
                        if tmp___10 == 0 {
                            return 0 as K;
                        }
                        tmp___11 = newK(0 as libc::c_int as I, (*a).n);
                        z = tmp___11;
                        tmp___12 = OOM_CD(
                            0 as libc::c_int as I,
                            z,
                            a,
                            b___1,
                            -(1 as libc::c_int) as V,
                        );
                        if tmp___12 == 0 {
                            return 0 as K;
                        }
                        i = 0 as libc::c_int as I;
                        _i___0 = (*a).n;
                        while i < _i___0 {
                            k___0 = dv_ex(
                                *((*a).k).as_mut_ptr().offset(i as isize),
                                p.offset(-(1 as libc::c_int as isize)),
                                *((*b___1).k).as_mut_ptr().offset(i as isize),
                            );
                            tmp___13 = OOM_CD(
                                0 as libc::c_int as I,
                                k___0,
                                z,
                                a,
                                b___1,
                                -(1 as libc::c_int) as V,
                            );
                            if tmp___13 == 0 {
                                return 0 as K;
                            }
                            let ref mut fresh134 = *((*z).k)
                                .as_mut_ptr()
                                .offset(i as isize);
                            *fresh134 = k___0;
                            i += 1;
                        }
                        cd(a);
                        cd(b___1);
                        tmp___14 = demote(z);
                        return tmp___14;
                    }
                }
            }
        }
        _ => {}
    }
    if adverb as UI == offsetEachright as UI {
        tmp___19 = eachright2(a, p, b___1);
        return tmp___19;
    }
    if adverb as UI == offsetEachleft as UI {
        tmp___20 = eachleft2(a, p, b___1);
        return tmp___20;
    }
    if adverb as UI == offsetEachpair as UI {
        tmp___21 = eachpair2(a, p, b___1);
        return tmp___21;
    }
    gn = 0 as libc::c_int as I;
    tmp___24 = valence(*p);
    if tmp___24 >= 2 as libc::c_longlong {
        if !a.is_null() {
            if !b___1.is_null() {
                gn = 2 as libc::c_int as I;
                current_block = 9216188846964669005;
            } else {
                current_block = 17416802831052951373;
            }
        } else {
            current_block = 17416802831052951373;
        }
    } else {
        current_block = 17416802831052951373;
    }
    match current_block {
        17416802831052951373 => {
            if !a.is_null() {
                q[0 as libc::c_int as usize] = &mut a as *mut K as V;
                q[1 as libc::c_int as usize] = 1 as libc::c_int as V;
                q[2 as libc::c_int as usize] = &mut b___1 as *mut K as V;
                q[3 as libc::c_int as usize] = 0 as V;
                tmp___22 = ex0(
                    &mut *q.as_mut_ptr().offset(0 as libc::c_int as isize),
                    0 as K,
                    2 as libc::c_int as I,
                );
                u = tmp___22;
                q[0 as libc::c_int as usize] = *p;
                q[1 as libc::c_int as usize] = 0 as V;
                tmp___23 = ex0(
                    &mut *q.as_mut_ptr().offset(0 as libc::c_int as isize),
                    u,
                    1 as libc::c_int as I,
                );
                v = tmp___23;
                cd(u);
                return v;
            } else {
                if !b___1.is_null() {
                    gn = 1 as libc::c_int as I;
                }
            }
        }
        _ => {}
    }
    tmp___25 = newK(0 as libc::c_int as I, gn);
    g = tmp___25;
    if g.is_null() {
        return 0 as K;
    }
    if gn > 1 as libc::c_longlong {
        let ref mut fresh135 = *((*g).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        *fresh135 = b___1;
    }
    if gn > 0 as libc::c_longlong {
        if !a.is_null() {
            let ref mut fresh136 = *((*g).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh136 = a;
        } else {
            let ref mut fresh137 = *((*g).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh137 = b___1;
        }
    }
    flag = 0 as libc::c_int as I;
    if *p as UI > DT_SIZE as UI {
        if (*b___1).n != 0 {
            p1 = *p as *mut V;
            if *p1 as UI > DT_SIZE as UI {
                p2 = *p1 as K;
                if 7 as libc::c_longlong != (*p2).t {
                    if -(1 as libc::c_longlong) != (*p2).t {
                        if 5 as libc::c_longlong != (*p2).t {
                            flag = 1 as libc::c_int as I;
                        }
                    }
                }
            }
        }
    }
    if flag != 0 {
        tmp___26 = vf_ex(*p, b___1);
    } else {
        if stk as libc::c_double > 2e6f64 {
            tmp___27 = kerr(b"stack\0" as *const u8 as *const libc::c_char);
            return tmp___27;
        }
        stk += 1;
        tmp___26 = vf_ex(*p, g);
        stk -= 1;
        if !grnt.is_null() {
            if prnt.is_null() {
                prnt = ci(grnt);
            }
        }
    }
    memset(
        ((*g).k).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ((*g).n as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<K>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    cd(g);
    return tmp___26;
}
pub unsafe extern "C" fn vf_ex(mut q: V, mut g: K) -> K {
    let mut current_block: u64;
    let mut tc: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut gn: I = 0;
    let mut k: I = 0;
    let mut tmp___0: I = 0;
    let mut n: I = 0;
    let mut j: I = 0;
    let mut ee: I = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut w___0: [V; 2] = [0 as *mut libc::c_void; 2];
    let mut tmp___3: K = 0 as *mut k0;
    let mut argc: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut a: K = 0 as *mut k0;
    let mut b___1: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut tmp___4: Option::<unsafe extern "C" fn(K, K, K) -> K> = None;
    let mut tmp___5: Option::<unsafe extern "C" fn(K, K, K, K) -> K> = None;
    let mut v: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut kb: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: I = 0;
    let mut f: K = 0 as *mut k0;
    let mut ft: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut o: K = 0 as *mut k0;
    let mut p: K = 0 as *mut k0;
    let mut s: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut special: I = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut ii: I = 0;
    let mut u: *mut V = 0 as *mut V;
    let mut tmp___11: I = 0;
    let mut ae: I = 0;
    let mut m: *mut K = 0 as *mut K;
    let mut q___0: *mut K = 0 as *mut K;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___12: I = 0;
    let mut w___1: [V; 5] = [0 as *mut libc::c_void; 5];
    let mut zz: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut v___0: V = 0 as *mut libc::c_void;
    let mut tree: K = 0 as *mut k0;
    let mut m___0: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut q___1: *mut K = 0 as *mut K;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___15: I = 0;
    let mut w___2: *mut V = 0 as *mut V;
    let mut a___0: [K; 7] = [0 as *mut k0; 7];
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___16: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___17: I = 0;
    let mut j___0: I = 0;
    let mut e: *mut K = 0 as *mut K;
    let mut fw: K = 0 as *mut k0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___18: *mut k0 = 0 as *mut k0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut j___1: I = 0;
    let mut _j: I = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: K = 0 as *mut k0;
    let mut j0___0: K = 0 as *mut k0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut j1___0: K = 0 as *mut k0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut j2: K = 0 as *mut k0;
    let mut tmp___25: K = 0 as *mut k0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut tmp___27: K = 0 as *mut k0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: I = 0;
    let mut t___0: I = 0;
    let mut fc: K = 0 as *mut k0;
    let mut tmp___30: K = 0 as *mut k0;
    let mut tt: I = 0;
    let mut ttt: I = 0;
    let mut i___7: I = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: K = 0 as *mut k0;
    let mut i___8: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut ff: I = 0;
    let mut i___9: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut d___1: K = 0 as *mut k0;
    let mut w___3: K = 0 as *mut k0;
    let mut i___10: I = 0;
    let mut _i___10: I = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut p___0: K = 0 as *mut k0;
    let mut we: K = 0 as *mut k0;
    let mut tmp___37: K = 0 as *mut k0;
    let mut j0___1: K = 0 as *mut k0;
    let mut tmp___38: K = 0 as *mut k0;
    let mut j2___0: K = 0 as *mut k0;
    let mut tmp___39: K = 0 as *mut k0;
    let mut tmp___40: K = 0 as *mut k0;
    let mut ff___0: I = 0;
    let mut i___11: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___41: libc::c_int = 0;
    let mut tmp___42: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut d___2: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut i___12: I = 0;
    let mut _i___12: I = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: K = 0 as *mut k0;
    let mut p___1: K = 0 as *mut k0;
    let mut ye: K = 0 as *mut k0;
    let mut tmp___45: K = 0 as *mut k0;
    let mut j0___2: K = 0 as *mut k0;
    let mut tmp___46: K = 0 as *mut k0;
    let mut j2___1: K = 0 as *mut k0;
    let mut tmp___47: K = 0 as *mut k0;
    let mut tmp___48: K = 0 as *mut k0;
    let mut ff___1: I = 0;
    let mut i___13: I = 0;
    let mut _i___13: I = 0;
    let mut tmp___49: libc::c_int = 0;
    let mut tmp___50: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut xx: K = 0 as *mut k0;
    let mut tmp___51: K = 0 as *mut k0;
    let mut tmp___52: S = 0 as *mut C;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___53: K = 0 as *mut k0;
    let mut tmp___54: K = 0 as *mut k0;
    let mut tmp___55: K = 0 as *mut k0;
    let mut p___2: K = 0 as *mut k0;
    let mut xe: K = 0 as *mut k0;
    let mut tmp___56: K = 0 as *mut k0;
    let mut j0___3: K = 0 as *mut k0;
    let mut tmp___57: K = 0 as *mut k0;
    let mut j2___2: K = 0 as *mut k0;
    let mut tmp___58: K = 0 as *mut k0;
    let mut tmp___59: K = 0 as *mut k0;
    tc = 0 as K;
    if interrupted != 0 {
        interrupted = 0 as libc::c_int;
        tmp = kerr(b"break\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if g.is_null() {
        return 0 as K;
    }
    z = 0 as K;
    g = promote(g);
    if g.is_null() {
        return 0 as K;
    }
    gn = (*g).n;
    tmp___0 = sva(q);
    k = tmp___0;
    n = -(1 as libc::c_int) as I;
    j = 0 as libc::c_int as I;
    if k == 0 {
        if (*(q as *mut V)).is_null() {
            cd(g);
            return 0 as K;
        }
    }
    n = valence(q);
    ee = 0 as libc::c_int as I;
    if q as libc::c_ulong > DT_SIZE as V as libc::c_ulong {
        h = *(q as *mut K);
        if (*h).t == 7 as libc::c_longlong {
            if (*h).n == 1 as libc::c_longlong {
                if !(*((*h).k).as_mut_ptr().offset(2 as libc::c_int as isize)).is_null()
                {
                    if *((**((*h).k).as_mut_ptr().offset(2 as libc::c_int as isize)).k)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize) as UI > DT_SIZE as UI
                    {
                        if (**((*h).k).as_mut_ptr().offset(2 as libc::c_int as isize)).n
                            == 3 as libc::c_longlong
                        {
                            if (**(*(((**((*h).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr() as *mut S)
                                .offset(0 as libc::c_int as isize) as *mut K))
                                .t == 0 as libc::c_longlong
                            {
                                z = dot(
                                    *(*(((**((*h).k)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr() as *mut S)
                                        .offset(0 as libc::c_int as isize) as *mut K),
                                    g,
                                );
                                current_block = 8790795054853801794;
                            } else {
                                current_block = 12705158477165241210;
                            }
                        } else {
                            current_block = 12705158477165241210;
                        }
                        match current_block {
                            8790795054853801794 => {}
                            _ => {
                                if *((**((*h).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize) as UI
                                    == 58 as libc::c_ulonglong
                                {
                                    if (*g).t == 0 as libc::c_longlong {
                                        z = dot(
                                            *(*(((**((*h).k)
                                                .as_mut_ptr()
                                                .offset(2 as libc::c_int as isize))
                                                .k)
                                                .as_mut_ptr() as *mut S)
                                                .offset(0 as libc::c_int as isize) as *mut K),
                                            *((*g).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                                        );
                                        current_block = 8790795054853801794;
                                    } else {
                                        current_block = 3634396408142324656;
                                    }
                                } else {
                                    current_block = 3634396408142324656;
                                }
                            }
                        }
                    } else {
                        current_block = 3634396408142324656;
                    }
                } else {
                    current_block = 3634396408142324656;
                }
                match current_block {
                    8790795054853801794 => {}
                    _ => {
                        if *(((**((*h).k).as_mut_ptr().offset(2 as libc::c_int as isize))
                            .k)
                            .as_mut_ptr() as *mut S)
                            .offset(0 as libc::c_int as isize) as V as libc::c_ulong
                            > DT_SIZE as V as libc::c_ulong
                        {
                            if (**(*(((**((*h).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr() as *mut S)
                                .offset(0 as libc::c_int as isize) as *mut K))
                                .t == 7 as libc::c_longlong
                            {
                                n = 2 as libc::c_int as I;
                                ee = 1 as libc::c_int as I;
                            }
                        }
                        current_block = 1428307939028130064;
                    }
                }
            } else {
                current_block = 1428307939028130064;
            }
            match current_block {
                8790795054853801794 => {}
                _ => {
                    if -(4 as libc::c_longlong)
                        == (**((*h).k).as_mut_ptr().offset(2 as libc::c_int as isize)).t
                    {
                        if 2 as libc::c_longlong
                            == (**((*h).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .n
                        {
                            if *(((**((*h).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr() as *mut V)
                                .offset(0 as libc::c_int as isize) as libc::c_ulong
                                == 58 as libc::c_int as V as libc::c_ulong
                            {
                                if 0 as libc::c_longlong == (*g).t {
                                    if 0 as *mut libc::c_void as libc::c_ulong
                                        == *(((*g).k).as_mut_ptr() as *mut V)
                                            .offset(0 as libc::c_int as isize) as libc::c_ulong
                                    {
                                        z = ci(*(q as *mut K));
                                        tmp___1 = ci(g);
                                        let ref mut fresh138 = *(((*z).k).as_mut_ptr() as *mut V)
                                            .offset(5 as libc::c_int as isize);
                                        *fresh138 = tmp___1 as V;
                                        current_block = 8790795054853801794;
                                    } else if 6 as libc::c_longlong
                                            == (**((*g).k)
                                                .as_mut_ptr()
                                                .offset(0 as libc::c_int as isize))
                                                .t
                                        {
                                        z = ci(*(q as *mut K));
                                        tmp___2 = ci(
                                            *((*z).k).as_mut_ptr().offset(4 as libc::c_int as isize),
                                        );
                                        let ref mut fresh139 = *(((*z).k).as_mut_ptr() as *mut V)
                                            .offset(5 as libc::c_int as isize);
                                        *fresh139 = tmp___2 as V;
                                        *(*((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize))
                                            .offset(
                                                0 as libc::c_int as isize,
                                            ) = *(*((*z).k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .offset(1 as libc::c_int as isize);
                                        ci(
                                            *((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize),
                                        );
                                        current_block = 8790795054853801794;
                                    } else {
                                        current_block = 12543410360505780601;
                                    }
                                } else {
                                    current_block = 12543410360505780601;
                                }
                            } else {
                                current_block = 12543410360505780601;
                            }
                        } else {
                            current_block = 12543410360505780601;
                        }
                    } else {
                        current_block = 12543410360505780601;
                    }
                }
            }
        } else {
            current_block = 12543410360505780601;
        }
    } else {
        current_block = 12543410360505780601;
    }
    match current_block {
        12543410360505780601 => {
            if ee != 0 {
                if (*(((*g).k).as_mut_ptr() as *mut V).offset(0 as libc::c_int as isize))
                    .is_null()
                {
                    if !(*(((*g).k).as_mut_ptr() as *mut V)
                        .offset(1 as libc::c_int as isize))
                        .is_null()
                    {
                        fom = 1 as libc::c_int as I;
                    }
                }
            }
            if k != 0 {
                current_block = 2258852089132303198;
            } else if (**(q as *mut K)).t == 7 as libc::c_longlong {
                current_block = 2258852089132303198;
            } else {
                current_block = 16236176907488530475;
            }
            match current_block {
                2258852089132303198 => {
                    if (q as UI) < DT_SIZE as UI {
                        current_block = 11482800488730663322;
                    } else if !(*(q as *mut V)).is_null() {
                        current_block = 11482800488730663322;
                    } else {
                        current_block = 16236176907488530475;
                    }
                    match current_block {
                        16236176907488530475 => {}
                        _ => {
                            if gn > n {
                                if n == 0 {
                                    if 1 as libc::c_longlong >= gn {
                                        current_block = 16236176907488530475;
                                    } else {
                                        current_block = 15154998508048084256;
                                    }
                                } else {
                                    current_block = 15154998508048084256;
                                }
                            } else {
                                current_block = 16236176907488530475;
                            }
                        }
                    }
                }
                _ => {}
            }
            match current_block {
                16236176907488530475 => {
                    if ee != 0 {
                        if !(*(((*g).k).as_mut_ptr() as *mut V)
                            .offset(0 as libc::c_int as isize))
                            .is_null()
                        {
                            if !(*(((*g).k).as_mut_ptr() as *mut V)
                                .offset(1 as libc::c_int as isize))
                                .is_null()
                            {
                                current_block = 15154998508048084256;
                            } else {
                                current_block = 3990161529967994542;
                            }
                        } else {
                            current_block = 3990161529967994542;
                        }
                    } else {
                        current_block = 3990161529967994542;
                    }
                }
                _ => {}
            }
            match current_block {
                15154998508048084256 => {
                    if *((*g).k).as_mut_ptr().offset(0 as libc::c_int as isize)
                        as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                    {
                        kerr(b"valence\0" as *const u8 as *const libc::c_char);
                        current_block = 8790795054853801794;
                    } else {
                        if 3 as libc::c_longlong
                            != (**((*g).k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize))
                                .t
                        {
                            current_block = 11372902183034008888;
                        } else if 1 as libc::c_longlong == (**(q as *mut K)).n {
                            current_block = 11372902183034008888;
                        } else if *((*g).k)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize) as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                            current_block = 11372902183034008888;
                        } else {
                            tmp___3 = collapse(g);
                            g = enlist(tmp___3);
                            gn = (*g).n;
                            cd(*((*g).k).as_mut_ptr().offset(0 as libc::c_int as isize));
                            current_block = 3990161529967994542;
                        }
                        match current_block {
                            3990161529967994542 => {}
                            _ => {
                                if (*g).t == 0 as libc::c_longlong {
                                    if gn == 2 as libc::c_longlong {
                                        if (**((**(q as *mut K)).k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .t == -(4 as libc::c_longlong)
                                        {
                                            if *(((**((**(q as *mut K)).k)
                                                .as_mut_ptr()
                                                .offset(2 as libc::c_int as isize))
                                                .k)
                                                .as_mut_ptr() as *mut S)
                                                .offset(0 as libc::c_int as isize) as V as libc::c_ulong
                                                > DT_SIZE as V as libc::c_ulong
                                            {
                                                if (**(*(((**((**(q as *mut K)).k)
                                                    .as_mut_ptr()
                                                    .offset(2 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr() as *mut S)
                                                    .offset(0 as libc::c_int as isize) as *mut K))
                                                    .t == 7 as libc::c_longlong
                                                {
                                                    w___0[0 as libc::c_int
                                                        as usize] = *(((**((**(q as *mut K)).k)
                                                        .as_mut_ptr()
                                                        .offset(2 as libc::c_int as isize))
                                                        .k)
                                                        .as_mut_ptr() as *mut S)
                                                        .offset(0 as libc::c_int as isize) as V;
                                                    w___0[1 as libc::c_int as usize] = offsetOver as V;
                                                    z = overMonad(
                                                        *((*g).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                                                        &mut *w___0.as_mut_ptr().offset(1 as libc::c_int as isize),
                                                        *((*g).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                                                    );
                                                } else {
                                                    kerr(b"valence\0" as *const u8 as *const libc::c_char);
                                                }
                                            } else {
                                                kerr(b"valence\0" as *const u8 as *const libc::c_char);
                                            }
                                        } else {
                                            kerr(b"valence\0" as *const u8 as *const libc::c_char);
                                        }
                                    } else {
                                        kerr(b"valence\0" as *const u8 as *const libc::c_char);
                                    }
                                } else {
                                    kerr(b"valence\0" as *const u8 as *const libc::c_char);
                                }
                                current_block = 8790795054853801794;
                            }
                        }
                    }
                }
                _ => {}
            }
            match current_block {
                8790795054853801794 => {}
                _ => {
                    argc = 0 as libc::c_int as I;
                    i = 0 as libc::c_int as I;
                    _i___0 = gn;
                    while i < _i___0 {
                        if !(*((*g).k).as_mut_ptr().offset(i as isize)).is_null() {
                            argc += 1;
                        }
                        i += 1;
                    }
                    a = 0 as K;
                    b___1 = 0 as K;
                    c = 0 as K;
                    d___0 = 0 as K;
                    if gn > 0 as libc::c_longlong {
                        a = *((*g).k).as_mut_ptr().offset(0 as libc::c_int as isize);
                    }
                    if gn > 1 as libc::c_longlong {
                        b___1 = *((*g).k).as_mut_ptr().offset(1 as libc::c_int as isize);
                    }
                    if gn > 2 as libc::c_longlong {
                        c = *((*g).k).as_mut_ptr().offset(2 as libc::c_int as isize);
                    }
                    if gn > 3 as libc::c_longlong {
                        d___0 = *((*g).k).as_mut_ptr().offset(3 as libc::c_int as isize);
                    }
                    if gn > 2 as libc::c_longlong {
                        if q as libc::c_ulong == offsetWhat as libc::c_ulong {
                            current_block = 17710679548441576800;
                        } else if q as libc::c_ulong == offsetSSR as libc::c_ulong {
                            current_block = 17710679548441576800;
                        } else {
                            current_block = 8966873693763611635;
                        }
                        match current_block {
                            8966873693763611635 => {}
                            _ => {
                                if q as libc::c_ulong == offsetWhat as libc::c_ulong {
                                    tmp___4 = Some(
                                        what_triadic as unsafe extern "C" fn(K, K, K) -> K,
                                    );
                                } else {
                                    tmp___4 = Some(_ssr as unsafe extern "C" fn(K, K, K) -> K);
                                }
                                z = (Some(tmp___4.expect("non-null function pointer")))
                                    .expect("non-null function pointer")(a, b___1, c);
                                current_block = 8790795054853801794;
                            }
                        }
                    } else {
                        current_block = 8966873693763611635;
                    }
                    match current_block {
                        8790795054853801794 => {}
                        _ => {
                            if gn > 2 as libc::c_longlong {
                                if q as libc::c_ulong == offsetAt as libc::c_ulong {
                                    current_block = 5545054561093443846;
                                } else if q as libc::c_ulong == offsetDot as libc::c_ulong {
                                    current_block = 5545054561093443846;
                                } else {
                                    current_block = 16477797002856340645;
                                }
                                match current_block {
                                    16477797002856340645 => {}
                                    _ => {
                                        if q as libc::c_ulong == offsetAt as libc::c_ulong {
                                            tmp___5 = Some(
                                                at_tetradic as unsafe extern "C" fn(K, K, K, K) -> K,
                                            );
                                        } else {
                                            tmp___5 = Some(
                                                dot_tetradic as unsafe extern "C" fn(K, K, K, K) -> K,
                                            );
                                        }
                                        z = (Some(tmp___5.expect("non-null function pointer")))
                                            .expect("non-null function pointer")(a, b___1, c, d___0);
                                        current_block = 8790795054853801794;
                                    }
                                }
                            } else {
                                current_block = 16477797002856340645;
                            }
                            match current_block {
                                8790795054853801794 => {}
                                _ => {
                                    if 2 as libc::c_longlong == k {
                                        if !a.is_null() {
                                            if !b___1.is_null() {
                                                fnc = DT[q as L as usize].text;
                                                if fnci < 127 as libc::c_longlong {
                                                    fncp[fnci as usize] = q;
                                                    fnci += 1;
                                                }
                                                if !cls.is_null() {
                                                    if (*a).t == 6 as libc::c_longlong {
                                                        z = (Some(
                                                            (::std::mem::transmute::<
                                                                V,
                                                                Option::<unsafe extern "C" fn(K, K) -> K>,
                                                            >((*DT.as_mut_ptr().offset(q as L as isize)).func))
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect("non-null function pointer")(cls, b___1);
                                                    } else {
                                                        z = (Some(
                                                            (::std::mem::transmute::<
                                                                V,
                                                                Option::<unsafe extern "C" fn(K, K) -> K>,
                                                            >((*DT.as_mut_ptr().offset(q as L as isize)).func))
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect("non-null function pointer")(a, b___1);
                                                    }
                                                } else {
                                                    z = (Some(
                                                        (::std::mem::transmute::<
                                                            V,
                                                            Option::<unsafe extern "C" fn(K, K) -> K>,
                                                        >((*DT.as_mut_ptr().offset(q as L as isize)).func))
                                                            .expect("non-null function pointer"),
                                                    ))
                                                        .expect("non-null function pointer")(a, b___1);
                                                }
                                                current_block = 8790795054853801794;
                                            } else {
                                                current_block = 16394086363301712866;
                                            }
                                        } else {
                                            current_block = 16394086363301712866;
                                        }
                                    } else {
                                        current_block = 16394086363301712866;
                                    }
                                    match current_block {
                                        8790795054853801794 => {}
                                        _ => {
                                            if 2 as libc::c_longlong == k {
                                                if a.is_null() {
                                                    kerr(b"valence\0" as *const u8 as *const libc::c_char);
                                                    current_block = 8790795054853801794;
                                                } else {
                                                    current_block = 12003943868717696208;
                                                }
                                            } else {
                                                current_block = 12003943868717696208;
                                            }
                                            match current_block {
                                                8790795054853801794 => {}
                                                _ => {
                                                    if 2 as libc::c_longlong == k {
                                                        current_block = 10700375664254641117;
                                                    } else if q as libc::c_ulong == offsetSSR as libc::c_ulong {
                                                        current_block = 10700375664254641117;
                                                    } else {
                                                        current_block = 4533671380017093834;
                                                    }
                                                    match current_block {
                                                        10700375664254641117 => {
                                                            if b___1.is_null() {
                                                                tmp___6 = Kv();
                                                                v = tmp___6;
                                                                tmp___7 = newK(
                                                                    -(4 as libc::c_int) as I,
                                                                    2 as libc::c_int as I,
                                                                );
                                                                kb = tmp___7;
                                                                tmp___8 = OOM_CD(
                                                                    0 as libc::c_int as I,
                                                                    v,
                                                                    kb,
                                                                    -(1 as libc::c_int) as V,
                                                                );
                                                                if tmp___8 == 0 {
                                                                    return 0 as K;
                                                                }
                                                                let ref mut fresh140 = *((*kb).k)
                                                                    .as_mut_ptr()
                                                                    .offset(0 as libc::c_int as isize);
                                                                *fresh140 = q as *mut k0;
                                                                let ref mut fresh141 = *((*kb).k)
                                                                    .as_mut_ptr()
                                                                    .offset(1 as libc::c_int as isize);
                                                                *fresh141 = 0 as *mut k0;
                                                                let ref mut fresh142 = *(((*v).k).as_mut_ptr() as *mut V)
                                                                    .offset(2 as libc::c_int as isize);
                                                                *fresh142 = kb as V;
                                                                z = vf_ex(&mut v as *mut K as V, g);
                                                                cd(v);
                                                                current_block = 8790795054853801794;
                                                            } else {
                                                                current_block = 4533671380017093834;
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                    match current_block {
                                                        8790795054853801794 => {}
                                                        _ => {
                                                            if 1 as libc::c_longlong == k {
                                                                if !a.is_null() {
                                                                    z = (Some(
                                                                        (::std::mem::transmute::<
                                                                            V,
                                                                            Option::<unsafe extern "C" fn(K) -> K>,
                                                                        >((*DT.as_mut_ptr().offset(q as L as isize)).func))
                                                                            .expect("non-null function pointer"),
                                                                    ))
                                                                        .expect("non-null function pointer")(a);
                                                                    current_block = 8790795054853801794;
                                                                } else {
                                                                    current_block = 13114814261106982490;
                                                                }
                                                            } else {
                                                                current_block = 13114814261106982490;
                                                            }
                                                            match current_block {
                                                                8790795054853801794 => {}
                                                                _ => {
                                                                    if 1 as libc::c_longlong == k {
                                                                        if a.is_null() {
                                                                            current_block = 8790795054853801794;
                                                                        } else {
                                                                            current_block = 8700473759921513224;
                                                                        }
                                                                    } else {
                                                                        current_block = 8700473759921513224;
                                                                    }
                                                                    match current_block {
                                                                        8790795054853801794 => {}
                                                                        _ => {
                                                                            f = *(q as *mut V) as K;
                                                                            ft = (*f).t;
                                                                            if ft != 7 as libc::c_longlong {
                                                                                if !g.is_null() {
                                                                                    tmp___9 = dot(f, g);
                                                                                    z = tmp___9;
                                                                                } else {
                                                                                    z = f;
                                                                                }
                                                                            } else {
                                                                                t = (*f).n;
                                                                                if -(1 as libc::c_longlong) == n {
                                                                                    n = valence(f as V);
                                                                                }
                                                                                o = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                    .offset(2 as libc::c_int as isize) as K;
                                                                                p = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                    .offset(4 as libc::c_int as isize) as K;
                                                                                s = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                    .offset(3 as libc::c_int as isize) as K;
                                                                                r = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                    .offset(5 as libc::c_int as isize) as K;
                                                                                if 1 as libc::c_longlong == t {
                                                                                    if r.is_null() {
                                                                                        if offsetAt as libc::c_ulong
                                                                                            == *(((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                .offset(2 as libc::c_int as isize) as K))
                                                                                                .k)
                                                                                                .as_mut_ptr() as *mut S as *mut V) as libc::c_ulong
                                                                                        {
                                                                                            tmp___10 = 1 as libc::c_int;
                                                                                        } else if offsetDot as libc::c_ulong
                                                                                                == *(((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                    .offset(2 as libc::c_int as isize) as K))
                                                                                                    .k)
                                                                                                    .as_mut_ptr() as *mut S as *mut V) as libc::c_ulong
                                                                                            {
                                                                                            tmp___10 = 1 as libc::c_int;
                                                                                        } else if offsetWhat as libc::c_ulong
                                                                                                == *(((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                    .offset(2 as libc::c_int as isize) as K))
                                                                                                    .k)
                                                                                                    .as_mut_ptr() as *mut S as *mut V) as libc::c_ulong
                                                                                            {
                                                                                            tmp___10 = 1 as libc::c_int;
                                                                                        } else {
                                                                                            tmp___10 = 0 as libc::c_int;
                                                                                        }
                                                                                    } else {
                                                                                        tmp___10 = 0 as libc::c_int;
                                                                                    }
                                                                                } else {
                                                                                    tmp___10 = 0 as libc::c_int;
                                                                                }
                                                                                special = tmp___10 as I;
                                                                                if (*o).t != -(3 as libc::c_longlong) {
                                                                                    ii = (*o).n - 2 as libc::c_longlong;
                                                                                    u = (((*o).k).as_mut_ptr() as *mut V).offset(ii as isize);
                                                                                    if 2 as libc::c_longlong == n {
                                                                                        tmp___11 = adverbClass(*u);
                                                                                        if 1 as libc::c_longlong == tmp___11 {
                                                                                            n = gn;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if (**((**(q as *mut K)).k)
                                                                                    .as_mut_ptr()
                                                                                    .offset(2 as libc::c_int as isize))
                                                                                    .n == 3 as libc::c_longlong
                                                                                {
                                                                                    if offsetWhat as libc::c_ulong
                                                                                        == *(((**((**(q as *mut K)).k)
                                                                                            .as_mut_ptr()
                                                                                            .offset(2 as libc::c_int as isize))
                                                                                            .k)
                                                                                            .as_mut_ptr() as *mut V)
                                                                                            .offset(1 as libc::c_int as isize) as libc::c_ulong
                                                                                    {
                                                                                        z = what(
                                                                                            *(*(((**((**(q as *mut K)).k)
                                                                                                .as_mut_ptr()
                                                                                                .offset(2 as libc::c_int as isize))
                                                                                                .k)
                                                                                                .as_mut_ptr() as *mut V)
                                                                                                .offset(0 as libc::c_int as isize) as *mut K),
                                                                                            *(((*g).k).as_mut_ptr() as *mut V as *mut K),
                                                                                        );
                                                                                        current_block = 8790795054853801794;
                                                                                    } else {
                                                                                        current_block = 10571249529392658292;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 10571249529392658292;
                                                                                }
                                                                                match current_block {
                                                                                    8790795054853801794 => {}
                                                                                    _ => {
                                                                                        if n != 0 {
                                                                                            if argc < gn {
                                                                                                current_block = 13616401549965075053;
                                                                                            } else if gn < n {
                                                                                                if special == 0 {
                                                                                                    current_block = 13616401549965075053;
                                                                                                } else if gn <= 1 as libc::c_longlong {
                                                                                                    current_block = 13616401549965075053;
                                                                                                } else {
                                                                                                    current_block = 14898553815918780345;
                                                                                                }
                                                                                            } else {
                                                                                                current_block = 14898553815918780345;
                                                                                            }
                                                                                            match current_block {
                                                                                                14898553815918780345 => {}
                                                                                                _ => {
                                                                                                    z = kcloneI(
                                                                                                        f,
                                                                                                        b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                        482 as libc::c_int,
                                                                                                    );
                                                                                                    if z.is_null() {
                                                                                                        current_block = 8790795054853801794;
                                                                                                    } else {
                                                                                                        ae = 0 as libc::c_int as I;
                                                                                                        m = (((*z).k).as_mut_ptr() as *mut V as *mut K)
                                                                                                            .offset(5 as libc::c_int as isize);
                                                                                                        if special != 0 {
                                                                                                            if gn != 4 as libc::c_longlong {
                                                                                                                n = 2 as libc::c_int as I;
                                                                                                            }
                                                                                                        }
                                                                                                        if (3 as libc::c_longlong)
                                                                                                            < (**((*z).k)
                                                                                                                .as_mut_ptr()
                                                                                                                .offset(2 as libc::c_int as isize))
                                                                                                                .n
                                                                                                        {
                                                                                                            if *((**((*z).k)
                                                                                                                .as_mut_ptr()
                                                                                                                .offset(2 as libc::c_int as isize))
                                                                                                                .k)
                                                                                                                .as_mut_ptr()
                                                                                                                .offset(1 as libc::c_int as isize) as *mut V
                                                                                                                as libc::c_ulong == offsetAt as libc::c_ulong
                                                                                                            {
                                                                                                                if *((**((*z).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(2 as libc::c_int as isize))
                                                                                                                    .k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(2 as libc::c_int as isize) as *mut V
                                                                                                                    as libc::c_ulong == offsetEach as V as libc::c_ulong
                                                                                                                {
                                                                                                                    ae = 1 as libc::c_int as I;
                                                                                                                    n = 1 as libc::c_int as I;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        if (*m).is_null() {
                                                                                                            *m = newK(0 as libc::c_int as I, n);
                                                                                                        }
                                                                                                        if (*m).is_null() {
                                                                                                            cd(z);
                                                                                                        } else {
                                                                                                            q___0 = ((**m).k).as_mut_ptr();
                                                                                                            i___0 = 0 as libc::c_int as I;
                                                                                                            _i___1 = (**m).n;
                                                                                                            while i___0 < _i___1 {
                                                                                                                if (*q___0.offset(i___0 as isize)).is_null() {
                                                                                                                    if j < gn {
                                                                                                                        tmp___12 = j;
                                                                                                                        j += 1;
                                                                                                                        let ref mut fresh143 = *q___0.offset(i___0 as isize);
                                                                                                                        *fresh143 = ci(
                                                                                                                            *((*g).k).as_mut_ptr().offset(tmp___12 as isize),
                                                                                                                        );
                                                                                                                    }
                                                                                                                }
                                                                                                                i___0 += 1;
                                                                                                            }
                                                                                                            if ae != 0 {
                                                                                                                w___1[0 as libc::c_int
                                                                                                                    as usize] = *(((**((*z).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(2 as libc::c_int as isize))
                                                                                                                    .k)
                                                                                                                    .as_mut_ptr() as *mut S)
                                                                                                                    .offset(0 as libc::c_int as isize) as V;
                                                                                                                w___1[1 as libc::c_int as usize] = offsetAt;
                                                                                                                w___1[2 as libc::c_int as usize] = offsetEach as V;
                                                                                                                w___1[3 as libc::c_int
                                                                                                                    as usize] = ((**((*z).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(5 as libc::c_int as isize))
                                                                                                                    .k)
                                                                                                                    .as_mut_ptr() as V;
                                                                                                                w___1[4 as libc::c_int as usize] = 0 as V;
                                                                                                                tmp___13 = ex2(
                                                                                                                    &mut *w___1.as_mut_ptr().offset(0 as libc::c_int as isize),
                                                                                                                    0 as K,
                                                                                                                );
                                                                                                                zz = tmp___13;
                                                                                                                cd(g);
                                                                                                                cd(z);
                                                                                                                return zz;
                                                                                                            }
                                                                                                        }
                                                                                                        current_block = 8790795054853801794;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 14898553815918780345;
                                                                                        }
                                                                                        match current_block {
                                                                                            8790795054853801794 => {}
                                                                                            _ => {
                                                                                                match t {
                                                                                                    1 => {
                                                                                                        if r.is_null() {
                                                                                                            z = ex2(
                                                                                                                ((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                    .offset(2 as libc::c_int as isize) as K))
                                                                                                                    .k)
                                                                                                                    .as_mut_ptr() as *mut S as *mut V,
                                                                                                                g,
                                                                                                            );
                                                                                                            current_block = 8790795054853801794;
                                                                                                        } else {
                                                                                                            tmp___14 = newK(0 as libc::c_int as I, (*r).n);
                                                                                                            m___0 = tmp___14;
                                                                                                            if m___0.is_null() {
                                                                                                                current_block = 8790795054853801794;
                                                                                                            } else {
                                                                                                                q___1 = ((*m___0).k).as_mut_ptr();
                                                                                                                i___1 = 0 as libc::c_int as I;
                                                                                                                _i___2 = (*m___0).n;
                                                                                                                while i___1 < _i___2 {
                                                                                                                    let ref mut fresh144 = *q___1.offset(i___1 as isize);
                                                                                                                    *fresh144 = ci(
                                                                                                                        *((*r).k).as_mut_ptr().offset(i___1 as isize),
                                                                                                                    );
                                                                                                                    if (*q___1.offset(i___1 as isize)).is_null() {
                                                                                                                        if j < gn {
                                                                                                                            tmp___15 = j;
                                                                                                                            j += 1;
                                                                                                                            let ref mut fresh145 = *q___1.offset(i___1 as isize);
                                                                                                                            *fresh145 = ci(
                                                                                                                                *((*g).k).as_mut_ptr().offset(tmp___15 as isize),
                                                                                                                            );
                                                                                                                        }
                                                                                                                    }
                                                                                                                    i___1 += 1;
                                                                                                                }
                                                                                                                if prj != 0 {
                                                                                                                    w___2 = (((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                        .offset(2 as libc::c_int as isize) as K))
                                                                                                                        .k)
                                                                                                                        .as_mut_ptr() as *mut S as *mut V)
                                                                                                                        .offset(1 as libc::c_int as isize);
                                                                                                                    z = bv_ex(w___2, m___0);
                                                                                                                } else {
                                                                                                                    z = ex2(
                                                                                                                        ((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(2 as libc::c_int as isize) as K))
                                                                                                                            .k)
                                                                                                                            .as_mut_ptr() as *mut S as *mut V,
                                                                                                                        m___0,
                                                                                                                    );
                                                                                                                }
                                                                                                                cd(m___0);
                                                                                                                current_block = 3325916876629046855;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    2 => {
                                                                                                        v___0 = *(((*(*(((*f).k).as_mut_ptr() as *mut V)
                                                                                                            .offset(2 as libc::c_int as isize) as K))
                                                                                                            .k)
                                                                                                            .as_mut_ptr() as *mut S as *mut V)
                                                                                                            .offset(1 as libc::c_int as isize);
                                                                                                        i___2 = 0 as libc::c_int as I;
                                                                                                        _i___3 = 7 as libc::c_int as I;
                                                                                                        while i___2 < _i___3 {
                                                                                                            a___0[i___2 as usize] = 0 as K;
                                                                                                            i___2 += 1;
                                                                                                        }
                                                                                                        if !r.is_null() {
                                                                                                            if (*r).n < 7 as libc::c_longlong {
                                                                                                                tmp___16 = (*r).n;
                                                                                                            } else {
                                                                                                                tmp___16 = 7 as libc::c_int as I;
                                                                                                            }
                                                                                                            memcpy(
                                                                                                                a___0.as_mut_ptr() as *mut libc::c_void,
                                                                                                                ((*r).k).as_mut_ptr() as *const libc::c_void,
                                                                                                                (tmp___16 as libc::c_ulonglong)
                                                                                                                    .wrapping_mul(
                                                                                                                        ::std::mem::size_of::<V>() as libc::c_ulong
                                                                                                                            as libc::c_ulonglong,
                                                                                                                    ) as size_t,
                                                                                                            );
                                                                                                        }
                                                                                                        i___3 = 0 as libc::c_int as I;
                                                                                                        _i___4 = 7 as libc::c_int as I;
                                                                                                        while i___3 < _i___4 {
                                                                                                            if (a___0[i___3 as usize]).is_null() {
                                                                                                                if j < gn {
                                                                                                                    tmp___17 = j;
                                                                                                                    j += 1;
                                                                                                                    a___0[i___3
                                                                                                                        as usize] = *((*g).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(tmp___17 as isize);
                                                                                                                }
                                                                                                            }
                                                                                                            i___3 += 1;
                                                                                                        }
                                                                                                        match n {
                                                                                                            0 => {
                                                                                                                z = ::std::mem::transmute::<
                                                                                                                    _,
                                                                                                                    fn() -> K,
                                                                                                                >(
                                                                                                                    (Some(
                                                                                                                        (::std::mem::transmute::<
                                                                                                                            V,
                                                                                                                            Option::<unsafe extern "C" fn() -> K>,
                                                                                                                        >(v___0))
                                                                                                                            .expect("non-null function pointer"),
                                                                                                                    ))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                )();
                                                                                                            }
                                                                                                            1 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(a___0[0 as libc::c_int as usize]);
                                                                                                            }
                                                                                                            2 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K, K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(
                                                                                                                    a___0[0 as libc::c_int as usize],
                                                                                                                    a___0[1 as libc::c_int as usize],
                                                                                                                );
                                                                                                            }
                                                                                                            3 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K, K, K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(
                                                                                                                    a___0[0 as libc::c_int as usize],
                                                                                                                    a___0[1 as libc::c_int as usize],
                                                                                                                    a___0[2 as libc::c_int as usize],
                                                                                                                );
                                                                                                            }
                                                                                                            4 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K, K, K, K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(
                                                                                                                    a___0[0 as libc::c_int as usize],
                                                                                                                    a___0[1 as libc::c_int as usize],
                                                                                                                    a___0[2 as libc::c_int as usize],
                                                                                                                    a___0[3 as libc::c_int as usize],
                                                                                                                );
                                                                                                            }
                                                                                                            5 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K, K, K, K, K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(
                                                                                                                    a___0[0 as libc::c_int as usize],
                                                                                                                    a___0[1 as libc::c_int as usize],
                                                                                                                    a___0[2 as libc::c_int as usize],
                                                                                                                    a___0[3 as libc::c_int as usize],
                                                                                                                    a___0[4 as libc::c_int as usize],
                                                                                                                );
                                                                                                            }
                                                                                                            6 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K, K, K, K, K, K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(
                                                                                                                    a___0[0 as libc::c_int as usize],
                                                                                                                    a___0[1 as libc::c_int as usize],
                                                                                                                    a___0[2 as libc::c_int as usize],
                                                                                                                    a___0[3 as libc::c_int as usize],
                                                                                                                    a___0[4 as libc::c_int as usize],
                                                                                                                    a___0[5 as libc::c_int as usize],
                                                                                                                );
                                                                                                            }
                                                                                                            7 => {
                                                                                                                z = (Some(
                                                                                                                    (::std::mem::transmute::<
                                                                                                                        V,
                                                                                                                        Option::<unsafe extern "C" fn(K, K, K, K, K, K, K) -> K>,
                                                                                                                    >(v___0))
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(
                                                                                                                    a___0[0 as libc::c_int as usize],
                                                                                                                    a___0[1 as libc::c_int as usize],
                                                                                                                    a___0[2 as libc::c_int as usize],
                                                                                                                    a___0[3 as libc::c_int as usize],
                                                                                                                    a___0[4 as libc::c_int as usize],
                                                                                                                    a___0[5 as libc::c_int as usize],
                                                                                                                    a___0[6 as libc::c_int as usize],
                                                                                                                );
                                                                                                            }
                                                                                                            _ => {}
                                                                                                        }
                                                                                                        current_block = 3325916876629046855;
                                                                                                    }
                                                                                                    3 => {
                                                                                                        if *(((*f).k).as_mut_ptr() as *mut V)
                                                                                                            .offset(1 as libc::c_int as isize) as L
                                                                                                            > 500 as libc::c_longlong
                                                                                                        {
                                                                                                            kerr(b"stack\0" as *const u8 as *const libc::c_char);
                                                                                                            current_block = 8790795054853801794;
                                                                                                        } else if stk as libc::c_double > 2e6f64 {
                                                                                                            kerr(b"stack\0" as *const u8 as *const libc::c_char);
                                                                                                            current_block = 8790795054853801794;
                                                                                                        } else {
                                                                                                            stk += 1;
                                                                                                            j___0 = 0 as libc::c_int as I;
                                                                                                            tree = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                .offset(7 as libc::c_int as isize) as K;
                                                                                                            if tree.is_null() {
                                                                                                                tree = newK(5 as libc::c_int as I, (*p).n + (*s).n);
                                                                                                                if tree.is_null() {
                                                                                                                    stk -= 1;
                                                                                                                    current_block = 8790795054853801794;
                                                                                                                } else {
                                                                                                                    i___4 = 0 as libc::c_int as I;
                                                                                                                    _i___5 = (*tree).n;
                                                                                                                    loop {
                                                                                                                        if !(i___4 < _i___5) {
                                                                                                                            current_block = 9029608189573075810;
                                                                                                                            break;
                                                                                                                        }
                                                                                                                        tmp___18 = newK(
                                                                                                                            0 as libc::c_int as I,
                                                                                                                            3 as libc::c_int as I,
                                                                                                                        );
                                                                                                                        let ref mut fresh146 = *((*tree).k)
                                                                                                                            .as_mut_ptr()
                                                                                                                            .offset(i___4 as isize);
                                                                                                                        *fresh146 = tmp___18;
                                                                                                                        if tmp___18.is_null() {
                                                                                                                            cd(tree);
                                                                                                                            stk -= 1;
                                                                                                                            current_block = 8790795054853801794;
                                                                                                                            break;
                                                                                                                        } else {
                                                                                                                            i___4 += 1;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    match current_block {
                                                                                                                        8790795054853801794 => {}
                                                                                                                        _ => {
                                                                                                                            i___5 = 0 as libc::c_int as I;
                                                                                                                            _i___6 = (*tree).n;
                                                                                                                            while i___5 < _i___6 {
                                                                                                                                j___1 = 0 as libc::c_int as I;
                                                                                                                                _j = 3 as libc::c_int as I;
                                                                                                                                while j___1 < _j {
                                                                                                                                    tmp___19 = DI(tree, i___5);
                                                                                                                                    if i___5 < (*p).n {
                                                                                                                                        tmp___20 = DI(p, i___5);
                                                                                                                                        tmp___22 = tmp___20;
                                                                                                                                    } else {
                                                                                                                                        tmp___21 = DI(s, i___5 - (*p).n);
                                                                                                                                        tmp___22 = tmp___21;
                                                                                                                                    }
                                                                                                                                    let ref mut fresh147 = *((*tmp___19).k)
                                                                                                                                        .as_mut_ptr()
                                                                                                                                        .offset(j___1 as isize);
                                                                                                                                    *fresh147 = ci(
                                                                                                                                        *((*tmp___22).k).as_mut_ptr().offset(j___1 as isize),
                                                                                                                                    );
                                                                                                                                    j___1 += 1;
                                                                                                                                }
                                                                                                                                i___5 += 1;
                                                                                                                            }
                                                                                                                            let ref mut fresh148 = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(7 as libc::c_int as isize);
                                                                                                                            *fresh148 = tree as V;
                                                                                                                            current_block = 2935573231841866810;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                current_block = 2935573231841866810;
                                                                                                            }
                                                                                                            match current_block {
                                                                                                                8790795054853801794 => {}
                                                                                                                _ => {
                                                                                                                    if fsf != 0 {
                                                                                                                        tmp___23 = dot_monadic(
                                                                                                                            *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(3 as libc::c_int as isize) as K,
                                                                                                                        );
                                                                                                                        j0___0 = tmp___23;
                                                                                                                        tmp___24 = dot_monadic(
                                                                                                                            *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(7 as libc::c_int as isize) as K,
                                                                                                                        );
                                                                                                                        j1___0 = tmp___24;
                                                                                                                        tmp___25 = ci(j0___0);
                                                                                                                        tmp___26 = join(tmp___25, j1___0);
                                                                                                                        j2 = tmp___26;
                                                                                                                        cd(j0___0);
                                                                                                                        cd(
                                                                                                                            *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(7 as libc::c_int as isize) as K,
                                                                                                                        );
                                                                                                                        tmp___27 = dot_monadic(j2);
                                                                                                                        let ref mut fresh149 = *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(7 as libc::c_int as isize);
                                                                                                                        *fresh149 = tmp___27 as V;
                                                                                                                        cd(j0___0);
                                                                                                                        cd(j1___0);
                                                                                                                        cd(j2);
                                                                                                                        tree = *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(7 as libc::c_int as isize) as K;
                                                                                                                        cd(
                                                                                                                            *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(6 as libc::c_int as isize) as K,
                                                                                                                        );
                                                                                                                        let ref mut fresh150 = *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(6 as libc::c_int as isize);
                                                                                                                        *fresh150 = 0 as V;
                                                                                                                    }
                                                                                                                    i___6 = 0 as libc::c_int as I;
                                                                                                                    _i___7 = (*p).n;
                                                                                                                    while i___6 < _i___7 {
                                                                                                                        tmp___28 = DI(tree, i___6);
                                                                                                                        e = EVP(tmp___28);
                                                                                                                        cd(*e);
                                                                                                                        *e = 0 as K;
                                                                                                                        if !r.is_null() {
                                                                                                                            if i___6 < (*r).n {
                                                                                                                                *e = ci(*((*r).k).as_mut_ptr().offset(i___6 as isize));
                                                                                                                            }
                                                                                                                        }
                                                                                                                        if (*e).is_null() {
                                                                                                                            if j___0 < (*g).n {
                                                                                                                                tmp___29 = j___0;
                                                                                                                                j___0 += 1;
                                                                                                                                *e = ci(*((*g).k).as_mut_ptr().offset(tmp___29 as isize));
                                                                                                                            }
                                                                                                                        }
                                                                                                                        i___6 += 1;
                                                                                                                    }
                                                                                                                    fw = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                        .offset(6 as libc::c_int as isize) as K;
                                                                                                                    t___0 = 0 as libc::c_int as I;
                                                                                                                    let mut current_block_402: u64;
                                                                                                                    if fw.is_null() {
                                                                                                                        current_block_402 = 1371282815856847947;
                                                                                                                    } else {
                                                                                                                        if *(((**((*fw).k)
                                                                                                                            .as_mut_ptr()
                                                                                                                            .offset(2 as libc::c_int as isize))
                                                                                                                            .k)
                                                                                                                            .as_mut_ptr() as *mut S)
                                                                                                                            .offset(0 as libc::c_int as isize) as UI > DT_SIZE as UI
                                                                                                                        {
                                                                                                                            tmp___31 = 1 as libc::c_int;
                                                                                                                        } else if *(((**((*fw).k)
                                                                                                                                .as_mut_ptr()
                                                                                                                                .offset(2 as libc::c_int as isize))
                                                                                                                                .k)
                                                                                                                                .as_mut_ptr() as *mut S)
                                                                                                                                .offset(1 as libc::c_int as isize) as UI > DT_SIZE as UI
                                                                                                                            {
                                                                                                                            tmp___31 = 1 as libc::c_int;
                                                                                                                        } else {
                                                                                                                            tmp___31 = 0 as libc::c_int;
                                                                                                                        }
                                                                                                                        t___0 = tmp___31 as I;
                                                                                                                        if t___0 != 0 {
                                                                                                                            current_block_402 = 1371282815856847947;
                                                                                                                        } else {
                                                                                                                            current_block_402 = 2693152076527319813;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    match current_block_402 {
                                                                                                                        1371282815856847947 => {
                                                                                                                            if t___0 != 0 {
                                                                                                                                cd(
                                                                                                                                    *(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                                        .offset(6 as libc::c_int as isize) as K,
                                                                                                                                );
                                                                                                                            }
                                                                                                                            tmp___30 = kcloneI(
                                                                                                                                f,
                                                                                                                                b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                                539 as libc::c_int,
                                                                                                                            );
                                                                                                                            fc = tmp___30;
                                                                                                                            cd(
                                                                                                                                *(((*fc).k).as_mut_ptr() as *mut V)
                                                                                                                                    .offset(5 as libc::c_int as isize) as K,
                                                                                                                            );
                                                                                                                            let ref mut fresh151 = *(((*fc).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(5 as libc::c_int as isize);
                                                                                                                            *fresh151 = 0 as V;
                                                                                                                            let ref mut fresh152 = *(((*fc).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(1 as libc::c_int as isize);
                                                                                                                            *fresh152 = (*fresh152).offset(1);
                                                                                                                            tt = 0 as libc::c_int as I;
                                                                                                                            ttt = 0 as libc::c_int as I;
                                                                                                                            i___7 = 0 as libc::c_int as I;
                                                                                                                            i___7 = 0 as libc::c_int as I;
                                                                                                                            while i___7 < (*o).n - 3 as libc::c_longlong {
                                                                                                                                if *(((*o).k).as_mut_ptr() as *mut C).offset(i___7 as isize)
                                                                                                                                    as libc::c_int == 123 as libc::c_int
                                                                                                                                {
                                                                                                                                    tt = 1 as libc::c_int as I;
                                                                                                                                    if *(((*o).k).as_mut_ptr() as *mut C)
                                                                                                                                        .offset((i___7 + 1 as libc::c_longlong) as isize)
                                                                                                                                        as libc::c_int == 58 as libc::c_int
                                                                                                                                    {
                                                                                                                                        ttt = 1 as libc::c_int as I;
                                                                                                                                        break;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                i___7 += 1;
                                                                                                                            }
                                                                                                                            if ttt == 0 {
                                                                                                                                if grnt.is_null() {
                                                                                                                                    fw = wd_(
                                                                                                                                        ((*o).k).as_mut_ptr() as *mut C,
                                                                                                                                        (*o).n as libc::c_int,
                                                                                                                                        &mut tree,
                                                                                                                                        fc,
                                                                                                                                    );
                                                                                                                                } else if tt != 0 {
                                                                                                                                    fw = wd_(
                                                                                                                                        ((*o).k).as_mut_ptr() as *mut C,
                                                                                                                                        (*o).n as libc::c_int,
                                                                                                                                        &mut tree,
                                                                                                                                        fc,
                                                                                                                                    );
                                                                                                                                } else if *(((*o).k).as_mut_ptr() as *mut C)
                                                                                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                                                                        == 91 as libc::c_int
                                                                                                                                    {
                                                                                                                                    fw = wd_(
                                                                                                                                        ((*o).k).as_mut_ptr() as *mut C,
                                                                                                                                        (*o).n as libc::c_int,
                                                                                                                                        &mut tree,
                                                                                                                                        fc,
                                                                                                                                    );
                                                                                                                                } else {
                                                                                                                                    tc = kcloneI(
                                                                                                                                        tree,
                                                                                                                                        b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                                        547 as libc::c_int,
                                                                                                                                    );
                                                                                                                                    fw = wd_(
                                                                                                                                        ((*o).k).as_mut_ptr() as *mut C,
                                                                                                                                        (*o).n as libc::c_int,
                                                                                                                                        &mut tc,
                                                                                                                                        fc,
                                                                                                                                    );
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                tc = kcloneI(
                                                                                                                                    tree,
                                                                                                                                    b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                                    547 as libc::c_int,
                                                                                                                                );
                                                                                                                                fw = wd_(
                                                                                                                                    ((*o).k).as_mut_ptr() as *mut C,
                                                                                                                                    (*o).n as libc::c_int,
                                                                                                                                    &mut tc,
                                                                                                                                    fc,
                                                                                                                                );
                                                                                                                            }
                                                                                                                            let ref mut fresh153 = *(((*f).k).as_mut_ptr() as *mut V)
                                                                                                                                .offset(6 as libc::c_int as isize);
                                                                                                                            *fresh153 = fw as V;
                                                                                                                            cd(fc);
                                                                                                                        }
                                                                                                                        _ => {}
                                                                                                                    }
                                                                                                                    if stk1 as libc::c_double > 1e3f64 {
                                                                                                                        cd(g);
                                                                                                                        kerr(b"stack\0" as *const u8 as *const libc::c_char);
                                                                                                                        tmp___32 = _n();
                                                                                                                        return tmp___32;
                                                                                                                    }
                                                                                                                    ci(fw);
                                                                                                                    stk1 += 1;
                                                                                                                    z = ex(fw);
                                                                                                                    stk1 -= 1;
                                                                                                                    i___8 = 0 as libc::c_int as I;
                                                                                                                    _i___8 = (*p).n;
                                                                                                                    while i___8 < _i___8 {
                                                                                                                        tmp___33 = DI(tree, i___8);
                                                                                                                        e = EVP(tmp___33);
                                                                                                                        cd(*e);
                                                                                                                        *e = 0 as K;
                                                                                                                        i___8 += 1;
                                                                                                                    }
                                                                                                                    stk -= 1;
                                                                                                                    current_block = 3325916876629046855;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {
                                                                                                        current_block = 3325916876629046855;
                                                                                                    }
                                                                                                }
                                                                                                match current_block {
                                                                                                    8790795054853801794 => {}
                                                                                                    _ => {
                                                                                                        if encp == 2 as libc::c_longlong {
                                                                                                            ff = 0 as libc::c_int as I;
                                                                                                            if !z.is_null() {
                                                                                                                if (*z).t == 7 as libc::c_longlong {
                                                                                                                    if (*z).n == 3 as libc::c_longlong {
                                                                                                                        if !(*(((*z).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(2 as libc::c_int as isize))
                                                                                                                            .is_null()
                                                                                                                        {
                                                                                                                            tmp___35 = strchr(
                                                                                                                                ((**((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize))
                                                                                                                                    .k)
                                                                                                                                    .as_mut_ptr() as *mut C as *const libc::c_char,
                                                                                                                                *(b"z\0" as *const u8 as *const libc::c_char)
                                                                                                                                    .offset(0 as libc::c_int as isize) as libc::c_int,
                                                                                                                            );
                                                                                                                            if !tmp___35.is_null() {
                                                                                                                                if !(*(((*z).k).as_mut_ptr() as *mut V)
                                                                                                                                    .offset(4 as libc::c_int as isize))
                                                                                                                                    .is_null()
                                                                                                                                {
                                                                                                                                    if (**((*z).k)
                                                                                                                                        .as_mut_ptr()
                                                                                                                                        .offset(4 as libc::c_int as isize))
                                                                                                                                        .n != 0
                                                                                                                                    {
                                                                                                                                        ff = 1 as libc::c_int as I;
                                                                                                                                        i___9 = 0 as libc::c_int as I;
                                                                                                                                        _i___9 = (**((*z).k)
                                                                                                                                            .as_mut_ptr()
                                                                                                                                            .offset(4 as libc::c_int as isize))
                                                                                                                                            .n;
                                                                                                                                        while i___9 < _i___9 {
                                                                                                                                            tmp___34 = strcmp(
                                                                                                                                                *(((**((**((**((*z).k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(4 as libc::c_int as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(i___9 as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr() as *mut S) as *const libc::c_char,
                                                                                                                                                b"z\0" as *const u8 as *const libc::c_char,
                                                                                                                                            );
                                                                                                                                            if tmp___34 == 0 {
                                                                                                                                                ff = 0 as libc::c_int as I;
                                                                                                                                                break;
                                                                                                                                            } else {
                                                                                                                                                i___9 += 1;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            if ff != 0 {
                                                                                                                d___1 = *((**((*KTREE).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                    .k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(1 as libc::c_int as isize);
                                                                                                                w___3 = 0 as K;
                                                                                                                i___10 = 0 as libc::c_int as I;
                                                                                                                _i___10 = (*d___1).n;
                                                                                                                while i___10 < _i___10 {
                                                                                                                    tmp___36 = strcmp(
                                                                                                                        *(((**((**((*d___1).k).as_mut_ptr().offset(i___10 as isize))
                                                                                                                            .k)
                                                                                                                            .as_mut_ptr()
                                                                                                                            .offset(0 as libc::c_int as isize))
                                                                                                                            .k)
                                                                                                                            .as_mut_ptr() as *mut S) as *const libc::c_char,
                                                                                                                        b"z\0" as *const u8 as *const libc::c_char,
                                                                                                                    );
                                                                                                                    if tmp___36 == 0 {
                                                                                                                        w___3 = kcloneI(
                                                                                                                            *((*d___1).k).as_mut_ptr().offset(i___10 as isize),
                                                                                                                            b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                            559 as libc::c_int,
                                                                                                                        );
                                                                                                                        break;
                                                                                                                    } else {
                                                                                                                        i___10 += 1;
                                                                                                                    }
                                                                                                                }
                                                                                                                if !w___3.is_null() {
                                                                                                                    p___0 = *((*g).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(0 as libc::c_int as isize);
                                                                                                                    cd(
                                                                                                                        *((*w___3).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                                                                                                                    );
                                                                                                                    let ref mut fresh154 = *((*w___3).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(1 as libc::c_int as isize);
                                                                                                                    *fresh154 = kcloneI(
                                                                                                                        p___0,
                                                                                                                        b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                        561 as libc::c_int,
                                                                                                                    );
                                                                                                                    tmp___37 = enlist(w___3);
                                                                                                                    we = tmp___37;
                                                                                                                    tmp___38 = dot_monadic(
                                                                                                                        *((*z).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                                                                    );
                                                                                                                    j0___1 = tmp___38;
                                                                                                                    tmp___39 = ci(j0___1);
                                                                                                                    tmp___40 = join(tmp___39, we);
                                                                                                                    j2___0 = tmp___40;
                                                                                                                    cd(j0___1);
                                                                                                                    cd(
                                                                                                                        *((*z).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                                                                    );
                                                                                                                    let ref mut fresh155 = *((*z).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(7 as libc::c_int as isize);
                                                                                                                    *fresh155 = dot_monadic(j2___0);
                                                                                                                    cd(w___3);
                                                                                                                    cd(we);
                                                                                                                    cd(j0___1);
                                                                                                                    cd(j2___0);
                                                                                                                    encp = 3 as libc::c_int as I;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        if encp == 1 as libc::c_longlong {
                                                                                                            ff___0 = 0 as libc::c_int as I;
                                                                                                            if !z.is_null() {
                                                                                                                if (*z).t == 7 as libc::c_longlong {
                                                                                                                    if (*z).n == 3 as libc::c_longlong {
                                                                                                                        if !(*(((*z).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(2 as libc::c_int as isize))
                                                                                                                            .is_null()
                                                                                                                        {
                                                                                                                            tmp___42 = strchr(
                                                                                                                                ((**((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize))
                                                                                                                                    .k)
                                                                                                                                    .as_mut_ptr() as *mut C as *const libc::c_char,
                                                                                                                                *(b"y\0" as *const u8 as *const libc::c_char)
                                                                                                                                    .offset(0 as libc::c_int as isize) as libc::c_int,
                                                                                                                            );
                                                                                                                            if !tmp___42.is_null() {
                                                                                                                                if !(*(((*z).k).as_mut_ptr() as *mut V)
                                                                                                                                    .offset(4 as libc::c_int as isize))
                                                                                                                                    .is_null()
                                                                                                                                {
                                                                                                                                    if (**((*z).k)
                                                                                                                                        .as_mut_ptr()
                                                                                                                                        .offset(4 as libc::c_int as isize))
                                                                                                                                        .n != 0
                                                                                                                                    {
                                                                                                                                        ff___0 = 1 as libc::c_int as I;
                                                                                                                                        i___11 = 0 as libc::c_int as I;
                                                                                                                                        _i___11 = (**((*z).k)
                                                                                                                                            .as_mut_ptr()
                                                                                                                                            .offset(4 as libc::c_int as isize))
                                                                                                                                            .n;
                                                                                                                                        while i___11 < _i___11 {
                                                                                                                                            tmp___41 = strcmp(
                                                                                                                                                *(((**((**((**((*z).k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(4 as libc::c_int as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(i___11 as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr() as *mut S) as *const libc::c_char,
                                                                                                                                                b"y\0" as *const u8 as *const libc::c_char,
                                                                                                                                            );
                                                                                                                                            if tmp___41 == 0 {
                                                                                                                                                ff___0 = 0 as libc::c_int as I;
                                                                                                                                                break;
                                                                                                                                            } else {
                                                                                                                                                i___11 += 1;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            if ff___0 != 0 {
                                                                                                                d___2 = *((**((*KTREE).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                    .k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(1 as libc::c_int as isize);
                                                                                                                y = 0 as K;
                                                                                                                if 6 as libc::c_longlong != (*d___2).t {
                                                                                                                    if 5 as libc::c_longlong == (*d___2).t {
                                                                                                                        if 6 as libc::c_longlong
                                                                                                                            == (**((**((*d___2).k)
                                                                                                                                .as_mut_ptr()
                                                                                                                                .offset(0 as libc::c_int as isize))
                                                                                                                                .k)
                                                                                                                                .as_mut_ptr()
                                                                                                                                .offset(1 as libc::c_int as isize))
                                                                                                                                .t
                                                                                                                        {
                                                                                                                            tmp___44 = kerr(
                                                                                                                                b"nyi\0" as *const u8 as *const libc::c_char,
                                                                                                                            );
                                                                                                                            return tmp___44;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    i___12 = 0 as libc::c_int as I;
                                                                                                                    _i___12 = (*d___2).n;
                                                                                                                    while i___12 < _i___12 {
                                                                                                                        tmp___43 = strcmp(
                                                                                                                            *(((**((**((*d___2).k).as_mut_ptr().offset(i___12 as isize))
                                                                                                                                .k)
                                                                                                                                .as_mut_ptr()
                                                                                                                                .offset(0 as libc::c_int as isize))
                                                                                                                                .k)
                                                                                                                                .as_mut_ptr() as *mut S) as *const libc::c_char,
                                                                                                                            b"y\0" as *const u8 as *const libc::c_char,
                                                                                                                        );
                                                                                                                        if tmp___43 == 0 {
                                                                                                                            y = kcloneI(
                                                                                                                                *((*d___2).k).as_mut_ptr().offset(i___12 as isize),
                                                                                                                                b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                                571 as libc::c_int,
                                                                                                                            );
                                                                                                                            break;
                                                                                                                        } else {
                                                                                                                            i___12 += 1;
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    tmp___44 = kerr(
                                                                                                                        b"nyi\0" as *const u8 as *const libc::c_char,
                                                                                                                    );
                                                                                                                    return tmp___44;
                                                                                                                }
                                                                                                                if !y.is_null() {
                                                                                                                    p___1 = *((*g).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(0 as libc::c_int as isize);
                                                                                                                    cd(
                                                                                                                        *((*y).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                                                                                                                    );
                                                                                                                    let ref mut fresh156 = *((*y).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(1 as libc::c_int as isize);
                                                                                                                    *fresh156 = kcloneI(
                                                                                                                        p___1,
                                                                                                                        b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                        574 as libc::c_int,
                                                                                                                    );
                                                                                                                    tmp___45 = enlist(y);
                                                                                                                    ye = tmp___45;
                                                                                                                    tmp___46 = dot_monadic(
                                                                                                                        *((*z).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                                                                    );
                                                                                                                    j0___2 = tmp___46;
                                                                                                                    tmp___47 = ci(j0___2);
                                                                                                                    tmp___48 = join(tmp___47, ye);
                                                                                                                    j2___1 = tmp___48;
                                                                                                                    cd(j0___2);
                                                                                                                    cd(
                                                                                                                        *((*z).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                                                                    );
                                                                                                                    let ref mut fresh157 = *((*z).k)
                                                                                                                        .as_mut_ptr()
                                                                                                                        .offset(7 as libc::c_int as isize);
                                                                                                                    *fresh157 = dot_monadic(j2___1);
                                                                                                                    cd(y);
                                                                                                                    cd(ye);
                                                                                                                    cd(j0___2);
                                                                                                                    cd(j2___1);
                                                                                                                    encp = 2 as libc::c_int as I;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        if encp == 0 as libc::c_longlong {
                                                                                                            ff___1 = 0 as libc::c_int as I;
                                                                                                            if !z.is_null() {
                                                                                                                if (*z).t == 7 as libc::c_longlong {
                                                                                                                    if (*z).n == 3 as libc::c_longlong {
                                                                                                                        if !(*(((*z).k).as_mut_ptr() as *mut V)
                                                                                                                            .offset(2 as libc::c_int as isize))
                                                                                                                            .is_null()
                                                                                                                        {
                                                                                                                            tmp___50 = strchr(
                                                                                                                                ((**((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize))
                                                                                                                                    .k)
                                                                                                                                    .as_mut_ptr() as *mut C as *const libc::c_char,
                                                                                                                                *(b"x\0" as *const u8 as *const libc::c_char)
                                                                                                                                    .offset(0 as libc::c_int as isize) as libc::c_int,
                                                                                                                            );
                                                                                                                            if !tmp___50.is_null() {
                                                                                                                                if !(*(((*z).k).as_mut_ptr() as *mut V)
                                                                                                                                    .offset(4 as libc::c_int as isize))
                                                                                                                                    .is_null()
                                                                                                                                {
                                                                                                                                    if (**((*z).k)
                                                                                                                                        .as_mut_ptr()
                                                                                                                                        .offset(4 as libc::c_int as isize))
                                                                                                                                        .n != 0
                                                                                                                                    {
                                                                                                                                        ff___1 = 1 as libc::c_int as I;
                                                                                                                                        i___13 = 0 as libc::c_int as I;
                                                                                                                                        _i___13 = (**((*z).k)
                                                                                                                                            .as_mut_ptr()
                                                                                                                                            .offset(4 as libc::c_int as isize))
                                                                                                                                            .n;
                                                                                                                                        while i___13 < _i___13 {
                                                                                                                                            tmp___49 = strcmp(
                                                                                                                                                *(((**((**((**((*z).k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(4 as libc::c_int as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(i___13 as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                                                    .k)
                                                                                                                                                    .as_mut_ptr() as *mut S) as *const libc::c_char,
                                                                                                                                                b"x\0" as *const u8 as *const libc::c_char,
                                                                                                                                            );
                                                                                                                                            if tmp___49 == 0 {
                                                                                                                                                ff___1 = 0 as libc::c_int as I;
                                                                                                                                                break;
                                                                                                                                            } else {
                                                                                                                                                i___13 += 1;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            if ff___1 != 0 {
                                                                                                                tmp___51 = newK(
                                                                                                                    4 as libc::c_int as I,
                                                                                                                    1 as libc::c_int as I,
                                                                                                                );
                                                                                                                xx = tmp___51;
                                                                                                                tmp___52 = sp(
                                                                                                                    b"x\0" as *const u8 as *const libc::c_char as S,
                                                                                                                );
                                                                                                                let ref mut fresh158 = *((*xx).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize);
                                                                                                                *fresh158 = tmp___52 as V as *mut k0;
                                                                                                                tmp___53 = newK(
                                                                                                                    0 as libc::c_int as I,
                                                                                                                    3 as libc::c_int as I,
                                                                                                                );
                                                                                                                x___0 = tmp___53;
                                                                                                                let ref mut fresh159 = *((*x___0).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize);
                                                                                                                *fresh159 = xx;
                                                                                                                tmp___54 = _n();
                                                                                                                let ref mut fresh160 = *((*x___0).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(1 as libc::c_int as isize);
                                                                                                                *fresh160 = tmp___54;
                                                                                                                tmp___55 = _n();
                                                                                                                let ref mut fresh161 = *((*x___0).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(2 as libc::c_int as isize);
                                                                                                                *fresh161 = tmp___55;
                                                                                                                p___2 = *((*g).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize);
                                                                                                                cd(
                                                                                                                    *((*x___0).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                                                                                                                );
                                                                                                                let ref mut fresh162 = *((*x___0).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(1 as libc::c_int as isize);
                                                                                                                *fresh162 = kcloneI(
                                                                                                                    p___2,
                                                                                                                    b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                                                                                    584 as libc::c_int,
                                                                                                                );
                                                                                                                tmp___56 = enlist(x___0);
                                                                                                                xe = tmp___56;
                                                                                                                tmp___57 = dot_monadic(
                                                                                                                    *((*z).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                                                                );
                                                                                                                j0___3 = tmp___57;
                                                                                                                tmp___58 = ci(j0___3);
                                                                                                                tmp___59 = join(tmp___58, xe);
                                                                                                                j2___2 = tmp___59;
                                                                                                                cd(j0___3);
                                                                                                                cd(
                                                                                                                    *((*z).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                                                                );
                                                                                                                let ref mut fresh163 = *((*z).k)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(7 as libc::c_int as isize);
                                                                                                                *fresh163 = dot_monadic(j2___2);
                                                                                                                cd(x___0);
                                                                                                                cd(xe);
                                                                                                                cd(j0___3);
                                                                                                                cd(j2___2);
                                                                                                                encp = 1 as libc::c_int as I;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    cd(g);
    cd(tc);
    return z;
}
unsafe extern "C" fn ex_(mut a: V, mut r: I) -> V {
    let mut x___0: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: V = 0 as *mut libc::c_void;
    y = 0 as K;
    tmp___0 = VA(a);
    if tmp___0 != 0 {
        return a;
    }
    x___0 = *(a as *mut K);
    if !x___0.is_null() {
        if 7 as libc::c_longlong != (*x___0).t {
            tmp___1 = ci(x___0);
            return tmp___1 as V;
        } else {
            if (0 as libc::c_longlong) < (*x___0).n {
                if (*x___0).n < 4 as libc::c_longlong {
                    tmp___1 = ci(x___0);
                    return tmp___1 as V;
                }
            }
        }
    } else {
        tmp___1 = ci(x___0);
        return tmp___1 as V;
    }
    if (*x___0).n < 4 as libc::c_longlong {
        r = r;
    } else {
        r = (*x___0).n;
    }
    if !(*(((*x___0).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize))
        .is_null()
    {
        tmp = *((((*x___0).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize)
            as *mut K);
        if !tmp.is_null() {
            if offsetColon as libc::c_ulong
                == *(((*(*(((*tmp).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .k)
                    .as_mut_ptr() as *mut S as *mut V) as libc::c_ulong
            {
                if *(((*(*(((*tmp).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .k)
                    .as_mut_ptr() as *mut S as *mut V)
                    .offset(1 as libc::c_int as isize) as UI > DT_SIZE as UI
                {
                    fer = 1 as libc::c_int as I;
                }
            }
        }
        tmp___2 = ex_(
            (((*x___0).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize) as V,
            2 as libc::c_int as I,
        );
        y = tmp___2 as K;
        if y.is_null() {
            return 0 as V;
        }
        if (*y).t == 0 as libc::c_longlong {
            if (*y).n == 0 as libc::c_longlong {
                cd(y);
                y = _n();
            }
        }
        if fer > 0 as libc::c_longlong {
            if fCheck == 0 {
                return y as V;
            }
        }
    }
    z = ex0(
        ((*(*(((*x___0).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
            as K))
            .k)
            .as_mut_ptr() as *mut S as *mut V,
        y,
        r,
    );
    cd(y);
    return z as V;
}
pub unsafe extern "C" fn ex(mut a: K) -> K {
    let mut i: I = 0;
    let mut tmp: I = 0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    if a.is_null() {
        return 0 as K;
    }
    if (*a).t == 7 as libc::c_longlong {
        if *(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize) as K
            as libc::c_ulong > DT_SIZE as K as libc::c_ulong
        {
            if 7 as libc::c_longlong
                == (*(*(((*a).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .t
            {
                if 6 as libc::c_longlong
                    == (*(*(((*a).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .n
                {
                    fwh = 1 as libc::c_int as I;
                }
            }
        }
    }
    if (*a).t == 7 as libc::c_longlong {
        if prnt as libc::c_ulong == 0 as K as libc::c_ulong {
            if *(((*(*(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
                as K))
                .k)
                .as_mut_ptr() as *mut S as *mut V)
                .offset(1 as libc::c_int as isize) as libc::c_ulong
                == offsetColon as libc::c_ulong
            {
                if *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .k)
                    .as_mut_ptr() as *mut S as *mut V)
                    .offset(2 as libc::c_int as isize) as libc::c_ulong
                    != offset3m as libc::c_ulong
                {
                    fam = 0 as libc::c_int as I;
                }
            }
            if (*(*(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
                as K))
                .n > 3 as libc::c_longlong
            {
                i = 3 as libc::c_int as I;
                while !(*(((*(*(((*a).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .k)
                    .as_mut_ptr() as *mut S as *mut V)
                    .offset(i as isize))
                    .is_null()
                {
                    tmp = i;
                    i += 1;
                    if *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut S as *mut V)
                        .offset(tmp as isize) as libc::c_ulong
                        == 1 as libc::c_int as V as libc::c_ulong
                    {
                        fam = 1 as libc::c_int as I;
                    }
                    if *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut S as *mut V)
                        .offset((i - 1 as libc::c_longlong) as isize) as libc::c_ulong
                        == offsetColon as libc::c_ulong
                    {
                        if *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                            .offset(2 as libc::c_int as isize) as K))
                            .k)
                            .as_mut_ptr() as *mut S as *mut V)
                            .offset(i as isize) as libc::c_ulong
                            != offset3m as libc::c_ulong
                        {
                            fam = 0 as libc::c_int as I;
                        }
                    }
                }
                if fCheck == 0 {
                    if i > 2 as libc::c_longlong {
                        k = 0 as libc::c_int as I;
                        j = i - 1 as libc::c_longlong;
                        while j > 0 as libc::c_longlong {
                            if !(k < 10 as libc::c_longlong) {
                                break;
                            }
                            if (*(((*(*(((*a).k).as_mut_ptr() as *mut V)
                                .offset(2 as libc::c_int as isize) as K))
                                .k)
                                .as_mut_ptr() as *mut S as *mut V)
                                .offset(j as isize) as libc::c_ulong)
                                < DT_SIZE as V as libc::c_ulong
                            {
                                if *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K))
                                    .k)
                                    .as_mut_ptr() as *mut S as *mut V)
                                    .offset(j as isize) as libc::c_ulong
                                    > 1 as libc::c_int as V as libc::c_ulong
                                {
                                    cdp[k
                                        as usize] = *DT[*(((*(*(((*a).k).as_mut_ptr() as *mut V)
                                            .offset(2 as libc::c_int as isize) as K))
                                            .k)
                                            .as_mut_ptr() as *mut S as *mut V)
                                            .offset(j as isize) as I as usize]
                                        .text;
                                    k += 1;
                                }
                            }
                            j -= 1;
                        }
                    }
                }
            }
        }
    } else {
        fam = 1 as libc::c_int as I;
    }
    tmp___0 = ex_(&mut a as *mut K as V, 0 as libc::c_int as I);
    z = tmp___0 as K;
    cd(a);
    if fer == 1 as libc::c_longlong {
        fer1 = 0 as libc::c_int as I;
        fer = fer1;
    }
    fsf = 0 as libc::c_int as I;
    prj2 = fsf;
    prj = prj2;
    stk1 = prj;
    stk = stk1;
    fwh = stk;
    if !prnt.is_null() {
        cd(prnt);
    }
    prnt = 0 as K;
    return z;
}
unsafe extern "C" fn ex0(mut v: *mut V, mut k: K, mut r: I) -> K {
    let mut current_block: u64;
    let mut n: I = 0;
    let mut e: I = 0;
    let mut i: I = 0;
    let mut a: I = 0;
    let mut b___1: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: I = 0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: I = 0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: I = 0;
    let mut tmp___23: I = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: I = 0;
    let mut tmp___26: I = 0;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: K = 0 as *mut k0;
    let mut tmp___30: I = 0;
    let mut tmp___31: I = 0;
    let mut j___0: I = 0;
    let mut tmp___32: I = 0;
    let mut i___1: I = 0;
    let mut _i___0: I = 0;
    let mut p: K = 0 as *mut k0;
    let mut i___2: I = 0;
    let mut q: *mut V = 0 as *mut V;
    let mut t: K = 0 as *mut k0;
    let mut i___3: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___33: I = 0;
    let mut tmp___34: I = 0;
    let mut tmp___35: I = 0;
    n = 0 as libc::c_int as I;
    e = 1 as libc::c_int as I;
    while !(*v.offset(n as isize)).is_null() {
        tmp = n;
        n += 1;
        tmp___0 = bk(*v.offset(tmp as isize));
        if tmp___0 != 0 {
            e += 1;
        }
    }
    b___1 = (e > 1 as libc::c_longlong) as libc::c_int as I;
    z = 0 as K;
    match r {
        0 => {
            i = -(1 as libc::c_int) as I;
            while i < n {
                let mut current_block_51: u64;
                if -(1 as libc::c_longlong) == i {
                    current_block_51 = 7345831568143831272;
                } else {
                    tmp___5 = bk(*v.offset(i as isize));
                    if tmp___5 != 0 {
                        current_block_51 = 7345831568143831272;
                    } else {
                        current_block_51 = 15669289850109000831;
                    }
                }
                match current_block_51 {
                    7345831568143831272 => {
                        cd(z);
                        frg += 1;
                        x___0 = ex1(
                            v.offset(1 as libc::c_int as isize).offset(i as isize),
                            0 as K,
                            &mut i,
                            n,
                            1 as libc::c_int as I,
                        );
                        frg -= 1;
                        if frg == 0 {
                            encp = 0 as libc::c_int as I;
                            if !encf.is_null() {
                                cd(encf);
                                encf = 0 as K;
                            }
                            if !grnt.is_null() {
                                cd(grnt);
                                grnt = 0 as K;
                            }
                        }
                        if x___0.is_null() {
                            return 0 as K;
                        }
                        tmp___3 = bk(x___0 as V);
                        if tmp___3 != 0 {
                            tmp___2 = _n();
                            z = tmp___2;
                        } else {
                            z = x___0;
                        }
                        if fer > 0 as libc::c_longlong {
                            if fCheck == 0 {
                                return z;
                            }
                        }
                        if !grnt.is_null() {
                            let mut current_block_48: u64;
                            if prnt.is_null() {
                                current_block_48 = 3455340628627372926;
                            } else {
                                tmp___4 = rc(prnt);
                                if tmp___4 == 2 as libc::c_longlong {
                                    current_block_48 = 3455340628627372926;
                                } else {
                                    current_block_48 = 13125627826496529465;
                                }
                            }
                            match current_block_48 {
                                3455340628627372926 => {
                                    if !prnt.is_null() {
                                        cd(prnt);
                                    }
                                    prnt = ci(grnt);
                                }
                                _ => {}
                            }
                        }
                    }
                    _ => {}
                }
                i += 1;
            }
        }
        4 => {
            i = -(1 as libc::c_int) as I;
            while i < n {
                let mut current_block_112: u64;
                if -(1 as libc::c_longlong) == i {
                    current_block_112 = 7637260607354866803;
                } else {
                    tmp___16 = bk(*v.offset(i as isize));
                    if tmp___16 != 0 {
                        current_block_112 = 7637260607354866803;
                    } else {
                        current_block_112 = 1425453989644512380;
                    }
                }
                match current_block_112 {
                    7637260607354866803 => {
                        x___0 = ex1(
                            v.offset(1 as libc::c_int as isize).offset(i as isize),
                            0 as K,
                            &mut i,
                            n,
                            1 as libc::c_int as I,
                        );
                        if x___0.is_null() {
                            return 0 as K;
                        }
                        if fer > 0 as libc::c_longlong {
                            if fCheck == 0 {
                                return x___0;
                            }
                        }
                        tmp___8 = bk(x___0 as V);
                        if tmp___8 != 0 {
                            tmp___7 = _n();
                            x___0 = tmp___7;
                        } else {
                            x___0 = x___0;
                        }
                        loop {
                            i += 1;
                            if !(i < n) {
                                break;
                            }
                            tmp___9 = bk(*v.offset(i as isize));
                            if tmp___9 != 0 {
                                break;
                            }
                        }
                        if i == n {
                            return x___0;
                        }
                        z = delist(x___0);
                        if (*z).t < 0 as libc::c_longlong {
                            tmp___11 = -(*z).t;
                        } else {
                            tmp___11 = (*z).t;
                        }
                        if tmp___11 != 1 as libc::c_longlong {
                            cd(z);
                            tmp___10 = kerr(
                                b"type\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___10;
                        } else {
                            if (*z).n != 1 as libc::c_longlong {
                                cd(z);
                                tmp___10 = kerr(
                                    b"type\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___10;
                            }
                        }
                        a = *(((*z).k).as_mut_ptr() as *mut I);
                        cd(z);
                        if a != 0 {
                            x___0 = ex1(
                                v.offset(i as isize).offset(1 as libc::c_int as isize),
                                0 as K,
                                &mut i,
                                n,
                                1 as libc::c_int as I,
                            );
                            tmp___14 = bk(x___0 as V);
                            if tmp___14 != 0 {
                                tmp___13 = _n();
                                x___0 = tmp___13;
                            } else {
                                x___0 = x___0;
                            }
                            return x___0;
                        } else {
                            while i < n {
                                tmp___15 = bk(*v.offset(i as isize));
                                if tmp___15 != 0 {
                                    break;
                                }
                                i += 1;
                            }
                        }
                    }
                    _ => {}
                }
                i += 1;
            }
            tmp___17 = _n();
            return tmp___17;
        }
        5 | 6 | 7 => {
            loop {
                i___0 = 0 as libc::c_int as I;
                x___0 = ex1(
                    v,
                    0 as K,
                    &mut i___0,
                    0 as libc::c_int as I,
                    1 as libc::c_int as I,
                );
                if x___0.is_null() {
                    return 0 as K;
                }
                if fer > 0 as libc::c_longlong {
                    return x___0;
                }
                tmp___20 = bk(x___0 as V);
                if tmp___20 != 0 {
                    tmp___19 = _n();
                    x___0 = tmp___19;
                } else {
                    x___0 = x___0;
                }
                z = delist(x___0);
                if (*z).t < 0 as libc::c_longlong {
                    tmp___22 = -(*z).t;
                } else {
                    tmp___22 = (*z).t;
                }
                if tmp___22 != 1 as libc::c_longlong {
                    cd(z);
                    tmp___21 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___21;
                } else {
                    if (*z).n != 1 as libc::c_longlong {
                        cd(z);
                        tmp___21 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                        return tmp___21;
                    }
                }
                a = *(((*z).k).as_mut_ptr() as *mut I);
                cd(z);
                i___0 = 0 as libc::c_int as I;
                if b___1 != 0 {
                    loop {
                        i___0 += 1;
                        if !(i___0 < n) {
                            break;
                        }
                        tmp___23 = bk(*v.offset(i___0 as isize));
                        if tmp___23 != 0 {
                            break;
                        }
                    }
                    if i___0 >= n {
                        break;
                    }
                }
                match r {
                    5 | 6 => {
                        if a != 0 {
                            if b___1 != 0 {
                                x___0 = ex0(
                                    v.offset(i___0 as isize).offset(1 as libc::c_int as isize),
                                    0 as K,
                                    0 as libc::c_int as I,
                                );
                                if fer > 0 as libc::c_longlong {
                                    return x___0;
                                }
                                cd(x___0);
                            }
                        }
                    }
                    7 => {
                        j = 0 as libc::c_int as I;
                        _j = a;
                        while j < _j {
                            x___0 = ex0(
                                v.offset(i___0 as isize).offset(1 as libc::c_int as isize),
                                0 as K,
                                0 as libc::c_int as I,
                            );
                            if fer > 0 as libc::c_longlong {
                                return x___0;
                            }
                            cd(x___0);
                            j += 1;
                        }
                    }
                    _ => {}
                }
                if !(6 as libc::c_longlong == r) {
                    break;
                }
                if a == 0 {
                    break;
                }
            }
            tmp___24 = _n();
            return tmp___24;
        }
        _ => {
            if n != 0 {
                tmp___25 = e;
            } else {
                tmp___25 = 0 as libc::c_int as I;
            }
            z = newK(0 as libc::c_int as I, tmp___25);
            if n != 0 {
                i = n - 1 as libc::c_longlong;
                while i >= -(1 as libc::c_longlong) {
                    let mut current_block_225: u64;
                    if -(1 as libc::c_longlong) == i {
                        current_block_225 = 13371923592300358653;
                    } else {
                        tmp___31 = bk(*v.offset(i as isize));
                        if tmp___31 != 0 {
                            current_block_225 = 13371923592300358653;
                        } else {
                            current_block_225 = 16096269104668059379;
                        }
                    }
                    match current_block_225 {
                        13371923592300358653 => {
                            if offsetColon as libc::c_ulong
                                == *v
                                    .offset(1 as libc::c_int as isize)
                                    .offset(i as isize)
                                    .offset(0 as libc::c_int as isize) as libc::c_ulong
                            {
                                if *v
                                    .offset(1 as libc::c_int as isize)
                                    .offset(i as isize)
                                    .offset(1 as libc::c_int as isize) as UI > DT_SIZE as UI
                                {
                                    fer = 1 as libc::c_int as I;
                                }
                            }
                            x___0 = ex1(
                                v.offset(1 as libc::c_int as isize).offset(i as isize),
                                0 as K,
                                &mut i,
                                n,
                                0 as libc::c_int as I,
                            );
                            if fer1 != 0 {
                                cd(z);
                                fer1 = 1 as libc::c_int as I;
                                return x___0;
                            } else {
                                if fer > 0 as libc::c_longlong {
                                    let mut current_block_204: u64;
                                    if *v.offset(0 as libc::c_int as isize) as libc::c_ulong
                                        == offsetColon as libc::c_ulong
                                    {
                                        current_block_204 = 1252603864885500583;
                                    } else if *v.offset(2 as libc::c_int as isize)
                                            as libc::c_ulong == 1 as libc::c_int as V as libc::c_ulong
                                        {
                                        current_block_204 = 1252603864885500583;
                                    } else {
                                        current_block_204 = 15458408974065364242;
                                    }
                                    match current_block_204 {
                                        1252603864885500583 => {
                                            if fCheck == 0 {
                                                cd(z);
                                                fer1 = 1 as libc::c_int as I;
                                                return x___0;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            tmp___26 = OOM_CD(
                                0 as libc::c_int as I,
                                x___0,
                                z,
                                -(1 as libc::c_int) as V,
                            );
                            if tmp___26 == 0 {
                                return 0 as K;
                            }
                            e -= 1;
                            tmp___30 = bk(x___0 as V);
                            if tmp___30 != 0 {
                                if 2 as libc::c_longlong == r {
                                    tmp___29 = 0 as K;
                                } else {
                                    tmp___28 = _n();
                                    tmp___29 = tmp___28;
                                }
                                let ref mut fresh164 = *((*z).k)
                                    .as_mut_ptr()
                                    .offset(e as isize);
                                *fresh164 = tmp___29;
                            } else {
                                let ref mut fresh165 = *((*z).k)
                                    .as_mut_ptr()
                                    .offset(e as isize);
                                *fresh165 = x___0;
                            }
                        }
                        _ => {}
                    }
                    i -= 1;
                }
            }
        }
    }
    if 1 as libc::c_longlong == r {
        z = collapse(z);
    } else if *v.offset(0 as libc::c_int as isize) as libc::c_ulong
            == 125 as libc::c_int as V as libc::c_ulong
        {
        z = collapse(z);
    }
    if !k.is_null() {
        tmp___32 = valence(&mut z as *mut K as V);
        j___0 = tmp___32;
        if j___0 == 0 {
            if 0 as libc::c_longlong == (*k).t {
                i___1 = 0 as libc::c_int as I;
                _i___0 = (*k).n;
                while i___1 < _i___0 {
                    if (*((*k).k).as_mut_ptr().offset(i___1 as isize)).is_null() {
                        let ref mut fresh166 = *((*k).k)
                            .as_mut_ptr()
                            .offset(i___1 as isize);
                        *fresh166 = _n();
                    }
                    i___1 += 1;
                }
            }
        }
        if (*z).t != 7 as libc::c_longlong {
            current_block = 2633367622042797542;
        } else if (*z).n != 1 as libc::c_longlong {
            current_block = 2633367622042797542;
        } else {
            if j___0 < (*k).n {
                if 0 as libc::c_longlong == j___0 {
                    if (*k).n == 1 as libc::c_longlong {
                        current_block = 769255970063260631;
                    } else {
                        current_block = 2633367622042797542;
                    }
                } else {
                    current_block = 2633367622042797542;
                }
            } else {
                current_block = 769255970063260631;
            }
            match current_block {
                2633367622042797542 => {}
                _ => {
                    p = *(((*z).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K;
                    i___2 = (*p).n - 2 as libc::c_longlong;
                    q = (((*p).k).as_mut_ptr() as *mut V).offset(i___2 as isize);
                    t = 0 as K;
                    if (*k).n == 1 as libc::c_longlong {
                        t = first(k);
                    }
                    let mut current_block_298: u64;
                    if (*k).n > 1 as libc::c_longlong {
                        current_block_298 = 17662753573329851056;
                    } else if !t.is_null() {
                        if (*t).n == 1 as libc::c_longlong {
                            current_block_298 = 17662753573329851056;
                        } else {
                            current_block_298 = 5918633923009477779;
                        }
                    } else {
                        current_block_298 = 5918633923009477779;
                    }
                    match current_block_298 {
                        17662753573329851056 => {
                            tmp___33 = sva(*q);
                            if tmp___33 == 0 {
                                tmp___34 = adverbClass(*q);
                                if tmp___34 != 0 {
                                    if (*k).n == 1 as libc::c_longlong {
                                        if prj2 == 0 {
                                            (*k).n = 2 as libc::c_int as I;
                                        }
                                    }
                                    prj2 = 1 as libc::c_int as I;
                                    i___3 = 0 as libc::c_int as I;
                                    _i___1 = (*k).n;
                                    while i___3 < _i___1 {
                                        if (*((*k).k).as_mut_ptr().offset(i___3 as isize)).is_null()
                                        {
                                            prj = 1 as libc::c_int as I;
                                        }
                                        i___3 += 1;
                                    }
                                    if prj == 0 {
                                        x___0 = bv_ex(q, k);
                                        cd(z);
                                        return x___0;
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    cd(t);
                    if (*z).t == 7 as libc::c_longlong {
                        if (*z).n == 1 as libc::c_longlong {
                            if *((**((*z).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize) as libc::c_ulong
                                == offsetSSR as libc::c_ulong
                            {
                                if (*k).t == 0 as libc::c_longlong {
                                    if (*k).n == 3 as libc::c_longlong {
                                        if (**((*k).k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .t < 0 as libc::c_longlong
                                        {
                                            tmp___35 = -(**((*k).k)
                                                .as_mut_ptr()
                                                .offset(2 as libc::c_int as isize))
                                                .t;
                                        } else {
                                            tmp___35 = (**((*k).k)
                                                .as_mut_ptr()
                                                .offset(2 as libc::c_int as isize))
                                                .t;
                                        }
                                        if tmp___35 == -(3 as libc::c_longlong) {
                                            let ref mut fresh167 = *((*k).k)
                                                .as_mut_ptr()
                                                .offset(2 as libc::c_int as isize);
                                            *fresh167 = enlist(
                                                *((*k).k).as_mut_ptr().offset(2 as libc::c_int as isize),
                                            );
                                            cd(x___0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    x___0 = vf_ex(&mut z as *mut K as V, k);
                    cd(z);
                    z = x___0;
                    current_block = 1239199080442314373;
                }
            }
        }
        match current_block {
            1239199080442314373 => {}
            _ => {
                if !encf.is_null() {
                    if (DT_SIZE as UI) < &mut z as *mut K as UI {
                        x___0 = vf_ex(&mut encf as *mut K as V, k);
                    } else {
                        x___0 = vf_ex(&mut z as *mut K as V, k);
                    }
                } else {
                    x___0 = vf_ex(&mut z as *mut K as V, k);
                }
                if encp != 3 as libc::c_longlong {
                    cd(z);
                }
                z = x___0;
                return z;
            }
        }
    }
    return z;
}
unsafe extern "C" fn bv_ex(mut p: *mut V, mut k: K) -> K {
    let mut q: V = 0 as *mut libc::c_void;
    let mut x___0: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut j___0: I = 0;
    let mut _j___0: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut g___0: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut j___1: I = 0;
    let mut _j___1: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: I = 0;
    let mut j___2: I = 0;
    let mut _j___2: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: I = 0;
    let mut c: I = 0;
    let mut z___1: K = 0 as *mut k0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut g___1: K = 0 as *mut k0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut x___1: K = 0 as *mut k0;
    let mut j___3: I = 0;
    let mut _j___3: I = 0;
    let mut tmp___26: I = 0;
    let mut tmp___27: I = 0;
    let mut j___4: I = 0;
    let mut _j___4: I = 0;
    let mut tmp___28: K = 0 as *mut k0;
    let mut a: K = 0 as *mut k0;
    let mut b___1: K = 0 as *mut k0;
    let mut tmp___29: K = 0 as *mut k0;
    let mut tmp___30: K = 0 as *mut k0;
    let mut a___0: K = 0 as *mut k0;
    let mut b___2: K = 0 as *mut k0;
    let mut tmp___31: K = 0 as *mut k0;
    let mut tmp___32: K = 0 as *mut k0;
    let mut a___1: K = 0 as *mut k0;
    let mut b___3: K = 0 as *mut k0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut tmp___34: K = 0 as *mut k0;
    q = *p;
    n = 0 as libc::c_int as I;
    tmp___1 = adverbClass(*p);
    if tmp___1 == 0 {
        tmp___2 = valence(*p);
        if tmp___2 < 3 as libc::c_longlong {
            if (*k).n < 2 as libc::c_longlong {
                tmp = kerr(b"valence\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
            tmp___0 = dv_ex(
                *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                p,
                *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize),
            );
            return tmp___0;
        }
    }
    if offsetOver == q as L {
        i = 0 as libc::c_int as I;
        _i___0 = (*k).n - 1 as libc::c_longlong;
        while i < _i___0 {
            x___0 = *((*k).k).as_mut_ptr().offset((i + 1 as libc::c_longlong) as isize);
            if (*x___0).n == 0 {
                tmp___3 = ci(*((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize));
                return tmp___3;
            }
            tmp___5 = atomI(x___0);
            if tmp___5 == 0 {
                if n != 0 {
                    if n != (*x___0).n {
                        tmp___4 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                        return tmp___4;
                    } else {
                        n = (*x___0).n;
                    }
                } else {
                    n = (*x___0).n;
                }
            }
            i += 1;
        }
        if 1 as libc::c_longlong > n {
            n = 1 as libc::c_int as I;
        } else {
            n = n;
        }
        tmp___6 = ci(*((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize));
        z = tmp___6;
        tmp___7 = newK(0 as libc::c_int as I, (*k).n);
        g = tmp___7;
        tmp___8 = OOM_CD(0 as libc::c_int as I, z, g, -(1 as libc::c_int) as V);
        if tmp___8 == 0 {
            return 0 as K;
        }
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            let ref mut fresh168 = *((*g).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh168 = z;
            j = 0 as libc::c_int as I;
            _j = (*g).n - 1 as libc::c_longlong;
            while j < _j {
                x___0 = itemAtIndex(
                    *((*k).k).as_mut_ptr().offset((j + 1 as libc::c_longlong) as isize),
                    i___0,
                );
                tmp___9 = OOM_CD(
                    0 as libc::c_int as I,
                    x___0,
                    g,
                    -(1 as libc::c_int) as V,
                );
                if tmp___9 == 0 {
                    return 0 as K;
                }
                let ref mut fresh169 = *((*g).k)
                    .as_mut_ptr()
                    .offset((j + 1 as libc::c_longlong) as isize);
                *fresh169 = x___0;
                j += 1;
            }
            x___0 = bv_ex(p.offset(-(1 as libc::c_int as isize)), g);
            tmp___10 = OOM_CD(0 as libc::c_int as I, x___0, g, -(1 as libc::c_int) as V);
            if tmp___10 == 0 {
                return 0 as K;
            }
            j___0 = 0 as libc::c_int as I;
            _j___0 = (*g).n;
            while j___0 < _j___0 {
                cd(*((*g).k).as_mut_ptr().offset(j___0 as isize));
                let ref mut fresh170 = *((*g).k).as_mut_ptr().offset(j___0 as isize);
                *fresh170 = 0 as *mut k0;
                j___0 += 1;
            }
            z = x___0;
            i___0 += 1;
        }
        cd(g);
        return z;
    }
    if offsetScan == q as L {
        i___1 = 0 as libc::c_int as I;
        _i___2 = (*k).n - 1 as libc::c_longlong;
        while i___1 < _i___2 {
            x___0 = *((*k).k)
                .as_mut_ptr()
                .offset((i___1 + 1 as libc::c_longlong) as isize);
            if !x___0.is_null() {
                if (*x___0).n == 0 {
                    tmp___11 = ci(
                        *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                    );
                    return tmp___11;
                }
                tmp___13 = atomI(x___0);
                if tmp___13 == 0 {
                    if n != 0 {
                        if n != (*x___0).n {
                            tmp___12 = kerr(
                                b"length\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___12;
                        } else {
                            n = (*x___0).n;
                        }
                    } else {
                        n = (*x___0).n;
                    }
                }
            }
            i___1 += 1;
        }
        if n == 0 {
            tmp___14 = bv_ex(p.offset(-(1 as libc::c_int as isize)), k);
            return tmp___14;
        }
        if 1 as libc::c_longlong > n {
            n = 1 as libc::c_int as I;
        } else {
            n = n;
        }
        tmp___15 = newK(0 as libc::c_int as I, 1 as libc::c_int as I);
        z___0 = tmp___15;
        tmp___16 = newK(0 as libc::c_int as I, (*k).n);
        g___0 = tmp___16;
        tmp___17 = OOM_CD(0 as libc::c_int as I, z___0, g___0, -(1 as libc::c_int) as V);
        if tmp___17 == 0 {
            return 0 as K;
        }
        let ref mut fresh171 = *((*z___0).k)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize);
        *fresh171 = ci(*((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize));
        i___2 = 0 as libc::c_int as I;
        _i___3 = n;
        while i___2 < _i___3 {
            let ref mut fresh172 = *((*g___0).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh172 = ci(
                *((*z___0).k)
                    .as_mut_ptr()
                    .offset(((*z___0).n - 1 as libc::c_longlong) as isize),
            );
            j___1 = 0 as libc::c_int as I;
            _j___1 = (*g___0).n - 1 as libc::c_longlong;
            while j___1 < _j___1 {
                x___0 = itemAtIndex(
                    *((*k).k)
                        .as_mut_ptr()
                        .offset((j___1 + 1 as libc::c_longlong) as isize),
                    i___2,
                );
                tmp___18 = OOM_CD(
                    0 as libc::c_int as I,
                    x___0,
                    z___0,
                    g___0,
                    -(1 as libc::c_int) as V,
                );
                if tmp___18 == 0 {
                    return 0 as K;
                }
                let ref mut fresh173 = *((*g___0).k)
                    .as_mut_ptr()
                    .offset((j___1 + 1 as libc::c_longlong) as isize);
                *fresh173 = x___0;
                j___1 += 1;
            }
            x___0 = bv_ex(p.offset(-(1 as libc::c_int as isize)), g___0);
            tmp___19 = OOM_CD(
                0 as libc::c_int as I,
                x___0,
                z___0,
                g___0,
                -(1 as libc::c_int) as V,
            );
            if tmp___19 == 0 {
                return 0 as K;
            }
            j___2 = 0 as libc::c_int as I;
            _j___2 = (*g___0).n;
            while j___2 < _j___2 {
                cd(*((*g___0).k).as_mut_ptr().offset(j___2 as isize));
                let ref mut fresh174 = *((*g___0).k).as_mut_ptr().offset(j___2 as isize);
                *fresh174 = 0 as *mut k0;
                j___2 += 1;
            }
            kap(&mut z___0, &mut x___0 as *mut K as V);
            cd(x___0);
            i___2 += 1;
        }
        cd(g___0);
        z___0 = collapse(z___0);
        return z___0;
    }
    if offsetEach == q as L {
        i___3 = 0 as libc::c_int as I;
        _i___4 = (*k).n;
        while i___3 < _i___4 {
            x___0 = *((*k).k).as_mut_ptr().offset(i___3 as isize);
            if !x___0.is_null() {
                if (*x___0).n == 0 {
                    tmp___20 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                    return tmp___20;
                }
                tmp___22 = atomI(x___0);
                if tmp___22 == 0 {
                    if n != 0 {
                        if n != (*x___0).n {
                            tmp___21 = kerr(
                                b"length\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___21;
                        } else {
                            n = (*x___0).n;
                        }
                    } else {
                        n = (*x___0).n;
                    }
                }
            }
            i___3 += 1;
        }
        c = (n == 0) as libc::c_int as I;
        if 1 as libc::c_longlong > n {
            n = 1 as libc::c_int as I;
        } else {
            n = n;
        }
        tmp___23 = newK(0 as libc::c_int as I, n);
        z___1 = tmp___23;
        tmp___24 = newK(0 as libc::c_int as I, (*k).n);
        g___1 = tmp___24;
        tmp___25 = OOM_CD(0 as libc::c_int as I, g___1, z___1, -(1 as libc::c_int) as V);
        if tmp___25 == 0 {
            return 0 as K;
        }
        i___4 = 0 as libc::c_int as I;
        _i___5 = n;
        while i___4 < _i___5 {
            j___3 = 0 as libc::c_int as I;
            _j___3 = (*k).n;
            while j___3 < _j___3 {
                x___1 = itemAtIndex(
                    *((*k).k).as_mut_ptr().offset(j___3 as isize),
                    i___4,
                );
                tmp___26 = OOM_CD(
                    0 as libc::c_int as I,
                    x___1,
                    g___1,
                    z___1,
                    -(1 as libc::c_int) as V,
                );
                if tmp___26 == 0 {
                    return 0 as K;
                }
                let ref mut fresh175 = *((*g___1).k).as_mut_ptr().offset(j___3 as isize);
                *fresh175 = x___1;
                j___3 += 1;
            }
            x___1 = bv_ex(p.offset(-(1 as libc::c_int as isize)), g___1);
            tmp___27 = OOM_CD(
                0 as libc::c_int as I,
                x___1,
                z___1,
                g___1,
                -(1 as libc::c_int) as V,
            );
            if tmp___27 == 0 {
                return 0 as K;
            }
            let ref mut fresh176 = *((*z___1).k).as_mut_ptr().offset(i___4 as isize);
            *fresh176 = x___1;
            j___4 = 0 as libc::c_int as I;
            _j___4 = (*k).n;
            while j___4 < _j___4 {
                cd(*((*g___1).k).as_mut_ptr().offset(j___4 as isize));
                let ref mut fresh177 = *((*g___1).k).as_mut_ptr().offset(j___4 as isize);
                *fresh177 = 0 as *mut k0;
                j___4 += 1;
            }
            i___4 += 1;
        }
        cd(g___1);
        if c != 0 {
            z___1 = collapse(z___1);
        } else {
            z___1 = demote(z___1);
        }
        return z___1;
    }
    if offsetEachright == q as L {
        if (*k).n != 2 as libc::c_longlong {
            tmp___28 = kerr(b"valence\0" as *const u8 as *const libc::c_char);
            return tmp___28;
        }
        a = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        b___1 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        tmp___29 = eachright2(a, p, b___1);
        return tmp___29;
    }
    if offsetEachleft == q as L {
        if (*k).n != 2 as libc::c_longlong {
            tmp___30 = kerr(b"valence\0" as *const u8 as *const libc::c_char);
            return tmp___30;
        }
        a___0 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        b___2 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        tmp___31 = eachleft2(a___0, p, b___2);
        return tmp___31;
    }
    if offsetEachpair == q as L {
        if (*k).n != 2 as libc::c_longlong {
            tmp___32 = kerr(b"valence\0" as *const u8 as *const libc::c_char);
            return tmp___32;
        }
        a___1 = *((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        b___3 = *((*k).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        tmp___33 = eachpair2(a___1, p, b___3);
        return tmp___33;
    }
    tmp___34 = vf_ex(*p, k);
    return tmp___34;
}
pub unsafe extern "C" fn ex1(
    mut w___0: *mut V,
    mut k: K,
    mut i: *mut I,
    mut n: I,
    mut f: I,
) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut d___0: I = 0;
    let mut tmp___14: I = 0;
    let mut a: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut kb: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: I = 0;
    let mut b___1: *mut V = 0 as *mut V;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: V = 0 as *mut libc::c_void;
    let mut tmp___18: V = 0 as *mut libc::c_void;
    let mut a___0: K = 0 as *mut k0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut kb___0: K = 0 as *mut k0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: I = 0;
    let mut b___2: *mut V = 0 as *mut V;
    let mut i___1: I = 0;
    let mut _i___1: I = 0;
    let mut j: I = 0;
    let mut tmp___22: I = 0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___23: V = 0 as *mut libc::c_void;
    let mut q: V = 0 as *mut libc::c_void;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: *mut K = 0 as *mut K;
    let mut z: K = 0 as *mut k0;
    let mut tmp___26: K = 0 as *mut k0;
    let mut tmp___27: I = 0;
    if offsetColon as libc::c_ulong
        == *w___0.offset(0 as libc::c_int as isize) as libc::c_ulong
    {
        if *w___0.offset(1 as libc::c_int as isize) as UI > DT_SIZE as UI {
            if *w___0.offset(2 as libc::c_int as isize) as UI > DT_SIZE as UI {
                if fwh == 0 as libc::c_longlong {
                    fer = 1 as libc::c_int as I;
                    if f != 0 {
                        *i = n;
                    } else {
                        *i = -(1 as libc::c_int) as I;
                    }
                    tmp = *(*w___0.offset(1 as libc::c_int as isize) as *mut K);
                    tmp___0 = ci(tmp);
                    return tmp___0;
                }
            }
        }
    }
    if DT_ADVERB_OFFSET <= *w___0 as L {
        if (*w___0 as L) < DT_VERB_OFFSET {
            if offsetScan != *w___0.offset(1 as libc::c_int as isize) as L {
                if 0 as *mut libc::c_void as libc::c_ulong
                    != *w___0.offset(1 as libc::c_int as isize) as libc::c_ulong
                {
                    if offsetScan == *w___0 as L {
                        tmp___2 = strcmp(
                            fBreak as *const libc::c_char,
                            b"n\0" as *const u8 as *const libc::c_char,
                        );
                        if 0 as libc::c_int == tmp___2 {
                            tmp___1 = ex2(w___0.offset(1 as libc::c_int as isize), k);
                            return tmp___1;
                        }
                        tmp___4 = strcmp(
                            fBreak as *const libc::c_char,
                            b"t\0" as *const u8 as *const libc::c_char,
                        );
                        if 0 as libc::c_int == tmp___4 {
                            tmp___3 = ex2(w___0.offset(1 as libc::c_int as isize), k);
                            return tmp___3;
                        }
                        tmp___6 = strcmp(
                            fBreak as *const libc::c_char,
                            b"s\0" as *const u8 as *const libc::c_char,
                        );
                        if 0 as libc::c_int == tmp___6 {
                            fer = 1 as libc::c_int as I;
                            tmp___5 = ex2(w___0.offset(1 as libc::c_int as isize), k);
                            return tmp___5;
                        }
                    } else if offsetEach as V as libc::c_ulong == *w___0 as libc::c_ulong
                        {
                        if (**(*w___0.offset(1 as libc::c_int as isize) as *mut K)).t
                            < 0 as libc::c_longlong
                        {
                            tmp___9 = -(**(*w___0.offset(1 as libc::c_int as isize)
                                as *mut K))
                                .t;
                        } else {
                            tmp___9 = (**(*w___0.offset(1 as libc::c_int as isize)
                                as *mut K))
                                .t;
                        }
                        if 3 as libc::c_longlong == tmp___9 {
                            tmp___7 = ci(
                                *(*w___0.offset(1 as libc::c_int as isize) as *mut K),
                            );
                            return tmp___7;
                        } else {
                            tmp___8 = _n();
                            return tmp___8;
                        }
                    } else {
                        tmp___10 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                        return tmp___10;
                    }
                }
            }
        }
    }
    c = 0 as libc::c_int as I;
    while !(*w___0.offset(c as isize)).is_null() {
        tmp___11 = bk(*w___0.offset(c as isize));
        if tmp___11 != 0 {
            break;
        }
        c += 1;
        if offsetColon as libc::c_ulong
            == *w___0.offset((c - 1 as libc::c_longlong) as isize) as libc::c_ulong
        {
            break;
        }
    }
    if c == 0 {
        tmp___12 = ex2(w___0, k);
        return tmp___12;
    } else {
        tmp___13 = VA(*w___0.offset((c - 1 as libc::c_longlong) as isize));
        if tmp___13 != 0 {
            if c > 1 as libc::c_longlong {
                if offsetColon as libc::c_ulong
                    == *w___0.offset((c - 1 as libc::c_longlong) as isize)
                        as libc::c_ulong
                {
                    tmp___12 = ex2(w___0, k);
                    return tmp___12;
                }
            }
        } else {
            tmp___12 = ex2(w___0, k);
            return tmp___12;
        }
    }
    if *w___0.offset(0 as libc::c_int as isize) as libc::c_ulong
        == offsetColon as libc::c_ulong
    {
        if *w___0.offset(1 as libc::c_int as isize) as UI > DT_SIZE as UI {
            d___0 = 0 as libc::c_int as I;
            while !(*w___0.offset(d___0 as isize)).is_null() {
                tmp___14 = bk(*w___0.offset(d___0 as isize));
                if tmp___14 != 0 {
                    break;
                }
                d___0 += 1;
            }
            tmp___15 = Kv();
            a = tmp___15;
            (*a).n = 0 as libc::c_int as I;
            tmp___16 = newK(-(4 as libc::c_int) as I, d___0);
            kb = tmp___16;
            tmp___17 = OOM_CD(0 as libc::c_int as I, a, kb, -(1 as libc::c_int) as V);
            if tmp___17 == 0 {
                return 0 as K;
            }
            b___1 = ((*kb).k).as_mut_ptr() as *mut V;
            i___0 = 0 as libc::c_int as I;
            _i___0 = d___0 - 1 as libc::c_longlong;
            while i___0 < _i___0 {
                let ref mut fresh178 = *b___1.offset(i___0 as isize);
                *fresh178 = *w___0.offset((i___0 + 1 as libc::c_longlong) as isize);
                i___0 += 1;
            }
            let ref mut fresh179 = *b___1
                .offset((d___0 - 1 as libc::c_longlong) as isize);
            *fresh179 = 0 as V;
            let ref mut fresh180 = *(((*a).k).as_mut_ptr() as *mut V)
                .offset(2 as libc::c_int as isize);
            *fresh180 = kb as V;
            tmp___18 = ex_(&mut a as *mut K as V, 0 as libc::c_int as I);
            x___0 = tmp___18;
            cd(a);
            if *w___0.offset(-(1 as libc::c_int) as isize) as libc::c_ulong
                != offsetColon as libc::c_ulong
            {
                fer = 1 as libc::c_int as I;
            }
            return x___0 as K;
        }
    }
    tmp___19 = Kv();
    a___0 = tmp___19;
    tmp___20 = newK(-(4 as libc::c_int) as I, 1 as libc::c_longlong + c);
    kb___0 = tmp___20;
    tmp___21 = OOM_CD(0 as libc::c_int as I, a___0, kb___0, -(1 as libc::c_int) as V);
    if tmp___21 == 0 {
        return 0 as K;
    }
    b___2 = ((*kb___0).k).as_mut_ptr() as *mut V;
    let ref mut fresh181 = *b___2.offset(c as isize);
    *fresh181 = 0 as V;
    i___1 = 0 as libc::c_int as I;
    _i___1 = c;
    while i___1 < _i___1 {
        j = c - i___1 - 1 as libc::c_longlong;
        let ref mut fresh182 = *b___2.offset(j as isize);
        *fresh182 = *w___0.offset(j as isize);
        tmp___22 = VA(*b___2.offset(j as isize));
        if !(tmp___22 != 0) {
            tmp___23 = ex_(*w___0.offset(j as isize), 1 as libc::c_int as I);
            r = tmp___23 as K;
            tmp___24 = newE(LS, r);
            q = tmp___24 as V;
            kap(
                (((*a___0).k).as_mut_ptr() as *mut V as *mut K)
                    .offset(3 as libc::c_int as isize),
                &mut q as *mut V as V,
            );
            cd(q as K);
            tmp___25 = EVP(q as K);
            q = tmp___25 as V;
            let ref mut fresh183 = *b___2.offset(j as isize);
            *fresh183 = q;
        }
        i___1 += 1;
    }
    let ref mut fresh184 = *(((*a___0).k).as_mut_ptr() as *mut V)
        .offset(2 as libc::c_int as isize);
    *fresh184 = kb___0 as V;
    if fll > 0 as libc::c_longlong {
        if 2 as libc::c_longlong == (*kb___0).n {
            tmp___27 = kdefClass(
                *(((*kb___0).k).as_mut_ptr() as *mut V).offset(0 as libc::c_int as isize)
                    as I,
            );
            if tmp___27 != 0 {
                tmp___26 = kdef(
                    *(((*kb___0).k).as_mut_ptr() as *mut V)
                        .offset(0 as libc::c_int as isize) as I,
                );
                z = tmp___26;
                cd(a___0);
                return z;
            }
        }
    }
    return a___0;
}
unsafe extern "C" fn ex2(mut v: *mut V, mut k: K) -> K {
    let mut current_block: u64;
    let mut t0___0: K = 0 as *mut k0;
    let mut t2: K = 0 as *mut k0;
    let mut t3: K = 0 as *mut k0;
    let mut e: K = 0 as *mut k0;
    let mut u: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___4: V = 0 as *mut libc::c_void;
    let mut j0___0: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut j1___0: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut j2: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___14: V = 0 as *mut libc::c_void;
    let mut tmp___15: K = 0 as *mut k0;
    let mut j0___1: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut j1___1: K = 0 as *mut k0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut j2___0: K = 0 as *mut k0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: I = 0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut tmp___24: I = 0;
    let mut a: K = 0 as *mut k0;
    let mut b___1: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut p: K = 0 as *mut k0;
    let mut w___0: *mut K = 0 as *mut K;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: V = 0 as *mut libc::c_void;
    let mut r: K = 0 as *mut k0;
    let mut kc: K = 0 as *mut k0;
    let mut tmp___27: K = 0 as *mut k0;
    let mut tmp___28: I = 0;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: I = 0;
    let mut tmp___32: I = 0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut tmp___34: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___35: I = 0;
    let mut x___1: K = 0 as *mut k0;
    let mut tmp___36: I = 0;
    let mut tmp___37: I = 0;
    let mut tmp___38: I = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp___39: K = 0 as *mut k0;
    let mut tmp___40: I = 0;
    let mut j: K = 0 as *mut k0;
    let mut tmp___41: K = 0 as *mut k0;
    let mut tmp___42: I = 0;
    let mut tmp___43: I = 0;
    let mut tmp___44: I = 0;
    let mut tmp___45: libc::c_int = 0;
    let mut tmp___46: V = 0 as *mut libc::c_void;
    let mut j0___2: K = 0 as *mut k0;
    let mut tmp___47: K = 0 as *mut k0;
    let mut j1___2: K = 0 as *mut k0;
    let mut tmp___48: K = 0 as *mut k0;
    let mut j2___1: K = 0 as *mut k0;
    let mut tmp___49: K = 0 as *mut k0;
    let mut tmp___50: K = 0 as *mut k0;
    let mut tmp___51: K = 0 as *mut k0;
    let mut tmp___53: I = 0;
    let mut tmp___54: V = 0 as *mut libc::c_void;
    let mut tmp___55: libc::c_int = 0;
    let mut j0___3: K = 0 as *mut k0;
    let mut tmp___56: K = 0 as *mut k0;
    let mut j1___3: K = 0 as *mut k0;
    let mut tmp___57: K = 0 as *mut k0;
    let mut j2___2: K = 0 as *mut k0;
    let mut tmp___58: K = 0 as *mut k0;
    let mut tmp___59: K = 0 as *mut k0;
    let mut tmp___60: K = 0 as *mut k0;
    let mut p___0: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut q: *mut V = 0 as *mut V;
    let mut tmp___61: I = 0;
    let mut tmp___62: I = 0;
    let mut tmp___63: I = 0;
    let mut tmp___64: I = 0;
    let mut tmp___65: V = 0 as *mut libc::c_void;
    let mut j0___4: K = 0 as *mut k0;
    let mut tmp___66: K = 0 as *mut k0;
    let mut j1___4: K = 0 as *mut k0;
    let mut tmp___67: K = 0 as *mut k0;
    let mut j2___3: K = 0 as *mut k0;
    let mut tmp___68: K = 0 as *mut k0;
    let mut tmp___69: K = 0 as *mut k0;
    let mut tmp___70: K = 0 as *mut k0;
    let mut j0___5: K = 0 as *mut k0;
    let mut tmp___71: K = 0 as *mut k0;
    let mut j1___5: K = 0 as *mut k0;
    let mut tmp___72: K = 0 as *mut k0;
    let mut j2___4: K = 0 as *mut k0;
    let mut tmp___73: K = 0 as *mut k0;
    let mut tmp___74: K = 0 as *mut k0;
    let mut tmp___75: K = 0 as *mut k0;
    let mut j0___6: K = 0 as *mut k0;
    let mut tmp___76: K = 0 as *mut k0;
    let mut j1___6: K = 0 as *mut k0;
    let mut tmp___77: K = 0 as *mut k0;
    let mut j2___5: K = 0 as *mut k0;
    let mut tmp___78: K = 0 as *mut k0;
    let mut tmp___79: K = 0 as *mut k0;
    let mut tmp___80: K = 0 as *mut k0;
    let mut j0___7: K = 0 as *mut k0;
    let mut tmp___81: K = 0 as *mut k0;
    let mut j1___7: K = 0 as *mut k0;
    let mut tmp___82: K = 0 as *mut k0;
    let mut j2___6: K = 0 as *mut k0;
    let mut tmp___83: K = 0 as *mut k0;
    let mut tmp___84: K = 0 as *mut k0;
    let mut tmp___85: K = 0 as *mut k0;
    let mut tmp___87: I = 0;
    let mut tmp___88: I = 0;
    i = 0 as libc::c_int as I;
    ft3 = 0 as libc::c_int as I;
    's_339: {
        if !v.is_null() {
            if !(*v).is_null() {
                break 's_339;
            }
        }
        if !k.is_null() {
            if 1 as libc::c_longlong == (*k).n {
                tmp = ci(*((*k).k).as_mut_ptr().offset(0 as libc::c_int as isize));
                tmp___1 = tmp;
            } else {
                tmp___0 = ci(k);
                tmp___1 = tmp___0;
            }
            tmp___2 = tmp___1;
        } else {
            tmp___2 = DT_END_OFFSET as K;
        }
        return tmp___2;
    }
    tmp___3 = bk(*v);
    if tmp___3 != 0 {
        return *v as K;
    }
    if (*v.offset(1 as libc::c_int as isize)).is_null() {
        if k.is_null() {
            tmp___4 = ex_(*v, 1 as libc::c_int as I);
            z = tmp___4 as K;
            if z as libc::c_ulong > DT_SIZE as K as libc::c_ulong {
                if (*z).t == 7 as libc::c_longlong {
                    if (*z).n == 3 as libc::c_longlong {
                        if !prnt.is_null() {
                            if !(*(((*z).k).as_mut_ptr() as *mut V)
                                .offset(4 as libc::c_int as isize))
                                .is_null()
                            {
                                if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                    .offset(7 as libc::c_int as isize))
                                    .is_null()
                                {
                                    if (*(((*z).k).as_mut_ptr() as *mut V)
                                        .offset(7 as libc::c_int as isize))
                                        .is_null()
                                    {
                                        if (**((*z).k)
                                            .as_mut_ptr()
                                            .offset(3 as libc::c_int as isize))
                                            .n == 0
                                        {
                                            tmp___5 = dot_monadic(
                                                *(((*z).k).as_mut_ptr() as *mut V)
                                                    .offset(4 as libc::c_int as isize) as K,
                                            );
                                            j0___0 = tmp___5;
                                            tmp___6 = dot_monadic(
                                                *(((*prnt).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize) as K,
                                            );
                                            j1___0 = tmp___6;
                                            tmp___7 = ci(j0___0);
                                            tmp___8 = join(tmp___7, j1___0);
                                            j2 = tmp___8;
                                            cd(j0___0);
                                            if encp == 0 as libc::c_longlong {
                                                tmp___9 = dot_monadic(j2);
                                                let ref mut fresh185 = *(((*z).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize);
                                                *fresh185 = tmp___9 as V;
                                            }
                                            if encp == 1 as libc::c_longlong {
                                                tmp___10 = dot_monadic(j1___0);
                                                let ref mut fresh186 = *(((*z).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize);
                                                *fresh186 = tmp___10 as V;
                                            }
                                            cd(j0___0);
                                            cd(j1___0);
                                            cd(j2);
                                            cd(
                                                *((*prnt).k).as_mut_ptr().offset(6 as libc::c_int as isize),
                                            );
                                            let ref mut fresh187 = *(((*prnt).k).as_mut_ptr() as *mut V)
                                                .offset(6 as libc::c_int as isize);
                                            *fresh187 = 0 as V;
                                        }
                                    }
                                }
                            }
                        }
                        if !prnt.is_null() {
                            if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                .offset(2 as libc::c_int as isize))
                                .is_null()
                            {
                                if (**((*prnt).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .t == -(3 as libc::c_longlong)
                                {
                                    if *(((**((*prnt).k)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr() as *mut C)
                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                        == 123 as libc::c_int
                                    {
                                        if *(((**((*prnt).k)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize))
                                            .k)
                                            .as_mut_ptr() as *mut C)
                                            .offset(
                                                ((**((*prnt).k)
                                                    .as_mut_ptr()
                                                    .offset(2 as libc::c_int as isize))
                                                    .n - 1 as libc::c_longlong) as isize,
                                            ) as libc::c_int
                                            == *(b"}\0" as *const u8 as *const libc::c_char)
                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                        {
                                            tmp___11 = strchr(
                                                ((**((*prnt).k)
                                                    .as_mut_ptr()
                                                    .offset(2 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr() as *mut C as *const libc::c_char,
                                                *(b"y\0" as *const u8 as *const libc::c_char)
                                                    .offset(0 as libc::c_int as isize) as libc::c_int,
                                            );
                                            if !tmp___11.is_null() {
                                                if !encf.is_null() {
                                                    cd(encf);
                                                }
                                                encf = ci(prnt);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if !(encp != 2 as libc::c_longlong) {
                            if !prnt.is_null() {
                                cd(z);
                                return prnt;
                            }
                        }
                        if !prnt.is_null() {
                            if !grnt.is_null() {
                                cd(grnt);
                            }
                            grnt = prnt;
                        }
                        prnt = ci(z);
                    }
                }
            }
            return z;
        }
    }
    if (*v.offset(1 as libc::c_int as isize)).is_null() {
        tmp___13 = sva(*v);
        if tmp___13 != 0 {
            tmp___12 = vf_ex(*v, k);
            return tmp___12;
        }
    }
    tmp___22 = bk(*v.offset(1 as libc::c_int as isize));
    if tmp___22 != 0 {
        tmp___14 = ex_(*v, 1 as libc::c_int as I);
        z___0 = tmp___14 as K;
        if fer == 2 as libc::c_longlong {
            if fCheck == 0 {
                return 0 as K;
            }
        }
        if !prnt.is_null() {
            if !z___0.is_null() {
                if (*z___0).t == 7 as libc::c_longlong {
                    if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                        .offset(4 as libc::c_int as isize))
                        .is_null()
                    {
                        if (**((*prnt).k).as_mut_ptr().offset(4 as libc::c_int as isize))
                            .n == 0
                        {
                            if !(*(((*z___0).k).as_mut_ptr() as *mut V)
                                .offset(3 as libc::c_int as isize))
                                .is_null()
                            {
                                if (**((*z___0).k)
                                    .as_mut_ptr()
                                    .offset(3 as libc::c_int as isize))
                                    .n == 0
                                {
                                    if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                        .offset(3 as libc::c_int as isize))
                                        .is_null()
                                    {
                                        if (**((*prnt).k)
                                            .as_mut_ptr()
                                            .offset(3 as libc::c_int as isize))
                                            .n != 0
                                        {
                                            tmp___15 = kcloneI(
                                                *((*prnt).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                847 as libc::c_int,
                                            );
                                            let ref mut fresh188 = *(((*z___0).k).as_mut_ptr()
                                                as *mut V)
                                                .offset(7 as libc::c_int as isize);
                                            *fresh188 = tmp___15 as V;
                                            if !prnt.is_null() {
                                                cd(prnt);
                                            }
                                            prnt = ci(z___0);
                                            current_block = 10720305954121010852;
                                        } else {
                                            current_block = 1970176346044679179;
                                        }
                                    } else {
                                        current_block = 1970176346044679179;
                                    }
                                } else {
                                    current_block = 1970176346044679179;
                                }
                            } else {
                                current_block = 1970176346044679179;
                            }
                        } else {
                            current_block = 1970176346044679179;
                        }
                    } else {
                        current_block = 1970176346044679179;
                    }
                    match current_block {
                        10720305954121010852 => {}
                        _ => {
                            if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                .offset(3 as libc::c_int as isize))
                                .is_null()
                            {
                                if (**((*prnt).k)
                                    .as_mut_ptr()
                                    .offset(3 as libc::c_int as isize))
                                    .n != 0
                                {
                                    if !(*(((*z___0).k).as_mut_ptr() as *mut V)
                                        .offset(4 as libc::c_int as isize))
                                        .is_null()
                                    {
                                        if (**((*z___0).k)
                                            .as_mut_ptr()
                                            .offset(4 as libc::c_int as isize))
                                            .n != 0
                                        {
                                            if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                                .offset(7 as libc::c_int as isize))
                                                .is_null()
                                            {
                                                tmp___16 = dot_monadic(
                                                    *(((*z___0).k).as_mut_ptr() as *mut V)
                                                        .offset(4 as libc::c_int as isize) as K,
                                                );
                                                j0___1 = tmp___16;
                                                tmp___17 = dot_monadic(
                                                    *(((*prnt).k).as_mut_ptr() as *mut V)
                                                        .offset(7 as libc::c_int as isize) as K,
                                                );
                                                j1___1 = tmp___17;
                                                tmp___18 = ci(j0___1);
                                                tmp___19 = join(tmp___18, j1___1);
                                                j2___0 = tmp___19;
                                                cd(j0___1);
                                                tmp___20 = dot_monadic(j2___0);
                                                let ref mut fresh189 = *(((*z___0).k).as_mut_ptr()
                                                    as *mut V)
                                                    .offset(7 as libc::c_int as isize);
                                                *fresh189 = tmp___20 as V;
                                                cd(j0___1);
                                                cd(j1___1);
                                                cd(j2___0);
                                            } else {
                                                tmp___21 = kcloneI(
                                                    *(((*z___0).k).as_mut_ptr() as *mut V)
                                                        .offset(4 as libc::c_int as isize) as K,
                                                    b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                                    852 as libc::c_int,
                                                );
                                                let ref mut fresh190 = *(((*z___0).k).as_mut_ptr()
                                                    as *mut V)
                                                    .offset(7 as libc::c_int as isize);
                                                *fresh190 = tmp___21 as V;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return z___0;
    } else {
        tmp___42 = VA(*v);
        if tmp___42 == 0 {
            if offsetColon as libc::c_ulong
                == *v.offset(1 as libc::c_int as isize) as libc::c_ulong
            {
                current_block = 14992491677151671251;
            } else {
                tmp___43 = VA(*v.offset(1 as libc::c_int as isize));
                if tmp___43 != 0 {
                    if offsetColon as libc::c_ulong
                        == *v.offset(2 as libc::c_int as isize) as libc::c_ulong
                    {
                        current_block = 14992491677151671251;
                    } else {
                        current_block = 3316925224002568308;
                    }
                } else {
                    current_block = 3316925224002568308;
                }
            }
            match current_block {
                3316925224002568308 => {}
                _ => {
                    tmp___24 = adverbClass(*v.offset(1 as libc::c_int as isize));
                    if tmp___24 != 0 {
                        tmp___23 = kerr(b"syntax\0" as *const u8 as *const libc::c_char);
                        return tmp___23;
                    }
                    a = 0 as K;
                    b___1 = 0 as K;
                    c = 0 as K;
                    d___0 = 0 as K;
                    p = 0 as K;
                    w___0 = *v as *mut K;
                    a = *w___0;
                    if a.is_null() {
                        return 0 as K;
                    }
                    if 7 as libc::c_longlong == (*a).t {
                        if 0 as libc::c_longlong == (*a).n {
                            b___1 = *(((*a).k).as_mut_ptr() as *mut V)
                                .offset(5 as libc::c_int as isize) as K;
                            if !b___1.is_null() {
                                if 7 as libc::c_longlong == (*b___1).t {
                                    if 0 as libc::c_longlong == (*b___1).n {
                                        if *(((*(*(((*b___1).k).as_mut_ptr() as *mut V)
                                            .offset(2 as libc::c_int as isize) as K))
                                            .k)
                                            .as_mut_ptr() as *mut S as *mut V) as L
                                            == 1 as libc::c_longlong
                                        {
                                            tmp___25 = 1 as libc::c_int;
                                        } else if *(((*(*(((*b___1).k).as_mut_ptr() as *mut V)
                                                .offset(2 as libc::c_int as isize) as K))
                                                .k)
                                                .as_mut_ptr() as *mut S as *mut V)
                                                .offset(1 as libc::c_int as isize) as L
                                                == 1 as libc::c_longlong
                                            {
                                            tmp___25 = 1 as libc::c_int;
                                        } else {
                                            tmp___25 = 2 as libc::c_int;
                                        }
                                        tmp___26 = ex_(
                                            (((*a).k).as_mut_ptr() as *mut V)
                                                .offset(5 as libc::c_int as isize) as V,
                                            tmp___25 as I,
                                        );
                                        b___1 = tmp___26 as K;
                                        if b___1.is_null() {
                                            return 0 as K;
                                        }
                                        w___0 = *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                                            .offset(2 as libc::c_int as isize) as K))
                                            .k)
                                            .as_mut_ptr() as *mut S as *mut V) as *mut K;
                                        if (*b___1).t == 0 as libc::c_longlong {
                                            if (*b___1).n == 0 as libc::c_longlong {
                                                if 1e6f64 < w___0 as UI as libc::c_double {
                                                    r = *w___0;
                                                    if (*r).t == 5 as libc::c_longlong {
                                                        p = enumerate(r);
                                                        cd(b___1);
                                                        b___1 = enlist(p);
                                                        cd(p);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if b___1.is_null() {
                        b___1 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                        if b___1.is_null() {
                            return 0 as K;
                        }
                    }
                    c = Kv();
                    tmp___27 = newK(-(4 as libc::c_int) as I, 2 as libc::c_int as I);
                    kc = tmp___27;
                    tmp___28 = OOM_CD(
                        0 as libc::c_int as I,
                        b___1,
                        c,
                        kc,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___28 == 0 {
                        return 0 as K;
                    }
                    let ref mut fresh191 = *(((*c).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize);
                    *fresh191 = kc as V;
                    let ref mut fresh192 = *(((*(*(((*c).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut S as *mut V);
                    *fresh192 = *v.offset(1 as libc::c_int as isize);
                    tmp___30 = sva(*v.offset(1 as libc::c_int as isize));
                    if 1 as libc::c_longlong != tmp___30 {
                        if offsetColon as libc::c_ulong
                            == *v.offset(1 as libc::c_int as isize) as libc::c_ulong
                        {
                            tmp___29 = 2 as libc::c_int;
                        } else {
                            tmp___29 = 3 as libc::c_int;
                        }
                        d___0 = ex1(
                            v.offset(tmp___29 as isize),
                            k,
                            0 as *mut I,
                            0 as libc::c_int as I,
                            1 as libc::c_int as I,
                        );
                    }
                    tmp___32 = bk(d___0 as V);
                    if tmp___32 != 0 {
                        d___0 = 0 as K;
                    } else {
                        d___0 = d___0;
                    }
                    if fer > 0 as libc::c_longlong {
                        cd(c);
                        cd(d___0);
                        cd(b___1);
                        tmp___33 = _n();
                        return tmp___33;
                    }
                    if (*w___0).is_null() {
                        tmp___34 = kerr(b"parse\0" as *const u8 as *const libc::c_char);
                        return tmp___34;
                    }
                    tmp___37 = cirRef(*w___0, d___0);
                    if tmp___37 != 0 {
                        current_block = 5199509390545736579;
                    } else {
                        if (**w___0).t == 6 as libc::c_longlong {
                            if !d___0.is_null() {
                                if (*d___0).t == 0 as libc::c_longlong {
                                    current_block = 5199509390545736579;
                                } else if (*d___0).t == 5 as libc::c_longlong {
                                    current_block = 5199509390545736579;
                                } else {
                                    if (*d___0).t < 0 as libc::c_longlong {
                                        tmp___38 = -(*d___0).t;
                                    } else {
                                        tmp___38 = (*d___0).t;
                                    }
                                    if tmp___38 != (*d___0).t {
                                        current_block = 5199509390545736579;
                                    } else {
                                        current_block = 8476377745503292289;
                                    }
                                }
                            } else {
                                current_block = 8476377745503292289;
                            }
                        } else {
                            current_block = 8476377745503292289;
                        }
                        match current_block {
                            5199509390545736579 => {}
                            _ => {
                                if (**w___0).t != 6 as libc::c_longlong {
                                    x___1 = *w___0;
                                    tmp___36 = rc(x___1);
                                    if tmp___36 > 1 as libc::c_longlong {
                                        *w___0 = kcloneI(
                                            x___1,
                                            b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                            872 as libc::c_int,
                                        );
                                        cd(x___1);
                                    }
                                }
                                current_block = 11911614146017124710;
                            }
                        }
                    }
                    match current_block {
                        5199509390545736579 => {
                            x___0 = d___0;
                            tmp___35 = rc(x___0);
                            if tmp___35 != 0 {
                                d___0 = kcloneI(
                                    x___0,
                                    b"src/kx.c\0" as *const u8 as *const libc::c_char,
                                    871 as libc::c_int,
                                );
                                cd(x___0);
                            }
                        }
                        _ => {}
                    }
                    tmp___39 = dot_tetradic_2(w___0, b___1, c, d___0);
                    h = tmp___39;
                    cd(c);
                    cd(d___0);
                    tmp___40 = OOM_CD(
                        0 as libc::c_int as I,
                        b___1,
                        h,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___40 == 0 {
                        return 0 as K;
                    }
                    tmp___41 = of(h, b___1);
                    j = tmp___41;
                    cd(b___1);
                    return j;
                }
            }
        }
        while !(*v.offset(1 as libc::c_int as isize)).is_null() {
            tmp___44 = adverbClass(*v.offset((2 as libc::c_longlong + i) as isize));
            if tmp___44 == 0 {
                break;
            }
            i += 1;
        }
        tmp___62 = sva(*v.offset(0 as libc::c_int as isize));
        if tmp___62 == 0 {
            's_2084: {
                if !(i != 0) {
                    tmp___63 = sva(*v.offset(1 as libc::c_int as isize));
                    if !(2 as libc::c_longlong == tmp___63) {
                        break 's_2084;
                    }
                }
                t2 = ex2(v.offset(2 as libc::c_int as isize).offset(i as isize), k);
                if fer > 0 as libc::c_longlong {
                    tmp___45 = strcmp(
                        errmsg.as_mut_ptr() as *const libc::c_char,
                        b"(nil)\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___45 != 0 {
                        return t2;
                    }
                }
                tmp___46 = ex_(
                    *v.offset(1 as libc::c_int as isize),
                    1 as libc::c_int as I,
                );
                t3 = tmp___46 as K;
                if t3 as libc::c_ulong > DT_SIZE as K as libc::c_ulong {
                    if (*t3).t == 7 as libc::c_longlong {
                        if (*t3).n == 3 as libc::c_longlong {
                            if !prnt.is_null() {
                                if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                    .offset(7 as libc::c_int as isize))
                                    .is_null()
                                {
                                    if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                        .offset(6 as libc::c_int as isize))
                                        .is_null()
                                    {
                                        if (**((*t3).k)
                                            .as_mut_ptr()
                                            .offset(3 as libc::c_int as isize))
                                            .n == 0
                                        {
                                            tmp___47 = dot_monadic(
                                                *(((*t3).k).as_mut_ptr() as *mut V)
                                                    .offset(4 as libc::c_int as isize) as K,
                                            );
                                            j0___2 = tmp___47;
                                            tmp___48 = dot_monadic(
                                                *(((*prnt).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize) as K,
                                            );
                                            j1___2 = tmp___48;
                                            tmp___49 = ci(j0___2);
                                            tmp___50 = join(tmp___49, j1___2);
                                            j2___1 = tmp___50;
                                            cd(j0___2);
                                            cd(
                                                *((*t3).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                            );
                                            tmp___51 = dot_monadic(j2___1);
                                            let ref mut fresh193 = *(((*t3).k).as_mut_ptr() as *mut V)
                                                .offset(7 as libc::c_int as isize);
                                            *fresh193 = tmp___51 as V;
                                            cd(j0___2);
                                            cd(j1___2);
                                            cd(j2___1);
                                            if (**((*prnt).k)
                                                .as_mut_ptr()
                                                .offset(7 as libc::c_int as isize))
                                                .n != 0
                                            {
                                                fsf = 1 as libc::c_int as I;
                                            }
                                        }
                                    }
                                }
                            }
                            if !prnt.is_null() {
                                cd(prnt);
                            }
                            prnt = ci(t3);
                        }
                    }
                }
                u = *v.offset(1 as libc::c_int as isize) as K;
                tmp___53 = VA(t3 as V);
                if tmp___53 != 0 {
                    let ref mut fresh194 = *v.offset(1 as libc::c_int as isize);
                    *fresh194 = t3 as V;
                } else {
                    let ref mut fresh195 = *v.offset(1 as libc::c_int as isize);
                    *fresh195 = &mut t3 as *mut K as V;
                }
                tmp___54 = ex_(*v, 1 as libc::c_int as I);
                t0___0 = tmp___54 as K;
                if fer > 0 as libc::c_longlong {
                    tmp___55 = strcmp(
                        errmsg.as_mut_ptr() as *const libc::c_char,
                        b"(nil)\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___55 != 0 {
                        cd(t2);
                        return t0___0;
                    }
                }
                if t0___0 as libc::c_ulong > DT_SIZE as K as libc::c_ulong {
                    if (*t0___0).t == 7 as libc::c_longlong {
                        if (*t0___0).n == 3 as libc::c_longlong {
                            if !prnt.is_null() {
                                if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                    .offset(7 as libc::c_int as isize))
                                    .is_null()
                                {
                                    if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                        .offset(6 as libc::c_int as isize))
                                        .is_null()
                                    {
                                        if (**((*t0___0).k)
                                            .as_mut_ptr()
                                            .offset(3 as libc::c_int as isize))
                                            .n == 0
                                        {
                                            tmp___56 = dot_monadic(
                                                *(((*t0___0).k).as_mut_ptr() as *mut V)
                                                    .offset(4 as libc::c_int as isize) as K,
                                            );
                                            j0___3 = tmp___56;
                                            tmp___57 = dot_monadic(
                                                *(((*prnt).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize) as K,
                                            );
                                            j1___3 = tmp___57;
                                            tmp___58 = ci(j0___3);
                                            tmp___59 = join(tmp___58, j1___3);
                                            j2___2 = tmp___59;
                                            cd(j0___3);
                                            cd(
                                                *((*t0___0).k)
                                                    .as_mut_ptr()
                                                    .offset(7 as libc::c_int as isize),
                                            );
                                            tmp___60 = dot_monadic(j2___2);
                                            let ref mut fresh196 = *(((*t0___0).k).as_mut_ptr()
                                                as *mut V)
                                                .offset(7 as libc::c_int as isize);
                                            *fresh196 = tmp___60 as V;
                                            cd(j0___3);
                                            cd(j1___3);
                                            cd(j2___2);
                                            if (**((*prnt).k)
                                                .as_mut_ptr()
                                                .offset(7 as libc::c_int as isize))
                                                .n != 0
                                            {
                                                fsf = 1 as libc::c_int as I;
                                            }
                                        }
                                    }
                                }
                            }
                            if !prnt.is_null() {
                                cd(prnt);
                            }
                            prnt = ci(t0___0);
                        }
                    }
                }
                if prnt.is_null() {
                    if (*t0___0).t == 7 as libc::c_longlong {
                        if (*t0___0).n == 3 as libc::c_longlong {
                            prnt = ci(t0___0);
                        }
                    }
                }
                if *v.offset(1 as libc::c_int as isize).offset(i as isize)
                    as libc::c_ulong == offsetDot as libc::c_ulong
                {
                    if (*t0___0).t == 7 as libc::c_longlong {
                        if (*t0___0).n == 1 as libc::c_longlong {
                            if *((**((*t0___0).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize) as libc::c_ulong
                                == offsetEach as V as libc::c_ulong
                            {
                                p___0 = *(((*t0___0).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K;
                                i___0 = (*p___0).n - 2 as libc::c_longlong;
                                q = (((*p___0).k).as_mut_ptr() as *mut V)
                                    .offset(i___0 as isize);
                                e = bv_ex(q, t2);
                            } else if *((**((*t0___0).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize) as libc::c_ulong
                                    == offsetEachright as V as libc::c_ulong
                                {
                                p___0 = *(((*t0___0).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K;
                                i___0 = (*p___0).n - 2 as libc::c_longlong;
                                q = (((*p___0).k).as_mut_ptr() as *mut V)
                                    .offset(i___0 as isize);
                                e = bv_ex(q, t2);
                            } else if *((**((*t0___0).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize) as libc::c_ulong
                                    == offsetEachleft as V as libc::c_ulong
                                {
                                p___0 = *(((*t0___0).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K;
                                i___0 = (*p___0).n - 2 as libc::c_longlong;
                                q = (((*p___0).k).as_mut_ptr() as *mut V)
                                    .offset(i___0 as isize);
                                e = bv_ex(q, t2);
                            } else if *((**((*t0___0).k)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize))
                                    .k)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize) as libc::c_ulong
                                    == offsetEachpair as V as libc::c_ulong
                                {
                                p___0 = *(((*t0___0).k).as_mut_ptr() as *mut V)
                                    .offset(2 as libc::c_int as isize) as K;
                                i___0 = (*p___0).n - 2 as libc::c_longlong;
                                q = (((*p___0).k).as_mut_ptr() as *mut V)
                                    .offset(i___0 as isize);
                                e = bv_ex(q, t2);
                            } else {
                                e = dv_ex(
                                    t0___0,
                                    v.offset(1 as libc::c_int as isize).offset(i as isize),
                                    t2,
                                );
                                let ref mut fresh197 = *v.offset(1 as libc::c_int as isize);
                                *fresh197 = u as V;
                            }
                        } else {
                            e = dv_ex(
                                t0___0,
                                v.offset(1 as libc::c_int as isize).offset(i as isize),
                                t2,
                            );
                            let ref mut fresh198 = *v.offset(1 as libc::c_int as isize);
                            *fresh198 = u as V;
                        }
                    } else {
                        e = dv_ex(
                            t0___0,
                            v.offset(1 as libc::c_int as isize).offset(i as isize),
                            t2,
                        );
                        let ref mut fresh199 = *v.offset(1 as libc::c_int as isize);
                        *fresh199 = u as V;
                    }
                } else {
                    e = dv_ex(
                        t0___0,
                        v.offset(1 as libc::c_int as isize).offset(i as isize),
                        t2,
                    );
                    let ref mut fresh200 = *v.offset(1 as libc::c_int as isize);
                    *fresh200 = u as V;
                }
                cd(t0___0);
                cd(t2);
                tmp___61 = VA(t3 as V);
                if tmp___61 == 0 {
                    cd(t3);
                }
                return e;
            }
        }
        i = 0 as libc::c_int as I;
        loop {
            tmp___64 = adverbClass(*v.offset((1 as libc::c_longlong + i) as isize));
            if tmp___64 == 0 {
                break;
            }
            i += 1;
        }
        t2 = ex2(v.offset(1 as libc::c_int as isize).offset(i as isize), k);
        tmp___65 = ex_(*v, 1 as libc::c_int as I);
        t3 = tmp___65 as K;
        if (t3 as libc::c_ulong) < DT_SIZE as K as libc::c_ulong {
            ft3 = 1 as libc::c_int as I;
        }
        if t3 as libc::c_ulong > DT_SIZE as K as libc::c_ulong {
            if (*t3).t == 7 as libc::c_longlong {
                if (*t3).n == 3 as libc::c_longlong {
                    if ((*t3).k).as_mut_ptr() as *mut V as libc::c_ulong
                        == ((*grnt).k).as_mut_ptr() as *mut V as libc::c_ulong
                    {
                        if !cls.is_null() {
                            cd(cls);
                        }
                        cls = ci(
                            *((**((**((*prnt).k)
                                .as_mut_ptr()
                                .offset(7 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize))
                                .k)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                        );
                    }
                    if !prnt.is_null() {
                        if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                            .offset(6 as libc::c_int as isize))
                            .is_null()
                        {
                            if (**((*t3).k)
                                .as_mut_ptr()
                                .offset(3 as libc::c_int as isize))
                                .n == 0
                            {
                                if (**((*prnt).k)
                                    .as_mut_ptr()
                                    .offset(3 as libc::c_int as isize))
                                    .n != 0
                                {
                                    let mut current_block_465: u64;
                                    if !(*(((*t3).k).as_mut_ptr() as *mut V)
                                        .offset(6 as libc::c_int as isize))
                                        .is_null()
                                    {
                                        if (*(((*t3).k).as_mut_ptr() as *mut V)
                                            .offset(7 as libc::c_int as isize))
                                            .is_null()
                                        {
                                            let ref mut fresh201 = *((*t3).k)
                                                .as_mut_ptr()
                                                .offset(7 as libc::c_int as isize);
                                            *fresh201 = *((*prnt).k)
                                                .as_mut_ptr()
                                                .offset(7 as libc::c_int as isize);
                                            ci(
                                                *((*t3).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                            );
                                            current_block_465 = 10956753407685442945;
                                        } else {
                                            current_block_465 = 11049977943750708045;
                                        }
                                    } else {
                                        current_block_465 = 11049977943750708045;
                                    }
                                    match current_block_465 {
                                        11049977943750708045 => {
                                            let mut current_block_464: u64;
                                            if (**((*t3).k)
                                                .as_mut_ptr()
                                                .offset(4 as libc::c_int as isize))
                                                .n != 0
                                            {
                                                current_block_464 = 14928900101244553844;
                                            } else if !grnt.is_null() {
                                                current_block_464 = 14928900101244553844;
                                            } else {
                                                current_block_464 = 18421592892663940172;
                                            }
                                            match current_block_464 {
                                                14928900101244553844 => {
                                                    tmp___66 = dot_monadic(
                                                        *(((*t3).k).as_mut_ptr() as *mut V)
                                                            .offset(4 as libc::c_int as isize) as K,
                                                    );
                                                    j0___4 = tmp___66;
                                                    tmp___67 = dot_monadic(
                                                        *(((*prnt).k).as_mut_ptr() as *mut V)
                                                            .offset(7 as libc::c_int as isize) as K,
                                                    );
                                                    j1___4 = tmp___67;
                                                    tmp___68 = ci(j0___4);
                                                    tmp___69 = join(tmp___68, j1___4);
                                                    j2___3 = tmp___69;
                                                    cd(j0___4);
                                                    if !(*(((*t3).k).as_mut_ptr() as *mut V)
                                                        .offset(7 as libc::c_int as isize))
                                                        .is_null()
                                                    {
                                                        if (**((*t3).k)
                                                            .as_mut_ptr()
                                                            .offset(7 as libc::c_int as isize))
                                                            .n != 0
                                                        {
                                                            cd(
                                                                *((*t3).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                            );
                                                        }
                                                    }
                                                    tmp___70 = dot_monadic(j2___3);
                                                    let ref mut fresh202 = *(((*t3).k).as_mut_ptr() as *mut V)
                                                        .offset(7 as libc::c_int as isize);
                                                    *fresh202 = tmp___70 as V;
                                                    cd(j0___4);
                                                    cd(j1___4);
                                                    cd(j2___3);
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {}
                                    }
                                } else if !(*(((**((*prnt).k)
                                        .as_mut_ptr()
                                        .offset(6 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr() as *mut V)
                                        .offset(3 as libc::c_int as isize))
                                        .is_null()
                                    {
                                    if (**((**((*prnt).k)
                                        .as_mut_ptr()
                                        .offset(6 as libc::c_int as isize))
                                        .k)
                                        .as_mut_ptr()
                                        .offset(3 as libc::c_int as isize))
                                        .n != 0
                                    {
                                        if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                            .offset(7 as libc::c_int as isize))
                                            .is_null()
                                        {
                                            if (**((*prnt).k)
                                                .as_mut_ptr()
                                                .offset(7 as libc::c_int as isize))
                                                .n != 0
                                            {
                                                let mut current_block_480: u64;
                                                if (*(((**((**((**((*prnt).k)
                                                    .as_mut_ptr()
                                                    .offset(6 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr()
                                                    .offset(3 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr()
                                                    .offset(0 as libc::c_int as isize))
                                                    .k)
                                                    .as_mut_ptr() as *mut V)
                                                    .offset(1 as libc::c_int as isize))
                                                    .is_null()
                                                {
                                                    current_block_480 = 5051009276427548354;
                                                } else if (*(((**((**((**((**((*prnt).k)
                                                        .as_mut_ptr()
                                                        .offset(6 as libc::c_int as isize))
                                                        .k)
                                                        .as_mut_ptr()
                                                        .offset(3 as libc::c_int as isize))
                                                        .k)
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize))
                                                        .k)
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize))
                                                        .k)
                                                        .as_mut_ptr() as *mut V)
                                                        .offset(5 as libc::c_int as isize))
                                                        .is_null()
                                                    {
                                                    current_block_480 = 5051009276427548354;
                                                } else {
                                                    current_block_480 = 5767032302874913457;
                                                }
                                                match current_block_480 {
                                                    5051009276427548354 => {
                                                        tmp___71 = dot_monadic(
                                                            *(((*t3).k).as_mut_ptr() as *mut V)
                                                                .offset(4 as libc::c_int as isize) as K,
                                                        );
                                                        j0___5 = tmp___71;
                                                        tmp___72 = dot_monadic(
                                                            *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                .offset(7 as libc::c_int as isize) as K,
                                                        );
                                                        j1___5 = tmp___72;
                                                        tmp___73 = ci(j0___5);
                                                        tmp___74 = join(tmp___73, j1___5);
                                                        j2___4 = tmp___74;
                                                        cd(j0___5);
                                                        tmp___75 = dot_monadic(j2___4);
                                                        let ref mut fresh203 = *(((*t3).k).as_mut_ptr() as *mut V)
                                                            .offset(7 as libc::c_int as isize);
                                                        *fresh203 = tmp___75 as V;
                                                        cd(j0___5);
                                                        cd(j1___5);
                                                        cd(j2___4);
                                                    }
                                                    _ => {}
                                                }
                                            }
                                        }
                                    }
                                }
                                current_block = 12189673838652692395;
                            } else {
                                current_block = 7862008493335463114;
                            }
                        } else {
                            current_block = 7862008493335463114;
                        }
                        match current_block {
                            7862008493335463114 => {
                                if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                    .offset(7 as libc::c_int as isize))
                                    .is_null()
                                {
                                    if 1 as libc::c_longlong
                                        == (**((*prnt).k)
                                            .as_mut_ptr()
                                            .offset(7 as libc::c_int as isize))
                                            .n
                                    {
                                        if (*(((*prnt).k).as_mut_ptr() as *mut V)
                                            .offset(6 as libc::c_int as isize))
                                            .is_null()
                                        {
                                            if (*(((*t3).k).as_mut_ptr() as *mut V)
                                                .offset(7 as libc::c_int as isize))
                                                .is_null()
                                            {
                                                tmp___76 = dot_monadic(
                                                    *(((*t3).k).as_mut_ptr() as *mut V)
                                                        .offset(4 as libc::c_int as isize) as K,
                                                );
                                                j0___6 = tmp___76;
                                                tmp___77 = dot_monadic(
                                                    *(((*prnt).k).as_mut_ptr() as *mut V)
                                                        .offset(7 as libc::c_int as isize) as K,
                                                );
                                                j1___6 = tmp___77;
                                                tmp___78 = ci(j0___6);
                                                tmp___79 = join(tmp___78, j1___6);
                                                j2___5 = tmp___79;
                                                cd(j0___6);
                                                tmp___80 = dot_monadic(j2___5);
                                                let ref mut fresh204 = *(((*t3).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize);
                                                *fresh204 = tmp___80 as V;
                                                cd(j0___6);
                                                cd(j1___6);
                                                cd(j2___5);
                                                current_block = 12189673838652692395;
                                            } else {
                                                current_block = 9944752181212136883;
                                            }
                                        } else {
                                            current_block = 9944752181212136883;
                                        }
                                    } else {
                                        current_block = 9944752181212136883;
                                    }
                                } else {
                                    current_block = 9944752181212136883;
                                }
                                match current_block {
                                    12189673838652692395 => {}
                                    _ => {
                                        if !(*(((*t3).k).as_mut_ptr() as *mut V)
                                            .offset(4 as libc::c_int as isize))
                                            .is_null()
                                        {
                                            if (**((*t3).k)
                                                .as_mut_ptr()
                                                .offset(4 as libc::c_int as isize))
                                                .n != 0
                                            {
                                                if !(*(((*prnt).k).as_mut_ptr() as *mut V)
                                                    .offset(7 as libc::c_int as isize))
                                                    .is_null()
                                                {
                                                    if (**((*prnt).k)
                                                        .as_mut_ptr()
                                                        .offset(7 as libc::c_int as isize))
                                                        .n == 1 as libc::c_longlong
                                                    {
                                                        let mut current_block_523: u64;
                                                        if (*((*prnt).k)
                                                            .as_mut_ptr()
                                                            .offset(6 as libc::c_int as isize))
                                                            .is_null()
                                                        {
                                                            current_block_523 = 12877800238306436244;
                                                        } else if !(*((*prnt).k)
                                                                .as_mut_ptr()
                                                                .offset(6 as libc::c_int as isize))
                                                                .is_null()
                                                            {
                                                            if (**((*prnt).k)
                                                                .as_mut_ptr()
                                                                .offset(6 as libc::c_int as isize))
                                                                .n != 0
                                                            {
                                                                current_block_523 = 12877800238306436244;
                                                            } else {
                                                                current_block_523 = 7318884828130944956;
                                                            }
                                                        } else {
                                                            current_block_523 = 7318884828130944956;
                                                        }
                                                        match current_block_523 {
                                                            12877800238306436244 => {
                                                                tmp___81 = dot_monadic(
                                                                    *(((*t3).k).as_mut_ptr() as *mut V)
                                                                        .offset(4 as libc::c_int as isize) as K,
                                                                );
                                                                j0___7 = tmp___81;
                                                                tmp___82 = dot_monadic(
                                                                    *(((*prnt).k).as_mut_ptr() as *mut V)
                                                                        .offset(7 as libc::c_int as isize) as K,
                                                                );
                                                                j1___7 = tmp___82;
                                                                tmp___83 = ci(j0___7);
                                                                tmp___84 = join(tmp___83, j1___7);
                                                                j2___6 = tmp___84;
                                                                cd(j0___7);
                                                                if !(*(((*t3).k).as_mut_ptr() as *mut V)
                                                                    .offset(7 as libc::c_int as isize))
                                                                    .is_null()
                                                                {
                                                                    if (**((*t3).k)
                                                                        .as_mut_ptr()
                                                                        .offset(7 as libc::c_int as isize))
                                                                        .n != 0
                                                                    {
                                                                        cd(
                                                                            *((*t3).k).as_mut_ptr().offset(7 as libc::c_int as isize),
                                                                        );
                                                                    }
                                                                }
                                                                tmp___85 = dot_monadic(j2___6);
                                                                let ref mut fresh205 = *(((*t3).k).as_mut_ptr() as *mut V)
                                                                    .offset(7 as libc::c_int as isize);
                                                                *fresh205 = tmp___85 as V;
                                                                cd(j0___7);
                                                                cd(j1___7);
                                                                cd(j2___6);
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        if !grnt.is_null() {
                            cd(prnt);
                        } else {
                            grnt = prnt;
                        }
                    }
                    prnt = ci(t3);
                }
            }
        }
        u = *v as K;
        tmp___87 = VA(t3 as V);
        if tmp___87 != 0 {
            *v = t3 as V;
        } else {
            *v = &mut t3 as *mut K as V;
        }
        if *v.offset(i as isize) as libc::c_ulong == offsetEach as V as libc::c_ulong {
            if grnt.is_null() {
                grnt = ci(prnt);
            }
        }
        e = dv_ex(0 as K, v.offset(i as isize), t2);
        *v = u as V;
        if *v.offset(i as isize) as libc::c_ulong == offsetEach as V as libc::c_ulong {
            if prnt as libc::c_ulong == grnt as libc::c_ulong {
                cd(grnt);
                grnt = 0 as K;
            }
        }
        cd(t2);
        tmp___88 = VA(t3 as V);
        if tmp___88 == 0 {
            if encp != 3 as libc::c_longlong {
                cd(t3);
            } else if encp == 3 as libc::c_longlong {
                if !(*(((*t3).k).as_mut_ptr() as *mut V)
                    .offset(6 as libc::c_int as isize))
                    .is_null()
                {
                    cd(t3);
                }
            }
        }
        return e;
    };
}
pub unsafe extern "C" fn cirRef(mut x___0: K, mut y: K) -> I {
    let mut f: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    if !x___0.is_null() {
        if x___0 as libc::c_ulong == y as libc::c_ulong {
            return 1 as libc::c_int as I;
        }
    }
    f = 0 as libc::c_int as I;
    if (*x___0).t == 6 as libc::c_longlong {
        return 0 as libc::c_int as I
    } else {
        if y.is_null() {
            return 0 as libc::c_int as I
        } else {
            if (*y).t != 0 as libc::c_longlong {
                if (*y).t != 5 as libc::c_longlong {
                    return 0 as libc::c_int as I;
                }
            }
            if (x___0 as UI) < DT_SIZE as UI {
                return 0 as libc::c_int as I;
            }
        }
    }
    i = 0 as libc::c_int as I;
    _i___0 = (*y).n;
    while i < _i___0 {
        f = cirRef_(
            x___0,
            *((*y).k).as_mut_ptr().offset(((*y).n - i - 1 as libc::c_longlong) as isize),
            f,
        );
        i += 1;
    }
    return f;
}
pub unsafe extern "C" fn cirRef_(mut x___0: K, mut y: K, mut f: I) -> I {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    if x___0 as libc::c_ulong == y as libc::c_ulong {
        f = 1 as libc::c_int as I;
    }
    i = 0 as libc::c_int as I;
    _i___0 = (*y).n;
    while i < _i___0 {
        if f == 0 {
            if (*y).t == 0 as libc::c_longlong {
                f = cirRef_(
                    x___0,
                    *((*y).k)
                        .as_mut_ptr()
                        .offset(((*y).n - i - 1 as libc::c_longlong) as isize),
                    f,
                );
            } else if (*y).t == 5 as libc::c_longlong {
                f = cirRef_(
                    x___0,
                    *((*y).k)
                        .as_mut_ptr()
                        .offset(((*y).n - i - 1 as libc::c_longlong) as isize),
                    f,
                );
            }
        }
        i += 1;
    }
    return f;
}
static mut gt: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn FC(mut a: F, mut b___1: F) -> I {
    let mut x___0: __anonunion_x_721633472 = __anonunion_x_721633472 { i: 0 };
    let mut y: __anonunion_x_721633472 = __anonunion_x_721633472 { i: 0 };
    let mut xu: I = 0;
    let mut ad: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    x___0.f = a;
    y.f = b___1;
    xu = x___0.i | y.i;
    if (9218868437227405312 as libc::c_ulonglong)
        < 9223372036854775807 as libc::c_ulonglong & x___0.i as libc::c_ulonglong
    {
        if (9218868437227405312 as libc::c_ulonglong)
            < 9223372036854775807 as libc::c_ulonglong & y.i as libc::c_ulonglong
        {
            tmp = 0 as libc::c_int;
        } else {
            tmp = -(1 as libc::c_int);
        }
        return tmp as I;
    } else {
        if x___0.i < 0 as libc::c_longlong {
            x___0
                .i = (-(0x7fffffffffffffff as libc::c_long)
                - 1 as libc::c_int as libc::c_long) as libc::c_longlong - x___0.i;
        }
    }
    if (9218868437227405312 as libc::c_ulonglong)
        < 9223372036854775807 as libc::c_ulonglong & y.i as libc::c_ulonglong
    {
        return 1 as libc::c_int as I
    } else {
        if y.i < 0 as libc::c_longlong {
            y
                .i = (-(0x7fffffffffffffff as libc::c_long)
                - 1 as libc::c_int as libc::c_long) as libc::c_longlong - y.i;
        }
    }
    ad = llabs(x___0.i - y.i);
    if ad < 1023 as libc::c_longlong {
        if 4503599627370496 as libc::c_ulonglong
            > 9223372036854775807 as libc::c_ulonglong & xu as libc::c_ulonglong
        {
            if x___0.i < y.i {
                tmp___1 = -(1 as libc::c_int);
            } else {
                if x___0.i != y.i {
                    tmp___0 = 1 as libc::c_int;
                } else {
                    tmp___0 = 0 as libc::c_int;
                }
                tmp___1 = tmp___0;
            }
            return tmp___1 as I;
        }
        if ad < 513 as libc::c_longlong {
            return 0 as libc::c_int as I;
        }
        xu = 513 as libc::c_longlong
            + ((255 as libc::c_longlong & xu >> 44 as libc::c_int) << 1 as libc::c_int);
        if ad < xu {
            return 0 as libc::c_int as I;
        }
    }
    if x___0.i < y.i {
        tmp___2 = -(1 as libc::c_int);
    } else {
        tmp___2 = 1 as libc::c_int;
    }
    return tmp___2 as I;
}
pub unsafe extern "C" fn KC(mut a: K, mut b___1: K) -> I {
    let mut tmp: K = 0 as *mut k0;
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut A: I = 0;
    let mut tmp___0: I = 0;
    let mut u: I = 0;
    let mut v: I = 0;
    let mut c: C = 0;
    let mut d___0: C = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___2: libc::c_int = 0;
    if b___1 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        feci = 1 as libc::c_int as I;
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp as I;
    }
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    A = tmp___0;
    if at___0 < bt {
        return -(1 as libc::c_int) as I;
    }
    if at___0 > bt {
        return 1 as libc::c_int as I;
    }
    if 3 as libc::c_longlong != A {
        if an < bn {
            return -(1 as libc::c_int) as I;
        }
        if an > bn {
            return 1 as libc::c_int as I;
        }
    }
    if 7 as libc::c_longlong == A {
        return 0 as libc::c_int as I
    } else {
        if 6 as libc::c_longlong == A {
            return 0 as libc::c_int as I
        } else {
            if 5 as libc::c_longlong == A {
                return 0 as libc::c_int as I
            } else {
                if 4 as libc::c_longlong == A {
                    i = 0 as libc::c_int as I;
                    _i___0 = an;
                    while i < _i___0 {
                        u = SC(
                            *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize),
                            *(((*b___1).k).as_mut_ptr() as *mut S).offset(i as isize),
                        );
                        if u != 0 {
                            return u;
                        }
                        i += 1;
                    }
                } else if 3 as libc::c_longlong == A {
                    i___0 = 0 as libc::c_int as I;
                    if an < bn {
                        tmp___1 = an;
                    } else {
                        tmp___1 = bn;
                    }
                    _i___1 = tmp___1 + 1 as libc::c_longlong;
                    while i___0 < _i___1 {
                        c = *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize);
                        d___0 = *(((*b___1).k).as_mut_ptr() as *mut C)
                            .offset(i___0 as isize);
                        if (c as libc::c_int) < d___0 as libc::c_int {
                            return -(1 as libc::c_int) as I;
                        }
                        if c as libc::c_int > d___0 as libc::c_int {
                            return 1 as libc::c_int as I;
                        }
                        i___0 += 1;
                    }
                } else if 2 as libc::c_longlong == A {
                    i___1 = 0 as libc::c_int as I;
                    _i___2 = an;
                    while i___1 < _i___2 {
                        u = FC(
                            *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                            *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                        );
                        if u != 0 {
                            return u;
                        }
                        i___1 += 1;
                    }
                } else if 1 as libc::c_longlong == A {
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = an;
                    while i___2 < _i___3 {
                        u = *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
                        v = *(((*b___1).k).as_mut_ptr() as *mut I)
                            .offset(i___2 as isize);
                        if u < v {
                            return -(1 as libc::c_int) as I;
                        }
                        if u > v {
                            return 1 as libc::c_int as I;
                        }
                        i___2 += 1;
                    }
                } else if 0 as libc::c_longlong == A {
                    i___3 = 0 as libc::c_int as I;
                    _i___4 = an;
                    while i___3 < _i___4 {
                        u = KC(
                            *((*a).k).as_mut_ptr().offset(i___3 as isize),
                            *((*b___1).k).as_mut_ptr().offset(i___3 as isize),
                        );
                        if u != 0 {
                            return u;
                        }
                        i___3 += 1;
                    }
                }
            }
        }
    }
    if 3 as libc::c_longlong == A {
        if an != bn {
            if an < bn {
                tmp___2 = -(1 as libc::c_int);
            } else {
                tmp___2 = 1 as libc::c_int;
            }
            return tmp___2 as I;
        }
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn distributionGrade(
    mut a: K,
    mut r: I,
    mut u: uI,
    mut v: uI,
) -> K {
    let mut n: I = 0;
    let mut b___1: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut d___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut s: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___1: I = 0;
    if gt != 0 {
        printf(b"distributionGrade\0" as *const u8 as *const libc::c_char);
    }
    n = (*a).n;
    b___1 = v.wrapping_sub(u).wrapping_add(1 as libc::c_ulonglong) as I;
    tmp = newK(-(1 as libc::c_int) as I, b___1);
    d___0 = tmp;
    if d___0.is_null() {
        return 0 as K;
    }
    c = ((*d___0).k).as_mut_ptr() as *mut I;
    tmp___0 = newK(-(1 as libc::c_int) as I, n);
    s = tmp___0;
    if !s.is_null() {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh206 = *c
                .offset(
                    (*(((*a).k).as_mut_ptr() as *mut uI).offset(i as isize))
                        .wrapping_sub(u) as isize,
                );
            *fresh206 += 1;
            i += 1;
        }
        if r == 0 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = b___1 - 1 as libc::c_longlong;
            while i___0 < _i___1 {
                let ref mut fresh207 = *c
                    .offset((i___0 + 1 as libc::c_longlong) as isize);
                *fresh207 += *c.offset(i___0 as isize);
                i___0 += 1;
            }
        } else {
            i___1 = 0 as libc::c_int as I;
            _i___2 = b___1 - 1 as libc::c_longlong;
            while i___1 < _i___2 {
                let ref mut fresh208 = *c
                    .offset((_i___2 - i___1 - 1 as libc::c_longlong) as isize);
                *fresh208 += *c.offset((_i___2 - i___1) as isize);
                i___1 += 1;
            }
        }
        i___2 = 0 as libc::c_int as I;
        _i___3 = n;
        while i___2 < _i___3 {
            tmp___1 = *c
                .offset(
                    (*(((*a).k).as_mut_ptr() as *mut uI)
                        .offset((n - i___2 - 1 as libc::c_longlong) as isize))
                        .wrapping_sub(u) as isize,
                );
            let ref mut fresh209 = *c
                .offset(
                    (*(((*a).k).as_mut_ptr() as *mut uI)
                        .offset((n - i___2 - 1 as libc::c_longlong) as isize))
                        .wrapping_sub(u) as isize,
                );
            *fresh209 -= 1;
            *(((*s).k).as_mut_ptr() as *mut I)
                .offset(
                    (-(1 as libc::c_longlong) + tmp___1) as isize,
                ) = n - i___2 - 1 as libc::c_longlong;
            i___2 += 1;
        }
    }
    cd(d___0);
    return s;
}
pub unsafe extern "C" fn charGrade(mut a: K, mut r: I) -> K {
    let mut n: I = 0;
    let mut c: [I; 256] = [0; 256];
    let mut s: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___0: I = 0;
    n = (*a).n;
    memset(
        c.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (256 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong),
    );
    tmp = newK(-(1 as libc::c_int) as I, n);
    s = tmp;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        c[*(((*a).k).as_mut_ptr() as *mut C).offset(i as isize) as UC as usize] += 1;
        i += 1;
    }
    if r == 0 {
        i___0 = 0 as libc::c_int as I;
        _i___1 = 255 as libc::c_int as I;
        while i___0 < _i___1 {
            c[(i___0 + 1 as libc::c_longlong) as usize] += c[i___0 as usize];
            i___0 += 1;
        }
    } else {
        i___1 = 0 as libc::c_int as I;
        _i___2 = 255 as libc::c_int as I;
        while i___1 < _i___2 {
            c[(_i___2 - i___1 - 1 as libc::c_longlong) as usize]
                += c[(_i___2 - i___1) as usize];
            i___1 += 1;
        }
    }
    i___2 = 0 as libc::c_int as I;
    _i___3 = n;
    while i___2 < _i___3 {
        tmp___0 = c[*(((*a).k).as_mut_ptr() as *mut C)
            .offset((n - i___2 - 1 as libc::c_longlong) as isize) as UC as usize];
        c[*(((*a).k).as_mut_ptr() as *mut C)
            .offset((n - i___2 - 1 as libc::c_longlong) as isize) as UC as usize] -= 1;
        *(((*s).k).as_mut_ptr() as *mut I)
            .offset(
                (-(1 as libc::c_longlong) + tmp___0) as isize,
            ) = n - i___2 - 1 as libc::c_longlong;
        i___2 += 1;
    }
    return s;
}
unsafe extern "C" fn mergerComparer(mut a: K, mut r: I, mut i: I, mut j: I) -> I {
    let mut t: I = 0;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    t = (*a).t;
    if -(4 as libc::c_longlong) == t {
        if 0 as libc::c_longlong == r {
            tmp___4 = SC(
                *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize),
                *(((*a).k).as_mut_ptr() as *mut S).offset(j as isize),
            );
            if 1 as libc::c_longlong > tmp___4 {
                return 1 as libc::c_int as I;
            }
        }
    }
    if -(4 as libc::c_longlong) == t {
        if 1 as libc::c_longlong == r {
            tmp___3 = SC(
                *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize),
                *(((*a).k).as_mut_ptr() as *mut S).offset(j as isize),
            );
            if -(1 as libc::c_longlong) < tmp___3 {
                return 1 as libc::c_int as I;
            }
        }
    }
    if -(2 as libc::c_longlong) == t {
        if 0 as libc::c_longlong == r {
            tmp___2 = FC(
                *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize),
                *(((*a).k).as_mut_ptr() as *mut F).offset(j as isize),
            );
            if 1 as libc::c_longlong > tmp___2 {
                return 1 as libc::c_int as I;
            }
        }
    }
    if -(2 as libc::c_longlong) == t {
        if 1 as libc::c_longlong == r {
            tmp___1 = FC(
                *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize),
                *(((*a).k).as_mut_ptr() as *mut F).offset(j as isize),
            );
            if -(1 as libc::c_longlong) < tmp___1 {
                return 1 as libc::c_int as I;
            }
        }
    }
    if -(1 as libc::c_longlong) == t {
        if 0 as libc::c_longlong == r {
            if *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize)
                <= *(((*a).k).as_mut_ptr() as *mut I).offset(j as isize)
            {
                return 1 as libc::c_int as I;
            }
        }
    }
    if -(1 as libc::c_longlong) == t {
        if 1 as libc::c_longlong == r {
            if *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize)
                >= *(((*a).k).as_mut_ptr() as *mut I).offset(j as isize)
            {
                return 1 as libc::c_int as I;
            }
        }
    }
    if 0 as libc::c_longlong == t {
        if 0 as libc::c_longlong == r {
            tmp___0 = KC(
                *((*a).k).as_mut_ptr().offset(i as isize),
                *((*a).k).as_mut_ptr().offset(j as isize),
            );
            if 1 as libc::c_longlong > tmp___0 {
                return 1 as libc::c_int as I;
            }
        }
    }
    if 0 as libc::c_longlong == t {
        if 1 as libc::c_longlong == r {
            tmp = KC(
                *((*a).k).as_mut_ptr().offset(i as isize),
                *((*a).k).as_mut_ptr().offset(j as isize),
            );
            if -(1 as libc::c_longlong) < tmp {
                return 1 as libc::c_int as I;
            }
        }
    }
    return 0 as libc::c_int as I;
}
unsafe extern "C" fn merger(
    mut a: K,
    mut r: I,
    mut x___0: K,
    mut y: K,
    mut s: I,
    mut t: I,
    mut m: I,
) {
    let mut i: I = 0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut d___0: *mut I = 0 as *mut I;
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    c = ((*x___0).k).as_mut_ptr() as *mut I;
    d___0 = ((*y).k).as_mut_ptr() as *mut I;
    memcpy(
        d___0.offset(s as isize) as *mut libc::c_void,
        c.offset(s as isize) as *const libc::c_void,
        ((t - s + 1 as libc::c_longlong) as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    i = s;
    j = m + 1 as libc::c_longlong;
    k = s;
    while i <= m {
        if !(j <= t) {
            break;
        }
        tmp___3 = mergerComparer(
            a,
            r,
            *d___0.offset(i as isize),
            *d___0.offset(j as isize),
        );
        if tmp___3 != 0 {
            tmp = k;
            k += 1;
            tmp___0 = i;
            i += 1;
            *c.offset(tmp as isize) = *d___0.offset(tmp___0 as isize);
        } else {
            tmp___1 = k;
            k += 1;
            tmp___2 = j;
            j += 1;
            *c.offset(tmp___1 as isize) = *d___0.offset(tmp___2 as isize);
        }
    }
    if i <= m {
        memcpy(
            c.offset(k as isize) as *mut libc::c_void,
            d___0.offset(i as isize) as *const libc::c_void,
            ((m - i + 1 as libc::c_longlong) as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
    }
}
unsafe extern "C" fn insertGrade(
    mut a: K,
    mut r: I,
    mut x___0: K,
    mut y: K,
    mut s: I,
    mut t: I,
) {
    let mut i: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut x___1: I = 0;
    let mut j: I = 0;
    let mut tmp: I = 0;
    c = ((*x___0).k).as_mut_ptr() as *mut I;
    i = s + 1 as libc::c_longlong;
    while i <= t {
        x___1 = *c.offset(i as isize);
        j = i;
        while s < j {
            tmp = mergerComparer(
                a,
                r,
                *c.offset((j - 1 as libc::c_longlong) as isize),
                x___1,
            );
            if tmp != 0 {
                break;
            }
            *c.offset(j as isize) = *c.offset((j - 1 as libc::c_longlong) as isize);
            j -= 1;
        }
        *c.offset(j as isize) = x___1;
        i += 1;
    }
}
unsafe extern "C" fn doMergeGrade(
    mut a: K,
    mut r: I,
    mut x___0: K,
    mut y: K,
    mut s: I,
    mut t: I,
) {
    let mut m: I = 0;
    if s >= t {
        return;
    }
    m = s + (t - s) / 2 as libc::c_longlong;
    if m - s < 7 as libc::c_longlong {
        insertGrade(a, r, x___0, y, s, m);
    } else {
        doMergeGrade(a, r, x___0, y, s, m);
    }
    if t - (m + 1 as libc::c_longlong) < 7 as libc::c_longlong {
        insertGrade(a, r, x___0, y, m + 1 as libc::c_longlong, t);
    } else {
        doMergeGrade(a, r, x___0, y, m + 1 as libc::c_longlong, t);
    }
    merger(a, r, x___0, y, s, t, m);
}
unsafe extern "C" fn StoU(mut s: S, mut n: I, mut t: I) -> uI {
    let mut h: uI = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: libc::c_int = 0;
    h = 0 as libc::c_int as uI;
    i = 0 as libc::c_int as I;
    _i___0 = 8 as libc::c_int as I;
    while i < _i___0 {
        h <<= 8 as libc::c_int;
        if i < n {
            tmp = *s.offset(i as isize) as UC as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
        h = (h as libc::c_ulonglong).wrapping_add(tmp as uI) as uI as uI;
        i += 1;
    }
    return h;
}
unsafe extern "C" fn strGrade(mut a: K, mut r: I) -> K {
    let mut h: uI = 0;
    let mut k: I = 0;
    let mut s: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___1: uI = 0;
    h = 0 as libc::c_int as uI;
    s = 1 as libc::c_int as I;
    z = 0 as K;
    tmp = newK(-(1 as libc::c_int) as I, (*a).n);
    x___0 = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, x___0, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        y = *((*a).k).as_mut_ptr().offset(i as isize);
        if -(3 as libc::c_longlong) != (*y).t {
            s = 0 as libc::c_int as I;
            break;
        } else if (*y).n > 8 as libc::c_longlong {
            s = 0 as libc::c_int as I;
            break;
        } else {
            tmp___1 = StoU(((*y).k).as_mut_ptr() as *mut C, (*y).n, (*y).t);
            k = tmp___1 as I;
            if k == 0 {
                if (*y).n != 0 {
                    s = 0 as libc::c_int as I;
                    break;
                }
            }
            *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i as isize) = k as uI;
            h |= k as libc::c_ulonglong;
            i += 1;
        }
    }
    if s != 0 {
        z = radixGrade(x___0, r, h);
    }
    cd(x___0);
    return z;
}
pub unsafe extern "C" fn mergeGrade(mut a: K, mut r: I) -> K {
    let mut x___0: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut tmp: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    x___0 = 0 as K;
    y = 0 as K;
    n = (*a).n;
    if gt != 0 {
        printf(b"mergeGrade\0" as *const u8 as *const libc::c_char);
    }
    if 0 as libc::c_longlong == (*a).t {
        x___0 = strGrade(a, r);
        if !x___0.is_null() {
            return x___0;
        }
    }
    x___0 = newK(-(1 as libc::c_int) as I, n);
    y = newK(-(1 as libc::c_int) as I, n);
    tmp = OOM_CD(0 as libc::c_int as I, x___0, y, -(1 as libc::c_int) as V);
    if tmp == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        *(((*x___0).k).as_mut_ptr() as *mut I).offset(i as isize) = i;
        i += 1;
    }
    doMergeGrade(a, r, x___0, y, 0 as libc::c_int as I, n - 1 as libc::c_longlong);
    cd(y);
    return x___0;
}
pub unsafe extern "C" fn insertGradeU(mut a: K, mut r: I) -> K {
    let mut u: *mut uI = 0 as *mut uI;
    let mut n: I = 0;
    let mut i: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut k: I = 0;
    let mut j: I = 0;
    let mut k___0: I = 0;
    let mut j___0: I = 0;
    if gt != 0 {
        printf(b"insertGrade\0" as *const u8 as *const libc::c_char);
    }
    u = ((*a).k).as_mut_ptr() as *mut uI;
    n = (*a).n;
    tmp = newK(-(1 as libc::c_int) as I, n);
    x___0 = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, x___0, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    i___0 = 0 as libc::c_int as I;
    _i___0 = n;
    while i___0 < _i___0 {
        *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___0 as isize) = i___0;
        i___0 += 1;
    }
    c = ((*x___0).k).as_mut_ptr() as *mut I;
    if r == 0 {
        i = 1 as libc::c_int as I;
        while i <= n - 1 as libc::c_longlong {
            k = *c.offset(i as isize);
            j = i;
            while (0 as libc::c_longlong) < j {
                if !(*u.offset(*c.offset((j - 1 as libc::c_longlong) as isize) as isize)
                    > *u.offset(k as isize))
                {
                    break;
                }
                *c.offset(j as isize) = *c.offset((j - 1 as libc::c_longlong) as isize);
                j -= 1;
            }
            *c.offset(j as isize) = k;
            i += 1;
        }
    } else {
        i = 1 as libc::c_int as I;
        while i <= n - 1 as libc::c_longlong {
            k___0 = *c.offset(i as isize);
            j___0 = i;
            while (0 as libc::c_longlong) < j___0 {
                if !(*u
                    .offset(*c.offset((j___0 - 1 as libc::c_longlong) as isize) as isize)
                    < *u.offset(k___0 as isize))
                {
                    break;
                }
                *c
                    .offset(
                        j___0 as isize,
                    ) = *c.offset((j___0 - 1 as libc::c_longlong) as isize);
                j___0 -= 1;
            }
            *c.offset(j___0 as isize) = k___0;
            i += 1;
        }
    }
    return x___0;
}
static mut t0: clock_t = 0;
pub unsafe extern "C" fn trst() {
    t0 = clock();
}
pub unsafe extern "C" fn elapsed(mut m: S) {
    let mut e: clock_t = 0;
    let mut tmp: clock_t = 0;
    let mut ms: I = 0;
    tmp = clock();
    e = tmp - t0;
    ms = (1000.0f64 * e as libc::c_double / 1000000 as libc::c_long as libc::c_double)
        as I;
    if ms != 0 {
        printf(b"%s %lld\n\0" as *const u8 as *const libc::c_char, m, ms);
    }
    trst();
}
unsafe extern "C" fn dGU(
    mut a: *mut uI,
    mut r: I,
    mut x___0: *mut I,
    mut y: *mut I,
    mut n: I,
    mut c: *mut I,
    mut d___0: I,
) {
    let mut sa: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut k: I = 0;
    let mut tmp: I = 0;
    sa = 16 as libc::c_longlong * d___0;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        let ref mut fresh210 = *c
            .offset((65535 as libc::c_ulonglong & *a.offset(i as isize) >> sa) as isize);
        *fresh210 += 1;
        i += 1;
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = 65535 as libc::c_int as I;
    while i___0 < _i___1 {
        let ref mut fresh211 = *c.offset((i___0 + 1 as libc::c_longlong) as isize);
        *fresh211 += *c.offset(i___0 as isize);
        i___0 += 1;
    }
    i___1 = 0 as libc::c_int as I;
    _i___2 = n;
    while i___1 < _i___2 {
        k = *x___0.offset((n - i___1 - 1 as libc::c_longlong) as isize);
        tmp = *c
            .offset(
                (65535 as libc::c_ulonglong
                    & *a.offset((n - i___1 - 1 as libc::c_longlong) as isize) >> sa)
                    as isize,
            );
        let ref mut fresh212 = *c
            .offset(
                (65535 as libc::c_ulonglong
                    & *a.offset((n - i___1 - 1 as libc::c_longlong) as isize) >> sa)
                    as isize,
            );
        *fresh212 -= 1;
        *y.offset((-(1 as libc::c_longlong) + tmp) as isize) = k;
        i___1 += 1;
    }
}
unsafe extern "C" fn radixGradeI(
    mut a: *mut uI,
    mut w___0: *mut uI,
    mut r: I,
    mut u: *mut I,
    mut v: *mut I,
    mut c: *mut I,
    mut n: I,
    mut h: uI,
) {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    if r != 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            *a.offset(i as isize) = !*a.offset(i as isize);
            i += 1;
        }
        r = 0 as libc::c_int as I;
    }
    dGU(a, r, u, v, n, c, 0 as libc::c_int as I);
    if !(65536 as libc::c_ulonglong > h) {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            *w___0
                .offset(i___0 as isize) = *a.offset(*v.offset(i___0 as isize) as isize);
            i___0 += 1;
        }
        c = c.offset(65536 as libc::c_int as isize);
        dGU(w___0, r, v, u, n, c, 1 as libc::c_int as I);
        if 4294967296 as libc::c_ulonglong > h {
            return;
        }
        i___1 = 0 as libc::c_int as I;
        _i___2 = n;
        while i___1 < _i___2 {
            *w___0
                .offset(i___1 as isize) = *a.offset(*u.offset(i___1 as isize) as isize);
            i___1 += 1;
        }
        c = c.offset(65536 as libc::c_int as isize);
        dGU(w___0, r, u, v, n, c, 2 as libc::c_int as I);
        if !(281474976710656 as libc::c_ulonglong > h) {
            i___2 = 0 as libc::c_int as I;
            _i___3 = n;
            while i___2 < _i___3 {
                *w___0
                    .offset(
                        i___2 as isize,
                    ) = *a.offset(*v.offset(i___2 as isize) as isize);
                i___2 += 1;
            }
            c = c.offset(65536 as libc::c_int as isize);
            dGU(w___0, r, v, u, n, c, 3 as libc::c_int as I);
            return;
        }
    }
    memcpy(
        u as *mut libc::c_void,
        v as *const libc::c_void,
        (n as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
}
pub unsafe extern "C" fn radixGrade(mut a: K, mut r: I, mut h: uI) -> K {
    let mut n: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut w___0: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    if gt != 0 {
        printf(b"radixGrade\0" as *const u8 as *const libc::c_char);
    }
    n = (*a).n;
    tmp = newK(-(1 as libc::c_int) as I, n);
    x___0 = tmp;
    tmp___0 = newK(-(1 as libc::c_int) as I, n);
    y = tmp___0;
    tmp___1 = newK(-(1 as libc::c_int) as I, 262144 as libc::c_int as I);
    z = tmp___1;
    tmp___2 = newK(-(1 as libc::c_int) as I, n);
    w___0 = tmp___2;
    tmp___3 = OOM_CD(
        0 as libc::c_int as I,
        x___0,
        y,
        z,
        w___0,
        -(1 as libc::c_int) as V,
    );
    if tmp___3 == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        *(((*x___0).k).as_mut_ptr() as *mut I).offset(i as isize) = i;
        i += 1;
    }
    radixGradeI(
        ((*a).k).as_mut_ptr() as *mut uI,
        ((*w___0).k).as_mut_ptr() as *mut uI,
        r,
        ((*x___0).k).as_mut_ptr() as *mut I,
        ((*y).k).as_mut_ptr() as *mut I,
        ((*z).k).as_mut_ptr() as *mut I,
        n,
        h,
    );
    cd(w___0);
    cd(z);
    cd(y);
    return x___0;
}
pub unsafe extern "C" fn symGrade(mut x___0: K, mut r: I) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut s: S = 0 as *mut C;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut s___0: S = 0 as *mut C;
    let mut y: I = 0;
    let mut tmp___1: I = 0;
    tmp = newK(-(1 as libc::c_int) as I, (*x___0).n);
    z = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, x___0, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    setS(1 as libc::c_int, 0 as libc::c_int as I);
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        s = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i as isize);
        let ref mut fresh213 = *(s as *mut I).offset(-(1 as libc::c_int) as isize);
        *fresh213 += 1;
        i += 1;
    }
    if r == 0 {
        wleft(SYMBOLS, 1 as libc::c_int as I, 0 as libc::c_int as I);
    } else {
        wright(SYMBOLS, 1 as libc::c_int as I, 0 as libc::c_int as I);
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = (*x___0).n;
    while i___0 < _i___1 {
        s___0 = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i___0 as isize);
        y = *(s___0 as *mut I).offset(-(1 as libc::c_int) as isize);
        tmp___1 = y;
        y += 1;
        *(((*z).k).as_mut_ptr() as *mut I).offset(tmp___1 as isize) = i___0;
        *(s___0 as *mut I).offset(-(1 as libc::c_int) as isize) = y;
        i___0 += 1;
    }
    return z;
}
pub static mut PG: I = 0;
pub static mut KP: [V; 27] = [0 as *const libc::c_void as *mut libc::c_void; 27];
pub static mut mUsed: F = 0.0f64;
pub static mut mAlloc: F = 0.0f64;
pub static mut mMap: F = 0.0f64;
pub static mut mMax: F = 0.0f64;
pub unsafe extern "C" fn alloc(mut sz___0: size_t) -> V {
    let mut r: V = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(sz___0);
    r = tmp;
    if r.is_null() {
        fputs(b"out of memory\n\0" as *const u8 as *const libc::c_char, stderr);
        exit(1 as libc::c_int);
    }
    return r;
}
pub unsafe extern "C" fn OOM_CD(mut g: I, mut args_0: ...) -> I {
    let mut a: ::std::ffi::VaListImpl;
    let mut v: V = 0 as *mut libc::c_void;
    let mut o: V = 0 as *mut libc::c_void;
    let mut tmp: V = 0 as *mut libc::c_void;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    o = -(1 as libc::c_int) as V;
    a = args_0.clone();
    loop {
        tmp = a.arg::<V>();
        v = tmp;
        if !(o as libc::c_ulong != v as libc::c_ulong) {
            break;
        }
        if v.is_null() {
            g = 1 as libc::c_int as I;
        }
    }
    if g == 0 {
        return 1 as libc::c_int as I;
    }
    a = args_0.clone();
    loop {
        tmp___0 = a.arg::<V>();
        v = tmp___0;
        if !(o as libc::c_ulong != v as libc::c_ulong) {
            break;
        }
        cd(v as K);
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn rc(mut x___0: K) -> I {
    return (*x___0)._c >> 8 as libc::c_int;
}
unsafe extern "C" fn ic(mut x___0: K) -> K {
    (*x___0)._c += 256 as libc::c_longlong;
    return x___0;
}
unsafe extern "C" fn dc(mut x___0: K) -> K {
    (*x___0)._c -= 256 as libc::c_longlong;
    return x___0;
}
unsafe extern "C" fn glsz(mut x___0: K) -> I {
    return 255 as libc::c_longlong & (*x___0)._c;
}
unsafe extern "C" fn slsz(mut x___0: K, mut r: I) -> K {
    (*x___0)
        ._c = ((*x___0)._c as libc::c_ulonglong
        & 18446744073709551360 as libc::c_ulonglong) as I;
    (*x___0)._c |= r;
    return x___0;
}
pub unsafe extern "C" fn mrc(mut x___0: K, mut c: I) -> K {
    let mut k: I = 0;
    let mut tmp: I = 0;
    let mut r: I = 0;
    let mut tmp___0: I = 0;
    tmp = sz((*x___0).t, (*x___0).n);
    k = tmp;
    tmp___0 = lsz(k);
    r = tmp___0;
    (*x___0)._c = c << 8 as libc::c_int | r;
    return x___0;
}
pub unsafe extern "C" fn cd(mut x___0: K) -> K {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut o: I = 0;
    let mut r: I = 0;
    let mut tmp: I = 0;
    let mut k: I = 0;
    let mut tmp___0: I = 0;
    let mut s: I = 0;
    let mut res: I = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: K = 0 as *mut k0;
    if x___0.is_null() {
        return 0 as K;
    }
    dc(x___0);
    match (*x___0).t {
        5 | 0 => {
            i = 0 as libc::c_int as I;
            _i___0 = (*x___0).n;
            while i < _i___0 {
                cd(
                    *((*x___0).k)
                        .as_mut_ptr()
                        .offset(((*x___0).n - i - 1 as libc::c_longlong) as isize),
                );
                i += 1;
            }
        }
        _ => {}
    }
    if (*x___0)._c > 255 as libc::c_longlong {
        return x___0;
    }
    match (*x___0).t {
        7 => {
            i___0 = 0 as libc::c_int as I;
            _i___1 = 6 as libc::c_int as I;
            while i___0 < _i___1 {
                cd(
                    *(((*x___0).k).as_mut_ptr() as *mut V)
                        .offset((2 as libc::c_longlong + i___0) as isize) as K,
                );
                i___0 += 1;
            }
        }
        _ => {}
    }
    o = (x___0 as size_t as libc::c_ulonglong
        & (PG - 1 as libc::c_longlong) as libc::c_ulonglong) as I;
    tmp = glsz(x___0);
    r = tmp;
    let mut current_block_42: u64;
    if o == 8 as libc::c_longlong {
        current_block_42 = 9534341262080604666;
    } else if r > 26 as libc::c_longlong {
        current_block_42 = 9534341262080604666;
    } else {
        repool(x___0 as V, r);
        current_block_42 = 17784502470059252271;
    }
    match current_block_42 {
        9534341262080604666 => {
            tmp___0 = sz((*x___0).t, (*x___0).n);
            k = tmp___0;
            s = k + o;
            tmp___1 = munmap((x___0 as V).offset(-(o as isize)), s as size_t);
            res = tmp___1 as I;
            if res != 0 {
                tmp___2 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
                return tmp___2;
            }
            if o == 8 as libc::c_longlong {
                mMap -= s as F;
            } else if r > 26 as libc::c_longlong {
                mAlloc -= s as F;
            }
            mUsed -= s as F;
        }
        _ => {}
    }
    return 0 as K;
}
pub unsafe extern "C" fn ci(mut x___0: K) -> K {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    if x___0.is_null() {
        return 0 as K;
    }
    ic(x___0);
    match (*x___0).t {
        5 | 0 => {
            i = 0 as libc::c_int as I;
            _i___0 = (*x___0).n;
            while i < _i___0 {
                ci(*((*x___0).k).as_mut_ptr().offset(i as isize));
                i += 1;
            }
        }
        _ => {}
    }
    return x___0;
}
pub unsafe extern "C" fn bp(mut t: I) -> I {
    let mut tmp: I = 0;
    if t < 0 as libc::c_longlong {
        tmp = -t;
    } else {
        tmp = t;
    }
    match tmp {
        1 => return ::std::mem::size_of::<I>() as libc::c_ulong as I,
        2 => return ::std::mem::size_of::<F>() as libc::c_ulong as I,
        3 => return ::std::mem::size_of::<C>() as libc::c_ulong as I,
        _ => return ::std::mem::size_of::<V>() as libc::c_ulong as I,
    };
}
pub unsafe extern "C" fn sz(mut t: I, mut n: I) -> I {
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    if 7 as libc::c_longlong == t {
        tmp = 8 as libc::c_int as I;
    } else {
        tmp = n;
    }
    tmp___0 = bp(t);
    if t < 0 as libc::c_longlong {
        tmp___1 = -t;
    } else {
        tmp___1 = t;
    }
    return ((3 as libc::c_ulong)
        .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong) as libc::c_ulonglong)
        .wrapping_add((tmp * tmp___0) as libc::c_ulonglong)
        .wrapping_add(
            (3 as libc::c_longlong == tmp___1) as libc::c_int as libc::c_ulonglong,
        ) as I;
}
unsafe extern "C" fn nearPG(mut i: I) -> I {
    let mut k: I = 0;
    let mut tmp: I = 0;
    k = (i as size_t as libc::c_ulonglong
        & (PG - 1 as libc::c_longlong) as libc::c_ulonglong) as I;
    if k != 0 {
        tmp = i + PG - k;
    } else {
        tmp = i;
    }
    return tmp;
}
pub unsafe extern "C" fn newK(mut t: I, mut n: I) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut k: I = 0;
    let mut tmp___0: I = 0;
    let mut r: I = 0;
    let mut tmp___1: V = 0 as *mut libc::c_void;
    let mut tmp___2: K = 0 as *mut k0;
    if n > 0 as libc::c_longlong {
        if n > 9223372036854775806 as libc::c_longlong {
            tmp = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    tmp___0 = sz(t, n);
    k = tmp___0;
    tmp___1 = kalloc(k, &mut r);
    z = tmp___1 as K;
    if z.is_null() {
        return 0 as K;
    }
    tmp___2 = slsz(z, r);
    ic(tmp___2);
    (*z).t = t;
    (*z).n = n;
    if t == 6 as libc::c_longlong {
        (*z).n = 0 as libc::c_int as I;
    }
    if (*z)._c == 0 as libc::c_longlong {
        (*z)._c = 256 as libc::c_int as I;
    }
    return z;
}
unsafe extern "C" fn kallocI(mut k: I, mut r: I) -> V {
    let mut tmp: V = 0 as *mut libc::c_void;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    if r > 26 as libc::c_longlong {
        tmp = amem(k, r);
        return tmp;
    }
    tmp___0 = unpool(r);
    return tmp___0;
}
unsafe extern "C" fn kalloc(mut k: I, mut r: *mut I) -> V {
    let mut tmp: V = 0 as *mut libc::c_void;
    *r = lsz(k);
    tmp = kallocI(k, *r);
    return tmp;
}
unsafe extern "C" fn amem(mut k: I, mut r: I) -> V {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: I = 0;
    tmp___0 = mmap(
        0 as *mut libc::c_void,
        k as size_t,
        3 as libc::c_int,
        34 as libc::c_int,
        -(1 as libc::c_int),
        0 as libc::c_int as __off_t,
    );
    z = tmp___0 as K;
    if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong == z as libc::c_ulong {
        tmp = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
        return tmp as V;
    }
    if k < PG {
        tmp___1 = PG;
    } else {
        tmp___1 = k;
    }
    mAlloc += tmp___1 as F;
    if r > 26 as libc::c_longlong {
        mUsed += k as F;
        if mUsed > mMax {
            mMax = mUsed;
        }
    }
    return z as V;
}
unsafe extern "C" fn unpool(mut r: I) -> V {
    let mut z: *mut V = 0 as *mut V;
    let mut L___0: *mut V = 0 as *mut V;
    let mut k: I = 0;
    let mut tmp: V = 0 as *mut libc::c_void;
    let mut y: V = 0 as *mut libc::c_void;
    L___0 = KP.as_mut_ptr().offset(r as isize);
    k = (1 as libc::c_longlong) << r;
    let mut current_block_14: u64;
    if (*L___0).is_null() {
        current_block_14 = 16435067991047338740;
    } else if 262 as libc::c_int as V as libc::c_ulong == *L___0 as libc::c_ulong {
        current_block_14 = 16435067991047338740;
    } else {
        current_block_14 = 13056961889198038528;
    }
    match current_block_14 {
        16435067991047338740 => {
            tmp = amem(k, r);
            z = tmp as *mut V;
            if z.is_null() {
                return 0 as V;
            }
            if k < PG {
                y = z as V;
                while (y as libc::c_ulong)
                    < (z as V).offset(PG as isize).offset(-k as isize) as libc::c_ulong
                {
                    let ref mut fresh214 = *(y as *mut V);
                    *fresh214 = y.offset(k as isize);
                    y = y.offset(k as isize);
                }
            }
            *L___0 = z as V;
        }
        _ => {}
    }
    z = *L___0 as *mut V;
    *L___0 = *z;
    *z = 0 as V;
    mUsed += k as F;
    if mUsed > mMax {
        mMax = mUsed;
    }
    return z as V;
}
pub unsafe extern "C" fn cl2(mut v: I) -> I {
    let mut e: I = 0;
    if v == 0 {
        return -(1 as libc::c_int) as I;
    }
    e = 0 as libc::c_int as I;
    if v as libc::c_ulonglong
        & (v as libc::c_ulonglong).wrapping_sub(1 as libc::c_ulonglong) != 0
    {
        e = 1 as libc::c_int as I;
    }
    if v as libc::c_ulonglong & 4294901760 as libc::c_ulonglong != 0 {
        e += 16 as libc::c_longlong;
        v >>= 16 as libc::c_int;
    }
    if v as libc::c_ulonglong & 65280 as libc::c_ulonglong != 0 {
        e += 8 as libc::c_longlong;
        v >>= 8 as libc::c_int;
    }
    if v as libc::c_ulonglong & 240 as libc::c_ulonglong != 0 {
        e += 4 as libc::c_longlong;
        v >>= 4 as libc::c_int;
    }
    if v as libc::c_ulonglong & 12 as libc::c_ulonglong != 0 {
        e += 2 as libc::c_longlong;
        v >>= 2 as libc::c_int;
    }
    if v as libc::c_ulonglong & 2 as libc::c_ulonglong != 0 {
        e += 1;
        v >>= 1 as libc::c_int;
    }
    return e;
}
pub unsafe extern "C" fn lsz(mut k: I) -> I {
    let mut tmp: I = 0;
    let mut tmp___0: I = 0;
    if k <= (1 as libc::c_longlong) << 6 as libc::c_int {
        tmp___0 = 6 as libc::c_int as I;
    } else {
        tmp = cl2(k);
        tmp___0 = tmp;
    }
    return tmp___0;
}
pub unsafe extern "C" fn repool(mut v: V, mut r: I) -> I {
    let mut k: I = 0;
    k = (1 as libc::c_longlong) << r;
    memset(v, 0 as libc::c_int, k as size_t);
    let ref mut fresh215 = *(v as *mut V);
    *fresh215 = KP[r as usize];
    KP[r as usize] = v;
    mUsed -= k as F;
    return 0 as libc::c_int as I;
}
unsafe extern "C" fn kexpander(mut p: *mut K, mut n: I) -> I {
    let mut a: K = 0 as *mut k0;
    let mut r: I = 0;
    let mut tmp: I = 0;
    let mut v: V = 0 as *mut libc::c_void;
    let mut c: I = 0;
    let mut tmp___0: I = 0;
    let mut d___0: I = 0;
    let mut tmp___1: I = 0;
    let mut e: I = 0;
    let mut tmp___2: I = 0;
    let mut f: I = 0;
    let mut w___0: *mut V = 0 as *mut V;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut res: I = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut d___1: I = 0;
    let mut tmp___6: I = 0;
    let mut s: I = 0;
    let mut tmp___7: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___8: V = 0 as *mut libc::c_void;
    let mut c___0: I = 0;
    let mut tmp___9: I = 0;
    a = *p;
    tmp = glsz(a);
    r = tmp;
    if r > 26 as libc::c_longlong {
        tmp___0 = sz((*a).t, (*a).n);
        c = tmp___0;
        tmp___1 = sz((*a).t, n);
        d___0 = tmp___1;
        tmp___2 = nearPG(c);
        e = tmp___2;
        f = d___0 - e;
        if f <= 0 as libc::c_longlong {
            return 1 as libc::c_int as I;
        }
        tmp___3 = mremap(
            a as *mut libc::c_void,
            c as size_t,
            d___0 as size_t,
            1 as libc::c_int,
        );
        w___0 = tmp___3 as *mut V;
        if -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong
            != w___0 as libc::c_ulong
        {
            mAlloc += (d___0 - c) as F;
            mUsed += (d___0 - c) as F;
            if mUsed > mMax {
                mMax = mUsed;
            }
            *p = w___0 as K;
            return 1 as libc::c_int as I;
        }
        v = amem(d___0, r);
        if v.is_null() {
            return 0 as libc::c_int as I;
        }
        memcpy(v, a as *const libc::c_void, c as size_t);
        *p = v as K;
        tmp___4 = munmap(a as *mut libc::c_void, c as size_t);
        res = tmp___4 as I;
        if res != 0 {
            tmp___5 = kerr(b"munmap\0" as *const u8 as *const libc::c_char);
            show(tmp___5);
            return 0 as libc::c_int as I;
        }
        mAlloc -= c as F;
        mUsed -= c as F;
        return 1 as libc::c_int as I;
    }
    tmp___6 = sz((*a).t, n);
    d___1 = tmp___6;
    if d___1 <= ((1 as libc::c_int) << r) as I {
        return 1 as libc::c_int as I;
    }
    tmp___7 = lsz(d___1);
    s = tmp___7;
    tmp___8 = kallocI(d___1, s);
    x___0 = tmp___8 as K;
    if x___0.is_null() {
        return 0 as libc::c_int as I;
    }
    tmp___9 = sz((*a).t, (*a).n);
    c___0 = tmp___9;
    memcpy(x___0 as *mut libc::c_void, a as *const libc::c_void, c___0 as size_t);
    *p = x___0;
    slsz(*p, s);
    repool(a as V, r);
    return 1 as libc::c_int as I;
}
unsafe extern "C" fn kap1_(mut a: *mut K, mut v: V) -> K {
    let mut k: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut m: I = 0;
    let mut p: I = 0;
    let mut tmp: I = 0;
    k = *a;
    t = (*k).t;
    m = (*k).n;
    p = m + 1 as libc::c_longlong;
    tmp = kexpander(&mut k, p);
    if tmp == 0 {
        return 0 as K;
    }
    if k as libc::c_ulong != *a as libc::c_ulong {
        *a = k;
    }
    (*k).n = p;
    match -t {
        0 => {
            let ref mut fresh216 = *((*k).k).as_mut_ptr().offset(m as isize);
            *fresh216 = ci(*(v as *mut K).offset(0 as libc::c_int as isize));
        }
        1 => {
            *(((*k).k).as_mut_ptr() as *mut I).offset(m as isize) = *(v as *mut I);
        }
        2 => {
            *(((*k).k).as_mut_ptr() as *mut F).offset(m as isize) = *(v as *mut F);
        }
        3 => {
            *(((*k).k).as_mut_ptr() as *mut C).offset(m as isize) = *(v as *mut C);
            *(((*k).k).as_mut_ptr() as *mut C)
                .offset(p as isize) = 0 as libc::c_int as C;
        }
        4 => {
            let ref mut fresh217 = *(((*k).k).as_mut_ptr() as *mut S).offset(m as isize);
            *fresh217 = *(v as *mut S);
        }
        _ => return 0 as K,
    }
    return k;
}
unsafe extern "C" fn kapn_(mut a: *mut K, mut v: V, mut n: I) -> K {
    let mut k: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut m: I = 0;
    let mut p: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut zv: *mut K = 0 as *mut K;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    if a.is_null() {
        return 0 as K
    } else {
        if n == 0 {
            return 0 as K;
        }
    }
    k = *a;
    t = (*k).t;
    m = (*k).n;
    p = m + n;
    if 6 as libc::c_longlong == t {
        tmp = newK(0 as libc::c_int as I, p);
        z = tmp;
        if z.is_null() {
            return 0 as K;
        }
        zv = ((*z).k).as_mut_ptr();
        tmp___0 = zv;
        zv = zv.offset(1);
        *tmp___0 = _n();
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh218 = *zv.offset(i as isize);
            *fresh218 = _n();
            i += 1;
        }
        cd(k);
        *a = z;
        return z;
    }
    tmp___1 = kexpander(&mut k, p);
    if tmp___1 == 0 {
        return 0 as K;
    }
    if k as libc::c_ulong != *a as libc::c_ulong {
        *a = k;
    }
    (*k).n = p;
    if t < 0 as libc::c_longlong {
        tmp___2 = -t;
    } else {
        tmp___2 = t;
    }
    match tmp___2 {
        0 | 5 => {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                let ref mut fresh219 = *((*k).k)
                    .as_mut_ptr()
                    .offset((i___0 + m) as isize);
                *fresh219 = ci(*(v as *mut K).offset(i___0 as isize));
                i___0 += 1;
            }
        }
        1 => {
            memcpy(
                (((*k).k).as_mut_ptr() as *mut I).offset(m as isize)
                    as *mut libc::c_void,
                v as *const libc::c_void,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
        }
        2 => {
            memcpy(
                (((*k).k).as_mut_ptr() as *mut F).offset(m as isize)
                    as *mut libc::c_void,
                v as *const libc::c_void,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
        }
        3 => {
            strncpy(
                (((*k).k).as_mut_ptr() as *mut C).offset(m as isize)
                    as *mut libc::c_char,
                v as S as *const libc::c_char,
                n as size_t,
            );
            *(((*k).k).as_mut_ptr() as *mut C)
                .offset(p as isize) = 0 as libc::c_int as C;
        }
        4 => {
            memcpy(
                (((*k).k).as_mut_ptr() as *mut S).offset(m as isize)
                    as *mut libc::c_void,
                v as *const libc::c_void,
                (n as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<S>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
        }
        _ => return 0 as K,
    }
    if t > 0 as libc::c_longlong {
        if t < 5 as libc::c_longlong {
            if p > 1 as libc::c_longlong {
                (*k).t *= -(1 as libc::c_longlong);
            }
        }
    }
    return *a;
}
pub unsafe extern "C" fn kapn(mut a: *mut K, mut v: V, mut n: I) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = kapn_(a, v, n);
    return tmp;
}
pub unsafe extern "C" fn kap(mut a: *mut K, mut v: V) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    if a.is_null() {
        return 0 as K;
    }
    if (0 as libc::c_longlong) < (**a).t {
        tmp = kapn_(a, v, 1 as libc::c_int as I);
        tmp___1 = tmp;
    } else {
        tmp___0 = kap1_(a, v);
        tmp___1 = tmp___0;
    }
    return tmp___1;
}
pub unsafe extern "C" fn newN() -> N {
    let mut tmp: I = 0;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    tmp = lsz(::std::mem::size_of::<Node>() as libc::c_ulong as I);
    tmp___0 = unpool(tmp);
    return tmp___0 as N;
}
pub unsafe extern "C" fn newPDA() -> PDA {
    let mut p: PDA = 0 as *mut Pda;
    let mut tmp: I = 0;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    let mut tmp___1: V = 0 as *mut libc::c_void;
    tmp = lsz(::std::mem::size_of::<Pda>() as libc::c_ulong as I);
    tmp___0 = unpool(tmp);
    p = tmp___0 as PDA;
    if p.is_null() {
        return 0 as PDA;
    }
    tmp___1 = alloc(1 as libc::c_int as size_t);
    (*p).c = tmp___1 as S;
    if ((*p).c).is_null() {
        kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
        return 0 as PDA;
    }
    return p;
}
pub unsafe extern "C" fn push(mut p: PDA, mut c: C) -> I {
    let mut tmp: I = 0;
    tmp = appender(&mut (*p).c, &mut (*p).n, &mut c, 1 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn peek(mut p: PDA) -> C {
    let mut n: I = 0;
    let mut tmp: libc::c_int = 0;
    n = (*p).n;
    if n != 0 {
        tmp = *((*p).c).offset((n - 1 as libc::c_longlong) as isize) as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as C;
}
pub unsafe extern "C" fn pop(mut p: PDA) -> C {
    let mut tmp: libc::c_int = 0;
    if (*p).n > 0 as libc::c_longlong {
        (*p).n -= 1;
        tmp = *((*p).c).offset((*p).n as isize) as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as C;
}
pub unsafe extern "C" fn bottom(mut p: PDA) -> C {
    let mut tmp: libc::c_int = 0;
    if (*p).n > 0 as libc::c_longlong {
        tmp = *((*p).c).offset(0 as libc::c_int as isize) as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as C;
}
pub unsafe extern "C" fn pdafree(mut p: PDA) {
    let mut tmp: I = 0;
    free((*p).c as *mut libc::c_void);
    tmp = lsz(::std::mem::size_of::<PDA>() as libc::c_ulong as I);
    repool(p as V, tmp);
}
pub unsafe extern "C" fn Ki(mut x___0: I) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    tmp = newK(1 as libc::c_int as I, 1 as libc::c_int as I);
    z = tmp;
    *(((*z).k).as_mut_ptr() as *mut I) = x___0;
    return z;
}
pub unsafe extern "C" fn Kf(mut x___0: F) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    tmp = newK(2 as libc::c_int as I, 1 as libc::c_int as I);
    z = tmp;
    *(((*z).k).as_mut_ptr() as *mut F) = x___0;
    return z;
}
pub unsafe extern "C" fn Kc(mut x___0: C) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    tmp = newK(3 as libc::c_int as I, 1 as libc::c_int as I);
    z = tmp;
    *(((*z).k).as_mut_ptr() as *mut C) = x___0;
    return z;
}
pub unsafe extern "C" fn Ks(mut x___0: S) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    if x___0.is_null() {
        return 0 as K;
    }
    tmp = newK(4 as libc::c_int as I, 1 as libc::c_int as I);
    z = tmp;
    let ref mut fresh220 = *(((*z).k).as_mut_ptr() as *mut S);
    *fresh220 = x___0;
    return z;
}
pub unsafe extern "C" fn Kd() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = newK(5 as libc::c_int as I, 0 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn Kn() -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = newK(6 as libc::c_int as I, 1 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn Kv() -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: V = 0 as *mut libc::c_void;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    tmp = newK(7 as libc::c_int as I, 8 as libc::c_int as I);
    z = tmp;
    if z.is_null() {
        return 0 as K;
    }
    (*z).n = 1 as libc::c_int as I;
    let ref mut fresh221 = *(((*z).k).as_mut_ptr() as *mut V)
        .offset(0 as libc::c_int as isize);
    *fresh221 = d_ as V;
    tmp___1 = Kd();
    tmp___0 = tmp___1 as V;
    let ref mut fresh222 = *(((*z).k).as_mut_ptr() as *mut V)
        .offset(3 as libc::c_int as isize);
    *fresh222 = tmp___0;
    tmp___3 = Kd();
    tmp___2 = tmp___3 as V;
    let ref mut fresh223 = *(((*z).k).as_mut_ptr() as *mut V)
        .offset(4 as libc::c_int as isize);
    *fresh223 = tmp___2;
    tmp___4 = OOM_CD(
        0 as libc::c_int as I,
        z,
        tmp___2,
        tmp___0,
        -(1 as libc::c_int) as V,
    );
    if tmp___4 == 0 {
        return 0 as K;
    }
    return z;
}
pub unsafe extern "C" fn newEntry(mut s: S) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = _n();
    tmp___0 = newE(s, tmp);
    return tmp___0;
}
pub unsafe extern "C" fn newE(mut s: S, mut k: K) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    tmp = newK(0 as libc::c_int as I, 3 as libc::c_int as I);
    z = tmp;
    if z.is_null() {
        return 0 as K;
    }
    let ref mut fresh224 = *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh224 = Ks(s);
    let ref mut fresh225 = *((*z).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    *fresh225 = k;
    let ref mut fresh226 = *((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize);
    *fresh226 = _n();
    tmp___0 = OOM_CD(
        0 as libc::c_int as I,
        z,
        *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize),
        *((*z).k).as_mut_ptr().offset(2 as libc::c_int as isize),
        -(1 as libc::c_int) as V,
    );
    if tmp___0 == 0 {
        return 0 as K;
    }
    return z;
}
pub unsafe extern "C" fn rp2(mut v: I) -> I {
    let mut tmp: I = 0;
    v -= 1;
    v |= v >> 1 as libc::c_int;
    v |= v >> 2 as libc::c_int;
    v |= v >> 4 as libc::c_int;
    v |= v >> 8 as libc::c_int;
    v |= v >> 16 as libc::c_int;
    if ::std::mem::size_of::<V>() as libc::c_ulong >= 8 as libc::c_ulong {
        v |= v >> 32 as libc::c_int;
    }
    v += 1;
    if 1 as libc::c_longlong > v {
        tmp = 1 as libc::c_int as I;
    } else {
        tmp = v;
    }
    return tmp;
}
pub unsafe extern "C" fn mstat() -> K {
    let mut ks: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut s: *mut I = 0 as *mut I;
    tmp = newK(-(1 as libc::c_int) as I, 4 as libc::c_int as I);
    ks = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, ks, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    s = ((*ks).k).as_mut_ptr() as *mut I;
    *s.offset(0 as libc::c_int as isize) = mUsed as I;
    *s.offset(1 as libc::c_int as isize) = mAlloc as I;
    *s.offset(2 as libc::c_int as isize) = mMap as I;
    *s.offset(3 as libc::c_int as isize) = mMax as I;
    return ks;
}
pub static mut CP: [M0; 1025] = [M0 {
    m1: M1 {
        a: 0,
        b: 0,
        c: [0; 5],
        d: 0,
        n: 0,
    },
    r: 0,
    k: 0 as *const k0 as *mut k0,
    a: 0,
}; 1025];
pub static mut KONA_WHO: K = 0 as *const k0 as *mut k0;
pub static mut KONA_PORT: K = 0 as *const k0 as *mut k0;
pub static mut KONA_CLIENT: K = 0 as *const k0 as *mut k0;
pub unsafe extern "C" fn nfinish() {}
static mut _done: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn ninit() -> I {
    if _done == 0 {
        _done = 1 as libc::c_int as I;
    }
    return _done;
}
pub unsafe extern "C" fn get_in_addr(mut sa: *mut sockaddr) -> *mut libc::c_void {
    if (*sa).sa_family as libc::c_int == 2 as libc::c_int {
        return &mut (*(sa as *mut sockaddr_in)).sin_addr as *mut in_addr
            as *mut libc::c_void;
    }
    return &mut (*(sa as *mut sockaddr_in6)).sin6_addr as *mut in6_addr
        as *mut libc::c_void;
}
static mut _oldw: I = 0;
static mut _oldc: I = 0;
unsafe extern "C" fn mhbegin(mut i: I) {
    _oldw = *(((*KONA_WHO).k).as_mut_ptr() as *mut I);
    _oldc = *(((*KONA_CLIENT).k).as_mut_ptr() as *mut I);
    *(((*KONA_WHO).k).as_mut_ptr() as *mut I) = i;
    *(((*KONA_CLIENT).k).as_mut_ptr() as *mut I) = CP[i as usize].a;
}
unsafe extern "C" fn mhend() {
    *(((*KONA_WHO).k).as_mut_ptr() as *mut I) = _oldw;
    *(((*KONA_CLIENT).k).as_mut_ptr() as *mut I) = _oldc;
}
pub unsafe extern "C" fn wipe_tape(mut i: I) -> I {
    let mut a: I = 0;
    a = CP[i as usize].a;
    if !(CP[i as usize].k).is_null() {
        cd(CP[i as usize].k);
    }
    memset(
        &mut *CP.as_mut_ptr().offset(i as isize) as *mut M0 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<M0>() as libc::c_ulong,
    );
    CP[i as usize].a = a;
    return 0 as libc::c_int as I;
}
unsafe extern "C" fn close_tape(mut i: I, mut sockfd: I) -> I {
    let mut r: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp___1: *mut K = 0 as *mut K;
    let mut tmp___2: I = 0;
    mhbegin(i);
    wipe_tape(i);
    CP[i as usize].a = 0 as libc::c_int as I;
    tmp = close(sockfd as libc::c_int);
    r = tmp as I;
    if r != 0 {
        tmp___0 = kerr(b"file\0" as *const u8 as *const libc::c_char);
        show(tmp___0);
        r = 0 as libc::c_int as I;
    }
    master
        .__fds_bits[(sockfd
        / (8 as libc::c_int
            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int) as I)
        as usize]
        &= !(((1 as libc::c_ulong)
            << sockfd
                % (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int)
                    as libc::c_longlong) as __fd_mask);
    tmp___1 = denameS(
        b".\0" as *const u8 as *const libc::c_char as S,
        b".m.c\0" as *const u8 as *const libc::c_char as S,
        0 as libc::c_int as I,
    );
    x___0 = *tmp___1;
    if 6 as libc::c_longlong == (*x___0).t {
        r = 0 as libc::c_int as I;
    } else {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___2 = -(*x___0).t;
        } else {
            tmp___2 = (*x___0).t;
        }
        if 3 as libc::c_longlong != tmp___2 {
            r = 1 as libc::c_int as I;
            printf(b"type error\0" as *const u8 as *const libc::c_char);
        } else {
            KX(x___0);
        }
    }
    mhend();
    return r;
}
pub static mut bx: [C; 128] = [
    0 as libc::c_int as C,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
];
pub static mut by: [C; 128] = [
    0 as libc::c_int as C,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
];
unsafe extern "C" fn modified_execute(mut x___0: K) -> K {
    let mut tmp: libc::c_int = 0;
    let mut a: K = 0 as *mut k0;
    let mut tmp___0: S = 0 as *mut C;
    let mut tmp___1: I = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: K = 0 as *mut k0;
    tmp = pthread_mutex_lock(&mut execute_mutex);
    if tmp != 0 {
        perror(b"Lock mutex in mod_ex()\0" as *const u8 as *const libc::c_char);
        abort();
    }
    a = -(1 as libc::c_int) as K;
    if 4 as libc::c_longlong == (*x___0).t {
        tmp___0 = CSK(x___0);
        a = X(tmp___0);
    } else {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___1 = -(*x___0).t;
        } else {
            tmp___1 = (*x___0).t;
        }
        if 3 as libc::c_longlong == tmp___1 {
            tmp___0 = CSK(x___0);
            a = X(tmp___0);
        }
    }
    if (*x___0).t == 0 {
        if (*x___0).n > 0 as libc::c_longlong {
            a = vf_ex(offsetDot, x___0);
        }
    }
    if -(1 as libc::c_int) as K as libc::c_ulong != a as libc::c_ulong {
        tmp___2 = pthread_mutex_unlock(&mut execute_mutex);
        if tmp___2 != 0 {
            perror(b"Unlock mutex in mod_ex()\0" as *const u8 as *const libc::c_char);
            abort();
        }
        return a;
    }
    tmp___3 = ci(x___0);
    return tmp___3;
}
pub unsafe extern "C" fn read_tape(mut i: I, mut j: I, mut type_0: I) -> K {
    let mut current_block: u64;
    let mut nbytes: I = 0;
    let mut n: I = 0;
    let mut bz: [C; 128] = [0; 128];
    let mut tmp: libc::c_uint = 0;
    let mut bn: [C; 1] = [0; 1];
    let mut tmp___0: ssize_t = 0;
    let mut tmp___1: ssize_t = 0;
    let mut tmp___2: ssize_t = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp___3: *mut K = 0 as *mut K;
    let mut n___0: I = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: size_t = 0;
    let mut f: S = 0 as *mut C;
    let mut ax: I = 0;
    let mut ay: I = 0;
    let mut az: I = 0;
    let mut sf: I = 0;
    let mut tmp___7: size_t = 0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut na: I = 0;
    let mut tmp___8: I = 0;
    let mut sbx: I = 0;
    let mut tmp___9: size_t = 0;
    let mut sby: I = 0;
    let mut tmp___10: size_t = 0;
    let mut sbz: I = 0;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: C = 0;
    let mut tmp___13: C = 0;
    let mut tmp___14: C = 0;
    let mut tmp___15: C = 0;
    let mut tmp___16: C = 0;
    let mut tmp___17: C = 0;
    let mut i___1: I = 0;
    let mut _i___1: I = 0;
    let mut i___2: I = 0;
    let mut _i___2: I = 0;
    let mut i___3: I = 0;
    let mut _i___3: I = 0;
    let mut i___4: I = 0;
    let mut _i___4: I = 0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut w___0: I = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: C = 0;
    let mut tmp___21: C = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: C = 0;
    let mut tmp___24: C = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: C = 0;
    let mut tmp___27: C = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: C = 0;
    let mut tmp___30: C = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: K = 0 as *mut k0;
    let mut tmp___33: size_t = 0;
    let mut sbx___0: I = 0;
    let mut tmp___34: size_t = 0;
    let mut sby___0: I = 0;
    let mut tmp___35: size_t = 0;
    let mut tmp___36: C = 0;
    let mut tmp___37: C = 0;
    let mut tmp___38: C = 0;
    let mut i___5: I = 0;
    let mut _i___5: I = 0;
    let mut i___6: I = 0;
    let mut _i___6: I = 0;
    let mut i___7: I = 0;
    let mut _i___7: I = 0;
    let mut r___0: K = 0 as *mut k0;
    let mut tmp___39: K = 0 as *mut k0;
    let mut w___1: I = 0;
    let mut tmp___40: libc::c_int = 0;
    let mut tmp___41: C = 0;
    let mut tmp___42: C = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: C = 0;
    let mut tmp___45: C = 0;
    let mut tmp___46: libc::c_int = 0;
    let mut tmp___47: C = 0;
    let mut tmp___48: C = 0;
    let mut tmp___49: libc::c_int = 0;
    let mut tmp___50: C = 0;
    let mut tmp___51: C = 0;
    let mut tmp___52: libc::c_int = 0;
    let mut tmp___53: K = 0 as *mut k0;
    let mut tmp___54: size_t = 0;
    let mut sbx___1: I = 0;
    let mut tmp___55: size_t = 0;
    let mut tmp___56: C = 0;
    let mut i___8: I = 0;
    let mut _i___8: I = 0;
    let mut i___9: I = 0;
    let mut _i___9: I = 0;
    let mut r___1: K = 0 as *mut k0;
    let mut tmp___57: K = 0 as *mut k0;
    let mut tmp___58: libc::c_int = 0;
    let mut w___2: I = 0;
    let mut tmp___59: libc::c_int = 0;
    let mut tmp___60: C = 0;
    let mut tmp___61: C = 0;
    let mut tmp___62: libc::c_int = 0;
    let mut tmp___63: C = 0;
    let mut tmp___64: C = 0;
    let mut tmp___65: libc::c_int = 0;
    let mut tmp___66: C = 0;
    let mut tmp___67: C = 0;
    let mut tmp___68: libc::c_int = 0;
    let mut tmp___69: C = 0;
    let mut tmp___70: C = 0;
    let mut tmp___71: libc::c_int = 0;
    let mut tmp___72: K = 0 as *mut k0;
    let mut tmp___73: size_t = 0;
    let mut u: I = 0;
    let mut a: I = 0;
    let mut c___2: I = 0;
    let mut m: I = 0;
    let mut g: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut b___1: S = 0 as *mut C;
    let mut tmp___74: S = 0 as *mut C;
    let mut tmp___75: ssize_t = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp___76: K = 0 as *mut k0;
    let mut tmp___77: K = 0 as *mut k0;
    let mut p: *mut M1 = 0 as *mut M1;
    let mut msg_type: I = 0;
    let mut h___0: K = 0 as *mut k0;
    let mut tmp___78: K = 0 as *mut k0;
    let mut tmp___79: K = 0 as *mut k0;
    let mut s: K = 0 as *mut k0;
    let mut r___2: K = 0 as *mut k0;
    let mut tmp___80: K = 0 as *mut k0;
    let mut tmp___81: K = 0 as *mut k0;
    let mut tmp___82: I = 0;
    let mut m___0: K = 0 as *mut k0;
    let mut tmp___83: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___84: *mut K = 0 as *mut K;
    let mut tmp___85: K = 0 as *mut k0;
    let mut u___0: K = 0 as *mut k0;
    let mut tmp___86: K = 0 as *mut k0;
    let mut s___0: K = 0 as *mut k0;
    let mut tmp___87: K = 0 as *mut k0;
    let mut tmp___88: I = 0;
    let mut tmp___89: size_t = 0;
    let mut tmp___90: I = 0;
    nbytes = 0 as libc::c_int as I;
    n = 0 as libc::c_int as I;
    bz[0 as libc::c_int as usize] = 0 as libc::c_int as C;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 128 as libc::c_uint) {
        bz[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    bn[0 as libc::c_int as usize] = 0 as libc::c_int as C;
    if !HTTP_PORT.is_null() {
        if bx[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
            tmp___0 = recv(
                j as libc::c_int,
                bx.as_mut_ptr() as *mut libc::c_void,
                128 as libc::c_int as size_t,
                0 as libc::c_int,
            );
            nbytes = tmp___0 as I;
        } else if by[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
            tmp___1 = recv(
                j as libc::c_int,
                by.as_mut_ptr() as *mut libc::c_void,
                128 as libc::c_int as size_t,
                0 as libc::c_int,
            );
            nbytes = tmp___1 as I;
        } else {
            tmp___2 = recv(
                j as libc::c_int,
                bz.as_mut_ptr() as *mut libc::c_void,
                128 as libc::c_int as size_t,
                0 as libc::c_int,
            );
            nbytes = tmp___2 as I;
        }
        if nbytes <= 0 as libc::c_longlong {
            if nbytes == 0 as libc::c_longlong {
                printf(
                    b"server: socket %lld hung up\n\0" as *const u8
                        as *const libc::c_char,
                    j,
                );
            } else {
                perror(b"recv\0" as *const u8 as *const libc::c_char);
            }
        } else {
            tmp___3 = denameS(
                b".\0" as *const u8 as *const libc::c_char as S,
                b".m.h\0" as *const u8 as *const libc::c_char as S,
                0 as libc::c_int as I,
            );
            h = *tmp___3;
            if 6 as libc::c_longlong == (*h).t {
                send(
                    j as libc::c_int,
                    bx.as_mut_ptr() as *const libc::c_void,
                    nbytes as size_t,
                    0 as libc::c_int,
                );
                bx[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                close_tape(i, j);
                return 0 as K;
            } else {
                if 7 as libc::c_longlong != (*h).t {
                    if 3 as libc::c_longlong != (*h).n {
                        tmp___4 = snprintf(
                            bx.as_mut_ptr() as *mut libc::c_char,
                            128 as libc::c_int as size_t,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            b".m.h is not type 7-3\0" as *const u8 as *const libc::c_char,
                        );
                        n___0 = tmp___4 as I;
                        if n___0 >= 128 as libc::c_longlong {
                            tmp___5 = kerr(
                                b"write\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___5;
                        }
                        tmp___6 = strlen(bx.as_mut_ptr() as *const libc::c_char);
                        send(
                            j as libc::c_int,
                            bx.as_mut_ptr() as *const libc::c_void,
                            tmp___6,
                            0 as libc::c_int,
                        );
                        bx[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                        close_tape(i, j);
                        return 0 as K;
                    }
                }
                f = ((**((*h).k).as_mut_ptr().offset(2 as libc::c_int as isize)).k)
                    .as_mut_ptr() as *mut C;
                ax = 0 as libc::c_int as I;
                ay = 0 as libc::c_int as I;
                az = 0 as libc::c_int as I;
                tmp___7 = strlen(f as *const libc::c_char);
                sf = tmp___7 as I;
                i___0 = 0 as libc::c_int as I;
                _i___0 = sf;
                while i___0 < _i___0 {
                    if *f.offset(i___0 as isize) as libc::c_int == 120 as libc::c_int {
                        ax = 1 as libc::c_int as I;
                    } else if *f.offset(i___0 as isize) as libc::c_int
                            == 121 as libc::c_int
                        {
                        ay = 1 as libc::c_int as I;
                    } else if *f.offset(i___0 as isize) as libc::c_int
                            == 122 as libc::c_int
                        {
                        az = 1 as libc::c_int as I;
                    }
                    i___0 += 1;
                }
                tmp___8 = maX(1 as libc::c_int as I, ax + ay + az);
                na = tmp___8;
                if na == 3 as libc::c_longlong {
                    if bz[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                        send(
                            j as libc::c_int,
                            bn.as_mut_ptr() as *const libc::c_void,
                            1 as libc::c_int as size_t,
                            0 as libc::c_int,
                        );
                        close_tape(i, j);
                        return 0 as K;
                    } else {
                        n = 0 as libc::c_int as I;
                        while n < 128 as libc::c_longlong {
                            if bx[n as usize] as libc::c_int == 13 as libc::c_int {
                                break;
                            }
                            if bx[n as usize] as libc::c_int == 0 as libc::c_int {
                                break;
                            }
                            n += 1;
                        }
                        bx[n as usize] = '\u{0}' as i32 as C;
                        n = 0 as libc::c_int as I;
                        while n < 128 as libc::c_longlong {
                            if by[n as usize] as libc::c_int == 13 as libc::c_int {
                                break;
                            }
                            if by[n as usize] as libc::c_int == 0 as libc::c_int {
                                break;
                            }
                            n += 1;
                        }
                        by[n as usize] = '\u{0}' as i32 as C;
                        n = 0 as libc::c_int as I;
                        while n < 128 as libc::c_longlong {
                            if bz[n as usize] as libc::c_int == 13 as libc::c_int {
                                break;
                            }
                            n += 1;
                        }
                        bz[n as usize] = '\u{0}' as i32 as C;
                        tmp___9 = strlen(bx.as_mut_ptr() as *const libc::c_char);
                        sbx = tmp___9 as I;
                        tmp___10 = strlen(by.as_mut_ptr() as *const libc::c_char);
                        sby = tmp___10 as I;
                        tmp___11 = strlen(bz.as_mut_ptr() as *const libc::c_char);
                        sbz = tmp___11 as I;
                        let vla = (13 as libc::c_longlong + sf + sbx + sby + sbz)
                            as usize;
                        let mut c: Vec::<C> = ::std::vec::from_elem(0, vla);
                        *c
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize) = '{' as i32 as C;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (1 as libc::c_longlong + sf) as isize,
                            ) = '}' as i32 as C;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (2 as libc::c_longlong + sf) as isize,
                            ) = '[' as i32 as C;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (11 as libc::c_longlong + sf + sbx + sby + sbz) as isize,
                            ) = ']' as i32 as C;
                        tmp___16 = '"' as i32 as C;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (10 as libc::c_longlong + sf + sbx + sby + sbz) as isize,
                            ) = tmp___16;
                        tmp___15 = tmp___16;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (9 as libc::c_longlong + sf + sbx + sby) as isize,
                            ) = tmp___15;
                        tmp___14 = tmp___15;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (7 as libc::c_longlong + sf + sbx + sby) as isize,
                            ) = tmp___14;
                        tmp___13 = tmp___14;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (6 as libc::c_longlong + sf + sbx) as isize,
                            ) = tmp___13;
                        tmp___12 = tmp___13;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (4 as libc::c_longlong + sf + sbx) as isize,
                            ) = tmp___12;
                        *c
                            .as_mut_ptr()
                            .offset((3 as libc::c_longlong + sf) as isize) = tmp___12;
                        tmp___17 = ';' as i32 as C;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (8 as libc::c_longlong + sf + sbx + sby) as isize,
                            ) = tmp___17;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (5 as libc::c_longlong + sf + sbx) as isize,
                            ) = tmp___17;
                        *c
                            .as_mut_ptr()
                            .offset(
                                (12 as libc::c_longlong + sf + sbx + sby + sbz) as isize,
                            ) = '\u{0}' as i32 as C;
                        i___1 = 0 as libc::c_int as I;
                        _i___1 = sf;
                        while i___1 < _i___1 {
                            *c
                                .as_mut_ptr()
                                .offset(
                                    (1 as libc::c_longlong + i___1) as isize,
                                ) = *f.offset(i___1 as isize);
                            i___1 += 1;
                        }
                        i___2 = 0 as libc::c_int as I;
                        _i___2 = sbx;
                        while i___2 < _i___2 {
                            *c
                                .as_mut_ptr()
                                .offset(
                                    (4 as libc::c_longlong + sf + i___2) as isize,
                                ) = bx[i___2 as usize];
                            i___2 += 1;
                        }
                        i___3 = 0 as libc::c_int as I;
                        _i___3 = sby;
                        while i___3 < _i___3 {
                            *c
                                .as_mut_ptr()
                                .offset(
                                    (7 as libc::c_longlong + sf + sbx + i___3) as isize,
                                ) = by[i___3 as usize];
                            i___3 += 1;
                        }
                        i___4 = 0 as libc::c_int as I;
                        _i___4 = sbz;
                        while i___4 < _i___4 {
                            *c
                                .as_mut_ptr()
                                .offset(
                                    (10 as libc::c_longlong + sf + sbx + sby + i___4) as isize,
                                ) = bz[i___4 as usize];
                            i___4 += 1;
                        }
                        tmp___18 = X(c.as_mut_ptr());
                        r = tmp___18;
                        w___0 = 128 as libc::c_int as I;
                        let vla_0 = w___0 as usize;
                        let mut bck: Vec::<C> = ::std::vec::from_elem(0, vla_0);
                        match (*r).t {
                            1 => {
                                tmp___19 = snprintf(
                                    bck.as_mut_ptr() as *mut libc::c_char,
                                    w___0 as size_t,
                                    b"%lld\0" as *const u8 as *const libc::c_char,
                                    *(((*r).k).as_mut_ptr() as *mut I),
                                );
                                n = tmp___19 as I;
                                if n >= w___0 {
                                    tmp___21 = '.' as i32 as C;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___21;
                                    tmp___20 = tmp___21;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___20;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___20;
                                }
                            }
                            2 => {
                                tmp___22 = snprintf(
                                    bck.as_mut_ptr() as *mut libc::c_char,
                                    w___0 as size_t,
                                    b"%f\0" as *const u8 as *const libc::c_char,
                                    *(((*r).k).as_mut_ptr() as *mut F),
                                );
                                n = tmp___22 as I;
                                if n >= w___0 {
                                    tmp___24 = '.' as i32 as C;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___24;
                                    tmp___23 = tmp___24;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___23;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___23;
                                }
                            }
                            3 => {
                                tmp___25 = snprintf(
                                    bck.as_mut_ptr() as *mut libc::c_char,
                                    w___0 as size_t,
                                    b"%s\0" as *const u8 as *const libc::c_char,
                                    ((*r).k).as_mut_ptr() as *mut C,
                                );
                                n = tmp___25 as I;
                                if n >= w___0 {
                                    tmp___27 = '.' as i32 as C;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___27;
                                    tmp___26 = tmp___27;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___26;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___26;
                                }
                            }
                            -3 => {
                                tmp___28 = snprintf(
                                    bck.as_mut_ptr() as *mut libc::c_char,
                                    w___0 as size_t,
                                    b"%s\0" as *const u8 as *const libc::c_char,
                                    ((*r).k).as_mut_ptr() as *mut C,
                                );
                                n = tmp___28 as I;
                                if n >= w___0 {
                                    tmp___30 = '.' as i32 as C;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___30;
                                    tmp___29 = tmp___30;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___29;
                                    *bck
                                        .as_mut_ptr()
                                        .offset(
                                            (w___0 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___29;
                                }
                            }
                            _ => {
                                tmp___31 = snprintf(
                                    bck.as_mut_ptr() as *mut libc::c_char,
                                    w___0 as size_t,
                                    b"%s\0" as *const u8 as *const libc::c_char,
                                    b"NYI: .m.h result of that type and count\0" as *const u8
                                        as *const libc::c_char,
                                );
                                n = tmp___31 as I;
                                if n >= w___0 {
                                    tmp___32 = kerr(
                                        b"write\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___32;
                                }
                            }
                        }
                        tmp___33 = strlen(bck.as_mut_ptr() as *const libc::c_char);
                        send(
                            j as libc::c_int,
                            bck.as_mut_ptr() as *const libc::c_void,
                            tmp___33,
                            0 as libc::c_int,
                        );
                        bx[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                        by[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                        close_tape(i, j);
                        return 0 as K;
                    }
                }
                if na == 2 as libc::c_longlong {
                    if by[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                        send(
                            j as libc::c_int,
                            bn.as_mut_ptr() as *const libc::c_void,
                            1 as libc::c_int as size_t,
                            0 as libc::c_int,
                        );
                        close_tape(i, j);
                        return 0 as K;
                    } else {
                        n = 0 as libc::c_int as I;
                        while n < 128 as libc::c_longlong {
                            if bx[n as usize] as libc::c_int == 13 as libc::c_int {
                                break;
                            }
                            n += 1;
                        }
                        bx[n as usize] = '\u{0}' as i32 as C;
                        n = 0 as libc::c_int as I;
                        while n < 128 as libc::c_longlong {
                            if by[n as usize] as libc::c_int == 13 as libc::c_int {
                                break;
                            }
                            n += 1;
                        }
                        by[n as usize] = '\u{0}' as i32 as C;
                        tmp___34 = strlen(bx.as_mut_ptr() as *const libc::c_char);
                        sbx___0 = tmp___34 as I;
                        tmp___35 = strlen(by.as_mut_ptr() as *const libc::c_char);
                        sby___0 = tmp___35 as I;
                        let vla_1 = (10 as libc::c_longlong + sf + sbx___0 + sby___0)
                            as usize;
                        let mut c___0: Vec::<C> = ::std::vec::from_elem(0, vla_1);
                        *c___0
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize) = '{' as i32 as C;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (1 as libc::c_longlong + sf) as isize,
                            ) = '}' as i32 as C;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (2 as libc::c_longlong + sf) as isize,
                            ) = '[' as i32 as C;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (8 as libc::c_longlong + sf + sbx___0 + sby___0) as isize,
                            ) = ']' as i32 as C;
                        tmp___38 = '"' as i32 as C;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (7 as libc::c_longlong + sf + sbx___0 + sby___0) as isize,
                            ) = tmp___38;
                        tmp___37 = tmp___38;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (6 as libc::c_longlong + sf + sbx___0) as isize,
                            ) = tmp___37;
                        tmp___36 = tmp___37;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (4 as libc::c_longlong + sf + sbx___0) as isize,
                            ) = tmp___36;
                        *c___0
                            .as_mut_ptr()
                            .offset((3 as libc::c_longlong + sf) as isize) = tmp___36;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (5 as libc::c_longlong + sf + sbx___0) as isize,
                            ) = ';' as i32 as C;
                        *c___0
                            .as_mut_ptr()
                            .offset(
                                (9 as libc::c_longlong + sf + sbx___0 + sby___0) as isize,
                            ) = '\u{0}' as i32 as C;
                        i___5 = 0 as libc::c_int as I;
                        _i___5 = sf;
                        while i___5 < _i___5 {
                            *c___0
                                .as_mut_ptr()
                                .offset(
                                    (1 as libc::c_longlong + i___5) as isize,
                                ) = *f.offset(i___5 as isize);
                            i___5 += 1;
                        }
                        i___6 = 0 as libc::c_int as I;
                        _i___6 = sbx___0;
                        while i___6 < _i___6 {
                            *c___0
                                .as_mut_ptr()
                                .offset(
                                    (4 as libc::c_longlong + sf + i___6) as isize,
                                ) = bx[i___6 as usize];
                            i___6 += 1;
                        }
                        i___7 = 0 as libc::c_int as I;
                        _i___7 = sby___0;
                        while i___7 < _i___7 {
                            *c___0
                                .as_mut_ptr()
                                .offset(
                                    (7 as libc::c_longlong + sf + sbx___0 + i___7) as isize,
                                ) = by[i___7 as usize];
                            i___7 += 1;
                        }
                        tmp___39 = X(c___0.as_mut_ptr());
                        r___0 = tmp___39;
                        w___1 = 128 as libc::c_int as I;
                        let vla_2 = w___1 as usize;
                        let mut bck___0: Vec::<C> = ::std::vec::from_elem(0, vla_2);
                        match (*r___0).t {
                            1 => {
                                tmp___40 = snprintf(
                                    bck___0.as_mut_ptr() as *mut libc::c_char,
                                    w___1 as size_t,
                                    b"%lld\0" as *const u8 as *const libc::c_char,
                                    *(((*r___0).k).as_mut_ptr() as *mut I),
                                );
                                n = tmp___40 as I;
                                if n >= w___1 {
                                    tmp___42 = '.' as i32 as C;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___42;
                                    tmp___41 = tmp___42;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___41;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___41;
                                }
                            }
                            2 => {
                                tmp___43 = snprintf(
                                    bck___0.as_mut_ptr() as *mut libc::c_char,
                                    w___1 as size_t,
                                    b"%f\0" as *const u8 as *const libc::c_char,
                                    *(((*r___0).k).as_mut_ptr() as *mut F),
                                );
                                n = tmp___43 as I;
                                if n >= w___1 {
                                    tmp___45 = '.' as i32 as C;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___45;
                                    tmp___44 = tmp___45;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___44;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___44;
                                }
                            }
                            3 => {
                                tmp___46 = snprintf(
                                    bck___0.as_mut_ptr() as *mut libc::c_char,
                                    w___1 as size_t,
                                    b"%s\0" as *const u8 as *const libc::c_char,
                                    ((*r___0).k).as_mut_ptr() as *mut C,
                                );
                                n = tmp___46 as I;
                                if n >= w___1 {
                                    tmp___48 = '.' as i32 as C;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___48;
                                    tmp___47 = tmp___48;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___47;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___47;
                                }
                            }
                            -3 => {
                                tmp___49 = snprintf(
                                    bck___0.as_mut_ptr() as *mut libc::c_char,
                                    w___1 as size_t,
                                    b"%s\0" as *const u8 as *const libc::c_char,
                                    ((*r___0).k).as_mut_ptr() as *mut C,
                                );
                                n = tmp___49 as I;
                                if n >= w___1 {
                                    tmp___51 = '.' as i32 as C;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 2 as libc::c_longlong) as isize,
                                        ) = tmp___51;
                                    tmp___50 = tmp___51;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 3 as libc::c_longlong) as isize,
                                        ) = tmp___50;
                                    *bck___0
                                        .as_mut_ptr()
                                        .offset(
                                            (w___1 - 4 as libc::c_longlong) as isize,
                                        ) = tmp___50;
                                }
                            }
                            _ => {
                                tmp___52 = snprintf(
                                    bck___0.as_mut_ptr() as *mut libc::c_char,
                                    w___1 as size_t,
                                    b"%s\0" as *const u8 as *const libc::c_char,
                                    b"NYI: .m.h result of that type and count\0" as *const u8
                                        as *const libc::c_char,
                                );
                                n = tmp___52 as I;
                                if n >= w___1 {
                                    tmp___53 = kerr(
                                        b"write\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___53;
                                }
                            }
                        }
                        tmp___54 = strlen(bck___0.as_mut_ptr() as *const libc::c_char);
                        send(
                            j as libc::c_int,
                            bck___0.as_mut_ptr() as *const libc::c_void,
                            tmp___54,
                            0 as libc::c_int,
                        );
                        bx[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                        by[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                        close_tape(i, j);
                        return 0 as K;
                    }
                }
                n = 0 as libc::c_int as I;
                while n < 128 as libc::c_longlong {
                    if bx[n as usize] as libc::c_int == 13 as libc::c_int {
                        break;
                    }
                    if bx[n as usize] as libc::c_int == 0 as libc::c_int {
                        break;
                    }
                    n += 1;
                }
                bx[n as usize] = '\u{0}' as i32 as C;
                tmp___55 = strlen(bx.as_mut_ptr() as *const libc::c_char);
                sbx___1 = tmp___55 as I;
                let vla_3 = (7 as libc::c_longlong + sf + sbx___1) as usize;
                let mut c___1: Vec::<C> = ::std::vec::from_elem(0, vla_3);
                *c___1.as_mut_ptr().offset(0 as libc::c_int as isize) = '{' as i32 as C;
                *c___1
                    .as_mut_ptr()
                    .offset((1 as libc::c_longlong + sf) as isize) = '}' as i32 as C;
                *c___1
                    .as_mut_ptr()
                    .offset((2 as libc::c_longlong + sf) as isize) = '[' as i32 as C;
                *c___1
                    .as_mut_ptr()
                    .offset(
                        (5 as libc::c_longlong + sf + sbx___1) as isize,
                    ) = ']' as i32 as C;
                tmp___56 = '"' as i32 as C;
                *c___1
                    .as_mut_ptr()
                    .offset((4 as libc::c_longlong + sf + sbx___1) as isize) = tmp___56;
                *c___1
                    .as_mut_ptr()
                    .offset((3 as libc::c_longlong + sf) as isize) = tmp___56;
                *c___1
                    .as_mut_ptr()
                    .offset(
                        (6 as libc::c_longlong + sf + sbx___1) as isize,
                    ) = '\u{0}' as i32 as C;
                i___8 = 0 as libc::c_int as I;
                _i___8 = sf;
                while i___8 < _i___8 {
                    *c___1
                        .as_mut_ptr()
                        .offset(
                            (1 as libc::c_longlong + i___8) as isize,
                        ) = *f.offset(i___8 as isize);
                    i___8 += 1;
                }
                i___9 = 0 as libc::c_int as I;
                _i___9 = sbx___1;
                while i___9 < _i___9 {
                    *c___1
                        .as_mut_ptr()
                        .offset(
                            (4 as libc::c_longlong + sf + i___9) as isize,
                        ) = bx[i___9 as usize];
                    i___9 += 1;
                }
                tmp___57 = X(c___1.as_mut_ptr());
                r___1 = tmp___57;
                tmp___58 = strcmp(
                    errmsg.as_mut_ptr() as *const libc::c_char,
                    b"(nil)\0" as *const u8 as *const libc::c_char,
                );
                if tmp___58 != 0 {
                    oerr();
                } else {
                    w___2 = 128 as libc::c_int as I;
                    let vla_4 = w___2 as usize;
                    let mut bck___1: Vec::<C> = ::std::vec::from_elem(0, vla_4);
                    match (*r___1).t {
                        1 => {
                            tmp___59 = snprintf(
                                bck___1.as_mut_ptr() as *mut libc::c_char,
                                w___2 as size_t,
                                b"%lld\0" as *const u8 as *const libc::c_char,
                                *(((*r___1).k).as_mut_ptr() as *mut I),
                            );
                            n = tmp___59 as I;
                            if n >= w___2 {
                                tmp___61 = '.' as i32 as C;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 2 as libc::c_longlong) as isize,
                                    ) = tmp___61;
                                tmp___60 = tmp___61;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 3 as libc::c_longlong) as isize,
                                    ) = tmp___60;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 4 as libc::c_longlong) as isize,
                                    ) = tmp___60;
                            }
                        }
                        2 => {
                            tmp___62 = snprintf(
                                bck___1.as_mut_ptr() as *mut libc::c_char,
                                w___2 as size_t,
                                b"%f\0" as *const u8 as *const libc::c_char,
                                *(((*r___1).k).as_mut_ptr() as *mut F),
                            );
                            n = tmp___62 as I;
                            if n >= w___2 {
                                tmp___64 = '.' as i32 as C;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 2 as libc::c_longlong) as isize,
                                    ) = tmp___64;
                                tmp___63 = tmp___64;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 3 as libc::c_longlong) as isize,
                                    ) = tmp___63;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 4 as libc::c_longlong) as isize,
                                    ) = tmp___63;
                            }
                        }
                        3 => {
                            tmp___65 = snprintf(
                                bck___1.as_mut_ptr() as *mut libc::c_char,
                                w___2 as size_t,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                ((*r___1).k).as_mut_ptr() as *mut C,
                            );
                            n = tmp___65 as I;
                            if n >= w___2 {
                                tmp___67 = '.' as i32 as C;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 2 as libc::c_longlong) as isize,
                                    ) = tmp___67;
                                tmp___66 = tmp___67;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 3 as libc::c_longlong) as isize,
                                    ) = tmp___66;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 4 as libc::c_longlong) as isize,
                                    ) = tmp___66;
                            }
                        }
                        -3 => {
                            tmp___68 = snprintf(
                                bck___1.as_mut_ptr() as *mut libc::c_char,
                                w___2 as size_t,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                ((*r___1).k).as_mut_ptr() as *mut C,
                            );
                            n = tmp___68 as I;
                            if n >= w___2 {
                                tmp___70 = '.' as i32 as C;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 2 as libc::c_longlong) as isize,
                                    ) = tmp___70;
                                tmp___69 = tmp___70;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 3 as libc::c_longlong) as isize,
                                    ) = tmp___69;
                                *bck___1
                                    .as_mut_ptr()
                                    .offset(
                                        (w___2 - 4 as libc::c_longlong) as isize,
                                    ) = tmp___69;
                            }
                        }
                        _ => {
                            tmp___71 = snprintf(
                                bck___1.as_mut_ptr() as *mut libc::c_char,
                                w___2 as size_t,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                b"NYI: .m.h result of that type and count\0" as *const u8
                                    as *const libc::c_char,
                            );
                            n = tmp___71 as I;
                            if n >= w___2 {
                                tmp___72 = kerr(
                                    b"write\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___72;
                            }
                        }
                    }
                    tmp___73 = strlen(bck___1.as_mut_ptr() as *const libc::c_char);
                    send(
                        j as libc::c_int,
                        bck___1.as_mut_ptr() as *const libc::c_void,
                        tmp___73,
                        0 as libc::c_int,
                    );
                    bx[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                    by[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
                    close_tape(i, j);
                    return 0 as K;
                }
            }
        }
    } else {
        u = 1 as libc::c_int as I;
        a = *(&mut u as *mut I as S) as I;
        c___2 = CP[i as usize].r;
        m = ::std::mem::size_of::<M1>() as libc::c_ulong as I;
        z = 0 as K;
        if c___2 < m {
            tmp___74 = (&mut (*CP.as_mut_ptr().offset(i as isize)).m1 as *mut M1 as S)
                .offset(c___2 as isize);
        } else {
            tmp___74 = (((*CP[i as usize].k).k).as_mut_ptr() as *mut C)
                .offset(c___2 as isize);
        }
        b___1 = tmp___74;
        if c___2 < m {
            g = m - c___2;
        } else {
            g = CP[i as usize].m1.n;
        }
        tmp___75 = recv(
            j as libc::c_int,
            b___1 as *mut libc::c_void,
            g as size_t,
            0 as libc::c_int,
        );
        nbytes = tmp___75 as I;
        if nbytes <= 0 as libc::c_longlong {
            if !(nbytes == 0 as libc::c_longlong) {
                perror(b"recv\0" as *const u8 as *const libc::c_char);
            }
        } else {
            CP[i as usize].r += nbytes;
            if m == CP[i as usize].r {
                if a != CP[i as usize].m1.a as I {
                    CP[i as usize].m1.n = bswapI(CP[i as usize].m1.n);
                }
                tmp___76 = newK(-(3 as libc::c_int) as I, m + CP[i as usize].m1.n);
                k = tmp___76;
                tmp___77 = k;
                CP[i as usize].k = tmp___77;
                if tmp___77.is_null() {
                    current_block = 12782520762177245533;
                } else {
                    memcpy(
                        ((*k).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                        &mut (*CP.as_mut_ptr().offset(i as isize)).m1 as *mut M1
                            as *const libc::c_void,
                        m as size_t,
                    );
                    current_block = 8004310806444026423;
                }
            } else {
                current_block = 8004310806444026423;
            }
            match current_block {
                12782520762177245533 => {}
                _ => {
                    if CP[i as usize].r == m + CP[i as usize].m1.n {
                        p = ((*CP[i as usize].k).k).as_mut_ptr() as *mut C as V
                            as *mut M1;
                        msg_type = (*p).d as I;
                        tmp___78 = _db(CP[i as usize].k);
                        h___0 = tmp___78;
                        if h___0.is_null() {
                            current_block = 12782520762177245533;
                        } else {
                            wipe_tape(i);
                            if 2 as libc::c_longlong == msg_type {
                                if 1 as libc::c_longlong == type_0 {
                                    if (*h___0).t != 0 {
                                        tmp___79 = kerr(
                                            b"nonce\0" as *const u8 as *const libc::c_char,
                                        );
                                        return tmp___79;
                                    } else {
                                        if 2 as libc::c_longlong != (*h___0).n {
                                            tmp___79 = kerr(
                                                b"nonce\0" as *const u8 as *const libc::c_char,
                                            );
                                            return tmp___79;
                                        }
                                    }
                                    s = *((*h___0).k)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize);
                                    r___2 = *((*h___0).k)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize);
                                    if 1 as libc::c_longlong != (*s).t {
                                        tmp___80 = kerr(
                                            b"nonce\0" as *const u8 as *const libc::c_char,
                                        );
                                        return tmp___80;
                                    }
                                    if *(((*s).k).as_mut_ptr() as *mut I) != 0 {
                                        if (*r___2).t < 0 as libc::c_longlong {
                                            tmp___82 = -(*r___2).t;
                                        } else {
                                            tmp___82 = (*r___2).t;
                                        }
                                        if 3 as libc::c_longlong != tmp___82 {
                                            tmp___81 = kerr(
                                                b"nonce\0" as *const u8 as *const libc::c_char,
                                            );
                                            return tmp___81;
                                        }
                                        r___2 = kerr(((*r___2).k).as_mut_ptr() as *mut C as cS);
                                    } else {
                                        ci(r___2);
                                    }
                                    cd(h___0);
                                    return r___2;
                                }
                            }
                            if 2 as libc::c_longlong > msg_type {
                                if msg_type != 0 {
                                    tmp___83 = b".m.g\0" as *const u8 as *const libc::c_char;
                                } else {
                                    tmp___83 = b".m.s\0" as *const u8 as *const libc::c_char;
                                }
                                tmp___84 = denameS(
                                    b".\0" as *const u8 as *const libc::c_char as S,
                                    tmp___83 as S,
                                    0 as libc::c_int as I,
                                );
                                tmp___85 = *tmp___84;
                            } else {
                                tmp___85 = 0 as K;
                            }
                            m___0 = tmp___85;
                            if m___0.is_null() {
                                z = modified_execute(h___0);
                            } else if 6 as libc::c_longlong == (*m___0).t {
                                z = modified_execute(h___0);
                            } else {
                                mhbegin(i);
                                z = at(m___0, h___0);
                                mhend();
                            }
                            if msg_type != 0 {
                                tmp___86 = newK(
                                    0 as libc::c_int as I,
                                    2 as libc::c_int as I,
                                );
                                u___0 = tmp___86;
                                tmp___87 = Ki(0 as libc::c_int as I);
                                s___0 = tmp___87;
                                tmp___88 = OOM_CD(
                                    0 as libc::c_int as I,
                                    u___0,
                                    s___0,
                                    -(1 as libc::c_int) as V,
                                );
                                if tmp___88 == 0 {
                                    return 0 as K;
                                }
                                if z.is_null() {
                                    *(((*s___0).k).as_mut_ptr()
                                        as *mut I) = 1 as libc::c_int as I;
                                    tmp___89 = strlen(
                                        errmsg.as_mut_ptr() as *const libc::c_char,
                                    );
                                    z = newK(-(3 as libc::c_int) as I, tmp___89 as I);
                                    tmp___90 = OOM_CD(
                                        0 as libc::c_int as I,
                                        u___0,
                                        z,
                                        -(1 as libc::c_int) as V,
                                    );
                                    if tmp___90 == 0 {
                                        return 0 as K;
                                    }
                                    strcpy(
                                        ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_char,
                                        errmsg.as_mut_ptr() as *const libc::c_char,
                                    );
                                    kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
                                }
                                let ref mut fresh227 = *((*u___0).k)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize);
                                *fresh227 = s___0;
                                let ref mut fresh228 = *((*u___0).k)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize);
                                *fresh228 = z;
                                z = u___0;
                            } else if z.is_null() {
                                printf(
                                    b"%s error\n\0" as *const u8 as *const libc::c_char,
                                    errmsg.as_mut_ptr(),
                                );
                                kerr(b"(nil)\0" as *const u8 as *const libc::c_char);
                            }
                            cd(h___0);
                            if !z.is_null() {
                                if 1 as libc::c_longlong == msg_type {
                                    if 0 as libc::c_longlong == type_0 {
                                        ksender(j, z, 2 as libc::c_int as I);
                                    }
                                }
                            }
                            cd(z);
                            z = 0 as K;
                            current_block = 9849624005465413564;
                        }
                    } else {
                        current_block = 9849624005465413564;
                    }
                    match current_block {
                        12782520762177245533 => {}
                        _ => return z,
                    }
                }
            }
        }
    }
    close_tape(i, j);
    return -(1 as libc::c_int) as K;
}
static mut w: I = 0 as libc::c_int as I;
pub unsafe extern "C" fn kcloneI(
    mut a: K,
    mut f: *const libc::c_char,
    mut n: libc::c_int,
) -> K {
    let mut tmp: K = 0 as *mut k0;
    if w != 0 {
        printf(b"kclone %s:%d \0" as *const u8 as *const libc::c_char, f, n);
    }
    tmp = _kclone(a);
    return tmp;
}
pub unsafe extern "C" fn _kclone(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut k: I = 0;
    let mut vt: I = 0;
    let mut tmp___3: I = 0;
    let mut kv: K = 0 as *mut k0;
    let mut v: *mut V = 0 as *mut V;
    let mut tmp___4: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut w___0: V = 0 as *mut libc::c_void;
    let mut r: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut q: V = 0 as *mut libc::c_void;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: *mut K = 0 as *mut K;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    if a.is_null() {
        return 0 as K;
    }
    t = (*a).t;
    n = (*a).n;
    if 7 as libc::c_longlong == t {
        tmp = Kv();
        tmp___2 = tmp;
    } else {
        if -(5 as libc::c_longlong) == t {
            tmp___0 = -(1 as libc::c_int) as I;
        } else {
            tmp___0 = t;
        }
        tmp___1 = newK(tmp___0, n);
        tmp___2 = tmp___1;
    }
    z = tmp___2;
    (*z).t = t;
    if t < 0 as libc::c_longlong {
        tmp___17 = -t;
    } else {
        tmp___17 = t;
    }
    if 4 as libc::c_longlong == tmp___17 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh229 = *(((*z).k).as_mut_ptr() as *mut S).offset(i as isize);
            *fresh229 = *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize);
            i += 1;
        }
    } else {
        if t < 0 as libc::c_longlong {
            tmp___16 = -t;
        } else {
            tmp___16 = t;
        }
        if 3 as libc::c_longlong == tmp___16 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                *(((*z).k).as_mut_ptr() as *mut C)
                    .offset(
                        i___0 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize);
                i___0 += 1;
            }
        } else {
            if t < 0 as libc::c_longlong {
                tmp___15 = -t;
            } else {
                tmp___15 = t;
            }
            if 2 as libc::c_longlong == tmp___15 {
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___1 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize);
                    i___1 += 1;
                }
            } else {
                let mut current_block_140: u64;
                if -(5 as libc::c_longlong) == t {
                    current_block_140 = 10869441286625475337;
                } else {
                    if t < 0 as libc::c_longlong {
                        tmp___14 = -t;
                    } else {
                        tmp___14 = t;
                    }
                    if 1 as libc::c_longlong == tmp___14 {
                        current_block_140 = 10869441286625475337;
                    } else {
                        if 0 as libc::c_longlong == t {
                            i___3 = 0 as libc::c_int as I;
                            _i___4 = n;
                            while i___3 < _i___4 {
                                let ref mut fresh230 = *((*z).k)
                                    .as_mut_ptr()
                                    .offset(i___3 as isize);
                                *fresh230 = _kclone(
                                    *((*a).k).as_mut_ptr().offset(i___3 as isize),
                                );
                                i___3 += 1;
                            }
                        } else if 5 as libc::c_longlong == t {
                            i___4 = 0 as libc::c_int as I;
                            _i___5 = n;
                            while i___4 < _i___5 {
                                let ref mut fresh231 = *((*z).k)
                                    .as_mut_ptr()
                                    .offset(i___4 as isize);
                                *fresh231 = _kclone(
                                    *((*a).k).as_mut_ptr().offset(i___4 as isize),
                                );
                                i___4 += 1;
                            }
                        } else if 7 as libc::c_longlong == t {
                            k = 0 as libc::c_int as I;
                            (*z).t = (*a).t;
                            tmp___3 = (*a).n;
                            (*z).n = tmp___3;
                            vt = tmp___3;
                            kv = 0 as K;
                            match vt {
                                1 => {
                                    k = (*(*(((*a).k).as_mut_ptr() as *mut V)
                                        .offset(2 as libc::c_int as isize) as K))
                                        .n - 1 as libc::c_longlong;
                                    kv = newK(
                                        -(4 as libc::c_int) as I,
                                        k + 1 as libc::c_longlong,
                                    );
                                    tmp___4 = OOM_CD(
                                        0 as libc::c_int as I,
                                        z,
                                        kv,
                                        -(1 as libc::c_int) as V,
                                    );
                                    if tmp___4 == 0 {
                                        return 0 as K;
                                    }
                                    v = ((*kv).k).as_mut_ptr() as *mut V;
                                    i___5 = 0 as libc::c_int as I;
                                    _i___6 = k;
                                    while i___5 < _i___6 {
                                        w___0 = *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                                            .offset(2 as libc::c_int as isize) as K))
                                            .k)
                                            .as_mut_ptr() as *mut S as *mut V)
                                            .offset(i___5 as isize);
                                        tmp___8 = VA(w___0);
                                        if tmp___8 != 0 {
                                            let ref mut fresh232 = *v.offset(i___5 as isize);
                                            *fresh232 = w___0;
                                        } else {
                                            tmp___5 = _kclone(*(w___0 as *mut K));
                                            r = tmp___5;
                                            tmp___6 = newE(LS, r);
                                            q = tmp___6 as V;
                                            kap(
                                                (((*z).k).as_mut_ptr() as *mut V as *mut K)
                                                    .offset(3 as libc::c_int as isize),
                                                &mut q as *mut V as V,
                                            );
                                            cd(q as K);
                                            tmp___7 = EVP(q as K);
                                            q = tmp___7 as V;
                                            let ref mut fresh233 = *v.offset(i___5 as isize);
                                            *fresh233 = q;
                                        }
                                        i___5 += 1;
                                    }
                                }
                                2 => {
                                    kv = newK(-(4 as libc::c_int) as I, 3 as libc::c_int as I);
                                    tmp___9 = OOM_CD(
                                        0 as libc::c_int as I,
                                        z,
                                        kv,
                                        -(1 as libc::c_int) as V,
                                    );
                                    if tmp___9 == 0 {
                                        return 0 as K;
                                    }
                                    v = ((*kv).k).as_mut_ptr() as *mut V;
                                    memcpy(
                                        v as *mut libc::c_void,
                                        ((*(*(((*a).k).as_mut_ptr() as *mut V)
                                            .offset(2 as libc::c_int as isize) as K))
                                            .k)
                                            .as_mut_ptr() as *mut S as *mut V as *const libc::c_void,
                                        ::std::mem::size_of::<V>() as libc::c_ulong,
                                    );
                                }
                                3 => {
                                    kv = _kclone(
                                        *(((*a).k).as_mut_ptr() as *mut V)
                                            .offset(2 as libc::c_int as isize) as K,
                                    );
                                    tmp___10 = OOM_CD(
                                        0 as libc::c_int as I,
                                        z,
                                        kv,
                                        -(1 as libc::c_int) as V,
                                    );
                                    if tmp___10 == 0 {
                                        return 0 as K;
                                    }
                                }
                                _ => {}
                            }
                            let ref mut fresh234 = *(((*z).k).as_mut_ptr() as *mut V)
                                .offset(2 as libc::c_int as isize);
                            *fresh234 = kv as V;
                            let ref mut fresh235 = *(((*z).k).as_mut_ptr() as *mut V)
                                .offset(1 as libc::c_int as isize);
                            *fresh235 = *(((*a).k).as_mut_ptr() as *mut V)
                                .offset(1 as libc::c_int as isize);
                            let ref mut fresh236 = *(((*z).k).as_mut_ptr() as *mut V)
                                .offset(0 as libc::c_int as isize);
                            *fresh236 = *(((*a).k).as_mut_ptr() as *mut V)
                                .offset(0 as libc::c_int as isize);
                            cd(
                                *(((*z).k).as_mut_ptr() as *mut V)
                                    .offset(4 as libc::c_int as isize) as K,
                            );
                            tmp___11 = _kclone(
                                *(((*a).k).as_mut_ptr() as *mut V)
                                    .offset(4 as libc::c_int as isize) as K,
                            );
                            let ref mut fresh237 = *(((*z).k).as_mut_ptr() as *mut V)
                                .offset(4 as libc::c_int as isize);
                            *fresh237 = tmp___11 as V;
                            cd(
                                *(((*z).k).as_mut_ptr() as *mut V)
                                    .offset(3 as libc::c_int as isize) as K,
                            );
                            tmp___12 = _kclone(
                                *(((*a).k).as_mut_ptr() as *mut V)
                                    .offset(3 as libc::c_int as isize) as K,
                            );
                            let ref mut fresh238 = *(((*z).k).as_mut_ptr() as *mut V)
                                .offset(3 as libc::c_int as isize);
                            *fresh238 = tmp___12 as V;
                            tmp___13 = _kclone(
                                *(((*a).k).as_mut_ptr() as *mut V)
                                    .offset(5 as libc::c_int as isize) as K,
                            );
                            let ref mut fresh239 = *(((*z).k).as_mut_ptr() as *mut V)
                                .offset(5 as libc::c_int as isize);
                            *fresh239 = tmp___13 as V;
                        }
                        current_block_140 = 7337917895049117968;
                    }
                }
                match current_block_140 {
                    10869441286625475337 => {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = n;
                        while i___2 < _i___3 {
                            *(((*z).k).as_mut_ptr() as *mut I)
                                .offset(
                                    i___2 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                .offset(i___2 as isize);
                            i___2 += 1;
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn collapse(mut x___0: K) -> K {
    let mut z: K = 0 as *mut k0;
    if (*x___0).t == 1 as libc::c_longlong {
        if (*x___0).n == 1 as libc::c_longlong {
            return x___0;
        }
    }
    if (*x___0).t < 0 as libc::c_longlong {
        if (*x___0).n == 1 as libc::c_longlong {
            if (*x___0).t < 0 as libc::c_longlong {
                (*x___0).t = -(*x___0).t;
            } else {
                (*x___0).t = (*x___0).t;
            }
            return x___0;
        }
    }
    if 1 as libc::c_longlong == (*x___0).n {
        z = ci(*((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize));
        cd(x___0);
    } else {
        z = demote(x___0);
    }
    return z;
}
pub unsafe extern "C" fn delist(mut x___0: K) -> K {
    let mut z: K = 0 as *mut k0;
    let mut t: K = 0 as *mut k0;
    z = 0 as K;
    t = x___0;
    while (*t).t == 0 as libc::c_longlong {
        if !((*t).n == 1 as libc::c_longlong) {
            break;
        }
        z = *((*t).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        t = z;
    }
    z = ci(t);
    cd(x___0);
    return z;
}
pub unsafe extern "C" fn demote(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut p: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    if a.is_null() {
        return a;
    }
    t = (*a).t;
    n = (*a).n;
    if 0 as libc::c_longlong != t {
        return a
    } else {
        if 1 as libc::c_longlong > n {
            return a;
        }
    }
    p = (**((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        if p != (**((*a).k).as_mut_ptr().offset(i as isize)).t {
            p = 0 as libc::c_int as I;
        }
        i += 1;
    }
    if 1 as libc::c_longlong <= p {
        if !(p <= 4 as libc::c_longlong) {
            return a;
        }
    } else {
        return a
    }
    tmp = newK(-p, n);
    z = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, a, z, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    if 4 as libc::c_longlong == p {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            let ref mut fresh240 = *(((*z).k).as_mut_ptr() as *mut S)
                .offset(i___0 as isize);
            *fresh240 = *(((**((*a).k).as_mut_ptr().offset(i___0 as isize)).k)
                .as_mut_ptr() as *mut S);
            i___0 += 1;
        }
    } else if 3 as libc::c_longlong == p {
        i___1 = 0 as libc::c_int as I;
        _i___2 = n;
        while i___1 < _i___2 {
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(
                    i___1 as isize,
                ) = *(((**((*a).k).as_mut_ptr().offset(i___1 as isize)).k).as_mut_ptr()
                as *mut C);
            i___1 += 1;
        }
    } else if 2 as libc::c_longlong == p {
        i___2 = 0 as libc::c_int as I;
        _i___3 = n;
        while i___2 < _i___3 {
            *(((*z).k).as_mut_ptr() as *mut F)
                .offset(
                    i___2 as isize,
                ) = *(((**((*a).k).as_mut_ptr().offset(i___2 as isize)).k).as_mut_ptr()
                as *mut F);
            i___2 += 1;
        }
    } else if 1 as libc::c_longlong == p {
        i___3 = 0 as libc::c_int as I;
        _i___4 = n;
        while i___3 < _i___4 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___3 as isize,
                ) = *(((**((*a).k).as_mut_ptr().offset(i___3 as isize)).k).as_mut_ptr()
                as *mut I);
            i___3 += 1;
        }
    }
    cd(a);
    if (*z).t == -(1 as libc::c_longlong) {
        if (*z).n == 1 as libc::c_longlong {
            (*z).t = 1 as libc::c_int as I;
        }
    }
    return z;
}
pub unsafe extern "C" fn promote(mut a: K) -> K {
    let mut at___0: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut v: I = 0;
    let mut tmp___2: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___3: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___4: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___5: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___6: I = 0;
    at___0 = (*a).t;
    if 0 as libc::c_longlong == at___0 {
        tmp = ci(a);
        return tmp;
    }
    if (4 as libc::c_longlong) < at___0 {
        tmp___0 = newK(0 as libc::c_int as I, 1 as libc::c_int as I);
        z = tmp___0;
        if z.is_null() {
            return 0 as K;
        }
        let ref mut fresh241 = *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        *fresh241 = ci(a);
        return z;
    }
    tmp___1 = newK(0 as libc::c_int as I, (*a).n);
    z___0 = tmp___1;
    if z___0.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___2 = -at___0;
    } else {
        tmp___2 = at___0;
    }
    v = tmp___2;
    if 4 as libc::c_longlong == v {
        i = 0 as libc::c_int as I;
        _i___0 = (*a).n;
        while i < _i___0 {
            x___0 = newK(v, 1 as libc::c_int as I);
            tmp___3 = OOM_CD(
                0 as libc::c_int as I,
                x___0,
                z___0,
                -(1 as libc::c_int) as V,
            );
            if tmp___3 == 0 {
                return 0 as K;
            }
            let ref mut fresh242 = *(((*x___0).k).as_mut_ptr() as *mut S);
            *fresh242 = *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize);
            let ref mut fresh243 = *((*z___0).k).as_mut_ptr().offset(i as isize);
            *fresh243 = x___0;
            i += 1;
        }
    } else if 3 as libc::c_longlong == v {
        i___0 = 0 as libc::c_int as I;
        _i___1 = (*a).n;
        while i___0 < _i___1 {
            x___0 = newK(v, 1 as libc::c_int as I);
            tmp___4 = OOM_CD(
                0 as libc::c_int as I,
                x___0,
                z___0,
                -(1 as libc::c_int) as V,
            );
            if tmp___4 == 0 {
                return 0 as K;
            }
            *(((*x___0).k).as_mut_ptr()
                as *mut C) = *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize);
            let ref mut fresh244 = *((*z___0).k).as_mut_ptr().offset(i___0 as isize);
            *fresh244 = x___0;
            i___0 += 1;
        }
    } else if 2 as libc::c_longlong == v {
        i___1 = 0 as libc::c_int as I;
        _i___2 = (*a).n;
        while i___1 < _i___2 {
            x___0 = newK(v, 1 as libc::c_int as I);
            tmp___5 = OOM_CD(
                0 as libc::c_int as I,
                x___0,
                z___0,
                -(1 as libc::c_int) as V,
            );
            if tmp___5 == 0 {
                return 0 as K;
            }
            *(((*x___0).k).as_mut_ptr()
                as *mut F) = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize);
            let ref mut fresh245 = *((*z___0).k).as_mut_ptr().offset(i___1 as isize);
            *fresh245 = x___0;
            i___1 += 1;
        }
    } else if 1 as libc::c_longlong == v {
        i___2 = 0 as libc::c_int as I;
        _i___3 = (*a).n;
        while i___2 < _i___3 {
            x___0 = newK(v, 1 as libc::c_int as I);
            tmp___6 = OOM_CD(
                0 as libc::c_int as I,
                x___0,
                z___0,
                -(1 as libc::c_int) as V,
            );
            if tmp___6 == 0 {
                return 0 as K;
            }
            *(((*x___0).k).as_mut_ptr()
                as *mut I) = *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
            let ref mut fresh246 = *((*z___0).k).as_mut_ptr().offset(i___2 as isize);
            *fresh246 = x___0;
            i___2 += 1;
        }
    }
    return z___0;
}
static mut ns: I = 0 as libc::c_int as I;
static mut sdd: I = 0 as libc::c_int as I;
unsafe extern "C" fn sdupI(mut s: S) -> S {
    let mut k: I = 0;
    let mut d___0: S = 0 as *mut C;
    let mut tmp: size_t = 0;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(s as *const libc::c_char);
    k = tmp as I;
    tmp___0 = alloc(
        ((2 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong)
            as libc::c_ulonglong)
            .wrapping_add(k as libc::c_ulonglong)
            .wrapping_add(1 as libc::c_ulonglong) as size_t,
    );
    d___0 = tmp___0 as S;
    if d___0.is_null() {
        return 0 as S;
    }
    ns += 1;
    sdd = 1 as libc::c_int as I;
    d___0 = d___0
        .offset(
            (2 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong) as isize,
        );
    *d___0.offset(k as isize) = 0 as libc::c_int as C;
    tmp___1 = memcpy(d___0 as *mut libc::c_void, s as *const libc::c_void, k as size_t);
    return tmp___1 as S;
}
pub unsafe extern "C" fn strdupn(mut s: S, mut k: I) -> S {
    let mut d___0: S = 0 as *mut C;
    let mut tmp: V = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = alloc((k + 1 as libc::c_longlong) as size_t);
    d___0 = tmp as S;
    if d___0.is_null() {
        return 0 as S;
    }
    *d___0.offset(k as isize) = 0 as libc::c_int as C;
    tmp___0 = memcpy(d___0 as *mut libc::c_void, s as *const libc::c_void, k as size_t);
    return tmp___0 as S;
}
pub unsafe extern "C" fn strlenn(mut s: S, mut k: I) -> I {
    let mut t: S = 0 as *mut C;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: I = 0;
    tmp = memchr(s as *const libc::c_void, '\u{0}' as i32, k as size_t);
    t = tmp as S;
    if !t.is_null() {
        tmp___0 = t.offset_from(s) as libc::c_long as I;
    } else {
        tmp___0 = k;
    }
    return tmp___0;
}
pub unsafe extern "C" fn StoI(mut s: S, mut n: *mut I) -> I {
    let mut t: S = 0 as *mut C;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: libc::c_long = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: libc::c_int = 0;
    tmp = __errno_location();
    *tmp = 0 as libc::c_int;
    tmp___0 = strtol(
        s as *const libc::c_char,
        &mut t as *mut S as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    *n = tmp___0 as I;
    tmp___1 = __errno_location();
    if *tmp___1 != 0 as libc::c_int {
        tmp___2 = 0 as libc::c_int;
    } else if t as libc::c_ulong == s as libc::c_ulong {
        tmp___2 = 0 as libc::c_int;
    } else if *t as libc::c_int != 0 as libc::c_int {
        tmp___2 = 0 as libc::c_int;
    } else {
        tmp___2 = 1 as libc::c_int;
    }
    return tmp___2 as I;
}
pub unsafe extern "C" fn SC(mut a: S, mut b___1: S) -> I {
    let mut x___0: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strcmp(a as *const libc::c_char, b___1 as *const libc::c_char);
    x___0 = tmp as I;
    if x___0 < 0 as libc::c_longlong {
        tmp___1 = -(1 as libc::c_int);
    } else {
        if x___0 > 0 as libc::c_longlong {
            tmp___0 = 1 as libc::c_int;
        } else {
            tmp___0 = 0 as libc::c_int;
        }
        tmp___1 = tmp___0;
    }
    return tmp___1 as I;
}
pub unsafe extern "C" fn sp(mut k: S) -> S {
    let mut t: N = 0 as *mut Node;
    let mut s: N = 0 as *mut Node;
    let mut p: N = 0 as *mut Node;
    let mut q: N = 0 as *mut Node;
    let mut r: N = 0 as *mut Node;
    let mut a: I = 0;
    let mut x___0: I = 0;
    let mut tmp: *mut node = 0 as *mut node;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: S = 0 as *mut C;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: S = 0 as *mut C;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: libc::c_int = 0;
    if k.is_null() {
        return 0 as S;
    }
    t = SYMBOLS;
    s = (*t).c[1 as libc::c_int as usize];
    p = s;
    q = p;
    if s.is_null() {
        tmp = newN();
        (*t).c[1 as libc::c_int as usize] = tmp;
        s = tmp;
        if s.is_null() {
            tmp___0 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
            return tmp___0 as S;
        }
        tmp___1 = sdupI(k);
        (*s).k = tmp___1 as V;
        if ((*s).k).is_null() {
            free(s as *mut libc::c_void);
            (*t).c[1 as libc::c_int as usize] = 0 as *mut node;
            kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
        }
        return (*s).k as S;
    }
    while !q.is_null() {
        a = SC(k, (*p).k as S);
        if a == 0 {
            return (*p).k as S;
        }
        q = (*p).c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
        if !q.is_null() {
            if (*q).b != 0 {
                t = p;
                s = q;
            }
            p = q;
        } else {
            q = newN();
            if q.is_null() {
                tmp___2 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
                return tmp___2 as S;
            }
            tmp___3 = sdupI(k);
            (*q).k = tmp___3 as V;
            if ((*q).k).is_null() {
                free(q as *mut libc::c_void);
                kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
                return 0 as S;
            }
            (*p).c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize] = q;
            break;
        }
    }
    tmp___5 = SC(k, (*s).k as S);
    if 0 as libc::c_longlong > tmp___5 {
        a = -(1 as libc::c_int) as I;
    } else {
        a = 1 as libc::c_int as I;
    }
    p = (*s).c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
    r = p;
    while p as libc::c_ulong != q as libc::c_ulong {
        x___0 = SC(k, (*p).k as S);
        (*p).b = x___0;
        p = (*p).c[((x___0 + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
    }
    if (*s).b == 0 {
        (*s).b = a;
        return (*p).k as S;
    } else {
        if (*s).b == -a {
            (*s).b = 0 as libc::c_int as I;
            return (*p).k as S;
        }
    }
    if (*r).b == a {
        p = r;
        (*s)
            .c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong)
            as usize] = (*r)
            .c[((-a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
        (*r).c[((-a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize] = s;
        tmp___6 = 0 as libc::c_int as I;
        (*r).b = tmp___6;
        (*s).b = tmp___6;
    } else if (*r).b == -a {
        p = (*r).c[((-a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
        (*r)
            .c[((-a + 1 as libc::c_longlong) / 2 as libc::c_longlong)
            as usize] = (*p)
            .c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
        (*p).c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize] = r;
        (*s)
            .c[((a + 1 as libc::c_longlong) / 2 as libc::c_longlong)
            as usize] = (*p)
            .c[((-a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize];
        (*p).c[((-a + 1 as libc::c_longlong) / 2 as libc::c_longlong) as usize] = s;
        if (*p).b == a {
            (*s).b = -a;
            (*r).b = 0 as libc::c_int as I;
        } else if (*p).b == 0 as libc::c_longlong {
            (*s).b = 0 as libc::c_int as I;
            (*r).b = 0 as libc::c_int as I;
        } else if (*p).b == -a {
            (*s).b = 0 as libc::c_int as I;
            (*r).b = a;
        }
        (*p).b = 0 as libc::c_int as I;
    }
    if s as libc::c_ulong == (*t).c[1 as libc::c_int as usize] as libc::c_ulong {
        tmp___7 = 1 as libc::c_int;
    } else {
        tmp___7 = 0 as libc::c_int;
    }
    (*t).c[tmp___7 as usize] = p;
    return (*q).k as S;
}
pub unsafe extern "C" fn spn(mut s: S, mut n: I) -> S {
    let mut k: I = 0;
    let mut u: S = 0 as *mut C;
    let mut tmp: S = 0 as *mut C;
    let mut v: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    k = 0 as libc::c_int as I;
    while k < n {
        if *s.offset(k as isize) == 0 {
            break;
        }
        k += 1;
    }
    tmp = strdupn(s, k);
    u = tmp;
    if u.is_null() {
        return 0 as S;
    }
    tmp___0 = sp(u);
    v = tmp___0;
    free(u as *mut libc::c_void);
    return v;
}
pub unsafe extern "C" fn wleft(mut x___0: N, mut y: I, mut z: I) -> I {
    let mut o: I = 0;
    let mut tmp: I = 0;
    if x___0.is_null() {
        return z;
    }
    z = wleft((*x___0).c[0 as libc::c_int as usize], y, z);
    if !((*x___0).k).is_null() {
        if *((*x___0).k as *mut I).offset(-y as isize) != 0 {
            o = *((*x___0).k as *mut I).offset(-y as isize);
            *((*x___0).k as *mut I).offset(-y as isize) = z;
            z += o;
        }
    }
    tmp = wleft((*x___0).c[1 as libc::c_int as usize], y, z);
    return tmp;
}
pub unsafe extern "C" fn wright(mut x___0: N, mut y: I, mut z: I) -> I {
    let mut o: I = 0;
    let mut tmp: I = 0;
    if x___0.is_null() {
        return z;
    }
    z = wright((*x___0).c[1 as libc::c_int as usize], y, z);
    if !((*x___0).k).is_null() {
        if *((*x___0).k as *mut I).offset(-y as isize) != 0 {
            o = *((*x___0).k as *mut I).offset(-y as isize);
            *((*x___0).k as *mut I).offset(-y as isize) = z;
            z += o;
        }
    }
    tmp = wright((*x___0).c[0 as libc::c_int as usize], y, z);
    return tmp;
}
unsafe extern "C" fn ssI(mut x___0: N, mut y: libc::c_int, mut z: I) {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    if !x___0.is_null() {
        i = 0 as libc::c_int as I;
        _i___0 = 2 as libc::c_int as I;
        while i < _i___0 {
            ssI((*x___0).c[i as usize], y, z);
            i += 1;
        }
        if !((*x___0).k).is_null() {
            *((*x___0).k as *mut I).offset(-y as isize) = z;
        }
    }
}
pub unsafe extern "C" fn setS(mut y: libc::c_int, mut z: I) {
    ssI(SYMBOLS, y, z);
}
pub unsafe extern "C" fn OS(mut x___0: N, mut y: I) {
    if x___0.is_null() {
        return;
    }
    OS((*x___0).c[0 as libc::c_int as usize], y);
    if !((*x___0).k).is_null() {
        if *((*x___0).k as *mut I).offset(-y as isize) != 0 {
            printf(
                b"%p: %lld\n\0" as *const u8 as *const libc::c_char,
                (*x___0).k,
                *((*x___0).k as *mut I).offset(-y as isize),
            );
        }
    }
    OS((*x___0).c[1 as libc::c_int as usize], y);
}
pub unsafe extern "C" fn itemAtIndex(mut a: K, mut i: I) -> K {
    let mut at___0: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    at___0 = (*a).t;
    if (0 as libc::c_longlong) < at___0 {
        tmp = ci(a);
        return tmp;
    }
    if -(4 as libc::c_longlong) == at___0 {
        tmp___0 = Ks(*(((*a).k).as_mut_ptr() as *mut S).offset(i as isize));
        return tmp___0;
    }
    if -(3 as libc::c_longlong) == at___0 {
        tmp___1 = Kc(*(((*a).k).as_mut_ptr() as *mut C).offset(i as isize));
        return tmp___1;
    }
    if -(2 as libc::c_longlong) == at___0 {
        tmp___2 = Kf(*(((*a).k).as_mut_ptr() as *mut F).offset(i as isize));
        return tmp___2;
    }
    if -(1 as libc::c_longlong) == at___0 {
        tmp___3 = Ki(*(((*a).k).as_mut_ptr() as *mut I).offset(i as isize));
        return tmp___3;
    }
    tmp___4 = ci(*((*a).k).as_mut_ptr().offset(i as isize));
    return tmp___4;
}
pub unsafe extern "C" fn glueSS(mut c: S, mut d___0: S) -> S {
    let mut x___0: I = 0;
    let mut tmp: size_t = 0;
    let mut y: I = 0;
    let mut tmp___0: size_t = 0;
    let mut m: S = 0 as *mut C;
    let mut tmp___1: V = 0 as *mut libc::c_void;
    tmp = strlen(c as *const libc::c_char);
    x___0 = tmp as I;
    tmp___0 = strlen(d___0 as *const libc::c_char);
    y = tmp___0 as I;
    tmp___1 = alloc((x___0 + y + 2 as libc::c_longlong) as size_t);
    m = tmp___1 as S;
    sprintf(
        m as *mut libc::c_char,
        b"%s.%s\0" as *const u8 as *const libc::c_char,
        c,
        d___0,
    );
    return m;
}
pub unsafe extern "C" fn glue(mut a: K, mut b___1: K) -> K {
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    let mut tmp___1: K = 0 as *mut k0;
    tmp = glueSS(
        *(((*a).k).as_mut_ptr() as *mut S),
        *(((*b___1).k).as_mut_ptr() as *mut S),
    );
    tmp___0 = sp(tmp);
    tmp___1 = Ks(tmp___0);
    return tmp___1;
}
pub unsafe extern "C" fn DI(mut d___0: K, mut i: I) -> K {
    return *((*d___0).k).as_mut_ptr().offset(i as isize);
}
pub unsafe extern "C" fn ES(mut d___0: K) -> S {
    return *(((**((*d___0).k).as_mut_ptr().offset(0 as libc::c_int as isize)).k)
        .as_mut_ptr() as *mut S);
}
pub unsafe extern "C" fn DE(mut d___0: K, mut b___1: S) -> K {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: S = 0 as *mut C;
    i = 0 as libc::c_int as I;
    _i___0 = (*d___0).n;
    while i < _i___0 {
        tmp = DI(d___0, i);
        x___0 = tmp;
        tmp___0 = ES(x___0);
        if b___1 as libc::c_ulong == tmp___0 as libc::c_ulong {
            return x___0;
        }
        i += 1;
    }
    return 0 as K;
}
unsafe extern "C" fn EIA(mut a: K, mut i: I) -> *mut K {
    return ((*a).k).as_mut_ptr().offset(i as isize);
}
pub unsafe extern "C" fn EVP(mut e: K) -> *mut K {
    let mut tmp: *mut K = 0 as *mut K;
    tmp = EIA(e, 1 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn EAP(mut e: K) -> *mut K {
    let mut tmp: *mut K = 0 as *mut K;
    tmp = EIA(e, 2 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn EV(mut e: K) -> K {
    let mut tmp: *mut K = 0 as *mut K;
    tmp = EVP(e);
    return *tmp;
}
pub unsafe extern "C" fn lookupEntryOrCreate(mut p: *mut K, mut k: S) -> K {
    let mut a: K = 0 as *mut k0;
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    a = *p;
    if 5 as libc::c_longlong == (*a).t {
        x___0 = DE(a, k);
        if !x___0.is_null() {
            return x___0;
        }
    }
    tmp___0 = strlen(k as *const libc::c_char);
    if tmp___0 == 0 {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    tmp___2 = strchr(k as *const libc::c_char, '.' as i32);
    if !tmp___2.is_null() {
        tmp___1 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___1;
    }
    x___0 = newEntry(k);
    if 6 as libc::c_longlong == (*a).t {
        cd(*p);
        *p = newK(5 as libc::c_int as I, 0 as libc::c_int as I);
    }
    kap(p, &mut x___0 as *mut K as V);
    cd(x___0);
    return x___0;
}
unsafe extern "C" fn denameRecurse(mut p: *mut K, mut t: S, mut create: I) -> *mut K {
    let mut c: I = 0;
    let mut a: I = 0;
    let mut u: S = 0 as *mut C;
    let mut tmp: S = 0 as *mut C;
    let mut k: S = 0 as *mut C;
    let mut tmp___0: S = 0 as *mut C;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut e: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut a___0: K = 0 as *mut k0;
    let mut tmp___4: *mut K = 0 as *mut K;
    if *t == 0 {
        return p;
    }
    if 46 as libc::c_int == *t as libc::c_int {
        t = t.offset(1);
    }
    c = 0 as libc::c_int as I;
    a = (**p).t;
    while *t.offset(c as isize) != 0 {
        if !(46 as libc::c_int != *t.offset(c as isize) as libc::c_int) {
            break;
        }
        c += 1;
    }
    tmp = strdupn(t, c);
    u = tmp;
    tmp___0 = sp(u);
    k = tmp___0;
    free(u as *mut libc::c_void);
    t = t.offset(c as isize);
    if 95 as libc::c_int == *k as libc::c_int {
        tmp___1 = kerr(b"reserved\0" as *const u8 as *const libc::c_char);
        return tmp___1 as *mut K;
    }
    if !(6 as libc::c_longlong == a) {
        if !(5 as libc::c_longlong == a) {
            tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___2 as *mut K;
        }
    }
    e = 0 as K;
    if create != 0 {
        e = lookupEntryOrCreate(p, k);
        if e.is_null() {
            tmp___3 = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
            return tmp___3 as *mut K;
        }
    } else {
        a___0 = *p;
        if 5 as libc::c_longlong == (*a___0).t {
            e = DE(a___0, k);
        }
        if e.is_null() {
            return &mut NIL;
        }
    }
    if 46 as libc::c_int == *t as libc::c_int {
        if *t.offset(1 as libc::c_int as isize) == 0 {
            t = t.offset(1);
            p = EAP(e);
        } else if 46 as libc::c_int
                == *t.offset(1 as libc::c_int as isize) as libc::c_int
            {
            t = t.offset(1);
            p = EAP(e);
        } else {
            p = EVP(e);
        }
    } else {
        p = EVP(e);
    }
    tmp___4 = denameRecurse(p, t, create);
    return tmp___4;
}
pub unsafe extern "C" fn denameD(mut d___0: *mut K, mut t: S, mut create: I) -> *mut K {
    let mut tmp: I = 0;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut tmp___1: *mut K = 0 as *mut K;
    tmp = simpleString(t);
    if tmp == 0 {
        return 0 as *mut K;
    }
    if 46 as libc::c_int == *t as libc::c_int {
        tmp___0 = &mut KTREE;
    } else if *t == 0 {
        tmp___0 = &mut KTREE;
    } else {
        tmp___0 = d___0;
    }
    tmp___1 = denameRecurse(tmp___0, t, create);
    return tmp___1;
}
pub unsafe extern "C" fn denameS(mut dir_string: S, mut t: S, mut create: I) -> *mut K {
    let mut tmp: *mut K = 0 as *mut K;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut tmp___1: *mut K = 0 as *mut K;
    if 46 as libc::c_int == *t as libc::c_int {
        tmp___0 = &mut KTREE;
    } else if *t == 0 {
        tmp___0 = &mut KTREE;
    } else {
        tmp = denameD(&mut KTREE, dir_string, create);
        tmp___0 = tmp;
    }
    tmp___1 = denameD(tmp___0, t, create);
    return tmp___1;
}
pub unsafe extern "C" fn lookupEVOrCreate(mut p: *mut K, mut k: S) -> *mut K {
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut tmp___1: *mut K = 0 as *mut K;
    tmp = lookupEntryOrCreate(p, k);
    x___0 = tmp;
    if !x___0.is_null() {
        tmp___0 = EVP(x___0);
        tmp___1 = tmp___0;
    } else {
        tmp___1 = 0 as *mut K;
    }
    return tmp___1;
}
pub unsafe extern "C" fn lookup(mut a: K, mut b___1: S) -> K {
    let mut x___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    tmp = DE(a, b___1);
    x___0 = tmp;
    if !x___0.is_null() {
        tmp___0 = EV(x___0);
        tmp___2 = tmp___0;
    } else {
        tmp___1 = _n();
        tmp___2 = tmp___1;
    }
    return tmp___2;
}
unsafe extern "C" fn isVerbDyadic(mut x___0: K, mut v: V) -> I {
    let mut tmp: libc::c_int = 0;
    if (*x___0).t == 7 as libc::c_longlong {
        if *(((*(*(((*x___0).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
            as K))
            .k)
            .as_mut_ptr() as *mut S as *mut V)
            .offset(0 as libc::c_int as isize) as libc::c_ulong == v as libc::c_ulong
        {
            if (*(((*(*(((*x___0).k).as_mut_ptr() as *mut V)
                .offset(2 as libc::c_int as isize) as K))
                .k)
                .as_mut_ptr() as *mut S as *mut V)
                .offset(1 as libc::c_int as isize))
                .is_null()
            {
                tmp = 1 as libc::c_int;
            } else {
                tmp = 0 as libc::c_int;
            }
        } else {
            tmp = 0 as libc::c_int;
        }
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as I;
}
pub unsafe extern "C" fn isColonDyadic(mut x___0: K) -> I {
    let mut tmp: I = 0;
    tmp = isVerbDyadic(x___0, offsetColon);
    return tmp;
}
unsafe extern "C" fn isDotDyadic(mut x___0: K) -> I {
    let mut tmp: I = 0;
    tmp = isVerbDyadic(x___0, offsetDot);
    return tmp;
}
pub unsafe extern "C" fn at_verb(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut p: *mut K = 0 as *mut K;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut x___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut zz: K = 0 as *mut k0;
    let mut tmp___13: K = 0 as *mut k0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___17: *mut k0 = 0 as *mut k0;
    let mut tmp___18: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: *mut K = 0 as *mut K;
    let mut tmp___21: K = 0 as *mut k0;
    let mut tmp___22: I = 0;
    let mut tmp___23: I = 0;
    let mut tmp___24: I = 0;
    let mut tmp___25: I = 0;
    if b___1.is_null() {
        return b___1;
    }
    if 0 as libc::c_longlong == (*b___1).t {
        if 0 as libc::c_longlong == (*b___1).n {
            tmp = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
            return tmp;
        }
    }
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 == 6 as libc::c_longlong {
        if bt < 0 as libc::c_longlong {
            tmp___1 = -bt;
        } else {
            tmp___1 = bt;
        }
        if 1 as libc::c_longlong == tmp___1 {
            tmp___0 = ci(b___1);
            return tmp___0;
        }
        if 6 as libc::c_longlong == bt {
            tmp___2 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
            return tmp___2;
        } else {
            if 0 as libc::c_longlong >= bt {
                if 0 as libc::c_longlong == bn {
                    tmp___2 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                    return tmp___2;
                }
            }
        }
        if 4 as libc::c_longlong == bt {
            tmp___3 = _n();
            return tmp___3;
        }
        if -(4 as libc::c_longlong) == bt {
            z = newK(0 as libc::c_int as I, bn);
            i = 0 as libc::c_int as I;
            _i___0 = bn;
            while i < _i___0 {
                let ref mut fresh247 = *((*z).k).as_mut_ptr().offset(i as isize);
                *fresh247 = _n();
                i += 1;
            }
            return z;
        }
        tmp___4 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___4;
    }
    if bt < 0 as libc::c_longlong {
        tmp___25 = -bt;
    } else {
        tmp___25 = bt;
    }
    if 1 as libc::c_longlong == tmp___25 {
        if at___0 == 7 as libc::c_longlong {
            if an == 3 as libc::c_longlong {
                p = &mut a;
                tmp___5 = dv_ex(0 as K, &mut p as *mut *mut K as *mut V, b___1);
                return tmp___5;
            }
        }
        if (0 as libc::c_longlong) < at___0 {
            tmp___6 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___6;
        }
        i___0 = 0 as libc::c_int as I;
        _i___1 = bn;
        while i___0 < _i___1 {
            x___0 = *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            if x___0 >= an {
                tmp___7 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                return tmp___7;
            } else {
                if x___0 < 0 as libc::c_longlong {
                    tmp___7 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                    return tmp___7;
                }
            }
            i___0 += 1;
        }
        z = newK(at___0 * -bt, bn);
        if -(4 as libc::c_longlong) == at___0 {
            i___1 = 0 as libc::c_int as I;
            _i___2 = bn;
            while i___1 < _i___2 {
                let ref mut fresh248 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset(i___1 as isize);
                *fresh248 = *(((*a).k).as_mut_ptr() as *mut S)
                    .offset(
                        *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___1 as isize)
                            as isize,
                    );
                i___1 += 1;
            }
        } else if -(3 as libc::c_longlong) == at___0 {
            i___2 = 0 as libc::c_int as I;
            _i___3 = bn;
            while i___2 < _i___3 {
                *(((*z).k).as_mut_ptr() as *mut C)
                    .offset(
                        i___2 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut C)
                    .offset(
                        *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___2 as isize)
                            as isize,
                    );
                i___2 += 1;
            }
        } else if -(2 as libc::c_longlong) == at___0 {
            i___3 = 0 as libc::c_int as I;
            _i___4 = bn;
            while i___3 < _i___4 {
                *(((*z).k).as_mut_ptr() as *mut F)
                    .offset(
                        i___3 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                    .offset(
                        *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___3 as isize)
                            as isize,
                    );
                i___3 += 1;
            }
        } else if -(1 as libc::c_longlong) == at___0 {
            i___4 = 0 as libc::c_int as I;
            _i___5 = bn;
            while i___4 < _i___5 {
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        i___4 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset(
                        *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___4 as isize)
                            as isize,
                    );
                i___4 += 1;
            }
        } else if 0 as libc::c_longlong == at___0 {
            i___5 = 0 as libc::c_int as I;
            _i___6 = bn;
            while i___5 < _i___6 {
                let ref mut fresh249 = *((*z).k).as_mut_ptr().offset(i___5 as isize);
                *fresh249 = ci(
                    *((*a).k)
                        .as_mut_ptr()
                        .offset(
                            *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___5 as isize)
                                as isize,
                        ),
                );
                i___5 += 1;
            }
            if bt < 0 as libc::c_longlong {
                tmp___8 = -bt;
            } else {
                tmp___8 = bt;
            }
            if bt == tmp___8 {
                z = collapse(z);
            } else if bn != 1 as libc::c_longlong {
                z = collapse(z);
            }
        }
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___24 = -bt;
        } else {
            tmp___24 = bt;
        }
        if 3 as libc::c_longlong == tmp___24 {
            if 5 as libc::c_longlong != at___0 {
                tmp___9 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___9;
            }
            tmp___10 = wd_(
                ((*b___1).k).as_mut_ptr() as *mut C,
                bn as libc::c_int,
                &mut a,
                0 as K,
            );
            z = ex(tmp___10);
        } else {
            if bt < 0 as libc::c_longlong {
                tmp___23 = -bt;
            } else {
                tmp___23 = bt;
            }
            if 4 as libc::c_longlong == tmp___23 {
                if 5 as libc::c_longlong != at___0 {
                    tmp___11 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___11;
                }
                z = newK(0 as libc::c_int as I, bn);
                i___6 = 0 as libc::c_int as I;
                _i___7 = bn;
                while i___6 < _i___7 {
                    tmp___12 = lookup(
                        a,
                        *(((*b___1).k).as_mut_ptr() as *mut S).offset(i___6 as isize),
                    );
                    let ref mut fresh250 = *((*z).k).as_mut_ptr().offset(i___6 as isize);
                    *fresh250 = ci(tmp___12);
                    i___6 += 1;
                }
                if bt < 0 as libc::c_longlong {
                    if !(bn == 1 as libc::c_longlong) {
                        z = collapse(z);
                    }
                } else {
                    z = collapse(z);
                }
                if (*z).t == 0 as libc::c_longlong {
                    if (*z).n == 1 as libc::c_longlong {
                        if (**((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t
                            == 1 as libc::c_longlong
                        {
                            tmp___13 = enlist(
                                *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                            );
                            zz = tmp___13;
                            cd(z);
                            return zz;
                        }
                    }
                }
            } else if 6 as libc::c_longlong == bt {
                if 0 as libc::c_longlong >= at___0 {
                    z = ci(a);
                } else if 5 as libc::c_longlong == at___0 {
                    z = newK(0 as libc::c_int as I, an);
                    i___7 = 0 as libc::c_int as I;
                    _i___8 = an;
                    while i___7 < _i___8 {
                        tmp___14 = DI(a, i___7);
                        tmp___15 = EV(tmp___14);
                        let ref mut fresh251 = *((*z).k)
                            .as_mut_ptr()
                            .offset(i___7 as isize);
                        *fresh251 = ci(tmp___15);
                        i___7 += 1;
                    }
                    z = collapse(z);
                } else {
                    tmp___16 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___16;
                }
            } else if 0 as libc::c_longlong == bt {
                z = newK(0 as libc::c_int as I, bn);
                if z.is_null() {
                    return 0 as K;
                }
                i___8 = 0 as libc::c_int as I;
                _i___9 = bn;
                while i___8 < _i___9 {
                    tmp___17 = at_verb(
                        a,
                        *((*b___1).k).as_mut_ptr().offset(i___8 as isize),
                    );
                    let ref mut fresh252 = *((*z).k).as_mut_ptr().offset(i___8 as isize);
                    *fresh252 = tmp___17;
                    tmp___18 = OOM_CD(
                        0 as libc::c_int as I,
                        z,
                        tmp___17,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___18 == 0 {
                        return 0 as K;
                    }
                    i___8 += 1;
                }
            } else {
                tmp___22 = isDotDyadic(b___1);
                if tmp___22 != 0 {
                    if at___0 == 5 as libc::c_longlong {
                        z = newK(0 as libc::c_int as I, an);
                        i___9 = 0 as libc::c_int as I;
                        _i___10 = an;
                        while i___9 < _i___10 {
                            tmp___19 = DI(a, i___9);
                            tmp___20 = EAP(tmp___19);
                            let ref mut fresh253 = *((*z).k)
                                .as_mut_ptr()
                                .offset(i___9 as isize);
                            *fresh253 = ci(*tmp___20);
                            i___9 += 1;
                        }
                    } else {
                        tmp___21 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                        return tmp___21;
                    }
                } else {
                    tmp___21 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___21;
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn at(mut x___0: K, mut y: K) -> K {
    let mut a: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut s: [C; 256] = [0; 256];
    let mut xx: *mut K = 0 as *mut K;
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: *mut K = 0 as *mut K;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: I = 0;
    if (*x___0).t == 4 as libc::c_longlong {
        if (*y).t < 0 as libc::c_longlong {
            tmp___4 = -(*y).t;
        } else {
            tmp___4 = (*y).t;
        }
        if 1 as libc::c_longlong == tmp___4 {
            strcpy(s.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
            strcat(
                s.as_mut_ptr() as *mut libc::c_char,
                b".\0" as *const u8 as *const libc::c_char,
            );
            strcat(
                s.as_mut_ptr() as *mut libc::c_char,
                *(((*x___0).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            tmp = sp(s.as_mut_ptr());
            tmp___0 = denameD(&mut KTREE, tmp, 1 as libc::c_int as I);
            xx = tmp___0;
            if 6 as libc::c_longlong == (**xx).t {
                tmp___1 = ci(y);
                return tmp___1;
            } else {
                tmp___2 = of(*xx, y);
                return tmp___2;
            }
        } else {
            tmp___3 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
            return tmp___3;
        }
    }
    if 7 as libc::c_longlong != (*x___0).t {
        tmp___5 = at_verb(x___0, y);
        return tmp___5;
    }
    a = enlist(y);
    tmp___6 = OOM_CD(0 as libc::c_int as I, a, -(1 as libc::c_int) as V);
    if tmp___6 == 0 {
        return 0 as K;
    }
    z = dot(x___0, a);
    cd(a);
    return z;
}
unsafe extern "C" fn updateIndex(mut p: *mut K, mut x___0: I, mut r: K) -> I {
    let mut pt: I = 0;
    let mut rt: I = 0;
    let mut t: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    pt = (**p).t;
    rt = (*r).t;
    if 0 as libc::c_longlong == pt {
        cd(*((**p).k).as_mut_ptr().offset(x___0 as isize));
        let ref mut fresh254 = *((**p).k).as_mut_ptr().offset(x___0 as isize);
        *fresh254 = ci(r);
        *p = demote(*p);
    } else if pt != -rt {
        tmp = promote(*p);
        t = tmp;
        cd(*p);
        *p = t;
        cd(*((**p).k).as_mut_ptr().offset(x___0 as isize));
        let ref mut fresh255 = *((**p).k).as_mut_ptr().offset(x___0 as isize);
        *fresh255 = ci(r);
    } else {
        if -(4 as libc::c_longlong) == pt {
            let ref mut fresh256 = *(((**p).k).as_mut_ptr() as *mut S)
                .offset(x___0 as isize);
            *fresh256 = *(((*r).k).as_mut_ptr() as *mut S);
        }
        if -(3 as libc::c_longlong) == pt {
            *(((**p).k).as_mut_ptr() as *mut C)
                .offset(x___0 as isize) = *(((*r).k).as_mut_ptr() as *mut C);
        }
        if -(2 as libc::c_longlong) == pt {
            *(((**p).k).as_mut_ptr() as *mut F)
                .offset(x___0 as isize) = *(((*r).k).as_mut_ptr() as *mut F);
        }
        if -(1 as libc::c_longlong) == pt {
            *(((**p).k).as_mut_ptr() as *mut I)
                .offset(x___0 as isize) = *(((*r).k).as_mut_ptr() as *mut I);
        }
    }
    return 0 as libc::c_int as I;
}
pub unsafe extern "C" fn specialAmendDot(mut c: K, mut args___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut tmp___3: K = 0 as *mut k0;
    tmp___2 = isColonDyadic(c);
    if tmp___2 != 0 {
        if (*(((*c).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize))
            .is_null()
        {
            if 2 as libc::c_longlong == (*args___0).n {
                tmp = ci(
                    *((*args___0).k).as_mut_ptr().offset(1 as libc::c_int as isize),
                );
                tmp___1 = tmp;
            } else {
                tmp___0 = _n();
                tmp___1 = tmp___0;
            }
            return tmp___1;
        }
    }
    tmp___3 = vf_ex(&mut c as *mut K as V, args___0);
    return tmp___3;
}
pub unsafe extern "C" fn atomI(mut a: K) -> I {
    let mut tmp: libc::c_int = 0;
    if (*a).t > 0 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp as I;
}
pub unsafe extern "C" fn atom(mut a: K) -> K {
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = atomI(a);
    tmp___0 = Ki(tmp);
    return tmp___0;
}
pub unsafe extern "C" fn at_ref(mut p: *mut K, mut b___1: K, mut c: K, mut y: K) -> K {
    let mut pt: I = 0;
    let mut pn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut n: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut argc: I = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___11: I = 0;
    let mut args___0: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: I = 0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut tmp___18: I = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___21: I = 0;
    let mut tmp___22: I = 0;
    let mut args___1: K = 0 as *mut k0;
    let mut tmp___23: K = 0 as *mut k0;
    let mut u: S = 0 as *mut C;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: size_t = 0;
    let mut tmp___26: *mut K = 0 as *mut K;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: K = 0 as *mut k0;
    let mut tmp___30: I = 0;
    let mut r___0: K = 0 as *mut k0;
    let mut tmp___31: K = 0 as *mut k0;
    let mut tmp___32: I = 0;
    let mut v: *mut K = 0 as *mut K;
    let mut tmp___33: K = 0 as *mut k0;
    let mut tmp___34: *mut K = 0 as *mut K;
    let mut tmp___35: K = 0 as *mut k0;
    let mut tmp___36: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut tmp___37: K = 0 as *mut k0;
    let mut tmp___38: K = 0 as *mut k0;
    let mut tmp___39: K = 0 as *mut k0;
    let mut tmp___40: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___41: K = 0 as *mut k0;
    let mut tmp___42: *mut k0 = 0 as *mut k0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___43: *mut k0 = 0 as *mut k0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut e: K = 0 as *mut k0;
    let mut tmp___44: K = 0 as *mut k0;
    let mut tmp___45: I = 0;
    let mut tmp___46: I = 0;
    pt = (**p).t;
    pn = (**p).n;
    if pt > 0 as libc::c_longlong {
        if pt != 5 as libc::c_longlong {
            if pt != 6 as libc::c_longlong {
                tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    bt = (*b___1).t;
    bn = (*b___1).n;
    if 0 as libc::c_longlong == bn {
        if -(1 as libc::c_longlong) == bt {
            return 0 as K
        } else {
            if 0 as libc::c_longlong == bt {
                return 0 as K
            } else {
                if 6 as libc::c_longlong == pt {
                    return 0 as K;
                }
            }
        }
    }
    if 0 as libc::c_longlong == bn {
        if bt <= 0 as libc::c_longlong {
            tmp___0 = kerr(b"int\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        }
    }
    if !y.is_null() {
        tmp___1 = atomI(b___1);
        if tmp___1 == 0 {
            tmp___2 = atomI(y);
            if tmp___2 == 0 {
                if bn != (*y).n {
                    return 0 as K;
                }
            }
        }
    }
    if !y.is_null() {
        tmp___5 = atomI(b___1);
        if tmp___5 != 0 {
            tmp___4 = (*y).n;
        } else {
            tmp___4 = bn;
        }
    } else {
        tmp___4 = bn;
    }
    n = tmp___4;
    if !y.is_null() {
        tmp___6 = 2 as libc::c_int;
    } else {
        tmp___6 = 1 as libc::c_int;
    }
    argc = tmp___6 as I;
    if bt < 0 as libc::c_longlong {
        tmp___46 = -bt;
    } else {
        tmp___46 = bt;
    }
    if 1 as libc::c_longlong == tmp___46 {
        if 5 as libc::c_longlong == pt {
            tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___7;
        } else {
            if 6 as libc::c_longlong == pt {
                tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___7;
            }
        }
        i = 0 as libc::c_int as I;
        _i___0 = bn;
        while i < _i___0 {
            x___0 = *(((*b___1).k).as_mut_ptr() as *mut I).offset(i as isize);
            if x___0 < 0 as libc::c_longlong {
                tmp___8 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                return tmp___8;
            } else {
                if x___0 >= pn {
                    tmp___8 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                    return tmp___8;
                }
            }
            i += 1;
        }
        i___0 = 0 as libc::c_int as I;
        tmp___11 = atomI(b___1);
        if tmp___11 != 0 {
            tmp___10 = 1 as libc::c_int as I;
        } else {
            tmp___10 = n;
        }
        _i___1 = tmp___10;
        while i___0 < _i___1 {
            tmp___12 = newK(0 as libc::c_int as I, argc);
            args___0 = tmp___12;
            if args___0.is_null() {
                return 0 as K;
            }
            let ref mut fresh257 = *((*args___0).k)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize);
            *fresh257 = itemAtIndex(
                *p,
                *(((*b___1).k).as_mut_ptr() as *mut I).offset((i___0 % bn) as isize),
            );
            if argc > 1 as libc::c_longlong {
                tmp___16 = atomI(b___1);
                if tmp___16 != 0 {
                    tmp___14 = ci(y);
                    let ref mut fresh258 = *((*args___0).k)
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize);
                    *fresh258 = tmp___14;
                } else {
                    tmp___15 = itemAtIndex(y, i___0 % (*y).n);
                    let ref mut fresh259 = *((*args___0).k)
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize);
                    *fresh259 = tmp___15;
                }
            }
            tmp___17 = specialAmendDot(c, args___0);
            r = tmp___17;
            tmp___18 = OOM_CD(
                0 as libc::c_int as I,
                r,
                args___0,
                -(1 as libc::c_int) as V,
            );
            if tmp___18 == 0 {
                return 0 as K;
            }
            updateIndex(
                p,
                *(((*b___1).k).as_mut_ptr() as *mut I).offset((i___0 % bn) as isize),
                r,
            );
            cd(r);
            cd(args___0);
            i___0 += 1;
        }
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___45 = -bt;
        } else {
            tmp___45 = bt;
        }
        if 4 as libc::c_longlong == tmp___45 {
            if 5 as libc::c_longlong != pt {
                if 6 as libc::c_longlong != pt {
                    tmp___19 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___19;
                }
            }
            i___1 = 0 as libc::c_int as I;
            tmp___22 = atomI(b___1);
            if tmp___22 != 0 {
                tmp___21 = 1 as libc::c_int as I;
            } else {
                tmp___21 = n;
            }
            _i___2 = tmp___21;
            while i___1 < _i___2 {
                tmp___23 = newK(0 as libc::c_int as I, argc);
                args___1 = tmp___23;
                if args___1.is_null() {
                    return 0 as K;
                }
                u = *(((*b___1).k).as_mut_ptr() as *mut S).offset((i___1 % bn) as isize);
                tmp___25 = strlen(u as *const libc::c_char);
                if tmp___25 == 0 {
                    tmp___24 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                    return tmp___24;
                }
                tmp___26 = lookupEVOrCreate(p, u);
                let ref mut fresh260 = *((*args___1).k)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize);
                *fresh260 = ci(*tmp___26);
                if argc > 1 as libc::c_longlong {
                    tmp___30 = atomI(b___1);
                    if tmp___30 != 0 {
                        tmp___28 = ci(y);
                        let ref mut fresh261 = *((*args___1).k)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize);
                        *fresh261 = tmp___28;
                    } else {
                        tmp___29 = itemAtIndex(y, i___1 % (*y).n);
                        let ref mut fresh262 = *((*args___1).k)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize);
                        *fresh262 = tmp___29;
                    }
                }
                tmp___31 = specialAmendDot(c, args___1);
                r___0 = tmp___31;
                tmp___32 = OOM_CD(
                    0 as libc::c_int as I,
                    r___0,
                    args___1,
                    -(1 as libc::c_int) as V,
                );
                if tmp___32 == 0 {
                    return 0 as K;
                }
                tmp___33 = DE(*p, u);
                tmp___34 = EVP(tmp___33);
                v = tmp___34;
                cd(*v);
                *v = r___0;
                cd(args___1);
                i___1 += 1;
            }
        } else if 6 as libc::c_longlong == bt {
            if !y.is_null() {
                tmp___36 = atomI(y);
                if tmp___36 == 0 {
                    if (*y).n != pn {
                        tmp___35 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                        return tmp___35;
                    }
                }
            }
            if 6 as libc::c_longlong == pt {
                return 0 as K;
            }
            if 5 as libc::c_longlong == pt {
                tmp___37 = Ks(LS);
                tmp___39 = tmp___37;
            } else {
                tmp___38 = Ki(0 as libc::c_int as I);
                tmp___39 = tmp___38;
            }
            k = tmp___39;
            if k.is_null() {
                return 0 as K;
            }
            if !y.is_null() {
                y = promote(y);
                tmp___40 = OOM_CD(0 as libc::c_int as I, k, y, -(1 as libc::c_int) as V);
                if tmp___40 == 0 {
                    return 0 as K;
                }
            }
            if 5 as libc::c_longlong == pt {
                i___2 = 0 as libc::c_int as I;
                _i___3 = pn;
                while i___2 < _i___3 {
                    tmp___41 = DI(*p, i___2);
                    let ref mut fresh263 = *(((*k).k).as_mut_ptr() as *mut S);
                    *fresh263 = ES(tmp___41);
                    if !y.is_null() {
                        tmp___42 = *((*y).k)
                            .as_mut_ptr()
                            .offset((i___2 % (*y).n) as isize);
                    } else {
                        tmp___42 = 0 as *mut k0;
                    }
                    at_ref(p, k, c, tmp___42);
                    i___2 += 1;
                }
            } else {
                i___3 = 0 as libc::c_int as I;
                _i___4 = pn;
                while i___3 < _i___4 {
                    *(((*k).k).as_mut_ptr() as *mut I) = i___3;
                    if !y.is_null() {
                        tmp___43 = *((*y).k)
                            .as_mut_ptr()
                            .offset((i___3 % (*y).n) as isize);
                    } else {
                        tmp___43 = 0 as *mut k0;
                    }
                    at_ref(p, k, c, tmp___43);
                    i___3 += 1;
                }
            }
            cd(k);
            cd(y);
        } else if 0 as libc::c_longlong == bt {
            i___4 = 0 as libc::c_int as I;
            _i___5 = n;
            while i___4 < _i___5 {
                e = 0 as K;
                if !y.is_null() {
                    e = itemAtIndex(y, i___4 % (*y).n);
                    if e.is_null() {
                        return 0 as K;
                    }
                }
                at_ref(
                    p,
                    *((*b___1).k).as_mut_ptr().offset((i___4 % bn) as isize),
                    c,
                    e,
                );
                cd(e);
                i___4 += 1;
            }
        } else {
            tmp___44 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___44;
        }
    }
    return 0 as K;
}
pub unsafe extern "C" fn at_tetradic(mut a: K, mut b___1: K, mut c: K, mut y: K) -> K {
    let mut d___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut e: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = enlist(b___1);
    d___0 = tmp;
    if d___0.is_null() {
        return 0 as K;
    }
    tmp___0 = dot_tetradic(a, d___0, c, y);
    e = tmp___0;
    cd(d___0);
    return e;
}
pub unsafe extern "C" fn colon_monadic(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(a);
    return tmp;
}
pub unsafe extern "C" fn colon_dyadic(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = ci(b___1);
    return tmp;
}
unsafe extern "C" fn notsp(mut a: S) -> S {
    let mut b___1: I = 0;
    let mut tmp: size_t = 0;
    let mut c: S = 0 as *mut C;
    let mut tmp___0: V = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut d___0: S = 0 as *mut C;
    let mut tmp___2: S = 0 as *mut C;
    tmp = strlen(a as *const libc::c_char);
    b___1 = tmp as I;
    tmp___0 = alloc((b___1 + 2 as libc::c_longlong) as size_t);
    tmp___1 = strcpy(tmp___0 as *mut libc::c_char, a as *const libc::c_char);
    c = tmp___1;
    if c.is_null() {
        return 0 as S;
    }
    *c.offset(b___1 as isize) = '.' as i32 as C;
    *c.offset((b___1 + 1 as libc::c_longlong) as isize) = '\u{0}' as i32 as C;
    tmp___2 = sp(c);
    d___0 = tmp___2;
    free(c as *mut libc::c_void);
    return d___0;
}
pub unsafe extern "C" fn not_attribute(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: S = 0 as *mut C;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___0: *mut k0 = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    t = (*a).t;
    n = (*a).n;
    if t < 0 as libc::c_longlong {
        tmp___5 = -t;
    } else {
        tmp___5 = t;
    }
    if 4 as libc::c_longlong == tmp___5 {
        z = newK(t, n);
        if z.is_null() {
            return 0 as K;
        }
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            tmp = notsp(*(((*a).k).as_mut_ptr() as *mut S).offset(i as isize));
            let ref mut fresh264 = *(((*z).k).as_mut_ptr() as *mut S).offset(i as isize);
            *fresh264 = tmp;
            if tmp.is_null() {
                cd(z);
                return 0 as K;
            }
            i += 1;
        }
    } else {
        if t < 0 as libc::c_longlong {
            tmp___4 = -t;
        } else {
            tmp___4 = t;
        }
        if 2 as libc::c_longlong == tmp___4 {
            z = newK(t / 2 as libc::c_longlong, n);
            if z.is_null() {
                return 0 as K;
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                if 0 as libc::c_int as F
                    == *(((*a).k).as_mut_ptr() as *mut F).offset(i___0 as isize)
                {
                    *(((*z).k).as_mut_ptr() as *mut I)
                        .offset(i___0 as isize) = 1 as libc::c_int as I;
                } else {
                    *(((*z).k).as_mut_ptr() as *mut I)
                        .offset(i___0 as isize) = 0 as libc::c_int as I;
                }
                i___0 += 1;
            }
        } else {
            if t < 0 as libc::c_longlong {
                tmp___3 = -t;
            } else {
                tmp___3 = t;
            }
            if 1 as libc::c_longlong == tmp___3 {
                z = newK(t, n);
                if z.is_null() {
                    return 0 as K;
                }
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    if 0 as libc::c_longlong
                        == *(((*a).k).as_mut_ptr() as *mut I).offset(i___1 as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___1 as isize) = 1 as libc::c_int as I;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___1 as isize) = 0 as libc::c_int as I;
                    }
                    i___1 += 1;
                }
            } else {
                if t < 0 as libc::c_longlong {
                    tmp___2 = -t;
                } else {
                    tmp___2 = t;
                }
                if 0 as libc::c_longlong == tmp___2 {
                    z = newK(t, n);
                    if z.is_null() {
                        return 0 as K;
                    }
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = n;
                    while i___2 < _i___3 {
                        tmp___0 = not_attribute(
                            *((*a).k).as_mut_ptr().offset(i___2 as isize),
                        );
                        let ref mut fresh265 = *((*z).k)
                            .as_mut_ptr()
                            .offset(i___2 as isize);
                        *fresh265 = tmp___0;
                        if tmp___0.is_null() {
                            cd(z);
                            return 0 as K;
                        }
                        i___2 += 1;
                    }
                } else {
                    tmp___1 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___1;
                }
            }
        }
    }
    return z;
}
unsafe extern "C" fn excl_mkdict(mut a: K, mut b___1: K) -> K {
    let mut n: I = 0;
    let mut k: K = 0 as *mut k0;
    let mut v: K = 0 as *mut k0;
    let mut t: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: I = 0;
    n = (*a).n;
    z = newK(5 as libc::c_int as I, n);
    if z.is_null() {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        v = ci(*((*b___1).k).as_mut_ptr().offset(i as isize));
        t = newK(0 as libc::c_int as I, 3 as libc::c_int as I);
        k = Ks(*(((*a).k).as_mut_ptr() as *mut S).offset(i as isize));
        tmp = OOM_CD(0 as libc::c_int as I, z, k, t, v, -(1 as libc::c_int) as V);
        if tmp == 0 {
            return 0 as K;
        }
        let ref mut fresh266 = *((*t).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        *fresh266 = k;
        let ref mut fresh267 = *((*t).k).as_mut_ptr().offset(1 as libc::c_int as isize);
        *fresh267 = v;
        let ref mut fresh268 = *((*t).k).as_mut_ptr().offset(2 as libc::c_int as isize);
        *fresh268 = _n();
        let ref mut fresh269 = *((*z).k).as_mut_ptr().offset(i as isize);
        *fresh269 = t;
        i += 1;
    }
    return z;
}
pub unsafe extern "C" fn rotate_mod(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    if (*b___1).t > 2 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if (*a).t < 0 as libc::c_longlong {
        tmp___1 = -(*a).t;
    } else {
        tmp___1 = (*a).t;
    }
    if 4 as libc::c_longlong == tmp___1 {
        if 0 as libc::c_longlong == (*b___1).t {
            if (*a).n == (*b___1).n {
                tmp___0 = excl_mkdict(a, b___1);
                return tmp___0;
            }
        }
    }
    if !(1 as libc::c_longlong == (*a).t) {
        if !((*b___1).t > 0 as libc::c_longlong) {
            tmp___2 = kerr(b"int\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
    }
    if (*b___1).t < 1 as libc::c_longlong {
        tmp___3 = rotate(a, b___1);
        tmp___5 = tmp___3;
    } else {
        tmp___4 = mod_0(a, b___1);
        tmp___5 = tmp___4;
    }
    return tmp___5;
}
unsafe extern "C" fn enumerate_charvec(mut pth: *mut C) -> K {
    let mut z: K = 0 as *mut k0;
    let mut len: I = 0;
    let mut tmp: size_t = 0;
    let mut p: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = strlen(pth as *const libc::c_char);
    len = tmp.wrapping_add(3 as libc::c_ulong) as I;
    tmp___0 = newK(-(3 as libc::c_int) as I, len);
    p = tmp___0;
    snprintf(
        ((*p).k).as_mut_ptr() as *mut C as *mut libc::c_char,
        len as size_t,
        b"ls %s\0" as *const u8 as *const libc::c_char,
        pth,
    );
    z = popen_charvec(((*p).k).as_mut_ptr() as *mut C);
    cd(p);
    return z;
}
pub unsafe extern "C" fn enumerate(mut a: K) -> K {
    let mut t: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut n___0: I = 0;
    let mut x___0: I = 0;
    let mut p: I = 0;
    let mut e: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut s: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___3: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut carry: I = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut n___1: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    t = (*a).t;
    if 6 as libc::c_longlong == t {
        z = newK(-(4 as libc::c_int) as I, 0 as libc::c_int as I);
    } else if 5 as libc::c_longlong == t {
        n = (*a).n;
        z = newK(-(4 as libc::c_int) as I, n);
        if z.is_null() {
            return 0 as K;
        }
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            tmp = DI(a, i);
            let ref mut fresh270 = *(((*z).k).as_mut_ptr() as *mut S).offset(i as isize);
            *fresh270 = ES(tmp);
            i += 1;
        }
    } else if -(3 as libc::c_longlong) == t {
        tmp___0 = enumerate_charvec(((*a).k).as_mut_ptr() as *mut C);
        return tmp___0;
    } else {
        if 3 as libc::c_longlong == t {
            tmp___0 = enumerate_charvec(((*a).k).as_mut_ptr() as *mut C);
            return tmp___0;
        } else {
            if 4 as libc::c_longlong == t {
                tmp___1 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
                return tmp___1;
            } else {
                if -(1 as libc::c_longlong) == t {
                    n___0 = (*a).n;
                    p = 1 as libc::c_int as I;
                    i___0 = 0 as libc::c_int as I;
                    _i___1 = n___0;
                    while i___0 < _i___1 {
                        x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                            .offset(i___0 as isize);
                        p *= x___0;
                        if x___0 < 0 as libc::c_longlong {
                            tmp___2 = kerr(b"int\0" as *const u8 as *const libc::c_char);
                            return tmp___2;
                        } else {
                            if p < 0 as libc::c_longlong {
                                tmp___2 = kerr(
                                    b"int\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___2;
                            }
                        }
                        i___0 += 1;
                    }
                    if n___0 == 0 as libc::c_longlong {
                        p = 0 as libc::c_int as I;
                    }
                    z = newK(0 as libc::c_int as I, p);
                    if z.is_null() {
                        return 0 as K;
                    }
                    if p > 0 as libc::c_longlong {
                        i___1 = 0 as libc::c_int as I;
                        _i___2 = p;
                        while i___1 < _i___2 {
                            e = newK(-(1 as libc::c_int) as I, (*a).n);
                            tmp___3 = OOM_CD(
                                0 as libc::c_int as I,
                                e,
                                z,
                                -(1 as libc::c_int) as V,
                            );
                            if tmp___3 == 0 {
                                return 0 as K;
                            }
                            let ref mut fresh271 = *((*z).k)
                                .as_mut_ptr()
                                .offset(i___1 as isize);
                            *fresh271 = e;
                            i___1 += 1;
                        }
                        r = *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize);
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = (*r).n;
                        while i___2 < _i___3 {
                            *(((*r).k).as_mut_ptr() as *mut I)
                                .offset(i___2 as isize) = 0 as libc::c_int as I;
                            i___2 += 1;
                        }
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = p - 1 as libc::c_longlong;
                        while i___3 < _i___4 {
                            r = *((*z).k).as_mut_ptr().offset(i___3 as isize);
                            s = *((*z).k)
                                .as_mut_ptr()
                                .offset((i___3 + 1 as libc::c_longlong) as isize);
                            carry = 1 as libc::c_int as I;
                            j = 0 as libc::c_int as I;
                            _j = (*s).n;
                            while j < _j {
                                x___0 = -(1 as libc::c_longlong) + (*s).n - j;
                                *(((*s).k).as_mut_ptr() as *mut I)
                                    .offset(
                                        x___0 as isize,
                                    ) = *(((*r).k).as_mut_ptr() as *mut I)
                                    .offset(x___0 as isize);
                                if carry != 0 {
                                    let ref mut fresh272 = *(((*s).k).as_mut_ptr() as *mut I)
                                        .offset(x___0 as isize);
                                    *fresh272 += 1;
                                    carry = 0 as libc::c_int as I;
                                }
                                if *(((*s).k).as_mut_ptr() as *mut I).offset(x___0 as isize)
                                    >= *(((*a).k).as_mut_ptr() as *mut I).offset(x___0 as isize)
                                {
                                    *(((*s).k).as_mut_ptr() as *mut I)
                                        .offset(x___0 as isize) = 0 as libc::c_int as I;
                                    carry = 1 as libc::c_int as I;
                                }
                                j += 1;
                            }
                            i___3 += 1;
                        }
                    }
                    return z;
                } else {
                    if !(1 as libc::c_longlong == t) {
                        if !(2 as libc::c_longlong == t) {
                            tmp___6 = kerr(
                                b"domain\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___6;
                        }
                    }
                    if t == 1 as libc::c_longlong {
                        tmp___4 = *(((*a).k).as_mut_ptr() as *mut I);
                    } else {
                        tmp___4 = *(((*a).k).as_mut_ptr() as *mut F) as I;
                    }
                    n___1 = tmp___4;
                    if n___1 < 0 as libc::c_longlong {
                        tmp___5 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                        return tmp___5;
                    }
                    z = newK(-(1 as libc::c_int) as I, n___1);
                    if z.is_null() {
                        return 0 as K;
                    }
                    i___4 = 0 as libc::c_int as I;
                    _i___5 = n___1;
                    while i___4 < _i___5 {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___4 as isize) = i___4;
                        i___4 += 1;
                    }
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn power(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut x___0: F = 0.;
    let mut y: F = 0.;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: libc::c_double = 0.;
    let mut tmp___12: libc::c_double = 0.;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___13: libc::c_double = 0.;
    let mut tmp___14: libc::c_double = 0.;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___15: libc::c_double = 0.;
    let mut tmp___16: libc::c_double = 0.;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___17: libc::c_double = 0.;
    let mut tmp___18: libc::c_double = 0.;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___19: libc::c_double = 0.;
    let mut tmp___20: libc::c_double = 0.;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___21: libc::c_double = 0.;
    let mut tmp___22: libc::c_double = 0.;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___23: libc::c_double = 0.;
    let mut tmp___24: libc::c_double = 0.;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___25: libc::c_double = 0.;
    let mut tmp___26: libc::c_double = 0.;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___27: libc::c_double = 0.;
    let mut tmp___28: libc::c_double = 0.;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___29: libc::c_double = 0.;
    let mut tmp___30: libc::c_double = 0.;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut tmp___31: libc::c_double = 0.;
    let mut tmp___32: libc::c_double = 0.;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___33: libc::c_double = 0.;
    let mut tmp___34: libc::c_double = 0.;
    let mut tmp___35: I = 0;
    let mut tmp___36: I = 0;
    let mut tmp___37: I = 0;
    let mut tmp___38: I = 0;
    let mut tmp___39: I = 0;
    let mut tmp___40: I = 0;
    let mut tmp___41: I = 0;
    let mut tmp___42: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if 1 as libc::c_longlong == zt * zt {
        zt *= 2 as libc::c_longlong;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___41 = -at___0;
    } else {
        tmp___41 = at___0;
    }
    let mut current_block_359: u64;
    if 2 as libc::c_longlong == tmp___41 {
        if bt < 0 as libc::c_longlong {
            tmp___42 = -bt;
        } else {
            tmp___42 = bt;
        }
        if 2 as libc::c_longlong == tmp___42 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    x___0 = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
                    y = *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize);
                    if 0 as libc::c_int as F == y {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i as isize) = 1 as libc::c_int as F;
                    } else {
                        if 0 as libc::c_int as F == x___0 {
                            tmp___12 = 0 as libc::c_int as libc::c_double;
                        } else {
                            tmp___11 = pow(x___0, y);
                            tmp___12 = tmp___11;
                        }
                        *(((*z).k).as_mut_ptr() as *mut F).offset(i as isize) = tmp___12;
                    }
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                x___0 = *(((*a).k).as_mut_ptr() as *mut F)
                    .offset(0 as libc::c_int as isize);
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    y = *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize);
                    if 0 as libc::c_int as F == y {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___0 as isize) = 1 as libc::c_int as F;
                    } else {
                        if 0 as libc::c_int as F == x___0 {
                            tmp___14 = 0 as libc::c_int as libc::c_double;
                        } else {
                            tmp___13 = pow(x___0, y);
                            tmp___14 = tmp___13;
                        }
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___0 as isize) = tmp___14;
                    }
                    i___0 += 1;
                }
            } else {
                y = *(((*b___1).k).as_mut_ptr() as *mut F)
                    .offset(0 as libc::c_int as isize);
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    x___0 = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize);
                    if 0 as libc::c_int as F == y {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize) = 1 as libc::c_int as F;
                    } else {
                        if 0 as libc::c_int as F == x___0 {
                            tmp___16 = 0 as libc::c_int as libc::c_double;
                        } else {
                            tmp___15 = pow(x___0, y);
                            tmp___16 = tmp___15;
                        }
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize) = tmp___16;
                    }
                    i___1 += 1;
                }
            }
            current_block_359 = 13791588947665731104;
        } else {
            current_block_359 = 16025392800501338418;
        }
    } else {
        current_block_359 = 16025392800501338418;
    }
    match current_block_359 {
        16025392800501338418 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___39 = -at___0;
            } else {
                tmp___39 = at___0;
            }
            let mut current_block_358: u64;
            if 2 as libc::c_longlong == tmp___39 {
                if bt < 0 as libc::c_longlong {
                    tmp___40 = -bt;
                } else {
                    tmp___40 = bt;
                }
                if 1 as libc::c_longlong == tmp___40 {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            x___0 = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___2 as isize);
                            y = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___2 as isize) as F;
                            if 0 as libc::c_int as F == y {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___2 as isize) = 1 as libc::c_int as F;
                            } else {
                                if 0 as libc::c_int as F == x___0 {
                                    tmp___18 = 0 as libc::c_int as libc::c_double;
                                } else {
                                    tmp___17 = pow(x___0, y);
                                    tmp___18 = tmp___17;
                                }
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___2 as isize) = tmp___18;
                            }
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        x___0 = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            y = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___3 as isize) as F;
                            if 0 as libc::c_int as F == y {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___3 as isize) = 1 as libc::c_int as F;
                            } else {
                                if 0 as libc::c_int as F == x___0 {
                                    tmp___20 = 0 as libc::c_int as libc::c_double;
                                } else {
                                    tmp___19 = pow(x___0, y);
                                    tmp___20 = tmp___19;
                                }
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___3 as isize) = tmp___20;
                            }
                            i___3 += 1;
                        }
                    } else {
                        y = *(((*b___1).k).as_mut_ptr() as *mut I)
                            .offset(0 as libc::c_int as isize) as F;
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            x___0 = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___4 as isize);
                            if 0 as libc::c_int as F == y {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___4 as isize) = 1 as libc::c_int as F;
                            } else {
                                if 0 as libc::c_int as F == x___0 {
                                    tmp___22 = 0 as libc::c_int as libc::c_double;
                                } else {
                                    tmp___21 = pow(x___0, y);
                                    tmp___22 = tmp___21;
                                }
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___4 as isize) = tmp___22;
                            }
                            i___4 += 1;
                        }
                    }
                    current_block_358 = 10953711258009896266;
                } else {
                    current_block_358 = 5451252698976542353;
                }
            } else {
                current_block_358 = 5451252698976542353;
            }
            match current_block_358 {
                5451252698976542353 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___37 = -at___0;
                    } else {
                        tmp___37 = at___0;
                    }
                    let mut current_block_357: u64;
                    if 1 as libc::c_longlong == tmp___37 {
                        if bt < 0 as libc::c_longlong {
                            tmp___38 = -bt;
                        } else {
                            tmp___38 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___38 {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___5 as isize) as F;
                                    y = *(((*b___1).k).as_mut_ptr() as *mut F)
                                        .offset(i___5 as isize);
                                    if 0 as libc::c_int as F == y {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize) = 1 as libc::c_int as F;
                                    } else {
                                        if 0 as libc::c_int as F == x___0 {
                                            tmp___24 = 0 as libc::c_int as libc::c_double;
                                        } else {
                                            tmp___23 = pow(x___0, y);
                                            tmp___24 = tmp___23;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize) = tmp___24;
                                    }
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    y = *(((*b___1).k).as_mut_ptr() as *mut F)
                                        .offset(i___6 as isize);
                                    if 0 as libc::c_int as F == y {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize) = 1 as libc::c_int as F;
                                    } else {
                                        if 0 as libc::c_int as F == x___0 {
                                            tmp___26 = 0 as libc::c_int as libc::c_double;
                                        } else {
                                            tmp___25 = pow(x___0, y);
                                            tmp___26 = tmp___25;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize) = tmp___26;
                                    }
                                    i___6 += 1;
                                }
                            } else {
                                y = *(((*b___1).k).as_mut_ptr() as *mut F)
                                    .offset(0 as libc::c_int as isize);
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___7 as isize) as F;
                                    if 0 as libc::c_int as F == y {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___7 as isize) = 1 as libc::c_int as F;
                                    } else {
                                        if 0 as libc::c_int as F == x___0 {
                                            tmp___28 = 0 as libc::c_int as libc::c_double;
                                        } else {
                                            tmp___27 = pow(x___0, y);
                                            tmp___28 = tmp___27;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___7 as isize) = tmp___28;
                                    }
                                    i___7 += 1;
                                }
                            }
                            current_block_357 = 3893156993890508670;
                        } else {
                            current_block_357 = 16860203665149995940;
                        }
                    } else {
                        current_block_357 = 16860203665149995940;
                    }
                    match current_block_357 {
                        16860203665149995940 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___35 = -at___0;
                            } else {
                                tmp___35 = at___0;
                            }
                            let mut current_block_356: u64;
                            if 1 as libc::c_longlong == tmp___35 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___36 = -bt;
                                } else {
                                    tmp___36 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___36 {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize) as F;
                                            y = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize) as F;
                                            if 0 as libc::c_int as F == y {
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___8 as isize) = 1 as libc::c_int as F;
                                            } else {
                                                if 0 as libc::c_int as F == x___0 {
                                                    tmp___30 = 0 as libc::c_int as libc::c_double;
                                                } else {
                                                    tmp___29 = pow(x___0, y);
                                                    tmp___30 = tmp___29;
                                                }
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___8 as isize) = tmp___30;
                                            }
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize) as F;
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            y = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                .offset(i___9 as isize) as F;
                                            if 0 as libc::c_int as F == y {
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___9 as isize) = 1 as libc::c_int as F;
                                            } else {
                                                if 0 as libc::c_int as F == x___0 {
                                                    tmp___32 = 0 as libc::c_int as libc::c_double;
                                                } else {
                                                    tmp___31 = pow(x___0, y);
                                                    tmp___32 = tmp___31;
                                                }
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___9 as isize) = tmp___32;
                                            }
                                            i___9 += 1;
                                        }
                                    } else {
                                        y = *(((*b___1).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize) as F;
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            x___0 = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize) as F;
                                            if 0 as libc::c_int as F == y {
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___10 as isize) = 1 as libc::c_int as F;
                                            } else {
                                                if 0 as libc::c_int as F == x___0 {
                                                    tmp___34 = 0 as libc::c_int as libc::c_double;
                                                } else {
                                                    tmp___33 = pow(x___0, y);
                                                    tmp___34 = tmp___33;
                                                }
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___10 as isize) = tmp___34;
                                            }
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_356 = 14829938724230399649;
                                } else {
                                    current_block_356 = 1947308076832162855;
                                }
                            } else {
                                current_block_356 = 1947308076832162855;
                            }
                            match current_block_356 {
                                1947308076832162855 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(power as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(power as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn plus(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___17 = -at___0;
    } else {
        tmp___17 = at___0;
    }
    let mut current_block_212: u64;
    if 2 as libc::c_longlong == tmp___17 {
        if bt < 0 as libc::c_longlong {
            tmp___18 = -bt;
        } else {
            tmp___18 = bt;
        }
        if 2 as libc::c_longlong == tmp___18 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize)
                        + *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize);
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___0 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F)
                        .offset(0 as libc::c_int as isize)
                        + *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize);
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___1 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize)
                        + *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    i___1 += 1;
                }
            }
            current_block_212 = 16185292562584120790;
        } else {
            current_block_212 = 6336621085953920143;
        }
    } else {
        current_block_212 = 6336621085953920143;
    }
    match current_block_212 {
        6336621085953920143 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___15 = -at___0;
            } else {
                tmp___15 = at___0;
            }
            let mut current_block_211: u64;
            if 2 as libc::c_longlong == tmp___15 {
                if bt < 0 as libc::c_longlong {
                    tmp___16 = -bt;
                } else {
                    tmp___16 = bt;
                }
                if 1 as libc::c_longlong == tmp___16 {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___2 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___2 as isize)
                                + *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F;
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___3 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize)
                                + *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F;
                            i___3 += 1;
                        }
                    } else {
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___4 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___4 as isize)
                                + *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                            i___4 += 1;
                        }
                    }
                    current_block_211 = 2956103269722328116;
                } else {
                    current_block_211 = 1968508080901067058;
                }
            } else {
                current_block_211 = 1968508080901067058;
            }
            match current_block_211 {
                1968508080901067058 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___13 = -at___0;
                    } else {
                        tmp___13 = at___0;
                    }
                    let mut current_block_210: u64;
                    if 1 as libc::c_longlong == tmp___13 {
                        if bt < 0 as libc::c_longlong {
                            tmp___14 = -bt;
                        } else {
                            tmp___14 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___14 {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___5 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___5 as isize) as F
                                        + *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize);
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___6 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(0 as libc::c_int as isize) as F
                                        + *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize);
                                    i___6 += 1;
                                }
                            } else {
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___7 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___7 as isize) as F
                                        + *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize);
                                    i___7 += 1;
                                }
                            }
                            current_block_210 = 12153365054289215322;
                        } else {
                            current_block_210 = 8146319797380063844;
                        }
                    } else {
                        current_block_210 = 8146319797380063844;
                    }
                    match current_block_210 {
                        8146319797380063844 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___11 = -at___0;
                            } else {
                                tmp___11 = at___0;
                            }
                            let mut current_block_209: u64;
                            if 1 as libc::c_longlong == tmp___11 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___12 = -bt;
                                } else {
                                    tmp___12 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___12 {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___8 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize)
                                                + *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___9 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize)
                                                + *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize);
                                            i___9 += 1;
                                        }
                                    } else {
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___10 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize)
                                                + *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_209 = 13063492480915008785;
                                } else {
                                    current_block_209 = 12785039224972191080;
                                }
                            } else {
                                current_block_209 = 12785039224972191080;
                            }
                            match current_block_209 {
                                12785039224972191080 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(plus as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(plus as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn times(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___17 = -at___0;
    } else {
        tmp___17 = at___0;
    }
    let mut current_block_212: u64;
    if 2 as libc::c_longlong == tmp___17 {
        if bt < 0 as libc::c_longlong {
            tmp___18 = -bt;
        } else {
            tmp___18 = bt;
        }
        if 2 as libc::c_longlong == tmp___18 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize)
                        * *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize);
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___0 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F)
                        .offset(0 as libc::c_int as isize)
                        * *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize);
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___1 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize)
                        * *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    i___1 += 1;
                }
            }
            current_block_212 = 16185292562584120790;
        } else {
            current_block_212 = 715516793910029825;
        }
    } else {
        current_block_212 = 715516793910029825;
    }
    match current_block_212 {
        715516793910029825 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___15 = -at___0;
            } else {
                tmp___15 = at___0;
            }
            let mut current_block_211: u64;
            if 2 as libc::c_longlong == tmp___15 {
                if bt < 0 as libc::c_longlong {
                    tmp___16 = -bt;
                } else {
                    tmp___16 = bt;
                }
                if 1 as libc::c_longlong == tmp___16 {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___2 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___2 as isize)
                                * *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F;
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___3 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize)
                                * *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F;
                            i___3 += 1;
                        }
                    } else {
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___4 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___4 as isize)
                                * *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                            i___4 += 1;
                        }
                    }
                    current_block_211 = 2956103269722328116;
                } else {
                    current_block_211 = 5798046047375960789;
                }
            } else {
                current_block_211 = 5798046047375960789;
            }
            match current_block_211 {
                5798046047375960789 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___13 = -at___0;
                    } else {
                        tmp___13 = at___0;
                    }
                    let mut current_block_210: u64;
                    if 1 as libc::c_longlong == tmp___13 {
                        if bt < 0 as libc::c_longlong {
                            tmp___14 = -bt;
                        } else {
                            tmp___14 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___14 {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___5 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___5 as isize) as F
                                        * *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize);
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___6 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(0 as libc::c_int as isize) as F
                                        * *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize);
                                    i___6 += 1;
                                }
                            } else {
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___7 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___7 as isize) as F
                                        * *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize);
                                    i___7 += 1;
                                }
                            }
                            current_block_210 = 12153365054289215322;
                        } else {
                            current_block_210 = 1837924089230840207;
                        }
                    } else {
                        current_block_210 = 1837924089230840207;
                    }
                    match current_block_210 {
                        1837924089230840207 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___11 = -at___0;
                            } else {
                                tmp___11 = at___0;
                            }
                            let mut current_block_209: u64;
                            if 1 as libc::c_longlong == tmp___11 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___12 = -bt;
                                } else {
                                    tmp___12 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___12 {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___8 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize)
                                                * *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___9 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize)
                                                * *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize);
                                            i___9 += 1;
                                        }
                                    } else {
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___10 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize)
                                                * *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_209 = 13063492480915008785;
                                } else {
                                    current_block_209 = 211616138621373811;
                                }
                            } else {
                                current_block_209 = 211616138621373811;
                            }
                            match current_block_209 {
                                211616138621373811 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(times as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(times as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn _dot(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut A: I = 0;
    let mut tmp___10: I = 0;
    let mut B: I = 0;
    let mut tmp___11: I = 0;
    let mut accI: I = 0;
    let mut accF: F = 0.;
    let mut x___0: F = 0.;
    let mut y: F = 0.;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut x___1: F = 0.;
    let mut y___0: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___12: libc::c_double = 0.;
    let mut tmp___13: libc::c_double = 0.;
    let mut tmp___14: libc::c_double = 0.;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___15: libc::c_double = 0.;
    let mut tmp___16: libc::c_double = 0.;
    let mut tmp___17: libc::c_double = 0.;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___18: libc::c_double = 0.;
    let mut tmp___19: libc::c_double = 0.;
    let mut tmp___20: libc::c_double = 0.;
    let mut x___2: I = 0;
    let mut y___1: F = 0.;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___21: libc::c_double = 0.;
    let mut tmp___22: libc::c_double = 0.;
    let mut tmp___23: libc::c_double = 0.;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___24: libc::c_double = 0.;
    let mut tmp___25: libc::c_double = 0.;
    let mut tmp___26: libc::c_double = 0.;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___27: libc::c_double = 0.;
    let mut tmp___28: libc::c_double = 0.;
    let mut tmp___29: libc::c_double = 0.;
    let mut x___3: I = 0;
    let mut y___2: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut p: [V; 2] = [0 as *mut libc::c_void; 2];
    let mut x___4: K = 0 as *mut k0;
    let mut y___3: K = 0 as *mut k0;
    let mut tmp___30: K = 0 as *mut k0;
    let mut tmp___32: K = 0 as *mut k0;
    let mut tmp___33: K = 0 as *mut k0;
    let mut tmp___34: K = 0 as *mut k0;
    let mut tmp___35: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    if at___0 < 0 as libc::c_longlong {
        tmp___10 = -at___0;
    } else {
        tmp___10 = at___0;
    }
    A = tmp___10;
    if bt < 0 as libc::c_longlong {
        tmp___11 = -bt;
    } else {
        tmp___11 = bt;
    }
    B = tmp___11;
    accI = 0 as libc::c_int as I;
    accF = 0.0f64;
    let mut current_block_297: u64;
    if 2 as libc::c_longlong == A {
        if 2 as libc::c_longlong == B {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    x___0 = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
                    y = *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize);
                    accF += x___0 * y;
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                x___0 = *(((*a).k).as_mut_ptr() as *mut F)
                    .offset(0 as libc::c_int as isize);
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    y = *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize);
                    accF += x___0 * y;
                    i___0 += 1;
                }
            } else {
                y = *(((*b___1).k).as_mut_ptr() as *mut F)
                    .offset(0 as libc::c_int as isize);
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    x___0 = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize);
                    accF += x___0 * y;
                    i___1 += 1;
                }
            }
            current_block_297 = 3645292745952825570;
        } else {
            current_block_297 = 14889819237577435830;
        }
    } else {
        current_block_297 = 14889819237577435830;
    }
    match current_block_297 {
        14889819237577435830 => {
            let mut current_block_296: u64;
            if 2 as libc::c_longlong == A {
                if 1 as libc::c_longlong == B {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            x___1 = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___2 as isize);
                            y___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___2 as isize);
                            if 9223372036854775807 as libc::c_longlong == y___0 {
                                tmp___14 = 1 as libc::c_int as libc::c_double / 0.0f64;
                            } else {
                                if -(9223372036854775807 as libc::c_longlong) == y___0 {
                                    tmp___13 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                                } else {
                                    if (-(0x7fffffffffffffff as libc::c_long)
                                        - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                        == y___0
                                    {
                                        tmp___12 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                    } else {
                                        tmp___12 = y___0 as libc::c_double;
                                    }
                                    tmp___13 = tmp___12;
                                }
                                tmp___14 = tmp___13;
                            }
                            accF += x___1 * tmp___14;
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        x___1 = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            y___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___3 as isize);
                            if 9223372036854775807 as libc::c_longlong == y___0 {
                                tmp___17 = 1 as libc::c_int as libc::c_double / 0.0f64;
                            } else {
                                if -(9223372036854775807 as libc::c_longlong) == y___0 {
                                    tmp___16 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                                } else {
                                    if (-(0x7fffffffffffffff as libc::c_long)
                                        - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                        == y___0
                                    {
                                        tmp___15 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                    } else {
                                        tmp___15 = y___0 as libc::c_double;
                                    }
                                    tmp___16 = tmp___15;
                                }
                                tmp___17 = tmp___16;
                            }
                            accF += x___1 * tmp___17;
                            i___3 += 1;
                        }
                    } else {
                        y___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                            .offset(0 as libc::c_int as isize);
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            x___1 = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___4 as isize);
                            if 9223372036854775807 as libc::c_longlong == y___0 {
                                tmp___20 = 1 as libc::c_int as libc::c_double / 0.0f64;
                            } else {
                                if -(9223372036854775807 as libc::c_longlong) == y___0 {
                                    tmp___19 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                                } else {
                                    if (-(0x7fffffffffffffff as libc::c_long)
                                        - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                        == y___0
                                    {
                                        tmp___18 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                    } else {
                                        tmp___18 = y___0 as libc::c_double;
                                    }
                                    tmp___19 = tmp___18;
                                }
                                tmp___20 = tmp___19;
                            }
                            accF += x___1 * tmp___20;
                            i___4 += 1;
                        }
                    }
                    current_block_296 = 4046338873413929684;
                } else {
                    current_block_296 = 10418223039402988151;
                }
            } else {
                current_block_296 = 10418223039402988151;
            }
            match current_block_296 {
                10418223039402988151 => {
                    let mut current_block_295: u64;
                    if 1 as libc::c_longlong == A {
                        if 2 as libc::c_longlong == B {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    x___2 = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___5 as isize);
                                    y___1 = *(((*b___1).k).as_mut_ptr() as *mut F)
                                        .offset(i___5 as isize);
                                    if 9223372036854775807 as libc::c_longlong == x___2 {
                                        tmp___23 = 1 as libc::c_int as libc::c_double / 0.0f64;
                                    } else {
                                        if -(9223372036854775807 as libc::c_longlong) == x___2 {
                                            tmp___22 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                                        } else {
                                            if (-(0x7fffffffffffffff as libc::c_long)
                                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                                == x___2
                                            {
                                                tmp___21 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                            } else {
                                                tmp___21 = x___2 as libc::c_double;
                                            }
                                            tmp___22 = tmp___21;
                                        }
                                        tmp___23 = tmp___22;
                                    }
                                    accF += tmp___23 * y___1;
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                x___2 = *(((*a).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize);
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    y___1 = *(((*b___1).k).as_mut_ptr() as *mut F)
                                        .offset(i___6 as isize);
                                    if 9223372036854775807 as libc::c_longlong == x___2 {
                                        tmp___26 = 1 as libc::c_int as libc::c_double / 0.0f64;
                                    } else {
                                        if -(9223372036854775807 as libc::c_longlong) == x___2 {
                                            tmp___25 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                                        } else {
                                            if (-(0x7fffffffffffffff as libc::c_long)
                                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                                == x___2
                                            {
                                                tmp___24 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                            } else {
                                                tmp___24 = x___2 as libc::c_double;
                                            }
                                            tmp___25 = tmp___24;
                                        }
                                        tmp___26 = tmp___25;
                                    }
                                    accF += tmp___26 * y___1;
                                    i___6 += 1;
                                }
                            } else {
                                y___1 = *(((*b___1).k).as_mut_ptr() as *mut F)
                                    .offset(0 as libc::c_int as isize);
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    x___2 = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___7 as isize);
                                    if 9223372036854775807 as libc::c_longlong == x___2 {
                                        tmp___29 = 1 as libc::c_int as libc::c_double / 0.0f64;
                                    } else {
                                        if -(9223372036854775807 as libc::c_longlong) == x___2 {
                                            tmp___28 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                                        } else {
                                            if (-(0x7fffffffffffffff as libc::c_long)
                                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                                                == x___2
                                            {
                                                tmp___27 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                            } else {
                                                tmp___27 = x___2 as libc::c_double;
                                            }
                                            tmp___28 = tmp___27;
                                        }
                                        tmp___29 = tmp___28;
                                    }
                                    accF += tmp___29 * y___1;
                                    i___7 += 1;
                                }
                            }
                            current_block_295 = 14001018086073583847;
                        } else {
                            current_block_295 = 4625221909475802558;
                        }
                    } else {
                        current_block_295 = 4625221909475802558;
                    }
                    match current_block_295 {
                        4625221909475802558 => {
                            let mut current_block_294: u64;
                            if 1 as libc::c_longlong == A {
                                if 1 as libc::c_longlong == B {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            x___3 = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize);
                                            y___2 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize);
                                            accI += x___3 * y___2;
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        x___3 = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize);
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            y___2 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                .offset(i___9 as isize);
                                            accI += x___3 * y___2;
                                            i___9 += 1;
                                        }
                                    } else {
                                        y___2 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize);
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            x___3 = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize);
                                            accI += x___3 * y___2;
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_294 = 8169728755214547442;
                                } else {
                                    current_block_294 = 17464968847345391050;
                                }
                            } else {
                                current_block_294 = 17464968847345391050;
                            }
                            match current_block_294 {
                                17464968847345391050 => 's_1355: {
                                    if !(0 as libc::c_longlong == A) {
                                        if !(0 as libc::c_longlong == B) {
                                            break 's_1355;
                                        }
                                    }
                                    p[0 as libc::c_int as usize] = 0 as V;
                                    p[1 as libc::c_int as usize] = 22 as libc::c_int as V;
                                    x___4 = times(a, b___1);
                                    tmp___30 = overDyad(
                                        0 as K,
                                        p.as_mut_ptr().offset(2 as libc::c_int as isize),
                                        x___4,
                                    );
                                    y___3 = tmp___30;
                                    cd(x___4);
                                    return y___3;
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    if zt < 0 as libc::c_longlong {
        tmp___35 = -zt;
    } else {
        tmp___35 = zt;
    }
    if 1 as libc::c_longlong == tmp___35 {
        tmp___32 = Ki(accI);
        tmp___34 = tmp___32;
    } else {
        tmp___33 = Kf(accF);
        tmp___34 = tmp___33;
    }
    return tmp___34;
}
pub unsafe extern "C" fn mod_0(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut t: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut d___0: I = 0;
    let mut e: I = 0;
    let mut f: F = 0.;
    let mut g: F = 0.;
    let mut h: F = 0.;
    let mut ct: F = 0.;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: libc::c_double = 0.;
    let mut tmp___13: F = 0.;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___14: libc::c_double = 0.;
    let mut tmp___16: F = 0.;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___17: libc::c_double = 0.;
    let mut tmp___19: F = 0.;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___20: libc::c_double = 0.;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___21: *mut k0 = 0 as *mut k0;
    let mut tmp___22: I = 0;
    let mut tmp___23: I = 0;
    let mut tmp___24: I = 0;
    let mut tmp___25: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    if tmp___0 > 2 as libc::c_longlong {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if 0 as libc::c_longlong == at___0 {
        tmp___9 = 0 as libc::c_int as I;
    } else {
        if at___0 < 0 as libc::c_longlong {
            tmp___6 = -at___0;
        } else {
            tmp___6 = at___0;
        }
        if bt < 0 as libc::c_longlong {
            tmp___7 = -bt;
        } else {
            tmp___7 = bt;
        }
        if tmp___6 > tmp___7 {
            if at___0 < 0 as libc::c_longlong {
                tmp___3 = -at___0;
            } else {
                tmp___3 = at___0;
            }
            tmp___5 = tmp___3;
        } else {
            if bt < 0 as libc::c_longlong {
                tmp___4 = -bt;
            } else {
                tmp___4 = bt;
            }
            tmp___5 = tmp___4;
        }
        if at___0 > 0 as libc::c_longlong {
            tmp___8 = 1 as libc::c_int;
        } else {
            tmp___8 = -(1 as libc::c_int);
        }
        tmp___9 = tmp___5 * tmp___8 as I;
    }
    t = tmp___9;
    tmp___10 = newK(t, an);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    ct = 1e-13f64;
    if at___0 < 0 as libc::c_longlong {
        tmp___25 = -at___0;
    } else {
        tmp___25 = at___0;
    }
    let mut current_block_177: u64;
    if 2 as libc::c_longlong == tmp___25 {
        if 2 as libc::c_longlong == bt {
            g = *(((*b___1).k).as_mut_ptr() as *mut F);
            i = 0 as libc::c_int as I;
            _i___0 = an;
            while i < _i___0 {
                f = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
                if g != 0. {
                    tmp___11 = floor(ct + f / g);
                    h = f - g * tmp___11;
                } else {
                    h = f;
                }
                if h < 0 as libc::c_int as F {
                    tmp___13 = -h;
                } else {
                    tmp___13 = h;
                }
                if tmp___13 > ct {
                    *(((*z).k).as_mut_ptr() as *mut F).offset(i as isize) = h;
                } else {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(i as isize) = 0 as libc::c_int as F;
                }
                i += 1;
            }
            current_block_177 = 2942604368452602584;
        } else {
            current_block_177 = 14190605192537412687;
        }
    } else {
        current_block_177 = 14190605192537412687;
    }
    match current_block_177 {
        14190605192537412687 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___24 = -at___0;
            } else {
                tmp___24 = at___0;
            }
            let mut current_block_176: u64;
            if 2 as libc::c_longlong == tmp___24 {
                if 1 as libc::c_longlong == bt {
                    g = *(((*b___1).k).as_mut_ptr() as *mut I) as F;
                    i___0 = 0 as libc::c_int as I;
                    _i___1 = an;
                    while i___0 < _i___1 {
                        f = *(((*a).k).as_mut_ptr() as *mut F).offset(i___0 as isize);
                        if g != 0. {
                            tmp___14 = floor(ct + f / g);
                            h = f - g * tmp___14;
                        } else {
                            h = f;
                        }
                        if h < 0 as libc::c_int as F {
                            tmp___16 = -h;
                        } else {
                            tmp___16 = h;
                        }
                        if tmp___16 > ct {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(i___0 as isize) = h;
                        } else {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(i___0 as isize) = 0 as libc::c_int as F;
                        }
                        i___0 += 1;
                    }
                    current_block_176 = 9216188846964669005;
                } else {
                    current_block_176 = 13882845324590448495;
                }
            } else {
                current_block_176 = 13882845324590448495;
            }
            match current_block_176 {
                13882845324590448495 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___23 = -at___0;
                    } else {
                        tmp___23 = at___0;
                    }
                    let mut current_block_175: u64;
                    if 1 as libc::c_longlong == tmp___23 {
                        if 2 as libc::c_longlong == bt {
                            g = *(((*b___1).k).as_mut_ptr() as *mut F);
                            i___1 = 0 as libc::c_int as I;
                            _i___2 = an;
                            while i___1 < _i___2 {
                                f = *(((*a).k).as_mut_ptr() as *mut I)
                                    .offset(i___1 as isize) as F;
                                if g != 0. {
                                    tmp___17 = floor(ct + f / g);
                                    h = f - g * tmp___17;
                                } else {
                                    h = f;
                                }
                                if h < 0 as libc::c_int as F {
                                    tmp___19 = -h;
                                } else {
                                    tmp___19 = h;
                                }
                                if tmp___19 > ct {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(i___1 as isize) = h;
                                } else {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(i___1 as isize) = 0 as libc::c_int as F;
                                }
                                i___1 += 1;
                            }
                            current_block_175 = 4183419379601546972;
                        } else {
                            current_block_175 = 775119877940558422;
                        }
                    } else {
                        current_block_175 = 775119877940558422;
                    }
                    match current_block_175 {
                        775119877940558422 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___22 = -at___0;
                            } else {
                                tmp___22 = at___0;
                            }
                            let mut current_block_174: u64;
                            if 1 as libc::c_longlong == tmp___22 {
                                if 1 as libc::c_longlong == bt {
                                    d___0 = *(((*b___1).k).as_mut_ptr() as *mut I);
                                    g = d___0 as F;
                                    i___2 = 0 as libc::c_int as I;
                                    _i___3 = an;
                                    while i___2 < _i___3 {
                                        c = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(i___2 as isize);
                                        if d___0 != 0 {
                                            tmp___20 = floor(c as F / g);
                                            e = (c as libc::c_double
                                                - d___0 as libc::c_double * tmp___20) as I;
                                        } else {
                                            e = c;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___2 as isize) = e;
                                        i___2 += 1;
                                    }
                                    current_block_174 = 11508203296038873488;
                                } else {
                                    current_block_174 = 2425783455488083099;
                                }
                            } else {
                                current_block_174 = 2425783455488083099;
                            }
                            match current_block_174 {
                                2425783455488083099 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        i___3 = 0 as libc::c_int as I;
                                        _i___4 = an;
                                        while i___3 < _i___4 {
                                            tmp___21 = mod_0(
                                                *((*a).k).as_mut_ptr().offset(i___3 as isize),
                                                b___1,
                                            );
                                            let ref mut fresh273 = *((*z).k)
                                                .as_mut_ptr()
                                                .offset(i___3 as isize);
                                            *fresh273 = tmp___21;
                                            if tmp___21.is_null() {
                                                cd(z);
                                                return 0 as K;
                                            }
                                            i___3 += 1;
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn minus(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___17 = -at___0;
    } else {
        tmp___17 = at___0;
    }
    let mut current_block_212: u64;
    if 2 as libc::c_longlong == tmp___17 {
        if bt < 0 as libc::c_longlong {
            tmp___18 = -bt;
        } else {
            tmp___18 = bt;
        }
        if 2 as libc::c_longlong == tmp___18 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize)
                        - *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize);
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___0 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F)
                        .offset(0 as libc::c_int as isize)
                        - *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize);
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    *(((*z).k).as_mut_ptr() as *mut F)
                        .offset(
                            i___1 as isize,
                        ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize)
                        - *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    i___1 += 1;
                }
            }
            current_block_212 = 16185292562584120790;
        } else {
            current_block_212 = 987426102729878509;
        }
    } else {
        current_block_212 = 987426102729878509;
    }
    match current_block_212 {
        987426102729878509 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___15 = -at___0;
            } else {
                tmp___15 = at___0;
            }
            let mut current_block_211: u64;
            if 2 as libc::c_longlong == tmp___15 {
                if bt < 0 as libc::c_longlong {
                    tmp___16 = -bt;
                } else {
                    tmp___16 = bt;
                }
                if 1 as libc::c_longlong == tmp___16 {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___2 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___2 as isize)
                                - *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F;
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___3 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize)
                                - *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F;
                            i___3 += 1;
                        }
                    } else {
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___4 as isize,
                                ) = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___4 as isize)
                                - *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                            i___4 += 1;
                        }
                    }
                    current_block_211 = 2956103269722328116;
                } else {
                    current_block_211 = 10402797325465072184;
                }
            } else {
                current_block_211 = 10402797325465072184;
            }
            match current_block_211 {
                10402797325465072184 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___13 = -at___0;
                    } else {
                        tmp___13 = at___0;
                    }
                    let mut current_block_210: u64;
                    if 1 as libc::c_longlong == tmp___13 {
                        if bt < 0 as libc::c_longlong {
                            tmp___14 = -bt;
                        } else {
                            tmp___14 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___14 {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___5 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___5 as isize) as F
                                        - *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize);
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___6 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(0 as libc::c_int as isize) as F
                                        - *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize);
                                    i___6 += 1;
                                }
                            } else {
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    *(((*z).k).as_mut_ptr() as *mut F)
                                        .offset(
                                            i___7 as isize,
                                        ) = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___7 as isize) as F
                                        - *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize);
                                    i___7 += 1;
                                }
                            }
                            current_block_210 = 12153365054289215322;
                        } else {
                            current_block_210 = 13458988118502358807;
                        }
                    } else {
                        current_block_210 = 13458988118502358807;
                    }
                    match current_block_210 {
                        13458988118502358807 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___11 = -at___0;
                            } else {
                                tmp___11 = at___0;
                            }
                            let mut current_block_209: u64;
                            if 1 as libc::c_longlong == tmp___11 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___12 = -bt;
                                } else {
                                    tmp___12 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___12 {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___8 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___8 as isize)
                                                - *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___9 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize)
                                                - *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize);
                                            i___9 += 1;
                                        }
                                    } else {
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___10 as isize,
                                                ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize)
                                                - *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_209 = 13063492480915008785;
                                } else {
                                    current_block_209 = 2576176546763828844;
                                }
                            } else {
                                current_block_209 = 2576176546763828844;
                            }
                            match current_block_209 {
                                2576176546763828844 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(minus as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(minus as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn negate(mut x___0: K) -> K {
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    y = Ki(0 as libc::c_int as I);
    if y.is_null() {
        return 0 as K;
    }
    z = minus(y, x___0);
    cd(y);
    return z;
}
pub unsafe extern "C" fn divide(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut u: F = 0.;
    let mut d___0: F = 0.;
    let mut y: F = 0.;
    let mut s: I = 0;
    let mut t: I = 0;
    let mut w___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: libc::c_longlong = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: libc::c_longlong = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: libc::c_longlong = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___19: F = 0.;
    let mut tmp___20: libc::c_double = 0.;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___21: F = 0.;
    let mut tmp___22: libc::c_double = 0.;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___23: F = 0.;
    let mut tmp___24: libc::c_double = 0.;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___25: F = 0.;
    let mut tmp___26: libc::c_double = 0.;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___27: F = 0.;
    let mut tmp___28: libc::c_double = 0.;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___29: F = 0.;
    let mut tmp___30: libc::c_double = 0.;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___31: F = 0.;
    let mut tmp___32: libc::c_double = 0.;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut tmp___33: F = 0.;
    let mut tmp___34: libc::c_double = 0.;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___35: F = 0.;
    let mut tmp___36: libc::c_double = 0.;
    let mut i___11: I = 0;
    let mut _i___12: I = 0;
    let mut tmp___37: F = 0.;
    let mut tmp___38: libc::c_double = 0.;
    let mut i___12: I = 0;
    let mut _i___13: I = 0;
    let mut tmp___39: F = 0.;
    let mut tmp___40: libc::c_double = 0.;
    let mut i___13: I = 0;
    let mut _i___14: I = 0;
    let mut tmp___41: F = 0.;
    let mut tmp___42: libc::c_double = 0.;
    let mut tmp___43: I = 0;
    let mut tmp___44: I = 0;
    let mut tmp___45: I = 0;
    let mut tmp___46: I = 0;
    let mut tmp___47: I = 0;
    let mut tmp___48: I = 0;
    let mut tmp___49: I = 0;
    let mut tmp___50: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    y = 1 as libc::c_int as libc::c_double / 0.0f64;
    w___0 = 9223372036854775807 as libc::c_longlong;
    if at___0 < 0 as libc::c_longlong {
        tmp___17 = -at___0;
    } else {
        tmp___17 = at___0;
    }
    if 1 as libc::c_longlong == tmp___17 {
        if bt < 0 as libc::c_longlong {
            tmp___18 = -bt;
        } else {
            tmp___18 = bt;
        }
        if 1 as libc::c_longlong == tmp___18 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    s = *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize);
                    t = *(((*b___1).k).as_mut_ptr() as *mut I).offset(i as isize);
                    if t == 0 {
                        if s == 0 {
                            tmp___12 = (-(0x7fffffffffffffff as libc::c_long)
                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong;
                        } else {
                            if s > 0 as libc::c_longlong {
                                tmp___11 = w___0;
                            } else {
                                tmp___11 = -w___0;
                            }
                            tmp___12 = tmp___11;
                        }
                        *(((*z).k).as_mut_ptr() as *mut I).offset(i as isize) = tmp___12;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I).offset(i as isize) = s / t;
                    }
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    s = *(((*a).k).as_mut_ptr() as *mut I)
                        .offset(0 as libc::c_int as isize);
                    t = *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
                    if t == 0 {
                        if s == 0 {
                            tmp___14 = (-(0x7fffffffffffffff as libc::c_long)
                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong;
                        } else {
                            if s > 0 as libc::c_longlong {
                                tmp___13 = w___0;
                            } else {
                                tmp___13 = -w___0;
                            }
                            tmp___14 = tmp___13;
                        }
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___0 as isize) = tmp___14;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___0 as isize) = s / t;
                    }
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    s = *(((*a).k).as_mut_ptr() as *mut I).offset(i___1 as isize);
                    t = *(((*b___1).k).as_mut_ptr() as *mut I)
                        .offset(0 as libc::c_int as isize);
                    if t == 0 {
                        if s == 0 {
                            tmp___16 = (-(0x7fffffffffffffff as libc::c_long)
                                - 1 as libc::c_int as libc::c_long) as libc::c_longlong;
                        } else {
                            if s > 0 as libc::c_longlong {
                                tmp___15 = w___0;
                            } else {
                                tmp___15 = -w___0;
                            }
                            tmp___16 = tmp___15;
                        }
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___1 as isize) = tmp___16;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___1 as isize) = s / t;
                    }
                    i___1 += 1;
                }
            }
            return z;
        }
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___49 = -at___0;
    } else {
        tmp___49 = at___0;
    }
    let mut current_block_492: u64;
    if 2 as libc::c_longlong == tmp___49 {
        if bt < 0 as libc::c_longlong {
            tmp___50 = -bt;
        } else {
            tmp___50 = bt;
        }
        if 2 as libc::c_longlong == tmp___50 {
            if an == bn {
                i___2 = 0 as libc::c_int as I;
                _i___3 = zn;
                while i___2 < _i___3 {
                    u = *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize);
                    d___0 = *(((*b___1).k).as_mut_ptr() as *mut F)
                        .offset(i___2 as isize);
                    if d___0 == 0. {
                        if u == 0. {
                            tmp___20 = 0 as libc::c_int as libc::c_double / 0.0f64;
                        } else {
                            if u > 0 as libc::c_int as F {
                                tmp___19 = y;
                            } else {
                                tmp___19 = -y;
                            }
                            tmp___20 = tmp___19;
                        }
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___2 as isize) = tmp___20;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___2 as isize) = u / d___0;
                    }
                    i___2 += 1;
                }
            } else if an == 1 as libc::c_longlong {
                u = *(((*a).k).as_mut_ptr() as *mut F).offset(0 as libc::c_int as isize);
                i___3 = 0 as libc::c_int as I;
                _i___4 = zn;
                while i___3 < _i___4 {
                    d___0 = *(((*b___1).k).as_mut_ptr() as *mut F)
                        .offset(i___3 as isize);
                    if d___0 == 0. {
                        if u == 0. {
                            tmp___22 = 0 as libc::c_int as libc::c_double / 0.0f64;
                        } else {
                            if u > 0 as libc::c_int as F {
                                tmp___21 = y;
                            } else {
                                tmp___21 = -y;
                            }
                            tmp___22 = tmp___21;
                        }
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___3 as isize) = tmp___22;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___3 as isize) = u / d___0;
                    }
                    i___3 += 1;
                }
            } else {
                d___0 = *(((*b___1).k).as_mut_ptr() as *mut F)
                    .offset(0 as libc::c_int as isize);
                i___4 = 0 as libc::c_int as I;
                _i___5 = zn;
                while i___4 < _i___5 {
                    u = *(((*a).k).as_mut_ptr() as *mut F).offset(i___4 as isize);
                    if d___0 == 0. {
                        if u == 0. {
                            tmp___24 = 0 as libc::c_int as libc::c_double / 0.0f64;
                        } else {
                            if u > 0 as libc::c_int as F {
                                tmp___23 = y;
                            } else {
                                tmp___23 = -y;
                            }
                            tmp___24 = tmp___23;
                        }
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___4 as isize) = tmp___24;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___4 as isize) = u / d___0;
                    }
                    i___4 += 1;
                }
            }
            current_block_492 = 18146883896451375166;
        } else {
            current_block_492 = 17181120519417383232;
        }
    } else {
        current_block_492 = 17181120519417383232;
    }
    match current_block_492 {
        17181120519417383232 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___47 = -at___0;
            } else {
                tmp___47 = at___0;
            }
            let mut current_block_491: u64;
            if 2 as libc::c_longlong == tmp___47 {
                if bt < 0 as libc::c_longlong {
                    tmp___48 = -bt;
                } else {
                    tmp___48 = bt;
                }
                if 1 as libc::c_longlong == tmp___48 {
                    if an == bn {
                        i___5 = 0 as libc::c_int as I;
                        _i___6 = zn;
                        while i___5 < _i___6 {
                            u = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___5 as isize);
                            d___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___5 as isize) as F;
                            if d___0 == 0. {
                                if u == 0. {
                                    tmp___26 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                } else {
                                    if u > 0 as libc::c_int as F {
                                        tmp___25 = y;
                                    } else {
                                        tmp___25 = -y;
                                    }
                                    tmp___26 = tmp___25;
                                }
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___5 as isize) = tmp___26;
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___5 as isize) = u / d___0;
                            }
                            i___5 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        u = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                        i___6 = 0 as libc::c_int as I;
                        _i___7 = zn;
                        while i___6 < _i___7 {
                            d___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___6 as isize) as F;
                            if d___0 == 0. {
                                if u == 0. {
                                    tmp___28 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                } else {
                                    if u > 0 as libc::c_int as F {
                                        tmp___27 = y;
                                    } else {
                                        tmp___27 = -y;
                                    }
                                    tmp___28 = tmp___27;
                                }
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___6 as isize) = tmp___28;
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___6 as isize) = u / d___0;
                            }
                            i___6 += 1;
                        }
                    } else {
                        d___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                            .offset(0 as libc::c_int as isize) as F;
                        i___7 = 0 as libc::c_int as I;
                        _i___8 = zn;
                        while i___7 < _i___8 {
                            u = *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(i___7 as isize);
                            if d___0 == 0. {
                                if u == 0. {
                                    tmp___30 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                } else {
                                    if u > 0 as libc::c_int as F {
                                        tmp___29 = y;
                                    } else {
                                        tmp___29 = -y;
                                    }
                                    tmp___30 = tmp___29;
                                }
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___7 as isize) = tmp___30;
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(i___7 as isize) = u / d___0;
                            }
                            i___7 += 1;
                        }
                    }
                    current_block_491 = 14135407831403722309;
                } else {
                    current_block_491 = 8116542939395503343;
                }
            } else {
                current_block_491 = 8116542939395503343;
            }
            match current_block_491 {
                8116542939395503343 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___45 = -at___0;
                    } else {
                        tmp___45 = at___0;
                    }
                    let mut current_block_490: u64;
                    if 1 as libc::c_longlong == tmp___45 {
                        if bt < 0 as libc::c_longlong {
                            tmp___46 = -bt;
                        } else {
                            tmp___46 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___46 {
                            if an == bn {
                                i___8 = 0 as libc::c_int as I;
                                _i___9 = zn;
                                while i___8 < _i___9 {
                                    u = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___8 as isize) as F;
                                    d___0 = *(((*b___1).k).as_mut_ptr() as *mut F)
                                        .offset(i___8 as isize);
                                    if d___0 == 0. {
                                        if u == 0. {
                                            tmp___32 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                        } else {
                                            if u > 0 as libc::c_int as F {
                                                tmp___31 = y;
                                            } else {
                                                tmp___31 = -y;
                                            }
                                            tmp___32 = tmp___31;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___8 as isize) = tmp___32;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___8 as isize) = u / d___0;
                                    }
                                    i___8 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                u = *(((*a).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                                i___9 = 0 as libc::c_int as I;
                                _i___10 = zn;
                                while i___9 < _i___10 {
                                    d___0 = *(((*b___1).k).as_mut_ptr() as *mut F)
                                        .offset(i___9 as isize);
                                    if d___0 == 0. {
                                        if u == 0. {
                                            tmp___34 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                        } else {
                                            if u > 0 as libc::c_int as F {
                                                tmp___33 = y;
                                            } else {
                                                tmp___33 = -y;
                                            }
                                            tmp___34 = tmp___33;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___9 as isize) = tmp___34;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___9 as isize) = u / d___0;
                                    }
                                    i___9 += 1;
                                }
                            } else {
                                d___0 = *(((*b___1).k).as_mut_ptr() as *mut F)
                                    .offset(0 as libc::c_int as isize);
                                i___10 = 0 as libc::c_int as I;
                                _i___11 = zn;
                                while i___10 < _i___11 {
                                    u = *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___10 as isize) as F;
                                    if d___0 == 0. {
                                        if u == 0. {
                                            tmp___36 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                        } else {
                                            if u > 0 as libc::c_int as F {
                                                tmp___35 = y;
                                            } else {
                                                tmp___35 = -y;
                                            }
                                            tmp___36 = tmp___35;
                                        }
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___10 as isize) = tmp___36;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(i___10 as isize) = u / d___0;
                                    }
                                    i___10 += 1;
                                }
                            }
                            current_block_490 = 2996341718137912513;
                        } else {
                            current_block_490 = 14857426295681092589;
                        }
                    } else {
                        current_block_490 = 14857426295681092589;
                    }
                    match current_block_490 {
                        14857426295681092589 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___43 = -at___0;
                            } else {
                                tmp___43 = at___0;
                            }
                            let mut current_block_489: u64;
                            if 1 as libc::c_longlong == tmp___43 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___44 = -bt;
                                } else {
                                    tmp___44 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___44 {
                                    if an == bn {
                                        i___11 = 0 as libc::c_int as I;
                                        _i___12 = zn;
                                        while i___11 < _i___12 {
                                            u = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___11 as isize) as F;
                                            d___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                .offset(i___11 as isize) as F;
                                            if d___0 == 0. {
                                                if u == 0. {
                                                    tmp___38 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                                } else {
                                                    if u > 0 as libc::c_int as F {
                                                        tmp___37 = y;
                                                    } else {
                                                        tmp___37 = -y;
                                                    }
                                                    tmp___38 = tmp___37;
                                                }
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___11 as isize) = tmp___38;
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___11 as isize) = u / d___0;
                                            }
                                            i___11 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        u = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize) as F;
                                        i___12 = 0 as libc::c_int as I;
                                        _i___13 = zn;
                                        while i___12 < _i___13 {
                                            d___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                .offset(i___12 as isize) as F;
                                            if d___0 == 0. {
                                                if u == 0. {
                                                    tmp___40 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                                } else {
                                                    if u > 0 as libc::c_int as F {
                                                        tmp___39 = y;
                                                    } else {
                                                        tmp___39 = -y;
                                                    }
                                                    tmp___40 = tmp___39;
                                                }
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___12 as isize) = tmp___40;
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___12 as isize) = u / d___0;
                                            }
                                            i___12 += 1;
                                        }
                                    } else {
                                        d___0 = *(((*b___1).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize) as F;
                                        i___13 = 0 as libc::c_int as I;
                                        _i___14 = zn;
                                        while i___13 < _i___14 {
                                            u = *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___13 as isize) as F;
                                            if d___0 == 0. {
                                                if u == 0. {
                                                    tmp___42 = 0 as libc::c_int as libc::c_double / 0.0f64;
                                                } else {
                                                    if u > 0 as libc::c_int as F {
                                                        tmp___41 = y;
                                                    } else {
                                                        tmp___41 = -y;
                                                    }
                                                    tmp___42 = tmp___41;
                                                }
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___13 as isize) = tmp___42;
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut F)
                                                    .offset(i___13 as isize) = u / d___0;
                                            }
                                            i___13 += 1;
                                        }
                                    }
                                    current_block_489 = 5981395450828152283;
                                } else {
                                    current_block_489 = 127172274418284549;
                                }
                            } else {
                                current_block_489 = 127172274418284549;
                            }
                            match current_block_489 {
                                127172274418284549 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(divide as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(divide as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn reciprocal(mut x___0: K) -> K {
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    y = Kf(1 as libc::c_int as F);
    if y.is_null() {
        return 0 as K;
    }
    z = divide(y, x___0);
    cd(y);
    return z;
}
pub unsafe extern "C" fn min_and(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___17 = -at___0;
    } else {
        tmp___17 = at___0;
    }
    let mut current_block_260: u64;
    if 2 as libc::c_longlong == tmp___17 {
        if bt < 0 as libc::c_longlong {
            tmp___18 = -bt;
        } else {
            tmp___18 = bt;
        }
        if 2 as libc::c_longlong == tmp___18 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    if *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize)
                        < *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(i as isize);
                    }
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    if *(((*a).k).as_mut_ptr() as *mut F)
                        .offset(0 as libc::c_int as isize)
                        < *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___0 as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___0 as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(i___0 as isize);
                    }
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    if *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize)
                        < *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    }
                    i___1 += 1;
                }
            }
            current_block_260 = 11721891865182793480;
        } else {
            current_block_260 = 11029500192299958212;
        }
    } else {
        current_block_260 = 11029500192299958212;
    }
    match current_block_260 {
        11029500192299958212 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___15 = -at___0;
            } else {
                tmp___15 = at___0;
            }
            let mut current_block_259: u64;
            if 2 as libc::c_longlong == tmp___15 {
                if bt < 0 as libc::c_longlong {
                    tmp___16 = -bt;
                } else {
                    tmp___16 = bt;
                }
                if 1 as libc::c_longlong == tmp___16 {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            if *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize)
                                < *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F
                            {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___2 as isize,
                                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(i___2 as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___2 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F;
                            }
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            if *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize)
                                < *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F
                            {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___3 as isize,
                                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(0 as libc::c_int as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___3 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F;
                            }
                            i___3 += 1;
                        }
                    } else {
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            if *(((*a).k).as_mut_ptr() as *mut F).offset(i___4 as isize)
                                < *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F
                            {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___4 as isize,
                                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(i___4 as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___4 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                            }
                            i___4 += 1;
                        }
                    }
                    current_block_259 = 14308887607299961996;
                } else {
                    current_block_259 = 17256573074275137345;
                }
            } else {
                current_block_259 = 17256573074275137345;
            }
            match current_block_259 {
                17256573074275137345 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___13 = -at___0;
                    } else {
                        tmp___13 = at___0;
                    }
                    let mut current_block_258: u64;
                    if 1 as libc::c_longlong == tmp___13 {
                        if bt < 0 as libc::c_longlong {
                            tmp___14 = -bt;
                        } else {
                            tmp___14 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___14 {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    if (*(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___5 as isize) as F)
                                        < *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize)
                                    {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___5 as isize,
                                            ) = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(i___5 as isize) as F;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___5 as isize,
                                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize);
                                    }
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    if (*(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(0 as libc::c_int as isize) as F)
                                        < *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize)
                                    {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___6 as isize,
                                            ) = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize) as F;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___6 as isize,
                                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize);
                                    }
                                    i___6 += 1;
                                }
                            } else {
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    if (*(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(i___7 as isize) as F)
                                        < *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize)
                                    {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___7 as isize,
                                            ) = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(i___7 as isize) as F;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___7 as isize,
                                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize);
                                    }
                                    i___7 += 1;
                                }
                            }
                            current_block_258 = 7609157773043925677;
                        } else {
                            current_block_258 = 8267784932374259760;
                        }
                    } else {
                        current_block_258 = 8267784932374259760;
                    }
                    match current_block_258 {
                        8267784932374259760 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___11 = -at___0;
                            } else {
                                tmp___11 = at___0;
                            }
                            let mut current_block_257: u64;
                            if 1 as libc::c_longlong == tmp___11 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___12 = -bt;
                                } else {
                                    tmp___12 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___12 {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            if *(((*a).k).as_mut_ptr() as *mut I).offset(i___8 as isize)
                                                < *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize)
                                            {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___8 as isize,
                                                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___8 as isize,
                                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            }
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            if *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize)
                                                < *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize)
                                            {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___9 as isize,
                                                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___9 as isize,
                                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize);
                                            }
                                            i___9 += 1;
                                        }
                                    } else {
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            if *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize)
                                                < *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize)
                                            {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___10 as isize,
                                                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(i___10 as isize);
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___10 as isize,
                                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            }
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_257 = 13675415059418534261;
                                } else {
                                    current_block_257 = 1509571696866590551;
                                }
                            } else {
                                current_block_257 = 1509571696866590551;
                            }
                            match current_block_257 {
                                1509571696866590551 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(min_and as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(min_and as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn max_or(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut type_0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut zt: I = 0;
    let mut tmp___8: I = 0;
    let mut zn: I = 0;
    let mut tmp___9: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut tmp___11: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if bt < 0 as libc::c_longlong {
        tmp___5 = -bt;
    } else {
        tmp___5 = bt;
    }
    if tmp___4 > tmp___5 {
        if at___0 < 0 as libc::c_longlong {
            tmp___1 = -at___0;
        } else {
            tmp___1 = at___0;
        }
        tmp___3 = tmp___1;
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___2 = -bt;
        } else {
            tmp___2 = bt;
        }
        tmp___3 = tmp___2;
    }
    type_0 = tmp___3;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp___6 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___6;
            }
        }
    }
    if type_0 > 2 as libc::c_longlong {
        tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___7;
    }
    zt = type_0;
    if at___0 < bt {
        tmp___8 = at___0;
    } else {
        tmp___8 = bt;
    }
    if tmp___8 < 1 as libc::c_longlong {
        zt = -zt;
    }
    if at___0 == 0 {
        zt = 0 as libc::c_int as I;
    } else if bt == 0 {
        zt = 0 as libc::c_int as I;
    }
    if at___0 > 0 as libc::c_longlong {
        tmp___9 = bn;
    } else {
        tmp___9 = an;
    }
    zn = tmp___9;
    tmp___10 = newK(zt, zn);
    z = tmp___10;
    if z.is_null() {
        return 0 as K;
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___17 = -at___0;
    } else {
        tmp___17 = at___0;
    }
    let mut current_block_260: u64;
    if 2 as libc::c_longlong == tmp___17 {
        if bt < 0 as libc::c_longlong {
            tmp___18 = -bt;
        } else {
            tmp___18 = bt;
        }
        if 2 as libc::c_longlong == tmp___18 {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    if *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize)
                        > *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(i as isize);
                    }
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    if *(((*a).k).as_mut_ptr() as *mut F)
                        .offset(0 as libc::c_int as isize)
                        > *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___0 as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___0 as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(i___0 as isize);
                    }
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    if *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize)
                        > *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize);
                    }
                    i___1 += 1;
                }
            }
            current_block_260 = 11721891865182793480;
        } else {
            current_block_260 = 15059034191380071223;
        }
    } else {
        current_block_260 = 15059034191380071223;
    }
    match current_block_260 {
        15059034191380071223 => {
            if at___0 < 0 as libc::c_longlong {
                tmp___15 = -at___0;
            } else {
                tmp___15 = at___0;
            }
            let mut current_block_259: u64;
            if 2 as libc::c_longlong == tmp___15 {
                if bt < 0 as libc::c_longlong {
                    tmp___16 = -bt;
                } else {
                    tmp___16 = bt;
                }
                if 1 as libc::c_longlong == tmp___16 {
                    if an == bn {
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = zn;
                        while i___2 < _i___3 {
                            if *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize)
                                > *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F
                            {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___2 as isize,
                                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(i___2 as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___2 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___2 as isize) as F;
                            }
                            i___2 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            if *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize)
                                > *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F
                            {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___3 as isize,
                                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(0 as libc::c_int as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___3 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) as F;
                            }
                            i___3 += 1;
                        }
                    } else {
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            if *(((*a).k).as_mut_ptr() as *mut F).offset(i___4 as isize)
                                > *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F
                            {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___4 as isize,
                                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(i___4 as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut F)
                                    .offset(
                                        i___4 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize) as F;
                            }
                            i___4 += 1;
                        }
                    }
                    current_block_259 = 14308887607299961996;
                } else {
                    current_block_259 = 4780522205923718078;
                }
            } else {
                current_block_259 = 4780522205923718078;
            }
            match current_block_259 {
                4780522205923718078 => {
                    if at___0 < 0 as libc::c_longlong {
                        tmp___13 = -at___0;
                    } else {
                        tmp___13 = at___0;
                    }
                    let mut current_block_258: u64;
                    if 1 as libc::c_longlong == tmp___13 {
                        if bt < 0 as libc::c_longlong {
                            tmp___14 = -bt;
                        } else {
                            tmp___14 = bt;
                        }
                        if 2 as libc::c_longlong == tmp___14 {
                            if an == bn {
                                i___5 = 0 as libc::c_int as I;
                                _i___6 = zn;
                                while i___5 < _i___6 {
                                    if *(((*a).k).as_mut_ptr() as *mut I).offset(i___5 as isize)
                                        as F
                                        > *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize)
                                    {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___5 as isize,
                                            ) = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(i___5 as isize) as F;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___5 as isize,
                                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___5 as isize);
                                    }
                                    i___5 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    if *(((*a).k).as_mut_ptr() as *mut I)
                                        .offset(0 as libc::c_int as isize) as F
                                        > *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize)
                                    {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___6 as isize,
                                            ) = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize) as F;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___6 as isize,
                                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize);
                                    }
                                    i___6 += 1;
                                }
                            } else {
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    if *(((*a).k).as_mut_ptr() as *mut I).offset(i___7 as isize)
                                        as F
                                        > *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize)
                                    {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___7 as isize,
                                            ) = *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(i___7 as isize) as F;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut F)
                                            .offset(
                                                i___7 as isize,
                                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize);
                                    }
                                    i___7 += 1;
                                }
                            }
                            current_block_258 = 7609157773043925677;
                        } else {
                            current_block_258 = 6242459971066794349;
                        }
                    } else {
                        current_block_258 = 6242459971066794349;
                    }
                    match current_block_258 {
                        6242459971066794349 => {
                            if at___0 < 0 as libc::c_longlong {
                                tmp___11 = -at___0;
                            } else {
                                tmp___11 = at___0;
                            }
                            let mut current_block_257: u64;
                            if 1 as libc::c_longlong == tmp___11 {
                                if bt < 0 as libc::c_longlong {
                                    tmp___12 = -bt;
                                } else {
                                    tmp___12 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___12 {
                                    if an == bn {
                                        i___8 = 0 as libc::c_int as I;
                                        _i___9 = zn;
                                        while i___8 < _i___9 {
                                            if *(((*a).k).as_mut_ptr() as *mut I).offset(i___8 as isize)
                                                > *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize)
                                            {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___8 as isize,
                                                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___8 as isize,
                                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___8 as isize);
                                            }
                                            i___8 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            if *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize)
                                                > *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize)
                                            {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___9 as isize,
                                                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___9 as isize,
                                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize);
                                            }
                                            i___9 += 1;
                                        }
                                    } else {
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            if *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___10 as isize)
                                                > *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize)
                                            {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___10 as isize,
                                                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(i___10 as isize);
                                            } else {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___10 as isize,
                                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize);
                                            }
                                            i___10 += 1;
                                        }
                                    }
                                    current_block_257 = 13675415059418534261;
                                } else {
                                    current_block_257 = 15945001352692722286;
                                }
                            } else {
                                current_block_257 = 15945001352692722286;
                            }
                            match current_block_257 {
                                15945001352692722286 => {
                                    if 0 as libc::c_longlong == at___0 {
                                        dp(
                                            &mut z,
                                            Some(max_or as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    } else if 0 as libc::c_longlong == bt {
                                        dp(
                                            &mut z,
                                            Some(max_or as unsafe extern "C" fn(K, K) -> K),
                                            a,
                                            b___1,
                                        );
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn floor_ceil(
    mut a: K,
    mut g: Option::<unsafe extern "C" fn(F) -> F>,
) -> K {
    let mut current_block: u64;
    let mut tmp: libc::c_int = 0;
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut h: Option::<unsafe extern "C" fn(F) -> F> = None;
    let mut tmp___0: Option::<unsafe extern "C" fn(libc::c_double) -> libc::c_double> = None;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut e: F = 0.;
    let mut f: F = 0.;
    let mut r: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___10: F = 0.;
    let mut tmp___11: F = 0.;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___16: I = 0;
    tmp = strcmp(
        errmsg.as_mut_ptr() as *const libc::c_char,
        b"(nil)\0" as *const u8 as *const libc::c_char,
    );
    if tmp != 0 {
        return 0 as K;
    }
    at___0 = (*a).t;
    an = (*a).n;
    if ::std::mem::transmute::<Option::<unsafe extern "C" fn(F) -> F>, libc::c_ulong>(g)
        == ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(libc::c_double) -> libc::c_double>,
            libc::c_ulong,
        >(Some(ceil as unsafe extern "C" fn(libc::c_double) -> libc::c_double))
    {
        tmp___0 = Some(floor as unsafe extern "C" fn(libc::c_double) -> libc::c_double);
    } else {
        tmp___0 = Some(ceil as unsafe extern "C" fn(libc::c_double) -> libc::c_double);
    }
    h = tmp___0;
    if at___0 < 0 as libc::c_longlong {
        tmp___2 = -at___0;
    } else {
        tmp___2 = at___0;
    }
    if (2 as libc::c_longlong) < tmp___2 {
        tmp___1 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___1;
    } else {
        if 0 as libc::c_longlong == at___0 {
            if 7 as libc::c_longlong
                == (**((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t
            {
                tmp___1 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___1;
            }
        }
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___4 = -at___0;
    } else {
        tmp___4 = at___0;
    }
    if 1 as libc::c_longlong == tmp___4 {
        tmp___3 = ci(a);
        return tmp___3;
    }
    if at___0 != 0 {
        if at___0 < 0 as libc::c_longlong {
            tmp___5 = -(1 as libc::c_int);
        } else {
            tmp___5 = 1 as libc::c_int;
        }
        tmp___6 = tmp___5;
    } else {
        tmp___6 = 0 as libc::c_int;
    }
    tmp___7 = newK(tmp___6 as I, an);
    z = tmp___7;
    if at___0 < 0 as libc::c_longlong {
        tmp___16 = -at___0;
    } else {
        tmp___16 = at___0;
    }
    if 2 as libc::c_longlong == tmp___16 {
        i = 0 as libc::c_int as I;
        _i___0 = an;
        while i < _i___0 {
            e = *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize);
            tmp___15 = e.is_nan() as i32;
            if tmp___15 != 0 {
                r = (-(0x7fffffffffffffff as libc::c_long)
                    - 1 as libc::c_int as libc::c_long) as I;
            } else {
                tmp___14 = if e.is_infinite() {
                    if e.is_sign_positive() { 1 } else { -1 }
                } else {
                    0
                };
                if tmp___14 != 0 {
                    current_block = 2698552979854033773;
                } else if e <= -(9223372036854775807 as libc::c_longlong) as F {
                    current_block = 2698552979854033773;
                } else if e >= 9223372036854775807 as libc::c_longlong as F {
                    current_block = 2698552979854033773;
                } else {
                    f = FF(e);
                    let mut current_block_82: u64;
                    if f > 0 as libc::c_int as F {
                        tmp___12 = FC(f, 1 as libc::c_int as F);
                        if tmp___12 != 0 {
                            current_block_82 = 6582340342484496857;
                        } else {
                            tmp___10 = (Some(h.expect("non-null function pointer")))
                                .expect("non-null function pointer")(e);
                            r = tmp___10 as I;
                            current_block_82 = 576355610076403033;
                        }
                    } else {
                        current_block_82 = 6582340342484496857;
                    }
                    match current_block_82 {
                        6582340342484496857 => {
                            if f < 0 as libc::c_int as F {
                                tmp___13 = FC(f, 0 as libc::c_int as F);
                                if tmp___13 != 0 {
                                    tmp___11 = (Some(g.expect("non-null function pointer")))
                                        .expect("non-null function pointer")(e);
                                    r = tmp___11 as I;
                                } else {
                                    tmp___10 = (Some(h.expect("non-null function pointer")))
                                        .expect("non-null function pointer")(e);
                                    r = tmp___10 as I;
                                }
                            } else {
                                tmp___11 = (Some(g.expect("non-null function pointer")))
                                    .expect("non-null function pointer")(e);
                                r = tmp___11 as I;
                            }
                        }
                        _ => {}
                    }
                    current_block = 12027283704867122503;
                }
                match current_block {
                    12027283704867122503 => {}
                    _ => {
                        if e < 0 as libc::c_int as F {
                            r = -(9223372036854775807 as libc::c_longlong);
                        } else {
                            r = 9223372036854775807 as libc::c_longlong;
                        }
                    }
                }
            }
            *(((*z).k).as_mut_ptr() as *mut I).offset(i as isize) = r;
            i += 1;
        }
    } else if at___0 == 0 {
        i___0 = 0 as libc::c_int as I;
        _i___1 = an;
        while i___0 < _i___1 {
            let ref mut fresh274 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh274 = floor_ceil(*((*a).k).as_mut_ptr().offset(i___0 as isize), g);
            i___0 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn floor_verb(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = floor_ceil(
        a,
        Some(floor as unsafe extern "C" fn(libc::c_double) -> libc::c_double),
    );
    return tmp;
}
pub unsafe extern "C" fn FC_IF(mut a: I, mut b___1: F) -> I {
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: I = 0;
    if 9223372036854775807 as libc::c_longlong == a {
        tmp___1 = 1 as libc::c_int as libc::c_double / 0.0f64;
    } else {
        if -(9223372036854775807 as libc::c_longlong) == a {
            tmp___0 = -(1 as libc::c_int as libc::c_double / 0.0f64);
        } else {
            if (-(0x7fffffffffffffff as libc::c_long) - 1 as libc::c_int as libc::c_long)
                as libc::c_longlong == a
            {
                tmp = 0 as libc::c_int as libc::c_double / 0.0f64;
            } else {
                tmp = a as libc::c_double;
            }
            tmp___0 = tmp;
        }
        tmp___1 = tmp___0;
    }
    tmp___2 = FC(tmp___1, b___1);
    return tmp___2;
}
pub unsafe extern "C" fn FC_FI(mut a: F, mut b___1: I) -> I {
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: I = 0;
    if 9223372036854775807 as libc::c_longlong == b___1 {
        tmp___1 = 1 as libc::c_int as libc::c_double / 0.0f64;
    } else {
        if -(9223372036854775807 as libc::c_longlong) == b___1 {
            tmp___0 = -(1 as libc::c_int as libc::c_double / 0.0f64);
        } else {
            if (-(0x7fffffffffffffff as libc::c_long) - 1 as libc::c_int as libc::c_long)
                as libc::c_longlong == b___1
            {
                tmp = 0 as libc::c_int as libc::c_double / 0.0f64;
            } else {
                tmp = b___1 as libc::c_double;
            }
            tmp___0 = tmp;
        }
        tmp___1 = tmp___0;
    }
    tmp___2 = FC(a, tmp___1);
    return tmp___2;
}
pub unsafe extern "C" fn dp(
    mut z: *mut K,
    mut f: Option::<unsafe extern "C" fn(K, K) -> K>,
    mut x___0: K,
    mut y: K,
) -> K {
    let mut tmp: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: *mut k0 = 0 as *mut k0;
    x___0 = promote(x___0);
    y = promote(y);
    tmp = OOM_CD(0 as libc::c_int as I, x___0, y, *z, -(1 as libc::c_int) as V);
    if tmp == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = (**z).n;
    while i < _i___0 {
        tmp___0 = (Some(f.expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            *((*x___0).k).as_mut_ptr().offset((i % (*x___0).n) as isize),
            *((*y).k).as_mut_ptr().offset((i % (*y).n) as isize),
        );
        let ref mut fresh275 = *((**z).k).as_mut_ptr().offset(i as isize);
        *fresh275 = tmp___0;
        if tmp___0.is_null() {
            cd(*z);
            *z = kerr(b"type\0" as *const u8 as *const libc::c_char);
            break;
        } else {
            i += 1;
        }
    }
    cd(x___0);
    cd(y);
    return 0 as K;
}
pub unsafe extern "C" fn equals(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut AT: I = 0;
    let mut tmp___0: I = 0;
    let mut BT: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut zn: I = 0;
    let mut tmp___8: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___13: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___15: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___17: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___19: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___21: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___23: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___25: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___27: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut i___11: I = 0;
    let mut _i___12: I = 0;
    let mut i___12: I = 0;
    let mut _i___13: I = 0;
    let mut i___13: I = 0;
    let mut _i___14: I = 0;
    let mut i___14: I = 0;
    let mut _i___15: I = 0;
    let mut i___15: I = 0;
    let mut _i___16: I = 0;
    let mut i___16: I = 0;
    let mut _i___17: I = 0;
    let mut i___17: I = 0;
    let mut _i___18: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    AT = tmp___0;
    if bt < 0 as libc::c_longlong {
        tmp___1 = -bt;
    } else {
        tmp___1 = bt;
    }
    BT = tmp___1;
    if (4 as libc::c_longlong) < AT {
        tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    } else {
        if (4 as libc::c_longlong) < BT {
            tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
    }
    if at___0 != 0 {
        if bt != 0 {
            let mut current_block_41: u64;
            if 2 as libc::c_longlong >= AT {
                if !(2 as libc::c_longlong >= BT) {
                    current_block_41 = 5986670233983901980;
                } else {
                    current_block_41 = 5597585068398118923;
                }
            } else {
                current_block_41 = 5986670233983901980;
            }
            match current_block_41 {
                5986670233983901980 => {
                    let mut current_block_40: u64;
                    if 3 as libc::c_longlong == AT {
                        if !(3 as libc::c_longlong == BT) {
                            current_block_40 = 12930807343001500861;
                        } else {
                            current_block_40 = 12930649117290160518;
                        }
                    } else {
                        current_block_40 = 12930807343001500861;
                    }
                    match current_block_40 {
                        12930807343001500861 => {
                            if 4 as libc::c_longlong == AT {
                                if !(4 as libc::c_longlong == BT) {
                                    tmp___3 = kerr(
                                        b"type\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___3;
                                }
                            } else {
                                tmp___3 = kerr(
                                    b"type\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___3;
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
    }
    if at___0 == 0 {
        tmp___7 = 0 as libc::c_int;
    } else if bt == 0 {
        tmp___7 = 0 as libc::c_int;
    } else {
        if at___0 < bt {
            tmp___6 = at___0;
        } else {
            tmp___6 = bt;
        }
        if tmp___6 < 0 as libc::c_longlong {
            tmp___5 = -(1 as libc::c_int);
        } else {
            tmp___5 = 1 as libc::c_int;
        }
        tmp___7 = tmp___5;
    }
    t = tmp___7 as I;
    if at___0 > 0 as libc::c_longlong {
        tmp___8 = bn;
    } else {
        tmp___8 = an;
    }
    zn = tmp___8;
    tmp___9 = newK(t, zn);
    z = tmp___9;
    let mut current_block_283: u64;
    if 2 as libc::c_longlong == AT {
        if 2 as libc::c_longlong == BT {
            if an == bn {
                i = 0 as libc::c_int as I;
                _i___0 = zn;
                while i < _i___0 {
                    tmp___11 = FC(
                        *(((*a).k).as_mut_ptr() as *mut F).offset(i as isize),
                        *(((*b___1).k).as_mut_ptr() as *mut F).offset(i as isize),
                    );
                    if tmp___11 != 0 {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i as isize) = 0 as libc::c_int as I;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i as isize) = 1 as libc::c_int as I;
                    }
                    i += 1;
                }
            } else if an == 1 as libc::c_longlong {
                i___0 = 0 as libc::c_int as I;
                _i___1 = zn;
                while i___0 < _i___1 {
                    tmp___13 = FC(
                        *(((*a).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize),
                        *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize),
                    );
                    if tmp___13 != 0 {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___0 as isize) = 0 as libc::c_int as I;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___0 as isize) = 1 as libc::c_int as I;
                    }
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = zn;
                while i___1 < _i___2 {
                    tmp___15 = FC(
                        *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                        *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(0 as libc::c_int as isize),
                    );
                    if tmp___15 != 0 {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___1 as isize) = 0 as libc::c_int as I;
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___1 as isize) = 1 as libc::c_int as I;
                    }
                    i___1 += 1;
                }
            }
            i___2 = 0 as libc::c_int as I;
            _i___3 = zn;
            while i___2 < _i___3 {
                if *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize)
                    != *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize)
                {
                    if *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___2 as isize)
                        != *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___2 as isize)
                    {
                        *(((*z).k).as_mut_ptr() as *mut I)
                            .offset(i___2 as isize) = 1 as libc::c_int as I;
                    }
                }
                i___2 += 1;
            }
            current_block_283 = 6852123435203331032;
        } else {
            current_block_283 = 4955655644470574765;
        }
    } else {
        current_block_283 = 4955655644470574765;
    }
    match current_block_283 {
        4955655644470574765 => {
            let mut current_block_282: u64;
            if 2 as libc::c_longlong == AT {
                if 1 as libc::c_longlong == BT {
                    if an == bn {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = zn;
                        while i___3 < _i___4 {
                            tmp___17 = FC_FI(
                                *(((*a).k).as_mut_ptr() as *mut F).offset(i___3 as isize),
                                *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize),
                            );
                            if tmp___17 != 0 {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) = 0 as libc::c_int as I;
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) = 1 as libc::c_int as I;
                            }
                            i___3 += 1;
                        }
                    } else if an == 1 as libc::c_longlong {
                        i___4 = 0 as libc::c_int as I;
                        _i___5 = zn;
                        while i___4 < _i___5 {
                            tmp___19 = FC_FI(
                                *(((*a).k).as_mut_ptr() as *mut F)
                                    .offset(0 as libc::c_int as isize),
                                *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(i___4 as isize),
                            );
                            if tmp___19 != 0 {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___4 as isize) = 0 as libc::c_int as I;
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___4 as isize) = 1 as libc::c_int as I;
                            }
                            i___4 += 1;
                        }
                    } else {
                        i___5 = 0 as libc::c_int as I;
                        _i___6 = zn;
                        while i___5 < _i___6 {
                            tmp___21 = FC_FI(
                                *(((*a).k).as_mut_ptr() as *mut F).offset(i___5 as isize),
                                *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset(0 as libc::c_int as isize),
                            );
                            if tmp___21 != 0 {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___5 as isize) = 0 as libc::c_int as I;
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___5 as isize) = 1 as libc::c_int as I;
                            }
                            i___5 += 1;
                        }
                    }
                    current_block_282 = 4581322941944613656;
                } else {
                    current_block_282 = 7205145972593539127;
                }
            } else {
                current_block_282 = 7205145972593539127;
            }
            match current_block_282 {
                7205145972593539127 => {
                    let mut current_block_281: u64;
                    if 1 as libc::c_longlong == AT {
                        if 2 as libc::c_longlong == BT {
                            if an == bn {
                                i___6 = 0 as libc::c_int as I;
                                _i___7 = zn;
                                while i___6 < _i___7 {
                                    tmp___23 = FC_IF(
                                        *(((*a).k).as_mut_ptr() as *mut I).offset(i___6 as isize),
                                        *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___6 as isize),
                                    );
                                    if tmp___23 != 0 {
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___6 as isize) = 0 as libc::c_int as I;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___6 as isize) = 1 as libc::c_int as I;
                                    }
                                    i___6 += 1;
                                }
                            } else if an == 1 as libc::c_longlong {
                                i___7 = 0 as libc::c_int as I;
                                _i___8 = zn;
                                while i___7 < _i___8 {
                                    tmp___25 = FC_IF(
                                        *(((*a).k).as_mut_ptr() as *mut I)
                                            .offset(0 as libc::c_int as isize),
                                        *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(i___7 as isize),
                                    );
                                    if tmp___25 != 0 {
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___7 as isize) = 0 as libc::c_int as I;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___7 as isize) = 1 as libc::c_int as I;
                                    }
                                    i___7 += 1;
                                }
                            } else {
                                i___8 = 0 as libc::c_int as I;
                                _i___9 = zn;
                                while i___8 < _i___9 {
                                    tmp___27 = FC_IF(
                                        *(((*a).k).as_mut_ptr() as *mut I).offset(i___8 as isize),
                                        *(((*b___1).k).as_mut_ptr() as *mut F)
                                            .offset(0 as libc::c_int as isize),
                                    );
                                    if tmp___27 != 0 {
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___8 as isize) = 0 as libc::c_int as I;
                                    } else {
                                        *(((*z).k).as_mut_ptr() as *mut I)
                                            .offset(i___8 as isize) = 1 as libc::c_int as I;
                                    }
                                    i___8 += 1;
                                }
                            }
                            current_block_281 = 10443764932861198466;
                        } else {
                            current_block_281 = 17655181693967542734;
                        }
                    } else {
                        current_block_281 = 17655181693967542734;
                    }
                    match current_block_281 {
                        17655181693967542734 => {
                            let mut current_block_280: u64;
                            if 1 as libc::c_longlong == AT {
                                if 1 as libc::c_longlong == BT {
                                    if an == bn {
                                        i___9 = 0 as libc::c_int as I;
                                        _i___10 = zn;
                                        while i___9 < _i___10 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___9 as isize,
                                                ) = (*(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___9 as isize)
                                                == *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize)) as libc::c_int as I;
                                            i___9 += 1;
                                        }
                                    } else if an == 1 as libc::c_longlong {
                                        i___10 = 0 as libc::c_int as I;
                                        _i___11 = zn;
                                        while i___10 < _i___11 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___10 as isize,
                                                ) = (*(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize)
                                                == *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(i___10 as isize)) as libc::c_int as I;
                                            i___10 += 1;
                                        }
                                    } else {
                                        i___11 = 0 as libc::c_int as I;
                                        _i___12 = zn;
                                        while i___11 < _i___12 {
                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                .offset(
                                                    i___11 as isize,
                                                ) = (*(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(i___11 as isize)
                                                == *(((*b___1).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize)) as libc::c_int as I;
                                            i___11 += 1;
                                        }
                                    }
                                    current_block_280 = 3760002206039831082;
                                } else {
                                    current_block_280 = 3586440712436119613;
                                }
                            } else {
                                current_block_280 = 3586440712436119613;
                            }
                            match current_block_280 {
                                3586440712436119613 => {
                                    let mut current_block_279: u64;
                                    if 3 as libc::c_longlong == AT {
                                        if 3 as libc::c_longlong == BT {
                                            if an == bn {
                                                i___12 = 0 as libc::c_int as I;
                                                _i___13 = zn;
                                                while i___12 < _i___13 {
                                                    *(((*z).k).as_mut_ptr() as *mut I)
                                                        .offset(
                                                            i___12 as isize,
                                                        ) = (*(((*a).k).as_mut_ptr() as *mut C)
                                                        .offset(i___12 as isize) as libc::c_int
                                                        == *(((*b___1).k).as_mut_ptr() as *mut C)
                                                            .offset(i___12 as isize) as libc::c_int) as libc::c_int
                                                        as I;
                                                    i___12 += 1;
                                                }
                                            } else if an == 1 as libc::c_longlong {
                                                i___13 = 0 as libc::c_int as I;
                                                _i___14 = zn;
                                                while i___13 < _i___14 {
                                                    *(((*z).k).as_mut_ptr() as *mut I)
                                                        .offset(
                                                            i___13 as isize,
                                                        ) = (*(((*a).k).as_mut_ptr() as *mut C)
                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                        == *(((*b___1).k).as_mut_ptr() as *mut C)
                                                            .offset(i___13 as isize) as libc::c_int) as libc::c_int
                                                        as I;
                                                    i___13 += 1;
                                                }
                                            } else {
                                                i___14 = 0 as libc::c_int as I;
                                                _i___15 = zn;
                                                while i___14 < _i___15 {
                                                    *(((*z).k).as_mut_ptr() as *mut I)
                                                        .offset(
                                                            i___14 as isize,
                                                        ) = (*(((*a).k).as_mut_ptr() as *mut C)
                                                        .offset(i___14 as isize) as libc::c_int
                                                        == *(((*b___1).k).as_mut_ptr() as *mut C)
                                                            .offset(0 as libc::c_int as isize) as libc::c_int)
                                                        as libc::c_int as I;
                                                    i___14 += 1;
                                                }
                                            }
                                            current_block_279 = 6531417090144833949;
                                        } else {
                                            current_block_279 = 14607242750406542793;
                                        }
                                    } else {
                                        current_block_279 = 14607242750406542793;
                                    }
                                    match current_block_279 {
                                        14607242750406542793 => {
                                            let mut current_block_278: u64;
                                            if 4 as libc::c_longlong == AT {
                                                if 4 as libc::c_longlong == BT {
                                                    if an == bn {
                                                        i___15 = 0 as libc::c_int as I;
                                                        _i___16 = zn;
                                                        while i___15 < _i___16 {
                                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                                .offset(
                                                                    i___15 as isize,
                                                                ) = (*(((*a).k).as_mut_ptr() as *mut S)
                                                                .offset(i___15 as isize) as libc::c_ulong
                                                                == *(((*b___1).k).as_mut_ptr() as *mut S)
                                                                    .offset(i___15 as isize) as libc::c_ulong) as libc::c_int
                                                                as I;
                                                            i___15 += 1;
                                                        }
                                                    } else if an == 1 as libc::c_longlong {
                                                        i___16 = 0 as libc::c_int as I;
                                                        _i___17 = zn;
                                                        while i___16 < _i___17 {
                                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                                .offset(
                                                                    i___16 as isize,
                                                                ) = (*(((*a).k).as_mut_ptr() as *mut S)
                                                                .offset(0 as libc::c_int as isize) as libc::c_ulong
                                                                == *(((*b___1).k).as_mut_ptr() as *mut S)
                                                                    .offset(i___16 as isize) as libc::c_ulong) as libc::c_int
                                                                as I;
                                                            i___16 += 1;
                                                        }
                                                    } else {
                                                        i___17 = 0 as libc::c_int as I;
                                                        _i___18 = zn;
                                                        while i___17 < _i___18 {
                                                            *(((*z).k).as_mut_ptr() as *mut I)
                                                                .offset(
                                                                    i___17 as isize,
                                                                ) = (*(((*a).k).as_mut_ptr() as *mut S)
                                                                .offset(i___17 as isize) as libc::c_ulong
                                                                == *(((*b___1).k).as_mut_ptr() as *mut S)
                                                                    .offset(0 as libc::c_int as isize) as libc::c_ulong)
                                                                as libc::c_int as I;
                                                            i___17 += 1;
                                                        }
                                                    }
                                                    current_block_278 = 15319172335895842423;
                                                } else {
                                                    current_block_278 = 11593350440981446443;
                                                }
                                            } else {
                                                current_block_278 = 11593350440981446443;
                                            }
                                            match current_block_278 {
                                                11593350440981446443 => {
                                                    if 0 as libc::c_longlong == at___0 {
                                                        dp(
                                                            &mut z,
                                                            Some(equals as unsafe extern "C" fn(K, K) -> K),
                                                            a,
                                                            b___1,
                                                        );
                                                    } else if 0 as libc::c_longlong == bt {
                                                        dp(
                                                            &mut z,
                                                            Some(equals as unsafe extern "C" fn(K, K) -> K),
                                                            a,
                                                            b___1,
                                                        );
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn matchI(mut a: K, mut b___1: K) -> I {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut AT: I = 0;
    let mut tmp: I = 0;
    let mut BT: I = 0;
    let mut tmp___0: I = 0;
    let mut c: *mut K = 0 as *mut K;
    let mut d___0: *mut K = 0 as *mut K;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___1: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___2: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    if a.is_null() {
        return 0 as libc::c_int as I
    } else {
        if b___1.is_null() {
            return 0 as libc::c_int as I;
        }
    }
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp = -at___0;
    } else {
        tmp = at___0;
    }
    AT = tmp;
    if bt < 0 as libc::c_longlong {
        tmp___0 = -bt;
    } else {
        tmp___0 = bt;
    }
    BT = tmp___0;
    if an != bn {
        return 0 as libc::c_int as I
    } else {
        if at___0 != bt {
            return 0 as libc::c_int as I;
        }
    }
    if 4 as libc::c_longlong == AT {
        i = 0 as libc::c_int as I;
        _i___0 = an;
        while i < _i___0 {
            if *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize) as libc::c_ulong
                != *(((*b___1).k).as_mut_ptr() as *mut S).offset(i as isize)
                    as libc::c_ulong
            {
                return 0 as libc::c_int as I;
            }
            i += 1;
        }
    }
    if 3 as libc::c_longlong == AT {
        i___0 = 0 as libc::c_int as I;
        _i___1 = an;
        while i___0 < _i___1 {
            if *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize) as libc::c_int
                != *(((*b___1).k).as_mut_ptr() as *mut C).offset(i___0 as isize)
                    as libc::c_int
            {
                return 0 as libc::c_int as I;
            }
            i___0 += 1;
        }
    }
    if 2 as libc::c_longlong == AT {
        if 2 as libc::c_longlong == BT {
            i___1 = 0 as libc::c_int as I;
            _i___2 = an;
            while i___1 < _i___2 {
                tmp___1 = FC(
                    *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                    *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                );
                if tmp___1 != 0 {
                    return 0 as libc::c_int as I;
                }
                i___1 += 1;
            }
        }
    }
    if 1 as libc::c_longlong == AT {
        if 1 as libc::c_longlong == BT {
            i___2 = 0 as libc::c_int as I;
            _i___3 = an;
            while i___2 < _i___3 {
                if *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize)
                    != *(((*b___1).k).as_mut_ptr() as *mut I).offset(i___2 as isize)
                {
                    return 0 as libc::c_int as I;
                }
                i___2 += 1;
            }
        }
    }
    let mut current_block_81: u64;
    if 0 as libc::c_longlong == AT {
        current_block_81 = 13938994264752010076;
    } else if 5 as libc::c_longlong == AT {
        current_block_81 = 13938994264752010076;
    } else {
        current_block_81 = 3736434875406665187;
    }
    match current_block_81 {
        13938994264752010076 => {
            i___3 = 0 as libc::c_int as I;
            _i___4 = an;
            while i___3 < _i___4 {
                tmp___2 = matchI(
                    *((*a).k).as_mut_ptr().offset(i___3 as isize),
                    *((*b___1).k).as_mut_ptr().offset(i___3 as isize),
                );
                if tmp___2 == 0 {
                    return 0 as libc::c_int as I;
                }
                i___3 += 1;
            }
        }
        _ => {}
    }
    if 7 as libc::c_longlong == AT {
        if (*a).n != (*b___1).n {
            return 0 as libc::c_int as I;
        }
        match (*a).n {
            1 => {
                an = (*(*(((*a).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .n - 1 as libc::c_longlong;
                bn = (*(*(((*b___1).k).as_mut_ptr() as *mut V)
                    .offset(2 as libc::c_int as isize) as K))
                    .n - 1 as libc::c_longlong;
                if an != bn {
                    return 0 as libc::c_int as I;
                }
                i___4 = 0 as libc::c_int as I;
                _i___5 = an;
                while i___4 < _i___5 {
                    c = *(((*(*(((*a).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut S as *mut V)
                        .offset(i___4 as isize) as *mut K;
                    d___0 = *(((*(*(((*b___1).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K))
                        .k)
                        .as_mut_ptr() as *mut S as *mut V)
                        .offset(i___4 as isize) as *mut K;
                    tmp___4 = VA(c as V);
                    let mut current_block_104: u64;
                    if tmp___4 != 0 {
                        current_block_104 = 728155957759596255;
                    } else {
                        tmp___5 = VA(d___0 as V);
                        if tmp___5 != 0 {
                            current_block_104 = 728155957759596255;
                        } else {
                            tmp___3 = matchI(*c, *d___0);
                            if tmp___3 == 0 {
                                return 0 as libc::c_int as I;
                            }
                            current_block_104 = 6406431739208918833;
                        }
                    }
                    match current_block_104 {
                        728155957759596255 => {
                            if c as libc::c_ulong != d___0 as libc::c_ulong {
                                return 0 as libc::c_int as I;
                            }
                        }
                        _ => {}
                    }
                    i___4 += 1;
                }
            }
            3 => {
                if *(((*a).k).as_mut_ptr() as *mut V).offset(0 as libc::c_int as isize)
                    as libc::c_ulong
                    != *(((*b___1).k).as_mut_ptr() as *mut V)
                        .offset(0 as libc::c_int as isize) as libc::c_ulong
                {
                    return 0 as libc::c_int as I;
                }
                tmp___6 = matchI(
                    *(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
                        as K,
                    *(((*b___1).k).as_mut_ptr() as *mut V)
                        .offset(2 as libc::c_int as isize) as K,
                );
                return tmp___6;
            }
            2 | _ => {}
        }
    }
    return 1 as libc::c_int as I;
}
pub unsafe extern "C" fn match_0(mut a: K, mut b___1: K) -> K {
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = matchI(a, b___1);
    tmp___0 = Ki(tmp);
    return tmp___0;
}
unsafe extern "C" fn lessmore(mut a: K, mut b___1: K, mut x___0: I) -> K {
    let mut c: K = 0 as *mut k0;
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut AT: I = 0;
    let mut tmp___0: I = 0;
    let mut BT: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut t: I = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut zn: I = 0;
    let mut tmp___8: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut h: *mut I = 0 as *mut I;
    let mut tmp___10: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___11: *mut k0 = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___12: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___13: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___14: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___15: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___16: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___17: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut tmp___18: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut tmp___19: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___20: I = 0;
    let mut i___9: I = 0;
    let mut _i___10: I = 0;
    let mut i___10: I = 0;
    let mut _i___11: I = 0;
    let mut i___11: I = 0;
    let mut _i___12: I = 0;
    let mut i___12: I = 0;
    let mut _i___13: I = 0;
    let mut i___13: I = 0;
    let mut _i___14: I = 0;
    let mut i___14: I = 0;
    let mut _i___15: I = 0;
    let mut i___15: I = 0;
    let mut _i___16: I = 0;
    let mut tmp___21: I = 0;
    let mut i___16: I = 0;
    let mut _i___17: I = 0;
    let mut tmp___22: I = 0;
    let mut i___17: I = 0;
    let mut _i___18: I = 0;
    let mut tmp___23: I = 0;
    if x___0 == 0 {
        if 0 as libc::c_longlong != (*b___1).t {
            c = a;
            a = b___1;
            b___1 = c;
        }
    }
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 <= 0 as libc::c_longlong {
        if bt <= 0 as libc::c_longlong {
            if an != bn {
                tmp = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    AT = tmp___0;
    if bt < 0 as libc::c_longlong {
        tmp___1 = -bt;
    } else {
        tmp___1 = bt;
    }
    BT = tmp___1;
    if (4 as libc::c_longlong) < AT {
        tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp___2;
    } else {
        if (4 as libc::c_longlong) < BT {
            tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
    }
    if at___0 != 0 {
        if bt != 0 {
            let mut current_block_48: u64;
            if 2 as libc::c_longlong >= AT {
                if !(2 as libc::c_longlong >= BT) {
                    current_block_48 = 7612609690571643136;
                } else {
                    current_block_48 = 14298507163138330979;
                }
            } else {
                current_block_48 = 7612609690571643136;
            }
            match current_block_48 {
                7612609690571643136 => {
                    let mut current_block_47: u64;
                    if 3 as libc::c_longlong == AT {
                        if !(3 as libc::c_longlong == BT) {
                            current_block_47 = 734232951738642529;
                        } else {
                            current_block_47 = 13853033528615664019;
                        }
                    } else {
                        current_block_47 = 734232951738642529;
                    }
                    match current_block_47 {
                        734232951738642529 => {
                            if 4 as libc::c_longlong == AT {
                                if !(4 as libc::c_longlong == BT) {
                                    tmp___3 = kerr(
                                        b"type\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___3;
                                }
                            } else {
                                tmp___3 = kerr(
                                    b"type\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___3;
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
    }
    if at___0 == 0 {
        tmp___7 = 0 as libc::c_int;
    } else if bt == 0 {
        tmp___7 = 0 as libc::c_int;
    } else {
        if at___0 < bt {
            tmp___6 = at___0;
        } else {
            tmp___6 = bt;
        }
        if tmp___6 < 0 as libc::c_longlong {
            tmp___5 = -(1 as libc::c_int);
        } else {
            tmp___5 = 1 as libc::c_int;
        }
        tmp___7 = tmp___5;
    }
    t = tmp___7 as I;
    if at___0 > 0 as libc::c_longlong {
        tmp___8 = bn;
    } else {
        tmp___8 = an;
    }
    zn = tmp___8;
    tmp___9 = newK(t, zn);
    z = tmp___9;
    if z.is_null() {
        return 0 as K;
    }
    h = ((*z).k).as_mut_ptr() as *mut I;
    let mut current_block_264: u64;
    if 0 as libc::c_longlong == at___0 {
        current_block_264 = 4349655192739211304;
    } else if 0 as libc::c_longlong == bt {
        current_block_264 = 4349655192739211304;
    } else {
        let mut current_block_263: u64;
        if 2 as libc::c_longlong == AT {
            if 2 as libc::c_longlong == BT {
                if an == bn {
                    i___0 = 0 as libc::c_int as I;
                    _i___1 = zn;
                    while i___0 < _i___1 {
                        tmp___12 = FC(
                            *(((*a).k).as_mut_ptr() as *mut F).offset(i___0 as isize),
                            *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___0 as isize),
                        );
                        *h
                            .offset(
                                i___0 as isize,
                            ) = (tmp___12 > 0 as libc::c_longlong) as libc::c_int as I;
                        i___0 += 1;
                    }
                } else if an == 1 as libc::c_longlong {
                    i___1 = 0 as libc::c_int as I;
                    _i___2 = zn;
                    while i___1 < _i___2 {
                        tmp___13 = FC(
                            *(((*a).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize),
                            *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                        );
                        *h
                            .offset(
                                i___1 as isize,
                            ) = (tmp___13 > 0 as libc::c_longlong) as libc::c_int as I;
                        i___1 += 1;
                    }
                } else {
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = zn;
                    while i___2 < _i___3 {
                        tmp___14 = FC(
                            *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize),
                            *(((*b___1).k).as_mut_ptr() as *mut F)
                                .offset(0 as libc::c_int as isize),
                        );
                        *h
                            .offset(
                                i___2 as isize,
                            ) = (tmp___14 > 0 as libc::c_longlong) as libc::c_int as I;
                        i___2 += 1;
                    }
                }
                current_block_263 = 6838189980997685602;
            } else {
                current_block_263 = 17909936098517472586;
            }
        } else {
            current_block_263 = 17909936098517472586;
        }
        match current_block_263 {
            17909936098517472586 => {
                let mut current_block_262: u64;
                if 2 as libc::c_longlong == AT {
                    if 1 as libc::c_longlong == BT {
                        if an == bn {
                            i___3 = 0 as libc::c_int as I;
                            _i___4 = zn;
                            while i___3 < _i___4 {
                                tmp___15 = FC_FI(
                                    *(((*a).k).as_mut_ptr() as *mut F).offset(i___3 as isize),
                                    *(((*b___1).k).as_mut_ptr() as *mut I)
                                        .offset(i___3 as isize),
                                );
                                *h
                                    .offset(
                                        i___3 as isize,
                                    ) = (tmp___15 > 0 as libc::c_longlong) as libc::c_int as I;
                                i___3 += 1;
                            }
                        } else if an == 1 as libc::c_longlong {
                            i___4 = 0 as libc::c_int as I;
                            _i___5 = zn;
                            while i___4 < _i___5 {
                                tmp___16 = FC_FI(
                                    *(((*a).k).as_mut_ptr() as *mut F)
                                        .offset(0 as libc::c_int as isize),
                                    *(((*b___1).k).as_mut_ptr() as *mut I)
                                        .offset(i___4 as isize),
                                );
                                *h
                                    .offset(
                                        i___4 as isize,
                                    ) = (tmp___16 > 0 as libc::c_longlong) as libc::c_int as I;
                                i___4 += 1;
                            }
                        } else {
                            i___5 = 0 as libc::c_int as I;
                            _i___6 = zn;
                            while i___5 < _i___6 {
                                tmp___17 = FC_FI(
                                    *(((*a).k).as_mut_ptr() as *mut F).offset(i___5 as isize),
                                    *(((*b___1).k).as_mut_ptr() as *mut I)
                                        .offset(0 as libc::c_int as isize),
                                );
                                *h
                                    .offset(
                                        i___5 as isize,
                                    ) = (tmp___17 > 0 as libc::c_longlong) as libc::c_int as I;
                                i___5 += 1;
                            }
                        }
                        current_block_262 = 10405964186021900795;
                    } else {
                        current_block_262 = 14144948481983164949;
                    }
                } else {
                    current_block_262 = 14144948481983164949;
                }
                match current_block_262 {
                    14144948481983164949 => {
                        let mut current_block_261: u64;
                        if 1 as libc::c_longlong == AT {
                            if 2 as libc::c_longlong == BT {
                                if an == bn {
                                    i___6 = 0 as libc::c_int as I;
                                    _i___7 = zn;
                                    while i___6 < _i___7 {
                                        tmp___18 = FC_IF(
                                            *(((*a).k).as_mut_ptr() as *mut I).offset(i___6 as isize),
                                            *(((*b___1).k).as_mut_ptr() as *mut F)
                                                .offset(i___6 as isize),
                                        );
                                        *h
                                            .offset(
                                                i___6 as isize,
                                            ) = (tmp___18 > 0 as libc::c_longlong) as libc::c_int as I;
                                        i___6 += 1;
                                    }
                                } else if an == 1 as libc::c_longlong {
                                    i___7 = 0 as libc::c_int as I;
                                    _i___8 = zn;
                                    while i___7 < _i___8 {
                                        tmp___19 = FC_IF(
                                            *(((*a).k).as_mut_ptr() as *mut I)
                                                .offset(0 as libc::c_int as isize),
                                            *(((*b___1).k).as_mut_ptr() as *mut F)
                                                .offset(i___7 as isize),
                                        );
                                        *h
                                            .offset(
                                                i___7 as isize,
                                            ) = (tmp___19 > 0 as libc::c_longlong) as libc::c_int as I;
                                        i___7 += 1;
                                    }
                                } else {
                                    i___8 = 0 as libc::c_int as I;
                                    _i___9 = zn;
                                    while i___8 < _i___9 {
                                        tmp___20 = FC_IF(
                                            *(((*a).k).as_mut_ptr() as *mut I).offset(i___8 as isize),
                                            *(((*b___1).k).as_mut_ptr() as *mut F)
                                                .offset(0 as libc::c_int as isize),
                                        );
                                        *h
                                            .offset(
                                                i___8 as isize,
                                            ) = (tmp___20 > 0 as libc::c_longlong) as libc::c_int as I;
                                        i___8 += 1;
                                    }
                                }
                                current_block_261 = 11573789974424595537;
                            } else {
                                current_block_261 = 10356444912033133773;
                            }
                        } else {
                            current_block_261 = 10356444912033133773;
                        }
                        match current_block_261 {
                            10356444912033133773 => {
                                let mut current_block_260: u64;
                                if 1 as libc::c_longlong == AT {
                                    if 1 as libc::c_longlong == BT {
                                        if an == bn {
                                            i___9 = 0 as libc::c_int as I;
                                            _i___10 = zn;
                                            while i___9 < _i___10 {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___9 as isize,
                                                    ) = (*(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(i___9 as isize)
                                                    > *(((*b___1).k).as_mut_ptr() as *mut I)
                                                        .offset(i___9 as isize)) as libc::c_int as I;
                                                i___9 += 1;
                                            }
                                        } else if an == 1 as libc::c_longlong {
                                            i___10 = 0 as libc::c_int as I;
                                            _i___11 = zn;
                                            while i___10 < _i___11 {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___10 as isize,
                                                    ) = (*(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(0 as libc::c_int as isize)
                                                    > *(((*b___1).k).as_mut_ptr() as *mut I)
                                                        .offset(i___10 as isize)) as libc::c_int as I;
                                                i___10 += 1;
                                            }
                                        } else {
                                            i___11 = 0 as libc::c_int as I;
                                            _i___12 = zn;
                                            while i___11 < _i___12 {
                                                *(((*z).k).as_mut_ptr() as *mut I)
                                                    .offset(
                                                        i___11 as isize,
                                                    ) = (*(((*a).k).as_mut_ptr() as *mut I)
                                                    .offset(i___11 as isize)
                                                    > *(((*b___1).k).as_mut_ptr() as *mut I)
                                                        .offset(0 as libc::c_int as isize)) as libc::c_int as I;
                                                i___11 += 1;
                                            }
                                        }
                                        current_block_260 = 13095187161273680990;
                                    } else {
                                        current_block_260 = 7896943273135362296;
                                    }
                                } else {
                                    current_block_260 = 7896943273135362296;
                                }
                                match current_block_260 {
                                    7896943273135362296 => {
                                        let mut current_block_259: u64;
                                        if 3 as libc::c_longlong == AT {
                                            if 3 as libc::c_longlong == BT {
                                                if an == bn {
                                                    i___12 = 0 as libc::c_int as I;
                                                    _i___13 = zn;
                                                    while i___12 < _i___13 {
                                                        *(((*z).k).as_mut_ptr() as *mut I)
                                                            .offset(
                                                                i___12 as isize,
                                                            ) = (*(((*a).k).as_mut_ptr() as *mut C)
                                                            .offset(i___12 as isize) as libc::c_int
                                                            > *(((*b___1).k).as_mut_ptr() as *mut C)
                                                                .offset(i___12 as isize) as libc::c_int) as libc::c_int
                                                            as I;
                                                        i___12 += 1;
                                                    }
                                                } else if an == 1 as libc::c_longlong {
                                                    i___13 = 0 as libc::c_int as I;
                                                    _i___14 = zn;
                                                    while i___13 < _i___14 {
                                                        *(((*z).k).as_mut_ptr() as *mut I)
                                                            .offset(
                                                                i___13 as isize,
                                                            ) = (*(((*a).k).as_mut_ptr() as *mut C)
                                                            .offset(0 as libc::c_int as isize) as libc::c_int
                                                            > *(((*b___1).k).as_mut_ptr() as *mut C)
                                                                .offset(i___13 as isize) as libc::c_int) as libc::c_int
                                                            as I;
                                                        i___13 += 1;
                                                    }
                                                } else {
                                                    i___14 = 0 as libc::c_int as I;
                                                    _i___15 = zn;
                                                    while i___14 < _i___15 {
                                                        *(((*z).k).as_mut_ptr() as *mut I)
                                                            .offset(
                                                                i___14 as isize,
                                                            ) = (*(((*a).k).as_mut_ptr() as *mut C)
                                                            .offset(i___14 as isize) as libc::c_int
                                                            > *(((*b___1).k).as_mut_ptr() as *mut C)
                                                                .offset(0 as libc::c_int as isize) as libc::c_int)
                                                            as libc::c_int as I;
                                                        i___14 += 1;
                                                    }
                                                }
                                                current_block_259 = 6813271534392596583;
                                            } else {
                                                current_block_259 = 3485561062752892245;
                                            }
                                        } else {
                                            current_block_259 = 3485561062752892245;
                                        }
                                        match current_block_259 {
                                            3485561062752892245 => {
                                                if 4 as libc::c_longlong == AT {
                                                    if 4 as libc::c_longlong == BT {
                                                        if an == bn {
                                                            i___15 = 0 as libc::c_int as I;
                                                            _i___16 = zn;
                                                            while i___15 < _i___16 {
                                                                tmp___21 = SC(
                                                                    *(((*a).k).as_mut_ptr() as *mut S).offset(i___15 as isize),
                                                                    *(((*b___1).k).as_mut_ptr() as *mut S)
                                                                        .offset(i___15 as isize),
                                                                );
                                                                *h
                                                                    .offset(
                                                                        i___15 as isize,
                                                                    ) = (tmp___21 > 0 as libc::c_longlong) as libc::c_int as I;
                                                                i___15 += 1;
                                                            }
                                                        } else if an == 1 as libc::c_longlong {
                                                            i___16 = 0 as libc::c_int as I;
                                                            _i___17 = zn;
                                                            while i___16 < _i___17 {
                                                                tmp___22 = SC(
                                                                    *(((*a).k).as_mut_ptr() as *mut S)
                                                                        .offset(0 as libc::c_int as isize),
                                                                    *(((*b___1).k).as_mut_ptr() as *mut S)
                                                                        .offset(i___16 as isize),
                                                                );
                                                                *h
                                                                    .offset(
                                                                        i___16 as isize,
                                                                    ) = (tmp___22 > 0 as libc::c_longlong) as libc::c_int as I;
                                                                i___16 += 1;
                                                            }
                                                        } else {
                                                            i___17 = 0 as libc::c_int as I;
                                                            _i___18 = zn;
                                                            while i___17 < _i___18 {
                                                                tmp___23 = SC(
                                                                    *(((*a).k).as_mut_ptr() as *mut S).offset(i___17 as isize),
                                                                    *(((*b___1).k).as_mut_ptr() as *mut S)
                                                                        .offset(0 as libc::c_int as isize),
                                                                );
                                                                *h
                                                                    .offset(
                                                                        i___17 as isize,
                                                                    ) = (tmp___23 > 0 as libc::c_longlong) as libc::c_int as I;
                                                                i___17 += 1;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        current_block_264 = 9957735944531162038;
    }
    match current_block_264 {
        4349655192739211304 => {
            a = promote(a);
            b___1 = promote(b___1);
            tmp___10 = OOM_CD(
                0 as libc::c_int as I,
                a,
                b___1,
                z,
                -(1 as libc::c_int) as V,
            );
            if tmp___10 == 0 {
                return 0 as K;
            }
            i = 0 as libc::c_int as I;
            _i___0 = zn;
            while i < _i___0 {
                tmp___11 = lessmore(
                    *((*a).k).as_mut_ptr().offset((i % an) as isize),
                    *((*b___1).k).as_mut_ptr().offset((i % (*b___1).n) as isize),
                    x___0,
                );
                let ref mut fresh276 = *((*z).k).as_mut_ptr().offset(i as isize);
                *fresh276 = tmp___11;
                if tmp___11.is_null() {
                    cd(z);
                    z = kerr(b"wsfull\0" as *const u8 as *const libc::c_char);
                    break;
                } else {
                    i += 1;
                }
            }
            cd(a);
            cd(b___1);
        }
        _ => {}
    }
    return z;
}
pub unsafe extern "C" fn less(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = lessmore(a, b___1, 0 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn more(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = lessmore(a, b___1, 1 as libc::c_int as I);
    return tmp;
}
unsafe extern "C" fn of2(mut d___0: K, mut x___0: *mut K, mut y: *mut K, mut s: I) -> K {
    let mut f: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut dt: I = 0;
    let mut dn: I = 0;
    let mut ft: I = 0;
    let mut fn_0: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___1: *mut k0 = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut k: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___5: *mut k0 = 0 as *mut k0;
    let mut tmp___6: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___9: *mut k0 = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___12: *mut k0 = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___14: *mut k0 = 0 as *mut k0;
    let mut tmp___15: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut tmp___18: I = 0;
    let mut tmp___19: I = 0;
    f = *x___0;
    if f.is_null() {
        tmp = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    dt = (*d___0).t;
    dn = (*d___0).n;
    ft = (*f).t;
    fn_0 = (*f).n;
    if 0 as libc::c_longlong >= s {
        tmp___0 = at_verb(d___0, f);
        return tmp___0;
    }
    if 0 as libc::c_longlong == ft {
        z = newK(0 as libc::c_int as I, fn_0);
        if z.is_null() {
            return 0 as K;
        }
        i = 0 as libc::c_int as I;
        _i___0 = fn_0;
        while i < _i___0 {
            tmp___1 = of2(d___0, &mut *((*f).k).as_mut_ptr().offset(i as isize), y, s);
            let ref mut fresh277 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh277 = tmp___1;
            tmp___2 = OOM_CD(
                0 as libc::c_int as I,
                z,
                tmp___1,
                -(1 as libc::c_int) as V,
            );
            if tmp___2 == 0 {
                return 0 as K;
            }
            i += 1;
        }
    } else {
        if ft < 0 as libc::c_longlong {
            tmp___19 = -ft;
        } else {
            tmp___19 = ft;
        }
        if 1 as libc::c_longlong == tmp___19 {
            if dt != 0 as libc::c_longlong {
                return 0 as K;
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = fn_0;
            while i___0 < _i___1 {
                k = *(((*f).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
                if k < 0 as libc::c_longlong {
                    tmp___3 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                    return tmp___3;
                } else {
                    if k >= dn {
                        tmp___3 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                        return tmp___3;
                    }
                }
                i___0 += 1;
            }
            if 1 as libc::c_longlong == ft {
                tmp___4 = of2(
                    *((*d___0).k)
                        .as_mut_ptr()
                        .offset(*(((*f).k).as_mut_ptr() as *mut I) as isize),
                    y,
                    y.offset(1 as libc::c_int as isize),
                    s - 1 as libc::c_longlong,
                );
                return tmp___4;
            }
            z = newK(0 as libc::c_int as I, fn_0);
            if z.is_null() {
                return 0 as K;
            }
            i___1 = 0 as libc::c_int as I;
            _i___2 = fn_0;
            while i___1 < _i___2 {
                tmp___5 = of2(
                    *((*d___0).k)
                        .as_mut_ptr()
                        .offset(
                            *(((*f).k).as_mut_ptr() as *mut I).offset(i___1 as isize)
                                as isize,
                        ),
                    y,
                    y.offset(1 as libc::c_int as isize),
                    s - 1 as libc::c_longlong,
                );
                let ref mut fresh278 = *((*z).k).as_mut_ptr().offset(i___1 as isize);
                *fresh278 = tmp___5;
                tmp___6 = OOM_CD(
                    0 as libc::c_int as I,
                    z,
                    tmp___5,
                    -(1 as libc::c_int) as V,
                );
                if tmp___6 == 0 {
                    return 0 as K;
                }
                i___1 += 1;
            }
        } else {
            if ft < 0 as libc::c_longlong {
                tmp___18 = -ft;
            } else {
                tmp___18 = ft;
            }
            if 4 as libc::c_longlong == tmp___18 {
                if dt != 5 as libc::c_longlong {
                    return 0 as K;
                }
                if 4 as libc::c_longlong == ft {
                    tmp___7 = lookup(d___0, *(((*f).k).as_mut_ptr() as *mut S));
                    tmp___8 = of2(
                        tmp___7,
                        y,
                        y.offset(1 as libc::c_int as isize),
                        s - 1 as libc::c_longlong,
                    );
                    return tmp___8;
                }
                z = newK(0 as libc::c_int as I, fn_0);
                if z.is_null() {
                    return 0 as K;
                }
                i___2 = 0 as libc::c_int as I;
                _i___3 = fn_0;
                while i___2 < _i___3 {
                    tmp___10 = lookup(
                        d___0,
                        *(((*f).k).as_mut_ptr() as *mut S).offset(i___2 as isize),
                    );
                    tmp___9 = of2(
                        tmp___10,
                        y,
                        y.offset(1 as libc::c_int as isize),
                        s - 1 as libc::c_longlong,
                    );
                    let ref mut fresh279 = *((*z).k).as_mut_ptr().offset(i___2 as isize);
                    *fresh279 = tmp___9;
                    tmp___11 = OOM_CD(
                        0 as libc::c_int as I,
                        z,
                        tmp___9,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___11 == 0 {
                        return 0 as K;
                    }
                    i___2 += 1;
                }
            } else if 6 as libc::c_longlong == ft {
                if 0 as libc::c_longlong == dt {
                    z = newK(0 as libc::c_int as I, dn);
                    if z.is_null() {
                        return 0 as K;
                    }
                    i___3 = 0 as libc::c_int as I;
                    _i___4 = dn;
                    while i___3 < _i___4 {
                        tmp___12 = of2(
                            *((*d___0).k).as_mut_ptr().offset(i___3 as isize),
                            y,
                            y.offset(1 as libc::c_int as isize),
                            s - 1 as libc::c_longlong,
                        );
                        let ref mut fresh280 = *((*z).k)
                            .as_mut_ptr()
                            .offset(i___3 as isize);
                        *fresh280 = tmp___12;
                        tmp___13 = OOM_CD(
                            0 as libc::c_int as I,
                            z,
                            tmp___12,
                            -(1 as libc::c_int) as V,
                        );
                        if tmp___13 == 0 {
                            return 0 as K;
                        }
                        i___3 += 1;
                    }
                } else if 5 as libc::c_longlong == dt {
                    z = newK(0 as libc::c_int as I, dn);
                    if z.is_null() {
                        return 0 as K;
                    }
                    i___4 = 0 as libc::c_int as I;
                    _i___5 = dn;
                    while i___4 < _i___5 {
                        tmp___14 = of2(
                            *((**((*d___0).k).as_mut_ptr().offset(i___4 as isize)).k)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                            y,
                            y.offset(1 as libc::c_int as isize),
                            s - 1 as libc::c_longlong,
                        );
                        let ref mut fresh281 = *((*z).k)
                            .as_mut_ptr()
                            .offset(i___4 as isize);
                        *fresh281 = tmp___14;
                        tmp___15 = OOM_CD(
                            0 as libc::c_int as I,
                            z,
                            tmp___14,
                            -(1 as libc::c_int) as V,
                        );
                        if tmp___15 == 0 {
                            return 0 as K;
                        }
                        i___4 += 1;
                    }
                } else {
                    tmp___16 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
                    return tmp___16;
                }
            } else {
                tmp___17 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp___17;
            }
        }
    }
    if !z.is_null() {
        z = demote(z);
    }
    return z;
}
pub unsafe extern "C" fn of(mut a: K, mut b___1: K) -> K {
    let mut current_block: u64;
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut s: [C; 256] = [0; 256];
    let mut ss: S = 0 as *mut C;
    let mut i: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: size_t = 0;
    let mut aa: *mut K = 0 as *mut K;
    let mut tmp___2: S = 0 as *mut C;
    let mut tmp___3: *mut K = 0 as *mut K;
    let mut f: *mut K = 0 as *mut K;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: *mut K = 0 as *mut K;
    let mut tmp___6: K = 0 as *mut k0;
    let mut s___0: [C; 256] = [0; 256];
    let mut aa___0: *mut K = 0 as *mut K;
    let mut tmp___7: S = 0 as *mut C;
    let mut tmp___8: *mut K = 0 as *mut K;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut tmp___13: I = 0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut f___0: *mut K = 0 as *mut K;
    let mut tmp___15: *mut K = 0 as *mut K;
    let mut k: K = 0 as *mut k0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut f___1: *mut K = 0 as *mut K;
    let mut f___2: K = 0 as *mut k0;
    let mut tmp___17: K = 0 as *mut k0;
    let mut k___0: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: K = 0 as *mut k0;
    let mut tmp___20: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if 0 as libc::c_longlong == (*b___1).t {
        if 0 as libc::c_longlong == (*b___1).n {
            tmp = ci(a);
            return tmp;
        }
    }
    z = 0 as K;
    if at___0 == 4 as libc::c_longlong {
        if bt == 0 as libc::c_longlong {
            strcpy(s.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
            strcat(
                s.as_mut_ptr() as *mut libc::c_char,
                b".\0" as *const u8 as *const libc::c_char,
            );
            strcat(
                s.as_mut_ptr() as *mut libc::c_char,
                *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            ss = *(((*a).k).as_mut_ptr() as *mut S);
            i = 0 as libc::c_int as I;
            loop {
                tmp___1 = strlen(ss as *const libc::c_char);
                if !((i as libc::c_ulonglong) < tmp___1 as libc::c_ulonglong) {
                    break;
                }
                if *ss.offset(i as isize) as libc::c_int == 95 as libc::c_int {
                    tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                    return tmp___0;
                } else {
                    if *ss.offset(i as isize) as libc::c_int == 26 as libc::c_int {
                        tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                        return tmp___0;
                    }
                }
                i += 1;
            }
            tmp___2 = sp(s.as_mut_ptr());
            tmp___3 = denameD(&mut KTREE, tmp___2, 1 as libc::c_int as I);
            aa = tmp___3;
            f = &mut *((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize)
                as *mut *mut k0;
            if 0 as *mut libc::c_void as libc::c_ulong == aa as libc::c_ulong {
                tmp___4 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                return tmp___4;
            }
            if bn > 0 as libc::c_longlong {
                tmp___5 = f.offset(1 as libc::c_int as isize);
            } else {
                tmp___5 = 0 as *mut K;
            }
            tmp___6 = of2(*aa, f, tmp___5, bn - 1 as libc::c_longlong);
            return tmp___6;
        }
    }
    if at___0 == 4 as libc::c_longlong {
        if bt == 1 as libc::c_longlong {
            strcpy(s___0.as_mut_ptr() as *mut libc::c_char, d_ as *const libc::c_char);
            strcat(
                s___0.as_mut_ptr() as *mut libc::c_char,
                b".\0" as *const u8 as *const libc::c_char,
            );
            strcat(
                s___0.as_mut_ptr() as *mut libc::c_char,
                *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            tmp___7 = sp(s___0.as_mut_ptr());
            tmp___8 = denameD(&mut KTREE, tmp___7, 1 as libc::c_int as I);
            aa___0 = tmp___8;
            tmp___9 = of(*aa___0, b___1);
            return tmp___9;
        }
    }
    if (0 as libc::c_longlong) < at___0 {
        if at___0 < 5 as libc::c_longlong {
            if 6 as libc::c_longlong != bt {
                tmp___10 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
                return tmp___10;
            }
        }
    }
    if 6 as libc::c_longlong == at___0 {
        if 1 as libc::c_longlong == bt {
            z = ci(b___1);
        } else {
            if bt < 0 as libc::c_longlong {
                tmp___13 = -bt;
            } else {
                tmp___13 = bt;
            }
            if 4 as libc::c_longlong == tmp___13 {
                z = _n();
            } else {
                let mut current_block_99: u64;
                if 0 as libc::c_longlong == bn {
                    if -(1 as libc::c_longlong) == bt {
                        z = _n();
                        current_block_99 = 1658462350791934405;
                    } else if -(2 as libc::c_longlong) == bt {
                        z = _n();
                        current_block_99 = 1658462350791934405;
                    } else {
                        current_block_99 = 16655594971188650244;
                    }
                } else {
                    current_block_99 = 16655594971188650244;
                }
                match current_block_99 {
                    16655594971188650244 => {
                        let mut current_block_98: u64;
                        if 0 as libc::c_longlong == bt {
                            if 1 as libc::c_longlong == bn {
                                z = ci(
                                    *((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize),
                                );
                                current_block_98 = 13824533195664196414;
                            } else {
                                current_block_98 = 11035213992733724493;
                            }
                        } else {
                            current_block_98 = 11035213992733724493;
                        }
                        match current_block_98 {
                            11035213992733724493 => {
                                if 0 as libc::c_longlong == bt {
                                    tmp___11 = ci(b___1);
                                    z = demote(tmp___11);
                                } else if 6 as libc::c_longlong == bt {
                                    z = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                                } else if -(3 as libc::c_longlong) == bt {
                                    if 0 as libc::c_longlong == bn {
                                        z = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                                    } else {
                                        tmp___12 = kerr(
                                            b"type\0" as *const u8 as *const libc::c_char,
                                        );
                                        return tmp___12;
                                    }
                                } else {
                                    tmp___12 = kerr(
                                        b"type\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___12;
                                }
                            }
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
        }
    } else if 6 as libc::c_longlong == bt {
        if 5 as libc::c_longlong == at___0 {
            z = newK(0 as libc::c_int as I, an);
            i___0 = 0 as libc::c_int as I;
            _i___0 = an;
            while i___0 < _i___0 {
                let ref mut fresh282 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
                *fresh282 = ci(
                    *((**((*a).k).as_mut_ptr().offset(i___0 as isize)).k)
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize),
                );
                i___0 += 1;
            }
            z = demote(z);
        } else if 0 as libc::c_longlong >= at___0 {
            z = ci(a);
        } else {
            tmp___14 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
            return tmp___14;
        }
    } else {
        if 0 as libc::c_longlong > bt {
            if 0 as libc::c_longlong == bn {
                if -(3 as libc::c_longlong) != bt {
                    z = ci(a);
                    current_block = 12094759598800435720;
                } else {
                    current_block = 11765686928131183963;
                }
            } else {
                current_block = 11765686928131183963;
            }
        } else {
            current_block = 11765686928131183963;
        }
        match current_block {
            12094759598800435720 => {}
            _ => {
                let mut current_block_183: u64;
                if 5 as libc::c_longlong == at___0 {
                    current_block_183 = 7362437428746118320;
                } else if 0 as libc::c_longlong == at___0 {
                    current_block_183 = 7362437428746118320;
                } else {
                    if 0 as libc::c_longlong > at___0 {
                        let mut current_block_180: u64;
                        if -(1 as libc::c_longlong) == bt {
                            if 1 as libc::c_longlong == bn {
                                tmp___17 = newK(
                                    1 as libc::c_int as I,
                                    1 as libc::c_int as I,
                                );
                                f___2 = tmp___17;
                                *(((*f___2).k).as_mut_ptr()
                                    as *mut I) = *(((*b___1).k).as_mut_ptr() as *mut I);
                                z = at_verb(a, f___2);
                                cd(f___2);
                                current_block_180 = 145651165234646754;
                            } else {
                                current_block_180 = 1864505793555618874;
                            }
                        } else {
                            current_block_180 = 1864505793555618874;
                        }
                        match current_block_180 {
                            1864505793555618874 => {
                                if bt < 0 as libc::c_longlong {
                                    tmp___20 = -bt;
                                } else {
                                    tmp___20 = bt;
                                }
                                if 1 as libc::c_longlong == tmp___20 {
                                    z = at_verb(a, b___1);
                                } else if 0 as libc::c_longlong == bt {
                                    z = newK(0 as libc::c_int as I, bn);
                                    i___1 = 0 as libc::c_int as I;
                                    _i___1 = bn;
                                    while i___1 < _i___1 {
                                        k___0 = at_verb(
                                            a,
                                            *((*b___1).k).as_mut_ptr().offset(i___1 as isize),
                                        );
                                        tmp___18 = OOM_CD(
                                            0 as libc::c_int as I,
                                            k___0,
                                            z,
                                            -(1 as libc::c_int) as V,
                                        );
                                        if tmp___18 == 0 {
                                            return 0 as K;
                                        }
                                        let ref mut fresh283 = *((*z).k)
                                            .as_mut_ptr()
                                            .offset(i___1 as isize);
                                        *fresh283 = k___0;
                                        i___1 += 1;
                                    }
                                    z = collapse(z);
                                } else {
                                    tmp___19 = kerr(
                                        b"type\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___19;
                                }
                            }
                            _ => {}
                        }
                    }
                    current_block_183 = 2885804587290726961;
                }
                match current_block_183 {
                    7362437428746118320 => {
                        if 0 as libc::c_longlong == bt {
                            f___0 = &mut *((*b___1).k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize) as *mut *mut k0;
                            if bn > 0 as libc::c_longlong {
                                tmp___15 = f___0.offset(1 as libc::c_int as isize);
                            } else {
                                tmp___15 = 0 as *mut K;
                            }
                            z = of2(a, f___0, tmp___15, bn - 1 as libc::c_longlong);
                        } else if -(1 as libc::c_longlong) == bt {
                            tmp___16 = promote(b___1);
                            k = tmp___16;
                            f___1 = &mut *((*k).k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize) as *mut *mut k0;
                            z = of2(
                                a,
                                f___1,
                                f___1.offset(1 as libc::c_int as isize),
                                bn - 1 as libc::c_longlong,
                            );
                            cd(k);
                        } else if -(4 as libc::c_longlong) == bt {
                            tmp___16 = promote(b___1);
                            k = tmp___16;
                            f___1 = &mut *((*k).k)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize) as *mut *mut k0;
                            z = of2(
                                a,
                                f___1,
                                f___1.offset(1 as libc::c_int as isize),
                                bn - 1 as libc::c_longlong,
                            );
                            cd(k);
                        } else {
                            z = at_verb(a, b___1);
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn dot(mut a: K, mut b___1: K) -> K {
    let mut s: S = 0 as *mut C;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut K = 0 as *mut K;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    if 4 as libc::c_longlong == (*a).t {
        if 4 as libc::c_longlong == (*b___1).t {
            tmp = strlen(*(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char);
            tmp___0 = strlen(
                *(((*b___1).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            tmp___1 = malloc(
                (2 as libc::c_ulong).wrapping_add(tmp).wrapping_add(tmp___0),
            );
            s = tmp___1 as S;
            s = strcpy(
                s as *mut libc::c_char,
                *(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            strcat(s as *mut libc::c_char, b".\0" as *const u8 as *const libc::c_char);
            strcat(
                s as *mut libc::c_char,
                *(((*b___1).k).as_mut_ptr() as *mut S) as *const libc::c_char,
            );
            tmp___2 = inKtree(
                &mut *((**((*KTREE).k).as_mut_ptr().offset(0 as libc::c_int as isize)).k)
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
                s,
                0 as libc::c_int as I,
            );
            tmp___3 = ci(*tmp___2);
            return tmp___3;
        }
    }
    if 7 as libc::c_longlong == (*a).t {
        tmp___4 = vf_ex(&mut a as *mut K as V, b___1);
        return tmp___4;
    }
    tmp___5 = of(a, b___1);
    return tmp___5;
}
unsafe extern "C" fn dot_ref(
    mut p: *mut K,
    mut x___0: *mut K,
    mut z: *mut K,
    mut s: I,
    mut c: K,
    mut y: K,
) -> K {
    let mut d___0: K = 0 as *mut k0;
    let mut f: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut dt: I = 0;
    let mut dn: I = 0;
    let mut tmp___0: I = 0;
    let mut ft: I = 0;
    let mut fn_0: I = 0;
    let mut yn0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut argc: I = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut args___0: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut r: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: I = 0;
    let mut tmp___11: I = 0;
    let mut n: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut tmp___16: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: K = 0 as *mut k0;
    let mut tmp___19: I = 0;
    let mut tmp___20: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut e: I = 0;
    let mut tmp___21: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut py: K = 0 as *mut k0;
    let mut tmp___23: I = 0;
    let mut tmp___24: K = 0 as *mut k0;
    let mut tmp___25: I = 0;
    let mut tmp___26: I = 0;
    let mut tmp___27: K = 0 as *mut k0;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut py___0: K = 0 as *mut k0;
    let mut tmp___31: I = 0;
    let mut u: S = 0 as *mut C;
    let mut tmp___32: *mut K = 0 as *mut K;
    let mut tmp___33: K = 0 as *mut k0;
    let mut tmp___34: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___35: *mut k0 = 0 as *mut k0;
    let mut tmp___36: K = 0 as *mut k0;
    let mut tmp___37: *mut K = 0 as *mut K;
    let mut k: K = 0 as *mut k0;
    let mut tmp___38: K = 0 as *mut k0;
    let mut tmp___39: K = 0 as *mut k0;
    let mut tmp___40: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___41: I = 0;
    let mut tmp___42: *mut k0 = 0 as *mut k0;
    let mut tmp___43: I = 0;
    let mut tmp___44: I = 0;
    d___0 = *p;
    if !x___0.is_null() {
        tmp = *x___0;
    } else {
        tmp = 0 as K;
    }
    f = tmp;
    dt = (*d___0).t;
    tmp___0 = countI(d___0);
    dn = tmp___0;
    ft = 999 as libc::c_int as I;
    yn0 = 0 as libc::c_int as I;
    if !f.is_null() {
        ft = (*f).t;
        fn_0 = countI(f);
    } else {
        tmp___1 = kerr(b"nyi\0" as *const u8 as *const libc::c_char);
        return tmp___1;
    }
    if !y.is_null() {
        yn0 = countI(y);
    }
    if -(1 as libc::c_longlong) == s {
        if 0 as libc::c_longlong == fn_0 {
            if -(3 as libc::c_longlong) != ft {
                if !y.is_null() {
                    tmp___2 = 2 as libc::c_int;
                } else {
                    tmp___2 = 1 as libc::c_int;
                }
                argc = tmp___2 as I;
                tmp___3 = newK(0 as libc::c_int as I, argc);
                args___0 = tmp___3;
                if args___0.is_null() {
                    return 0 as K;
                }
                let ref mut fresh284 = *((*args___0).k)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize);
                *fresh284 = ci(*p);
                if argc > 1 as libc::c_longlong {
                    let ref mut fresh285 = *((*args___0).k)
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize);
                    *fresh285 = ci(y);
                }
                tmp___4 = specialAmendDot(c, args___0);
                r = tmp___4;
                cd(args___0);
                if r.is_null() {
                    return 0 as K;
                }
                cd(*p);
                if 5 as libc::c_longlong == (*r).t {
                    *p = kcloneI(
                        r,
                        b"src/vd.c\0" as *const u8 as *const libc::c_char,
                        157 as libc::c_int,
                    );
                    cd(r);
                } else if 0 as libc::c_longlong == (*r).t {
                    *p = kcloneI(
                        r,
                        b"src/vd.c\0" as *const u8 as *const libc::c_char,
                        157 as libc::c_int,
                    );
                    cd(r);
                } else {
                    *p = r;
                }
                return 0 as *mut libc::c_void as K;
            }
        }
    }
    if 1 as libc::c_longlong <= dt {
        if dt <= 4 as libc::c_longlong {
            tmp___5 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
            return tmp___5;
        }
    }
    if 7 as libc::c_longlong == dt {
        tmp___5 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp___5;
    } else if 7 as libc::c_longlong == ft {
        tmp___5 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp___5;
    } else {
        if 6 as libc::c_longlong == dt {
            if 0 as libc::c_longlong >= ft {
                if -(4 as libc::c_longlong) != ft {
                    tmp___6 = kerr(b"index\0" as *const u8 as *const libc::c_char);
                    return tmp___6;
                }
            }
        }
        if 6 as libc::c_longlong == dt {
            if 6 as libc::c_longlong != ft {
                if ft < 0 as libc::c_longlong {
                    tmp___8 = -ft;
                } else {
                    tmp___8 = ft;
                }
                if 4 as libc::c_longlong != tmp___8 {
                    tmp___7 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___7;
                }
            }
        }
        if 5 as libc::c_longlong == dt {
            if 123 as libc::c_longlong == ft {
                return 0 as *mut libc::c_void as K;
            }
        }
        if 0 as libc::c_longlong >= s {
            at_ref(p, f, c, y);
        } else if 0 as libc::c_longlong == ft {
            tmp___10 = atomI(f);
            if tmp___10 == 0 {
                if !y.is_null() {
                    tmp___11 = atomI(y);
                    if tmp___11 == 0 {
                        if fn_0 != yn0 {
                            tmp___9 = kerr(
                                b"length\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___9;
                        }
                    }
                }
            }
            tmp___14 = atomI(f);
            if tmp___14 != 0 {
                if !y.is_null() {
                    tmp___13 = yn0;
                } else {
                    tmp___13 = fn_0;
                }
            } else {
                tmp___13 = fn_0;
            }
            n = tmp___13;
            if !y.is_null() {
                y = promote(y);
                if y.is_null() {
                    return 0 as K;
                }
            }
            i = 0 as libc::c_int as I;
            _i___0 = n;
            while i < _i___0 {
                dot_ref(
                    p,
                    ((*f).k).as_mut_ptr().offset((i % fn_0) as isize),
                    z,
                    s,
                    c,
                    *((*y).k).as_mut_ptr().offset((i % yn0) as isize),
                );
                i += 1;
            }
            cd(y);
        } else {
            if ft < 0 as libc::c_longlong {
                tmp___44 = -ft;
            } else {
                tmp___44 = ft;
            }
            if 1 as libc::c_longlong == tmp___44 {
                if !f.is_null() {
                    tmp___16 = atomI(f);
                    if tmp___16 == 0 {
                        if !y.is_null() {
                            tmp___17 = atomI(y);
                            if tmp___17 == 0 {
                                if fn_0 != yn0 {
                                    tmp___15 = kerr(
                                        b"length\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___15;
                                }
                            }
                        }
                    }
                }
                if 1 as libc::c_longlong == ft {
                    if dt > 0 as libc::c_longlong {
                        tmp___18 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                        return tmp___18;
                    }
                }
                if !y.is_null() {
                    if (*y).t != 0 as libc::c_longlong {
                        if !f.is_null() {
                            tmp___19 = atomI(f);
                            if tmp___19 != 0 {
                                ci(y);
                            } else {
                                y = promote(y);
                                if y.is_null() {
                                    return 0 as K;
                                }
                            }
                        } else {
                            ci(y);
                        }
                    } else {
                        ci(y);
                    }
                } else {
                    ci(y);
                }
                if dt != 0 as libc::c_longlong {
                    tmp___20 = kerr(b"rank\0" as *const u8 as *const libc::c_char);
                    return tmp___20;
                }
                if !f.is_null() {
                    i___0 = 0 as libc::c_int as I;
                    _i___1 = fn_0;
                    while i___0 < _i___1 {
                        e = *(((*f).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
                        if e < 0 as libc::c_longlong {
                            tmp___21 = kerr(
                                b"index\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___21;
                        } else {
                            if dn <= e {
                                tmp___21 = kerr(
                                    b"index\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___21;
                            }
                        }
                        i___0 += 1;
                    }
                }
                if !f.is_null() {
                    i___1 = 0 as libc::c_int as I;
                    _i___2 = fn_0;
                    while i___1 < _i___2 {
                        py = 0 as K;
                        if !y.is_null() {
                            tmp___23 = atomI(f);
                            if tmp___23 != 0 {
                                py = y;
                            } else {
                                py = *((*y).k).as_mut_ptr().offset((i___1 % yn0) as isize);
                            }
                        }
                        dot_ref(
                            ((*d___0).k)
                                .as_mut_ptr()
                                .offset(
                                    *(((*f).k).as_mut_ptr() as *mut I).offset(i___1 as isize)
                                        as isize,
                                ),
                            z,
                            z.offset(1 as libc::c_int as isize),
                            s - 1 as libc::c_longlong,
                            c,
                            py,
                        );
                        i___1 += 1;
                    }
                }
                cd(y);
            } else {
                if ft < 0 as libc::c_longlong {
                    tmp___43 = -ft;
                } else {
                    tmp___43 = ft;
                }
                if 4 as libc::c_longlong == tmp___43 {
                    tmp___25 = atomI(f);
                    if tmp___25 == 0 {
                        if !y.is_null() {
                            tmp___26 = atomI(y);
                            if tmp___26 == 0 {
                                if fn_0 != yn0 {
                                    tmp___24 = kerr(
                                        b"length\0" as *const u8 as *const libc::c_char,
                                    );
                                    return tmp___24;
                                }
                            }
                        }
                    }
                    if 4 as libc::c_longlong == ft {
                        if 0 as libc::c_longlong >= dt {
                            tmp___27 = kerr(
                                b"type\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___27;
                        }
                    }
                    if -(4 as libc::c_longlong) == ft {
                        if 0 as libc::c_longlong >= dt {
                            tmp___28 = kerr(
                                b"int\0" as *const u8 as *const libc::c_char,
                            );
                            return tmp___28;
                        }
                    }
                    if !y.is_null() {
                        if (*y).t != 0 as libc::c_longlong {
                            tmp___29 = atomI(f);
                            if tmp___29 != 0 {
                                ci(y);
                            } else {
                                y = promote(y);
                                if y.is_null() {
                                    return 0 as K;
                                }
                            }
                        } else {
                            ci(y);
                        }
                    } else {
                        ci(y);
                    }
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = fn_0;
                    while i___2 < _i___3 {
                        py___0 = 0 as K;
                        if !y.is_null() {
                            tmp___31 = atomI(f);
                            if tmp___31 != 0 {
                                py___0 = y;
                            } else {
                                py___0 = *((*y).k)
                                    .as_mut_ptr()
                                    .offset((i___2 % yn0) as isize);
                            }
                        }
                        u = *(((*f).k).as_mut_ptr() as *mut S).offset(i___2 as isize);
                        tmp___32 = lookupEVOrCreate(p, u);
                        dot_ref(
                            tmp___32,
                            z,
                            z.offset(1 as libc::c_int as isize),
                            s - 1 as libc::c_longlong,
                            c,
                            py___0,
                        );
                        i___2 += 1;
                    }
                    cd(y);
                } else if 6 as libc::c_longlong == ft {
                    if 6 as libc::c_longlong == dt {
                        return 0 as *mut libc::c_void as K;
                    }
                    if !y.is_null() {
                        tmp___34 = atomI(y);
                        if tmp___34 == 0 {
                            if yn0 != (*d___0).n {
                                tmp___33 = kerr(
                                    b"length\0" as *const u8 as *const libc::c_char,
                                );
                                return tmp___33;
                            }
                        }
                    }
                    if !y.is_null() {
                        y = promote(y);
                        if y.is_null() {
                            return 0 as K;
                        }
                    }
                    if 5 as libc::c_longlong == dt {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = (*d___0).n;
                        while i___3 < _i___4 {
                            if !y.is_null() {
                                tmp___35 = *((*y).k)
                                    .as_mut_ptr()
                                    .offset((i___3 % yn0) as isize);
                            } else {
                                tmp___35 = 0 as *mut k0;
                            }
                            tmp___36 = DI(d___0, i___3);
                            tmp___37 = EVP(tmp___36);
                            dot_ref(
                                tmp___37,
                                z,
                                z.offset(1 as libc::c_int as isize),
                                s - 1 as libc::c_longlong,
                                c,
                                tmp___35,
                            );
                            i___3 += 1;
                        }
                    }
                    if 0 as libc::c_longlong >= dt {
                        tmp___38 = Ki(0 as libc::c_int as I);
                        k = tmp___38;
                        if !y.is_null() {
                            tmp___39 = y;
                        } else {
                            tmp___39 = k;
                        }
                        tmp___40 = OOM_CD(
                            0 as libc::c_int as I,
                            k,
                            tmp___39,
                            -(1 as libc::c_int) as V,
                        );
                        if tmp___40 == 0 {
                            return 0 as K;
                        }
                        i___4 = 0 as libc::c_int as I;
                        tmp___41 = countI(d___0);
                        _i___5 = tmp___41;
                        while i___4 < _i___5 {
                            *(((*k).k).as_mut_ptr() as *mut I) = i___4;
                            if !y.is_null() {
                                tmp___42 = *((*y).k)
                                    .as_mut_ptr()
                                    .offset((i___4 % yn0) as isize);
                            } else {
                                tmp___42 = 0 as *mut k0;
                            }
                            dot_ref(p, &mut k, z, s, c, tmp___42);
                            i___4 += 1;
                        }
                        cd(k);
                    }
                    cd(y);
                }
            }
        }
        return 0 as K;
    };
}
pub unsafe extern "C" fn dot_tetradic_2(
    mut g: *mut K,
    mut b___1: K,
    mut c: K,
    mut y: K,
) -> K {
    let mut q: V = 0 as *mut libc::c_void;
    let mut tmp: K = 0 as *mut k0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp___0: I = 0;
    let mut f: *mut K = 0 as *mut K;
    let mut tmp___1: *mut K = 0 as *mut K;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    if (*c).t == 7 as libc::c_longlong {
        if (**((*c).k).as_mut_ptr().offset(2 as libc::c_int as isize)).t
            == -(4 as libc::c_longlong)
        {
            q = *(((*(*(((*c).k).as_mut_ptr() as *mut S)
                .offset(2 as libc::c_int as isize) as K))
                .k)
                .as_mut_ptr() as *mut V)
                .offset(0 as libc::c_int as isize);
            if q as libc::c_ulong > 500 as libc::c_int as V as libc::c_ulong {
                tmp = kerr(b"syntax\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
            fnc = DT[q as L as usize].text;
            if fnci < 127 as libc::c_longlong {
                fncp[fnci as usize] = q;
                fnci += 1;
            }
        }
    }
    bt = (*b___1).t;
    tmp___0 = countI(b___1);
    bn = tmp___0;
    if 0 as libc::c_longlong == bn {
        dot_ref(g, &mut b___1, 0 as *mut K, bn - 1 as libc::c_longlong, c, y);
    } else if 6 as libc::c_longlong == bt {
        dot_ref(g, &mut b___1, 0 as *mut K, bn - 1 as libc::c_longlong, c, y);
    } else {
        if !(0 as libc::c_longlong == bt) {
            if bt < 0 as libc::c_longlong {
                tmp___3 = -bt;
            } else {
                tmp___3 = bt;
            }
            if !(1 as libc::c_longlong == tmp___3) {
                if bt < 0 as libc::c_longlong {
                    tmp___4 = -bt;
                } else {
                    tmp___4 = bt;
                }
                if !(4 as libc::c_longlong == tmp___4) {
                    tmp___2 = kerr(b"type\0" as *const u8 as *const libc::c_char);
                    return tmp___2;
                }
            }
        }
        b___1 = promote(b___1);
        bt = 0 as libc::c_int as I;
        bn = countI(b___1);
        f = ((*b___1).k).as_mut_ptr();
        if bn > 0 as libc::c_longlong {
            tmp___1 = f.offset(1 as libc::c_int as isize);
        } else {
            tmp___1 = 0 as *mut K;
        }
        dot_ref(g, f, tmp___1, bn - 1 as libc::c_longlong, c, y);
        cd(b___1);
    }
    return *g;
}
pub unsafe extern "C" fn dot_tetradic(mut a: K, mut b___1: K, mut c: K, mut y: K) -> K {
    let mut d___0: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut i: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut e: K = 0 as *mut k0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: I = 0;
    let mut q: K = 0 as *mut k0;
    let mut p: *mut K = 0 as *mut K;
    let mut g: *mut K = 0 as *mut K;
    let mut tmp___8: *mut K = 0 as *mut K;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    tmp___7 = isColonDyadic(c);
    if tmp___7 != 0 {
        if y.is_null() {
            if (*(((*c).k).as_mut_ptr() as *mut V).offset(5 as libc::c_int as isize))
                .is_null()
            {
                tmp = newK(0 as libc::c_int as I, 2 as libc::c_int as I);
                d___0 = tmp;
                tmp___0 = Ki(0 as libc::c_int as I);
                i = tmp___0;
                tmp___1 = OOM_CD(
                    0 as libc::c_int as I,
                    d___0,
                    i,
                    -(1 as libc::c_int) as V,
                );
                if tmp___1 == 0 {
                    return 0 as K;
                }
                let ref mut fresh286 = *((*d___0).k)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize);
                *fresh286 = i;
                tmp___2 = vf_ex(&mut a as *mut K as V, b___1);
                z = tmp___2;
                let ref mut fresh287 = *((*d___0).k)
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize);
                *fresh287 = z;
                if z.is_null() {
                    *(((*i).k).as_mut_ptr() as *mut I) = 1 as libc::c_int as I;
                    tmp___3 = strlen(errmsg.as_mut_ptr() as *const libc::c_char);
                    tmp___4 = newK(-(3 as libc::c_int) as I, tmp___3 as I);
                    e = tmp___4;
                    tmp___5 = OOM_CD(
                        0 as libc::c_int as I,
                        d___0,
                        e,
                        -(1 as libc::c_int) as V,
                    );
                    if tmp___5 == 0 {
                        return 0 as K;
                    }
                    strcpy(
                        ((*e).k).as_mut_ptr() as *mut C as *mut libc::c_char,
                        errmsg.as_mut_ptr() as *const libc::c_char,
                    );
                    let ref mut fresh288 = *((*d___0).k)
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize);
                    *fresh288 = e;
                }
                fer = -(1 as libc::c_int) as I;
                tmp___6 = demote(d___0);
                return tmp___6;
            }
        }
    }
    if !KONA_GSET.is_null() {
        if a as libc::c_ulong != KONA_GSET as libc::c_ulong {
            ci(a);
            cd(KONA_GSET);
            KONA_GSET = a;
        }
    }
    if !KONA_IDX.is_null() {
        if b___1 as libc::c_ulong != KONA_IDX as libc::c_ulong {
            ci(b___1);
            cd(KONA_IDX);
            KONA_IDX = b___1;
        }
    }
    q = 0 as K;
    p = 0 as *mut K;
    if (*a).t == 4 as libc::c_longlong {
        p = denameS(d_, *(((*a).k).as_mut_ptr() as *mut S), 1 as libc::c_int as I);
        if p.is_null() {
            return 0 as K;
        }
    } else {
        q = kcloneI(
            a,
            b"src/vd.c\0" as *const u8 as *const libc::c_char,
            295 as libc::c_int,
        );
    }
    if !q.is_null() {
        tmp___8 = &mut q;
    } else {
        tmp___8 = p;
    }
    g = tmp___8;
    tmp___9 = dot_tetradic_2(g, b___1, c, y);
    if tmp___9.is_null() {
        return 0 as K;
    }
    if !q.is_null() {
        tmp___11 = q;
    } else {
        tmp___10 = ci(a);
        tmp___11 = tmp___10;
    }
    return tmp___11;
}
pub unsafe extern "C" fn make(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    tmp___0 = makeable(a);
    if tmp___0.is_null() {
        tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    n = (*a).n;
    tmp___1 = newK(5 as libc::c_int as I, n);
    z = tmp___1;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        let ref mut fresh289 = *((*z).k).as_mut_ptr().offset(i as isize);
        *fresh289 = newK(0 as libc::c_int as I, 3 as libc::c_int as I);
        i += 1;
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = n;
    while i___0 < _i___1 {
        x___0 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
        y = *((*a).k).as_mut_ptr().offset(i___0 as isize);
        j = 0 as libc::c_int as I;
        _j = (*y).n;
        while j < _j {
            if (*y).t != 0 {
                tmp___2 = Ks(*(((*y).k).as_mut_ptr() as *mut S).offset(j as isize));
                let ref mut fresh290 = *((*x___0).k).as_mut_ptr().offset(j as isize);
                *fresh290 = tmp___2;
            } else {
                tmp___3 = ci(*((*y).k).as_mut_ptr().offset(j as isize));
                let ref mut fresh291 = *((*x___0).k).as_mut_ptr().offset(j as isize);
                *fresh291 = tmp___3;
            }
            j += 1;
        }
        if (*y).n < 3 as libc::c_longlong {
            let ref mut fresh292 = *((*x___0).k)
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize);
            *fresh292 = _n();
        }
        i___0 += 1;
    }
    return z;
}
unsafe extern "C" fn unmake(mut a: K) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    tmp = kcloneI(
        a,
        b"src/vd.c\0" as *const u8 as *const libc::c_char,
        321 as libc::c_int,
    );
    z = tmp;
    (*z).t = 0 as libc::c_int as I;
    return z;
}
unsafe extern "C" fn makeable(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    t = (*a).t;
    n = (*a).n;
    if 0 as libc::c_longlong != t {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        x___0 = *((*a).k).as_mut_ptr().offset(i as isize);
        if 0 as libc::c_longlong != (*x___0).t {
            if -(4 as libc::c_longlong) != (*x___0).t {
                return 0 as K;
            }
        }
        if (*x___0).n < 2 as libc::c_longlong {
            return 0 as K
        } else {
            if (3 as libc::c_longlong) < (*x___0).n {
                return 0 as K
            } else {
                if -(4 as libc::c_longlong) == (*x___0).t {
                    if (*x___0).n != 2 as libc::c_longlong {
                        return 0 as K;
                    }
                }
            }
        }
        i += 1;
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = n;
    while i___0 < _i___1 {
        x___0 = *((*a).k).as_mut_ptr().offset(i___0 as isize);
        if 0 as libc::c_longlong == (*x___0).t {
            if 4 as libc::c_longlong
                != (**((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t
            {
                return 0 as K
            } else {
                if 3 as libc::c_longlong == (*x___0).n {
                    if 5 as libc::c_longlong
                        != (**((*x___0).k)
                            .as_mut_ptr()
                            .offset(2 as libc::c_int as isize))
                            .t
                    {
                        if 6 as libc::c_longlong
                            != (**((*x___0).k)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .t
                        {
                            return 0 as K;
                        }
                    }
                }
            }
        }
        i___0 += 1;
    }
    return 1 as libc::c_int as K;
}
pub unsafe extern "C" fn dot_monadic(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut p: *mut K = 0 as *mut K;
    let mut tmp___2: *mut K = 0 as *mut K;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    if (*x___0).t == 0 as libc::c_longlong {
        if (*x___0).n == 1 as libc::c_longlong {
            if (**((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize)).t
                == -(3 as libc::c_longlong)
            {
                tmp = kerr(b"valence\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if (*x___0).t < 0 as libc::c_longlong {
        tmp___1 = -(*x___0).t;
    } else {
        tmp___1 = (*x___0).t;
    }
    if 3 as libc::c_longlong == tmp___1 {
        tmp___0 = KX(x___0);
        return tmp___0;
    }
    if 4 as libc::c_longlong == (*x___0).t {
        tmp___2 = denameS(
            d_,
            *(((*x___0).k).as_mut_ptr() as *mut S),
            0 as libc::c_int as I,
        );
        p = tmp___2;
        if p.is_null() {
            tmp___3 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___3;
        }
        tmp___4 = ci(*p);
        return tmp___4;
    }
    if 5 as libc::c_longlong == (*x___0).t {
        tmp___5 = unmake(x___0);
        return tmp___5;
    }
    tmp___7 = makeable(x___0);
    if !tmp___7.is_null() {
        tmp___6 = make(x___0);
        return tmp___6;
    }
    tmp___8 = vf_ex(offsetDot, x___0);
    return tmp___8;
}
pub unsafe extern "C" fn CSK(mut x___0: K) -> S {
    let mut tmp___0: *mut C = 0 as *mut C;
    let mut tmp___1: I = 0;
    let mut tmp___2: S = 0 as *mut C;
    let mut tmp___3: S = 0 as *mut C;
    if x___0.is_null() {
        tmp___3 = 0 as S;
    } else {
        if 4 as libc::c_longlong == (*x___0).t {
            tmp___2 = *(((*x___0).k).as_mut_ptr() as *mut S);
        } else {
            if (*x___0).t < 0 as libc::c_longlong {
                tmp___1 = -(*x___0).t;
            } else {
                tmp___1 = (*x___0).t;
            }
            if 3 as libc::c_longlong == tmp___1 {
                tmp___0 = ((*x___0).k).as_mut_ptr() as *mut C;
            } else {
                tmp___0 = 0 as *mut C;
            }
            tmp___2 = tmp___0;
        }
        tmp___3 = tmp___2;
    }
    return tmp___3;
}
unsafe extern "C" fn formKsCS(mut s: S) -> K {
    let mut t: S = 0 as *mut C;
    let mut tmp: S = 0 as *mut C;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = sp(s);
    t = tmp;
    if t.is_null() {
        return 0 as K;
    }
    tmp___0 = Ks(t);
    z = tmp___0;
    if z.is_null() {
        return 0 as K;
    }
    return z;
}
pub unsafe extern "C" fn formKiCS(mut s: S) -> K {
    let mut p: *mut C = 0 as *mut C;
    let mut q: C = 0;
    let mut r: I = 0;
    let mut w___0: I = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: K = 0 as *mut k0;
    q = 0 as libc::c_int as C;
    r = (-(0x7fffffffffffffff as libc::c_long) - 1 as libc::c_int as libc::c_long) as I;
    tmp = strlen(s as *const libc::c_char);
    tmp___0 = parseNI(s, tmp as I);
    w___0 = tmp___0;
    if w___0 != 0 {
        r = NI[w___0 as usize];
    } else if *s != 0 {
        r = strtoll(
            s as *const libc::c_char,
            &mut p as *mut *mut C as *mut *mut libc::c_char,
            10 as libc::c_int,
        );
        tmp___1 = __errno_location();
        *tmp___1 = 0 as libc::c_int;
        q = *p;
        if (-(0x7fffffffffffffff as libc::c_long) - 1 as libc::c_int as libc::c_long)
            as libc::c_longlong == r
        {
            r = -(9223372036854775807 as libc::c_longlong);
        }
    }
    if q != 0 {
        tmp___2 = __ctype_b_loc();
        if *(*tmp___2).offset(q as libc::c_int as isize) as libc::c_int
            & 1 as libc::c_int == 0
        {
            return 0 as K;
        }
    }
    tmp___3 = Ki(r);
    return tmp___3;
}
pub unsafe extern "C" fn formKfCS(mut s: S) -> K {
    let mut p: *mut C = 0 as *mut C;
    let mut q: C = 0;
    let mut r: F = 0.;
    let mut w___0: I = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: K = 0 as *mut k0;
    q = 0 as libc::c_int as C;
    r = 0 as libc::c_int as libc::c_double / 0.0f64;
    tmp = strlen(s as *const libc::c_char);
    tmp___0 = parseNI(s, tmp as I);
    w___0 = tmp___0;
    if w___0 != 0 {
        r = ni[w___0 as usize];
    } else if *s != 0 {
        r = strtod(
            s as *const libc::c_char,
            &mut p as *mut *mut C as *mut *mut libc::c_char,
        );
        tmp___1 = __errno_location();
        *tmp___1 = 0 as libc::c_int;
        q = *p;
        tmp___2 = r.is_nan() as i32;
        if tmp___2 != 0 {
            r = -(1 as libc::c_int as libc::c_double / 0.0f64);
        }
    }
    if q != 0 {
        tmp___3 = __ctype_b_loc();
        if *(*tmp___3).offset(q as libc::c_int as isize) as libc::c_int
            & 1 as libc::c_int == 0
        {
            return 0 as K;
        }
    }
    tmp___4 = Kf(r);
    return tmp___4;
}
unsafe extern "C" fn formatFn(mut a: K) -> K {
    let mut v: *mut V = 0 as *mut V;
    let mut p: V = 0 as *mut libc::c_void;
    let mut i: I = 0;
    let mut k: I = 0;
    let mut n: I = 0;
    let mut r: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut t: [C; 256] = [0; 256];
    let mut tmp: libc::c_uint = 0;
    let mut s: S = 0 as *mut C;
    let mut q: L = 0;
    let mut u: S = 0 as *mut C;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut f: S = 0 as *mut C;
    let mut n___0: I = 0;
    let mut tmp___2: size_t = 0;
    v = ((*(*(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize) as K))
        .k)
        .as_mut_ptr() as *mut S as *mut V;
    r = 0 as libc::c_int as I;
    z = 0 as K;
    t[0 as libc::c_int as usize] = '\u{0}' as i32 as C;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 256 as libc::c_uint) {
        t[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    s = t.as_mut_ptr();
    match (*a).n {
        1 => {
            i = 0 as libc::c_int as I;
            loop {
                p = *v.offset(i as isize);
                if p.is_null() {
                    break;
                }
                q = p as L;
                let mut current_block_35: u64;
                if q < DT_SIZE {
                    if q >= DT_SPECIAL_VERB_OFFSET {
                        u = DT[q as usize].text;
                        tmp___0 = strlen(u as *const libc::c_char);
                        n = tmp___0 as I;
                        strcpy(
                            s.offset(r as isize) as *mut libc::c_char,
                            u as *const libc::c_char,
                        );
                        r += n;
                        current_block_35 = 980989089337379490;
                    } else {
                        current_block_35 = 11779442858660984456;
                    }
                } else {
                    current_block_35 = 11779442858660984456;
                }
                match current_block_35 {
                    11779442858660984456 => {
                        k = adverbClass(p);
                        if k != 0 {
                            t[r as usize] = adverbsChar(p);
                            if k != 1 as libc::c_longlong {
                                t[(r + 1 as libc::c_longlong) as usize] = ':' as i32 as C;
                            }
                            r += 1;
                        } else {
                            k = sva(p);
                            if k != 0 {
                                t[r as usize] = verbsChar(p);
                                if k != 2 as libc::c_longlong {
                                    t[(r + 1 as libc::c_longlong) as usize] = ':' as i32 as C;
                                }
                                r += 1;
                            }
                        }
                    }
                    _ => {}
                }
                i += 1;
            }
            tmp___1 = strlen(s as *const libc::c_char);
            n = tmp___1 as I;
            z = newK(-(3 as libc::c_int) as I, n);
            memcpy(
                ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
                s as *const libc::c_void,
                (n + 1 as libc::c_longlong) as size_t,
            );
        }
        3 => {
            f = ((*(*(((*a).k).as_mut_ptr() as *mut V).offset(2 as libc::c_int as isize)
                as K))
                .k)
                .as_mut_ptr() as *mut C;
            tmp___2 = strlen(f as *const libc::c_char);
            n___0 = tmp___2 as I;
            z = newK(-(3 as libc::c_int) as I, n___0 + 2 as libc::c_longlong);
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(0 as libc::c_int as isize) = '{' as i32 as C;
            memcpy(
                (((*z).k).as_mut_ptr() as *mut C).offset(1 as libc::c_int as isize)
                    as *mut libc::c_void,
                f as *const libc::c_void,
                n___0 as size_t,
            );
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset((n___0 + 1 as libc::c_longlong) as isize) = '}' as i32 as C;
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(
                    (n___0 + 2 as libc::c_longlong) as isize,
                ) = 0 as libc::c_int as C;
        }
        2 | _ => {}
    }
    return z;
}
unsafe extern "C" fn formatS(mut x___0: S) -> K {
    let mut n: I = 0;
    let mut tmp: size_t = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = strlen(x___0 as *const libc::c_char);
    n = tmp as I;
    tmp___0 = newK(-(3 as libc::c_int) as I, n);
    z = tmp___0;
    if !z.is_null() {
        sprintf(
            ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_char,
            b"%s\0" as *const u8 as *const libc::c_char,
            x___0,
        );
    }
    return z;
}
static mut buf: [C; 32] = [0; 32];
unsafe extern "C" fn formatF(mut x___0: F, mut y: I, mut c: I) -> K {
    let mut k: libc::c_int = 0;
    let mut b___1: S = 0 as *mut C;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut n: I = 0;
    let mut tmp___1: size_t = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    k = y as libc::c_int;
    if 0 as libc::c_longlong == c {
        tmp___0 = b"%.*g\0" as *const u8 as *const libc::c_char;
    } else {
        if 1 as libc::c_longlong == c {
            tmp = b"%.*f\0" as *const u8 as *const libc::c_char;
        } else {
            tmp = b"%.*e\0" as *const u8 as *const libc::c_char;
        }
        tmp___0 = tmp;
    }
    b___1 = tmp___0 as S;
    sprintf(
        buf.as_mut_ptr() as *mut libc::c_char,
        b___1 as *const libc::c_char,
        k,
        x___0,
    );
    tmp___1 = strlen(buf.as_mut_ptr() as *const libc::c_char);
    n = tmp___1 as I;
    tmp___2 = newK(-(3 as libc::c_int) as I, n);
    z = tmp___2;
    if !z.is_null() {
        memcpy(
            ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
            buf.as_mut_ptr() as *const libc::c_void,
            n as size_t,
        );
    }
    return z;
}
static mut buf___0: [C; 72] = [0; 72];
unsafe extern "C" fn formatI(mut x___0: I) -> K {
    let mut n: I = 0;
    let mut tmp: size_t = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    sprintf(
        buf___0.as_mut_ptr() as *mut libc::c_char,
        b"%lld\0" as *const u8 as *const libc::c_char,
        x___0,
    );
    tmp = strlen(buf___0.as_mut_ptr() as *const libc::c_char);
    n = tmp as I;
    tmp___0 = newK(-(3 as libc::c_int) as I, n);
    z = tmp___0;
    if !z.is_null() {
        memcpy(
            ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
            buf___0.as_mut_ptr() as *const libc::c_void,
            n as size_t,
        );
    }
    return z;
}
pub unsafe extern "C" fn format(mut a: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: S = 0 as *mut C;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    if at___0 < 0 as libc::c_longlong {
        tmp___6 = -at___0;
    } else {
        tmp___6 = at___0;
    }
    if 3 as libc::c_longlong == tmp___6 {
        z = kcloneI(
            a,
            b"src/vf.c\0" as *const u8 as *const libc::c_char,
            100 as libc::c_int,
        );
        (*z).t = -(3 as libc::c_int) as I;
        return z;
    } else {
        if 7 as libc::c_longlong == at___0 {
            tmp = formatFn(a);
            return tmp;
        } else {
            if 6 as libc::c_longlong == at___0 {
                tmp___0 = newK(-(3 as libc::c_int) as I, 0 as libc::c_int as I);
                return tmp___0;
            } else {
                if 5 as libc::c_longlong == at___0 {
                    tmp___1 = sp(b".(..)\0" as *const u8 as *const libc::c_char as S);
                    tmp___2 = formatS(tmp___1);
                    return tmp___2;
                } else {
                    if 4 as libc::c_longlong == at___0 {
                        tmp___3 = formatS(*(((*a).k).as_mut_ptr() as *mut S));
                        return tmp___3;
                    } else {
                        if 2 as libc::c_longlong == at___0 {
                            tmp___4 = formatF(
                                *(((*a).k).as_mut_ptr() as *mut F),
                                PP,
                                0 as libc::c_int as I,
                            );
                            return tmp___4;
                        } else {
                            if 1 as libc::c_longlong == at___0 {
                                tmp___5 = formatI(*(((*a).k).as_mut_ptr() as *mut I));
                                return tmp___5;
                            }
                        }
                    }
                }
            }
        }
    }
    z = newK(0 as libc::c_int as I, an);
    if 0 as libc::c_longlong == at___0 {
        i = 0 as libc::c_int as I;
        _i___0 = an;
        while i < _i___0 {
            let ref mut fresh293 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh293 = format(*((*a).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
    } else if -(1 as libc::c_longlong) == at___0 {
        i___0 = 0 as libc::c_int as I;
        _i___1 = an;
        while i___0 < _i___1 {
            let ref mut fresh294 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh294 = formatI(
                *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize),
            );
            i___0 += 1;
        }
    } else if -(2 as libc::c_longlong) == at___0 {
        i___1 = 0 as libc::c_int as I;
        _i___2 = an;
        while i___1 < _i___2 {
            let ref mut fresh295 = *((*z).k).as_mut_ptr().offset(i___1 as isize);
            *fresh295 = formatF(
                *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                PP,
                0 as libc::c_int as I,
            );
            i___1 += 1;
        }
    } else if -(4 as libc::c_longlong) == at___0 {
        i___2 = 0 as libc::c_int as I;
        _i___3 = an;
        while i___2 < _i___3 {
            let ref mut fresh296 = *((*z).k).as_mut_ptr().offset(i___2 as isize);
            *fresh296 = formatS(
                *(((*a).k).as_mut_ptr() as *mut S).offset(i___2 as isize),
            );
            i___2 += 1;
        }
    }
    return z;
}
pub static mut NI: [I; 7] = [
    0 as libc::c_int as I,
    (-(0x7fffffffffffffff as libc::c_long) - 1 as libc::c_int as libc::c_long) as I,
    -(9223372036854775807 as libc::c_longlong),
    9223372036854775807 as libc::c_longlong,
    9223372036854775807 as libc::c_longlong,
    -(9223372036854775807 as libc::c_longlong),
    9223372036854775807 as libc::c_longlong,
];
pub static mut ni: [F; 7] = [
    0 as libc::c_int as F,
    0 as libc::c_int as libc::c_double / 0.0f64,
    -(1 as libc::c_int as libc::c_double / 0.0f64),
    1 as libc::c_int as libc::c_double / 0.0f64,
    0 as libc::c_int as libc::c_double / 0.0f64,
    -(1 as libc::c_int as libc::c_double / 0.0f64),
    1 as libc::c_int as libc::c_double / 0.0f64,
];
unsafe extern "C" fn TNI(mut p: I, mut h: C) -> I {
    let mut c: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    tmp___2 = __ctype_b_loc();
    if *(*tmp___2).offset(h as libc::c_int as isize) as libc::c_int & 1 as libc::c_int
        != 0
    {
        tmp___1 = 0 as libc::c_int as I;
    } else {
        tmp___0 = charpos(b" -0NIni\0" as *const u8 as *const libc::c_char as S, h);
        tmp___1 = tmp___0;
    }
    c = tmp___1;
    if 0 as libc::c_longlong == c {
        if 7 as libc::c_longlong >= p {
            return p;
        }
    }
    if 1 as libc::c_longlong == c {
        if 0 as libc::c_longlong == p {
            return 7 as libc::c_longlong - p
        } else {
            if 7 as libc::c_longlong == p {
                return 7 as libc::c_longlong - p;
            }
        }
    }
    if 2 as libc::c_longlong == c {
        if 0 as libc::c_longlong == p {
            return 9 as libc::c_int as I;
        }
    }
    if 2 as libc::c_longlong == c {
        if 7 as libc::c_longlong == p {
            return 8 as libc::c_int as I;
        }
    }
    if 3 as libc::c_longlong == c {
        if 8 as libc::c_longlong == p {
            return 1 as libc::c_int as I
        } else {
            if 9 as libc::c_longlong == p {
                return 1 as libc::c_int as I;
            }
        }
    }
    if 4 as libc::c_longlong == c {
        if 8 as libc::c_longlong == p {
            return p - 6 as libc::c_longlong
        } else {
            if 9 as libc::c_longlong == p {
                return p - 6 as libc::c_longlong;
            }
        }
    }
    if 5 as libc::c_longlong == c {
        if 8 as libc::c_longlong == p {
            return 4 as libc::c_int as I
        } else {
            if 9 as libc::c_longlong == p {
                return 4 as libc::c_int as I;
            }
        }
    }
    if 6 as libc::c_longlong == c {
        if 8 as libc::c_longlong == p {
            return p - 3 as libc::c_longlong
        } else {
            if 9 as libc::c_longlong == p {
                return p - 3 as libc::c_longlong;
            }
        }
    }
    return 10 as libc::c_int as I;
}
unsafe extern "C" fn parseNI(mut s: S, mut n: I) -> I {
    let mut i: I = 0;
    let mut p: I = 0;
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: I = 0;
    i = 0 as libc::c_int as I;
    p = 0 as libc::c_int as I;
    while i < n {
        if *s == 0 {
            break;
        }
        tmp = s;
        s = s.offset(1);
        p = TNI(p, *tmp);
    }
    if p < 7 as libc::c_longlong {
        tmp___0 = p;
    } else {
        tmp___0 = 0 as libc::c_int as I;
    }
    return tmp___0;
}
unsafe extern "C" fn tround(mut f: F) -> F {
    let mut d___0: F = 0.;
    let mut tmp: F = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: I = 0;
    let mut tmp___6: I = 0;
    tmp = FF(f);
    d___0 = tmp;
    let mut current_block_18: u64;
    if d___0 > 0 as libc::c_int as F {
        tmp___5 = FC(d___0, 1 as libc::c_int as F);
        if tmp___5 != 0 {
            current_block_18 = 7292311698034448976;
        } else {
            tmp___2 = ceil(f);
            tmp___4 = tmp___2;
            current_block_18 = 2838571290723028321;
        }
    } else {
        current_block_18 = 7292311698034448976;
    }
    match current_block_18 {
        7292311698034448976 => {
            if d___0 < 0 as libc::c_int as F {
                tmp___6 = FC(d___0, 0 as libc::c_int as F);
                if tmp___6 != 0 {
                    tmp___3 = floor(f);
                    tmp___4 = tmp___3;
                } else {
                    tmp___2 = ceil(f);
                    tmp___4 = tmp___2;
                }
            } else {
                tmp___3 = floor(f);
                tmp___4 = tmp___3;
            }
        }
        _ => {}
    }
    return tmp___4;
}
pub unsafe extern "C" fn dollar(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut x___0: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut y: I = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut q: K = 0 as *mut k0;
    let mut tmp___8: *mut k0 = 0 as *mut k0;
    let mut tmp___9: *mut k0 = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    let mut tmp___11: I = 0;
    let mut tmp___12: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut m: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut k: I = 0;
    let mut tmp___15: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut f: F = 0.;
    let mut c___0: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_double = 0.;
    let mut tmp___20: F = 0.;
    let mut tmp___21: F = 0.;
    let mut tmp___22: S = 0 as *mut C;
    let mut tmp___23: K = 0 as *mut k0;
    let mut tmp___24: size_t = 0;
    let mut tmp___25: K = 0 as *mut k0;
    let mut tmp___26: I = 0;
    let mut tmp___27: S = 0 as *mut C;
    let mut tmp___28: K = 0 as *mut k0;
    let mut tmp___29: S = 0 as *mut C;
    let mut tmp___30: K = 0 as *mut k0;
    let mut tmp___31: I = 0;
    let mut tmp___32: K = 0 as *mut k0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    z = 0 as K;
    if at___0 <= 0 as libc::c_longlong {
        if -(3 as libc::c_longlong) != at___0 {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
    } else {
        tmp = 0 as libc::c_int;
    }
    x___0 = tmp as I;
    if bt <= 0 as libc::c_longlong {
        if -(3 as libc::c_longlong) != bt {
            tmp___0 = 1 as libc::c_int;
        } else {
            tmp___0 = 0 as libc::c_int;
        }
    } else {
        tmp___0 = 0 as libc::c_int;
    }
    y = tmp___0 as I;
    if x___0 != 0 {
        if y != 0 {
            if an != bn {
                tmp___1 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___1;
            }
        }
    }
    's_466: {
        if !(x___0 != 0) {
            if !(y != 0) {
                break 's_466;
            }
        }
        if x___0 != 0 {
            tmp___2 = promote(a);
            a = tmp___2;
        } else {
            tmp___3 = ci(a);
            a = tmp___3;
        }
        if y != 0 {
            tmp___4 = promote(b___1);
            b___1 = tmp___4;
        } else {
            tmp___5 = ci(b___1);
            b___1 = tmp___5;
        }
        if !a.is_null() {
            if !b___1.is_null() {
                if x___0 != 0 {
                    tmp___6 = (*a).n;
                } else {
                    tmp___6 = (*b___1).n;
                }
                tmp___7 = newK(0 as libc::c_int as I, tmp___6);
                z = tmp___7;
            } else {
                z = 0 as K;
            }
        } else {
            z = 0 as K;
        }
        if !z.is_null() {
            i = 0 as libc::c_int as I;
            _i___0 = (*z).n;
            while i < _i___0 {
                if y != 0 {
                    tmp___8 = *((*b___1).k).as_mut_ptr().offset(i as isize);
                } else {
                    tmp___8 = b___1;
                }
                if x___0 != 0 {
                    tmp___9 = *((*a).k).as_mut_ptr().offset(i as isize);
                } else {
                    tmp___9 = a;
                }
                tmp___10 = dollar(tmp___9, tmp___8);
                q = tmp___10;
                tmp___11 = OOM_CD(
                    0 as libc::c_int as I,
                    q,
                    z,
                    a,
                    b___1,
                    -(1 as libc::c_int) as V,
                );
                if tmp___11 == 0 {
                    return 0 as K;
                }
                let ref mut fresh297 = *((*z).k).as_mut_ptr().offset(i as isize);
                *fresh297 = q;
                i += 1;
            }
        }
        cd(a);
        cd(b___1);
        tmp___12 = demote(z);
        return tmp___12;
    }
    if 1 as libc::c_longlong == at___0 {
        if *(((*a).k).as_mut_ptr() as *mut I) != 0 {
            c = format(b___1);
            if c.is_null() {
                return 0 as K;
            }
            m = *(((*a).k).as_mut_ptr() as *mut I);
            if m < 0 as libc::c_longlong {
                tmp___13 = -m;
            } else {
                tmp___13 = m;
            }
            z = newK(-(3 as libc::c_int) as I, tmp___13);
            tmp___14 = OOM_CD(0 as libc::c_int as I, c, z, -(1 as libc::c_int) as V);
            if tmp___14 == 0 {
                return 0 as K;
            }
            if (*z).n < (*c).n {
                i___0 = 0 as libc::c_int as I;
                _i___1 = (*z).n;
                while i___0 < _i___1 {
                    *(((*z).k).as_mut_ptr() as *mut C)
                        .offset(i___0 as isize) = '*' as i32 as C;
                    i___0 += 1;
                }
            } else {
                if m > 0 as libc::c_longlong {
                    tmp___15 = m - (*c).n;
                } else {
                    tmp___15 = 0 as libc::c_int as I;
                }
                k = tmp___15;
                i___1 = 0 as libc::c_int as I;
                _i___2 = (*z).n;
                while i___1 < _i___2 {
                    *(((*z).k).as_mut_ptr() as *mut C)
                        .offset(i___1 as isize) = ' ' as i32 as C;
                    i___1 += 1;
                }
                i___2 = 0 as libc::c_int as I;
                _i___3 = (*c).n;
                while i___2 < _i___3 {
                    *(((*z).k).as_mut_ptr() as *mut C)
                        .offset(
                            (i___2 + k) as isize,
                        ) = *(((*c).k).as_mut_ptr() as *mut C).offset(i___2 as isize);
                    i___2 += 1;
                }
            }
            cd(c);
            return z;
        }
    }
    if 2 as libc::c_longlong == at___0 {
        f = *(((*a).k).as_mut_ptr() as *mut F);
        's_751: {
            if !(2 as libc::c_longlong == bt) {
                if !(1 as libc::c_longlong == bt) {
                    break 's_751;
                }
            }
            c___0 = Ki(f as I);
            if c___0.is_null() {
                return 0 as K;
            }
            tmp___18 = f.is_sign_negative() as libc::c_int;
            if tmp___18 != 0 {
                tmp___17 = 2 as libc::c_int;
            } else {
                tmp___17 = 1 as libc::c_int;
            }
            tmp___19 = fabs(f);
            tmp___20 = tround(tmp___19 * 10 as libc::c_int as libc::c_double);
            if 2 as libc::c_longlong == bt {
                tmp___21 = *(((*b___1).k).as_mut_ptr() as *mut F);
            } else {
                tmp___21 = *(((*b___1).k).as_mut_ptr() as *mut I) as F;
            }
            d___0 = formatF(
                tmp___21,
                tmp___20 as I % 10 as libc::c_longlong,
                tmp___17 as I,
            );
            if !d___0.is_null() {
                z = dollar(c___0, d___0);
            }
            cd(c___0);
            cd(d___0);
            return z;
        }
    }
    if bt < 0 as libc::c_longlong {
        tmp___31 = -bt;
    } else {
        tmp___31 = bt;
    }
    if 3 as libc::c_longlong == tmp___31 {
        if 3 as libc::c_longlong == bt {
            b___1 = enlist(b___1);
        }
        if 4 as libc::c_longlong == at___0 {
            tmp___24 = strlen(*(((*a).k).as_mut_ptr() as *mut S) as *const libc::c_char);
            if tmp___24 == 0 {
                tmp___22 = CSK(b___1);
                tmp___23 = formKsCS(tmp___22);
                return tmp___23;
            }
        }
        if at___0 < 0 as libc::c_longlong {
            tmp___26 = -at___0;
        } else {
            tmp___26 = at___0;
        }
        if 3 as libc::c_longlong == tmp___26 {
            tmp___25 = ci(b___1);
            return tmp___25;
        }
        if 2 as libc::c_longlong == at___0 {
            tmp___27 = CSK(b___1);
            tmp___28 = formKfCS(tmp___27);
            return tmp___28;
        }
        if 1 as libc::c_longlong == at___0 {
            if *(((*a).k).as_mut_ptr() as *mut I) == 0 {
                tmp___29 = CSK(b___1);
                tmp___30 = formKiCS(tmp___29);
                return tmp___30;
            }
        }
        return 0 as K;
    }
    tmp___32 = kerr(b"type\0" as *const u8 as *const libc::c_char);
    return tmp___32;
}
unsafe extern "C" fn FtoI(mut a: F) -> I {
    let mut u: __anonunion_u_554368621 = __anonunion_u_554368621 { f: 0. };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_longlong = 0;
    tmp = a.is_nan() as i32;
    if tmp != 0 {
        return (-(0x7fffffffffffffff as libc::c_long) - 1 as libc::c_int as libc::c_long)
            as I;
    }
    u.f = a;
    if 0 as libc::c_longlong > u.i {
        tmp___0 = (-(0x7fffffffffffffff as libc::c_long)
            - 1 as libc::c_int as libc::c_long) as libc::c_longlong - u.i;
    } else {
        tmp___0 = u.i;
    }
    return tmp___0;
}
unsafe extern "C" fn ItoU(mut a: I) -> uI {
    return 9223372036854775808 as libc::c_ulonglong ^ a as uI;
}
pub unsafe extern "C" fn grade_updown(mut a: K, mut r: I) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: K = 0 as *mut k0;
    let mut y: uI = 0;
    let mut u: uI = 0;
    let mut v: uI = 0;
    let mut h: uI = 0;
    let mut k: uI = 0;
    let mut tmp___3: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___6: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    at___0 = (*a).t;
    an = (*a).n;
    if (0 as libc::c_longlong) < at___0 {
        tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if -(4 as libc::c_longlong) == at___0 {
        tmp___0 = symGrade(a, r);
        return tmp___0;
    }
    if -(3 as libc::c_longlong) == at___0 {
        tmp___1 = charGrade(a, r);
        return tmp___1;
    }
    's_671: {
        if !(-(1 as libc::c_longlong) == at___0) {
            if !(-(2 as libc::c_longlong) == at___0) {
                break 's_671;
            }
        }
        if an < 2 as libc::c_longlong {
            z = newK(-(1 as libc::c_int) as I, an);
            tmp___2 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
            if tmp___2 == 0 {
                return 0 as K;
            }
            i = 0 as libc::c_int as I;
            _i___0 = an;
            while i < _i___0 {
                *(((*z).k).as_mut_ptr() as *mut I).offset(i as isize) = i;
                i += 1;
            }
            return z;
        } else {
            x___0 = 0 as K;
            u = -(1 as libc::c_int) as uI;
            v = 0 as libc::c_int as uI;
            h = 0 as libc::c_int as uI;
            if -(2 as libc::c_longlong) == at___0 {
                x___0 = newK(-(1 as libc::c_int) as I, an);
                tmp___3 = OOM_CD(0 as libc::c_int as I, x___0, -(1 as libc::c_int) as V);
                if tmp___3 == 0 {
                    return 0 as K;
                }
            }
            if -(1 as libc::c_longlong) == at___0 {
                i___0 = 0 as libc::c_int as I;
                _i___1 = an;
                while i___0 < _i___1 {
                    y = *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize) as uI;
                    h |= y;
                    if y < u {
                        u = y;
                    }
                    if y > v {
                        v = y;
                    }
                    i___0 += 1;
                }
            } else {
                i___1 = 0 as libc::c_int as I;
                _i___2 = an;
                while i___1 < _i___2 {
                    tmp___4 = FtoI(
                        *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                    );
                    y = tmp___4 as uI;
                    *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i___1 as isize) = y;
                    h |= y;
                    if y < u {
                        u = y;
                    }
                    if y > v {
                        v = y;
                    }
                    i___1 += 1;
                }
            }
            let mut current_block_107: u64;
            if r != 0 {
                if -(1 as libc::c_longlong) == at___0 {
                    current_block_107 = 3789384218494840508;
                } else {
                    current_block_107 = 18332131926005604402;
                }
            } else {
                current_block_107 = 18332131926005604402;
            }
            match current_block_107 {
                18332131926005604402 => {
                    if u & 0x8000000000000000 as libc::c_ulonglong
                        != v & 0x8000000000000000 as libc::c_ulonglong
                    {
                        current_block_107 = 3789384218494840508;
                    } else {
                        current_block_107 = 4488496028633655612;
                    }
                }
                _ => {}
            }
            match current_block_107 {
                3789384218494840508 => {
                    u = -(1 as libc::c_int) as uI;
                    v = 0 as libc::c_int as uI;
                    h = 0 as libc::c_int as uI;
                    if -(1 as libc::c_longlong) == at___0 {
                        x___0 = newK(-(1 as libc::c_int) as I, an);
                        tmp___5 = OOM_CD(
                            0 as libc::c_int as I,
                            x___0,
                            -(1 as libc::c_int) as V,
                        );
                        if tmp___5 == 0 {
                            return 0 as K;
                        }
                        i___2 = 0 as libc::c_int as I;
                        _i___3 = an;
                        while i___2 < _i___3 {
                            y = ItoU(
                                *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize),
                            );
                            *(((*x___0).k).as_mut_ptr() as *mut uI)
                                .offset(i___2 as isize) = y;
                            h |= y;
                            if y < u {
                                u = y;
                            }
                            if y > v {
                                v = y;
                            }
                            i___2 += 1;
                        }
                    } else {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = an;
                        while i___3 < _i___4 {
                            y = ItoU(
                                *(((*x___0).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize),
                            );
                            *(((*x___0).k).as_mut_ptr() as *mut uI)
                                .offset(i___3 as isize) = y;
                            h |= y;
                            if y < u {
                                u = y;
                            }
                            if y > v {
                                v = y;
                            }
                            i___3 += 1;
                        }
                    }
                }
                _ => {}
            }
            k = v.wrapping_sub(u);
            if k == 0 {
                z = newK(-(1 as libc::c_int) as I, an);
                tmp___6 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
                if tmp___6 == 0 {
                    return 0 as K;
                }
                i___4 = 0 as libc::c_int as I;
                _i___5 = an;
                while i___4 < _i___5 {
                    *(((*z).k).as_mut_ptr() as *mut I).offset(i___4 as isize) = i___4;
                    i___4 += 1;
                }
            } else if an < 7 as libc::c_longlong {
                if !x___0.is_null() {
                    tmp___7 = x___0;
                } else {
                    tmp___7 = a;
                }
                z = insertGradeU(tmp___7, r);
            } else {
                let mut current_block_141: u64;
                if k < ((1 as libc::c_int) << 26 as libc::c_int) as uI {
                    if (9 as libc::c_longlong * an + 18 as libc::c_longlong) as uI
                        > (2 as libc::c_ulonglong).wrapping_mul(k)
                    {
                        if !x___0.is_null() {
                            tmp___8 = x___0;
                        } else {
                            tmp___8 = a;
                        }
                        z = distributionGrade(tmp___8, r, u, v);
                        current_block_141 = 248631179418912492;
                    } else {
                        current_block_141 = 16475220760498759834;
                    }
                } else {
                    current_block_141 = 16475220760498759834;
                }
                match current_block_141 {
                    16475220760498759834 => {
                        if !x___0.is_null() {
                            tmp___9 = x___0;
                        } else {
                            tmp___9 = a;
                        }
                        z = radixGrade(tmp___9, r, h);
                    }
                    _ => {}
                }
            }
            cd(x___0);
        }
        return z;
    }
    tmp___10 = mergeGrade(a, r);
    return tmp___10;
}
pub unsafe extern "C" fn grade_up(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = grade_updown(a, 0 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn grade_down(mut a: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    tmp = grade_updown(a, 1 as libc::c_int as I);
    return tmp;
}
pub unsafe extern "C" fn enlist(mut x___0: K) -> K {
    let mut t: I = 0;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    if 1 as libc::c_longlong <= (*x___0).t {
        if (*x___0).t <= 4 as libc::c_longlong {
            tmp = -(*x___0).t;
        } else {
            tmp = 0 as libc::c_int as I;
        }
    } else {
        tmp = 0 as libc::c_int as I;
    }
    t = tmp;
    tmp___0 = newK(t, 1 as libc::c_int as I);
    z = tmp___0;
    if -(4 as libc::c_longlong) == t {
        let ref mut fresh298 = *(((*z).k).as_mut_ptr() as *mut S);
        *fresh298 = *(((*x___0).k).as_mut_ptr() as *mut S);
    }
    if -(3 as libc::c_longlong) == t {
        *(((*z).k).as_mut_ptr() as *mut C) = *(((*x___0).k).as_mut_ptr() as *mut C);
    }
    if -(2 as libc::c_longlong) == t {
        *(((*z).k).as_mut_ptr() as *mut F) = *(((*x___0).k).as_mut_ptr() as *mut F);
    }
    if -(1 as libc::c_longlong) == t {
        *(((*z).k).as_mut_ptr() as *mut I) = *(((*x___0).k).as_mut_ptr() as *mut I);
    }
    if 0 as libc::c_longlong == t {
        let ref mut fresh299 = *((*z).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        *fresh299 = ci(x___0);
    }
    return z;
}
unsafe extern "C" fn charRange(mut a: K) -> K {
    let mut n: I = 0;
    let mut c: [I; 256] = [0; 256];
    let mut j: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: UC = 0;
    let mut tmp___1: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    n = (*a).n;
    j = 0 as libc::c_int as I;
    memset(
        c.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (256 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong),
    );
    tmp = newK(-(3 as libc::c_int) as I, n);
    z = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        x___0 = *(((*a).k).as_mut_ptr() as *mut C).offset(i as isize) as UC;
        if c[x___0 as usize] == 0 {
            c[x___0 as usize] = -(1 as libc::c_int) as I;
            tmp___1 = j;
            j += 1;
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(
                    tmp___1 as isize,
                ) = *(((*a).k).as_mut_ptr() as *mut C).offset(i as isize);
        }
        i += 1;
    }
    if n == j {
        return z;
    }
    tmp___2 = newK(-(3 as libc::c_int) as I, j);
    y = tmp___2;
    tmp___3 = OOM_CD(0 as libc::c_int as I, z, y, -(1 as libc::c_int) as V);
    if tmp___3 == 0 {
        return 0 as K;
    }
    memcpy(
        ((*y).k).as_mut_ptr() as *mut C as *mut libc::c_void,
        ((*z).k).as_mut_ptr() as *mut C as *const libc::c_void,
        (j as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<C>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    cd(z);
    return y;
}
unsafe extern "C" fn symRange(mut x___0: K) -> K {
    let mut j: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut s: S = 0 as *mut C;
    let mut tmp___1: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    j = 0 as libc::c_int as I;
    tmp = newK(-(4 as libc::c_int) as I, (*x___0).n);
    z = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    setS(2 as libc::c_int, 0 as libc::c_int as I);
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        s = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i as isize);
        if *(s as *mut I).offset(-(2 as libc::c_int) as isize) == 0 {
            *(s as *mut I)
                .offset(-(2 as libc::c_int) as isize) = -(1 as libc::c_int) as I;
            tmp___1 = j;
            j += 1;
            let ref mut fresh300 = *(((*z).k).as_mut_ptr() as *mut S)
                .offset(tmp___1 as isize);
            *fresh300 = s;
        }
        i += 1;
    }
    if (*x___0).n == j {
        return z;
    }
    tmp___2 = newK(-(4 as libc::c_int) as I, j);
    y = tmp___2;
    tmp___3 = OOM_CD(0 as libc::c_int as I, z, y, -(1 as libc::c_int) as V);
    if tmp___3 == 0 {
        return 0 as K;
    }
    memcpy(
        ((*y).k).as_mut_ptr() as *mut S as *mut libc::c_void,
        ((*z).k).as_mut_ptr() as *mut S as *const libc::c_void,
        (j as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<S>() as libc::c_ulong as libc::c_ulonglong,
            ) as size_t,
    );
    cd(z);
    return y;
}
unsafe extern "C" fn newH(mut n: I) -> K {
    let mut m: I = 0;
    let mut tmp: I = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    tmp = cl2(n);
    m = ((1 as libc::c_int) << 1 as libc::c_longlong + tmp) as I;
    tmp___0 = newK(-(1 as libc::c_int) as I, m);
    h = tmp___0;
    tmp___1 = OOM_CD(0 as libc::c_int as I, h, -(1 as libc::c_int) as V);
    if tmp___1 == 0 {
        return 0 as K;
    }
    return h;
}
unsafe extern "C" fn hg(mut h: K, mut hk: uI, mut k: I, mut p: *mut uI) -> I {
    let mut n: I = 0;
    let mut d___0: *mut I = 0 as *mut I;
    let mut u: uI = 0;
    n = (*h).n;
    d___0 = ((*h).k).as_mut_ptr() as *mut I;
    u = hk & (n - 1 as libc::c_longlong) as libc::c_ulonglong;
    while *d___0.offset(u as isize) != 0 {
        if k == *d___0.offset(u as isize) {
            *p = u;
            return k;
        }
        u = u.wrapping_add(1);
        if u == n as uI {
            u = 0 as libc::c_int as uI;
        }
    }
    *p = u;
    return 0 as libc::c_int as I;
}
static mut hcc: [uI; 8] = [
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
    0 as libc::c_int as uI,
];
unsafe extern "C" fn hcinit() {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    if hcc[0 as libc::c_int as usize] == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = 8 as libc::c_int as I;
        while i < _i___0 {
            hcc[i as usize] = genrand64_int64();
            i += 1;
        }
    }
}
unsafe extern "C" fn hc(mut u: uI) -> uint32_t {
    let mut i: I = 0;
    let mut _i___0: I = 0;
    i = 0 as libc::c_int as I;
    _i___0 = 8 as libc::c_int as I;
    while i < _i___0 {
        u ^= hcc[i as usize];
        u = (u as libc::c_ulonglong).wrapping_add(u >> 8 as libc::c_int) as uI as uI;
        i += 1;
    }
    return (u as uint32_t as libc::c_ulonglong ^ u >> 32 as libc::c_int) as uint32_t;
}
unsafe extern "C" fn intRange(mut x___0: K) -> K {
    let mut j: I = 0;
    let mut h0: I = 0;
    let mut sa: I = 0;
    let mut m: uI = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut v: uI = 0;
    let mut tmp___3: I = 0;
    let mut vsa: uI = 0;
    let mut u: uI = 0;
    let mut tmp___4: uint32_t = 0;
    let mut tmp___5: uI = 0;
    let mut p: uI = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    hcinit();
    j = 0 as libc::c_int as I;
    h0 = 0 as libc::c_int as I;
    sa = 0 as libc::c_int as I;
    m = 0 as libc::c_int as uI;
    tmp = newH((*x___0).n);
    h = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, h, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    tmp___1 = newK((*x___0).t, (*x___0).n);
    z = tmp___1;
    tmp___2 = OOM_CD(0 as libc::c_int as I, h, z, -(1 as libc::c_int) as V);
    if tmp___2 == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        m |= *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i as isize);
        i += 1;
    }
    if m != 0 {
        while m & 1 as libc::c_ulonglong == 0 {
            m >>= 1 as libc::c_int;
            sa += 1;
        }
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = (*x___0).n;
    while i___0 < _i___1 {
        v = *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i___0 as isize);
        if v == 0 {
            if h0 == 0 {
                h0 = 1 as libc::c_int as I;
                tmp___3 = j;
                j += 1;
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(tmp___3 as isize) = 0 as libc::c_int as I;
            }
        } else {
            vsa = v >> sa;
            if m < (*h).n as uI {
                tmp___5 = vsa;
            } else {
                tmp___4 = hc(vsa);
                tmp___5 = tmp___4 as uI;
            }
            u = tmp___5;
            tmp___7 = hg(h, u, vsa as I, &mut p);
            if tmp___7 == 0 {
                *(((*h).k).as_mut_ptr() as *mut I).offset(p as isize) = vsa as I;
                tmp___6 = j;
                j += 1;
                *(((*z).k).as_mut_ptr() as *mut I).offset(tmp___6 as isize) = v as I;
            }
        }
        i___0 += 1;
    }
    if !((*x___0).n == j) {
        tmp___8 = newK((*x___0).t, j);
        y = tmp___8;
        if !y.is_null() {
            memcpy(
                ((*y).k).as_mut_ptr() as *mut I as *mut libc::c_void,
                ((*z).k).as_mut_ptr() as *mut I as *const libc::c_void,
                (j as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                    ) as size_t,
            );
            cd(z);
            z = y;
        }
    }
    cd(h);
    return z;
}
unsafe extern "C" fn KEQ(mut a: K, mut b___1: K) -> I {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut A: I = 0;
    let mut tmp: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___0: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___1: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if at___0 < 0 as libc::c_longlong {
        tmp = -at___0;
    } else {
        tmp = at___0;
    }
    A = tmp;
    if at___0 != bt {
        return 0 as libc::c_int as I;
    }
    if an != bn {
        return 0 as libc::c_int as I;
    }
    if 7 as libc::c_longlong == A {
        return 0 as libc::c_int as I
    } else {
        if 6 as libc::c_longlong == A {
            return 1 as libc::c_int as I
        } else {
            if 5 as libc::c_longlong == A {
                return 0 as libc::c_int as I
            } else {
                if 4 as libc::c_longlong == A {
                    i = 0 as libc::c_int as I;
                    _i___0 = an;
                    while i < _i___0 {
                        if *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize)
                            as libc::c_ulong
                            != *(((*b___1).k).as_mut_ptr() as *mut S).offset(i as isize)
                                as libc::c_ulong
                        {
                            return 0 as libc::c_int as I;
                        }
                        i += 1;
                    }
                } else if 3 as libc::c_longlong == A {
                    i___0 = 0 as libc::c_int as I;
                    _i___1 = an;
                    while i___0 < _i___1 {
                        if *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize)
                            as libc::c_int
                            != *(((*b___1).k).as_mut_ptr() as *mut C)
                                .offset(i___0 as isize) as libc::c_int
                        {
                            return 0 as libc::c_int as I;
                        }
                        i___0 += 1;
                    }
                } else if 2 as libc::c_longlong == A {
                    i___1 = 0 as libc::c_int as I;
                    _i___2 = an;
                    while i___1 < _i___2 {
                        tmp___0 = FC(
                            *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                            *(((*b___1).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                        );
                        if tmp___0 != 0 {
                            return 0 as libc::c_int as I;
                        }
                        i___1 += 1;
                    }
                } else if 1 as libc::c_longlong == A {
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = an;
                    while i___2 < _i___3 {
                        if *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize)
                            != *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(i___2 as isize)
                        {
                            return 0 as libc::c_int as I;
                        }
                        i___2 += 1;
                    }
                } else if 0 as libc::c_longlong == A {
                    i___3 = 0 as libc::c_int as I;
                    _i___4 = an;
                    while i___3 < _i___4 {
                        tmp___1 = KEQ(
                            *((*a).k).as_mut_ptr().offset(i___3 as isize),
                            *((*b___1).k).as_mut_ptr().offset(i___3 as isize),
                        );
                        if tmp___1 == 0 {
                            return 0 as libc::c_int as I;
                        }
                        i___3 += 1;
                    }
                }
            }
        }
    }
    return 1 as libc::c_int as I;
}
unsafe extern "C" fn shg(mut sh: K, mut hk: uI, mut k: K, mut p: *mut uI) -> K {
    let mut n: I = 0;
    let mut d___0: *mut K = 0 as *mut K;
    let mut u: uI = 0;
    let mut tmp: I = 0;
    n = (*sh).n;
    d___0 = ((*sh).k).as_mut_ptr();
    u = hk & (n - 1 as libc::c_longlong) as libc::c_ulonglong;
    while !(*d___0.offset(u as isize)).is_null() {
        tmp = KEQ(k, *d___0.offset(u as isize));
        if tmp != 0 {
            *p = u;
            return k;
        }
        u = u.wrapping_add(1);
        if u == n as uI {
            u = 0 as libc::c_int as uI;
        }
    }
    *p = u;
    return 0 as K;
}
pub unsafe extern "C" fn fnv1a(mut x___0: *mut UC, mut n: I) -> uint32_t {
    let mut h: uint32_t = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    h = 2166136261 as libc::c_ulong as uint32_t;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        h ^= *x___0.offset(i as isize) as libc::c_uint;
        h = (h as libc::c_ulong).wrapping_mul(16777619 as libc::c_ulong) as uint32_t;
        i += 1;
    }
    return h;
}
unsafe extern "C" fn hcode(mut x___0: K) -> UI {
    let mut t: I = 0;
    let mut tmp: I = 0;
    let mut u: uI = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut v: S = 0 as *mut C;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: uint32_t = 0;
    let mut tmp___2: uint32_t = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut v___0: uI = 0;
    let mut tmp___3: uint32_t = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut v___1: K = 0 as *mut k0;
    let mut tmp___4: UI = 0;
    if (*x___0).t < 0 as libc::c_longlong {
        tmp = -(*x___0).t;
    } else {
        tmp = (*x___0).t;
    }
    t = tmp;
    u = 0 as libc::c_int as uI;
    match t {
        7 => return t as UI,
        6 => return &mut NIL as *mut K as UI,
        5 => return t as UI,
        4 => {
            i = 0 as libc::c_int as I;
            _i___0 = (*x___0).n;
            while i < _i___0 {
                v = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i as isize);
                if *(v as *mut I).offset(-(1 as libc::c_int) as isize) == 0 {
                    tmp___0 = strlen(v as *const libc::c_char);
                    tmp___1 = fnv1a(v as *mut UC, tmp___0 as I);
                    *(v as *mut I).offset(-(1 as libc::c_int) as isize) = tmp___1 as I;
                }
                u = (u as libc::c_ulonglong)
                    .wrapping_add(
                        *(v as *mut I).offset(-(1 as libc::c_int) as isize) as uI,
                    ) as uI as uI;
                i += 1;
            }
            return ((*x___0).t as uI).wrapping_add(u);
        }
        3 => {
            tmp___2 = fnv1a(((*x___0).k).as_mut_ptr() as *mut C as *mut UC, (*x___0).n);
            return ((*x___0).t + tmp___2 as I) as UI;
        }
        2 | 1 => {
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*x___0).n;
            while i___0 < _i___1 {
                v___0 = *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___0 as isize)
                    as uI;
                tmp___3 = hc(v___0);
                u = (u as libc::c_ulonglong).wrapping_add(tmp___3 as uI) as uI as uI;
                i___0 += 1;
            }
            return ((*x___0).t as uI).wrapping_add(u);
        }
        0 => {
            i___1 = 0 as libc::c_int as I;
            _i___2 = (*x___0).n;
            while i___1 < _i___2 {
                v___1 = *((*x___0).k).as_mut_ptr().offset(i___1 as isize);
                tmp___4 = hcode(v___1);
                u = (u as libc::c_ulonglong).wrapping_add(tmp___4) as uI as uI;
                i___1 += 1;
            }
            return u;
        }
        _ => {}
    }
    return 0 as libc::c_int as UI;
}
unsafe extern "C" fn listRange(mut x___0: K) -> K {
    let mut j: I = 0;
    let mut sh: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut p: uI = 0;
    let mut kv: K = 0 as *mut k0;
    let mut u: uI = 0;
    let mut tmp___3: UI = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    hcinit();
    j = 0 as libc::c_int as I;
    setS(1 as libc::c_int, 0 as libc::c_int as I);
    tmp = newH((*x___0).n);
    sh = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, sh, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    tmp___1 = newK((*x___0).t, (*x___0).n);
    z = tmp___1;
    tmp___2 = OOM_CD(0 as libc::c_int as I, sh, z, -(1 as libc::c_int) as V);
    if tmp___2 == 0 {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        kv = *((*x___0).k).as_mut_ptr().offset(i as isize);
        tmp___3 = hcode(kv);
        u = tmp___3;
        tmp___5 = shg(sh, u, kv, &mut p);
        if tmp___5.is_null() {
            let ref mut fresh301 = *((*sh).k).as_mut_ptr().offset(p as isize);
            *fresh301 = kv;
            tmp___4 = j;
            j += 1;
            let ref mut fresh302 = *((*z).k).as_mut_ptr().offset(tmp___4 as isize);
            *fresh302 = ci(kv);
        }
        i += 1;
    }
    if !((*x___0).n == j) {
        tmp___6 = newK((*x___0).t, j);
        y = tmp___6;
        if !y.is_null() {
            i___0 = 0 as libc::c_int as I;
            _i___1 = j;
            while i___0 < _i___1 {
                let ref mut fresh303 = *((*y).k).as_mut_ptr().offset(i___0 as isize);
                *fresh303 = ci(*((*z).k).as_mut_ptr().offset(i___0 as isize));
                i___0 += 1;
            }
            cd(z);
            z = y;
        }
    }
    cd(sh);
    return z;
}
pub unsafe extern "C" fn range(mut a: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut k: K = 0 as *mut k0;
    let mut u: I = 0;
    let mut h: *mut I = 0 as *mut I;
    let mut m: *mut I = 0 as *mut I;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___4: I = 0;
    let mut x___0: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___5: I = 0;
    t = (*a).t;
    n = (*a).n;
    z = 0 as K;
    g = 0 as K;
    k = 0 as K;
    u = n;
    h = 0 as *mut I;
    m = 0 as *mut I;
    if t > 0 as libc::c_longlong {
        tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    match -t {
        0 => {
            tmp___0 = listRange(a);
            return tmp___0;
        }
        1 | 2 => {
            tmp___1 = intRange(a);
            return tmp___1;
        }
        3 => {
            tmp___2 = charRange(a);
            return tmp___2;
        }
        4 => {
            tmp___3 = symRange(a);
            return tmp___3;
        }
        _ => {}
    }
    g = grade_up(a);
    if !g.is_null() {
        h = ((*g).k).as_mut_ptr() as *mut I;
        k = newK(-(1 as libc::c_int) as I, n);
        if !k.is_null() {
            m = ((*k).k).as_mut_ptr() as *mut I;
            i = 0 as libc::c_int as I;
            _i___0 = n;
            while i < _i___0 {
                *m.offset(*h.offset(i as isize) as isize) = i;
                i += 1;
            }
            i___0 = 0 as libc::c_int as I;
            _i___1 = n - 1 as libc::c_longlong;
            while i___0 < _i___1 {
                tmp___4 = matchI(
                    *((*a).k)
                        .as_mut_ptr()
                        .offset(
                            *h.offset((n - i___0 - 1 as libc::c_longlong) as isize)
                                as isize,
                        ),
                    *((*a).k)
                        .as_mut_ptr()
                        .offset(
                            *h.offset((n - i___0 - 2 as libc::c_longlong) as isize)
                                as isize,
                        ),
                );
                if tmp___4 != 0 {
                    *h
                        .offset(
                            (n - i___0 - 1 as libc::c_longlong) as isize,
                        ) = -(1 as libc::c_int) as I;
                    u -= 1;
                }
                i___0 += 1;
            }
            z = newK(t, u);
            if !z.is_null() {
                x___0 = 0 as libc::c_int as I;
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    if *h.offset(*m.offset(i___1 as isize) as isize)
                        > -(1 as libc::c_longlong)
                    {
                        tmp___5 = x___0;
                        x___0 += 1;
                        let ref mut fresh304 = *((*z).k)
                            .as_mut_ptr()
                            .offset(tmp___5 as isize);
                        *fresh304 = ci(
                            *((*a).k)
                                .as_mut_ptr()
                                .offset(
                                    *h.offset(*m.offset(i___1 as isize) as isize) as isize,
                                ),
                        );
                    }
                    i___1 += 1;
                }
            }
        }
    }
    cd(k);
    cd(g);
    return z;
}
unsafe extern "C" fn charGroup(mut x___0: K) -> K {
    let mut h: [I; 256] = [0; 256];
    let mut c: [I; 256] = [0; 256];
    let mut j: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut u: UC = 0;
    let mut w___0: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut u___0: UC = 0;
    let mut w___1: I = 0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    trst();
    j = 0 as libc::c_int as I;
    memset(
        h.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (256 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong),
    );
    memset(
        c.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (256 as libc::c_ulong).wrapping_mul(::std::mem::size_of::<I>() as libc::c_ulong),
    );
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        u = *(((*x___0).k).as_mut_ptr() as *mut C).offset(i as isize) as UC;
        if h[u as usize] == 0 {
            j += 1;
            h[u as usize] = j;
        }
        w___0 = h[u as usize] - 1 as libc::c_longlong;
        c[w___0 as usize] += 1;
        i += 1;
    }
    tmp = newK(0 as libc::c_int as I, j);
    y = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, y, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = j;
    while i___0 < _i___1 {
        tmp___1 = newK(-(1 as libc::c_int) as I, c[i___0 as usize]);
        z = tmp___1;
        tmp___2 = OOM_CD(0 as libc::c_int as I, z, y, -(1 as libc::c_int) as V);
        if tmp___2 == 0 {
            return 0 as K;
        }
        let ref mut fresh305 = *((*y).k).as_mut_ptr().offset(i___0 as isize);
        *fresh305 = z;
        c[i___0 as usize] = 0 as libc::c_int as I;
        i___0 += 1;
    }
    i___1 = 0 as libc::c_int as I;
    _i___2 = (*x___0).n;
    while i___1 < _i___2 {
        u___0 = *(((*x___0).k).as_mut_ptr() as *mut C).offset(i___1 as isize) as UC;
        w___1 = h[u___0 as usize] - 1 as libc::c_longlong;
        z___0 = *((*y).k).as_mut_ptr().offset(w___1 as isize);
        tmp___3 = c[w___1 as usize];
        c[w___1 as usize] += 1;
        *(((*z___0).k).as_mut_ptr() as *mut I).offset(tmp___3 as isize) = i___1;
        i___1 += 1;
    }
    return y;
}
unsafe extern "C" fn symGroup(mut x___0: K) -> K {
    let mut j: I = 0;
    let mut uk: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut u: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut s: S = 0 as *mut C;
    let mut y: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut s___0: S = 0 as *mut C;
    let mut z: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut s___1: S = 0 as *mut C;
    let mut w___0: I = 0;
    let mut z___0: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    j = 0 as libc::c_int as I;
    tmp = newK(-(1 as libc::c_int) as I, (*x___0).n);
    uk = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, uk, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    u = ((*uk).k).as_mut_ptr() as *mut I;
    setS(1 as libc::c_int, 0 as libc::c_int as I);
    setS(2 as libc::c_int, 0 as libc::c_int as I);
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        s = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i as isize);
        if *(s as *mut I).offset(-(2 as libc::c_int) as isize) == 0 {
            *u.offset(j as isize) = s as L;
            j += 1;
            *(s as *mut I).offset(-(2 as libc::c_int) as isize) = j;
        }
        let ref mut fresh306 = *(s as *mut I).offset(-(1 as libc::c_int) as isize);
        *fresh306 += 1;
        i += 1;
    }
    tmp___1 = newK(0 as libc::c_int as I, j);
    y = tmp___1;
    tmp___2 = OOM_CD(0 as libc::c_int as I, y, uk, -(1 as libc::c_int) as V);
    if tmp___2 == 0 {
        return 0 as K;
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = j;
    while i___0 < _i___1 {
        s___0 = *u.offset(i___0 as isize) as S;
        tmp___3 = newK(
            -(1 as libc::c_int) as I,
            *(s___0 as *mut I).offset(-(1 as libc::c_int) as isize),
        );
        z = tmp___3;
        tmp___4 = OOM_CD(0 as libc::c_int as I, z, y, uk, -(1 as libc::c_int) as V);
        if tmp___4 == 0 {
            return 0 as K;
        }
        let ref mut fresh307 = *((*y).k).as_mut_ptr().offset(i___0 as isize);
        *fresh307 = z;
        *u.offset(i___0 as isize) = 0 as libc::c_int as I;
        i___0 += 1;
    }
    i___1 = 0 as libc::c_int as I;
    _i___2 = (*x___0).n;
    while i___1 < _i___2 {
        s___1 = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i___1 as isize);
        w___0 = *(s___1 as *mut I).offset(-(2 as libc::c_int) as isize)
            - 1 as libc::c_longlong;
        z___0 = *((*y).k).as_mut_ptr().offset(w___0 as isize);
        tmp___5 = *u.offset(w___0 as isize);
        let ref mut fresh308 = *u.offset(w___0 as isize);
        *fresh308 += 1;
        *(((*z___0).k).as_mut_ptr() as *mut I).offset(tmp___5 as isize) = i___1;
        i___1 += 1;
    }
    cd(uk);
    return y;
}
unsafe extern "C" fn groupI(mut x___0: K, mut y: K, mut n: I) -> K {
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut v: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut w___0: I = 0;
    let mut v___0: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut v___1: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut w___1: I = 0;
    let mut v___2: K = 0 as *mut k0;
    let mut tmp___6: I = 0;
    tmp = newK(0 as libc::c_int as I, n);
    z = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, z, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    c = ((*y).k).as_mut_ptr() as *mut I;
    if n < 65537 as libc::c_longlong {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            tmp___1 = newK(-(1 as libc::c_int) as I, *c.offset(i as isize));
            v = tmp___1;
            tmp___2 = OOM_CD(0 as libc::c_int as I, v, z, -(1 as libc::c_int) as V);
            if tmp___2 == 0 {
                return 0 as K;
            }
            let ref mut fresh309 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh309 = v;
            *c.offset(i as isize) = 0 as libc::c_int as I;
            i += 1;
        }
        i___0 = 0 as libc::c_int as I;
        _i___1 = (*x___0).n;
        while i___0 < _i___1 {
            w___0 = *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            v___0 = *((*z).k).as_mut_ptr().offset(w___0 as isize);
            tmp___3 = *c.offset(w___0 as isize);
            let ref mut fresh310 = *c.offset(w___0 as isize);
            *fresh310 += 1;
            *(((*v___0).k).as_mut_ptr() as *mut I).offset(tmp___3 as isize) = i___0;
            i___0 += 1;
        }
    } else {
        i___1 = 0 as libc::c_int as I;
        _i___2 = n;
        while i___1 < _i___2 {
            tmp___4 = newK(-(1 as libc::c_int) as I, *c.offset(i___1 as isize));
            v___1 = tmp___4;
            tmp___5 = OOM_CD(0 as libc::c_int as I, v___1, z, -(1 as libc::c_int) as V);
            if tmp___5 == 0 {
                return 0 as K;
            }
            let ref mut fresh311 = *((*z).k).as_mut_ptr().offset(i___1 as isize);
            *fresh311 = v___1;
            (*v___1).n = 0 as libc::c_int as I;
            i___1 += 1;
        }
        i___2 = 0 as libc::c_int as I;
        _i___3 = (*x___0).n;
        while i___2 < _i___3 {
            w___1 = *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
            v___2 = *((*z).k).as_mut_ptr().offset(w___1 as isize);
            tmp___6 = (*v___2).n;
            (*v___2).n += 1;
            *(((*v___2).k).as_mut_ptr() as *mut I).offset(tmp___6 as isize) = i___2;
            i___2 += 1;
        }
    }
    cd(y);
    cd(x___0);
    return z;
}
unsafe extern "C" fn intGroup(mut x___0: K) -> K {
    let mut j: I = 0;
    let mut h0: I = 0;
    let mut sa: I = 0;
    let mut m: uI = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut ok: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut o: *mut I = 0 as *mut I;
    let mut xok: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut xo: *mut I = 0 as *mut I;
    let mut ck: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut v: uI = 0;
    let mut u: uI = 0;
    let mut tmp___7: uint32_t = 0;
    let mut tmp___8: uI = 0;
    let mut p: uI = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut w___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    hcinit();
    j = 0 as libc::c_int as I;
    h0 = 0 as libc::c_int as I;
    sa = 0 as libc::c_int as I;
    m = 0 as libc::c_int as uI;
    tmp = newH((*x___0).n);
    h = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, h, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    tmp___1 = newK(-(1 as libc::c_int) as I, (*h).n);
    ok = tmp___1;
    tmp___2 = OOM_CD(0 as libc::c_int as I, ok, h, -(1 as libc::c_int) as V);
    if tmp___2 == 0 {
        return 0 as K;
    }
    o = ((*ok).k).as_mut_ptr() as *mut I;
    tmp___3 = newK(-(1 as libc::c_int) as I, (*x___0).n);
    xok = tmp___3;
    tmp___4 = OOM_CD(0 as libc::c_int as I, xok, ok, h, -(1 as libc::c_int) as V);
    if tmp___4 == 0 {
        return 0 as K;
    }
    xo = ((*xok).k).as_mut_ptr() as *mut I;
    tmp___5 = newK(-(1 as libc::c_int) as I, (*x___0).n);
    ck = tmp___5;
    tmp___6 = OOM_CD(0 as libc::c_int as I, ck, xok, ok, h, -(1 as libc::c_int) as V);
    if tmp___6 == 0 {
        return 0 as K;
    }
    c = ((*ck).k).as_mut_ptr() as *mut I;
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        m |= *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i as isize);
        i += 1;
    }
    if m != 0 {
        while m & 1 as libc::c_ulonglong == 0 {
            m >>= 1 as libc::c_int;
            sa += 1;
        }
    }
    i___0 = 0 as libc::c_int as I;
    _i___1 = (*x___0).n;
    while i___0 < _i___1 {
        v = *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i___0 as isize);
        if v == 0 {
            if h0 == 0 {
                j += 1;
                h0 = j;
            }
            *xo.offset(i___0 as isize) = h0 - 1 as libc::c_longlong;
            let ref mut fresh312 = *c.offset((h0 - 1 as libc::c_longlong) as isize);
            *fresh312 += 1;
        } else {
            v >>= sa;
            if m < (*h).n as uI {
                tmp___8 = v;
            } else {
                tmp___7 = hc(v);
                tmp___8 = tmp___7 as uI;
            }
            u = tmp___8;
            tmp___10 = hg(h, u, v as I, &mut p);
            if tmp___10 == 0 {
                *(((*h).k).as_mut_ptr() as *mut I).offset(p as isize) = v as I;
                tmp___9 = j;
                j += 1;
                *o.offset(p as isize) = tmp___9;
            }
            w___0 = *o.offset(p as isize);
            *xo.offset(i___0 as isize) = w___0;
            let ref mut fresh313 = *c.offset(w___0 as isize);
            *fresh313 += 1;
        }
        i___0 += 1;
    }
    cd(ok);
    cd(h);
    tmp___11 = groupI(xok, ck, j);
    z = tmp___11;
    return z;
}
unsafe extern "C" fn listGroup(mut x___0: K) -> K {
    let mut j: I = 0;
    let mut h: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut ok: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut o: *mut I = 0 as *mut I;
    let mut xok: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut xo: *mut I = 0 as *mut I;
    let mut ck: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut tmp___6: I = 0;
    let mut c: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut v: K = 0 as *mut k0;
    let mut u: uI = 0;
    let mut tmp___7: UI = 0;
    let mut p: uI = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut w___0: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    hcinit();
    j = 0 as libc::c_int as I;
    tmp = newH((*x___0).n);
    h = tmp;
    tmp___0 = OOM_CD(0 as libc::c_int as I, h, -(1 as libc::c_int) as V);
    if tmp___0 == 0 {
        return 0 as K;
    }
    tmp___1 = newK(-(1 as libc::c_int) as I, (*h).n);
    ok = tmp___1;
    tmp___2 = OOM_CD(0 as libc::c_int as I, ok, h, -(1 as libc::c_int) as V);
    if tmp___2 == 0 {
        return 0 as K;
    }
    o = ((*ok).k).as_mut_ptr() as *mut I;
    tmp___3 = newK(-(1 as libc::c_int) as I, (*x___0).n);
    xok = tmp___3;
    tmp___4 = OOM_CD(0 as libc::c_int as I, xok, ok, h, -(1 as libc::c_int) as V);
    if tmp___4 == 0 {
        return 0 as K;
    }
    xo = ((*xok).k).as_mut_ptr() as *mut I;
    tmp___5 = newK(-(1 as libc::c_int) as I, (*x___0).n);
    ck = tmp___5;
    tmp___6 = OOM_CD(0 as libc::c_int as I, ck, xok, ok, h, -(1 as libc::c_int) as V);
    if tmp___6 == 0 {
        return 0 as K;
    }
    c = ((*ck).k).as_mut_ptr() as *mut I;
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        v = *((*x___0).k).as_mut_ptr().offset(i as isize);
        tmp___7 = hcode(v);
        u = tmp___7;
        tmp___9 = shg(h, u, v, &mut p);
        if tmp___9.is_null() {
            let ref mut fresh314 = *((*h).k).as_mut_ptr().offset(p as isize);
            *fresh314 = v;
            tmp___8 = j;
            j += 1;
            *o.offset(p as isize) = tmp___8;
        }
        w___0 = *o.offset(p as isize);
        *xo.offset(i as isize) = w___0;
        let ref mut fresh315 = *c.offset(w___0 as isize);
        *fresh315 += 1;
        i += 1;
    }
    cd(ok);
    cd(h);
    tmp___10 = groupI(xok, ck, j);
    z = tmp___10;
    return z;
}
pub unsafe extern "C" fn group(mut x___0: K) -> K {
    let mut t: I = 0;
    let mut n: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut u: I = 0;
    let mut g: *mut I = 0 as *mut I;
    let mut h: *mut I = 0 as *mut I;
    let mut z: K = 0 as *mut k0;
    let mut b___1: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut k: I = 0;
    let mut p: I = 0;
    let mut v: I = 0;
    let mut s: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    t = (*x___0).t;
    n = (*x___0).n;
    if t > 0 as libc::c_longlong {
        tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    u = n;
    z = 0 as K;
    b___1 = 0 as K;
    c = 0 as K;
    match -t {
        0 => {
            tmp___0 = listGroup(x___0);
            return tmp___0;
        }
        1 | 2 => {
            tmp___1 = intGroup(x___0);
            return tmp___1;
        }
        3 => {
            tmp___2 = charGroup(x___0);
            return tmp___2;
        }
        4 => {
            tmp___3 = symGroup(x___0);
            return tmp___3;
        }
        _ => {}
    }
    b___1 = grade_up(x___0);
    tmp___4 = OOM_CD(0 as libc::c_int as I, b___1, -(1 as libc::c_int) as V);
    if tmp___4 == 0 {
        return 0 as K;
    }
    g = ((*b___1).k).as_mut_ptr() as *mut I;
    c = newK(-(1 as libc::c_int) as I, n);
    tmp___5 = OOM_CD(0 as libc::c_int as I, b___1, c, -(1 as libc::c_int) as V);
    if tmp___5 == 0 {
        return 0 as K;
    }
    h = ((*c).k).as_mut_ptr() as *mut I;
    i = 0 as libc::c_int as I;
    _i___0 = n;
    while i < _i___0 {
        *h.offset(*g.offset(i as isize) as isize) = i;
        i += 1;
    }
    if 0 as libc::c_longlong == t {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n - 1 as libc::c_longlong;
        while i___0 < _i___1 {
            tmp___6 = matchI(
                *((*x___0).k)
                    .as_mut_ptr()
                    .offset(
                        *g.offset((n - i___0 - 1 as libc::c_longlong) as isize) as isize,
                    ),
                *((*x___0).k)
                    .as_mut_ptr()
                    .offset(
                        *g.offset((n - i___0 - 2 as libc::c_longlong) as isize) as isize,
                    ),
            );
            if tmp___6 != 0 {
                u -= 1;
                let ref mut fresh316 = *g
                    .offset((n - i___0 - 1 as libc::c_longlong) as isize);
                *fresh316 *= -(1 as libc::c_longlong);
            }
            i___0 += 1;
        }
    }
    z = newK(0 as libc::c_int as I, u);
    tmp___7 = OOM_CD(0 as libc::c_int as I, b___1, c, z, -(1 as libc::c_int) as V);
    if tmp___7 == 0 {
        return 0 as K;
    }
    k = 0 as libc::c_int as I;
    p = 0 as libc::c_int as I;
    while p < n {
        if !(k < u) {
            break;
        }
        v = 1 as libc::c_int as I;
        while p + v < n {
            if !(*g.offset((*h.offset(p as isize) + v) as isize) < 0 as libc::c_longlong)
            {
                break;
            }
            v += 1;
        }
        tmp___8 = newK(-(1 as libc::c_int) as I, v);
        s = tmp___8;
        tmp___9 = OOM_CD(
            0 as libc::c_int as I,
            b___1,
            c,
            z,
            s,
            -(1 as libc::c_int) as V,
        );
        if tmp___9 == 0 {
            return 0 as K;
        }
        i___1 = 0 as libc::c_int as I;
        _i___2 = v;
        while i___1 < _i___2 {
            if *g.offset((*h.offset(p as isize) + i___1) as isize)
                < 0 as libc::c_longlong
            {
                *(((*s).k).as_mut_ptr() as *mut I)
                    .offset(
                        i___1 as isize,
                    ) = -*g.offset((*h.offset(p as isize) + i___1) as isize);
            } else {
                *(((*s).k).as_mut_ptr() as *mut I)
                    .offset(
                        i___1 as isize,
                    ) = *g.offset((*h.offset(p as isize) + i___1) as isize);
            }
            i___1 += 1;
        }
        let ref mut fresh317 = *((*z).k).as_mut_ptr().offset(k as isize);
        *fresh317 = s;
        loop {
            p += 1;
            if !(p < n) {
                break;
            }
            if !(*g.offset(*h.offset(p as isize) as isize) < 0 as libc::c_longlong) {
                break;
            }
        }
        k += 1;
    }
    cd(b___1);
    cd(c);
    return z;
}
pub unsafe extern "C" fn VAT(mut i: I) -> I {
    let mut tmp: I = 0;
    if 1 as libc::c_longlong <= i {
        if i <= 4 as libc::c_longlong {
            tmp = i;
        } else {
            tmp = 0 as libc::c_int as I;
        }
    } else {
        tmp = 0 as libc::c_int as I;
    }
    return tmp;
}
pub unsafe extern "C" fn flip(mut a: K) -> K {
    let mut x___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut p: I = 0;
    let mut q: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut c: *mut K = 0 as *mut K;
    let mut d___0: K = 0 as *mut k0;
    let mut u: I = 0;
    let mut t: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    let mut tmp___12: I = 0;
    let mut tmp___13: I = 0;
    let mut tmp___14: I = 0;
    let mut tmp___15: I = 0;
    let mut tmp___17: I = 0;
    let mut tmp___18: I = 0;
    let mut tmp___19: I = 0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut tmp___42: I = 0;
    let mut tmp___43: I = 0;
    let mut tmp___44: I = 0;
    let mut tmp___46: I = 0;
    let mut tmp___47: I = 0;
    let mut tmp___48: I = 0;
    let mut tmp___49: I = 0;
    let mut tmp___51: I = 0;
    let mut tmp___52: I = 0;
    let mut tmp___53: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___54: *mut k0 = 0 as *mut k0;
    let mut j___0: I = 0;
    let mut _j___0: I = 0;
    let mut j___1: I = 0;
    let mut _j___1: I = 0;
    let mut j___2: I = 0;
    let mut _j___2: I = 0;
    let mut j___3: I = 0;
    let mut _j___3: I = 0;
    let mut j___4: I = 0;
    let mut _j___4: I = 0;
    p = (*a).n;
    q = -(1 as libc::c_int) as I;
    if (*a).t != 0 {
        tmp = ci(a);
        return tmp;
    } else {
        if p == 0 {
            tmp = ci(a);
            return tmp;
        }
    }
    i___0 = 0 as libc::c_int as I;
    _i___0 = p;
    while i___0 < _i___0 {
        x___0 = *((*a).k).as_mut_ptr().offset(i___0 as isize);
        if (*x___0).t < 1 as libc::c_longlong {
            q = (*x___0).n;
        }
        i___0 += 1;
    }
    if -(1 as libc::c_longlong) == q {
        tmp___0 = ci(a);
        return tmp___0;
    }
    i___1 = 0 as libc::c_int as I;
    _i___1 = p;
    while i___1 < _i___1 {
        x___0 = *((*a).k).as_mut_ptr().offset(i___1 as isize);
        if (*x___0).t < 1 as libc::c_longlong {
            if (*x___0).n != q {
                tmp___1 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___1;
            }
        }
        i___1 += 1;
    }
    tmp___2 = newK(0 as libc::c_int as I, q);
    z = tmp___2;
    i = 0 as libc::c_int as I;
    while i < q {
        c = ((*a).k).as_mut_ptr();
        d___0 = *c.offset(0 as libc::c_int as isize);
        if (*d___0).t != 0 {
            tmp___19 = (*d___0).t;
        } else {
            u = (**((*d___0).k).as_mut_ptr().offset(i as isize)).t;
            tmp___18 = VAT(u);
            if tmp___18 != 0 {
                tmp___17 = u;
            } else {
                tmp___17 = 0 as libc::c_int as I;
            }
            tmp___19 = tmp___17;
        }
        if tmp___19 < 0 as libc::c_longlong {
            if (*d___0).t != 0 {
                tmp___10 = (*d___0).t;
            } else {
                u = (**((*d___0).k).as_mut_ptr().offset(i as isize)).t;
                tmp___9 = VAT(u);
                if tmp___9 != 0 {
                    tmp___8 = u;
                } else {
                    tmp___8 = 0 as libc::c_int as I;
                }
                tmp___10 = tmp___8;
            }
            tmp___15 = -tmp___10;
        } else {
            if (*d___0).t != 0 {
                tmp___14 = (*d___0).t;
            } else {
                u = (**((*d___0).k).as_mut_ptr().offset(i as isize)).t;
                tmp___13 = VAT(u);
                if tmp___13 != 0 {
                    tmp___12 = u;
                } else {
                    tmp___12 = 0 as libc::c_int as I;
                }
                tmp___14 = tmp___12;
            }
            tmp___15 = tmp___14;
        }
        t = -tmp___15;
        j = 0 as libc::c_int as I;
        _j = p;
        while j < _j {
            d___0 = *c.offset(j as isize);
            if (*d___0).t != 0 {
                tmp___53 = (*d___0).t;
            } else {
                u = (**((*d___0).k).as_mut_ptr().offset(i as isize)).t;
                tmp___52 = VAT(u);
                if tmp___52 != 0 {
                    tmp___51 = u;
                } else {
                    tmp___51 = 0 as libc::c_int as I;
                }
                tmp___53 = tmp___51;
            }
            if tmp___53 < 0 as libc::c_longlong {
                if (*d___0).t != 0 {
                    tmp___44 = (*d___0).t;
                } else {
                    u = (**((*d___0).k).as_mut_ptr().offset(i as isize)).t;
                    tmp___43 = VAT(u);
                    if tmp___43 != 0 {
                        tmp___42 = u;
                    } else {
                        tmp___42 = 0 as libc::c_int as I;
                    }
                    tmp___44 = tmp___42;
                }
                tmp___49 = -tmp___44;
            } else {
                if (*d___0).t != 0 {
                    tmp___48 = (*d___0).t;
                } else {
                    u = (**((*d___0).k).as_mut_ptr().offset(i as isize)).t;
                    tmp___47 = VAT(u);
                    if tmp___47 != 0 {
                        tmp___46 = u;
                    } else {
                        tmp___46 = 0 as libc::c_int as I;
                    }
                    tmp___48 = tmp___46;
                }
                tmp___49 = tmp___48;
            }
            if t == -tmp___49 {
                t = t;
            } else {
                t = 0 as libc::c_int as I;
            }
            j += 1;
        }
        tmp___54 = newK(t, p);
        let ref mut fresh318 = *((*z).k).as_mut_ptr().offset(i as isize);
        *fresh318 = tmp___54;
        y = tmp___54;
        if -(4 as libc::c_longlong) == t {
            j___0 = 0 as libc::c_int as I;
            _j___0 = p;
            while j___0 < _j___0 {
                d___0 = *c.offset(j___0 as isize);
                if (*d___0).t != 0 {
                    let ref mut fresh319 = *(((*y).k).as_mut_ptr() as *mut S)
                        .offset(j___0 as isize);
                    *fresh319 = *(((*d___0).k).as_mut_ptr() as *mut S)
                        .offset((i % (*d___0).n) as isize);
                } else {
                    let ref mut fresh320 = *(((*y).k).as_mut_ptr() as *mut S)
                        .offset(j___0 as isize);
                    *fresh320 = *(((**((*d___0).k).as_mut_ptr().offset(i as isize)).k)
                        .as_mut_ptr() as *mut S);
                }
                j___0 += 1;
            }
        } else if -(3 as libc::c_longlong) == t {
            j___1 = 0 as libc::c_int as I;
            _j___1 = p;
            while j___1 < _j___1 {
                d___0 = *c.offset(j___1 as isize);
                if (*d___0).t != 0 {
                    *(((*y).k).as_mut_ptr() as *mut C)
                        .offset(
                            j___1 as isize,
                        ) = *(((*d___0).k).as_mut_ptr() as *mut C)
                        .offset((i % (*d___0).n) as isize);
                } else {
                    *(((*y).k).as_mut_ptr() as *mut C)
                        .offset(
                            j___1 as isize,
                        ) = *(((**((*d___0).k).as_mut_ptr().offset(i as isize)).k)
                        .as_mut_ptr() as *mut C);
                }
                j___1 += 1;
            }
        } else if -(2 as libc::c_longlong) == t {
            j___2 = 0 as libc::c_int as I;
            _j___2 = p;
            while j___2 < _j___2 {
                d___0 = *c.offset(j___2 as isize);
                if (*d___0).t != 0 {
                    *(((*y).k).as_mut_ptr() as *mut F)
                        .offset(
                            j___2 as isize,
                        ) = *(((*d___0).k).as_mut_ptr() as *mut F)
                        .offset((i % (*d___0).n) as isize);
                } else {
                    *(((*y).k).as_mut_ptr() as *mut F)
                        .offset(
                            j___2 as isize,
                        ) = *(((**((*d___0).k).as_mut_ptr().offset(i as isize)).k)
                        .as_mut_ptr() as *mut F);
                }
                j___2 += 1;
            }
        } else if -(1 as libc::c_longlong) == t {
            j___3 = 0 as libc::c_int as I;
            _j___3 = p;
            while j___3 < _j___3 {
                d___0 = *c.offset(j___3 as isize);
                if (*d___0).t != 0 {
                    *(((*y).k).as_mut_ptr() as *mut I)
                        .offset(
                            j___3 as isize,
                        ) = *(((*d___0).k).as_mut_ptr() as *mut I)
                        .offset((i % (*d___0).n) as isize);
                } else {
                    *(((*y).k).as_mut_ptr() as *mut I)
                        .offset(
                            j___3 as isize,
                        ) = *(((**((*d___0).k).as_mut_ptr().offset(i as isize)).k)
                        .as_mut_ptr() as *mut I);
                }
                j___3 += 1;
            }
        } else if 0 as libc::c_longlong == t {
            j___4 = 0 as libc::c_int as I;
            _j___4 = p;
            while j___4 < _j___4 {
                d___0 = *c.offset(j___4 as isize);
                let ref mut fresh321 = *((*y).k).as_mut_ptr().offset(j___4 as isize);
                *fresh321 = itemAtIndex(d___0, i);
                j___4 += 1;
            }
        }
        i += 1;
    }
    return z;
}
pub unsafe extern "C" fn first(mut a: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: F = 0.;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    at___0 = (*a).t;
    an = (*a).n;
    if -(4 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp = *(((*a).k).as_mut_ptr() as *mut S);
        } else {
            tmp = LS;
        }
        tmp___0 = Ks(tmp);
        return tmp___0;
    }
    if -(3 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp___1 = *(((*a).k).as_mut_ptr() as *mut C) as libc::c_int;
        } else {
            tmp___1 = ' ' as i32;
        }
        tmp___2 = Kc(tmp___1 as C);
        return tmp___2;
    }
    if -(2 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp___3 = *(((*a).k).as_mut_ptr() as *mut F);
        } else {
            tmp___3 = 0.0f64;
        }
        tmp___4 = Kf(tmp___3);
        return tmp___4;
    }
    if -(1 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp___5 = *(((*a).k).as_mut_ptr() as *mut I);
        } else {
            tmp___5 = 0 as libc::c_int as I;
        }
        tmp___6 = Ki(tmp___5);
        return tmp___6;
    }
    if 0 as libc::c_longlong == at___0 {
        if an != 0 {
            tmp___7 = ci(*((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize));
            tmp___9 = tmp___7;
        } else {
            tmp___8 = _n();
            tmp___9 = tmp___8;
        }
        return tmp___9;
    }
    tmp___10 = ci(a);
    return tmp___10;
}
pub unsafe extern "C" fn last(mut a: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut tmp: S = 0 as *mut C;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: F = 0.;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: K = 0 as *mut k0;
    at___0 = (*a).t;
    an = (*a).n;
    if -(4 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp = *(((*a).k).as_mut_ptr() as *mut S)
                .offset((an - 1 as libc::c_longlong) as isize);
        } else {
            tmp = LS;
        }
        tmp___0 = Ks(tmp);
        return tmp___0;
    }
    if -(3 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp___1 = *(((*a).k).as_mut_ptr() as *mut C)
                .offset((an - 1 as libc::c_longlong) as isize) as libc::c_int;
        } else {
            tmp___1 = ' ' as i32;
        }
        tmp___2 = Kc(tmp___1 as C);
        return tmp___2;
    }
    if -(2 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp___3 = *(((*a).k).as_mut_ptr() as *mut F)
                .offset((an - 1 as libc::c_longlong) as isize);
        } else {
            tmp___3 = 0.0f64;
        }
        tmp___4 = Kf(tmp___3);
        return tmp___4;
    }
    if -(1 as libc::c_longlong) == at___0 {
        if an != 0 {
            tmp___5 = *(((*a).k).as_mut_ptr() as *mut I)
                .offset((an - 1 as libc::c_longlong) as isize);
        } else {
            tmp___5 = 0 as libc::c_int as I;
        }
        tmp___6 = Ki(tmp___5);
        return tmp___6;
    }
    if 0 as libc::c_longlong == at___0 {
        if an != 0 {
            tmp___7 = ci(
                *((*a).k).as_mut_ptr().offset((an - 1 as libc::c_longlong) as isize),
            );
            tmp___9 = tmp___7;
        } else {
            tmp___8 = _n();
            tmp___9 = tmp___8;
        }
        return tmp___9;
    }
    tmp___10 = ci(a);
    return tmp___10;
}
unsafe extern "C" fn reshaper(
    mut a: K,
    mut b___1: K,
    mut d___0: I,
    mut f: I,
    mut p: *mut I,
) -> K {
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut v: I = 0;
    let mut g: I = 0;
    let mut tmp: libc::c_int = 0;
    let mut t: I = 0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut n: I = 0;
    let mut tmp___2: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: I = 0;
    bt = (*b___1).t;
    bn = (*b___1).n;
    v = *(((*a).k).as_mut_ptr() as *mut I).offset(d___0 as isize);
    if v == 0 {
        tmp = 1 as libc::c_int;
    } else if (*a).n == d___0 + 1 as libc::c_longlong {
        tmp = 1 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    g = tmp as I;
    if g != 0 {
        if bt < 5 as libc::c_longlong {
            if bt < 0 as libc::c_longlong {
                tmp___0 = -bt;
            } else {
                tmp___0 = bt;
            }
            tmp___1 = -tmp___0;
        } else {
            tmp___1 = 0 as libc::c_int as I;
        }
    } else {
        tmp___1 = 0 as libc::c_int as I;
    }
    t = tmp___1;
    if -(1 as libc::c_longlong) == v {
        tmp___2 = f;
    } else {
        tmp___2 = v;
    }
    n = tmp___2;
    tmp___3 = newK(t, n);
    z = tmp___3;
    if z.is_null() {
        return 0 as K;
    }
    if g == 0 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            let ref mut fresh322 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh322 = reshaper(a, b___1, d___0 + 1 as libc::c_longlong, f, p);
            i += 1;
        }
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___10 = -bt;
        } else {
            tmp___10 = bt;
        }
        if 4 as libc::c_longlong == tmp___10 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                if bn != 0 {
                    *p += 1;
                    let ref mut fresh323 = *(((*z).k).as_mut_ptr() as *mut S)
                        .offset(i___0 as isize);
                    *fresh323 = *(((*b___1).k).as_mut_ptr() as *mut S)
                        .offset((*p % bn) as isize);
                } else {
                    let ref mut fresh324 = *(((*z).k).as_mut_ptr() as *mut S)
                        .offset(i___0 as isize);
                    *fresh324 = LS;
                }
                i___0 += 1;
            }
        } else {
            if bt < 0 as libc::c_longlong {
                tmp___9 = -bt;
            } else {
                tmp___9 = bt;
            }
            if 3 as libc::c_longlong == tmp___9 {
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    if bn != 0 {
                        *p += 1;
                        *(((*z).k).as_mut_ptr() as *mut C)
                            .offset(
                                i___1 as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut C)
                            .offset((*p % bn) as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut C)
                            .offset(i___1 as isize) = ' ' as i32 as C;
                    }
                    i___1 += 1;
                }
            } else {
                if bt < 0 as libc::c_longlong {
                    tmp___8 = -bt;
                } else {
                    tmp___8 = bt;
                }
                if 2 as libc::c_longlong == tmp___8 {
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = n;
                    while i___2 < _i___3 {
                        if bn != 0 {
                            *p += 1;
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(
                                    i___2 as isize,
                                ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                                .offset((*p % bn) as isize);
                        } else {
                            *(((*z).k).as_mut_ptr() as *mut F)
                                .offset(i___2 as isize) = 0.0f64;
                        }
                        i___2 += 1;
                    }
                } else {
                    if bt < 0 as libc::c_longlong {
                        tmp___7 = -bt;
                    } else {
                        tmp___7 = bt;
                    }
                    if 1 as libc::c_longlong == tmp___7 {
                        i___3 = 0 as libc::c_int as I;
                        _i___4 = n;
                        while i___3 < _i___4 {
                            if bn != 0 {
                                *p += 1;
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(
                                        i___3 as isize,
                                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                    .offset((*p % bn) as isize);
                            } else {
                                *(((*z).k).as_mut_ptr() as *mut I)
                                    .offset(i___3 as isize) = 0 as libc::c_int as I;
                            }
                            i___3 += 1;
                        }
                    } else {
                        if bt < 0 as libc::c_longlong {
                            tmp___6 = -bt;
                        } else {
                            tmp___6 = bt;
                        }
                        if 0 as libc::c_longlong == tmp___6 {
                            i___4 = 0 as libc::c_int as I;
                            _i___5 = n;
                            while i___4 < _i___5 {
                                if bn != 0 {
                                    *p += 1;
                                    tmp___4 = ci(
                                        *((*b___1).k).as_mut_ptr().offset((*p % bn) as isize),
                                    );
                                    let ref mut fresh325 = *((*z).k)
                                        .as_mut_ptr()
                                        .offset(i___4 as isize);
                                    *fresh325 = tmp___4;
                                } else {
                                    tmp___5 = _n();
                                    let ref mut fresh326 = *((*z).k)
                                        .as_mut_ptr()
                                        .offset(i___4 as isize);
                                    *fresh326 = tmp___5;
                                }
                                i___4 += 1;
                            }
                        } else if 5 as libc::c_longlong <= bt {
                            i___5 = 0 as libc::c_int as I;
                            _i___6 = n;
                            while i___5 < _i___6 {
                                let ref mut fresh327 = *((*z).k)
                                    .as_mut_ptr()
                                    .offset(i___5 as isize);
                                *fresh327 = ci(b___1);
                                i___5 += 1;
                            }
                        }
                    }
                }
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn reshape(mut a: K, mut b___1: K) -> K {
    let mut an: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut ns___0: I = 0;
    let mut x___0: I = 0;
    let mut y: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut p: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: K = 0 as *mut k0;
    an = (*a).n;
    bn = (*b___1).n;
    if an == 0 {
        tmp = first(b___1);
        return tmp;
    }
    ns___0 = 0 as libc::c_int as I;
    y = -(1 as libc::c_int) as I;
    i = 0 as libc::c_int as I;
    _i___0 = an;
    while i < _i___0 {
        x___0 = *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize);
        if (50000000 as libc::c_longlong) < x___0 {
            tmp___0 = kerr(b"limit\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        }
        if 0 as libc::c_longlong > x___0 {
            ns___0 -= x___0;
        }
        i += 1;
    }
    if ns___0 < -(1 as libc::c_longlong) {
        tmp___1 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp___1;
    }
    p = 1 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = an;
    while i___0 < _i___1 {
        p *= *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
        i___0 += 1;
    }
    if ns___0 < 0 as libc::c_longlong {
        if p == 0 {
            tmp___2 = kerr(b"length\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        } else {
            if bn == 0 {
                tmp___2 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___2;
            } else {
                if bn % p != 0 {
                    tmp___2 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                    return tmp___2;
                }
            }
        }
    }
    if p != 0 {
        if bn / p < 0 as libc::c_longlong {
            tmp___3 = -(bn / p);
        } else {
            tmp___3 = bn / p;
        }
        tmp___4 = tmp___3;
    } else {
        tmp___4 = 0 as libc::c_int as I;
    }
    tmp___5 = reshaper(a, b___1, 0 as libc::c_int as I, tmp___4, &mut y);
    return tmp___5;
}
pub unsafe extern "C" fn take(mut a: K, mut b___1: K) -> K {
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut n: I = 0;
    let mut tmp: I = 0;
    let mut m: I = 0;
    let mut tmp___0: I = 0;
    let mut k: I = 0;
    let mut t: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut tmp___8: I = 0;
    let mut tmp___9: I = 0;
    let mut tmp___10: K = 0 as *mut k0;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if *(((*a).k).as_mut_ptr() as *mut I) < 0 as libc::c_longlong {
        tmp = -*(((*a).k).as_mut_ptr() as *mut I);
    } else {
        tmp = *(((*a).k).as_mut_ptr() as *mut I);
    }
    n = tmp;
    if 1 as libc::c_longlong > bn {
        tmp___0 = 1 as libc::c_int as I;
    } else {
        tmp___0 = bn;
    }
    m = tmp___0;
    k = *(((*a).k).as_mut_ptr() as *mut I) % m;
    if k < 0 as libc::c_longlong {
        k = bn + k;
    } else {
        k = 0 as libc::c_int as I;
    }
    if bt < 5 as libc::c_longlong {
        if bt < 0 as libc::c_longlong {
            tmp___1 = -bt;
        } else {
            tmp___1 = bt;
        }
        tmp___2 = -tmp___1;
    } else {
        tmp___2 = 0 as libc::c_int as I;
    }
    t = tmp___2;
    tmp___3 = newK(t, n);
    z = tmp___3;
    if z.is_null() {
        return 0 as K;
    }
    if bt < 0 as libc::c_longlong {
        tmp___9 = -bt;
    } else {
        tmp___9 = bt;
    }
    if 4 as libc::c_longlong == tmp___9 {
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            if bn != 0 {
                let ref mut fresh328 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset(i as isize);
                *fresh328 = *(((*b___1).k).as_mut_ptr() as *mut S)
                    .offset(((i + k) % m) as isize);
            } else {
                let ref mut fresh329 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset(i as isize);
                *fresh329 = LS;
            }
            i += 1;
        }
    } else {
        if bt < 0 as libc::c_longlong {
            tmp___8 = -bt;
        } else {
            tmp___8 = bt;
        }
        if 3 as libc::c_longlong == tmp___8 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                if bn != 0 {
                    *(((*z).k).as_mut_ptr() as *mut C)
                        .offset(
                            i___0 as isize,
                        ) = *(((*b___1).k).as_mut_ptr() as *mut C)
                        .offset(((i___0 + k) % m) as isize);
                } else {
                    *(((*z).k).as_mut_ptr() as *mut C)
                        .offset(i___0 as isize) = ' ' as i32 as C;
                }
                i___0 += 1;
            }
        } else {
            if bt < 0 as libc::c_longlong {
                tmp___7 = -bt;
            } else {
                tmp___7 = bt;
            }
            if 2 as libc::c_longlong == tmp___7 {
                i___1 = 0 as libc::c_int as I;
                _i___2 = n;
                while i___1 < _i___2 {
                    if bn != 0 {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(
                                i___1 as isize,
                            ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                            .offset(((i___1 + k) % m) as isize);
                    } else {
                        *(((*z).k).as_mut_ptr() as *mut F)
                            .offset(i___1 as isize) = 0.0f64;
                    }
                    i___1 += 1;
                }
            } else {
                if bt < 0 as libc::c_longlong {
                    tmp___6 = -bt;
                } else {
                    tmp___6 = bt;
                }
                if 1 as libc::c_longlong == tmp___6 {
                    i___2 = 0 as libc::c_int as I;
                    _i___3 = n;
                    while i___2 < _i___3 {
                        if bn != 0 {
                            *(((*z).k).as_mut_ptr() as *mut I)
                                .offset(
                                    i___2 as isize,
                                ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                                .offset(((i___2 + k) % m) as isize);
                        } else {
                            *(((*z).k).as_mut_ptr() as *mut I)
                                .offset(i___2 as isize) = 0 as libc::c_int as I;
                        }
                        i___2 += 1;
                    }
                } else if 0 as libc::c_longlong == bt {
                    i___3 = 0 as libc::c_int as I;
                    _i___4 = n;
                    while i___3 < _i___4 {
                        if bn != 0 {
                            tmp___4 = ci(
                                *((*b___1).k)
                                    .as_mut_ptr()
                                    .offset(((i___3 + k) % m) as isize),
                            );
                            let ref mut fresh330 = *((*z).k)
                                .as_mut_ptr()
                                .offset(i___3 as isize);
                            *fresh330 = tmp___4;
                        } else {
                            tmp___5 = _n();
                            let ref mut fresh331 = *((*z).k)
                                .as_mut_ptr()
                                .offset(i___3 as isize);
                            *fresh331 = tmp___5;
                        }
                        i___3 += 1;
                    }
                } else if 5 as libc::c_longlong <= bt {
                    i___4 = 0 as libc::c_int as I;
                    _i___5 = n;
                    while i___4 < _i___5 {
                        let ref mut fresh332 = *((*z).k)
                            .as_mut_ptr()
                            .offset(i___4 as isize);
                        *fresh332 = ci(b___1);
                        i___4 += 1;
                    }
                }
            }
        }
    }
    tmp___10 = demote(z);
    return tmp___10;
}
pub unsafe extern "C" fn take_reshape(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    if (*a).n != 0 {
        if (*a).t < 0 as libc::c_longlong {
            tmp___0 = -(*a).t;
        } else {
            tmp___0 = (*a).t;
        }
        if 1 as libc::c_longlong != tmp___0 {
            tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    if (0 as libc::c_longlong) < (*a).t {
        tmp___1 = take(a, b___1);
        tmp___3 = tmp___1;
    } else {
        tmp___2 = reshape(a, b___1);
        tmp___3 = tmp___2;
    }
    return tmp___3;
}
unsafe extern "C" fn shapeCheck(mut a: K, mut p: K, mut d___0: I) {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    if at___0 > 0 as libc::c_longlong {
        *(((*p).k).as_mut_ptr() as *mut I)
            .offset(d___0 as isize) = -(1 as libc::c_int) as I;
    } else if an != *(((*p).k).as_mut_ptr() as *mut I).offset(d___0 as isize) {
        *(((*p).k).as_mut_ptr() as *mut I)
            .offset(d___0 as isize) = -(1 as libc::c_int) as I;
    } else {
        let mut current_block_21: u64;
        if at___0 != 0 {
            if d___0 < (*p).n - 1 as libc::c_longlong {
                *(((*p).k).as_mut_ptr() as *mut I)
                    .offset(
                        (d___0 + 1 as libc::c_longlong) as isize,
                    ) = -(1 as libc::c_int) as I;
                current_block_21 = 5634871135123216486;
            } else {
                current_block_21 = 14772594638076115928;
            }
        } else {
            current_block_21 = 14772594638076115928;
        }
        match current_block_21 {
            14772594638076115928 => {
                if at___0 == 0 {
                    if an != 0 {
                        if *(((*p).k).as_mut_ptr() as *mut I).offset(d___0 as isize)
                            != -(1 as libc::c_longlong)
                        {
                            if d___0 < (*p).n - 1 as libc::c_longlong {
                                i = 0 as libc::c_int as I;
                                _i___0 = an;
                                while i < _i___0 {
                                    shapeCheck(
                                        *((*a).k).as_mut_ptr().offset(i as isize),
                                        p,
                                        d___0 + 1 as libc::c_longlong,
                                    );
                                    i += 1;
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    };
}
unsafe extern "C" fn firstDepth(mut x___0: K) -> I {
    let mut tmp: I = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: I = 0;
    let mut current_block_8: u64;
    if (*x___0).t == 0 {
        if (*x___0).n != 0 {
            tmp = firstDepth(
                *((*x___0).k).as_mut_ptr().offset(0 as libc::c_int as isize),
            );
            tmp___1 = 1 as libc::c_longlong + tmp;
            current_block_8 = 12209867499936983673;
        } else {
            current_block_8 = 8426120120897514965;
        }
    } else {
        current_block_8 = 8426120120897514965;
    }
    match current_block_8 {
        8426120120897514965 => {
            if (*x___0).t > 0 as libc::c_longlong {
                tmp___0 = 0 as libc::c_int;
            } else {
                tmp___0 = 1 as libc::c_int;
            }
            tmp___1 = tmp___0 as I;
        }
        _ => {}
    }
    return tmp___1;
}
pub unsafe extern "C" fn shape(mut a: K) -> K {
    let mut b___1: K = 0 as *mut k0;
    let mut p: K = 0 as *mut k0;
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut n: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    b___1 = a;
    tmp = firstDepth(a);
    tmp___0 = newK(-(1 as libc::c_int) as I, tmp);
    p = tmp___0;
    i = 0 as libc::c_int as I;
    _i___0 = (*p).n;
    while i < _i___0 {
        *(((*p).k).as_mut_ptr() as *mut I).offset(i as isize) = (*b___1).n;
        if i < _i___0 - 1 as libc::c_longlong {
            b___1 = *((*b___1).k).as_mut_ptr().offset(0 as libc::c_int as isize);
        }
        i += 1;
    }
    shapeCheck(a, p, 0 as libc::c_int as I);
    n = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = (*p).n;
    while i___0 < _i___1 {
        if *(((*p).k).as_mut_ptr() as *mut I).offset(i___0 as isize)
            == -(1 as libc::c_longlong)
        {
            break;
        }
        n += 1;
        i___0 += 1;
    }
    tmp___1 = newK(-(1 as libc::c_int) as I, n);
    z = tmp___1;
    i___1 = 0 as libc::c_int as I;
    _i___2 = n;
    while i___1 < _i___2 {
        *(((*z).k).as_mut_ptr() as *mut I)
            .offset(
                i___1 as isize,
            ) = *(((*p).k).as_mut_ptr() as *mut I).offset(i___1 as isize);
        i___1 += 1;
    }
    cd(p);
    return z;
}
pub unsafe extern "C" fn rotate(mut a: K, mut b___1: K) -> K {
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut r: I = 0;
    let mut tmp: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if 1 as libc::c_longlong > bn {
        tmp = 1 as libc::c_int as I;
    } else {
        tmp = bn;
    }
    r = *(((*a).k).as_mut_ptr() as *mut I) % tmp;
    if r > 0 as libc::c_longlong {
        r = r;
    } else {
        r = bn + r;
    }
    tmp___0 = newK(bt, bn);
    z = tmp___0;
    if z.is_null() {
        return 0 as K;
    }
    if -(4 as libc::c_longlong) == bt {
        i = 0 as libc::c_int as I;
        _i___0 = bn;
        while i < _i___0 {
            let ref mut fresh333 = *(((*z).k).as_mut_ptr() as *mut S).offset(i as isize);
            *fresh333 = *(((*b___1).k).as_mut_ptr() as *mut S)
                .offset(((i + r) % bn) as isize);
            i += 1;
        }
    } else if -(3 as libc::c_longlong) == bt {
        i___0 = 0 as libc::c_int as I;
        _i___1 = bn;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(
                    i___0 as isize,
                ) = *(((*b___1).k).as_mut_ptr() as *mut C)
                .offset(((i___0 + r) % bn) as isize);
            i___0 += 1;
        }
    } else if -(2 as libc::c_longlong) == bt {
        i___1 = 0 as libc::c_int as I;
        _i___2 = bn;
        while i___1 < _i___2 {
            *(((*z).k).as_mut_ptr() as *mut F)
                .offset(
                    i___1 as isize,
                ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                .offset(((i___1 + r) % bn) as isize);
            i___1 += 1;
        }
    } else if -(1 as libc::c_longlong) == bt {
        i___2 = 0 as libc::c_int as I;
        _i___3 = bn;
        while i___2 < _i___3 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___2 as isize,
                ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                .offset(((i___2 + r) % bn) as isize);
            i___2 += 1;
        }
    } else if 0 as libc::c_longlong == bt {
        i___3 = 0 as libc::c_int as I;
        _i___4 = bn;
        while i___3 < _i___4 {
            let ref mut fresh334 = *((*z).k).as_mut_ptr().offset(i___3 as isize);
            *fresh334 = ci(
                *((*b___1).k).as_mut_ptr().offset(((i___3 + r) % bn) as isize),
            );
            i___3 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn drop_0(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut v: I = 0;
    let mut zn: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut c: I = 0;
    let mut tmp___6: I = 0;
    let mut tmp___7: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___8: K = 0 as *mut k0;
    at___0 = (*a).t;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if 1 as libc::c_longlong != at___0 {
        tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if bt > 0 as libc::c_longlong {
        tmp___0 = ci(b___1);
        return tmp___0;
    }
    v = *(((*a).k).as_mut_ptr() as *mut I);
    if v < 0 as libc::c_longlong {
        tmp___4 = -v;
    } else {
        tmp___4 = v;
    }
    if 0 as libc::c_longlong > bn - tmp___4 {
        tmp___3 = 0 as libc::c_int as I;
    } else {
        if v < 0 as libc::c_longlong {
            tmp___2 = -v;
        } else {
            tmp___2 = v;
        }
        tmp___3 = bn - tmp___2;
    }
    zn = tmp___3;
    tmp___5 = newK(bt, zn);
    z = tmp___5;
    if z.is_null() {
        return 0 as K;
    }
    if v < 1 as libc::c_longlong {
        tmp___7 = 0 as libc::c_int as I;
    } else {
        if v < bn {
            tmp___6 = v;
        } else {
            tmp___6 = bn;
        }
        tmp___7 = tmp___6;
    }
    c = tmp___7;
    if -(4 as libc::c_longlong) == bt {
        i = 0 as libc::c_int as I;
        _i___0 = zn;
        while i < _i___0 {
            let ref mut fresh335 = *(((*z).k).as_mut_ptr() as *mut S).offset(i as isize);
            *fresh335 = *(((*b___1).k).as_mut_ptr() as *mut S).offset((i + c) as isize);
            i += 1;
        }
    } else if -(3 as libc::c_longlong) == bt {
        i___0 = 0 as libc::c_int as I;
        _i___1 = zn;
        while i___0 < _i___1 {
            *(((*z).k).as_mut_ptr() as *mut C)
                .offset(
                    i___0 as isize,
                ) = *(((*b___1).k).as_mut_ptr() as *mut C).offset((i___0 + c) as isize);
            i___0 += 1;
        }
    } else if -(2 as libc::c_longlong) == bt {
        i___1 = 0 as libc::c_int as I;
        _i___2 = zn;
        while i___1 < _i___2 {
            *(((*z).k).as_mut_ptr() as *mut F)
                .offset(
                    i___1 as isize,
                ) = *(((*b___1).k).as_mut_ptr() as *mut F).offset((i___1 + c) as isize);
            i___1 += 1;
        }
    } else if -(1 as libc::c_longlong) == bt {
        i___2 = 0 as libc::c_int as I;
        _i___3 = zn;
        while i___2 < _i___3 {
            *(((*z).k).as_mut_ptr() as *mut I)
                .offset(
                    i___2 as isize,
                ) = *(((*b___1).k).as_mut_ptr() as *mut I).offset((i___2 + c) as isize);
            i___2 += 1;
        }
    } else if 0 as libc::c_longlong == bt {
        i___3 = 0 as libc::c_int as I;
        _i___4 = zn;
        while i___3 < _i___4 {
            let ref mut fresh336 = *((*z).k).as_mut_ptr().offset(i___3 as isize);
            *fresh336 = ci(*((*b___1).k).as_mut_ptr().offset((i___3 + c) as isize));
            i___3 += 1;
        }
    }
    tmp___8 = demote(z);
    return tmp___8;
}
pub unsafe extern "C" fn cut(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut x___0: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut zn: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut x___1: I = 0;
    let mut y: I = 0;
    let mut tmp___4: I = 0;
    let mut w___0: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut j: I = 0;
    let mut _j: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut x___2: I = 0;
    let mut y___0: I = 0;
    let mut tmp___6: I = 0;
    let mut w___1: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut j___0: I = 0;
    let mut _j___0: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut x___3: I = 0;
    let mut y___1: I = 0;
    let mut tmp___8: I = 0;
    let mut w___2: K = 0 as *mut k0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut j___1: I = 0;
    let mut _j___1: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut x___4: I = 0;
    let mut y___2: I = 0;
    let mut tmp___10: I = 0;
    let mut w___3: K = 0 as *mut k0;
    let mut tmp___11: K = 0 as *mut k0;
    let mut j___2: I = 0;
    let mut _j___2: I = 0;
    let mut i___4: I = 0;
    let mut x___5: I = 0;
    let mut y___3: I = 0;
    let mut tmp___12: I = 0;
    let mut sn: I = 0;
    let mut t: I = 0;
    let mut j___3: I = 0;
    let mut _j___3: I = 0;
    let mut tmp___13: I = 0;
    let mut s: K = 0 as *mut k0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut j___4: I = 0;
    let mut _j___4: I = 0;
    let mut j___5: I = 0;
    let mut _j___5: I = 0;
    let mut j___6: I = 0;
    let mut _j___6: I = 0;
    let mut j___7: I = 0;
    let mut _j___7: I = 0;
    let mut j___8: I = 0;
    let mut _j___8: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    bn = (*b___1).n;
    if -(1 as libc::c_longlong) != at___0 {
        tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    i = 0 as libc::c_int as I;
    _i___0 = an;
    while i < _i___0 {
        x___0 = *(((*a).k).as_mut_ptr() as *mut I).offset(i as isize);
        if x___0 < 0 as libc::c_longlong {
            tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___0;
        } else {
            if i > 0 as libc::c_longlong {
                tmp___2 = i - 1 as libc::c_longlong;
            } else {
                tmp___2 = 0 as libc::c_int as I;
            }
            if x___0 < *(((*a).k).as_mut_ptr() as *mut I).offset(tmp___2 as isize) {
                tmp___0 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
                return tmp___0;
            } else {
                if x___0 > bn {
                    tmp___1 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                    return tmp___1;
                }
            }
        }
        i += 1;
    }
    tmp___3 = newK(0 as libc::c_int as I, an);
    z = tmp___3;
    if z.is_null() {
        return 0 as K;
    }
    zn = (*z).n;
    if -(4 as libc::c_longlong) == bt {
        i___0 = 0 as libc::c_int as I;
        _i___1 = zn;
        while i___0 < _i___1 {
            x___1 = *(((*a).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
            if i___0 == (*z).n - 1 as libc::c_longlong {
                tmp___4 = bn;
            } else {
                tmp___4 = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset((i___0 + 1 as libc::c_longlong) as isize);
            }
            y = tmp___4;
            tmp___5 = newK(-(4 as libc::c_int) as I, y - x___1);
            w___0 = tmp___5;
            j = 0 as libc::c_int as I;
            _j = (*w___0).n;
            while j < _j {
                let ref mut fresh337 = *(((*w___0).k).as_mut_ptr() as *mut S)
                    .offset(j as isize);
                *fresh337 = *(((*b___1).k).as_mut_ptr() as *mut S)
                    .offset((x___1 + j) as isize);
                j += 1;
            }
            let ref mut fresh338 = *((*z).k).as_mut_ptr().offset(i___0 as isize);
            *fresh338 = w___0;
            i___0 += 1;
        }
    } else if -(3 as libc::c_longlong) == bt {
        i___1 = 0 as libc::c_int as I;
        _i___2 = zn;
        while i___1 < _i___2 {
            x___2 = *(((*a).k).as_mut_ptr() as *mut I).offset(i___1 as isize);
            if i___1 == (*z).n - 1 as libc::c_longlong {
                tmp___6 = bn;
            } else {
                tmp___6 = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset((i___1 + 1 as libc::c_longlong) as isize);
            }
            y___0 = tmp___6;
            tmp___7 = newK(-(3 as libc::c_int) as I, y___0 - x___2);
            w___1 = tmp___7;
            j___0 = 0 as libc::c_int as I;
            _j___0 = (*w___1).n;
            while j___0 < _j___0 {
                *(((*w___1).k).as_mut_ptr() as *mut C)
                    .offset(
                        j___0 as isize,
                    ) = *(((*b___1).k).as_mut_ptr() as *mut C)
                    .offset((x___2 + j___0) as isize);
                j___0 += 1;
            }
            let ref mut fresh339 = *((*z).k).as_mut_ptr().offset(i___1 as isize);
            *fresh339 = w___1;
            i___1 += 1;
        }
    } else if -(2 as libc::c_longlong) == bt {
        i___2 = 0 as libc::c_int as I;
        _i___3 = zn;
        while i___2 < _i___3 {
            x___3 = *(((*a).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
            if i___2 == (*z).n - 1 as libc::c_longlong {
                tmp___8 = bn;
            } else {
                tmp___8 = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset((i___2 + 1 as libc::c_longlong) as isize);
            }
            y___1 = tmp___8;
            tmp___9 = newK(-(2 as libc::c_int) as I, y___1 - x___3);
            w___2 = tmp___9;
            j___1 = 0 as libc::c_int as I;
            _j___1 = (*w___2).n;
            while j___1 < _j___1 {
                *(((*w___2).k).as_mut_ptr() as *mut F)
                    .offset(
                        j___1 as isize,
                    ) = *(((*b___1).k).as_mut_ptr() as *mut F)
                    .offset((x___3 + j___1) as isize);
                j___1 += 1;
            }
            let ref mut fresh340 = *((*z).k).as_mut_ptr().offset(i___2 as isize);
            *fresh340 = w___2;
            i___2 += 1;
        }
    } else if -(1 as libc::c_longlong) == bt {
        i___3 = 0 as libc::c_int as I;
        _i___4 = zn;
        while i___3 < _i___4 {
            x___4 = *(((*a).k).as_mut_ptr() as *mut I).offset(i___3 as isize);
            if i___3 == (*z).n - 1 as libc::c_longlong {
                tmp___10 = bn;
            } else {
                tmp___10 = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset((i___3 + 1 as libc::c_longlong) as isize);
            }
            y___2 = tmp___10;
            tmp___11 = newK(-(1 as libc::c_int) as I, y___2 - x___4);
            w___3 = tmp___11;
            j___2 = 0 as libc::c_int as I;
            _j___2 = (*w___3).n;
            while j___2 < _j___2 {
                *(((*w___3).k).as_mut_ptr() as *mut I)
                    .offset(
                        j___2 as isize,
                    ) = *(((*b___1).k).as_mut_ptr() as *mut I)
                    .offset((x___4 + j___2) as isize);
                j___2 += 1;
            }
            let ref mut fresh341 = *((*z).k).as_mut_ptr().offset(i___3 as isize);
            *fresh341 = w___3;
            i___3 += 1;
        }
    } else if 0 as libc::c_longlong == bt {
        i___4 = 0 as libc::c_int as I;
        while i___4 < zn {
            x___5 = *(((*a).k).as_mut_ptr() as *mut I).offset(i___4 as isize);
            if i___4 == (*z).n - 1 as libc::c_longlong {
                tmp___12 = bn;
            } else {
                tmp___12 = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset((i___4 + 1 as libc::c_longlong) as isize);
            }
            y___3 = tmp___12;
            sn = y___3 - x___5;
            t = bt;
            if sn != 0 {
                if x___5 < bn {
                    t = (**((*b___1).k).as_mut_ptr().offset(x___5 as isize)).t;
                }
            }
            j___3 = 0 as libc::c_int as I;
            _j___3 = sn;
            while j___3 < _j___3 {
                if t != (**((*b___1).k).as_mut_ptr().offset((x___5 + j___3) as isize)).t
                {
                    t = 0 as libc::c_int as I;
                    break;
                } else {
                    j___3 += 1;
                }
            }
            if 0 as libc::c_longlong > t {
                tmp___13 = 0 as libc::c_int as I;
            } else {
                tmp___13 = t;
            }
            t = -tmp___13;
            tmp___14 = newK(t, sn);
            s = tmp___14;
            if -(4 as libc::c_longlong) == t {
                j___4 = 0 as libc::c_int as I;
                _j___4 = sn;
                while j___4 < _j___4 {
                    let ref mut fresh342 = *(((*s).k).as_mut_ptr() as *mut S)
                        .offset(j___4 as isize);
                    *fresh342 = *(((**((*b___1).k)
                        .as_mut_ptr()
                        .offset((x___5 + j___4) as isize))
                        .k)
                        .as_mut_ptr() as *mut S);
                    j___4 += 1;
                }
            } else if -(3 as libc::c_longlong) == t {
                j___5 = 0 as libc::c_int as I;
                _j___5 = sn;
                while j___5 < _j___5 {
                    *(((*s).k).as_mut_ptr() as *mut C)
                        .offset(
                            j___5 as isize,
                        ) = *(((**((*b___1).k)
                        .as_mut_ptr()
                        .offset((x___5 + j___5) as isize))
                        .k)
                        .as_mut_ptr() as *mut C);
                    j___5 += 1;
                }
            } else if -(2 as libc::c_longlong) == t {
                j___6 = 0 as libc::c_int as I;
                _j___6 = sn;
                while j___6 < _j___6 {
                    *(((*s).k).as_mut_ptr() as *mut F)
                        .offset(
                            j___6 as isize,
                        ) = *(((**((*b___1).k)
                        .as_mut_ptr()
                        .offset((x___5 + j___6) as isize))
                        .k)
                        .as_mut_ptr() as *mut F);
                    j___6 += 1;
                }
            } else if -(1 as libc::c_longlong) == t {
                j___7 = 0 as libc::c_int as I;
                _j___7 = sn;
                while j___7 < _j___7 {
                    *(((*s).k).as_mut_ptr() as *mut I)
                        .offset(
                            j___7 as isize,
                        ) = *(((**((*b___1).k)
                        .as_mut_ptr()
                        .offset((x___5 + j___7) as isize))
                        .k)
                        .as_mut_ptr() as *mut I);
                    j___7 += 1;
                }
            } else if 0 as libc::c_longlong == t {
                j___8 = 0 as libc::c_int as I;
                _j___8 = sn;
                while j___8 < _j___8 {
                    let ref mut fresh343 = *((*s).k).as_mut_ptr().offset(j___8 as isize);
                    *fresh343 = ci(
                        *((*b___1).k).as_mut_ptr().offset((x___5 + j___8) as isize),
                    );
                    j___8 += 1;
                }
            }
            let ref mut fresh344 = *((*z).k).as_mut_ptr().offset(i___4 as isize);
            *fresh344 = s;
            i___4 += 1;
        }
    }
    return z;
}
pub unsafe extern "C" fn drop_cut(mut a: K, mut b___1: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    if (*a).t < 0 as libc::c_longlong {
        tmp___0 = -(*a).t;
    } else {
        tmp___0 = (*a).t;
    }
    if 1 as libc::c_longlong != tmp___0 {
        tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if -(1 as libc::c_longlong) == (*a).t {
            if (0 as libc::c_longlong) < (*b___1).t {
                tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    if 1 as libc::c_longlong == (*a).t {
        tmp___1 = drop_0(a, b___1);
        tmp___3 = tmp___1;
    } else {
        tmp___2 = cut(a, b___1);
        tmp___3 = tmp___2;
    }
    return tmp___3;
}
pub unsafe extern "C" fn where_0(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut zn: I = 0;
    let mut y: I = 0;
    let mut j: I = 0;
    let mut t: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___4: I = 0;
    if (*x___0).n == 0 {
        tmp = newK(-(1 as libc::c_int) as I, 0 as libc::c_int as I);
        return tmp;
    }
    if (*x___0).t < 0 as libc::c_longlong {
        tmp___1 = -(*x___0).t;
    } else {
        tmp___1 = (*x___0).t;
    }
    if 1 as libc::c_longlong != tmp___1 {
        tmp___0 = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp___0;
    }
    i = 0 as libc::c_int as I;
    _i___0 = (*x___0).n;
    while i < _i___0 {
        if *(((*x___0).k).as_mut_ptr() as *mut I).offset(i as isize)
            == 9223372036854775807 as libc::c_longlong
        {
            tmp___2 = kerr(b"int\0" as *const u8 as *const libc::c_char);
            return tmp___2;
        }
        i += 1;
    }
    zn = 0 as libc::c_int as I;
    t = 0 as libc::c_int as I;
    i___0 = 0 as libc::c_int as I;
    _i___1 = (*x___0).n;
    while i___0 < _i___1 {
        y = *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___0 as isize);
        if !(y < 0 as libc::c_longlong) {
            zn += y;
        }
        i___0 += 1;
    }
    tmp___3 = newK(-(1 as libc::c_int) as I, zn);
    z = tmp___3;
    if z.is_null() {
        return 0 as K;
    }
    i___1 = 0 as libc::c_int as I;
    _i___2 = (*x___0).n;
    while i___1 < _i___2 {
        j = 0 as libc::c_int as I;
        while j < *(((*x___0).k).as_mut_ptr() as *mut I).offset(i___1 as isize) {
            tmp___4 = t;
            t += 1;
            *(((*z).k).as_mut_ptr() as *mut I).offset(tmp___4 as isize) = i___1;
            j += 1;
        }
        i___1 += 1;
    }
    return z;
}
pub unsafe extern "C" fn reverse(mut a: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut n: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut _t___0: S = 0 as *mut C;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut _t___1: C = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut _t___2: F = 0.;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut _t___3: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut _t___4: K = 0 as *mut k0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut i___6: I = 0;
    let mut _i___7: I = 0;
    let mut i___7: I = 0;
    let mut _i___8: I = 0;
    let mut i___8: I = 0;
    let mut _i___9: I = 0;
    let mut tmp___0: I = 0;
    at___0 = (*a).t;
    an = (*a).n;
    if (0 as libc::c_longlong) < at___0 {
        tmp = ci(a);
        return tmp;
    }
    tmp___0 = rc(a);
    if 1 as libc::c_longlong == tmp___0 {
        n = an >> 1 as libc::c_int;
        z = ci(a);
        if n == 0 {
            return z;
        }
        if -(4 as libc::c_longlong) == at___0 {
            i = 0 as libc::c_int as I;
            _i___0 = n;
            while i < _i___0 {
                _t___0 = *(((*z).k).as_mut_ptr() as *mut S).offset(i as isize);
                let ref mut fresh345 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset(i as isize);
                *fresh345 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset((an - i - 1 as libc::c_longlong) as isize);
                let ref mut fresh346 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset((an - i - 1 as libc::c_longlong) as isize);
                *fresh346 = _t___0;
                i += 1;
            }
        } else if -(3 as libc::c_longlong) == at___0 {
            i___0 = 0 as libc::c_int as I;
            _i___1 = n;
            while i___0 < _i___1 {
                _t___1 = *(((*z).k).as_mut_ptr() as *mut C).offset(i___0 as isize);
                *(((*z).k).as_mut_ptr() as *mut C)
                    .offset(
                        i___0 as isize,
                    ) = *(((*z).k).as_mut_ptr() as *mut C)
                    .offset((an - i___0 - 1 as libc::c_longlong) as isize);
                *(((*z).k).as_mut_ptr() as *mut C)
                    .offset((an - i___0 - 1 as libc::c_longlong) as isize) = _t___1;
                i___0 += 1;
            }
        } else if -(2 as libc::c_longlong) == at___0 {
            i___1 = 0 as libc::c_int as I;
            _i___2 = n;
            while i___1 < _i___2 {
                _t___2 = *(((*z).k).as_mut_ptr() as *mut F).offset(i___1 as isize);
                *(((*z).k).as_mut_ptr() as *mut F)
                    .offset(
                        i___1 as isize,
                    ) = *(((*z).k).as_mut_ptr() as *mut F)
                    .offset((an - i___1 - 1 as libc::c_longlong) as isize);
                *(((*z).k).as_mut_ptr() as *mut F)
                    .offset((an - i___1 - 1 as libc::c_longlong) as isize) = _t___2;
                i___1 += 1;
            }
        } else if -(1 as libc::c_longlong) == at___0 {
            i___2 = 0 as libc::c_int as I;
            _i___3 = n;
            while i___2 < _i___3 {
                _t___3 = *(((*z).k).as_mut_ptr() as *mut I).offset(i___2 as isize);
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        i___2 as isize,
                    ) = *(((*z).k).as_mut_ptr() as *mut I)
                    .offset((an - i___2 - 1 as libc::c_longlong) as isize);
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset((an - i___2 - 1 as libc::c_longlong) as isize) = _t___3;
                i___2 += 1;
            }
        } else if 0 as libc::c_longlong == at___0 {
            i___3 = 0 as libc::c_int as I;
            _i___4 = n;
            while i___3 < _i___4 {
                _t___4 = *((*z).k).as_mut_ptr().offset(i___3 as isize);
                let ref mut fresh347 = *((*z).k).as_mut_ptr().offset(i___3 as isize);
                *fresh347 = *((*z).k)
                    .as_mut_ptr()
                    .offset((an - i___3 - 1 as libc::c_longlong) as isize);
                let ref mut fresh348 = *((*z).k)
                    .as_mut_ptr()
                    .offset((an - i___3 - 1 as libc::c_longlong) as isize);
                *fresh348 = _t___4;
                i___3 += 1;
            }
        }
    } else {
        z = newK(at___0, an);
        if z.is_null() {
            return 0 as K;
        }
        if -(4 as libc::c_longlong) == at___0 {
            i___4 = 0 as libc::c_int as I;
            _i___5 = an;
            while i___4 < _i___5 {
                let ref mut fresh349 = *(((*z).k).as_mut_ptr() as *mut S)
                    .offset(i___4 as isize);
                *fresh349 = *(((*a).k).as_mut_ptr() as *mut S)
                    .offset((an - i___4 - 1 as libc::c_longlong) as isize);
                i___4 += 1;
            }
        } else if -(3 as libc::c_longlong) == at___0 {
            i___5 = 0 as libc::c_int as I;
            _i___6 = an;
            while i___5 < _i___6 {
                *(((*z).k).as_mut_ptr() as *mut C)
                    .offset(
                        i___5 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut C)
                    .offset((an - i___5 - 1 as libc::c_longlong) as isize);
                i___5 += 1;
            }
        } else if -(2 as libc::c_longlong) == at___0 {
            i___6 = 0 as libc::c_int as I;
            _i___7 = an;
            while i___6 < _i___7 {
                *(((*z).k).as_mut_ptr() as *mut F)
                    .offset(
                        i___6 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut F)
                    .offset((an - i___6 - 1 as libc::c_longlong) as isize);
                i___6 += 1;
            }
        } else if -(1 as libc::c_longlong) == at___0 {
            i___7 = 0 as libc::c_int as I;
            _i___8 = an;
            while i___7 < _i___8 {
                *(((*z).k).as_mut_ptr() as *mut I)
                    .offset(
                        i___7 as isize,
                    ) = *(((*a).k).as_mut_ptr() as *mut I)
                    .offset((an - i___7 - 1 as libc::c_longlong) as isize);
                i___7 += 1;
            }
        } else if 0 as libc::c_longlong == at___0 {
            i___8 = 0 as libc::c_int as I;
            _i___9 = an;
            while i___8 < _i___9 {
                let ref mut fresh350 = *((*z).k).as_mut_ptr().offset(i___8 as isize);
                *fresh350 = ci(
                    *((*a).k)
                        .as_mut_ptr()
                        .offset((an - i___8 - 1 as libc::c_longlong) as isize),
                );
                i___8 += 1;
            }
        }
    }
    return z;
}
pub unsafe extern "C" fn countI(mut x___0: K) -> I {
    let mut tmp: I = 0;
    if (*x___0).t > 0 as libc::c_longlong {
        tmp = 1 as libc::c_int as I;
    } else {
        tmp = (*x___0).n;
    }
    return tmp;
}
pub unsafe extern "C" fn count(mut x___0: K) -> K {
    let mut tmp: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    tmp = countI(x___0);
    tmp___0 = Ki(tmp);
    return tmp___0;
}
pub unsafe extern "C" fn join(mut x___0: K, mut y: K) -> K {
    let mut xk: I = 0;
    let mut tmp: I = 0;
    let mut yk: I = 0;
    let mut tmp___0: I = 0;
    let mut zt: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: I = 0;
    let mut tmp___3: I = 0;
    let mut tmp___4: I = 0;
    let mut tmp___5: I = 0;
    let mut zn: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___6: K = 0 as *mut k0;
    let mut c: K = 0 as *mut k0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut d___0: K = 0 as *mut k0;
    let mut tmp___8: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    tmp = countI(x___0);
    xk = tmp;
    tmp___0 = countI(y);
    yk = tmp___0;
    zt = 0 as libc::c_int as I;
    if (*x___0).t < 0 as libc::c_longlong {
        tmp___2 = -(*x___0).t;
    } else {
        tmp___2 = (*x___0).t;
    }
    if (*y).t < 0 as libc::c_longlong {
        tmp___3 = -(*y).t;
    } else {
        tmp___3 = (*y).t;
    }
    if tmp___2 == tmp___3 {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___1 = -(*x___0).t;
        } else {
            tmp___1 = (*x___0).t;
        }
        zt = -tmp___1;
    }
    if xk == 0 {
        if (*y).t < 0 as libc::c_longlong {
            tmp___4 = -(*y).t;
        } else {
            tmp___4 = (*y).t;
        }
        zt = -tmp___4;
    } else if yk == 0 {
        if (*x___0).t < 0 as libc::c_longlong {
            tmp___5 = -(*x___0).t;
        } else {
            tmp___5 = (*x___0).t;
        }
        zt = -tmp___5;
    }
    if zt < -(4 as libc::c_longlong) {
        zt = 0 as libc::c_int as I;
    }
    zn = xk + yk;
    tmp___6 = newK(zt, zn);
    z = tmp___6;
    if z.is_null() {
        return 0 as K;
    }
    if -(4 as libc::c_longlong) == zt {
        memcpy(
            ((*z).k).as_mut_ptr() as *mut S as *mut libc::c_void,
            ((*x___0).k).as_mut_ptr() as *mut S as *const libc::c_void,
            (xk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<S>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
        memcpy(
            (((*z).k).as_mut_ptr() as *mut S).offset(xk as isize) as *mut libc::c_void,
            ((*y).k).as_mut_ptr() as *mut S as *const libc::c_void,
            (yk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<S>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
    } else if -(3 as libc::c_longlong) == zt {
        memcpy(
            ((*z).k).as_mut_ptr() as *mut C as *mut libc::c_void,
            ((*x___0).k).as_mut_ptr() as *mut C as *const libc::c_void,
            (xk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<C>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
        memcpy(
            (((*z).k).as_mut_ptr() as *mut C).offset(xk as isize) as *mut libc::c_void,
            ((*y).k).as_mut_ptr() as *mut C as *const libc::c_void,
            (yk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<C>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
    } else if -(2 as libc::c_longlong) == zt {
        memcpy(
            ((*z).k).as_mut_ptr() as *mut F as *mut libc::c_void,
            ((*x___0).k).as_mut_ptr() as *mut F as *const libc::c_void,
            (xk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
        memcpy(
            (((*z).k).as_mut_ptr() as *mut F).offset(xk as isize) as *mut libc::c_void,
            ((*y).k).as_mut_ptr() as *mut F as *const libc::c_void,
            (yk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<F>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
    } else if -(1 as libc::c_longlong) == zt {
        memcpy(
            ((*z).k).as_mut_ptr() as *mut I as *mut libc::c_void,
            ((*x___0).k).as_mut_ptr() as *mut I as *const libc::c_void,
            (xk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
        memcpy(
            (((*z).k).as_mut_ptr() as *mut I).offset(xk as isize) as *mut libc::c_void,
            ((*y).k).as_mut_ptr() as *mut I as *const libc::c_void,
            (yk as libc::c_ulonglong)
                .wrapping_mul(
                    ::std::mem::size_of::<I>() as libc::c_ulong as libc::c_ulonglong,
                ) as size_t,
        );
    } else if 0 as libc::c_longlong == zt {
        tmp___7 = promote(x___0);
        c = tmp___7;
        tmp___8 = promote(y);
        d___0 = tmp___8;
        i = 0 as libc::c_int as I;
        _i___0 = xk;
        while i < _i___0 {
            let ref mut fresh351 = *((*z).k).as_mut_ptr().offset(i as isize);
            *fresh351 = ci(*((*c).k).as_mut_ptr().offset(i as isize));
            i += 1;
        }
        i___0 = 0 as libc::c_int as I;
        _i___1 = yk;
        while i___0 < _i___1 {
            let ref mut fresh352 = *((*z).k).as_mut_ptr().offset((xk + i___0) as isize);
            *fresh352 = ci(*((*d___0).k).as_mut_ptr().offset(i___0 as isize));
            i___0 += 1;
        }
        cd(c);
        cd(d___0);
    }
    return z;
}
unsafe extern "C" fn _hg(
    mut h: K,
    mut k: uI,
    mut v: I,
    mut x___0: K,
    mut p: *mut uI,
) -> I {
    let mut n: I = 0;
    let mut d___0: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut u: uI = 0;
    n = (*h).n;
    d___0 = ((*h).k).as_mut_ptr() as *mut I;
    u = k & (n - 1 as libc::c_longlong) as libc::c_ulonglong;
    loop {
        i = *d___0.offset(u as isize);
        if !(-(1 as libc::c_longlong) != i) {
            break;
        }
        if v == *(((*x___0).k).as_mut_ptr() as *mut I).offset(i as isize) {
            *p = u;
            return i;
        }
        u = u.wrapping_add(1);
        if u == n as uI {
            u = 0 as libc::c_int as uI;
        }
    }
    *p = u;
    return (*x___0).n;
}
unsafe extern "C" fn _hgk(
    mut h: K,
    mut k: uI,
    mut v: K,
    mut x___0: K,
    mut p: *mut uI,
) -> I {
    let mut n: I = 0;
    let mut d___0: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut u: uI = 0;
    let mut tmp: I = 0;
    n = (*h).n;
    d___0 = ((*h).k).as_mut_ptr() as *mut I;
    u = k & (n - 1 as libc::c_longlong) as libc::c_ulonglong;
    loop {
        i = *d___0.offset(u as isize);
        if !(-(1 as libc::c_longlong) != i) {
            break;
        }
        tmp = KEQ(v, *((*x___0).k).as_mut_ptr().offset(i as isize));
        if tmp != 0 {
            *p = u;
            return i;
        }
        u = u.wrapping_add(1);
        if u == n as uI {
            u = 0 as libc::c_int as uI;
        }
    }
    *p = u;
    return (*x___0).n;
}
unsafe extern "C" fn _hgv(
    mut h: K,
    mut k: uI,
    mut v: V,
    mut x___0: K,
    mut p: *mut uI,
) -> I {
    let mut n: I = 0;
    let mut d___0: *mut I = 0 as *mut I;
    let mut i: I = 0;
    let mut u: uI = 0;
    n = (*h).n;
    d___0 = ((*h).k).as_mut_ptr() as *mut I;
    u = k & (n - 1 as libc::c_longlong) as libc::c_ulonglong;
    loop {
        i = *d___0.offset(u as isize);
        if !(-(1 as libc::c_longlong) != i) {
            break;
        }
        if v as libc::c_ulong
            == *(((*x___0).k).as_mut_ptr() as *mut V).offset(i as isize) as libc::c_ulong
        {
            *p = u;
            return i;
        }
        u = u.wrapping_add(1);
        if u == n as uI {
            u = 0 as libc::c_int as uI;
        }
    }
    *p = u;
    return (*x___0).n;
}
pub unsafe extern "C" fn _hash(mut x___0: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut p: uI = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut v: K = 0 as *mut k0;
    let mut tmp___4: UI = 0;
    let mut tmp___5: I = 0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut v___0: uI = 0;
    let mut tmp___6: uint32_t = 0;
    let mut tmp___7: I = 0;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut k: uI = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut v___1: S = 0 as *mut C;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: uint32_t = 0;
    let mut tmp___10: I = 0;
    if (*x___0).t > 0 as libc::c_longlong {
        tmp = kerr(b"rank\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if -(3 as libc::c_longlong) == (*x___0).t {
        tmp___0 = newK(-(1 as libc::c_int) as I, 256 as libc::c_int as I);
        tmp___2 = tmp___0;
    } else {
        tmp___1 = newH((*x___0).n);
        tmp___2 = tmp___1;
    }
    y = tmp___2;
    tmp___3 = OOM_CD(0 as libc::c_int as I, y, -(1 as libc::c_int) as V);
    if tmp___3 == 0 {
        return 0 as K;
    }
    hcinit();
    i = 0 as libc::c_int as I;
    _i___0 = (*y).n;
    while i < _i___0 {
        *(((*y).k).as_mut_ptr() as *mut I).offset(i as isize) = -(1 as libc::c_int) as I;
        i += 1;
    }
    match -(*x___0).t {
        0 => {
            i___0 = 0 as libc::c_int as I;
            _i___1 = (*x___0).n;
            while i___0 < _i___1 {
                v = *((*x___0).k).as_mut_ptr().offset(i___0 as isize);
                tmp___4 = hcode(v);
                tmp___5 = _hgk(y, tmp___4, v, x___0, &mut p);
                if (*x___0).n == tmp___5 {
                    *(((*y).k).as_mut_ptr() as *mut I).offset(p as isize) = i___0;
                }
                i___0 += 1;
            }
        }
        1 | 2 => {
            i___1 = 0 as libc::c_int as I;
            _i___2 = (*x___0).n;
            while i___1 < _i___2 {
                v___0 = *(((*x___0).k).as_mut_ptr() as *mut uI).offset(i___1 as isize);
                tmp___6 = hc(v___0);
                tmp___7 = _hg(y, tmp___6 as uI, v___0 as I, x___0, &mut p);
                if (*x___0).n == tmp___7 {
                    *(((*y).k).as_mut_ptr() as *mut I).offset(p as isize) = i___1;
                }
                i___1 += 1;
            }
        }
        3 => {
            i___2 = 0 as libc::c_int as I;
            _i___3 = (*x___0).n;
            while i___2 < _i___3 {
                k = *(((*x___0).k).as_mut_ptr() as *mut C).offset(i___2 as isize) as UC
                    as uI;
                if (*x___0).n == *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize) {
                    *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize) = i___2;
                }
                i___2 += 1;
            }
        }
        4 => {
            setS(1 as libc::c_int, 0 as libc::c_int as I);
            i___3 = 0 as libc::c_int as I;
            _i___4 = (*x___0).n;
            while i___3 < _i___4 {
                v___1 = *(((*x___0).k).as_mut_ptr() as *mut S).offset(i___3 as isize);
                if *(v___1 as *mut I).offset(-(1 as libc::c_int) as isize) == 0 {
                    tmp___8 = strlen(v___1 as *const libc::c_char);
                    tmp___9 = fnv1a(v___1 as *mut UC, tmp___8 as I);
                    *(v___1 as *mut I)
                        .offset(-(1 as libc::c_int) as isize) = tmp___9 as I;
                }
                tmp___10 = _hgv(
                    y,
                    *(v___1 as *mut I).offset(-(1 as libc::c_int) as isize) as uI,
                    v___1 as V,
                    x___0,
                    &mut p,
                );
                if (*x___0).n == tmp___10 {
                    *(((*y).k).as_mut_ptr() as *mut I).offset(p as isize) = i___3;
                }
                i___3 += 1;
            }
        }
        _ => {}
    }
    (*y).t = -(5 as libc::c_int) as I;
    return y;
}
pub unsafe extern "C" fn hash_find(mut a: K, mut b___1: K) -> K {
    let mut x___0: K = 0 as *mut k0;
    let mut y: K = 0 as *mut k0;
    let mut k: uI = 0;
    let mut p: uI = 0;
    let mut i: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___1: UI = 0;
    let mut v: uI = 0;
    let mut tmp___2: uint32_t = 0;
    let mut v___0: S = 0 as *mut C;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: uint32_t = 0;
    let mut tmp___5: K = 0 as *mut k0;
    x___0 = *((*a).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    y = *((*a).k).as_mut_ptr().offset(1 as libc::c_int as isize);
    if (*x___0).t > 0 as libc::c_longlong {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if (*x___0).t != 0 {
        if (*x___0).t + (*b___1).t != 0 {
            tmp___0 = Ki((*x___0).n);
            return tmp___0;
        }
    }
    hcinit();
    match -(*x___0).t {
        0 => {
            tmp___1 = hcode(b___1);
            i = _hgk(y, tmp___1, b___1, x___0, &mut p);
        }
        1 | 2 => {
            v = *(((*b___1).k).as_mut_ptr() as *mut uI);
            tmp___2 = hc(v);
            i = _hg(y, tmp___2 as uI, v as I, x___0, &mut p);
        }
        3 => {
            k = *(((*b___1).k).as_mut_ptr() as *mut C) as UC as uI;
            i = *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize);
            if i < 0 as libc::c_longlong {
                i = (*x___0).n;
            }
        }
        4 => {
            v___0 = *(((*b___1).k).as_mut_ptr() as *mut S);
            tmp___3 = strlen(v___0 as *const libc::c_char);
            tmp___4 = fnv1a(v___0 as *mut UC, tmp___3 as I);
            k = tmp___4 as uI;
            i = _hgv(y, k, v___0 as V, x___0, &mut p);
        }
        _ => {}
    }
    tmp___5 = Ki(i);
    return tmp___5;
}
pub unsafe extern "C" fn find(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut an: I = 0;
    let mut bt: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___1: K = 0 as *mut k0;
    let mut i___1: I = 0;
    let mut _i___2: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: I = 0;
    let mut fb: F = 0.;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_double = 0.;
    let mut tmp___6: libc::c_double = 0.;
    let mut i___2: I = 0;
    let mut _i___3: I = 0;
    let mut tmp___7: K = 0 as *mut k0;
    let mut tmp___8: I = 0;
    let mut i___3: I = 0;
    let mut _i___4: I = 0;
    let mut tmp___9: K = 0 as *mut k0;
    let mut tmp___10: libc::c_double = 0.;
    let mut tmp___11: libc::c_double = 0.;
    let mut tmp___12: libc::c_double = 0.;
    let mut tmp___13: I = 0;
    let mut i___4: I = 0;
    let mut _i___5: I = 0;
    let mut tmp___14: K = 0 as *mut k0;
    let mut tmp___15: K = 0 as *mut k0;
    let mut i___5: I = 0;
    let mut _i___6: I = 0;
    let mut tmp___16: K = 0 as *mut k0;
    let mut tmp___17: I = 0;
    let mut tmp___18: K = 0 as *mut k0;
    at___0 = (*a).t;
    an = (*a).n;
    bt = (*b___1).t;
    if at___0 > 0 as libc::c_longlong {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if -(4 as libc::c_longlong) == at___0 {
        if 4 as libc::c_longlong == bt {
            i = 0 as libc::c_int as I;
            _i___0 = an;
            while i < _i___0 {
                if *(((*a).k).as_mut_ptr() as *mut S).offset(i as isize) as libc::c_ulong
                    == *(((*b___1).k).as_mut_ptr() as *mut S) as libc::c_ulong
                {
                    tmp___0 = Ki(i);
                    return tmp___0;
                }
                i += 1;
            }
        }
    }
    if -(3 as libc::c_longlong) == at___0 {
        if 3 as libc::c_longlong == bt {
            i___0 = 0 as libc::c_int as I;
            _i___1 = an;
            while i___0 < _i___1 {
                if *(((*a).k).as_mut_ptr() as *mut C).offset(i___0 as isize)
                    as libc::c_int
                    == *(((*b___1).k).as_mut_ptr() as *mut C) as libc::c_int
                {
                    tmp___1 = Ki(i___0);
                    return tmp___1;
                }
                i___0 += 1;
            }
        }
    }
    if -(2 as libc::c_longlong) == at___0 {
        if 2 as libc::c_longlong == bt {
            i___1 = 0 as libc::c_int as I;
            _i___2 = an;
            while i___1 < _i___2 {
                tmp___3 = FC(
                    *(((*a).k).as_mut_ptr() as *mut F).offset(i___1 as isize),
                    *(((*b___1).k).as_mut_ptr() as *mut F),
                );
                if tmp___3 == 0 {
                    tmp___2 = Ki(i___1);
                    return tmp___2;
                }
                i___1 += 1;
            }
        }
    }
    if -(2 as libc::c_longlong) == at___0 {
        if 1 as libc::c_longlong == bt {
            if 9223372036854775807 as libc::c_longlong
                == *(((*b___1).k).as_mut_ptr() as *mut I)
            {
                tmp___6 = 1 as libc::c_int as libc::c_double / 0.0f64;
            } else {
                if -(9223372036854775807 as libc::c_longlong)
                    == *(((*b___1).k).as_mut_ptr() as *mut I)
                {
                    tmp___5 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                } else {
                    if (-(0x7fffffffffffffff as libc::c_long)
                        - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                        == *(((*b___1).k).as_mut_ptr() as *mut I)
                    {
                        tmp___4 = 0 as libc::c_int as libc::c_double / 0.0f64;
                    } else {
                        tmp___4 = *(((*b___1).k).as_mut_ptr() as *mut I)
                            as libc::c_double;
                    }
                    tmp___5 = tmp___4;
                }
                tmp___6 = tmp___5;
            }
            fb = tmp___6;
            i___2 = 0 as libc::c_int as I;
            _i___3 = an;
            while i___2 < _i___3 {
                tmp___8 = FC(
                    *(((*a).k).as_mut_ptr() as *mut F).offset(i___2 as isize),
                    fb,
                );
                if tmp___8 == 0 {
                    tmp___7 = Ki(i___2);
                    return tmp___7;
                }
                i___2 += 1;
            }
        }
    }
    if -(1 as libc::c_longlong) == at___0 {
        if 2 as libc::c_longlong == bt {
            i___3 = 0 as libc::c_int as I;
            _i___4 = an;
            while i___3 < _i___4 {
                if 9223372036854775807 as libc::c_longlong
                    == *(((*a).k).as_mut_ptr() as *mut I).offset(i___3 as isize)
                {
                    tmp___12 = 1 as libc::c_int as libc::c_double / 0.0f64;
                } else {
                    if -(9223372036854775807 as libc::c_longlong)
                        == *(((*a).k).as_mut_ptr() as *mut I).offset(i___3 as isize)
                    {
                        tmp___11 = -(1 as libc::c_int as libc::c_double / 0.0f64);
                    } else {
                        if (-(0x7fffffffffffffff as libc::c_long)
                            - 1 as libc::c_int as libc::c_long) as libc::c_longlong
                            == *(((*a).k).as_mut_ptr() as *mut I).offset(i___3 as isize)
                        {
                            tmp___10 = 0 as libc::c_int as libc::c_double / 0.0f64;
                        } else {
                            tmp___10 = *(((*a).k).as_mut_ptr() as *mut I)
                                .offset(i___3 as isize) as libc::c_double;
                        }
                        tmp___11 = tmp___10;
                    }
                    tmp___12 = tmp___11;
                }
                tmp___13 = FC(tmp___12, *(((*b___1).k).as_mut_ptr() as *mut F));
                if tmp___13 == 0 {
                    tmp___9 = Ki(i___3);
                    return tmp___9;
                }
                i___3 += 1;
            }
        }
    }
    if -(1 as libc::c_longlong) == at___0 {
        if 1 as libc::c_longlong == bt {
            i___4 = 0 as libc::c_int as I;
            _i___5 = an;
            while i___4 < _i___5 {
                if *(((*a).k).as_mut_ptr() as *mut I).offset(i___4 as isize)
                    == *(((*b___1).k).as_mut_ptr() as *mut I)
                {
                    tmp___14 = Ki(i___4);
                    return tmp___14;
                }
                i___4 += 1;
            }
        }
    }
    if at___0 == 0 {
        if 2 as libc::c_longlong == an {
            if -(5 as libc::c_longlong)
                == (**((*a).k).as_mut_ptr().offset(1 as libc::c_int as isize)).t
            {
                tmp___15 = hash_find(a, b___1);
                return tmp___15;
            }
        }
        i___5 = 0 as libc::c_int as I;
        _i___6 = an;
        while i___5 < _i___6 {
            tmp___17 = matchI(*((*a).k).as_mut_ptr().offset(i___5 as isize), b___1);
            if tmp___17 != 0 {
                tmp___16 = Ki(i___5);
                return tmp___16;
            }
            i___5 += 1;
        }
    }
    tmp___18 = Ki(an);
    return tmp___18;
}
unsafe extern "C" fn num_ex(mut a: K, mut x___0: F) -> F {
    let mut y: F = 0.;
    let mut b___1: K = 0 as *mut k0;
    let mut g: K = 0 as *mut k0;
    let mut k: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    y = 0 as libc::c_int as F;
    b___1 = Kf(x___0);
    if b___1.is_null() {
        return 0 as libc::c_int as libc::c_double / 0.0f64;
    }
    g = newK(0 as libc::c_int as I, 1 as libc::c_int as I);
    if g.is_null() {
        cd(b___1);
        return 0 as libc::c_int as libc::c_double / 0.0f64;
    }
    let ref mut fresh353 = *((*g).k).as_mut_ptr().offset(0 as libc::c_int as isize);
    *fresh353 = ci(b___1);
    tmp = vf_ex(&mut a as *mut K as V, g);
    k = tmp;
    if k.is_null() {
        y = 0 as libc::c_int as libc::c_double / 0.0f64;
    } else {
        let mut current_block_21: u64;
        if (*k).t != 1 as libc::c_longlong {
            if (*k).t != 2 as libc::c_longlong {
                y = 0 as libc::c_int as libc::c_double / 0.0f64;
                current_block_21 = 224731115979188411;
            } else {
                current_block_21 = 17393450596804690908;
            }
        } else {
            current_block_21 = 17393450596804690908;
        }
        match current_block_21 {
            17393450596804690908 => {
                if (*k).t == 1 as libc::c_longlong {
                    y = *(((*k).k).as_mut_ptr() as *mut I) as F;
                } else {
                    y = *(((*k).k).as_mut_ptr() as *mut F);
                }
            }
            _ => {}
        }
    }
    cd(b___1);
    cd(k);
    cd(g);
    return y;
}
unsafe extern "C" fn isShallowNumeric(mut k: K) -> I {
    let mut tmp: I = 0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut t: I = 0;
    if (*k).t < 0 as libc::c_longlong {
        tmp = -(*k).t;
    } else {
        tmp = (*k).t;
    }
    if tmp > 2 as libc::c_longlong {
        return 0 as libc::c_int as I;
    }
    if 0 as libc::c_longlong == (*k).t {
        i = 0 as libc::c_int as I;
        _i___0 = (*k).n;
        while i < _i___0 {
            t = (**((*k).k).as_mut_ptr().offset(i as isize)).t;
            if t != 1 as libc::c_longlong {
                if t != 2 as libc::c_longlong {
                    return 0 as libc::c_int as I;
                }
            }
            i += 1;
        }
    }
    return 1 as libc::c_int as I;
}
unsafe extern "C" fn ithFloat(mut k: K, mut i: I) -> F {
    let mut n: I = 0;
    let mut tmp: I = 0;
    if k.is_null() {
        return 0 as libc::c_int as F;
    }
    n = (*k).n;
    if (*k).t == 0 {
        k = *((*k).k).as_mut_ptr().offset((i % n) as isize);
        i = 0 as libc::c_int as I;
    }
    if (*k).t < 0 as libc::c_longlong {
        tmp = -(*k).t;
    } else {
        tmp = (*k).t;
    }
    if 1 as libc::c_longlong == tmp {
        return *(((*k).k).as_mut_ptr() as *mut I).offset((i % n) as isize) as F;
    }
    return *(((*k).k).as_mut_ptr() as *mut F).offset((i % n) as isize);
}
unsafe extern "C" fn inverter(mut a: K, mut b___1: K, mut c: K, mut index___0: I) -> F {
    let mut y: F = 0.;
    let mut tmp: F = 0.;
    let mut i: I = 0;
    let mut m: I = 0;
    let mut r: F = 0.;
    let mut tmp___0: F = 0.;
    let mut i___0: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___1: F = 0.;
    let mut d___0: F = 0.;
    let mut e: F = 0.;
    let mut tmp___2: F = 0.;
    let mut tmp___3: F = 0.;
    let mut tmp___4: F = 0.;
    let mut tmp___5: I = 0;
    tmp = ithFloat(b___1, index___0);
    y = tmp;
    m = 20 as libc::c_int as I;
    let vla = (m + 2 as libc::c_longlong) as usize;
    let mut x___0: Vec::<F> = ::std::vec::from_elem(0., vla);
    let vla_0 = (m + 2 as libc::c_longlong) as usize;
    let mut f: Vec::<F> = ::std::vec::from_elem(0., vla_0);
    *x___0.as_mut_ptr().offset(0 as libc::c_int as isize) = 0.9998f64;
    *x___0.as_mut_ptr().offset(1 as libc::c_int as isize) = 0.9999f64;
    if !c.is_null() {
        tmp___0 = ithFloat(c, index___0);
        r = tmp___0;
        *x___0.as_mut_ptr().offset(0 as libc::c_int as isize) = 0.9999f64 * r;
        *x___0.as_mut_ptr().offset(1 as libc::c_int as isize) = r;
    }
    i___0 = 0 as libc::c_int as I;
    _i___0 = 2 as libc::c_int as I;
    while i___0 < _i___0 {
        tmp___1 = num_ex(a, *x___0.as_mut_ptr().offset(i___0 as isize));
        *f.as_mut_ptr().offset(i___0 as isize) = tmp___1 - y;
        i___0 += 1;
    }
    if y != 0. {
        tmp___2 = y * 0.000001f64;
    } else {
        tmp___2 = 0.000001f64;
    }
    e = tmp___2;
    i = 0 as libc::c_int as I;
    while i < m {
        d___0 = (*x___0.as_mut_ptr().offset((i + 1 as libc::c_longlong) as isize)
            - *x___0.as_mut_ptr().offset(i as isize))
            / (*f.as_mut_ptr().offset((i + 1 as libc::c_longlong) as isize)
                - *f.as_mut_ptr().offset(i as isize))
            * *f.as_mut_ptr().offset((i + 1 as libc::c_longlong) as isize);
        *x___0
            .as_mut_ptr()
            .offset(
                (i + 2 as libc::c_longlong) as isize,
            ) = *x___0.as_mut_ptr().offset((i + 1 as libc::c_longlong) as isize) - d___0;
        tmp___3 = num_ex(
            a,
            *x___0.as_mut_ptr().offset((i + 2 as libc::c_longlong) as isize),
        );
        *f.as_mut_ptr().offset((i + 2 as libc::c_longlong) as isize) = tmp___3 - y;
        if d___0 < 0 as libc::c_int as F {
            tmp___4 = -d___0;
        } else {
            tmp___4 = d___0;
        }
        if tmp___4 < e {
            break;
        }
        tmp___5 = FC(
            *f.as_mut_ptr().offset((i + 2 as libc::c_longlong) as isize),
            0.0f64,
        );
        if tmp___5 == 0 {
            break;
        }
        i += 1;
    }
    if i >= m {
        kerr(b"limit\0" as *const u8 as *const libc::c_char);
        return 0 as libc::c_int as F;
    }
    return *x___0.as_mut_ptr().offset((i + 2 as libc::c_longlong) as isize);
}
pub unsafe extern "C" fn what_triadic(mut a: K, mut b___1: K, mut c: K) -> K {
    let mut bt: I = 0;
    let mut bn: I = 0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut zn: I = 0;
    let mut zt: I = 0;
    let mut z: K = 0 as *mut k0;
    let mut tmp___5: K = 0 as *mut k0;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    bt = (*b___1).t;
    bn = (*b___1).n;
    tmp___0 = isShallowNumeric(b___1);
    if tmp___0 != 0 {
        if !c.is_null() {
            tmp___1 = isShallowNumeric(c);
            if tmp___1 == 0 {
                tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    } else {
        tmp = kerr(b"type\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if bt == 0 {
        if bn == 0 {
            tmp___2 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
            return tmp___2;
        }
    }
    if !c.is_null() {
        if (*c).t == 0 {
            if (*c).n == 0 {
                tmp___2 = newK(0 as libc::c_int as I, 0 as libc::c_int as I);
                return tmp___2;
            }
        }
    }
    if 0 as libc::c_longlong == bn {
        tmp___3 = newK(-(2 as libc::c_int) as I, 0 as libc::c_int as I);
        return tmp___3;
    } else {
        if !c.is_null() {
            if 0 as libc::c_longlong == (*c).n {
                tmp___3 = newK(-(2 as libc::c_int) as I, 0 as libc::c_int as I);
                return tmp___3;
            }
        }
    }
    if !c.is_null() {
        if (*c).t < 1 as libc::c_longlong {
            if bt < 1 as libc::c_longlong {
                if (*c).n != (*b___1).n {
                    tmp___4 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                    return tmp___4;
                }
            }
        }
    }
    zn = bn;
    zt = 2 as libc::c_int as I;
    if bt < 1 as libc::c_longlong {
        zt = -(2 as libc::c_int) as I;
    } else if !c.is_null() {
        if (*c).t < 1 as libc::c_longlong {
            zt = -(2 as libc::c_int) as I;
        }
    }
    if !c.is_null() {
        if zn > (*c).n {
            zn = zn;
        } else {
            zn = (*c).n;
        }
    }
    tmp___5 = newK(zt, zn);
    z = tmp___5;
    if z.is_null() {
        return 0 as K;
    }
    i = 0 as libc::c_int as I;
    _i___0 = zn;
    while i < _i___0 {
        *(((*z).k).as_mut_ptr() as *mut F).offset(i as isize) = inverter(a, b___1, c, i);
        i += 1;
    }
    return z;
}
unsafe extern "C" fn qrand(mut a: K, mut b___1: K) -> K {
    let mut at___0: I = 0;
    let mut bt: I = 0;
    let mut y: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut c: I = 0;
    let mut n: I = 0;
    let mut tmp___1: I = 0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut j: I = 0;
    let mut k: I = 0;
    let mut s: I = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut f: F = 0.;
    let mut i: I = 0;
    let mut _i___0: I = 0;
    let mut tmp___5: F = 0.;
    let mut d___0: I = 0;
    let mut i___0: I = 0;
    let mut _i___1: I = 0;
    let mut tmp___6: F = 0.;
    let mut tmp___7: F = 0.;
    at___0 = (*a).t;
    bt = (*b___1).t;
    if at___0 < 0 as libc::c_longlong {
        tmp___0 = -at___0;
    } else {
        tmp___0 = at___0;
    }
    if 1 as libc::c_longlong != tmp___0 {
        tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if 1 as libc::c_longlong != bt {
            if 2 as libc::c_longlong != bt {
                tmp = kerr(b"int\0" as *const u8 as *const libc::c_char);
                return tmp;
            }
        }
    }
    c = *(((*a).k).as_mut_ptr() as *mut I);
    if c < 0 as libc::c_longlong {
        tmp___1 = -c;
    } else {
        tmp___1 = c;
    }
    n = tmp___1;
    if 1 as libc::c_longlong == bt {
        if c < 0 as libc::c_longlong {
            if *(((*b___1).k).as_mut_ptr() as *mut I) < -c {
                tmp___2 = kerr(b"length\0" as *const u8 as *const libc::c_char);
                return tmp___2;
            }
        }
    }
    if 1 as libc::c_longlong == bt {
        if *(((*b___1).k).as_mut_ptr() as *mut I) < 0 as libc::c_longlong {
            tmp___3 = kerr(b"domain\0" as *const u8 as *const libc::c_char);
            return tmp___3;
        }
    }
    j = 0 as libc::c_int as I;
    if 1 as libc::c_longlong == bt {
        tmp___4 = -(1 as libc::c_int);
    } else {
        tmp___4 = -(2 as libc::c_int);
    }
    y = newK(tmp___4 as I, n);
    if y.is_null() {
        return 0 as K;
    }
    if 2 as libc::c_longlong == bt {
        f = *(((*b___1).k).as_mut_ptr() as *mut F);
        i = 0 as libc::c_int as I;
        _i___0 = n;
        while i < _i___0 {
            tmp___5 = RF();
            *(((*y).k).as_mut_ptr() as *mut F).offset(i as isize) = tmp___5 * f;
            i += 1;
        }
        return y;
    }
    d___0 = *(((*b___1).k).as_mut_ptr() as *mut I);
    if c >= 0 as libc::c_longlong {
        i___0 = 0 as libc::c_int as I;
        _i___1 = n;
        while i___0 < _i___1 {
            tmp___6 = RF();
            *(((*y).k).as_mut_ptr() as *mut I)
                .offset(i___0 as isize) = (d___0 as F * tmp___6) as I;
            i___0 += 1;
        }
    } else {
        vitter(((*y).k).as_mut_ptr() as *mut I, (*y).n, d___0);
        j = n - 1 as libc::c_longlong;
        while j > 0 as libc::c_longlong {
            tmp___7 = RF();
            k = ((1 as libc::c_longlong + j) as F * tmp___7) as I;
            s = *(((*y).k).as_mut_ptr() as *mut I).offset(j as isize);
            *(((*y).k).as_mut_ptr() as *mut I)
                .offset(
                    j as isize,
                ) = *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize);
            *(((*y).k).as_mut_ptr() as *mut I).offset(k as isize) = s;
            j -= 1;
        }
    }
    return y;
}
pub unsafe extern "C" fn sample(mut x___0: K, mut y: K) -> K {
    let mut a: K = 0 as *mut k0;
    let mut b___1: K = 0 as *mut k0;
    let mut z: K = 0 as *mut k0;
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: I = 0;
    let mut tmp___1: I = 0;
    if (*y).n == 0 {
        tmp = take(x___0, y);
        return tmp;
    }
    tmp___0 = countI(y);
    b___1 = Ki(tmp___0);
    if b___1.is_null() {
        return 0 as K;
    }
    a = qrand(x___0, b___1);
    tmp___1 = OOM_CD(0 as libc::c_int as I, a, b___1, -(1 as libc::c_int) as V);
    if tmp___1 == 0 {
        return 0 as K;
    }
    cd(b___1);
    z = at_verb(y, a);
    cd(a);
    return z;
}
pub unsafe extern "C" fn what(mut x___0: K, mut y: K) -> K {
    let mut tmp: K = 0 as *mut k0;
    let mut tmp___0: K = 0 as *mut k0;
    let mut tmp___2: K = 0 as *mut k0;
    let mut tmp___3: K = 0 as *mut k0;
    let mut tmp___4: K = 0 as *mut k0;
    let mut tmp___5: I = 0;
    let mut tmp___6: K = 0 as *mut k0;
    if 1 as libc::c_longlong == (*x___0).t {
        tmp = kerr(b"domain\0" as *const u8 as *const libc::c_char);
        return tmp;
    }
    if 7 as libc::c_longlong == (*x___0).t {
        tmp___0 = what_triadic(x___0, y, 0 as K);
        return tmp___0;
    }
    if 1 as libc::c_longlong == (*x___0).t {
        tmp___5 = atomI(y);
        if tmp___5 != 0 {
            tmp___2 = qrand(x___0, y);
            tmp___4 = tmp___2;
        } else {
            tmp___3 = sample(x___0, y);
            tmp___4 = tmp___3;
        }
        return tmp___4;
    }
    tmp___6 = find(x___0, y);
    return tmp___6;
}
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut S) -> libc::c_int {
    kinit();
    args(argc, argv);
    attend();
    return 0 as libc::c_int;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0((args.len() - 1) as libc::c_int, args.as_mut_ptr() as *mut S) as i32,
        )
    }
}
