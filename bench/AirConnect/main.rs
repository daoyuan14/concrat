use ::libc;
use ::c2rust_bitfields;
use ::c2rust_asm_casts;
use c2rust_asm_casts::AsmCastTrait;
use std::arch::asm;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type FLAC__StreamEncoderProtected;
    pub type FLAC__StreamEncoderPrivate;
    pub type shine_global_flags;
    pub type bio_st;
    pub type rsa_st;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
    fn ixmlDocument_createDocument() -> *mut IXML_Document;
    fn ixmlDocument_free(doc: *mut IXML_Document);
    fn ixmlNodetoString(doc: *mut IXML_Node) -> *mut libc::c_char;
    fn UpnpMakeAction(
        ActionName: *const libc::c_char,
        ServType: *const libc::c_char,
        NumArg: libc::c_int,
        Arg: *const libc::c_char,
        _: ...
    ) -> *mut IXML_Document;
    fn UpnpAddToAction(
        ActionDoc: *mut *mut IXML_Document,
        ActionName: *const libc::c_char,
        ServType: *const libc::c_char,
        ArgName: *const libc::c_char,
        ArgVal: *const libc::c_char,
    ) -> libc::c_int;
    fn UpnpSendAction(
        Hnd: UpnpClient_Handle,
        ActionURL: *const libc::c_char,
        ServiceType: *const libc::c_char,
        DevUDN: *const libc::c_char,
        Action: *mut IXML_Document,
        RespNode: *mut *mut IXML_Document,
    ) -> libc::c_int;
    fn UpnpSendActionAsync(
        Hnd: UpnpClient_Handle,
        ActionURL: *const libc::c_char,
        ServiceType: *const libc::c_char,
        DevUDN: *const libc::c_char,
        Action: *mut IXML_Document,
        Fun: Option::<
            unsafe extern "C" fn(
                Upnp_EventType,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        Cookie: *const libc::c_void,
    ) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn signal(
        __sig: libc::c_int,
        __handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    ) -> __sighandler_t;
    fn strcasecmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
    fn pause() -> libc::c_int;
    fn getpid() -> __pid_t;
    fn gethostname(__name: *mut libc::c_char, __len: size_t) -> libc::c_int;
    fn daemon(__nochdir: libc::c_int, __noclose: libc::c_int) -> libc::c_int;
    fn ftruncate(__fd: libc::c_int, __length: __off64_t) -> libc::c_int;
    fn inet_addr(__cp: *const libc::c_char) -> in_addr_t;
    fn inet_ntoa(__in: in_addr) -> *mut libc::c_char;
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option::<
            unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
    fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn asprintf(
        __ptr: *mut *mut libc::c_char,
        __fmt: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn scanf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn fileno(__stream: *mut FILE) -> libc::c_int;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn exit(_: libc::c_int) -> !;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strtok(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcasestr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn UpnpInit(HostIP: *const libc::c_char, DestPort: libc::c_ushort) -> libc::c_int;
    fn UpnpFinish() -> libc::c_int;
    fn UpnpGetServerPort() -> libc::c_ushort;
    fn UpnpRegisterClient(
        Callback: Option::<
            unsafe extern "C" fn(
                Upnp_EventType,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        Cookie: *const libc::c_void,
        Hnd: *mut UpnpClient_Handle,
    ) -> libc::c_int;
    fn UpnpUnRegisterClient(Hnd: UpnpClient_Handle) -> libc::c_int;
    fn UpnpSetMaxContentLength(contentLength: size_t) -> libc::c_int;
    fn UpnpSearchAsync(
        Hnd: UpnpClient_Handle,
        Mx: libc::c_int,
        TTarget_constarget_const: *const libc::c_char,
        Cookie_const: *const libc::c_void,
    ) -> libc::c_int;
    fn UpnpSubscribeAsync(
        Hnd: UpnpClient_Handle,
        PublisherUrl: *const libc::c_char,
        TimeOut: libc::c_int,
        Fun: Option::<
            unsafe extern "C" fn(
                Upnp_EventType,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        Cookie: *const libc::c_void,
    ) -> libc::c_int;
    fn UpnpDownloadXmlDoc(
        url: *const libc::c_char,
        xmlDoc: *mut *mut IXML_Document,
    ) -> libc::c_int;
    fn ixmlNode_getNodeName(nodeptr: *mut IXML_Node) -> *const libc::c_char;
    fn ixmlNode_getNodeValue(nodeptr: *mut IXML_Node) -> *const libc::c_char;
    fn ixmlNode_getFirstChild(nodeptr: *mut IXML_Node) -> *mut IXML_Node;
    fn ixmlNode_getPreviousSibling(nodeptr: *mut IXML_Node) -> *mut IXML_Node;
    fn ixmlNode_getNextSibling(nodeptr: *mut IXML_Node) -> *mut IXML_Node;
    fn ixmlNode_getAttributes(nodeptr: *mut IXML_Node) -> *mut IXML_NamedNodeMap;
    fn ixmlDocument_getElementsByTagName(
        doc: *mut IXML_Document,
        tagName: *const libc::c_char,
    ) -> *mut IXML_NodeList;
    fn ixmlDocument_getElementById(
        doc: *mut IXML_Document,
        tagName: *const libc::c_char,
    ) -> *mut IXML_Element;
    fn ixmlElement_getAttribute(
        element: *mut IXML_Element,
        name: *const libc::c_char,
    ) -> *const libc::c_char;
    fn ixmlElement_getElementsByTagName(
        element: *mut IXML_Element,
        tagName: *const libc::c_char,
    ) -> *mut IXML_NodeList;
    fn ixmlNamedNodeMap_getLength(nnMap: *mut IXML_NamedNodeMap) -> libc::c_ulong;
    fn ixmlNamedNodeMap_item(
        nnMap: *mut IXML_NamedNodeMap,
        index: libc::c_ulong,
    ) -> *mut IXML_Node;
    fn ixmlNamedNodeMap_free(nnMap: *mut IXML_NamedNodeMap);
    fn ixmlNodeList_item(
        nList: *mut IXML_NodeList,
        index: libc::c_ulong,
    ) -> *mut IXML_Node;
    fn ixmlNodeList_length(nList: *mut IXML_NodeList) -> libc::c_ulong;
    fn ixmlNodeList_free(nList: *mut IXML_NodeList);
    fn ixmlParseBuffer(buffer: *const libc::c_char) -> *mut IXML_Document;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn UpnpUnSubscribeAsync(
        Hnd: UpnpClient_Handle,
        SubsId: *mut libc::c_char,
        Fun: Option::<
            unsafe extern "C" fn(
                Upnp_EventType,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        Cookie: *const libc::c_void,
    ) -> libc::c_int;
    fn UpnpResolveURL(
        BaseURL: *const libc::c_char,
        RelURL: *const libc::c_char,
        AbsURL: *mut libc::c_char,
    ) -> libc::c_int;
    fn ixmlNode_getParentNode(nodeptr: *mut IXML_Node) -> *mut IXML_Node;
    fn ixmlNode_getChildNodes(nodeptr: *mut IXML_Node) -> *mut IXML_NodeList;
    fn ixmlNode_removeChild(
        nodeptr: *mut IXML_Node,
        oldChild: *mut IXML_Node,
        returnNode: *mut *mut IXML_Node,
    ) -> libc::c_int;
    fn ixmlNode_appendChild(
        nodeptr: *mut IXML_Node,
        newChild: *mut IXML_Node,
    ) -> libc::c_int;
    fn ixmlNode_free(nodeptr: *mut IXML_Node);
    fn ixmlDocument_importNode(
        doc: *mut IXML_Document,
        importNode: *mut IXML_Node,
        deep: BOOL,
        rtNode: *mut *mut IXML_Node,
    ) -> libc::c_int;
    fn ixmlDocumenttoString(doc: *mut IXML_Document) -> *mut libc::c_char;
    fn ixmlLoadDocument(xmlFile: *const libc::c_char) -> *mut IXML_Document;
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn rand() -> libc::c_int;
    fn llabs(_: libc::c_longlong) -> libc::c_longlong;
    fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn AES_set_decrypt_key(
        userKey: *const libc::c_uchar,
        bits: libc::c_int,
        key: *mut AES_KEY,
    ) -> libc::c_int;
    fn AES_cbc_encrypt(
        in_0: *const libc::c_uchar,
        out: *mut libc::c_uchar,
        length: size_t,
        key: *const AES_KEY,
        ivec: *mut libc::c_uchar,
        enc: libc::c_int,
    );
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn send(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
    ) -> ssize_t;
    fn sendto(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> ssize_t;
    fn recvfrom(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
    fn setsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *const libc::c_void,
        __optlen: socklen_t,
    ) -> libc::c_int;
    fn listen(__fd: libc::c_int, __n: libc::c_int) -> libc::c_int;
    fn accept(
        __fd: libc::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> libc::c_int;
    fn FLAC__stream_encoder_new() -> *mut FLAC__StreamEncoder;
    fn FLAC__stream_encoder_delete(encoder: *mut FLAC__StreamEncoder);
    fn FLAC__stream_encoder_set_verify(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_set_streamable_subset(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_set_channels(
        encoder: *mut FLAC__StreamEncoder,
        value: uint32_t,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_set_bits_per_sample(
        encoder: *mut FLAC__StreamEncoder,
        value: uint32_t,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_set_sample_rate(
        encoder: *mut FLAC__StreamEncoder,
        value: uint32_t,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_set_compression_level(
        encoder: *mut FLAC__StreamEncoder,
        value: uint32_t,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_set_blocksize(
        encoder: *mut FLAC__StreamEncoder,
        value: uint32_t,
    ) -> FLAC__bool;
    fn FLAC__stream_encoder_init_stream(
        encoder: *mut FLAC__StreamEncoder,
        write_callback: Option::<
            unsafe extern "C" fn(
                *const FLAC__StreamEncoder,
                *const FLAC__byte,
                size_t,
                uint32_t,
                uint32_t,
                *mut libc::c_void,
            ) -> FLAC__StreamEncoderWriteStatus,
        >,
        seek_callback: Option::<
            unsafe extern "C" fn(
                *const FLAC__StreamEncoder,
                FLAC__uint64,
                *mut libc::c_void,
            ) -> FLAC__StreamEncoderSeekStatus,
        >,
        tell_callback: Option::<
            unsafe extern "C" fn(
                *const FLAC__StreamEncoder,
                *mut FLAC__uint64,
                *mut libc::c_void,
            ) -> FLAC__StreamEncoderTellStatus,
        >,
        metadata_callback: Option::<
            unsafe extern "C" fn(
                *const FLAC__StreamEncoder,
                *const FLAC__StreamMetadata,
                *mut libc::c_void,
            ) -> (),
        >,
        client_data: *mut libc::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
    fn FLAC__stream_encoder_finish(encoder: *mut FLAC__StreamEncoder) -> FLAC__bool;
    fn FLAC__stream_encoder_process_interleaved(
        encoder: *mut FLAC__StreamEncoder,
        buffer: *const FLAC__int32,
        samples: uint32_t,
    ) -> FLAC__bool;
    fn shine_set_config_mpeg_defaults(mpeg: *mut shine_mpeg_t);
    fn shine_initialise(config: *mut shine_config_t) -> shine_t;
    fn shine_samples_per_pass(s: shine_t) -> libc::c_int;
    fn shine_encode_buffer_interleaved(
        s: shine_t,
        data: *mut int16_t,
        written: *mut libc::c_int,
    ) -> *mut libc::c_uchar;
    fn shine_flush(s: shine_t, written: *mut libc::c_int) -> *mut libc::c_uchar;
    fn shine_close(s: shine_t);
    fn socket(
        __domain: libc::c_int,
        __type: libc::c_int,
        __protocol: libc::c_int,
    ) -> libc::c_int;
    fn getsockname(
        __fd: libc::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> libc::c_int;
    fn connect(
        __fd: libc::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> libc::c_int;
    fn recv(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
    ) -> ssize_t;
    fn shutdown(__fd: libc::c_int, __how: libc::c_int) -> libc::c_int;
    fn BIO_free(a: *mut BIO) -> libc::c_int;
    fn BIO_new_mem_buf(buf_0: *const libc::c_void, len: libc::c_int) -> *mut BIO;
    fn RSA_size(rsa: *const RSA) -> libc::c_int;
    fn RSA_private_encrypt(
        flen: libc::c_int,
        from: *const libc::c_uchar,
        to: *mut libc::c_uchar,
        rsa: *mut RSA,
        padding: libc::c_int,
    ) -> libc::c_int;
    fn RSA_private_decrypt(
        flen: libc::c_int,
        from: *const libc::c_uchar,
        to: *mut libc::c_uchar,
        rsa: *mut RSA,
        padding: libc::c_int,
    ) -> libc::c_int;
    fn RSA_free(r: *mut RSA);
    fn PEM_read_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: Option::<pem_password_cb>,
        u: *mut libc::c_void,
    ) -> *mut RSA;
    fn strndup(_: *const libc::c_char, _: libc::c_ulong) -> *mut libc::c_char;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    fn bind(__fd: libc::c_int, __addr: *const sockaddr, __len: socklen_t) -> libc::c_int;
    fn gettimeofday(__tv: *mut timeval, __tz: *mut libc::c_void) -> libc::c_int;
    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;
    fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
    fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
    fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
    fn ioctl(__fd: libc::c_int, __request: libc::c_ulong, _: ...) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn vsprintf(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn vasprintf(
        __ptr: *mut *mut libc::c_char,
        __f: *const libc::c_char,
        __arg: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn ixmlNode_setNodeValue(
        nodeptr: *mut IXML_Node,
        newNodeValue: *const libc::c_char,
    ) -> libc::c_int;
    fn ixmlNode_getLocalName(nodeptr: *mut IXML_Node) -> *const libc::c_char;
    fn ixmlDocument_createElement(
        doc: *mut IXML_Document,
        tagName: *const libc::c_char,
    ) -> *mut IXML_Element;
    fn ixmlDocument_createTextNode(
        doc: *mut IXML_Document,
        data: *const libc::c_char,
    ) -> *mut IXML_Node;
    fn ixmlElement_setAttribute(
        element: *mut IXML_Element,
        name: *const libc::c_char,
        value: *const libc::c_char,
    ) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn strftime(
        __s: *mut libc::c_char,
        __maxsize: size_t,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> size_t;
    fn localtime(__timer: *const time_t) -> *mut tm;
    fn abort() -> !;
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn getsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *mut libc::c_void,
        __optlen: *mut socklen_t,
    ) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;
    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
    fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
    fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: libc::c_int,
    ) -> libc::c_int;
    fn dlclose(__handle: *mut libc::c_void) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_div_t_773697287 {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
pub type div_t = __anonstruct_div_t_773697287;
pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type int32_t = __int32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
pub type socklen_t = __socklen_t;
pub type __gnuc_va_list = __builtin_va_list;
pub type u8_t = u_int8_t;
pub type u16_t = u_int16_t;
pub type u32_t = u_int32_t;
pub type u64_t = u_int64_t;
pub type s32_t = int32_t;
pub type BOOL = libc::c_int;
pub type __anonenum_IXML_NODE_TYPE_562787448 = libc::c_uint;
pub const eNOTATION_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 12;
pub const eDOCUMENT_FRAGMENT_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 11;
pub const eDOCUMENT_TYPE_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 10;
pub const eDOCUMENT_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 9;
pub const eCOMMENT_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 8;
pub const ePROCESSING_INSTRUCTION_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 7;
pub const eENTITY_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 6;
pub const eENTITY_REFERENCE_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 5;
pub const eCDATA_SECTION_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 4;
pub const eTEXT_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 3;
pub const eATTRIBUTE_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 2;
pub const eELEMENT_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 1;
pub const eINVALID_NODE: __anonenum_IXML_NODE_TYPE_562787448 = 0;
pub type IXML_NODE_TYPE = __anonenum_IXML_NODE_TYPE_562787448;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IXML_Document {
    pub n: IXML_Node,
}
pub type IXML_Node = _IXML_Node;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IXML_Node {
    pub nodeName: *mut libc::c_char,
    pub nodeValue: *mut libc::c_char,
    pub nodeType: IXML_NODE_TYPE,
    pub namespaceURI: *mut libc::c_char,
    pub prefix: *mut libc::c_char,
    pub localName: *mut libc::c_char,
    pub readOnly: BOOL,
    pub parentNode: Nodeptr,
    pub firstChild: Nodeptr,
    pub prevSibling: Nodeptr,
    pub nextSibling: Nodeptr,
    pub firstAttr: Nodeptr,
    pub ownerDocument: Docptr,
}
pub type Docptr = *mut _IXML_Document;
pub type Nodeptr = *mut _IXML_Node;
pub type IXML_Document = _IXML_Document;
pub type UpnpClient_Handle = libc::c_int;
pub type Upnp_EventType_e = libc::c_uint;
pub const UPNP_EVENT_SUBSCRIPTION_EXPIRED: Upnp_EventType_e = 14;
pub const UPNP_EVENT_AUTORENEWAL_FAILED: Upnp_EventType_e = 13;
pub const UPNP_EVENT_UNSUBSCRIBE_COMPLETE: Upnp_EventType_e = 12;
pub const UPNP_EVENT_SUBSCRIBE_COMPLETE: Upnp_EventType_e = 11;
pub const UPNP_EVENT_RENEWAL_COMPLETE: Upnp_EventType_e = 10;
pub const UPNP_EVENT_RECEIVED: Upnp_EventType_e = 9;
pub const UPNP_EVENT_SUBSCRIPTION_REQUEST: Upnp_EventType_e = 8;
pub const UPNP_DISCOVERY_SEARCH_TIMEOUT: Upnp_EventType_e = 7;
pub const UPNP_DISCOVERY_SEARCH_RESULT: Upnp_EventType_e = 6;
pub const UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE: Upnp_EventType_e = 5;
pub const UPNP_DISCOVERY_ADVERTISEMENT_ALIVE: Upnp_EventType_e = 4;
pub const UPNP_CONTROL_GET_VAR_COMPLETE: Upnp_EventType_e = 3;
pub const UPNP_CONTROL_GET_VAR_REQUEST: Upnp_EventType_e = 2;
pub const UPNP_CONTROL_ACTION_COMPLETE: Upnp_EventType_e = 1;
pub const UPNP_CONTROL_ACTION_REQUEST: Upnp_EventType_e = 0;
pub type Upnp_EventType = Upnp_EventType_e;
pub type Upnp_SID = [libc::c_char; 44];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sQueue_e {
    pub next: *mut sQueue_e,
    pub item: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_tQueue_157918770 {
    pub mutex: *mut pthread_mutex_t,
    pub cleanup: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub list: sQueue_e,
}
pub type tQueue = __anonstruct_tQueue_157918770;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct metadata_s {
    pub artist: *mut libc::c_char,
    pub album: *mut libc::c_char,
    pub title: *mut libc::c_char,
    pub genre: *mut libc::c_char,
    pub path: *mut libc::c_char,
    pub artwork: *mut libc::c_char,
    pub remote_title: *mut libc::c_char,
    pub track: u32_t,
    pub duration: u32_t,
    pub track_hash: u32_t,
    pub sample_rate: u32_t,
    pub sample_size: u8_t,
    pub channels: u8_t,
}
pub type metadata_t = metadata_s;
pub type __anonenum_raop_event_t_164395424 = libc::c_uint;
pub const RAOP_VOLUME: __anonenum_raop_event_t_164395424 = 5;
pub const RAOP_STOP: __anonenum_raop_event_t_164395424 = 4;
pub const RAOP_PAUSE: __anonenum_raop_event_t_164395424 = 3;
pub const RAOP_FLUSH: __anonenum_raop_event_t_164395424 = 2;
pub const RAOP_PLAY: __anonenum_raop_event_t_164395424 = 1;
pub const RAOP_STREAM: __anonenum_raop_event_t_164395424 = 0;
pub type raop_event_t = __anonenum_raop_event_t_164395424;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct raop_ctx_s {
    pub svc: *mut mdns_service,
    pub svr: *mut mdnsd,
    pub host: in_addr,
    pub port: libc::c_ushort,
    pub sock: libc::c_int,
    pub hport: libc::c_ushort,
    pub peer: in_addr,
    pub latencies: *mut libc::c_char,
    pub running: bool,
    pub encode: encode_t,
    pub drift: bool,
    pub flush: bool,
    pub thread: pthread_t,
    pub search_thread: pthread_t,
    pub mac: [libc::c_uchar; 6],
    pub rtsp: __anonstruct_rtsp_476363767,
    pub ht: *mut hairtunes_s,
    pub raop_cb: Option::<
        unsafe extern "C" fn(*mut libc::c_void, raop_event_t, *mut libc::c_void) -> (),
    >,
    pub http_cb: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut key_data_s, *mut key_data_s) -> (),
    >,
    pub active_remote: __anonstruct_active_remote_822481794,
    pub owner: *mut libc::c_void,
    pub ports: __anonstruct_ports_376111945,
    pub http_length: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_ports_376111945 {
    pub base: u16_t,
    pub range: u16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_active_remote_822481794 {
    pub DACPid: [libc::c_char; 32],
    pub id: [libc::c_char; 32],
    pub host: in_addr,
    pub port: u16_t,
    pub handle: *mut mDNShandle_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mDNShandle_s {
    pub sock: libc::c_int,
    pub state: __anonenum_state_567020907,
    pub control: mDNScontrol_e,
    pub last: uint32_t,
    pub context: context_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct context_s {
    pub query: *mut libc::c_char,
    pub ttl: uint32_t,
    pub slist: *mut slist_t,
    pub alist: *mut alist_t,
}
pub type alist_t = alist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct alist_s {
    pub next: *mut alist_s,
    pub eol: uint32_t,
    pub name: *mut libc::c_char,
    pub addr: in_addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_addr_t = uint32_t;
pub type uint32_t = __uint32_t;
pub type slist_t = slist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct slist_s {
    pub next: *mut slist_s,
    pub status: __anonenum_status_277728880,
    pub eol: [uint32_t; 3],
    pub seen: uint32_t,
    pub name: *mut libc::c_char,
    pub hostname: *mut libc::c_char,
    pub addr: in_addr,
    pub host: in_addr,
    pub port: uint16_t,
    pub txt_length: libc::c_int,
    pub txt: *mut libc::c_char,
}
pub type uint16_t = __uint16_t;
pub type __anonenum_status_277728880 = libc::c_uint;
pub const MDNS_EXPIRED: __anonenum_status_277728880 = 2;
pub const MDNS_UPDATED: __anonenum_status_277728880 = 1;
pub const MDNS_CURRENT: __anonenum_status_277728880 = 0;
pub type mDNScontrol_e = __anonenum_mDNScontrol_e_242194298;
pub type __anonenum_mDNScontrol_e_242194298 = libc::c_uint;
pub const MDNS_SUSPEND: __anonenum_mDNScontrol_e_242194298 = 2;
pub const MDNS_RESET: __anonenum_mDNScontrol_e_242194298 = 1;
pub const MDNS_NONE: __anonenum_mDNScontrol_e_242194298 = 0;
pub type __anonenum_state_567020907 = libc::c_uint;
pub const MDNS_RUNNING: __anonenum_state_567020907 = 1;
pub const MDNS_IDLE: __anonenum_state_567020907 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct key_data_s {
    pub key: *mut libc::c_char,
    pub data: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct hairtunes_s {
    pub running: bool,
    pub aesiv: [libc::c_uchar; 16],
    pub aes: AES_KEY,
    pub decrypt: bool,
    pub range: bool,
    pub frame_size: libc::c_int,
    pub in_frames: libc::c_int,
    pub out_frames: libc::c_int,
    pub host: in_addr,
    pub rtp_host: sockaddr_in,
    pub rtp_sockets: [__anonstruct_rtp_sockets_660642390; 3],
    pub timing: timing_s,
    pub synchro: __anonstruct_synchro_126477707,
    pub record: __anonstruct_record_382962036,
    pub latency: libc::c_int,
    pub delay: libc::c_int,
    pub resent_frames: u32_t,
    pub silent_frames: u32_t,
    pub silence_count: u32_t,
    pub filled_frames: u32_t,
    pub http_fill: bool,
    pub pause: bool,
    pub skip: libc::c_int,
    pub audio_buffer: [abuf_t; 1024],
    pub http_listener: libc::c_int,
    pub ab_read: seq_t,
    pub ab_write: seq_t,
    pub ab_mutex: pthread_mutex_t,
    pub http_thread: pthread_t,
    pub rtp_thread: pthread_t,
    pub encode: __anonstruct_encode_755591885,
    pub icy: __anonstruct_icy_978631765,
    pub metadata: metadata_s,
    pub silence_frame: *mut libc::c_char,
    pub alac_codec: *mut alac_file,
    pub flush_seqno: libc::c_int,
    pub playing: bool,
    pub silence: bool,
    pub http_ready: bool,
    pub event_cb: Option::<
        unsafe extern "C" fn(*mut libc::c_void, hairtunes_event_t) -> (),
    >,
    pub http_cb: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut key_data_s, *mut key_data_s) -> (),
    >,
    pub owner: *mut libc::c_void,
    pub http_tail: *mut libc::c_char,
    pub http_count: size_t,
    pub http_length: libc::c_int,
}
pub type hairtunes_event_t = __anonenum_hairtunes_event_t_112117092;
pub type __anonenum_hairtunes_event_t_112117092 = libc::c_uint;
pub const HAIRTUNES_PLAY: __anonenum_hairtunes_event_t_112117092 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct alac_file {
    pub input_buffer: *mut libc::c_uchar,
    pub input_buffer_bitaccumulator: libc::c_int,
    pub samplesize: libc::c_int,
    pub numchannels: libc::c_int,
    pub bytespersample: libc::c_int,
    pub predicterror_buffer_a: *mut int32_t,
    pub predicterror_buffer_b: *mut int32_t,
    pub outputsamples_buffer_a: *mut int32_t,
    pub outputsamples_buffer_b: *mut int32_t,
    pub uncompressed_bytes_buffer_a: *mut int32_t,
    pub uncompressed_bytes_buffer_b: *mut int32_t,
    pub setinfo_max_samples_per_frame: uint32_t,
    pub setinfo_7a: uint8_t,
    pub setinfo_sample_size: uint8_t,
    pub setinfo_rice_historymult: uint8_t,
    pub setinfo_rice_initialhistory: uint8_t,
    pub setinfo_rice_kmodifier: uint8_t,
    pub setinfo_7f: uint8_t,
    pub setinfo_80: uint16_t,
    pub setinfo_82: uint32_t,
    pub setinfo_86: uint32_t,
    pub setinfo_8a_rate: uint32_t,
}
pub type uint8_t = __uint8_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_icy_978631765 {
    pub interval: size_t,
    pub remain: size_t,
    pub updated: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_encode_755591885 {
    pub buffer: [libc::c_char; 9216],
    pub codec: *mut libc::c_void,
    pub config: encode_t,
    pub len: libc::c_int,
    pub header: bool,
}
pub type encode_t = __anonstruct_encode_t_239194442;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_encode_t_239194442 {
    pub codec: __anonenum_codec_812345935,
    pub __annonCompField8: __anonunion____missing_field_name_960959629,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_960959629 {
    pub mp3: __anonstruct_mp3_266379400,
    pub flac: __anonstruct_flac_1037408948,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_flac_1037408948 {
    pub level: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_mp3_266379400 {
    pub bitrate: libc::c_int,
    pub icy: bool,
}
pub type __anonenum_codec_812345935 = libc::c_uint;
pub const CODEC_WAV: __anonenum_codec_812345935 = 3;
pub const CODEC_PCM: __anonenum_codec_812345935 = 2;
pub const CODEC_FLAC: __anonenum_codec_812345935 = 1;
pub const CODEC_MP3: __anonenum_codec_812345935 = 0;
pub type seq_t = u16_t;
pub type abuf_t = audio_buffer_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct audio_buffer_entry {
    pub ready: libc::c_int,
    pub rtptime: u32_t,
    pub last_resend: u32_t,
    pub data: *mut s16_t,
    pub len: libc::c_int,
}
pub type s16_t = int16_t;
pub type int16_t = __int16_t;
pub type __int16_t = libc::c_short;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_record_382962036 {
    pub time: u32_t,
    pub seqno: seq_t,
    pub rtptime: u32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_synchro_126477707 {
    pub rtp: u32_t,
    pub time: u32_t,
    pub status: u8_t,
    pub first: bool,
    pub required: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timing_s {
    pub drift: bool,
    pub local: u64_t,
    pub remote: u64_t,
    pub count: u32_t,
    pub gap_count: u32_t,
    pub gap_sum: s64_t,
    pub gap_adjust: s64_t,
}
pub type s64_t = int64_t;
pub type int64_t = __int64_t;
pub type __int64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_rtp_sockets_660642390 {
    pub rport: libc::c_ushort,
    pub lport: libc::c_ushort,
    pub sock: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}
pub type in_port_t = uint16_t;
pub type sa_family_t = libc::c_ushort;
pub type AES_KEY = aes_key_st;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct aes_key_st {
    pub rd_key: [libc::c_uint; 60],
    pub rounds: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_rtsp_476363767 {
    pub aesiv: *mut libc::c_char,
    pub aeskey: *mut libc::c_char,
    pub fmtp: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mdnsd {
    pub data_lock: pthread_mutex_t,
    pub sockfd: libc::c_int,
    pub notify_pipe: [libc::c_int; 2],
    pub stop_flag: libc::c_int,
    pub group: *mut rr_group,
    pub announce: *mut rr_list,
    pub services: *mut rr_list,
    pub leave: *mut rr_list,
    pub hostname: *mut uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_list {
    pub e: *mut rr_entry,
    pub next: *mut rr_list,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_entry {
    pub name: *mut uint8_t,
    pub type_0: rr_type,
    pub ttl: uint32_t,
    pub unicast_query: libc::c_char,
    pub cache_flush: libc::c_char,
    pub rr_class: uint16_t,
    pub data: __anonunion_data_487002723,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_data_487002723 {
    pub NSEC: rr_data_nsec,
    pub SRV: rr_data_srv,
    pub TXT: rr_data_txt,
    pub PTR: rr_data_ptr,
    pub A: rr_data_a,
    pub AAAA: rr_data_aaaa,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_data_aaaa {
    pub addr: *mut in6_addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in6_addr {
    pub __in6_u: __anonunion___in6_u_979734923,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion___in6_u_979734923 {
    pub __u6_addr8: [uint8_t; 16],
    pub __u6_addr16: [uint16_t; 8],
    pub __u6_addr32: [uint32_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_data_a {
    pub addr: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_data_ptr {
    pub name: *mut uint8_t,
    pub entry: *mut rr_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_data_txt {
    pub next: *mut rr_data_txt,
    pub txt: *mut uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_data_srv {
    pub priority: uint16_t,
    pub weight: uint16_t,
    pub port: uint16_t,
    pub target: *mut uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_data_nsec {
    pub bitmap: [uint8_t; 5],
}
pub type rr_type = libc::c_uint;
pub const RR_ANY: rr_type = 255;
pub const RR_NSEC: rr_type = 47;
pub const RR_SRV: rr_type = 33;
pub const RR_AAAA: rr_type = 28;
pub const RR_TXT: rr_type = 16;
pub const RR_PTR: rr_type = 12;
pub const RR_A: rr_type = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rr_group {
    pub name: *mut uint8_t,
    pub rr: *mut rr_list,
    pub next: *mut rr_group,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mdns_service {
    pub entries: *mut rr_list,
}
pub type eMRstate = libc::c_uint;
pub const TRANSITIONING: eMRstate = 4;
pub const PAUSED: eMRstate = 3;
pub const PLAYING: eMRstate = 2;
pub const STOPPED: eMRstate = 1;
pub const UNKNOWN: eMRstate = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sService {
    pub Id: [libc::c_char; 250],
    pub Type: [libc::c_char; 250],
    pub EventURL: [libc::c_char; 250],
    pub ControlURL: [libc::c_char; 250],
    pub SID: Upnp_SID,
    pub TimeOut: s32_t,
    pub Failed: u32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_ProtocolInfo_343724373 {
    pub pcm: [libc::c_char; 256],
    pub wav: [libc::c_char; 256],
    pub flac: [libc::c_char; 256],
    pub mp3: [libc::c_char; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sMRConfig {
    pub HTTPLength: libc::c_int,
    pub Enabled: bool,
    pub Name: [libc::c_char; 256],
    pub UPnPMax: libc::c_int,
    pub SendMetaData: bool,
    pub SendCoverArt: bool,
    pub Flush: bool,
    pub MaxVolume: libc::c_int,
    pub Codec: [libc::c_char; 256],
    pub Metadata: bool,
    pub Latency: [libc::c_char; 256],
    pub Drift: bool,
    pub mac: [u8_t; 6],
    pub ArtWork: [libc::c_char; 1024],
    pub ProtocolInfo: __anonstruct_ProtocolInfo_343724373,
}
pub type tMRConfig = sMRConfig;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sAction {
    pub Device: *mut sMR,
    pub ActionNode: *mut libc::c_void,
    pub Param: __anonunion_Param_339046624,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_Param_339046624 {
    pub Volume: u8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sMR {
    pub Magic: u32_t,
    pub Running: bool,
    pub Config: tMRConfig,
    pub UDN: [libc::c_char; 250],
    pub DescDocURL: [libc::c_char; 250],
    pub friendlyName: [libc::c_char; 256],
    pub State: eMRstate,
    pub ExpectStop: bool,
    pub Raop: *mut raop_ctx_s,
    pub MetaData: metadata_t,
    pub RaopState: raop_event_t,
    pub Elapsed: u32_t,
    pub LastSeen: u32_t,
    pub seqN: *mut u8_t,
    pub WaitCookie: *mut libc::c_void,
    pub StartCookie: *mut libc::c_void,
    pub ActionQueue: tQueue,
    pub TrackPoll: libc::c_uint,
    pub StatePoll: libc::c_uint,
    pub Service: [sService; 5],
    pub Actions: *mut sAction,
    pub Master: *mut sMR,
    pub Mutex: pthread_mutex_t,
    pub Thread: pthread_t,
    pub Volume: libc::c_double,
    pub VolumeStampRx: u32_t,
    pub VolumeStampTx: u32_t,
    pub ErrorCount: u16_t,
    pub TimeOut: bool,
    pub ProtocolInfo: *mut libc::c_char,
}
pub type __anonenum_log_level_750577654 = libc::c_uint;
pub const lSDEBUG: __anonenum_log_level_750577654 = 4;
pub const lDEBUG: __anonenum_log_level_750577654 = 3;
pub const lINFO: __anonenum_log_level_750577654 = 2;
pub const lWARN: __anonenum_log_level_750577654 = 1;
pub const lERROR: __anonenum_log_level_750577654 = 0;
pub type log_level = __anonenum_log_level_750577654;
pub type tAction = sAction;
pub type __pid_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___wseq32_112954846 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_750625702 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __anonstruct___wseq32_112954846,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___g1_start32_170565821 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_170565820 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __anonstruct___g1_start32_170565821,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __annonCompField1: __anonunion____missing_field_name_750625702,
    pub __annonCompField2: __anonunion____missing_field_name_170565820,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_condattr_t_488594145 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_condattr_t = __anonunion_pthread_condattr_t_488594145;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_cond_t_951761805 {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type pthread_cond_t = __anonunion_pthread_cond_t_951761805;
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [libc::c_char; 118],
    pub __ss_align: libc::c_ulong,
}
pub type key_data_t = key_data_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Upnp_Action_Complete {
    pub ErrCode: libc::c_int,
    pub CtrlUrl: [libc::c_char; 256],
    pub ActionRequest: *mut IXML_Document,
    pub ActionResult: *mut IXML_Document,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Upnp_Event {
    pub Sid: Upnp_SID,
    pub EventKey: libc::c_int,
    pub ChangedVariables: *mut IXML_Document,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Upnp_Discovery {
    pub ErrCode: libc::c_int,
    pub Expires: libc::c_int,
    pub DeviceId: [libc::c_char; 180],
    pub DeviceType: [libc::c_char; 180],
    pub ServiceType: [libc::c_char; 180],
    pub ServiceVer: [libc::c_char; 180],
    pub Location: [libc::c_char; 180],
    pub Os: [libc::c_char; 180],
    pub Date: [libc::c_char; 180],
    pub Ext: [libc::c_char; 180],
    pub DestAddr: sockaddr_storage,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Upnp_Event_Subscribe {
    pub Sid: Upnp_SID,
    pub ErrCode: libc::c_int,
    pub PublisherUrl: [libc::c_char; 256],
    pub TimeOut: libc::c_int,
}
pub type Upnp_LogLevel_e = libc::c_uint;
pub const UPNP_ALL: Upnp_LogLevel_e = 3;
pub const UPNP_INFO: Upnp_LogLevel_e = 2;
pub const UPNP_PACKET: Upnp_LogLevel_e = 1;
pub const UPNP_CRITICAL: Upnp_LogLevel_e = 0;
pub type Upnp_LogLevel = Upnp_LogLevel_e;
pub type __anonenum_Type_248025457 = libc::c_uint;
pub const SEARCH_TIMEOUT: __anonenum_Type_248025457 = 2;
pub const BYE_BYE: __anonenum_Type_248025457 = 1;
pub const DISCOVERY: __anonenum_Type_248025457 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sUpdate {
    pub Type: __anonenum_Type_248025457,
    pub Data: *mut libc::c_char,
}
pub type tUpdate = sUpdate;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cSearchedSRV_s {
    pub name: [libc::c_char; 250],
    pub idx: libc::c_int,
    pub TimeOut: u32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IXML_Element {
    pub n: IXML_Node,
    pub tagName: *mut libc::c_char,
}
pub type IXML_Element = _IXML_Element;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IXML_NodeList {
    pub nodeItem: *mut IXML_Node,
    pub next: *mut _IXML_NodeList,
}
pub type IXML_NodeList = _IXML_NodeList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IXML_NamedNodeMap {
    pub nodeItem: *mut IXML_Node,
    pub next: *mut _IXML_NamedNodeMap,
}
pub type IXML_NamedNodeMap = _IXML_NamedNodeMap;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct __anonstruct_se_struct_24_422959015 {
    #[bitfield(name = "x", ty = "libc::c_int", bits = "0..=23")]
    pub x: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
}
pub type __suseconds_t = libc::c_long;
pub type ssize_t = __ssize_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_fd_set_356711149 {
    pub fds_bits: [__fd_mask; 16],
}
pub type fd_set = __anonstruct_fd_set_356711149;
pub type uint64_t = __uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_hairtunes_resp_t_422214079 {
    pub cport: libc::c_ushort,
    pub tport: libc::c_ushort,
    pub aport: libc::c_ushort,
    pub hport: libc::c_ushort,
    pub ctx: *mut hairtunes_s,
}
pub type hairtunes_resp_t = __anonstruct_hairtunes_resp_t_422214079;
pub type FLAC__uint8 = uint8_t;
pub type FLAC__int32 = int32_t;
pub type FLAC__uint32 = uint32_t;
pub type FLAC__uint64 = uint64_t;
pub type FLAC__bool = libc::c_int;
pub type FLAC__byte = FLAC__uint8;
pub type __anonenum_FLAC__MetadataType_822905234 = libc::c_uint;
pub const FLAC__MAX_METADATA_TYPE: __anonenum_FLAC__MetadataType_822905234 = 126;
pub const FLAC__METADATA_TYPE_UNDEFINED: __anonenum_FLAC__MetadataType_822905234 = 7;
pub const FLAC__METADATA_TYPE_PICTURE: __anonenum_FLAC__MetadataType_822905234 = 6;
pub const FLAC__METADATA_TYPE_CUESHEET: __anonenum_FLAC__MetadataType_822905234 = 5;
pub const FLAC__METADATA_TYPE_VORBIS_COMMENT: __anonenum_FLAC__MetadataType_822905234 = 4;
pub const FLAC__METADATA_TYPE_SEEKTABLE: __anonenum_FLAC__MetadataType_822905234 = 3;
pub const FLAC__METADATA_TYPE_APPLICATION: __anonenum_FLAC__MetadataType_822905234 = 2;
pub const FLAC__METADATA_TYPE_PADDING: __anonenum_FLAC__MetadataType_822905234 = 1;
pub const FLAC__METADATA_TYPE_STREAMINFO: __anonenum_FLAC__MetadataType_822905234 = 0;
pub type FLAC__MetadataType = __anonenum_FLAC__MetadataType_822905234;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_StreamInfo_396494791 {
    pub min_blocksize: uint32_t,
    pub max_blocksize: uint32_t,
    pub min_framesize: uint32_t,
    pub max_framesize: uint32_t,
    pub sample_rate: uint32_t,
    pub channels: uint32_t,
    pub bits_per_sample: uint32_t,
    pub total_samples: FLAC__uint64,
    pub md5sum: [FLAC__byte; 16],
}
pub type FLAC__StreamMetadata_StreamInfo = __anonstruct_FLAC__StreamMetadata_StreamInfo_396494791;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_Padding_1037408949 {
    pub dummy: libc::c_int,
}
pub type FLAC__StreamMetadata_Padding = __anonstruct_FLAC__StreamMetadata_Padding_1037408949;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_Application_933084990 {
    pub id: [FLAC__byte; 4],
    pub data: *mut FLAC__byte,
}
pub type FLAC__StreamMetadata_Application = __anonstruct_FLAC__StreamMetadata_Application_933084990;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_SeekPoint_665542223 {
    pub sample_number: FLAC__uint64,
    pub stream_offset: FLAC__uint64,
    pub frame_samples: uint32_t,
}
pub type FLAC__StreamMetadata_SeekPoint = __anonstruct_FLAC__StreamMetadata_SeekPoint_665542223;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_SeekTable_430183476 {
    pub num_points: uint32_t,
    pub points: *mut FLAC__StreamMetadata_SeekPoint,
}
pub type FLAC__StreamMetadata_SeekTable = __anonstruct_FLAC__StreamMetadata_SeekTable_430183476;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_VorbisComment_Entry_431082649 {
    pub length: FLAC__uint32,
    pub entry: *mut FLAC__byte,
}
pub type FLAC__StreamMetadata_VorbisComment_Entry = __anonstruct_FLAC__StreamMetadata_VorbisComment_Entry_431082649;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_VorbisComment_149760624 {
    pub vendor_string: FLAC__StreamMetadata_VorbisComment_Entry,
    pub num_comments: FLAC__uint32,
    pub comments: *mut FLAC__StreamMetadata_VorbisComment_Entry,
}
pub type FLAC__StreamMetadata_VorbisComment = __anonstruct_FLAC__StreamMetadata_VorbisComment_149760624;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_CueSheet_Index_485252243 {
    pub offset: FLAC__uint64,
    pub number: FLAC__byte,
}
pub type FLAC__StreamMetadata_CueSheet_Index = __anonstruct_FLAC__StreamMetadata_CueSheet_Index_485252243;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_CueSheet_Track_46655545 {
    pub offset: FLAC__uint64,
    pub number: FLAC__byte,
    pub isrc: [libc::c_char; 13],
    #[bitfield(name = "type_0", ty = "uint32_t", bits = "0..=0")]
    #[bitfield(name = "pre_emphasis", ty = "uint32_t", bits = "1..=1")]
    pub type_0_pre_emphasis: [u8; 1],
    pub num_indices: FLAC__byte,
    pub indices: *mut FLAC__StreamMetadata_CueSheet_Index,
}
pub type FLAC__StreamMetadata_CueSheet_Track = __anonstruct_FLAC__StreamMetadata_CueSheet_Track_46655545;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_CueSheet_959825136 {
    pub media_catalog_number: [libc::c_char; 129],
    pub lead_in: FLAC__uint64,
    pub is_cd: FLAC__bool,
    pub num_tracks: uint32_t,
    pub tracks: *mut FLAC__StreamMetadata_CueSheet_Track,
}
pub type FLAC__StreamMetadata_CueSheet = __anonstruct_FLAC__StreamMetadata_CueSheet_959825136;
pub type __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = libc::c_uint;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 21;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 20;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 19;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 18;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_FISH: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 17;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 16;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 15;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 14;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 13;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 12;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 11;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_BAND: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 10;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 9;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 8;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 7;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 6;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 5;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 4;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 3;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 2;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 1;
pub const FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER: __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 = 0;
pub type FLAC__StreamMetadata_Picture_Type = __anonenum_FLAC__StreamMetadata_Picture_Type_722181312;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_Picture_949245910 {
    pub type_0: FLAC__StreamMetadata_Picture_Type,
    pub mime_type: *mut libc::c_char,
    pub description: *mut FLAC__byte,
    pub width: FLAC__uint32,
    pub height: FLAC__uint32,
    pub depth: FLAC__uint32,
    pub colors: FLAC__uint32,
    pub data_length: FLAC__uint32,
    pub data: *mut FLAC__byte,
}
pub type FLAC__StreamMetadata_Picture = __anonstruct_FLAC__StreamMetadata_Picture_949245910;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_Unknown_409514583 {
    pub data: *mut FLAC__byte,
}
pub type FLAC__StreamMetadata_Unknown = __anonstruct_FLAC__StreamMetadata_Unknown_409514583;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_data_646410294 {
    pub stream_info: FLAC__StreamMetadata_StreamInfo,
    pub padding: FLAC__StreamMetadata_Padding,
    pub application: FLAC__StreamMetadata_Application,
    pub seek_table: FLAC__StreamMetadata_SeekTable,
    pub vorbis_comment: FLAC__StreamMetadata_VorbisComment,
    pub cue_sheet: FLAC__StreamMetadata_CueSheet,
    pub picture: FLAC__StreamMetadata_Picture,
    pub unknown: FLAC__StreamMetadata_Unknown,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamMetadata_912216532 {
    pub type_0: FLAC__MetadataType,
    pub is_last: FLAC__bool,
    pub length: uint32_t,
    pub data: __anonunion_data_646410294,
}
pub type FLAC__StreamMetadata = __anonstruct_FLAC__StreamMetadata_912216532;
pub type __anonenum_FLAC__StreamEncoderInitStatus_423082740 = libc::c_uint;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 13;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 12;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 11;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 10;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 9;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 8;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 7;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 6;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 5;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 4;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 3;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 2;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 1;
pub const FLAC__STREAM_ENCODER_INIT_STATUS_OK: __anonenum_FLAC__StreamEncoderInitStatus_423082740 = 0;
pub type FLAC__StreamEncoderInitStatus = __anonenum_FLAC__StreamEncoderInitStatus_423082740;
pub type __anonenum_FLAC__StreamEncoderWriteStatus_240045189 = libc::c_uint;
pub const FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR: __anonenum_FLAC__StreamEncoderWriteStatus_240045189 = 1;
pub const FLAC__STREAM_ENCODER_WRITE_STATUS_OK: __anonenum_FLAC__StreamEncoderWriteStatus_240045189 = 0;
pub type FLAC__StreamEncoderWriteStatus = __anonenum_FLAC__StreamEncoderWriteStatus_240045189;
pub type __anonenum_FLAC__StreamEncoderSeekStatus_483072504 = libc::c_uint;
pub const FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED: __anonenum_FLAC__StreamEncoderSeekStatus_483072504 = 2;
pub const FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR: __anonenum_FLAC__StreamEncoderSeekStatus_483072504 = 1;
pub const FLAC__STREAM_ENCODER_SEEK_STATUS_OK: __anonenum_FLAC__StreamEncoderSeekStatus_483072504 = 0;
pub type FLAC__StreamEncoderSeekStatus = __anonenum_FLAC__StreamEncoderSeekStatus_483072504;
pub type __anonenum_FLAC__StreamEncoderTellStatus_853679927 = libc::c_uint;
pub const FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED: __anonenum_FLAC__StreamEncoderTellStatus_853679927 = 2;
pub const FLAC__STREAM_ENCODER_TELL_STATUS_ERROR: __anonenum_FLAC__StreamEncoderTellStatus_853679927 = 1;
pub const FLAC__STREAM_ENCODER_TELL_STATUS_OK: __anonenum_FLAC__StreamEncoderTellStatus_853679927 = 0;
pub type FLAC__StreamEncoderTellStatus = __anonenum_FLAC__StreamEncoderTellStatus_853679927;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_FLAC__StreamEncoder_294495691 {
    pub protected_: *mut FLAC__StreamEncoderProtected,
    pub private_: *mut FLAC__StreamEncoderPrivate,
}
pub type FLAC__StreamEncoder = __anonstruct_FLAC__StreamEncoder_294495691;
pub type channels = libc::c_uint;
pub const PCM_STEREO: channels = 2;
pub const PCM_MONO: channels = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_shine_wave_t_932429307 {
    pub channels: channels,
    pub samplerate: libc::c_int,
}
pub type shine_wave_t = __anonstruct_shine_wave_t_932429307;
pub type modes = libc::c_uint;
pub const MONO: modes = 3;
pub const DUAL_CHANNEL: modes = 2;
pub const JOINT_STEREO: modes = 1;
pub const STEREO: modes = 0;
pub type emph = libc::c_uint;
pub const CITT: emph = 3;
pub const MU50_15: emph = 1;
pub const NONE: emph = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_shine_mpeg_t_269278397 {
    pub mode: modes,
    pub bitr: libc::c_int,
    pub emph: emph,
    pub copyright: libc::c_int,
    pub original: libc::c_int,
}
pub type shine_mpeg_t = __anonstruct_shine_mpeg_t_269278397;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_shine_config_t_328299085 {
    pub wave: shine_wave_t,
    pub mpeg: shine_mpeg_t,
}
pub type shine_config_t = __anonstruct_shine_config_t_328299085;
pub type shine_t = *mut shine_global_flags;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct wave_header_s {
    pub chunk_id: [u8_t; 4],
    pub chunk_size: [u8_t; 4],
    pub format: [u8_t; 4],
    pub subchunk1_id: [u8_t; 4],
    pub subchunk1_size: [u8_t; 4],
    pub audio_format: [u8_t; 2],
    pub channels: [u8_t; 2],
    pub sample_rate: [u8_t; 4],
    pub byte_rate: [u8_t; 4],
    pub block_align: [u8_t; 2],
    pub bits_per_sample: [u8_t; 2],
    pub subchunk2_id: [u8_t; 4],
    pub subchunk2_size: [u8_t; 4],
}
pub type hairtunes_t = hairtunes_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_port_213969425 {
    pub count: libc::c_ushort,
    pub offset: libc::c_ushort,
}
pub type BIO = bio_st;
pub type RSA = rsa_st;
pub type pem_password_cb = unsafe extern "C" fn(
    *mut libc::c_char,
    libc::c_int,
    libc::c_int,
    *mut libc::c_void,
) -> libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct txt_attr_s {
    pub name: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
pub type txt_attr_t = txt_attr_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mDNSservice_s {
    pub next: *mut mDNSservice_s,
    pub host: in_addr,
    pub name: *mut libc::c_char,
    pub hostname: *mut libc::c_char,
    pub addr: in_addr,
    pub port: libc::c_ushort,
    pub since: libc::c_uint,
    pub expired: bool,
    pub attr: *mut txt_attr_t,
    pub attr_count: libc::c_int,
}
pub type mDNSservice_t = mDNSservice_s;
pub type mdns_callback_t = unsafe extern "C" fn(
    *mut mDNSservice_t,
    *mut libc::c_void,
    *mut bool,
) -> bool;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_dmap_settings_779894284 {
    pub on_dict_start: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
        ) -> (),
    >,
    pub on_dict_end: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
        ) -> (),
    >,
    pub on_int32: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            int32_t,
        ) -> (),
    >,
    pub on_int64: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            int64_t,
        ) -> (),
    >,
    pub on_uint32: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            uint32_t,
        ) -> (),
    >,
    pub on_uint64: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            uint64_t,
        ) -> (),
    >,
    pub on_date: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            uint32_t,
        ) -> (),
    >,
    pub on_string: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            *const libc::c_char,
            size_t,
        ) -> (),
    >,
    pub on_data: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_char,
            *const libc::c_char,
            size_t,
        ) -> (),
    >,
    pub ctx: *mut libc::c_void,
}
pub type dmap_settings = __anonstruct_dmap_settings_779894284;
pub type raop_ctx_t = raop_ctx_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_port_213969425___0 {
    pub count: libc::c_ushort,
    pub offset: libc::c_ushort,
}
pub type __clockid_t = libc::c_int;
pub type __caddr_t = *mut libc::c_char;
pub type caddr_t = __caddr_t;
pub type clockid_t = __clockid_t;
pub type nfds_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pollfd {
    pub fd: libc::c_int,
    pub events: libc::c_short,
    pub revents: libc::c_short,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ifmap {
    pub mem_start: libc::c_ulong,
    pub mem_end: libc::c_ulong,
    pub base_addr: libc::c_ushort,
    pub irq: libc::c_uchar,
    pub dma: libc::c_uchar,
    pub port: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_ifr_ifrn_352126815 {
    pub ifrn_name: [libc::c_char; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_ifr_ifru_537349870 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: libc::c_short,
    pub ifru_ivalue: libc::c_int,
    pub ifru_mtu: libc::c_int,
    pub ifru_map: ifmap,
    pub ifru_slave: [libc::c_char; 16],
    pub ifru_newname: [libc::c_char; 16],
    pub ifru_data: __caddr_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ifreq {
    pub ifr_ifrn: __anonunion_ifr_ifrn_352126815,
    pub ifr_ifru: __anonunion_ifr_ifru_537349870,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_ifc_ifcu_753034691 {
    pub ifcu_buf: __caddr_t,
    pub ifcu_req: *mut ifreq,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ifconf {
    pub ifc_len: libc::c_int,
    pub ifc_ifcu: __anonunion_ifc_ifcu_753034691,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arpreq {
    pub arp_pa: sockaddr,
    pub arp_ha: sockaddr,
    pub arp_flags: libc::c_int,
    pub arp_netmask: sockaddr,
    pub arp_dev: [libc::c_char; 16],
}
pub type va_list___0 = __gnuc_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct list_s {
    pub next: *mut list_s,
}
pub type list_t = list_s;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
pub type __anonenum_DMAP_TYPE_89445397 = libc::c_uint;
pub const DMAP_ITEM: __anonenum_DMAP_TYPE_89445397 = 8;
pub const DMAP_DICT: __anonenum_DMAP_TYPE_89445397 = 7;
pub const DMAP_VERS: __anonenum_DMAP_TYPE_89445397 = 6;
pub const DMAP_DATE: __anonenum_DMAP_TYPE_89445397 = 5;
pub const DMAP_DATA: __anonenum_DMAP_TYPE_89445397 = 4;
pub const DMAP_STR: __anonenum_DMAP_TYPE_89445397 = 3;
pub const DMAP_INT: __anonenum_DMAP_TYPE_89445397 = 2;
pub const DMAP_UINT: __anonenum_DMAP_TYPE_89445397 = 1;
pub const DMAP_UNKNOWN: __anonenum_DMAP_TYPE_89445397 = 0;
pub type DMAP_TYPE = __anonenum_DMAP_TYPE_89445397;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_dmap_field_217118876 {
    pub code: *const libc::c_char,
    pub type_0: DMAP_TYPE,
    pub list_item_type: DMAP_TYPE,
    pub name: *const libc::c_char,
}
pub type dmap_field = __anonstruct_dmap_field_217118876;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mDNSMessageStruct {
    pub id: uint16_t,
    pub flags: uint16_t,
    pub qd_count: uint16_t,
    pub an_count: uint16_t,
    pub ns_count: uint16_t,
    pub ar_count: uint16_t,
    pub data: *mut libc::c_char,
    pub data_size: size_t,
}
pub type mDNSMessage = mDNSMessageStruct;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_mDNSFlags_485089013 {
    pub qr: libc::c_int,
    pub opcode: libc::c_int,
    pub aa: libc::c_int,
    pub tc: libc::c_int,
    pub rd: libc::c_int,
    pub ra: libc::c_int,
    pub zero: libc::c_int,
    pub ad: libc::c_int,
    pub cd: libc::c_int,
    pub rcode: libc::c_int,
}
pub type mDNSFlags = __anonstruct_mDNSFlags_485089013;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_mDNSQuestion_1021182219 {
    pub qname: *mut libc::c_char,
    pub qtype: uint16_t,
    pub qclass: uint16_t,
    pub prefer_unicast_response: libc::c_int,
}
pub type mDNSQuestion = __anonstruct_mDNSQuestion_1021182219;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_mDNSResourceRecord_782783891 {
    pub name: *mut libc::c_char,
    pub type_0: uint16_t,
    pub class: uint16_t,
    pub ttl: uint32_t,
    pub rdata_length: uint16_t,
    pub rdata: *mut libc::c_void,
}
pub type mDNSResourceRecord = __anonstruct_mDNSResourceRecord_782783891;
pub type mDNShandle_t = mDNShandle_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct item_s {
    pub next: *mut item_s,
}
pub type item_t = item_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mdns_pkt {
    pub id: uint16_t,
    pub flags: uint16_t,
    pub num_qn: uint16_t,
    pub num_ans_rr: uint16_t,
    pub num_auth_rr: uint16_t,
    pub num_add_rr: uint16_t,
    pub rr_qn: *mut rr_list,
    pub rr_ans: *mut rr_list,
    pub rr_auth: *mut rr_list,
    pub rr_add: *mut rr_list,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct name_comp {
    pub label: *mut uint8_t,
    pub pos: size_t,
    pub next: *mut name_comp,
}
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp as libc::c_int;
}
#[inline]
unsafe extern "C" fn atol(mut __nptr: *const libc::c_char) -> libc::c_long {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp;
}
#[inline]
unsafe extern "C" fn bsearch(
    mut __key: *const libc::c_void,
    mut __base: *const libc::c_void,
    mut __nmemb: size_t,
    mut __size: size_t,
    mut __compar: Option::<
        unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
    >,
) -> *mut libc::c_void {
    let mut __l: size_t = 0;
    let mut __u: size_t = 0;
    let mut __idx: size_t = 0;
    let mut __p: *const libc::c_void = 0 as *const libc::c_void;
    let mut __comparison: libc::c_int = 0;
    __l = 0 as libc::c_int as size_t;
    __u = __nmemb;
    while __l < __u {
        __idx = __l.wrapping_add(__u).wrapping_div(2 as libc::c_ulong);
        __p = (__base as *const libc::c_char).offset(__idx.wrapping_mul(__size) as isize)
            as *mut libc::c_void as *const libc::c_void;
        __comparison = (Some(__compar.expect("non-null function pointer")))
            .expect("non-null function pointer")(__key, __p);
        if __comparison < 0 as libc::c_int {
            __u = __idx;
        } else if __comparison > 0 as libc::c_int {
            __l = __idx.wrapping_add(1 as libc::c_ulong);
        } else {
            return __p as *mut libc::c_void
        }
    }
    return 0 as *mut libc::c_void;
}
static mut loglevel: *mut log_level = unsafe {
    &upnp_loglevel as *const log_level as *mut log_level
};
pub unsafe extern "C" fn SubmitTransportAction(
    mut Device: *mut sMR,
    mut ActionNode: *mut IXML_Document,
) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut rc: libc::c_int = 0;
    let mut tmp: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut Action: *mut tAction = 0 as *mut tAction;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    rc = 0 as libc::c_int;
    if ((*Device).WaitCookie).is_null() {
        tmp = (*Device).seqN;
        (*Device).seqN = ((*Device).seqN).offset(1);
        (*Device).WaitCookie = tmp as *mut libc::c_void;
        rc = UpnpSendActionAsync(
            glControlPointHandle,
            ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
            ((*Service).Type).as_mut_ptr() as *const libc::c_char,
            0 as *mut libc::c_void as *const libc::c_char,
            ActionNode,
            Some(
                ActionHandler
                    as unsafe extern "C" fn(
                        Upnp_EventType,
                        *mut libc::c_void,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            (*Device).WaitCookie as *const libc::c_void,
        );
        if rc != 0 as libc::c_int {
            tmp___0 = logtime();
            logprint(
                b"%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n\0" as *const u8
                    as *const libc::c_char,
                tmp___0,
                b"SubmitTransportAction\0" as *const u8 as *const libc::c_char,
                54 as libc::c_int,
                Device,
                rc,
            );
        }
        ixmlDocument_free(ActionNode);
    } else {
        tmp___1 = malloc(::std::mem::size_of::<tAction>() as libc::c_ulong);
        Action = tmp___1 as *mut tAction;
        (*Action).Device = Device;
        (*Action).ActionNode = ActionNode as *mut libc::c_void;
        QueueInsert(&mut (*Device).ActionQueue, Action as *mut libc::c_void);
    }
    return rc == 0 as libc::c_int;
}
pub unsafe extern "C" fn AVTActionFlush(mut Queue: *mut tQueue) {
    let mut Action: *mut tAction = 0 as *mut tAction;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    loop {
        tmp = QueueExtract(Queue);
        Action = tmp as *mut tAction;
        if !(Action as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        free(Action as *mut libc::c_void);
    };
}
pub unsafe extern "C" fn AVTSetURI(
    mut Device: *mut sMR,
    mut URI: *mut libc::c_char,
    mut MetaData: *mut metadata_s,
    mut ProtoInfo: *mut libc::c_char,
) -> bool {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut DIDLData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: bool = false;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    DIDLData = CreateDIDL(URI, ProtoInfo, MetaData, &mut (*Device).Config);
    if *loglevel as libc::c_uint >= 3 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: DIDL header: %s\n\0" as *const u8 as *const libc::c_char,
            tmp,
            b"AVTSetURI\0" as *const u8 as *const libc::c_char,
            89 as libc::c_int,
            Device,
            DIDLData,
        );
    }
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP setURI %s (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"AVTSetURI\0" as *const u8 as *const libc::c_char,
            91 as libc::c_int,
            Device,
            URI,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        b"SetAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"SetAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"CurrentURI\0" as *const u8 as *const libc::c_char,
        URI as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"CurrentURIMetaData\0" as *const u8 as *const libc::c_char,
        DIDLData as *const libc::c_char,
    );
    free(DIDLData as *mut libc::c_void);
    tmp___1 = SubmitTransportAction(Device, ActionNode);
    return tmp___1;
}
pub unsafe extern "C" fn AVTSetNextURI(
    mut Device: *mut sMR,
    mut URI: *mut libc::c_char,
    mut MetaData: *mut metadata_s,
    mut ProtoInfo: *mut libc::c_char,
) -> bool {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut DIDLData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: bool = false;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    DIDLData = CreateDIDL(URI, ProtoInfo, MetaData, &mut (*Device).Config);
    if *loglevel as libc::c_uint >= 3 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: DIDL header: %s\n\0" as *const u8 as *const libc::c_char,
            tmp,
            b"AVTSetNextURI\0" as *const u8 as *const libc::c_char,
            110 as libc::c_int,
            Device,
            DIDLData,
        );
    }
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP setNextURI %s (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"AVTSetNextURI\0" as *const u8 as *const libc::c_char,
            112 as libc::c_int,
            Device,
            URI,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        b"SetNextAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"SetNextAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetNextAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"NextURI\0" as *const u8 as *const libc::c_char,
        URI as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetNextAVTransportURI\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"NextURIMetaData\0" as *const u8 as *const libc::c_char,
        DIDLData as *const libc::c_char,
    );
    free(DIDLData as *mut libc::c_void);
    tmp___1 = SubmitTransportAction(Device, ActionNode);
    return tmp___1;
}
pub unsafe extern "C" fn AVTCallAction(
    mut Device: *mut sMR,
    mut Action: *mut libc::c_char,
    mut Cookie: *mut libc::c_void,
) -> libc::c_int {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut rc: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    if *loglevel as libc::c_uint >= 4 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP %s (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"AVTCallAction\0" as *const u8 as *const libc::c_char,
            130 as libc::c_int,
            Device,
            Action,
            Cookie,
        );
    }
    ActionNode = UpnpMakeAction(
        Action as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int;
    }
    UpnpAddToAction(
        &mut ActionNode,
        Action as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    rc = UpnpSendActionAsync(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        Some(
            ActionHandler
                as unsafe extern "C" fn(
                    Upnp_EventType,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        Cookie as *const libc::c_void,
    );
    if rc != 0 as libc::c_int {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"AVTCallAction\0" as *const u8 as *const libc::c_char,
            138 as libc::c_int,
            Device,
            rc,
        );
    }
    ixmlDocument_free(ActionNode);
    return rc;
}
pub unsafe extern "C" fn AVTPlay(mut Device: *mut sMR) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: bool = false;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP play (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"AVTPlay\0" as *const u8 as *const libc::c_char,
            151 as libc::c_int,
            Device,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        b"Play\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"Play\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"Play\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"Speed\0" as *const u8 as *const libc::c_char,
        b"1\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = SubmitTransportAction(Device, ActionNode);
    return tmp___0;
}
pub unsafe extern "C" fn AVTSetPlayMode(mut Device: *mut sMR) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: bool = false;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP set play mode (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"AVTSetPlayMode\0" as *const u8 as *const libc::c_char,
            167 as libc::c_int,
            Device,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        b"SetPlayMode\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"SetPlayMode\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetPlayMode\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"NewPlayMode\0" as *const u8 as *const libc::c_char,
        b"NORMAL\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = SubmitTransportAction(Device, ActionNode);
    return tmp___0;
}
pub unsafe extern "C" fn AVTSeek(
    mut Device: *mut sMR,
    mut Interval: libc::c_uint,
) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut params: [libc::c_char; 128] = [0; 128];
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: bool = false;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP seek (%ds) (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"AVTSeek\0" as *const u8 as *const libc::c_char,
            183 as libc::c_int,
            Device,
            Interval,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        b"Seek\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"Seek\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    sprintf(
        params.as_mut_ptr(),
        b"%d\0" as *const u8 as *const libc::c_char,
        (Interval.wrapping_div(1000 as libc::c_uint) as libc::c_double + 0.5f64)
            as libc::c_int,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"Seek\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"Unit\0" as *const u8 as *const libc::c_char,
        params.as_mut_ptr() as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"Seek\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"Target\0" as *const u8 as *const libc::c_char,
        b"REL_TIME\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = SubmitTransportAction(Device, ActionNode);
    return tmp___0;
}
pub unsafe extern "C" fn AVTBasic(
    mut Device: *mut sMR,
    mut Action: *mut libc::c_char,
) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: bool = false;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP %s (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"AVTBasic\0" as *const u8 as *const libc::c_char,
            201 as libc::c_int,
            Device,
            Action,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        Action as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        Action as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = SubmitTransportAction(Device, ActionNode);
    return tmp___0;
}
pub unsafe extern "C" fn AVTStop(mut Device: *mut sMR) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut rc: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP stop (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"AVTStop\0" as *const u8 as *const libc::c_char,
            217 as libc::c_int,
            Device,
            (*Device).seqN,
        );
    }
    ActionNode = UpnpMakeAction(
        b"Stop\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    if ActionNode as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"Stop\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    AVTActionFlush(&mut (*Device).ActionQueue);
    tmp___0 = (*Device).seqN;
    (*Device).seqN = ((*Device).seqN).offset(1);
    (*Device).WaitCookie = tmp___0 as *mut libc::c_void;
    rc = UpnpSendActionAsync(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        Some(
            ActionHandler
                as unsafe extern "C" fn(
                    Upnp_EventType,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        (*Device).WaitCookie as *const libc::c_void,
    );
    ixmlDocument_free(ActionNode);
    if rc != 0 as libc::c_int {
        tmp___1 = logtime();
        logprint(
            b"%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___1,
            b"AVTStop\0" as *const u8 as *const libc::c_char,
            230 as libc::c_int,
            Device,
            rc,
        );
    }
    return rc == 0 as libc::c_int;
}
pub unsafe extern "C" fn CtrlSetVolume(
    mut Device: *mut sMR,
    mut Volume: u8_t,
    mut Cookie: *mut libc::c_void,
) -> libc::c_int {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut params: [libc::c_char; 8] = [0; 8];
    let mut rc: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut sService;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP volume %d (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"CtrlSetVolume\0" as *const u8 as *const libc::c_char,
            245 as libc::c_int,
            Device,
            Volume as libc::c_int,
            Cookie,
        );
    }
    ActionNode = UpnpMakeAction(
        b"SetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"Channel\0" as *const u8 as *const libc::c_char,
        b"Master\0" as *const u8 as *const libc::c_char,
    );
    sprintf(
        params.as_mut_ptr(),
        b"%d\0" as *const u8 as *const libc::c_char,
        Volume as libc::c_int,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"DesiredVolume\0" as *const u8 as *const libc::c_char,
        params.as_mut_ptr() as *const libc::c_char,
    );
    rc = UpnpSendActionAsync(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        Some(
            ActionHandler
                as unsafe extern "C" fn(
                    Upnp_EventType,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        Cookie as *const libc::c_void,
    );
    if rc != 0 as libc::c_int {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"CtrlSetVolume\0" as *const u8 as *const libc::c_char,
            256 as libc::c_int,
            Device,
            rc,
        );
    }
    if !ActionNode.is_null() {
        ixmlDocument_free(ActionNode);
    }
    return rc;
}
pub unsafe extern "C" fn CtrlSetMute(
    mut Device: *mut sMR,
    mut Mute: bool,
    mut Cookie: *mut libc::c_void,
) -> libc::c_int {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut rc: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut sService;
    if *loglevel as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP mute %d (cookie %p)\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"CtrlSetMute\0" as *const u8 as *const libc::c_char,
            272 as libc::c_int,
            Device,
            Mute as libc::c_int,
            Cookie,
        );
    }
    ActionNode = UpnpMakeAction(
        b"SetMute\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetMute\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"SetMute\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"Channel\0" as *const u8 as *const libc::c_char,
        b"Master\0" as *const u8 as *const libc::c_char,
    );
    if Mute {
        tmp___0 = b"1\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = b"0\0" as *const u8 as *const libc::c_char;
    }
    UpnpAddToAction(
        &mut ActionNode,
        b"SetMute\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"DesiredMute\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    rc = UpnpSendActionAsync(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        Some(
            ActionHandler
                as unsafe extern "C" fn(
                    Upnp_EventType,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        Cookie as *const libc::c_void,
    );
    if !ActionNode.is_null() {
        ixmlDocument_free(ActionNode);
    }
    if rc != 0 as libc::c_int {
        tmp___1 = logtime();
        logprint(
            b"%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___1,
            b"CtrlSetMute\0" as *const u8 as *const libc::c_char,
            284 as libc::c_int,
            Device,
            rc,
        );
    }
    return rc;
}
pub unsafe extern "C" fn CtrlGetGroupVolume(mut Device: *mut sMR) -> libc::c_int {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Response: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut Item: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut Volume: libc::c_int = 0;
    Response = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(4 as libc::c_int as isize)
        as *mut sService;
    Volume = -(1 as libc::c_int);
    if ((*Service).ControlURL).as_mut_ptr().is_null() {
        return Volume;
    }
    ActionNode = UpnpMakeAction(
        b"GetGroupVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"GetGroupVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpSendAction(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        &mut Response,
    );
    if !ActionNode.is_null() {
        ixmlDocument_free(ActionNode);
    }
    Item = XMLGetFirstDocumentItem(
        Response,
        b"CurrentVolume\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    if !Response.is_null() {
        ixmlDocument_free(Response);
    }
    if !Item.is_null() {
        Volume = atoi(Item as *const libc::c_char);
        free(Item as *mut libc::c_void);
    }
    return Volume;
}
pub unsafe extern "C" fn CtrlGetVolume(mut Device: *mut sMR) -> libc::c_int {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Response: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut Item: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut Volume: libc::c_int = 0;
    Response = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut sService;
    Volume = -(1 as libc::c_int);
    if ((*Service).ControlURL).as_mut_ptr().is_null() {
        return Volume;
    }
    ActionNode = UpnpMakeAction(
        b"GetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"GetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"InstanceID\0" as *const u8 as *const libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char,
    );
    UpnpAddToAction(
        &mut ActionNode,
        b"GetVolume\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        b"Channel\0" as *const u8 as *const libc::c_char,
        b"Master\0" as *const u8 as *const libc::c_char,
    );
    UpnpSendAction(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        &mut Response,
    );
    if !ActionNode.is_null() {
        ixmlDocument_free(ActionNode);
    }
    if !Response.is_null() {
        Item = XMLGetFirstDocumentItem(
            Response,
            b"CurrentVolume\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int != 0,
        );
        if !Item.is_null() {
            Volume = atoi(Item as *const libc::c_char);
            free(Item as *mut libc::c_void);
        }
        ixmlDocument_free(Response);
    }
    return Volume;
}
pub unsafe extern "C" fn GetProtocolInfo(mut Device: *mut sMR) -> *mut libc::c_char {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Response: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut ProtocolInfo: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    Response = 0 as *mut libc::c_void as *mut IXML_Document;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(2 as libc::c_int as isize)
        as *mut sService;
    ProtocolInfo = 0 as *mut libc::c_void as *mut libc::c_char;
    if *loglevel as libc::c_uint >= 3 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: uPNP GetProtocolInfo\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"GetProtocolInfo\0" as *const u8 as *const libc::c_char,
            359 as libc::c_int,
            Device,
        );
    }
    ActionNode = UpnpMakeAction(
        b"GetProtocolInfo\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    UpnpSendAction(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        &mut Response,
    );
    if !ActionNode.is_null() {
        ixmlDocument_free(ActionNode);
    }
    if !Response.is_null() {
        ProtocolInfo = XMLGetFirstDocumentItem(
            Response,
            b"Sink\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int != 0,
        );
        ixmlDocument_free(Response);
        if *loglevel as libc::c_uint >= 3 as libc::c_uint {
            tmp___0 = logtime();
            logprint(
                b"%s %s:%d [%p]: ProtocolInfo %s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___0,
                b"GetProtocolInfo\0" as *const u8 as *const libc::c_char,
                370 as libc::c_int,
                Device,
                ProtocolInfo,
            );
        }
    }
    return ProtocolInfo;
}
unsafe extern "C" fn CreateDIDL(
    mut URI: *mut libc::c_char,
    mut ProtoInfo: *mut libc::c_char,
    mut MetaData: *mut metadata_s,
    mut Config: *mut sMRConfig,
) -> *mut libc::c_char {
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut doc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut tmp: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut root: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut duration: div_t = div_t { quot: 0, rem: 0 };
    let mut tmp___0: div_t = div_t { quot: 0, rem: 0 };
    tmp = ixmlDocument_createDocument();
    doc = tmp;
    root = XMLAddNode(
        doc,
        0 as *mut libc::c_void as *mut IXML_Node,
        b"DIDL-Lite\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        0 as *mut libc::c_void as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        root,
        b"xmlns:dc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"http://purl.org/dc/elements/1.1/\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        root,
        b"xmlns:upnp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"urn:schemas-upnp-org:metadata-1-0/upnp/\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        root,
        b"xmlns\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        root,
        b"xmlns:dlna\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"urn:schemas-dlna-org:metadata-1-0/\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    node = XMLAddNode(
        doc,
        root,
        b"item\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        0 as *mut libc::c_void as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"1\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        node,
        b"parentID\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"0\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    XMLAddAttribute(
        doc,
        node,
        b"restricted\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"1\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if (*MetaData).duration != 0 {
        tmp___0 = div((*MetaData).duration as libc::c_int, 1000 as libc::c_int);
        duration = tmp___0;
        if (*Config).SendMetaData {
            XMLAddNode(
                doc,
                node,
                b"dc:title\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).title,
            );
            XMLAddNode(
                doc,
                node,
                b"dc:creator\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).artist,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:genre\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).genre,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:artist\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*MetaData).artist,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:album\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).album,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:originalTrackNumber\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).track,
            );
            if !((*MetaData).artwork).is_null() {
                XMLAddNode(
                    doc,
                    node,
                    b"upnp:albumArtURI\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*MetaData).artwork,
                );
            }
        }
        XMLAddNode(
            doc,
            node,
            b"upnp:class\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"object.item.audioItem.musicTrack\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        node = XMLAddNode(
            doc,
            node,
            b"res\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            URI,
        );
        XMLAddAttribute(
            doc,
            node,
            b"duration\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"%1d:%02d:%02d.%03d\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            duration.quot / 3600 as libc::c_int,
            duration.quot % 3600 as libc::c_int / 60 as libc::c_int,
            duration.quot % 60 as libc::c_int,
            duration.rem,
        );
    } else {
        if (*Config).SendMetaData {
            XMLAddNode(
                doc,
                node,
                b"dc:title\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).remote_title,
            );
            XMLAddNode(
                doc,
                node,
                b"dc:creator\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:album\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:channelName\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*MetaData).remote_title,
            );
            XMLAddNode(
                doc,
                node,
                b"upnp:channelNr\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*MetaData).track,
            );
            if !((*MetaData).artwork).is_null() {
                XMLAddNode(
                    doc,
                    node,
                    b"upnp:albumArtURI\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*MetaData).artwork,
                );
            }
        }
        XMLAddNode(
            doc,
            node,
            b"upnp:class\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"object.item.audioItem.audioBroadcast\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        node = XMLAddNode(
            doc,
            node,
            b"res\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            URI,
        );
    }
    XMLAddAttribute(
        doc,
        node,
        b"protocolInfo\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ProtoInfo,
    );
    if (*MetaData).sample_rate != 0 {
        if (*MetaData).sample_size != 0 {
            if (*MetaData).channels != 0 {
                XMLAddAttribute(
                    doc,
                    node,
                    b"sampleFrequency\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*MetaData).sample_rate,
                );
                XMLAddAttribute(
                    doc,
                    node,
                    b"bitsPerSample\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%hhu\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*MetaData).sample_size as libc::c_int,
                );
                XMLAddAttribute(
                    doc,
                    node,
                    b"nrAudioChannels\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%hhu\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*MetaData).channels as libc::c_int,
                );
                if (*MetaData).duration != 0 {
                    XMLAddAttribute(
                        doc,
                        node,
                        b"size\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        b"%u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                        (((*MetaData).sample_rate)
                            .wrapping_mul((*MetaData).sample_size as u32_t)
                            .wrapping_div(8 as libc::c_uint)
                            .wrapping_mul((*MetaData).channels as u32_t) as u64_t)
                            .wrapping_mul((*MetaData).duration as u64_t)
                            .wrapping_div(1000 as libc::c_ulong) as u32_t,
                    );
                }
            }
        }
    }
    s = ixmlNodetoString(doc as *mut IXML_Node);
    ixmlDocument_free(doc);
    return s;
}
pub static mut glControlPointHandle: UpnpClient_Handle = 0;
pub static mut glMRDevices: *mut sMR = 0 as *const sMR as *mut sMR;
pub static mut glPortBase: libc::c_ushort = 0;
pub static mut glPortRange: libc::c_ushort = 0;
#[inline]
unsafe extern "C" fn UpnpSetLogLevel(mut log_level: Upnp_LogLevel) {}
pub static mut glLogLimit: s32_t = -(1 as libc::c_int);
pub static mut glMaxDevices: libc::c_int = 32 as libc::c_int;
pub static mut glBinding: [libc::c_char; 128] = [
    '?' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
];
pub static mut main_loglevel: log_level = lINFO;
pub static mut raop_loglevel: log_level = lINFO;
pub static mut util_loglevel: log_level = lWARN;
pub static mut upnp_loglevel: log_level = lINFO;
pub static mut glMRConfig: tMRConfig = {
    let mut init = sMRConfig {
        HTTPLength: -(1 as libc::c_int),
        Enabled: 1 as libc::c_int != 0,
        Name: [
            '\u{0}' as i32 as libc::c_char,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
        UPnPMax: 1 as libc::c_int,
        SendMetaData: 1 as libc::c_int != 0,
        SendCoverArt: 0 as libc::c_int != 0,
        Flush: 1 as libc::c_int != 0,
        MaxVolume: 100 as libc::c_int,
        Codec: [
            'f' as i32 as libc::c_char,
            'l' as i32 as libc::c_char,
            'c' as i32 as libc::c_char,
            '\u{0}' as i32 as libc::c_char,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
        Metadata: 1 as libc::c_int != 0,
        Latency: [
            '\u{0}' as i32 as libc::c_char,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
        Drift: 0 as libc::c_int != 0,
        mac: [
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
        ],
        ArtWork: [
            '\u{0}' as i32 as libc::c_char,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
        ProtocolInfo: {
            let mut init = __anonstruct_ProtocolInfo_343724373 {
                pcm: [
                    'h' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    'p' as i32 as libc::c_char,
                    '-' as i32 as libc::c_char,
                    'g' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    '*' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'u' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    'i' as i32 as libc::c_char,
                    'o' as i32 as libc::c_char,
                    '/' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    '1' as i32 as libc::c_char,
                    '6' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'r' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '4' as i32 as libc::c_char,
                    '4' as i32 as libc::c_char,
                    '1' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'c' as i32 as libc::c_char,
                    'h' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'n' as i32 as libc::c_char,
                    'n' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    'l' as i32 as libc::c_char,
                    's' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '2' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    'C' as i32 as libc::c_char,
                    'M' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'C' as i32 as libc::c_char,
                    'I' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'F' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    'S' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    '5' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '\u{0}' as i32 as libc::c_char,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
                wav: [
                    'h' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    'p' as i32 as libc::c_char,
                    '-' as i32 as libc::c_char,
                    'g' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    '*' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'u' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    'i' as i32 as libc::c_char,
                    'o' as i32 as libc::c_char,
                    '/' as i32 as libc::c_char,
                    'w' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'v' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'C' as i32 as libc::c_char,
                    'I' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'F' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    'S' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    '5' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '\u{0}' as i32 as libc::c_char,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
                flac: [
                    'h' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    'p' as i32 as libc::c_char,
                    '-' as i32 as libc::c_char,
                    'g' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    '*' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'u' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    'i' as i32 as libc::c_char,
                    'o' as i32 as libc::c_char,
                    '/' as i32 as libc::c_char,
                    'f' as i32 as libc::c_char,
                    'l' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'c' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'C' as i32 as libc::c_char,
                    'I' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'F' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    'S' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    '5' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '\u{0}' as i32 as libc::c_char,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
                mp3: [
                    'h' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    'p' as i32 as libc::c_char,
                    '-' as i32 as libc::c_char,
                    'g' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    't' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    '*' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'a' as i32 as libc::c_char,
                    'u' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    'i' as i32 as libc::c_char,
                    'o' as i32 as libc::c_char,
                    '/' as i32 as libc::c_char,
                    'm' as i32 as libc::c_char,
                    'p' as i32 as libc::c_char,
                    'e' as i32 as libc::c_char,
                    'g' as i32 as libc::c_char,
                    ':' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    'M' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    '3' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'P' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'C' as i32 as libc::c_char,
                    'I' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    ';' as i32 as libc::c_char,
                    'D' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'N' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    '.' as i32 as libc::c_char,
                    'O' as i32 as libc::c_char,
                    'R' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    '_' as i32 as libc::c_char,
                    'F' as i32 as libc::c_char,
                    'L' as i32 as libc::c_char,
                    'A' as i32 as libc::c_char,
                    'G' as i32 as libc::c_char,
                    'S' as i32 as libc::c_char,
                    '=' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    'd' as i32 as libc::c_char,
                    '5' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '0' as i32 as libc::c_char,
                    '\u{0}' as i32 as libc::c_char,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            };
            init
        },
    };
    init
};
static mut cSearchedSRV: [cSearchedSRV_s; 5] = [
    {
        let mut init = cSearchedSRV_s {
            name: [
                'u' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'h' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'm' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'v' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                'A' as i32 as libc::c_char,
                'V' as i32 as libc::c_char,
                'T' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                't' as i32 as libc::c_char,
                '\u{0}' as i32 as libc::c_char,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            idx: 0 as libc::c_int,
            TimeOut: 0 as libc::c_int as u32_t,
        };
        init
    },
    {
        let mut init = cSearchedSRV_s {
            name: [
                'u' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'h' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'm' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'v' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                'R' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'd' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                'C' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                't' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'l' as i32 as libc::c_char,
                '\u{0}' as i32 as libc::c_char,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            idx: 1 as libc::c_int,
            TimeOut: 30 as libc::c_int as u32_t,
        };
        init
    },
    {
        let mut init = cSearchedSRV_s {
            name: [
                'u' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'h' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'm' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'v' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                'C' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                't' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'M' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                '\u{0}' as i32 as libc::c_char,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            idx: 2 as libc::c_int,
            TimeOut: 0 as libc::c_int as u32_t,
        };
        init
    },
    {
        let mut init = cSearchedSRV_s {
            name: [
                'u' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'h' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'm' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'v' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                'Z' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'G' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'T' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'l' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                'y' as i32 as libc::c_char,
                '\u{0}' as i32 as libc::c_char,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            idx: 3 as libc::c_int,
            TimeOut: 0 as libc::c_int as u32_t,
        };
        init
    },
    {
        let mut init = cSearchedSRV_s {
            name: [
                'u' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'h' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'm' as i32 as libc::c_char,
                'a' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                '-' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                's' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'v' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'c' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                ':' as i32 as libc::c_char,
                'G' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'u' as i32 as libc::c_char,
                'p' as i32 as libc::c_char,
                'R' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'd' as i32 as libc::c_char,
                'e' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'i' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                'g' as i32 as libc::c_char,
                'C' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'n' as i32 as libc::c_char,
                't' as i32 as libc::c_char,
                'r' as i32 as libc::c_char,
                'o' as i32 as libc::c_char,
                'l' as i32 as libc::c_char,
                '\u{0}' as i32 as libc::c_char,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            idx: 4 as libc::c_int,
            TimeOut: 0 as libc::c_int as u32_t,
        };
        init
    },
];
static mut loglevel___0: *mut log_level = unsafe {
    &main_loglevel as *const log_level as *mut log_level
};
static mut glDaemonize: bool = 0 as libc::c_int != 0;
static mut glMainRunning: bool = 1 as libc::c_int != 0;
static mut glHost: in_addr = in_addr { s_addr: 0 };
static mut glHostName: [libc::c_char; 256] = [0; 256];
static mut glmDNSServer: *mut mdnsd = 0 as *const libc::c_void as *mut libc::c_void
    as *mut mdnsd;
static mut glExcluded: *mut libc::c_char = 0 as *const libc::c_void as *mut libc::c_void
    as *mut libc::c_char;
static mut glExcludedModelNumber: *mut libc::c_char = 0 as *const libc::c_void
    as *mut libc::c_void as *mut libc::c_char;
static mut glIncludedModelNumbers: *mut libc::c_char = 0 as *const libc::c_void
    as *mut libc::c_void as *mut libc::c_char;
static mut glPidFile: *mut libc::c_char = 0 as *const libc::c_void as *mut libc::c_void
    as *mut libc::c_char;
static mut glAutoSaveConfigFile: bool = 0 as libc::c_int != 0;
static mut glGracefullShutdown: bool = 1 as libc::c_int != 0;
static mut glDiscovery: bool = 0 as libc::c_int != 0;
static mut glUpdateMutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
    __data: __pthread_mutex_s {
        __lock: 0,
        __count: 0,
        __owner: 0,
        __nusers: 0,
        __kind: 0,
        __spins: 0,
        __elision: 0,
        __list: __pthread_list_t {
            __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
        },
    },
};
static mut glUpdateCond: pthread_cond_t = __anonunion_pthread_cond_t_951761805 {
    __data: __pthread_cond_s {
        __annonCompField1: __anonunion____missing_field_name_750625702 {
            __wseq: 0,
        },
        __annonCompField2: __anonunion____missing_field_name_170565820 {
            __g1_start: 0,
        },
        __g_refs: [0; 2],
        __g_size: [0; 2],
        __g1_orig_size: 0,
        __wrefs: 0,
        __g_signals: [0; 2],
    },
};
static mut glMainThread: pthread_t = 0;
static mut glUpdateThread: pthread_t = 0;
static mut glUpdateQueue: tQueue = tQueue {
    mutex: 0 as *const pthread_mutex_t as *mut pthread_mutex_t,
    cleanup: None,
    list: sQueue_e {
        next: 0 as *const sQueue_e as *mut sQueue_e,
        item: 0 as *const libc::c_void as *mut libc::c_void,
    },
};
static mut glInteractive: bool = 1 as libc::c_int != 0;
static mut glLogFile: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
static mut glPort: u32_t = 0;
static mut glConfigID: *mut libc::c_void = 0 as *const libc::c_void as *mut libc::c_void;
static mut glConfigName: [libc::c_char; 256] = [
    '.' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
];
static mut usage: [libc::c_char; 1312] = [
    'v' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '@' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '[' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ']' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\'' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '\'' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ';' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '\'' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '=' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '|' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
static mut license: [libc::c_char; 614] = [
    'T' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '(' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ')' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    ';' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    ',' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '<' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '>' as i32 as libc::c_char,
    '.' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
unsafe extern "C" fn MRThread(mut args: *mut libc::c_void) -> *mut libc::c_void {
    let mut current_block: u64;
    let mut elapsed: libc::c_int = 0;
    let mut wakeTimer: libc::c_int = 0;
    let mut last: libc::c_uint = 0;
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut tmp: u32_t = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___2: *mut u8_t = 0 as *mut u8_t;
    wakeTimer = 500 as libc::c_int;
    p = args as *mut sMR;
    last = gettime_ms();
    while (*p).Running {
        tmp = gettime_ms();
        elapsed = tmp.wrapping_sub(last) as libc::c_int;
        pthread_mutex_lock(&mut (*p).Mutex);
        if (*p).State as libc::c_uint != 1 as libc::c_uint {
            wakeTimer = 500 as libc::c_int;
        } else {
            wakeTimer = 5000 as libc::c_int;
        }
        if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
            tmp___0 = logtime();
            logprint(
                b"%s %s:%d [%p]: UPnP thread timer %d %d\n\0" as *const u8
                    as *const libc::c_char,
                tmp___0,
                b"MRThread\0" as *const u8 as *const libc::c_char,
                255 as libc::c_int,
                p,
                elapsed,
                wakeTimer,
            );
        }
        (*p).StatePoll = ((*p).StatePoll).wrapping_add(elapsed as libc::c_uint);
        (*p).TrackPoll = ((*p).TrackPoll).wrapping_add(elapsed as libc::c_uint);
        if ((*p).Master).is_null() {
            if (*p).RaopState as libc::c_uint != 1 as libc::c_uint {
                if (*p).State as libc::c_uint == 1 as libc::c_uint {
                    current_block = 964246761467645392;
                } else {
                    current_block = 3321870518564370297;
                }
            } else {
                current_block = 3321870518564370297;
            }
            match current_block {
                964246761467645392 => {}
                _ => {
                    if !((*p).ErrorCount as libc::c_int > 5 as libc::c_int) {
                        if ((*p).WaitCookie).is_null() {
                            if (*p).TrackPoll > 1000 as libc::c_uint {
                                (*p).TrackPoll = 0 as libc::c_uint;
                                if (*p).State as libc::c_uint != 1 as libc::c_uint {
                                    if (*p).State as libc::c_uint != 3 as libc::c_uint {
                                        tmp___1 = (*p).seqN;
                                        (*p).seqN = ((*p).seqN).offset(1);
                                        AVTCallAction(
                                            p,
                                            b"GetPositionInfo\0" as *const u8 as *const libc::c_char
                                                as *mut libc::c_char,
                                            tmp___1 as *mut libc::c_void,
                                        );
                                    }
                                }
                            }
                            if (*p).StatePoll > 500 as libc::c_uint {
                                (*p).StatePoll = 0 as libc::c_uint;
                                tmp___2 = (*p).seqN;
                                (*p).seqN = ((*p).seqN).offset(1);
                                AVTCallAction(
                                    p,
                                    b"GetTransportInfo\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                    tmp___2 as *mut libc::c_void,
                                );
                            }
                        }
                    }
                }
            }
        }
        last = gettime_ms();
        pthread_mutex_unlock(&mut (*p).Mutex);
        WakeableSleep(wakeTimer as u32_t);
    }
    return 0 as *mut libc::c_void;
}
static mut count: libc::c_int = 0;
pub unsafe extern "C" fn HandleRAOP(
    mut owner: *mut libc::c_void,
    mut event: raop_event_t,
    mut param: *mut libc::c_void,
) {
    let mut current_block: u64;
    let mut Device: *mut sMR = 0 as *mut sMR;
    let mut tmp: bool = false;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut uri: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut mp3radio: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut RaopVolume: libc::c_double = 0.;
    let mut GroupVolume: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut now: u32_t = 0;
    let mut tmp___9: u32_t = 0;
    let mut tmp___10: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut Ratio: libc::c_double = 0.;
    let mut tmp___12: libc::c_double = 0.;
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut tmp___13: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    Device = owner as *mut sMR;
    tmp = CheckAndLock(owner as *mut sMR);
    if !tmp {
        return;
    }
    match event as libc::c_uint {
        0 => {
            if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                tmp___0 = logtime();
                logprint(
                    b"%s %s:%d [%p]: Stream\n\0" as *const u8 as *const libc::c_char,
                    tmp___0,
                    b"HandleRAOP\0" as *const u8 as *const libc::c_char,
                    300 as libc::c_int,
                    Device,
                );
            }
            (*Device).RaopState = event;
        }
        4 => {
            if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                tmp___1 = logtime();
                logprint(
                    b"%s %s:%d [%p]: Stop\n\0" as *const u8 as *const libc::c_char,
                    tmp___1,
                    b"HandleRAOP\0" as *const u8 as *const libc::c_char,
                    305 as libc::c_int,
                    Device,
                );
            }
            if (*Device).RaopState as libc::c_uint == 1 as libc::c_uint {
                AVTStop(Device);
                (*Device).ExpectStop = 1 as libc::c_int != 0;
            }
            (*Device).RaopState = event;
        }
        2 => {
            if (*Device).Config.Flush {
                if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                    tmp___2 = logtime();
                    logprint(
                        b"%s %s:%d [%p]: Flush\n\0" as *const u8 as *const libc::c_char,
                        tmp___2,
                        b"HandleRAOP\0" as *const u8 as *const libc::c_char,
                        314 as libc::c_int,
                        Device,
                    );
                }
                AVTStop(Device);
                (*Device).ExpectStop = 1 as libc::c_int != 0;
                (*Device).RaopState = event;
            }
        }
        1 => {
            mp3radio = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
            if (*Device).RaopState as libc::c_uint != 1 as libc::c_uint {
                tmp___4 = strcasestr(
                    ((*Device).Config.Codec).as_mut_ptr() as *const libc::c_char,
                    b"mp3\0" as *const u8 as *const libc::c_char,
                );
                if !tmp___4.is_null() {
                    if (*Device)
                        .Service[3 as libc::c_int as usize]
                        .ControlURL[0 as libc::c_int as usize] != 0
                    {
                        mp3radio = b"x-rincon-mp3radio://\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char;
                        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                            tmp___3 = logtime();
                            logprint(
                                b"%s %s:%d [%p]: Sonos live stream\n\0" as *const u8
                                    as *const libc::c_char,
                                tmp___3,
                                b"HandleRAOP\0" as *const u8 as *const libc::c_char,
                                327 as libc::c_int,
                                Device,
                            );
                        }
                    }
                }
                tmp___5 = count;
                count += 1;
                tmp___6 = inet_ntoa(glHost);
                tmp___7 = asprintf(
                    &mut uri as *mut *mut libc::c_char,
                    b"%shttp://%s:%u/stream-%u.%s\0" as *const u8 as *const libc::c_char,
                    mp3radio,
                    tmp___6,
                    *(param as *mut libc::c_ushort) as libc::c_int,
                    tmp___5,
                    ((*Device).Config.Codec).as_mut_ptr(),
                );
                if tmp___7 != 0 {
                    tmp___8 = 0 as libc::c_int;
                } else {
                    tmp___8 = 1 as libc::c_int;
                }
                AVTSetURI(Device, uri, &mut (*Device).MetaData, (*Device).ProtocolInfo);
                if !uri.is_null() {
                    free(uri as *mut libc::c_void);
                    uri = 0 as *mut libc::c_void as *mut libc::c_char;
                }
            }
            AVTPlay(Device);
            (*Device).RaopState = event;
        }
        5 => {
            RaopVolume = *(param as *mut libc::c_double);
            tmp___9 = gettime_ms();
            now = tmp___9;
            if !(now < ((*Device).VolumeStampRx).wrapping_add(1000 as libc::c_uint)) {
                (*Device).VolumeStampTx = now;
                GroupVolume = CalcGroupVolume(Device);
                if GroupVolume < 0 as libc::c_int {
                    (*Device)
                        .Volume = RaopVolume
                        * (*Device).Config.MaxVolume as libc::c_double;
                    tmp___10 = (*Device).seqN;
                    (*Device).seqN = ((*Device).seqN).offset(1);
                    CtrlSetVolume(
                        Device,
                        ((*Device).Volume + 0.5f64) as u8_t,
                        tmp___10 as *mut libc::c_void,
                    );
                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                        tmp___11 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: Volume[0..100] %d\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___11,
                            b"HandleRAOP\0" as *const u8 as *const libc::c_char,
                            363 as libc::c_int,
                            Device,
                            (*Device).Volume as libc::c_int,
                        );
                    }
                } else {
                    if GroupVolume != 0 {
                        tmp___12 = RaopVolume
                            * (*Device).Config.MaxVolume as libc::c_double
                            / GroupVolume as libc::c_double;
                    } else {
                        tmp___12 = 0 as libc::c_int as libc::c_double;
                    }
                    Ratio = tmp___12;
                    i = 0 as libc::c_int;
                    while i < glMaxDevices {
                        p = glMRDevices.offset(i as isize);
                        if (*p).Running {
                            if p as libc::c_ulong != Device as libc::c_ulong {
                                if (*p).Master as libc::c_ulong != Device as libc::c_ulong {
                                    current_block = 136660206916729436;
                                } else {
                                    current_block = 15514718523126015390;
                                }
                            } else {
                                current_block = 15514718523126015390;
                            }
                            match current_block {
                                136660206916729436 => {}
                                _ => {
                                    if GroupVolume != 0 {
                                        if (*p).Volume * Ratio
                                            < (*p).Config.MaxVolume as libc::c_double
                                        {
                                            (*p).Volume *= Ratio;
                                        } else {
                                            (*p).Volume = (*p).Config.MaxVolume as libc::c_double;
                                        }
                                    } else {
                                        (*p)
                                            .Volume = RaopVolume
                                            * (*p).Config.MaxVolume as libc::c_double;
                                    }
                                    tmp___13 = (*p).seqN;
                                    (*p).seqN = ((*p).seqN).offset(1);
                                    CtrlSetVolume(
                                        p,
                                        ((*p).Volume + 0.5f64) as u8_t,
                                        tmp___13 as *mut libc::c_void,
                                    );
                                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                        tmp___14 = logtime();
                                        logprint(
                                            b"%s %s:%d [%p]: Volume[0..100] %d:%d\n\0" as *const u8
                                                as *const libc::c_char,
                                            tmp___14,
                                            b"HandleRAOP\0" as *const u8 as *const libc::c_char,
                                            377 as libc::c_int,
                                            p,
                                            (*p).Volume as libc::c_int,
                                            GroupVolume,
                                        );
                                    }
                                }
                            }
                        }
                        i += 1;
                    }
                }
            }
        }
        _ => {}
    }
    pthread_mutex_unlock(&mut (*Device).Mutex);
}
pub unsafe extern "C" fn HandleHTTP(
    mut owner: *mut libc::c_void,
    mut headers: *mut key_data_s,
    mut response: *mut key_data_s,
) {
    let mut Device: *mut sMR = 0 as *mut sMR;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    Device = owner as *mut sMR;
    tmp = kd_lookup(
        headers,
        b"getcontentFeatures.dlna.org\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    if !tmp.is_null() {
        p = strcasestr(
            (*Device).ProtocolInfo as *const libc::c_char,
            b"DLNA.ORG\0" as *const u8 as *const libc::c_char,
        );
        if p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            kd_add(
                response,
                b"contentFeatures.dlna.org\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                p,
            );
        }
    }
    p = kd_lookup(
        headers,
        b"transferMode.dlna.org\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    if p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        kd_add(
            response,
            b"transferMode.dlna.org\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            p,
        );
    }
}
unsafe extern "C" fn _ProcessQueue(mut Device: *mut sMR) -> bool {
    let mut Service: *mut sService = 0 as *mut sService;
    let mut Action: *mut tAction = 0 as *mut tAction;
    let mut rc: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut sService;
    rc = 0 as libc::c_int;
    (*Device).WaitCookie = 0 as *mut libc::c_void;
    tmp = QueueExtract(&mut (*Device).ActionQueue);
    Action = tmp as *mut tAction;
    if Action as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    tmp___0 = (*Device).seqN;
    (*Device).seqN = ((*Device).seqN).offset(1);
    (*Device).WaitCookie = tmp___0 as *mut libc::c_void;
    rc = UpnpSendActionAsync(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        (*Action).ActionNode as *mut IXML_Document,
        Some(
            ActionHandler
                as unsafe extern "C" fn(
                    Upnp_EventType,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        (*Device).WaitCookie as *const libc::c_void,
    );
    if rc != 0 as libc::c_int {
        tmp___1 = logtime();
        logprint(
            b"%s %s:%d Error in queued UpnpSendActionAsync -- %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___1,
            b"_ProcessQueue\0" as *const u8 as *const libc::c_char,
            422 as libc::c_int,
            rc,
        );
    }
    ixmlDocument_free((*Action).ActionNode as *mut IXML_Document);
    free(Action as *mut libc::c_void);
    return rc == 0 as libc::c_int;
}
unsafe extern "C" fn ProcessEvent(
    mut EventType: Upnp_EventType,
    mut _Event: *mut libc::c_void,
    mut Cookie: *mut libc::c_void,
) {
    let mut Event: *mut Upnp_Event = 0 as *mut Upnp_Event;
    let mut Device: *mut sMR = 0 as *mut sMR;
    let mut tmp: *mut sMR = 0 as *mut sMR;
    let mut VarDoc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut r: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut LastChange: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: bool = false;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut Master: *mut sMR = 0 as *mut sMR;
    let mut tmp___2: *mut sMR = 0 as *mut sMR;
    let mut Volume: libc::c_double = 0.;
    let mut tmp___3: libc::c_int = 0;
    let mut GroupVolume: libc::c_double = 0.;
    let mut now: u32_t = 0;
    let mut tmp___4: u32_t = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    Event = _Event as *mut Upnp_Event;
    tmp = SID2Device(((*Event).Sid).as_mut_ptr());
    Device = tmp;
    VarDoc = (*Event).ChangedVariables;
    r = 0 as *mut libc::c_void as *mut libc::c_char;
    LastChange = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___0 = CheckAndLock(Device);
    if !tmp___0 {
        return;
    }
    LastChange = XMLGetFirstDocumentItem(
        VarDoc,
        b"LastChange\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    's_135: {
        let mut current_block_20: u64;
        if ((*Device).Raop).is_null() {
            if ((*Device).Master).is_null() {
                current_block_20 = 8625811519263459544;
            } else {
                current_block_20 = 11981164825820366640;
            }
        } else {
            current_block_20 = 11981164825820366640;
        }
        match current_block_20 {
            11981164825820366640 => {
                if !LastChange.is_null() {
                    break 's_135;
                }
            }
            _ => {}
        }
        if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
            tmp___1 = logtime();
            logprint(
                b"%s %s:%d no RAOP device (yet) or not change for %s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___1,
                b"ProcessEvent\0" as *const u8 as *const libc::c_char,
                447 as libc::c_int,
                ((*Event).Sid).as_mut_ptr(),
            );
        }
        pthread_mutex_unlock(&mut (*Device).Mutex);
        if !LastChange.is_null() {
            free(LastChange as *mut libc::c_void);
            LastChange = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        return;
    }
    r = XMLGetChangeItem(
        VarDoc,
        b"Volume\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"channel\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"Master\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"val\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if !r.is_null() {
        if !((*Device).Master).is_null() {
            tmp___2 = (*Device).Master;
        } else {
            tmp___2 = Device;
        }
        Master = tmp___2;
        tmp___3 = atoi(r as *const libc::c_char);
        Volume = tmp___3 as libc::c_double;
        tmp___4 = gettime_ms();
        now = tmp___4;
        if Volume != (*Device).Volume as libc::c_int as libc::c_double {
            if now > ((*Master).VolumeStampTx).wrapping_add(1000 as libc::c_uint) {
                (*Device).Volume = Volume;
                (*Master).VolumeStampRx = now;
                tmp___5 = CalcGroupVolume(Master);
                GroupVolume = tmp___5 as libc::c_double;
                if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                    if !((*Device).Master).is_null() {
                        tmp___6 = b"slave\0" as *const u8 as *const libc::c_char;
                    } else {
                        tmp___6 = b"master\0" as *const u8 as *const libc::c_char;
                    }
                    tmp___7 = logtime();
                    logprint(
                        b"%s %s:%d [%p]: UPnP Volume local change %d:%d (%s)\n\0"
                            as *const u8 as *const libc::c_char,
                        tmp___7,
                        b"ProcessEvent\0" as *const u8 as *const libc::c_char,
                        464 as libc::c_int,
                        Device,
                        Volume as libc::c_int,
                        GroupVolume as libc::c_int,
                        tmp___6,
                    );
                }
                if GroupVolume < 0 as libc::c_int as libc::c_double {
                    Volume /= (*Device).Config.MaxVolume as libc::c_double;
                } else {
                    Volume = GroupVolume / 100 as libc::c_int as libc::c_double;
                }
                raop_notify(
                    (*Master).Raop,
                    RAOP_VOLUME,
                    &mut Volume as *mut libc::c_double as *mut libc::c_void,
                );
            }
        }
    }
    if !r.is_null() {
        free(r as *mut libc::c_void);
        r = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !LastChange.is_null() {
        free(LastChange as *mut libc::c_void);
        LastChange = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    pthread_mutex_unlock(&mut (*Device).Mutex);
}
static mut recurse: libc::c_int = 0 as libc::c_int;
pub unsafe extern "C" fn ActionHandler(
    mut EventType: Upnp_EventType,
    mut Event: *mut libc::c_void,
    mut Cookie: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut Action: *mut Upnp_Action_Complete = 0 as *mut Upnp_Action_Complete;
    let mut r: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: bool = false;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut Resp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___18: *const libc::c_char = 0 as *const libc::c_char;
    p = 0 as *mut libc::c_void as *mut sMR;
    if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
        tmp = uPNPEvent2String(EventType);
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d action: %i [%s] [%p] [%u]\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"ActionHandler\0" as *const u8 as *const libc::c_char,
            483 as libc::c_int,
            EventType as libc::c_uint,
            tmp,
            Cookie,
            recurse,
        );
    }
    recurse += 1;
    match EventType as libc::c_uint {
        1 => {
            Action = Event as *mut Upnp_Action_Complete;
            p = CURL2Device(((*Action).CtrlUrl).as_mut_ptr());
            tmp___1 = CheckAndLock(p);
            if !tmp___1 {
                return 0 as libc::c_int;
            }
            if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
                tmp___2 = logtime();
                logprint(
                    b"%s %s:%d [%p]: ac %i %s (cookie %p)\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___2,
                    b"ActionHandler\0" as *const u8 as *const libc::c_char,
                    495 as libc::c_int,
                    p,
                    EventType as libc::c_uint,
                    ((*Action).CtrlUrl).as_mut_ptr(),
                    Cookie,
                );
            }
            if !((*p).WaitCookie).is_null() {
                tmp___3 = XMLGetLocalName((*Action).ActionResult, 1 as libc::c_int);
                Resp = tmp___3;
                if *loglevel___0 as libc::c_uint >= 3 as libc::c_uint {
                    if !Resp.is_null() {
                        tmp___4 = Resp;
                    } else {
                        tmp___4 = b"<none>\0" as *const u8 as *const libc::c_char;
                    }
                    tmp___5 = logtime();
                    logprint(
                        b"%s %s:%d [%p]: Waited action %s\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___5,
                        b"ActionHandler\0" as *const u8 as *const libc::c_char,
                        501 as libc::c_int,
                        p,
                        tmp___4,
                    );
                }
                if !(Cookie as libc::c_ulong != (*p).WaitCookie as libc::c_ulong) {
                    (*p).StartCookie = (*p).WaitCookie;
                    _ProcessQueue(p);
                    if !Resp.is_null() {
                        tmp___6 = strcasecmp(
                            Resp,
                            b"StopResponse\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___6 != 0 {
                            tmp___7 = strcasecmp(
                                Resp,
                                b"PlayResponse\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___7 != 0 {
                                tmp___8 = strcasecmp(
                                    Resp,
                                    b"PauseResponse\0" as *const u8 as *const libc::c_char,
                                );
                                if tmp___8 == 0 {
                                    (*p).State = UNKNOWN;
                                }
                            } else {
                                (*p).State = UNKNOWN;
                            }
                        } else {
                            (*p).State = UNKNOWN;
                        }
                    }
                }
            } else if !((Cookie as libc::c_ulong) < (*p).StartCookie as libc::c_ulong) {
                r = XMLGetFirstDocumentItem(
                    (*Action).ActionResult,
                    b"CurrentTransportState\0" as *const u8 as *const libc::c_char,
                    1 as libc::c_int != 0,
                );
                if r as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___16 = strcmp(
                        r as *const libc::c_char,
                        b"TRANSITIONING\0" as *const u8 as *const libc::c_char,
                    );
                    let mut current_block_91: u64;
                    if tmp___16 != 0 {
                        current_block_91 = 15092292971051809588;
                    } else if (*p).State as libc::c_uint != 4 as libc::c_uint {
                        (*p).State = TRANSITIONING;
                        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                            tmp___9 = logtime();
                            logprint(
                                b"%s %s:%d [%p]: uPNP transition\n\0" as *const u8
                                    as *const libc::c_char,
                                tmp___9,
                                b"ActionHandler\0" as *const u8 as *const libc::c_char,
                                531 as libc::c_int,
                                p,
                            );
                        }
                        current_block_91 = 7301440000599063274;
                    } else {
                        current_block_91 = 15092292971051809588;
                    }
                    match current_block_91 {
                        15092292971051809588 => {
                            tmp___15 = strcmp(
                                r as *const libc::c_char,
                                b"STOPPED\0" as *const u8 as *const libc::c_char,
                            );
                            let mut current_block_84: u64;
                            if tmp___15 != 0 {
                                current_block_84 = 2293973286807104147;
                            } else if (*p).State as libc::c_uint != 1 as libc::c_uint {
                                if (*p).RaopState as libc::c_uint == 1 as libc::c_uint {
                                    if !(*p).ExpectStop {
                                        raop_notify((*p).Raop, RAOP_STOP, 0 as *mut libc::c_void);
                                    }
                                }
                                (*p).State = STOPPED;
                                (*p).ExpectStop = 0 as libc::c_int != 0;
                                if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                    tmp___10 = logtime();
                                    logprint(
                                        b"%s %s:%d [%p]: uPNP stopped\n\0" as *const u8
                                            as *const libc::c_char,
                                        tmp___10,
                                        b"ActionHandler\0" as *const u8 as *const libc::c_char,
                                        536 as libc::c_int,
                                        p,
                                    );
                                }
                                current_block_84 = 8062065914618164218;
                            } else {
                                current_block_84 = 2293973286807104147;
                            }
                            match current_block_84 {
                                2293973286807104147 => {
                                    tmp___14 = strcmp(
                                        r as *const libc::c_char,
                                        b"PLAYING\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut current_block_71: u64;
                                    if tmp___14 != 0 {
                                        current_block_71 = 5411190401301349556;
                                    } else if (*p).State as libc::c_uint != 2 as libc::c_uint {
                                        (*p).State = PLAYING;
                                        if (*p).RaopState as libc::c_uint != 1 as libc::c_uint {
                                            raop_notify((*p).Raop, RAOP_PLAY, 0 as *mut libc::c_void);
                                        }
                                        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                            tmp___11 = logtime();
                                            logprint(
                                                b"%s %s:%d [%p]: uPNP playing\n\0" as *const u8
                                                    as *const libc::c_char,
                                                tmp___11,
                                                b"ActionHandler\0" as *const u8 as *const libc::c_char,
                                                540 as libc::c_int,
                                                p,
                                            );
                                        }
                                        current_block_71 = 17239133558811367971;
                                    } else {
                                        current_block_71 = 5411190401301349556;
                                    }
                                    match current_block_71 {
                                        5411190401301349556 => {
                                            tmp___13 = strcmp(
                                                r as *const libc::c_char,
                                                b"PAUSED_PLAYBACK\0" as *const u8 as *const libc::c_char,
                                            );
                                            if tmp___13 == 0 {
                                                if (*p).State as libc::c_uint != 3 as libc::c_uint {
                                                    (*p).State = PAUSED;
                                                    if (*p).RaopState as libc::c_uint == 1 as libc::c_uint {
                                                        raop_notify((*p).Raop, RAOP_PAUSE, 0 as *mut libc::c_void);
                                                    }
                                                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                                        tmp___12 = logtime();
                                                        logprint(
                                                            b"%s %s:%d [%p]: uPNP pause\n\0" as *const u8
                                                                as *const libc::c_char,
                                                            tmp___12,
                                                            b"ActionHandler\0" as *const u8 as *const libc::c_char,
                                                            544 as libc::c_int,
                                                            p,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                if !r.is_null() {
                    free(r as *mut libc::c_void);
                    r = 0 as *mut libc::c_void as *mut libc::c_char;
                }
                if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
                    tmp___17 = logtime();
                    logprint(
                        b"%s %s:%d Action complete : %i (cookie %p)\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___17,
                        b"ActionHandler\0" as *const u8 as *const libc::c_char,
                        550 as libc::c_int,
                        EventType as libc::c_uint,
                        Cookie,
                    );
                }
                if (*Action).ErrCode != 0 as libc::c_int {
                    (*p)
                        .ErrorCount = ((*p).ErrorCount as libc::c_int + 1 as libc::c_int)
                        as u16_t;
                    tmp___18 = logtime();
                    logprint(
                        b"%s %s:%d Error in action callback -- %d (cookie %p)\n\0"
                            as *const u8 as *const libc::c_char,
                        tmp___18,
                        b"ActionHandler\0" as *const u8 as *const libc::c_char,
                        554 as libc::c_int,
                        (*Action).ErrCode,
                        Cookie,
                    );
                } else {
                    (*p).ErrorCount = 0 as libc::c_int as u16_t;
                }
            }
        }
        _ => {}
    }
    if !p.is_null() {
        pthread_mutex_unlock(&mut (*p).Mutex);
    }
    recurse -= 1;
    return 0 as libc::c_int;
}
static mut recurse___0: libc::c_int = 0 as libc::c_int;
static mut Version: libc::c_int = 0;
pub unsafe extern "C" fn MasterHandler(
    mut EventType: Upnp_EventType,
    mut _Event: *mut libc::c_void,
    mut Cookie: *mut libc::c_void,
) -> libc::c_int {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut Event: *mut Upnp_Discovery = 0 as *mut Upnp_Discovery;
    let mut Update: *mut tUpdate = 0 as *mut tUpdate;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut Event___0: *mut Upnp_Discovery = 0 as *mut Upnp_Discovery;
    let mut Update___0: *mut tUpdate = 0 as *mut tUpdate;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut Update___1: *mut tUpdate = 0 as *mut tUpdate;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut SearchTopic: [libc::c_char; 44] = [0; 44];
    let mut tmp___4: libc::c_int = 0;
    let mut Event___1: *mut Upnp_Event_Subscribe = 0 as *mut Upnp_Event_Subscribe;
    let mut s: *mut sService = 0 as *mut sService;
    let mut Device: *mut sMR = 0 as *mut sMR;
    let mut tmp___5: *mut sMR = 0 as *mut sMR;
    let mut tmp___6: bool = false;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut Event___2: *mut Upnp_Event_Subscribe = 0 as *mut Upnp_Event_Subscribe;
    let mut Device___0: *mut sMR = 0 as *mut sMR;
    let mut tmp___9: *mut sMR = 0 as *mut sMR;
    let mut s___0: *mut sService = 0 as *mut sService;
    let mut tmp___10: bool = false;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___15: u32_t = 0;
    if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
        tmp = uPNPEvent2String(EventType);
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d event: %i [%s] [%p] (recurse %u)\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"MasterHandler\0" as *const u8 as *const libc::c_char,
            582 as libc::c_int,
            EventType as libc::c_uint,
            tmp,
            Cookie,
            recurse___0,
        );
    }
    if !glMainRunning {
        return 0 as libc::c_int;
    }
    recurse___0 += 1;
    match EventType as libc::c_uint {
        6 => {
            Event = _Event as *mut Upnp_Discovery;
            tmp___1 = malloc(::std::mem::size_of::<tUpdate>() as libc::c_ulong);
            Update = tmp___1 as *mut tUpdate;
            (*Update).Type = DISCOVERY;
            (*Update)
                .Data = strdup(((*Event).Location).as_mut_ptr() as *const libc::c_char);
            QueueInsert(&mut glUpdateQueue, Update as *mut libc::c_void);
            pthread_cond_signal(&mut glUpdateCond);
        }
        5 => {
            Event___0 = _Event as *mut Upnp_Discovery;
            tmp___2 = malloc(::std::mem::size_of::<tUpdate>() as libc::c_ulong);
            Update___0 = tmp___2 as *mut tUpdate;
            (*Update___0).Type = BYE_BYE;
            (*Update___0)
                .Data = strdup(
                ((*Event___0).DeviceId).as_mut_ptr() as *const libc::c_char,
            );
            QueueInsert(&mut glUpdateQueue, Update___0 as *mut libc::c_void);
            pthread_cond_signal(&mut glUpdateCond);
        }
        7 => {
            tmp___3 = malloc(::std::mem::size_of::<tUpdate>() as libc::c_ulong);
            Update___1 = tmp___3 as *mut tUpdate;
            (*Update___1).Type = SEARCH_TIMEOUT;
            (*Update___1).Data = 0 as *mut libc::c_void as *mut libc::c_char;
            QueueInsert(&mut glUpdateQueue, Update___1 as *mut libc::c_void);
            pthread_cond_signal(&mut glUpdateCond);
            if Cookie.is_null() {
                tmp___4 = Version;
                Version += 1;
                sprintf(
                    SearchTopic.as_mut_ptr(),
                    b"%s:%i\0" as *const u8 as *const libc::c_char,
                    b"urn:schemas-upnp-org:device:MediaRenderer\0" as *const u8
                        as *const libc::c_char,
                    tmp___4 % glMRConfig.UPnPMax + 1 as libc::c_int,
                );
                UpnpSearchAsync(
                    glControlPointHandle,
                    20 as libc::c_int,
                    SearchTopic.as_mut_ptr() as *const libc::c_char,
                    0 as *mut libc::c_void as *const libc::c_void,
                );
            }
        }
        9 => {
            ProcessEvent(EventType, _Event, Cookie);
        }
        13 | 14 => {
            Event___1 = _Event as *mut Upnp_Event_Subscribe;
            tmp___5 = SID2Device(((*Event___1).Sid).as_mut_ptr());
            Device = tmp___5;
            tmp___6 = CheckAndLock(Device);
            if tmp___6 {
                s = EventURL2Service(
                    ((*Event___1).PublisherUrl).as_mut_ptr(),
                    ((*Device).Service).as_mut_ptr(),
                );
                if s as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___7 = strdup(
                        ((*Device).UDN).as_mut_ptr() as *const libc::c_char,
                    );
                    UpnpSubscribeAsync(
                        glControlPointHandle,
                        ((*s).EventURL).as_mut_ptr() as *const libc::c_char,
                        (*s).TimeOut,
                        Some(
                            MasterHandler
                                as unsafe extern "C" fn(
                                    Upnp_EventType,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> libc::c_int,
                        ),
                        tmp___7 as *mut libc::c_void as *const libc::c_void,
                    );
                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                        tmp___8 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: Auto-renewal failed, re-subscribing\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___8,
                            b"MasterHandler\0" as *const u8 as *const libc::c_char,
                            646 as libc::c_int,
                            Device,
                        );
                    }
                }
                pthread_mutex_unlock(&mut (*Device).Mutex);
            }
        }
        11 | 10 => {
            Event___2 = _Event as *mut Upnp_Event_Subscribe;
            tmp___9 = UDN2Device(Cookie as *mut libc::c_char);
            Device___0 = tmp___9;
            free(Cookie);
            tmp___10 = CheckAndLock(Device___0);
            if tmp___10 {
                s___0 = EventURL2Service(
                    ((*Event___2).PublisherUrl).as_mut_ptr(),
                    ((*Device___0).Service).as_mut_ptr(),
                );
                if s___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    if (*Event___2).ErrCode == 0 as libc::c_int {
                        (*s___0).Failed = 0 as libc::c_int as u32_t;
                        strcpy(
                            ((*s___0).SID).as_mut_ptr(),
                            ((*Event___2).Sid).as_mut_ptr() as *const libc::c_char,
                        );
                        (*s___0).TimeOut = (*Event___2).TimeOut;
                        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                            tmp___11 = logtime();
                            logprint(
                                b"%s %s:%d [%p]: subscribe success\n\0" as *const u8
                                    as *const libc::c_char,
                                tmp___11,
                                b"MasterHandler\0" as *const u8 as *const libc::c_char,
                                669 as libc::c_int,
                                Device___0,
                            );
                        }
                    } else {
                        tmp___15 = (*s___0).Failed;
                        (*s___0).Failed = ((*s___0).Failed).wrapping_add(1);
                        if tmp___15 < 3 as libc::c_uint {
                            if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                tmp___12 = logtime();
                                logprint(
                                    b"%s %s:%d [%p]: subscribe fail, re-trying %u\n\0"
                                        as *const u8 as *const libc::c_char,
                                    tmp___12,
                                    b"MasterHandler\0" as *const u8 as *const libc::c_char,
                                    671 as libc::c_int,
                                    Device___0,
                                    (*s___0).Failed,
                                );
                            }
                            tmp___13 = strdup(
                                ((*Device___0).UDN).as_mut_ptr() as *const libc::c_char,
                            );
                            UpnpSubscribeAsync(
                                glControlPointHandle,
                                ((*s___0).EventURL).as_mut_ptr() as *const libc::c_char,
                                (*s___0).TimeOut,
                                Some(
                                    MasterHandler
                                        as unsafe extern "C" fn(
                                            Upnp_EventType,
                                            *mut libc::c_void,
                                            *mut libc::c_void,
                                        ) -> libc::c_int,
                                ),
                                tmp___13 as *mut libc::c_void as *const libc::c_void,
                            );
                        } else if *loglevel___0 as libc::c_uint >= 1 as libc::c_uint {
                            tmp___14 = logtime();
                            logprint(
                                b"%s %s:%d [%p]: subscribe fail, volume feedback will not work\n\0"
                                    as *const u8 as *const libc::c_char,
                                tmp___14,
                                b"MasterHandler\0" as *const u8 as *const libc::c_char,
                                675 as libc::c_int,
                                Device___0,
                            );
                        }
                    }
                }
                pthread_mutex_unlock(&mut (*Device___0).Mutex);
            }
        }
        4 | 3 | 1 | 2 | 12 | 0 | 8 | _ => {}
    }
    recurse___0 -= 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn FreeUpdate(mut _Item: *mut libc::c_void) {
    let mut Item: *mut tUpdate = 0 as *mut tUpdate;
    Item = _Item as *mut tUpdate;
    if !((*Item).Data).is_null() {
        free((*Item).Data as *mut libc::c_void);
        (*Item).Data = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    free(Item as *mut libc::c_void);
}
unsafe extern "C" fn UpdateThread(mut args: *mut libc::c_void) -> *mut libc::c_void {
    let mut current_block: u64;
    let mut Update: *mut tUpdate = 0 as *mut tUpdate;
    let mut Updated: bool = false;
    let mut Device: *mut sMR = 0 as *mut sMR;
    let mut i: libc::c_int = 0;
    let mut now: u32_t = 0;
    let mut tmp: u32_t = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: bool = false;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut DescDoc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut UDN: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ModelName: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ModelNumber: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i___0: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut friendlyName: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut Master: *mut sMR = 0 as *mut sMR;
    let mut tmp___5: *mut sMR = 0 as *mut sMR;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: bool = false;
    let mut tmp___18: bool = false;
    let mut tmp___19: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___20: libc::c_int = 0;
    let mut tmp___21: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___22: bool = false;
    let mut tmp___23: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___24: *mut libc::c_void = 0 as *mut libc::c_void;
    while glMainRunning {
        Updated = 0 as libc::c_int != 0;
        pthread_mutex_lock(&mut glUpdateMutex);
        pthread_cond_wait(
            &mut glUpdateCond as *mut pthread_cond_t,
            &mut glUpdateMutex as *mut pthread_mutex_t,
        );
        pthread_mutex_unlock(&mut glUpdateMutex);
        while glMainRunning {
            tmp___24 = QueueExtract(&mut glUpdateQueue);
            Update = tmp___24 as *mut tUpdate;
            if !(Update as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                break;
            }
            tmp = gettime_ms();
            now = tmp.wrapping_div(1000 as libc::c_uint);
            if (*Update).Type as libc::c_uint == 2 as libc::c_uint {
                if *loglevel___0 as libc::c_uint >= 3 as libc::c_uint {
                    tmp___0 = logtime();
                    logprint(
                        b"%s %s:%d Presence checking\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___0,
                        b"UpdateThread\0" as *const u8 as *const libc::c_char,
                        726 as libc::c_int,
                        0 as *mut libc::c_void,
                    );
                }
                i = 0 as libc::c_int;
                while i < glMaxDevices {
                    Device = glMRDevices.offset(i as isize);
                    if (*Device).Running {
                        let mut current_block_21: u64;
                        if (*Device).State as libc::c_uint != 2 as libc::c_uint {
                            current_block_21 = 17149495288147383288;
                        } else if (*Device).RaopState as libc::c_uint
                                != 1 as libc::c_uint
                            {
                            current_block_21 = 17149495288147383288;
                        } else {
                            current_block_21 = 790185930182612747;
                        }
                        match current_block_21 {
                            17149495288147383288 => {
                                let mut current_block_20: u64;
                                if ((*Device).LastSeen)
                                    .wrapping_add(120 as libc::c_uint)
                                    .wrapping_sub(now) > 120 as libc::c_uint
                                {
                                    current_block_20 = 15648039568432238731;
                                } else if (*Device).ErrorCount as libc::c_int
                                        > 5 as libc::c_int
                                    {
                                    current_block_20 = 15648039568432238731;
                                } else {
                                    current_block_20 = 12199444798915819164;
                                }
                                match current_block_20 {
                                    15648039568432238731 => {
                                        pthread_mutex_lock(&mut (*Device).Mutex);
                                        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                            tmp___1 = logtime();
                                            logprint(
                                                b"%s %s:%d [%p]: removing unresponsive player (%s)\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                tmp___1,
                                                b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                                735 as libc::c_int,
                                                Device,
                                                ((*Device).Config.Name).as_mut_ptr(),
                                            );
                                        }
                                        raop_delete((*Device).Raop);
                                        DelMRDevice(Device);
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                    i += 1;
                }
            } else if (*Update).Type as libc::c_uint == 1 as libc::c_uint {
                Device = UDN2Device((*Update).Data);
                tmp___2 = CheckAndLock(Device);
                if tmp___2 {
                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                        tmp___3 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: renderer bye-bye: %s\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___3,
                            b"UpdateThread\0" as *const u8 as *const libc::c_char,
                            750 as libc::c_int,
                            Device,
                            ((*Device).Config.Name).as_mut_ptr(),
                        );
                    }
                    raop_delete((*Device).Raop);
                    DelMRDevice(Device);
                }
            } else if (*Update).Type as libc::c_uint == 0 as libc::c_uint {
                DescDoc = 0 as *mut libc::c_void as *mut IXML_Document;
                UDN = 0 as *mut libc::c_void as *mut libc::c_char;
                ModelName = 0 as *mut libc::c_void as *mut libc::c_char;
                ModelNumber = 0 as *mut libc::c_void as *mut libc::c_char;
                tmp___4 = strstr(
                    (*Update).Data as *const libc::c_char,
                    b"group_description\0" as *const u8 as *const libc::c_char,
                );
                if !tmp___4.is_null() {
                    i___0 = 0 as libc::c_int;
                    while i___0 < glMaxDevices {
                        Device = glMRDevices.offset(i___0 as isize);
                        if (*Device).Running {
                            if (*Device)
                                .Service[3 as libc::c_int as usize]
                                .ControlURL[0 as libc::c_int as usize] != 0
                            {
                                UpnpSearchAsync(
                                    glControlPointHandle,
                                    5 as libc::c_int,
                                    ((*Device).UDN).as_mut_ptr() as *const libc::c_char,
                                    Device as *const libc::c_void,
                                );
                            }
                        }
                        i___0 += 1;
                    }
                } else {
                    i___0 = 0 as libc::c_int;
                    loop {
                        if !(i___0 < glMaxDevices) {
                            current_block = 7337917895049117968;
                            break;
                        }
                        Device = glMRDevices.offset(i___0 as isize);
                        if (*Device).Running {
                            tmp___15 = strcmp(
                                ((*Device).DescDocURL).as_mut_ptr() as *const libc::c_char,
                                (*Update).Data as *const libc::c_char,
                            );
                            if tmp___15 == 0 {
                                friendlyName = 0 as *mut libc::c_void as *mut libc::c_char;
                                tmp___5 = GetMaster(Device, &mut friendlyName);
                                Master = tmp___5;
                                (*Device).LastSeen = now;
                                if *loglevel___0 as libc::c_uint >= 3 as libc::c_uint {
                                    tmp___6 = logtime();
                                    logprint(
                                        b"%s %s:%d [%p] UPnP keep alive: %s\n\0" as *const u8
                                            as *const libc::c_char,
                                        tmp___6,
                                        b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                        779 as libc::c_int,
                                        Device,
                                        ((*Device).Config.Name).as_mut_ptr(),
                                    );
                                }
                                UpnpDownloadXmlDoc(
                                    (*Update).Data as *const libc::c_char,
                                    &mut DescDoc,
                                );
                                if friendlyName.is_null() {
                                    friendlyName = XMLGetFirstDocumentItem(
                                        DescDoc,
                                        b"friendlyName\0" as *const u8 as *const libc::c_char,
                                        1 as libc::c_int != 0,
                                    );
                                }
                                if !friendlyName.is_null() {
                                    tmp___8 = strcmp(
                                        friendlyName as *const libc::c_char,
                                        ((*Device).friendlyName).as_mut_ptr() as *const libc::c_char,
                                    );
                                    if tmp___8 != 0 {
                                        tmp___9 = strlen(
                                            ((*Device).friendlyName).as_mut_ptr() as *const libc::c_char,
                                        );
                                        tmp___10 = strncmp(
                                            ((*Device).friendlyName).as_mut_ptr()
                                                as *const libc::c_char,
                                            ((*Device).Config.Name).as_mut_ptr() as *const libc::c_char,
                                            tmp___9,
                                        );
                                        if tmp___10 == 0 {
                                            tmp___11 = strlen(
                                                ((*Device).Config.Name).as_mut_ptr() as *const libc::c_char,
                                            );
                                            if (*Device)
                                                .Config
                                                .Name[tmp___11.wrapping_sub(1 as libc::c_ulong) as usize]
                                                as libc::c_int == 43 as libc::c_int
                                            {
                                                if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                                    tmp___7 = logtime();
                                                    logprint(
                                                        b"%s %s:%d [%p]: Device name change %s %s\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        tmp___7,
                                                        b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                                        788 as libc::c_int,
                                                        Device,
                                                        friendlyName,
                                                        ((*Device).friendlyName).as_mut_ptr(),
                                                    );
                                                }
                                                strcpy(
                                                    ((*Device).friendlyName).as_mut_ptr(),
                                                    friendlyName as *const libc::c_char,
                                                );
                                                sprintf(
                                                    ((*Device).Config.Name).as_mut_ptr(),
                                                    b"%s+\0" as *const u8 as *const libc::c_char,
                                                    friendlyName,
                                                );
                                                raop_update(
                                                    (*Device).Raop,
                                                    ((*Device).Config.Name).as_mut_ptr(),
                                                    b"airupnp\0" as *const u8 as *const libc::c_char
                                                        as *mut libc::c_char,
                                                );
                                                Updated = 1 as libc::c_int != 0;
                                            }
                                        }
                                    }
                                }
                                let mut current_block_112: u64;
                                if Master.is_null() {
                                    if !((*Device).Master).is_null() {
                                        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                            tmp___12 = logtime();
                                            logprint(
                                                b"%s %s:%d [%p]: Sonos %s is now master\n\0" as *const u8
                                                    as *const libc::c_char,
                                                tmp___12,
                                                b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                                798 as libc::c_int,
                                                Device,
                                                ((*Device).Config.Name).as_mut_ptr(),
                                            );
                                        }
                                        pthread_mutex_lock(&mut (*Device).Mutex);
                                        (*Device).Master = 0 as *mut libc::c_void as *mut sMR;
                                        if (*Device).Config.HTTPLength != 0 {
                                            tmp___13 = (*Device).Config.HTTPLength;
                                        } else {
                                            tmp___13 = 2147483647 as libc::c_int;
                                        }
                                        (*Device)
                                            .Raop = raop_create(
                                            glHost,
                                            glmDNSServer,
                                            ((*Device).Config.Name).as_mut_ptr(),
                                            b"airupnp\0" as *const u8 as *const libc::c_char
                                                as *mut libc::c_char,
                                            ((*Device).Config.mac).as_mut_ptr() as *mut libc::c_uchar,
                                            ((*Device).Config.Codec).as_mut_ptr(),
                                            (*Device).Config.Metadata,
                                            (*Device).Config.Drift,
                                            (*Device).Config.Flush,
                                            ((*Device).Config.Latency).as_mut_ptr(),
                                            Device as *mut libc::c_void,
                                            Some(
                                                HandleRAOP
                                                    as unsafe extern "C" fn(
                                                        *mut libc::c_void,
                                                        raop_event_t,
                                                        *mut libc::c_void,
                                                    ) -> (),
                                            ),
                                            Some(
                                                HandleHTTP
                                                    as unsafe extern "C" fn(
                                                        *mut libc::c_void,
                                                        *mut key_data_s,
                                                        *mut key_data_s,
                                                    ) -> (),
                                            ),
                                            glPortBase,
                                            glPortRange,
                                            tmp___13,
                                        );
                                        pthread_mutex_unlock(&mut (*Device).Mutex);
                                        current_block_112 = 10248984122780841972;
                                    } else {
                                        current_block_112 = 13225231385464678467;
                                    }
                                } else {
                                    current_block_112 = 13225231385464678467;
                                }
                                match current_block_112 {
                                    13225231385464678467 => {
                                        if !Master.is_null() {
                                            let mut current_block_109: u64;
                                            if ((*Device).Master).is_null() {
                                                current_block_109 = 10494300529663812675;
                                            } else if (*Device).Master as libc::c_ulong
                                                    == Device as libc::c_ulong
                                                {
                                                current_block_109 = 10494300529663812675;
                                            } else {
                                                current_block_109 = 13253659531982233645;
                                            }
                                            match current_block_109 {
                                                10494300529663812675 => {
                                                    pthread_mutex_lock(&mut (*Device).Mutex);
                                                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                                        tmp___14 = logtime();
                                                        logprint(
                                                            b"%s %s:%d [%p]: Sonos %s is now slave\n\0" as *const u8
                                                                as *const libc::c_char,
                                                            tmp___14,
                                                            b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                                            810 as libc::c_int,
                                                            Device,
                                                            ((*Device).Config.Name).as_mut_ptr(),
                                                        );
                                                    }
                                                    (*Device).Master = Master;
                                                    raop_delete((*Device).Raop);
                                                    (*Device).Raop = 0 as *mut libc::c_void as *mut raop_ctx_s;
                                                    pthread_mutex_unlock(&mut (*Device).Mutex);
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                if !friendlyName.is_null() {
                                    free(friendlyName as *mut libc::c_void);
                                    friendlyName = 0 as *mut libc::c_void as *mut libc::c_char;
                                }
                                current_block = 15017683767704321837;
                                break;
                            }
                        }
                        i___0 += 1;
                    }
                    match current_block {
                        7337917895049117968 => {
                            rc = UpnpDownloadXmlDoc(
                                (*Update).Data as *const libc::c_char,
                                &mut DescDoc,
                            );
                            if rc != 0 as libc::c_int {
                                if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                                    tmp___16 = logtime();
                                    logprint(
                                        b"%s %s:%d Error obtaining description %s -- error = %d\n\n\0"
                                            as *const u8 as *const libc::c_char,
                                        tmp___16,
                                        b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                        824 as libc::c_int,
                                        (*Update).Data,
                                        rc,
                                    );
                                }
                            } else {
                                tmp___17 = XMLMatchDocumentItem(
                                    DescDoc,
                                    b"deviceType\0" as *const u8 as *const libc::c_char,
                                    b"urn:schemas-upnp-org:device:MediaRenderer\0" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int != 0,
                                );
                                if tmp___17 {
                                    ModelName = XMLGetFirstDocumentItem(
                                        DescDoc,
                                        b"modelName\0" as *const u8 as *const libc::c_char,
                                        1 as libc::c_int != 0,
                                    );
                                    ModelNumber = XMLGetFirstDocumentItem(
                                        DescDoc,
                                        b"modelNumber\0" as *const u8 as *const libc::c_char,
                                        1 as libc::c_int != 0,
                                    );
                                    UDN = XMLGetFirstDocumentItem(
                                        DescDoc,
                                        b"UDN\0" as *const u8 as *const libc::c_char,
                                        1 as libc::c_int != 0,
                                    );
                                    tmp___18 = isExcluded(ModelName, ModelNumber);
                                    if !tmp___18 {
                                        i___0 = 0 as libc::c_int;
                                        while i___0 < glMaxDevices {
                                            if !(*glMRDevices.offset(i___0 as isize)).Running {
                                                break;
                                            }
                                            i___0 += 1;
                                        }
                                        if i___0 == glMaxDevices {
                                            tmp___19 = logtime();
                                            logprint(
                                                b"%s %s:%d Too many uPNP devices (max:%u)\n\0" as *const u8
                                                    as *const libc::c_char,
                                                tmp___19,
                                                b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                                848 as libc::c_int,
                                                glMaxDevices,
                                            );
                                        } else {
                                            Device = glMRDevices.offset(i___0 as isize);
                                            Updated = 1 as libc::c_int != 0;
                                            tmp___22 = AddMRDevice(
                                                Device,
                                                UDN,
                                                DescDoc,
                                                (*Update).Data as *const libc::c_char,
                                            );
                                            if tmp___22 {
                                                if !glDiscovery {
                                                    if (*Device).Config.HTTPLength != 0 {
                                                        tmp___20 = (*Device).Config.HTTPLength;
                                                    } else {
                                                        tmp___20 = 2147483647 as libc::c_int;
                                                    }
                                                    (*Device)
                                                        .Raop = raop_create(
                                                        glHost,
                                                        glmDNSServer,
                                                        ((*Device).Config.Name).as_mut_ptr(),
                                                        b"airupnp\0" as *const u8 as *const libc::c_char
                                                            as *mut libc::c_char,
                                                        ((*Device).Config.mac).as_mut_ptr() as *mut libc::c_uchar,
                                                        ((*Device).Config.Codec).as_mut_ptr(),
                                                        (*Device).Config.Metadata,
                                                        (*Device).Config.Drift,
                                                        (*Device).Config.Flush,
                                                        ((*Device).Config.Latency).as_mut_ptr(),
                                                        Device as *mut libc::c_void,
                                                        Some(
                                                            HandleRAOP
                                                                as unsafe extern "C" fn(
                                                                    *mut libc::c_void,
                                                                    raop_event_t,
                                                                    *mut libc::c_void,
                                                                ) -> (),
                                                        ),
                                                        Some(
                                                            HandleHTTP
                                                                as unsafe extern "C" fn(
                                                                    *mut libc::c_void,
                                                                    *mut key_data_s,
                                                                    *mut key_data_s,
                                                                ) -> (),
                                                        ),
                                                        glPortBase,
                                                        glPortRange,
                                                        tmp___20,
                                                    );
                                                    if ((*Device).Raop).is_null() {
                                                        tmp___21 = logtime();
                                                        logprint(
                                                            b"%s %s:%d [%p]: cannot create RAOP instance (%s)\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            tmp___21,
                                                            b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                                            864 as libc::c_int,
                                                            Device,
                                                            ((*Device).Config.Name).as_mut_ptr(),
                                                        );
                                                        DelMRDevice(Device);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    if Updated {
                        let mut current_block_156: u64;
                        if glAutoSaveConfigFile {
                            current_block_156 = 11275914710009028990;
                        } else if glDiscovery {
                            current_block_156 = 11275914710009028990;
                        } else {
                            current_block_156 = 10282596542094995802;
                        }
                        match current_block_156 {
                            11275914710009028990 => {
                                if *loglevel___0 as libc::c_uint >= 3 as libc::c_uint {
                                    tmp___23 = logtime();
                                    logprint(
                                        b"%s %s:%d Updating configuration %s\n\0" as *const u8
                                            as *const libc::c_char,
                                        tmp___23,
                                        b"UpdateThread\0" as *const u8 as *const libc::c_char,
                                        871 as libc::c_int,
                                        glConfigName.as_mut_ptr(),
                                    );
                                }
                                SaveConfig(
                                    glConfigName.as_mut_ptr(),
                                    glConfigID,
                                    0 as libc::c_int != 0,
                                );
                            }
                            _ => {}
                        }
                    }
                    if !UDN.is_null() {
                        free(UDN as *mut libc::c_void);
                        UDN = 0 as *mut libc::c_void as *mut libc::c_char;
                    }
                    if !ModelName.is_null() {
                        free(ModelName as *mut libc::c_void);
                        ModelName = 0 as *mut libc::c_void as *mut libc::c_char;
                    }
                    if !ModelNumber.is_null() {
                        free(ModelNumber as *mut libc::c_void);
                        ModelNumber = 0 as *mut libc::c_void as *mut libc::c_char;
                    }
                    if !DescDoc.is_null() {
                        ixmlDocument_free(DescDoc);
                    }
                }
            }
            FreeUpdate(Update as *mut libc::c_void);
        }
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn MainThread(mut args: *mut libc::c_void) -> *mut libc::c_void {
    let mut size: u32_t = 0;
    let mut tmp: libc::c_long = 0;
    let mut Sum: u32_t = 0;
    let mut BufSize: u32_t = 0;
    let mut buf___0: *mut u8_t = 0 as *mut u8_t;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut rlog: *mut FILE = 0 as *mut FILE;
    let mut tmp___1: *mut FILE = 0 as *mut FILE;
    let mut wlog: *mut FILE = 0 as *mut FILE;
    let mut tmp___2: *mut FILE = 0 as *mut FILE;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: *mut FILE = 0 as *mut FILE;
    let mut Host: in_addr = in_addr { s_addr: 0 };
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    while glMainRunning {
        WakeableSleep(30000 as libc::c_int as u32_t);
        if !glMainRunning {
            break;
        }
        if !glLogFile.is_null() {
            if glLogLimit != -(1 as libc::c_int) {
                tmp = ftell(stderr);
                size = tmp as u32_t;
                if size
                    > (glLogLimit * 1024 as libc::c_int * 1024 as libc::c_int) as u32_t
                {
                    BufSize = 16384 as libc::c_int as u32_t;
                    tmp___0 = malloc(BufSize as size_t);
                    buf___0 = tmp___0 as *mut u8_t;
                    tmp___1 = fopen(
                        glLogFile as *const libc::c_char,
                        b"rb\0" as *const u8 as *const libc::c_char,
                    );
                    rlog = tmp___1;
                    tmp___2 = fopen(
                        glLogFile as *const libc::c_char,
                        b"r+b\0" as *const u8 as *const libc::c_char,
                    );
                    wlog = tmp___2;
                    if *loglevel___0 as libc::c_uint >= 3 as libc::c_uint {
                        tmp___3 = logtime();
                        logprint(
                            b"%s %s:%d Resizing log\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___3,
                            b"MainThread\0" as *const u8 as *const libc::c_char,
                            904 as libc::c_int,
                            0 as *mut libc::c_void,
                        );
                    }
                    Sum = 0 as libc::c_int as u32_t;
                    fseek(
                        rlog,
                        size
                            .wrapping_sub(
                                (glLogLimit * 1024 as libc::c_int * 1024 as libc::c_int
                                    / 2 as libc::c_int) as u32_t,
                            ) as libc::c_long,
                        0 as libc::c_int,
                    );
                    loop {
                        tmp___4 = fread(
                            buf___0 as *mut libc::c_void,
                            1 as libc::c_int as size_t,
                            BufSize as size_t,
                            rlog,
                        );
                        BufSize = tmp___4 as u32_t;
                        if !(BufSize != 0 as libc::c_uint) {
                            break;
                        }
                        Sum = (Sum as libc::c_uint).wrapping_add(BufSize) as u32_t
                            as u32_t;
                        fwrite(
                            buf___0 as *const libc::c_void,
                            1 as libc::c_int as size_t,
                            BufSize as size_t,
                            wlog,
                        );
                    }
                    tmp___5 = fileno(wlog);
                    tmp___6 = ftruncate(tmp___5, Sum as __off64_t);
                    Sum = tmp___6 as u32_t;
                    fclose(wlog);
                    fclose(rlog);
                    if !buf___0.is_null() {
                        free(buf___0 as *mut libc::c_void);
                        buf___0 = 0 as *mut libc::c_void as *mut u8_t;
                    }
                    tmp___8 = freopen(
                        glLogFile as *const libc::c_char,
                        b"a\0" as *const u8 as *const libc::c_char,
                        stderr,
                    );
                    if tmp___8.is_null() {
                        tmp___7 = logtime();
                        logprint(
                            b"%s %s:%d re-open error while truncating log\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___7,
                            b"MainThread\0" as *const u8 as *const libc::c_char,
                            914 as libc::c_int,
                            0 as *mut libc::c_void,
                        );
                    }
                }
            }
        }
        tmp___11 = strstr(
            glBinding.as_mut_ptr() as *const libc::c_char,
            b"?\0" as *const u8 as *const libc::c_char,
        );
        if !tmp___11.is_null() {
            Host
                .s_addr = get_localhost(
                0 as *mut libc::c_void as *mut *mut libc::c_char,
            );
            if Host.s_addr != 0 as libc::c_uint {
                if Host.s_addr != glHost.s_addr {
                    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
                        tmp___9 = inet_ntoa(glHost);
                        tmp___10 = logtime();
                        logprint(
                            b"%s %s:%d IP change detected %s\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___10,
                            b"MainThread\0" as *const u8 as *const libc::c_char,
                            924 as libc::c_int,
                            tmp___9,
                        );
                    }
                    Stop(0 as libc::c_int != 0);
                    glMainRunning = 1 as libc::c_int != 0;
                    Start(0 as libc::c_int != 0);
                }
            }
        }
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn AddMRDevice(
    mut Device: *mut sMR,
    mut UDN: *mut libc::c_char,
    mut DescDoc: *mut IXML_Document,
    mut location: *const libc::c_char,
) -> bool {
    let mut friendlyName: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut mac_size: libc::c_ulong = 0;
    let mut ip: in_addr_t = 0;
    let mut now: u32_t = 0;
    let mut tmp: u32_t = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: u32_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: libc::c_uint = 0;
    let mut ServiceId: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ServiceType: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut EventURL: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ControlURL: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: *mut sService = 0 as *mut sService;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut hash: u32_t = 0;
    let mut tmp___12: u32_t = 0;
    let mut tmp___13: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: *mut libc::c_char = 0 as *mut libc::c_char;
    friendlyName = 0 as *mut libc::c_void as *mut libc::c_char;
    mac_size = 6 as libc::c_ulong;
    tmp = gettime_ms();
    now = tmp;
    memcpy(
        &mut (*Device).Config as *mut tMRConfig as *mut libc::c_void,
        &mut glMRConfig as *mut tMRConfig as *const libc::c_void,
        ::std::mem::size_of::<tMRConfig>() as libc::c_ulong,
    );
    LoadMRConfig(glConfigID, UDN, &mut (*Device).Config);
    if !(*Device).Config.Enabled {
        return 0 as libc::c_int != 0;
    }
    friendlyName = XMLGetFirstDocumentItem(
        DescDoc,
        b"friendlyName\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    if !friendlyName.is_null() {
        strcpy(
            ((*Device).friendlyName).as_mut_ptr(),
            friendlyName as *const libc::c_char,
        );
    }
    if friendlyName.is_null() {
        friendlyName = strdup(UDN as *const libc::c_char);
    } else if *friendlyName == 0 {
        friendlyName = strdup(UDN as *const libc::c_char);
    }
    if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d UDN:\t%s\nFriendlyName:\t%s\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"AddMRDevice\0" as *const u8 as *const libc::c_char,
            955 as libc::c_int,
            UDN,
            friendlyName,
        );
    }
    (*Device).Magic = 2864434397 as libc::c_uint;
    (*Device).RaopState = RAOP_STOP;
    (*Device).State = STOPPED;
    (*Device).LastSeen = now.wrapping_div(1000 as libc::c_uint);
    tmp___1 = now.wrapping_sub(2000 as libc::c_uint);
    (*Device).VolumeStampTx = tmp___1;
    (*Device).VolumeStampRx = tmp___1;
    (*Device).ExpectStop = 0 as libc::c_int != 0;
    (*Device).TimeOut = 0 as libc::c_int != 0;
    tmp___2 = 0 as *mut libc::c_void;
    (*Device).StartCookie = tmp___2;
    (*Device).WaitCookie = tmp___2;
    (*Device).Raop = 0 as *mut libc::c_void as *mut raop_ctx_s;
    (*Device).Elapsed = 0 as libc::c_int as u32_t;
    (*Device).seqN = 0 as *mut libc::c_void as *mut u8_t;
    tmp___3 = 0 as libc::c_uint;
    (*Device).StatePoll = tmp___3;
    (*Device).TrackPoll = tmp___3;
    (*Device).Volume = 0 as libc::c_int as libc::c_double;
    (*Device).Actions = 0 as *mut libc::c_void as *mut sAction;
    (*Device).Master = 0 as *mut libc::c_void as *mut sMR;
    strcpy(((*Device).UDN).as_mut_ptr(), UDN as *const libc::c_char);
    strcpy(((*Device).DescDocURL).as_mut_ptr(), location);
    memset(
        &mut (*Device).MetaData as *mut metadata_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<metadata_t>() as libc::c_ulong,
    );
    memset(
        &mut (*Device).Service as *mut [sService; 5] as *mut libc::c_void,
        0 as libc::c_int,
        (::std::mem::size_of::<sService>() as libc::c_ulong)
            .wrapping_mul(5 as libc::c_ulong),
    );
    i = 0 as libc::c_int;
    while i < 5 as libc::c_int {
        ServiceId = 0 as *mut libc::c_void as *mut libc::c_char;
        ServiceType = 0 as *mut libc::c_void as *mut libc::c_char;
        EventURL = 0 as *mut libc::c_void as *mut libc::c_char;
        ControlURL = 0 as *mut libc::c_void as *mut libc::c_char;
        strcpy(
            ((*Device).Service[i as usize].Id).as_mut_ptr(),
            b"\0" as *const u8 as *const libc::c_char,
        );
        tmp___5 = XMLFindAndParseService(
            DescDoc,
            location,
            (cSearchedSRV[i as usize].name).as_ptr(),
            &mut ServiceType,
            &mut ServiceId,
            &mut EventURL,
            &mut ControlURL,
        );
        if tmp___5 != 0 {
            s = &mut *((*Device).Service)
                .as_mut_ptr()
                .offset((*cSearchedSRV.as_ptr().offset(i as isize)).idx as isize)
                as *mut sService;
            if *loglevel___0 as libc::c_uint >= 4 as libc::c_uint {
                tmp___4 = logtime();
                logprint(
                    b"%s %s:%d \tservice [%s] %s %s, %s, %s\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___4,
                    b"AddMRDevice\0" as *const u8 as *const libc::c_char,
                    987 as libc::c_int,
                    (cSearchedSRV[i as usize].name).as_ptr(),
                    ServiceType,
                    ServiceId,
                    EventURL,
                    ControlURL,
                );
            }
            strncpy(
                ((*s).Id).as_mut_ptr(),
                ServiceId as *const libc::c_char,
                249 as libc::c_int as size_t,
            );
            strncpy(
                ((*s).ControlURL).as_mut_ptr(),
                ControlURL as *const libc::c_char,
                249 as libc::c_int as size_t,
            );
            strncpy(
                ((*s).EventURL).as_mut_ptr(),
                EventURL as *const libc::c_char,
                249 as libc::c_int as size_t,
            );
            strncpy(
                ((*s).Type).as_mut_ptr(),
                ServiceType as *const libc::c_char,
                249 as libc::c_int as size_t,
            );
            (*s).TimeOut = cSearchedSRV[i as usize].TimeOut as s32_t;
        }
        if !ServiceId.is_null() {
            free(ServiceId as *mut libc::c_void);
            ServiceId = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if !ServiceType.is_null() {
            free(ServiceType as *mut libc::c_void);
            ServiceType = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if !EventURL.is_null() {
            free(EventURL as *mut libc::c_void);
            EventURL = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if !ControlURL.is_null() {
            free(ControlURL as *mut libc::c_void);
            ControlURL = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        i += 1;
    }
    (*Device).Master = GetMaster(Device, &mut friendlyName);
    tmp___6 = CtrlGetVolume(Device);
    (*Device).Volume = tmp___6 as libc::c_double;
    if !((*Device).Master).is_null() {
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp___7 = logtime();
            logprint(
                b"%s %s:%d [%p] skipping Sonos slave %s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___7,
                b"AddMRDevice\0" as *const u8 as *const libc::c_char,
                1006 as libc::c_int,
                Device,
                friendlyName,
            );
        }
    } else if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
        tmp___8 = logtime();
        logprint(
            b"%s %s:%d [%p]: adding renderer (%s)\n\0" as *const u8
                as *const libc::c_char,
            tmp___8,
            b"AddMRDevice\0" as *const u8 as *const libc::c_char,
            1008 as libc::c_int,
            Device,
            friendlyName,
        );
    }
    if (*Device).Service[3 as libc::c_int as usize].ControlURL[0 as libc::c_int as usize]
        != 0
    {
        (*Device).MetaData.duration = 1 as libc::c_int as u32_t;
        (*Device)
            .MetaData
            .title = strdup(
            b"Streaming from AirConnect\0" as *const u8 as *const libc::c_char,
        );
    } else {
        (*Device)
            .MetaData
            .remote_title = strdup(
            b"Streaming from AirConnect\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*Device).Config.ArtWork[0 as libc::c_int as usize] != 0 {
        (*Device)
            .MetaData
            .artwork = strdup(
            ((*Device).Config.ArtWork).as_mut_ptr() as *const libc::c_char,
        );
    }
    (*Device).Running = 1 as libc::c_int != 0;
    if !friendlyName.is_null() {
        strcpy(
            ((*Device).friendlyName).as_mut_ptr(),
            friendlyName as *const libc::c_char,
        );
    }
    if (*Device).Config.Name[0 as libc::c_int as usize] == 0 {
        sprintf(
            ((*Device).Config.Name).as_mut_ptr(),
            b"%s+\0" as *const u8 as *const libc::c_char,
            friendlyName,
        );
    }
    QueueInit(
        &mut (*Device).ActionQueue,
        0 as libc::c_int != 0,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(0 as *mut libc::c_void),
    );
    tmp___11 = strcasecmp(
        ((*Device).Config.Codec).as_mut_ptr() as *const libc::c_char,
        b"pcm\0" as *const u8 as *const libc::c_char,
    );
    if tmp___11 != 0 {
        tmp___10 = strcasecmp(
            ((*Device).Config.Codec).as_mut_ptr() as *const libc::c_char,
            b"wav\0" as *const u8 as *const libc::c_char,
        );
        if tmp___10 != 0 {
            tmp___9 = strcasestr(
                ((*Device).Config.Codec).as_mut_ptr() as *const libc::c_char,
                b"mp3\0" as *const u8 as *const libc::c_char,
            );
            if !tmp___9.is_null() {
                (*Device)
                    .ProtocolInfo = ((*Device).Config.ProtocolInfo.mp3).as_mut_ptr();
            } else {
                (*Device)
                    .ProtocolInfo = ((*Device).Config.ProtocolInfo.flac).as_mut_ptr();
            }
        } else {
            (*Device).ProtocolInfo = ((*Device).Config.ProtocolInfo.wav).as_mut_ptr();
        }
    } else {
        (*Device).ProtocolInfo = ((*Device).Config.ProtocolInfo.pcm).as_mut_ptr();
    }
    ip = ExtractIP(location);
    tmp___15 = memcmp(
        ((*Device).Config.mac).as_mut_ptr() as *const libc::c_void,
        b"\0\0\0\0\0\0\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        mac_size,
    );
    if tmp___15 == 0 {
        tmp___14 = SendARP(
            ip,
            0 as libc::c_int as in_addr_t,
            ((*Device).Config.mac).as_mut_ptr(),
            &mut mac_size,
        );
        if tmp___14 != 0 {
            tmp___12 = hash32(UDN);
            hash = tmp___12;
            tmp___13 = logtime();
            logprint(
                b"%s %s:%d [%p]: cannot get mac %s, creating fake %x\n\0" as *const u8
                    as *const libc::c_char,
                tmp___13,
                b"AddMRDevice\0" as *const u8 as *const libc::c_char,
                1035 as libc::c_int,
                Device,
                ((*Device).Config.Name).as_mut_ptr(),
                hash,
            );
            memcpy(
                ((*Device).Config.mac).as_mut_ptr().offset(2 as libc::c_int as isize)
                    as *mut libc::c_void,
                &mut hash as *mut u32_t as *const libc::c_void,
                4 as libc::c_int as size_t,
            );
        }
        memset(
            ((*Device).Config.mac).as_mut_ptr() as *mut libc::c_void,
            187 as libc::c_int,
            2 as libc::c_int as size_t,
        );
    }
    MakeMacUnique(Device);
    if !friendlyName.is_null() {
        free(friendlyName as *mut libc::c_void);
        friendlyName = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    pthread_create(
        &mut (*Device).Thread as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        Some(MRThread as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void),
        Device as *mut libc::c_void,
    );
    i = 0 as libc::c_int;
    while i < 5 as libc::c_int {
        if (*Device).Service[i as usize].TimeOut != 0 {
            tmp___16 = strdup(UDN as *const libc::c_char);
            UpnpSubscribeAsync(
                glControlPointHandle,
                ((*Device).Service[i as usize].EventURL).as_mut_ptr()
                    as *const libc::c_char,
                (*Device).Service[i as usize].TimeOut,
                Some(
                    MasterHandler
                        as unsafe extern "C" fn(
                            Upnp_EventType,
                            *mut libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                tmp___16 as *mut libc::c_void as *const libc::c_void,
            );
        }
        i += 1;
    }
    return (*Device).Master as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong;
}
unsafe extern "C" fn isExcluded(
    mut Model: *mut libc::c_char,
    mut ModelNumber: *mut libc::c_char,
) -> bool {
    let mut item: [libc::c_char; 256] = [0; 256];
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut o: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    p = glExcluded;
    q = glExcludedModelNumber;
    o = glIncludedModelNumbers;
    if !glIncludedModelNumbers.is_null() {
        if ModelNumber.is_null() {
            tmp = strcasestr(
                glIncludedModelNumbers as *const libc::c_char,
                b"<NULL>\0" as *const u8 as *const libc::c_char,
            );
            if !tmp.is_null() {
                return 0 as libc::c_int != 0
            } else {
                return 1 as libc::c_int != 0
            }
        }
        loop {
            sscanf(
                o as *const libc::c_char,
                b"%[^,]\0" as *const u8 as *const libc::c_char,
                item.as_mut_ptr(),
            );
            tmp___0 = strcmp(
                ModelNumber as *const libc::c_char,
                item.as_mut_ptr() as *const libc::c_char,
            );
            if tmp___0 == 0 {
                return 0 as libc::c_int != 0;
            }
            tmp___1 = strlen(item.as_mut_ptr() as *const libc::c_char);
            o = o.offset(tmp___1 as isize);
            tmp___2 = o;
            o = o.offset(1);
            if *tmp___2 == 0 {
                break;
            }
        }
        return 1 as libc::c_int != 0;
    }
    if !glExcluded.is_null() {
        if !Model.is_null() {
            loop {
                sscanf(
                    p as *const libc::c_char,
                    b"%[^,]\0" as *const u8 as *const libc::c_char,
                    item.as_mut_ptr(),
                );
                tmp___3 = strcasestr(
                    Model as *const libc::c_char,
                    item.as_mut_ptr() as *const libc::c_char,
                );
                if !tmp___3.is_null() {
                    return 1 as libc::c_int != 0;
                }
                tmp___4 = strlen(item.as_mut_ptr() as *const libc::c_char);
                p = p.offset(tmp___4 as isize);
                tmp___5 = p;
                p = p.offset(1);
                if *tmp___5 == 0 {
                    break;
                }
            }
        }
    }
    if !glExcludedModelNumber.is_null() {
        if !ModelNumber.is_null() {
            loop {
                sscanf(
                    q as *const libc::c_char,
                    b"%[^,]\0" as *const u8 as *const libc::c_char,
                    item.as_mut_ptr(),
                );
                tmp___6 = strcasestr(
                    ModelNumber as *const libc::c_char,
                    item.as_mut_ptr() as *const libc::c_char,
                );
                if !tmp___6.is_null() {
                    return 1 as libc::c_int != 0;
                }
                tmp___7 = strlen(item.as_mut_ptr() as *const libc::c_char);
                q = q.offset(tmp___7 as isize);
                tmp___8 = q;
                q = q.offset(1);
                if *tmp___8 == 0 {
                    break;
                }
            }
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Start(mut cold: bool) -> bool {
    let mut current_block: u64;
    let mut hostname: [libc::c_char; 256] = [0; 256];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut IP: [libc::c_char; 16] = [0; 16];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut host: in_addr = in_addr { s_addr: 0 };
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_ushort = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: bool = false;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut SearchTopic: [libc::c_char; 44] = [0; 44];
    IP[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 16 as libc::c_uint) {
        IP[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    glHost.s_addr = 0 as libc::c_int as in_addr_t;
    tmp___0 = strstr(
        glBinding.as_mut_ptr() as *const libc::c_char,
        b"?\0" as *const u8 as *const libc::c_char,
    );
    if tmp___0.is_null() {
        tmp___1 = sscanf(
            glBinding.as_mut_ptr() as *const libc::c_char,
            b"%[^:]:%u\0" as *const u8 as *const libc::c_char,
            IP.as_mut_ptr(),
            &mut glPort as *mut u32_t,
        );
        if tmp___1 == 0 {
            sscanf(
                glBinding.as_mut_ptr() as *const libc::c_char,
                b":%u\0" as *const u8 as *const libc::c_char,
                &mut glPort as *mut u32_t,
            );
        }
    }
    if IP[0 as libc::c_int as usize] == 0 {
        host.s_addr = get_localhost(0 as *mut libc::c_void as *mut *mut libc::c_char);
        tmp___2 = inet_ntoa(host);
        strcpy(IP.as_mut_ptr(), tmp___2 as *const libc::c_char);
    }
    UpnpSetLogLevel(UPNP_ALL);
    rc = UpnpInit(IP.as_mut_ptr() as *const libc::c_char, glPort as libc::c_ushort);
    if rc != 0 as libc::c_int {
        tmp___3 = logtime();
        logprint(
            b"%s %s:%d UPnP init failed: %d\n\0" as *const u8 as *const libc::c_char,
            tmp___3,
            b"Start\0" as *const u8 as *const libc::c_char,
            1120 as libc::c_int,
            rc,
        );
    } else {
        UpnpSetMaxContentLength(60000 as libc::c_int as size_t);
        glHost.s_addr = inet_addr(IP.as_mut_ptr() as *const libc::c_char);
        gethostname(glHostName.as_mut_ptr(), 256 as libc::c_int as size_t);
        tmp___4 = UpnpGetServerPort();
        glPort = tmp___4 as u32_t;
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp___5 = logtime();
            logprint(
                b"%s %s:%d Binding to %s:%d\n\0" as *const u8 as *const libc::c_char,
                tmp___5,
                b"Start\0" as *const u8 as *const libc::c_char,
                1130 as libc::c_int,
                IP.as_mut_ptr(),
                glPort,
            );
        }
        if cold {
            tmp___7 = load_ssl_symbols();
            if !tmp___7 {
                tmp___6 = logtime();
                logprint(
                    b"%s %s:%d Cannot load SSL libraries\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___6,
                    b"Start\0" as *const u8 as *const libc::c_char,
                    1135 as libc::c_int,
                    0 as *mut libc::c_void,
                );
                current_block = 15073472184771409921;
            } else {
                InitUtils();
                tmp___8 = calloc(
                    glMaxDevices as size_t,
                    ::std::mem::size_of::<sMR>() as libc::c_ulong,
                );
                glMRDevices = tmp___8 as *mut sMR;
                i = 0 as libc::c_int;
                while i < glMaxDevices {
                    pthread_mutex_init(
                        &mut (*glMRDevices.offset(i as isize)).Mutex,
                        0 as *const pthread_mutexattr_t,
                    );
                    i += 1;
                }
                pthread_create(
                    &mut glMainThread as *mut pthread_t,
                    0 as *mut libc::c_void as *const pthread_attr_t,
                    Some(
                        MainThread
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                            ) -> *mut libc::c_void,
                    ),
                    0 as *mut libc::c_void,
                );
                current_block = 17784502470059252271;
            }
        } else {
            current_block = 17784502470059252271;
        }
        match current_block {
            15073472184771409921 => {}
            _ => {
                if glHost.s_addr != 0 as libc::c_uint {
                    pthread_mutex_init(
                        &mut glUpdateMutex,
                        0 as *const pthread_mutexattr_t,
                    );
                    pthread_cond_init(
                        &mut glUpdateCond as *mut pthread_cond_t,
                        0 as *const pthread_condattr_t,
                    );
                    QueueInit(
                        &mut glUpdateQueue,
                        1 as libc::c_int != 0,
                        Some(FreeUpdate as unsafe extern "C" fn(*mut libc::c_void) -> ()),
                    );
                    pthread_create(
                        &mut glUpdateThread as *mut pthread_t,
                        0 as *mut libc::c_void as *const pthread_attr_t,
                        Some(
                            UpdateThread
                                as unsafe extern "C" fn(
                                    *mut libc::c_void,
                                ) -> *mut libc::c_void,
                        ),
                        0 as *mut libc::c_void,
                    );
                    rc = UpnpRegisterClient(
                        Some(
                            MasterHandler
                                as unsafe extern "C" fn(
                                    Upnp_EventType,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> libc::c_int,
                        ),
                        0 as *mut libc::c_void as *const libc::c_void,
                        &mut glControlPointHandle,
                    );
                    if rc != 0 as libc::c_int {
                        tmp___9 = logtime();
                        logprint(
                            b"%s %s:%d Error registering ControlPoint: %d\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___9,
                            b"Start\0" as *const u8 as *const libc::c_char,
                            1159 as libc::c_int,
                            rc,
                        );
                        current_block = 15073472184771409921;
                    } else {
                        snprintf(
                            hostname.as_mut_ptr(),
                            256 as libc::c_int as size_t,
                            b"%s.local\0" as *const u8 as *const libc::c_char,
                            glHostName.as_mut_ptr(),
                        );
                        glmDNSServer = mdnsd_start(glHost);
                        if glmDNSServer as libc::c_ulong
                            == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            current_block = 15073472184771409921;
                        } else {
                            mdnsd_set_hostname(
                                glmDNSServer,
                                hostname.as_mut_ptr() as *const libc::c_char,
                                glHost,
                            );
                            i = 0 as libc::c_int;
                            while i < glMRConfig.UPnPMax {
                                sprintf(
                                    SearchTopic.as_mut_ptr(),
                                    b"%s:%i\0" as *const u8 as *const libc::c_char,
                                    b"urn:schemas-upnp-org:device:MediaRenderer\0" as *const u8
                                        as *const libc::c_char,
                                    i + 1 as libc::c_int,
                                );
                                UpnpSearchAsync(
                                    glControlPointHandle,
                                    20 as libc::c_int,
                                    SearchTopic.as_mut_ptr() as *const libc::c_char,
                                    0 as *mut libc::c_void as *const libc::c_void,
                                );
                                i += 1;
                            }
                            current_block = 7343950298149844727;
                        }
                    }
                } else {
                    current_block = 7343950298149844727;
                }
                match current_block {
                    15073472184771409921 => {}
                    _ => return 1 as libc::c_int != 0,
                }
            }
        }
    }
    UpnpFinish();
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Stop(mut exit___0: bool) -> bool {
    let mut i: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    glMainRunning = 0 as libc::c_int != 0;
    if glHost.s_addr != 0 as libc::c_uint {
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp = logtime();
            logprint(
                b"%s %s:%d terminate update thread ...\n\0" as *const u8
                    as *const libc::c_char,
                tmp,
                b"Stop\0" as *const u8 as *const libc::c_char,
                1193 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        pthread_cond_signal(&mut glUpdateCond);
        pthread_join(glUpdateThread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp___0 = logtime();
            logprint(
                b"%s %s:%d flush renderers ...\n\0" as *const u8 as *const libc::c_char,
                tmp___0,
                b"Stop\0" as *const u8 as *const libc::c_char,
                1198 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        FlushMRDevices();
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp___1 = logtime();
            logprint(
                b"%s %s:%d terminate libupnp\n\0" as *const u8 as *const libc::c_char,
                tmp___1,
                b"Stop\0" as *const u8 as *const libc::c_char,
                1201 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        UpnpUnRegisterClient(glControlPointHandle);
        UpnpFinish();
        pthread_mutex_destroy(&mut glUpdateMutex);
        pthread_cond_destroy(&mut glUpdateCond);
        QueueFlush(&mut glUpdateQueue);
        mdnsd_stop(glmDNSServer);
    } else {
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp___2 = logtime();
            logprint(
                b"%s %s:%d terminate libupnp\n\0" as *const u8 as *const libc::c_char,
                tmp___2,
                b"Stop\0" as *const u8 as *const libc::c_char,
                1214 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        UpnpFinish();
    }
    if exit___0 {
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp___3 = logtime();
            logprint(
                b"%s %s:%d terminate main thread ...\n\0" as *const u8
                    as *const libc::c_char,
                tmp___3,
                b"Stop\0" as *const u8 as *const libc::c_char,
                1220 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        WakeAll();
        pthread_join(glMainThread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
        i = 0 as libc::c_int;
        while i < glMaxDevices {
            pthread_mutex_destroy(&mut (*glMRDevices.offset(i as isize)).Mutex);
            i += 1;
        }
        EndUtils();
        if !glConfigID.is_null() {
            ixmlDocument_free(glConfigID as *mut IXML_Document);
        }
        free_ssl_symbols();
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn sighandler(mut signum: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if !glGracefullShutdown {
        i = 0 as libc::c_int;
        while i < glMaxDevices {
            p = glMRDevices.offset(i as isize);
            if (*p).Running {
                if (*p).State as libc::c_uint == 2 as libc::c_uint {
                    AVTStop(p);
                }
            }
            i += 1;
        }
        if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
            tmp = logtime();
            logprint(
                b"%s %s:%d forced exit\n\0" as *const u8 as *const libc::c_char,
                tmp,
                b"sighandler\0" as *const u8 as *const libc::c_char,
                1250 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        exit(0 as libc::c_int);
    }
    Stop(1 as libc::c_int != 0);
    exit(0 as libc::c_int);
}
pub unsafe extern "C" fn ParseArgs(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> bool {
    let mut optarg___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut optind___0: libc::c_int = 0;
    let mut cmdline: [libc::c_char; 256] = [0; 256];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut opt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut l: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut v: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut new: log_level = lERROR;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: size_t = 0;
    optarg___0 = 0 as *mut libc::c_void as *mut libc::c_char;
    optind___0 = 1 as libc::c_int;
    cmdline[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 256 as libc::c_uint) {
        cmdline[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    i = 0 as libc::c_int;
    while i < argc {
        tmp___0 = strlen(*argv.offset(i as isize) as *const libc::c_char);
        tmp___1 = strlen(cmdline.as_mut_ptr() as *const libc::c_char);
        if !(tmp___0.wrapping_add(tmp___1).wrapping_add(2 as libc::c_ulong)
            < ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
        {
            break;
        }
        strcat(cmdline.as_mut_ptr(), *argv.offset(i as isize) as *const libc::c_char);
        strcat(cmdline.as_mut_ptr(), b" \0" as *const u8 as *const libc::c_char);
        i += 1;
    }
    while optind___0 < argc {
        tmp___20 = strlen(*argv.offset(optind___0 as isize) as *const libc::c_char);
        if !(tmp___20 >= 2 as libc::c_ulong) {
            break;
        }
        if !(*(*argv.offset(optind___0 as isize)).offset(0 as libc::c_int as isize)
            as libc::c_int == 45 as libc::c_int)
        {
            break;
        }
        opt = (*argv.offset(optind___0 as isize)).offset(1 as libc::c_int as isize);
        tmp___3 = strstr(
            b"abxdpifmnolcug\0" as *const u8 as *const libc::c_char,
            opt as *const libc::c_char,
        );
        let mut current_block_32: u64;
        if !tmp___3.is_null() {
            if optind___0 < argc - 1 as libc::c_int {
                optarg___0 = *argv.offset((optind___0 + 1 as libc::c_int) as isize);
                optind___0 += 2 as libc::c_int;
                current_block_32 = 13619784596304402172;
            } else {
                current_block_32 = 1213444042845738554;
            }
        } else {
            current_block_32 = 1213444042845738554;
        }
        match current_block_32 {
            1213444042845738554 => {
                tmp___2 = strstr(
                    b"tzZIkr\0" as *const u8 as *const libc::c_char,
                    opt as *const libc::c_char,
                );
                if !tmp___2.is_null() {
                    optarg___0 = 0 as *mut libc::c_void as *mut libc::c_char;
                    optind___0 += 1;
                } else if *opt.offset(0 as libc::c_int as isize) as libc::c_int
                        == 45 as libc::c_int
                    {
                    optarg___0 = 0 as *mut libc::c_void as *mut libc::c_char;
                    optind___0 += 1;
                } else {
                    printf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        usage.as_mut_ptr(),
                    );
                    return 0 as libc::c_int != 0;
                }
            }
            _ => {}
        }
        match *opt.offset(0 as libc::c_int as isize) as libc::c_int {
            98 => {
                strcpy(glBinding.as_mut_ptr(), optarg___0 as *const libc::c_char);
            }
            97 => {
                sscanf(
                    optarg___0 as *const libc::c_char,
                    b"%hu:%hu\0" as *const u8 as *const libc::c_char,
                    &mut glPortBase as *mut libc::c_ushort,
                    &mut glPortRange as *mut libc::c_ushort,
                );
            }
            102 => {
                glLogFile = optarg___0;
            }
            99 => {
                strcpy(
                    (glMRConfig.Codec).as_mut_ptr(),
                    optarg___0 as *const libc::c_char,
                );
            }
            117 => {
                glMRConfig.UPnPMax = atoi(optarg___0 as *const libc::c_char);
            }
            105 => {
                strcpy(glConfigName.as_mut_ptr(), optarg___0 as *const libc::c_char);
                glDiscovery = 1 as libc::c_int != 0;
            }
            73 => {
                glAutoSaveConfigFile = 1 as libc::c_int != 0;
            }
            112 => {
                glPidFile = optarg___0;
            }
            90 => {
                glInteractive = 0 as libc::c_int != 0;
            }
            107 => {
                glGracefullShutdown = 0 as libc::c_int != 0;
            }
            114 => {
                glMRConfig.Drift = 1 as libc::c_int != 0;
            }
            109 => {
                glExcluded = optarg___0;
            }
            110 => {
                glExcludedModelNumber = optarg___0;
            }
            111 => {
                glIncludedModelNumbers = optarg___0;
            }
            108 => {
                strcpy(
                    (glMRConfig.Latency).as_mut_ptr(),
                    optarg___0 as *const libc::c_char,
                );
            }
            103 => {
                glMRConfig.HTTPLength = atoi(optarg___0 as *const libc::c_char);
            }
            122 => {
                glDaemonize = 1 as libc::c_int != 0;
            }
            100 => {
                tmp___4 = strtok(optarg___0, b"=\0" as *const u8 as *const libc::c_char);
                l = tmp___4;
                tmp___5 = strtok(
                    0 as *mut libc::c_void as *mut libc::c_char,
                    b"=\0" as *const u8 as *const libc::c_char,
                );
                v = tmp___5;
                new = lWARN;
                if !l.is_null() {
                    if !v.is_null() {
                        tmp___6 = strcmp(
                            v as *const libc::c_char,
                            b"error\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___6 == 0 {
                            new = lERROR;
                        }
                        tmp___7 = strcmp(
                            v as *const libc::c_char,
                            b"warn\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___7 == 0 {
                            new = lWARN;
                        }
                        tmp___8 = strcmp(
                            v as *const libc::c_char,
                            b"info\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___8 == 0 {
                            new = lINFO;
                        }
                        tmp___9 = strcmp(
                            v as *const libc::c_char,
                            b"debug\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___9 == 0 {
                            new = lDEBUG;
                        }
                        tmp___10 = strcmp(
                            v as *const libc::c_char,
                            b"sdebug\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___10 == 0 {
                            new = lSDEBUG;
                        }
                        tmp___11 = strcmp(
                            l as *const libc::c_char,
                            b"all\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___11 != 0 {
                            tmp___12 = strcmp(
                                l as *const libc::c_char,
                                b"raop\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___12 == 0 {
                                raop_loglevel = new;
                            }
                        } else {
                            raop_loglevel = new;
                        }
                        tmp___13 = strcmp(
                            l as *const libc::c_char,
                            b"all\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___13 != 0 {
                            tmp___14 = strcmp(
                                l as *const libc::c_char,
                                b"main\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___14 == 0 {
                                main_loglevel = new;
                            }
                        } else {
                            main_loglevel = new;
                        }
                        tmp___15 = strcmp(
                            l as *const libc::c_char,
                            b"all\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___15 != 0 {
                            tmp___16 = strcmp(
                                l as *const libc::c_char,
                                b"util\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___16 == 0 {
                                util_loglevel = new;
                            }
                        } else {
                            util_loglevel = new;
                        }
                        tmp___17 = strcmp(
                            l as *const libc::c_char,
                            b"all\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___17 != 0 {
                            tmp___18 = strcmp(
                                l as *const libc::c_char,
                                b"upnp\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___18 == 0 {
                                upnp_loglevel = new;
                            }
                        } else {
                            upnp_loglevel = new;
                        }
                    } else {
                        printf(
                            b"%s\0" as *const u8 as *const libc::c_char,
                            usage.as_mut_ptr(),
                        );
                        return 0 as libc::c_int != 0;
                    }
                } else {
                    printf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        usage.as_mut_ptr(),
                    );
                    return 0 as libc::c_int != 0;
                }
            }
            116 => {
                printf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    license.as_mut_ptr(),
                );
                return 0 as libc::c_int != 0;
            }
            45 => {
                tmp___19 = strcmp(
                    opt.offset(1 as libc::c_int as isize) as *const libc::c_char,
                    b"noflush\0" as *const u8 as *const libc::c_char,
                );
                if tmp___19 == 0 {
                    glMRConfig.Flush = 0 as libc::c_int != 0;
                }
            }
            _ => {}
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut resp: [libc::c_char; 20] = [0; 20];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: bool = false;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut FILE = 0 as *mut FILE;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: libc::c_double = 0.;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut pid_file: *mut FILE = 0 as *mut FILE;
    let mut tmp___14: __pid_t = 0;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: bool = false;
    let mut level: [libc::c_char; 20] = [0; 20];
    let mut tmp___18: libc::c_int = 0;
    let mut level___0: [libc::c_char; 20] = [0; 20];
    let mut tmp___19: libc::c_int = 0;
    let mut level___1: [libc::c_char; 20] = [0; 20];
    let mut tmp___20: libc::c_int = 0;
    let mut level___2: [libc::c_char; 20] = [0; 20];
    let mut tmp___21: libc::c_int = 0;
    let mut name: [libc::c_char; 128] = [0; 128];
    let mut tmp___22: libc::c_int = 0;
    let mut now: u32_t = 0;
    let mut tmp___23: u32_t = 0;
    let mut all: bool = false;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut Locked: bool = false;
    let mut tmp___26: libc::c_int = 0;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___31: *const libc::c_char = 0 as *const libc::c_char;
    resp[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 20 as libc::c_uint) {
        resp[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    signal(
        2 as libc::c_int,
        Some(sighandler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        15 as libc::c_int,
        Some(sighandler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        3 as libc::c_int,
        Some(sighandler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        1 as libc::c_int,
        Some(sighandler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        13 as libc::c_int,
        ::std::mem::transmute::<
            libc::intptr_t,
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        >(1 as libc::c_int as libc::intptr_t),
    );
    i = 1 as libc::c_int;
    while i < argc {
        tmp___0 = strcmp(
            *argv.offset(i as isize) as *const libc::c_char,
            b"-x\0" as *const u8 as *const libc::c_char,
        );
        if tmp___0 == 0 {
            strcpy(
                glConfigName.as_mut_ptr(),
                *argv.offset((i + 1 as libc::c_int) as isize) as *const libc::c_char,
            );
        }
        i += 1;
    }
    tmp___1 = LoadConfig(glConfigName.as_mut_ptr(), &mut glMRConfig);
    glConfigID = tmp___1;
    tmp___2 = ParseArgs(argc, argv);
    if !tmp___2 {
        exit(1 as libc::c_int);
    }
    if glPortBase != 0 {
        if glPortRange == 0 {
            glPortRange = (glMaxDevices * 4 as libc::c_int) as libc::c_ushort;
        }
    }
    if !glLogFile.is_null() {
        tmp___5 = freopen(
            glLogFile as *const libc::c_char,
            b"a\0" as *const u8 as *const libc::c_char,
            stderr,
        );
        if tmp___5.is_null() {
            tmp___3 = __errno_location();
            tmp___4 = strerror(*tmp___3);
            fprintf(
                stderr,
                b"error opening logfile %s: %s\n\0" as *const u8 as *const libc::c_char,
                glLogFile,
                tmp___4,
            );
        }
    }
    tmp___6 = logtime();
    logprint(
        b"%s %s:%d Starting airupnp version: %s\n\0" as *const u8 as *const libc::c_char,
        tmp___6,
        b"main\0" as *const u8 as *const libc::c_char,
        1420 as libc::c_int,
        b"v0.2.51.2 (Aug  3 2022 @ 17:23:46)\0" as *const u8 as *const libc::c_char,
    );
    tmp___8 = strtod(
        b"0.30\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
    );
    if tmp___8 != 0.30f64 {
        tmp___7 = logtime();
        logprint(
            b"%s %s:%d Wrong GLIBC version, use -static build\n\0" as *const u8
                as *const libc::c_char,
            tmp___7,
            b"main\0" as *const u8 as *const libc::c_char,
            1423 as libc::c_int,
            0 as *mut libc::c_void,
        );
        exit(1 as libc::c_int);
    }
    if glConfigID.is_null() {
        if *loglevel___0 as libc::c_uint >= 1 as libc::c_uint {
            tmp___9 = logtime();
            logprint(
                b"%s %s:%d no config file, using defaults\n\0" as *const u8
                    as *const libc::c_char,
                tmp___9,
                b"main\0" as *const u8 as *const libc::c_char,
                1428 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
    }
    if glDiscovery {
        Start(1 as libc::c_int != 0);
        sleep(21 as libc::c_uint);
        Stop(1 as libc::c_int != 0);
        return 0 as libc::c_int;
    }
    if glDaemonize {
        if !glLogFile.is_null() {
            tmp___12 = 1 as libc::c_int;
        } else {
            tmp___12 = 0 as libc::c_int;
        }
        tmp___13 = daemon(1 as libc::c_int, tmp___12);
        if tmp___13 != 0 {
            tmp___10 = __errno_location();
            tmp___11 = strerror(*tmp___10);
            fprintf(
                stderr,
                b"error daemonizing: %s\n\0" as *const u8 as *const libc::c_char,
                tmp___11,
            );
        }
    }
    if !glPidFile.is_null() {
        pid_file = fopen(
            glPidFile as *const libc::c_char,
            b"wb\0" as *const u8 as *const libc::c_char,
        );
        if !pid_file.is_null() {
            tmp___14 = getpid();
            fprintf(
                pid_file,
                b"%ld\0" as *const u8 as *const libc::c_char,
                tmp___14 as libc::c_long,
            );
            fclose(pid_file);
        } else {
            tmp___15 = logtime();
            logprint(
                b"%s %s:%d Cannot open PID file %s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___15,
                b"main\0" as *const u8 as *const libc::c_char,
                1455 as libc::c_int,
                glPidFile,
            );
        }
    }
    tmp___17 = Start(1 as libc::c_int != 0);
    if !tmp___17 {
        tmp___16 = logtime();
        logprint(
            b"%s %s:%d Cannot start\n\0" as *const u8 as *const libc::c_char,
            tmp___16,
            b"main\0" as *const u8 as *const libc::c_char,
            1461 as libc::c_int,
            0 as *mut libc::c_void,
        );
        exit(1 as libc::c_int);
    }
    loop {
        tmp___29 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"exit\0" as *const u8 as *const libc::c_char,
        );
        if tmp___29 == 0 {
            break;
        }
        if !glDaemonize {
            if glInteractive {
                i = scanf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    resp.as_mut_ptr(),
                );
            } else {
                pause();
            }
        } else {
            pause();
        }
        tmp___18 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"raopdbg\0" as *const u8 as *const libc::c_char,
        );
        if tmp___18 == 0 {
            i = scanf(b"%s\0" as *const u8 as *const libc::c_char, level.as_mut_ptr());
            raop_loglevel = debug2level(level.as_mut_ptr());
        }
        tmp___19 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"maindbg\0" as *const u8 as *const libc::c_char,
        );
        if tmp___19 == 0 {
            i = scanf(
                b"%s\0" as *const u8 as *const libc::c_char,
                level___0.as_mut_ptr(),
            );
            main_loglevel = debug2level(level___0.as_mut_ptr());
        }
        tmp___20 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"utildbg\0" as *const u8 as *const libc::c_char,
        );
        if tmp___20 == 0 {
            i = scanf(
                b"%s\0" as *const u8 as *const libc::c_char,
                level___1.as_mut_ptr(),
            );
            util_loglevel = debug2level(level___1.as_mut_ptr());
        }
        tmp___21 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"upnpdbg\0" as *const u8 as *const libc::c_char,
        );
        if tmp___21 == 0 {
            i = scanf(
                b"%s\0" as *const u8 as *const libc::c_char,
                level___2.as_mut_ptr(),
            );
            upnp_loglevel = debug2level(level___2.as_mut_ptr());
        }
        tmp___22 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"save\0" as *const u8 as *const libc::c_char,
        );
        if tmp___22 == 0 {
            i = scanf(b"%s\0" as *const u8 as *const libc::c_char, name.as_mut_ptr());
            SaveConfig(name.as_mut_ptr(), glConfigID, 1 as libc::c_int != 0);
        }
        tmp___27 = strcmp(
            resp.as_mut_ptr() as *const libc::c_char,
            b"dump\0" as *const u8 as *const libc::c_char,
        );
        let mut current_block_144: u64;
        if tmp___27 != 0 {
            tmp___28 = strcmp(
                resp.as_mut_ptr() as *const libc::c_char,
                b"dumpall\0" as *const u8 as *const libc::c_char,
            );
            if tmp___28 == 0 {
                current_block_144 = 13720795673165968460;
            } else {
                current_block_144 = 18201902862271706575;
            }
        } else {
            current_block_144 = 13720795673165968460;
        }
        match current_block_144 {
            13720795673165968460 => {
                tmp___23 = gettime_ms();
                now = tmp___23.wrapping_div(1000 as libc::c_uint);
                tmp___24 = strcmp(
                    resp.as_mut_ptr() as *const libc::c_char,
                    b"dumpall\0" as *const u8 as *const libc::c_char,
                );
                if tmp___24 != 0 {
                    tmp___25 = 0 as libc::c_int;
                } else {
                    tmp___25 = 1 as libc::c_int;
                }
                all = tmp___25 != 0;
                i = 0 as libc::c_int;
                while i < glMaxDevices {
                    let mut current_block_142: u64;
                    p = glMRDevices.offset(i as isize);
                    tmp___26 = pthread_mutex_trylock(&mut (*p).Mutex);
                    Locked = tmp___26 != 0;
                    if !Locked {
                        pthread_mutex_unlock(&mut (*p).Mutex);
                    }
                    if !(*p).Running {
                        if !all {
                            current_block_142 = 2920954537910346520;
                        } else {
                            current_block_142 = 7337917895049117968;
                        }
                    } else {
                        current_block_142 = 7337917895049117968;
                    }
                    match current_block_142 {
                        7337917895049117968 => {
                            printf(
                                b"%20.20s [r:%u] [l:%u] [s:%u] Last:%u eCnt:%u\n\0"
                                    as *const u8 as *const libc::c_char,
                                ((*p).Config.Name).as_mut_ptr(),
                                (*p).Running as libc::c_int,
                                Locked as libc::c_int,
                                (*p).State as libc::c_uint,
                                now.wrapping_sub((*p).LastSeen),
                                (*p).ErrorCount as libc::c_int,
                            );
                        }
                        _ => {}
                    }
                    i += 1;
                }
            }
            _ => {}
        }
    }
    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
        tmp___30 = logtime();
        logprint(
            b"%s %s:%d stopping devices ...\n\0" as *const u8 as *const libc::c_char,
            tmp___30,
            b"main\0" as *const u8 as *const libc::c_char,
            1532 as libc::c_int,
            0 as *mut libc::c_void,
        );
    }
    Stop(1 as libc::c_int != 0);
    if *loglevel___0 as libc::c_uint >= 2 as libc::c_uint {
        tmp___31 = logtime();
        logprint(
            b"%s %s:%d all done\n\0" as *const u8 as *const libc::c_char,
            tmp___31,
            b"main\0" as *const u8 as *const libc::c_char,
            1534 as libc::c_int,
            0 as *mut libc::c_void,
        );
    }
    return 1 as libc::c_int;
}
static mut loglevel___1: *mut log_level = unsafe {
    &util_loglevel as *const log_level as *mut log_level
};
pub unsafe extern "C" fn _voidHandler(
    mut EventType: Upnp_EventType,
    mut _Event: *mut libc::c_void,
    mut Cookie: *mut libc::c_void,
) -> libc::c_int {
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn CalcGroupVolume(mut Device: *mut sMR) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut GroupVolume: libc::c_double = 0.;
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut tmp: libc::c_int = 0;
    n = 0 as libc::c_int;
    GroupVolume = 0 as libc::c_int as libc::c_double;
    if (*Device).Service[4 as libc::c_int as usize].ControlURL[0 as libc::c_int as usize]
        == 0
    {
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        p = glMRDevices.offset(i as isize);
        if (*p).Running {
            let mut current_block_12: u64;
            if p as libc::c_ulong == Device as libc::c_ulong {
                current_block_12 = 10419963650164969427;
            } else if (*p).Master as libc::c_ulong == Device as libc::c_ulong {
                current_block_12 = 10419963650164969427;
            } else {
                current_block_12 = 7976072742316086414;
            }
            match current_block_12 {
                10419963650164969427 => {
                    if (*p).Volume == -(1 as libc::c_int) as libc::c_double {
                        tmp = CtrlGetVolume(p);
                        (*p).Volume = tmp as libc::c_double;
                    }
                    GroupVolume += (*p).Volume;
                    n += 1;
                }
                _ => {}
            }
        }
        i += 1;
    }
    return (GroupVolume / n as libc::c_double) as libc::c_int;
}
pub unsafe extern "C" fn GetMaster(
    mut Device: *mut sMR,
    mut Name: *mut *mut libc::c_char,
) -> *mut sMR {
    let mut ActionNode: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Response: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut Body: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut Master: *mut sMR = 0 as *mut sMR;
    let mut Service: *mut sService = 0 as *mut sService;
    let mut done: bool = false;
    let mut myUUID: [libc::c_char; 250] = [0; 250];
    let mut tmp: libc::c_uint = 0;
    let mut GroupList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut tmp___0: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut i: libc::c_int = 0;
    let mut Group: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___1: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut Coordinator: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut MemberList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut tmp___3: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut j: libc::c_int = 0;
    let mut Member: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___4: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut UUID: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut k: libc::c_int = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: libc::c_ulong = 0;
    let mut tmp___12: libc::c_ulong = 0;
    let mut tmp___13: *const libc::c_char = 0 as *const libc::c_char;
    ActionNode = 0 as *mut libc::c_void as *mut IXML_Document;
    Master = 0 as *mut libc::c_void as *mut sMR;
    Service = &mut *((*Device).Service).as_mut_ptr().offset(3 as libc::c_int as isize)
        as *mut sService;
    done = 0 as libc::c_int != 0;
    if (*Service).ControlURL[0 as libc::c_int as usize] == 0 {
        return 0 as *mut libc::c_void as *mut sMR;
    }
    ActionNode = UpnpMakeAction(
        b"GetZoneGroupState\0" as *const u8 as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
        0 as *mut libc::c_void as *const libc::c_char,
    );
    UpnpSendAction(
        glControlPointHandle,
        ((*Service).ControlURL).as_mut_ptr() as *const libc::c_char,
        ((*Service).Type).as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        ActionNode,
        &mut Response,
    );
    if !ActionNode.is_null() {
        ixmlDocument_free(ActionNode);
    }
    Body = XMLGetFirstDocumentItem(
        Response,
        b"ZoneGroupState\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    if !Response.is_null() {
        ixmlDocument_free(Response);
    }
    Response = ixmlParseBuffer(Body as *const libc::c_char);
    if !Body.is_null() {
        free(Body as *mut libc::c_void);
        Body = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !Response.is_null() {
        myUUID[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 250 as libc::c_uint) {
            myUUID[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = ixmlDocument_getElementsByTagName(
            Response,
            b"ZoneGroup\0" as *const u8 as *const libc::c_char,
        );
        GroupList = tmp___0;
        sscanf(
            ((*Device).UDN).as_mut_ptr() as *const libc::c_char,
            b"uuid:%s\0" as *const u8 as *const libc::c_char,
            myUUID.as_mut_ptr(),
        );
        i = 0 as libc::c_int;
        while !done {
            if GroupList.is_null() {
                break;
            }
            tmp___12 = ixmlNodeList_length(GroupList);
            if !(i < tmp___12 as libc::c_int) {
                break;
            }
            tmp___1 = ixmlNodeList_item(GroupList, i as libc::c_ulong);
            Group = tmp___1;
            tmp___2 = ixmlElement_getAttribute(
                Group as *mut IXML_Element,
                b"Coordinator\0" as *const u8 as *const libc::c_char,
            );
            Coordinator = tmp___2;
            tmp___3 = ixmlDocument_getElementsByTagName(
                Group as *mut IXML_Document,
                b"ZoneGroupMember\0" as *const u8 as *const libc::c_char,
            );
            MemberList = tmp___3;
            j = 0 as libc::c_int;
            while !done {
                tmp___11 = ixmlNodeList_length(MemberList);
                if !(j < tmp___11 as libc::c_int) {
                    break;
                }
                tmp___4 = ixmlNodeList_item(MemberList, j as libc::c_ulong);
                Member = tmp___4;
                tmp___5 = ixmlElement_getAttribute(
                    Member as *mut IXML_Element,
                    b"UUID\0" as *const u8 as *const libc::c_char,
                );
                UUID = tmp___5;
                tmp___8 = strcasecmp(myUUID.as_mut_ptr() as *const libc::c_char, UUID);
                if tmp___8 == 0 {
                    if !(*Name).is_null() {
                        free(*Name as *mut libc::c_void);
                        *Name = 0 as *mut libc::c_void as *mut libc::c_char;
                    }
                    tmp___6 = ixmlElement_getAttribute(
                        Member as *mut IXML_Element,
                        b"ZoneName\0" as *const u8 as *const libc::c_char,
                    );
                    *Name = strdup(tmp___6);
                    tmp___7 = strcasecmp(
                        myUUID.as_mut_ptr() as *const libc::c_char,
                        Coordinator,
                    );
                    if tmp___7 == 0 {
                        done = 1 as libc::c_int != 0;
                    }
                }
                k = 0 as libc::c_int;
                while !done {
                    if !(k < glMaxDevices) {
                        break;
                    }
                    if (*glMRDevices.offset(k as isize)).Running {
                        tmp___10 = strcasestr(
                            ((*glMRDevices.offset(k as isize)).UDN).as_mut_ptr()
                                as *const libc::c_char,
                            Coordinator as *mut libc::c_char as *const libc::c_char,
                        );
                        if !tmp___10.is_null() {
                            Master = glMRDevices.offset(k as isize);
                            if *loglevel___1 as libc::c_uint >= 3 as libc::c_uint {
                                tmp___9 = logtime();
                                logprint(
                                    b"%s %s:%d Found Master %s %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    tmp___9,
                                    b"GetMaster\0" as *const u8 as *const libc::c_char,
                                    115 as libc::c_int,
                                    myUUID.as_mut_ptr(),
                                    ((*Master).UDN).as_mut_ptr(),
                                );
                            }
                            done = 1 as libc::c_int != 0;
                        }
                    }
                    k += 1;
                }
                j += 1;
            }
            ixmlNodeList_free(MemberList);
            i += 1;
        }
        if !done {
            Master = Device;
            if *loglevel___1 as libc::c_uint >= 2 as libc::c_uint {
                tmp___13 = logtime();
                logprint(
                    b"%s %s:%d [%p]: Master not discovered yet, assigning to self\n\0"
                        as *const u8 as *const libc::c_char,
                    tmp___13,
                    b"GetMaster\0" as *const u8 as *const libc::c_char,
                    127 as libc::c_int,
                    Device,
                );
            }
        }
        ixmlNodeList_free(GroupList);
        ixmlDocument_free(Response);
    }
    return Master;
}
pub unsafe extern "C" fn FlushMRDevices() {
    let mut i: libc::c_int = 0;
    let mut p: *mut sMR = 0 as *mut sMR;
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        p = glMRDevices.offset(i as isize);
        pthread_mutex_lock(&mut (*p).Mutex);
        if (*p).Running {
            if (*p).RaopState as libc::c_uint == 1 as libc::c_uint {
                AVTStop(p);
            }
            raop_delete((*p).Raop);
            DelMRDevice(p);
        } else {
            pthread_mutex_unlock(&mut (*p).Mutex);
        }
        i += 1;
    }
}
pub unsafe extern "C" fn DelMRDevice(mut p: *mut sMR) {
    let mut i: libc::c_int = 0;
    pthread_mutex_trylock(&mut (*p).Mutex);
    i = 0 as libc::c_int;
    while i < 5 as libc::c_int {
        if (*p).Service[i as usize].TimeOut != 0 {
            UpnpUnSubscribeAsync(
                glControlPointHandle,
                ((*p).Service[i as usize].SID).as_mut_ptr(),
                Some(
                    _voidHandler
                        as unsafe extern "C" fn(
                            Upnp_EventType,
                            *mut libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                0 as *mut libc::c_void as *const libc::c_void,
            );
        }
        i += 1;
    }
    (*p).Running = 0 as libc::c_int != 0;
    WakeAll();
    pthread_mutex_unlock(&mut (*p).Mutex);
    pthread_join((*p).Thread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
    AVTActionFlush(&mut (*p).ActionQueue);
    free_metadata(&mut (*p).MetaData);
}
pub unsafe extern "C" fn CURL2Device(mut CtrlURL: *mut libc::c_char) -> *mut sMR {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        if (*glMRDevices.offset(i as isize)).Running {
            j = 0 as libc::c_int;
            while j < 5 as libc::c_int {
                tmp = strcmp(
                    ((*glMRDevices.offset(i as isize)).Service[j as usize].ControlURL)
                        .as_mut_ptr() as *const libc::c_char,
                    CtrlURL as *const libc::c_char,
                );
                if tmp == 0 {
                    return glMRDevices.offset(i as isize);
                }
                j += 1;
            }
        }
        i += 1;
    }
    return 0 as *mut libc::c_void as *mut sMR;
}
pub unsafe extern "C" fn SID2Device(mut SID: *mut libc::c_char) -> *mut sMR {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        if (*glMRDevices.offset(i as isize)).Running {
            j = 0 as libc::c_int;
            while j < 5 as libc::c_int {
                tmp = strcmp(
                    ((*glMRDevices.offset(i as isize)).Service[j as usize].SID)
                        .as_mut_ptr() as *const libc::c_char,
                    SID as *const libc::c_char,
                );
                if tmp == 0 {
                    return glMRDevices.offset(i as isize);
                }
                j += 1;
            }
        }
        i += 1;
    }
    return 0 as *mut libc::c_void as *mut sMR;
}
pub unsafe extern "C" fn EventURL2Service(
    mut URL: *mut libc::c_char,
    mut s: *mut sService,
) -> *mut sService {
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 5 as libc::c_int {
        tmp = strcmp(
            ((*s).EventURL).as_mut_ptr() as *const libc::c_char,
            URL as *const libc::c_char,
        );
        if tmp != 0 {
            s = s.offset(1);
            i += 1;
        } else {
            return s
        }
    }
    return 0 as *mut libc::c_void as *mut sService;
}
pub unsafe extern "C" fn UDN2Device(mut UDN: *mut libc::c_char) -> *mut sMR {
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        if (*glMRDevices.offset(i as isize)).Running {
            tmp = strcmp(
                ((*glMRDevices.offset(i as isize)).UDN).as_mut_ptr()
                    as *const libc::c_char,
                UDN as *const libc::c_char,
            );
            if tmp == 0 {
                return glMRDevices.offset(i as isize);
            }
        }
        i += 1;
    }
    return 0 as *mut libc::c_void as *mut sMR;
}
pub unsafe extern "C" fn CheckAndLock(mut Device: *mut sMR) -> bool {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    if Device.is_null() {
        if *loglevel___1 as libc::c_uint >= 2 as libc::c_uint {
            tmp = logtime();
            logprint(
                b"%s %s:%d device is NULL\n\0" as *const u8 as *const libc::c_char,
                tmp,
                b"CheckAndLock\0" as *const u8 as *const libc::c_char,
                259 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        return 0 as libc::c_int != 0;
    }
    pthread_mutex_lock(&mut (*Device).Mutex);
    if (*Device).Running {
        return 1 as libc::c_int != 0;
    }
    if *loglevel___1 as libc::c_uint >= 2 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: device has been removed\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"CheckAndLock\0" as *const u8 as *const libc::c_char,
            267 as libc::c_int,
            Device,
        );
    }
    pthread_mutex_unlock(&mut (*Device).Mutex);
    return 0 as libc::c_int != 0;
}
pub unsafe extern "C" fn MakeMacUnique(mut Device: *mut sMR) {
    let mut i: libc::c_int = 0;
    let mut hash: u32_t = 0;
    let mut tmp: u32_t = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        if (*glMRDevices.offset(i as isize)).Running {
            if !(Device as libc::c_ulong
                == glMRDevices.offset(i as isize) as libc::c_ulong)
            {
                tmp___1 = memcmp(
                    &mut (*glMRDevices.offset(i as isize)).Config.mac as *mut [u8_t; 6]
                        as *const libc::c_void,
                    &mut (*Device).Config.mac as *mut [u8_t; 6] as *const libc::c_void,
                    6 as libc::c_int as size_t,
                );
                if tmp___1 == 0 {
                    tmp = hash32(((*Device).UDN).as_mut_ptr());
                    hash = tmp;
                    if *loglevel___1 as libc::c_uint >= 2 as libc::c_uint {
                        tmp___0 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: duplicated mac ... updating\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___0,
                            b"MakeMacUnique\0" as *const u8 as *const libc::c_char,
                            285 as libc::c_int,
                            Device,
                        );
                    }
                    memset(
                        &mut *((*Device).Config.mac)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize) as *mut u8_t
                            as *mut libc::c_void,
                        204 as libc::c_int,
                        2 as libc::c_int as size_t,
                    );
                    memcpy(
                        (&mut *((*Device).Config.mac)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize) as *mut u8_t)
                            .offset(2 as libc::c_int as isize) as *mut libc::c_void,
                        &mut hash as *mut u32_t as *const libc::c_void,
                        4 as libc::c_int as size_t,
                    );
                }
            }
        }
        i += 1;
    }
}
pub unsafe extern "C" fn ExtractIP(mut URL: *const libc::c_char) -> in_addr_t {
    let mut p1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ip: [libc::c_char; 32] = [0; 32];
    let mut tmp: in_addr_t = 0;
    sscanf(URL, b"http://%31s\0" as *const u8 as *const libc::c_char, ip.as_mut_ptr());
    ip[31 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    p1 = strchr(ip.as_mut_ptr() as *const libc::c_char, ':' as i32);
    if !p1.is_null() {
        *p1 = '\u{0}' as i32 as libc::c_char;
    }
    tmp = inet_addr(ip.as_mut_ptr() as *const libc::c_char);
    return tmp;
}
unsafe extern "C" fn XMLGetNthServiceList(
    mut doc: *mut IXML_Document,
    mut n: libc::c_uint,
    mut contd: *mut bool,
) -> *mut IXML_NodeList {
    let mut ServiceList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut servlistnodelist: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut servlistnode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_ulong = 0;
    let mut tmp___2: libc::c_ulong = 0;
    ServiceList = 0 as *mut libc::c_void as *mut IXML_NodeList;
    servlistnodelist = 0 as *mut libc::c_void as *mut IXML_NodeList;
    servlistnode = 0 as *mut libc::c_void as *mut IXML_Node;
    *contd = 0 as libc::c_int != 0;
    if *loglevel___1 as libc::c_uint >= 4 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d GetNthServiceList called : n = %d\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"XMLGetNthServiceList\0" as *const u8 as *const libc::c_char,
            328 as libc::c_int,
            n,
        );
    }
    servlistnodelist = ixmlDocument_getElementsByTagName(
        doc,
        b"serviceList\0" as *const u8 as *const libc::c_char,
    );
    if !servlistnodelist.is_null() {
        tmp___1 = ixmlNodeList_length(servlistnodelist);
        if tmp___1 != 0 {
            tmp___2 = ixmlNodeList_length(servlistnodelist);
            if (n as libc::c_ulong) < tmp___2 {
                servlistnode = ixmlNodeList_item(servlistnodelist, n as libc::c_ulong);
                if !servlistnode.is_null() {
                    ServiceList = ixmlElement_getElementsByTagName(
                        servlistnode as *mut IXML_Element,
                        b"service\0" as *const u8 as *const libc::c_char,
                    );
                    *contd = 1 as libc::c_int != 0;
                } else if *loglevel___1 as libc::c_uint >= 1 as libc::c_uint {
                    tmp___0 = logtime();
                    logprint(
                        b"%s %s:%d ixmlNodeList_item(nodeList, n) returned NULL\n\0"
                            as *const u8 as *const libc::c_char,
                        tmp___0,
                        b"XMLGetNthServiceList\0" as *const u8 as *const libc::c_char,
                        345 as libc::c_int,
                        0 as *mut libc::c_void,
                    );
                }
            }
        }
    }
    if !servlistnodelist.is_null() {
        ixmlNodeList_free(servlistnodelist);
    }
    return ServiceList;
}
pub unsafe extern "C" fn XMLFindAndParseService(
    mut DescDoc: *mut IXML_Document,
    mut location: *const libc::c_char,
    mut serviceTypeBase: *const libc::c_char,
    mut serviceType: *mut *mut libc::c_char,
    mut serviceId: *mut *mut libc::c_char,
    mut eventURL: *mut *mut libc::c_char,
    mut controlURL: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_uint = 0;
    let mut length: libc::c_ulong = 0;
    let mut found: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut sindex: libc::c_uint = 0;
    let mut tempServiceType: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut baseURL: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut base: *const libc::c_char = 0 as *const libc::c_char;
    let mut relcontrolURL: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut releventURL: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut serviceList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut service: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut contd: bool = false;
    let mut tmp: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: libc::c_int = 0;
    found = 0 as libc::c_int;
    sindex = 0 as libc::c_uint;
    tempServiceType = 0 as *mut libc::c_void as *mut libc::c_char;
    baseURL = 0 as *mut libc::c_void as *mut libc::c_char;
    base = 0 as *mut libc::c_void as *const libc::c_char;
    relcontrolURL = 0 as *mut libc::c_void as *mut libc::c_char;
    releventURL = 0 as *mut libc::c_void as *mut libc::c_char;
    serviceList = 0 as *mut libc::c_void as *mut IXML_NodeList;
    service = 0 as *mut libc::c_void as *mut IXML_Element;
    contd = 1 as libc::c_int != 0;
    baseURL = XMLGetFirstDocumentItem(
        DescDoc,
        b"URLBase\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    if !baseURL.is_null() {
        base = baseURL as *const libc::c_char;
    } else {
        base = location;
    }
    sindex = 0 as libc::c_uint;
    while contd {
        tempServiceType = 0 as *mut libc::c_void as *mut libc::c_char;
        relcontrolURL = 0 as *mut libc::c_void as *mut libc::c_char;
        releventURL = 0 as *mut libc::c_void as *mut libc::c_char;
        service = 0 as *mut libc::c_void as *mut IXML_Element;
        serviceList = XMLGetNthServiceList(DescDoc, sindex, &mut contd);
        if !(serviceList as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            length = ixmlNodeList_length(serviceList);
            i = 0 as libc::c_uint;
            while (i as libc::c_ulong) < length {
                tmp = ixmlNodeList_item(serviceList, i as libc::c_ulong);
                service = tmp as *mut IXML_Element;
                tempServiceType = XMLGetFirstElementItem(
                    service,
                    b"serviceType\0" as *const u8 as *const libc::c_char,
                );
                if *loglevel___1 as libc::c_uint >= 4 as libc::c_uint {
                    tmp___0 = logtime();
                    logprint(
                        b"%s %s:%d serviceType %s\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___0,
                        b"XMLFindAndParseService\0" as *const u8 as *const libc::c_char,
                        386 as libc::c_int,
                        tempServiceType,
                    );
                }
                tmp___1 = strrchr(tempServiceType as *const libc::c_char, ':' as i32);
                *tmp___1 = '\u{0}' as i32 as libc::c_char;
                if !tempServiceType.is_null() {
                    tmp___11 = strcmp(
                        tempServiceType as *const libc::c_char,
                        serviceTypeBase,
                    );
                    if tmp___11 == 0 as libc::c_int {
                        if !(*serviceType).is_null() {
                            free(*serviceType as *mut libc::c_void);
                            *serviceType = 0 as *mut libc::c_void as *mut libc::c_char;
                        }
                        *serviceType = XMLGetFirstElementItem(
                            service,
                            b"serviceType\0" as *const u8 as *const libc::c_char,
                        );
                        if !(*serviceId).is_null() {
                            free(*serviceId as *mut libc::c_void);
                            *serviceId = 0 as *mut libc::c_void as *mut libc::c_char;
                        }
                        *serviceId = XMLGetFirstElementItem(
                            service,
                            b"serviceId\0" as *const u8 as *const libc::c_char,
                        );
                        if *loglevel___1 as libc::c_uint >= 4 as libc::c_uint {
                            tmp___2 = logtime();
                            logprint(
                                b"%s %s:%d Service %s, serviceId: %s\n\0" as *const u8
                                    as *const libc::c_char,
                                tmp___2,
                                b"XMLFindAndParseService\0" as *const u8
                                    as *const libc::c_char,
                                395 as libc::c_int,
                                serviceType,
                                *serviceId,
                            );
                        }
                        relcontrolURL = XMLGetFirstElementItem(
                            service,
                            b"controlURL\0" as *const u8 as *const libc::c_char,
                        );
                        releventURL = XMLGetFirstElementItem(
                            service,
                            b"eventSubURL\0" as *const u8 as *const libc::c_char,
                        );
                        if !(*controlURL).is_null() {
                            free(*controlURL as *mut libc::c_void);
                            *controlURL = 0 as *mut libc::c_void as *mut libc::c_char;
                        }
                        tmp___3 = strlen(base);
                        tmp___4 = strlen(relcontrolURL as *const libc::c_char);
                        tmp___5 = malloc(
                            tmp___3
                                .wrapping_add(tmp___4)
                                .wrapping_add(1 as libc::c_ulong),
                        );
                        *controlURL = tmp___5 as *mut libc::c_char;
                        if !(*controlURL).is_null() {
                            ret = UpnpResolveURL(
                                base,
                                relcontrolURL as *const libc::c_char,
                                *controlURL,
                            );
                            if ret != 0 as libc::c_int {
                                tmp___6 = logtime();
                                logprint(
                                    b"%s %s:%d Error generating controlURL from %s + %s\n\0"
                                        as *const u8 as *const libc::c_char,
                                    tmp___6,
                                    b"XMLFindAndParseService\0" as *const u8
                                        as *const libc::c_char,
                                    402 as libc::c_int,
                                    base,
                                    relcontrolURL,
                                );
                            }
                        }
                        if !(*eventURL).is_null() {
                            free(*eventURL as *mut libc::c_void);
                            *eventURL = 0 as *mut libc::c_void as *mut libc::c_char;
                        }
                        tmp___7 = strlen(base);
                        tmp___8 = strlen(releventURL as *const libc::c_char);
                        tmp___9 = malloc(
                            tmp___7
                                .wrapping_add(tmp___8)
                                .wrapping_add(1 as libc::c_ulong),
                        );
                        *eventURL = tmp___9 as *mut libc::c_char;
                        if !(*eventURL).is_null() {
                            ret = UpnpResolveURL(
                                base,
                                releventURL as *const libc::c_char,
                                *eventURL,
                            );
                            if ret != 0 as libc::c_int {
                                tmp___10 = logtime();
                                logprint(
                                    b"%s %s:%d Error generating eventURL from %s + %s\n\0"
                                        as *const u8 as *const libc::c_char,
                                    tmp___10,
                                    b"XMLFindAndParseService\0" as *const u8
                                        as *const libc::c_char,
                                    408 as libc::c_int,
                                    base,
                                    releventURL,
                                );
                            }
                        }
                        free(relcontrolURL as *mut libc::c_void);
                        free(releventURL as *mut libc::c_void);
                        relcontrolURL = 0 as *mut libc::c_void as *mut libc::c_char;
                        releventURL = 0 as *mut libc::c_void as *mut libc::c_char;
                        found = 1 as libc::c_int;
                        break;
                    }
                }
                free(tempServiceType as *mut libc::c_void);
                tempServiceType = 0 as *mut libc::c_void as *mut libc::c_char;
                i = i.wrapping_add(1);
            }
            free(tempServiceType as *mut libc::c_void);
            tempServiceType = 0 as *mut libc::c_void as *mut libc::c_char;
            if !serviceList.is_null() {
                ixmlNodeList_free(serviceList);
            }
            serviceList = 0 as *mut libc::c_void as *mut IXML_NodeList;
        }
        sindex = sindex.wrapping_add(1);
    }
    free(baseURL as *mut libc::c_void);
    return found;
}
pub unsafe extern "C" fn XMLGetChangeItem(
    mut doc: *mut IXML_Document,
    mut Tag: *mut libc::c_char,
    mut SearchAttr: *mut libc::c_char,
    mut SearchVal: *mut libc::c_char,
    mut RetAttr: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut current_block: u64;
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut ItemDoc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut LastChange: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut List: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut buf___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: u32_t = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut node___0: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___0: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut attr: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___1: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_ulong = 0;
    ret = 0 as *mut libc::c_void as *mut libc::c_char;
    LastChange = ixmlDocument_getElementById(
        doc,
        b"LastChange\0" as *const u8 as *const libc::c_char,
    );
    if LastChange.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    node = ixmlNode_getFirstChild(LastChange as *mut IXML_Node);
    if node.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmp = ixmlNode_getNodeValue(node);
    buf___0 = tmp as *mut libc::c_char;
    if buf___0.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    ItemDoc = ixmlParseBuffer(buf___0 as *const libc::c_char);
    if ItemDoc.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    List = ixmlDocument_getElementsByTagName(ItemDoc, Tag as *const libc::c_char);
    if List.is_null() {
        ixmlDocument_free(ItemDoc);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    i = 0 as libc::c_int as u32_t;
    loop {
        tmp___7 = ixmlNodeList_length(List);
        if !((i as libc::c_ulong) < tmp___7) {
            break;
        }
        tmp___0 = ixmlNodeList_item(List, i as libc::c_ulong);
        node___0 = tmp___0;
        tmp___1 = _getAttributeNode(node___0, SearchAttr);
        attr = tmp___1;
        if !attr.is_null() {
            tmp___5 = ixmlNode_getNodeValue(attr);
            tmp___6 = strcasecmp(tmp___5, SearchVal as *const libc::c_char);
            if tmp___6 == 0 {
                node___0 = ixmlNode_getNextSibling(attr);
                if node___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    node___0 = ixmlNode_getPreviousSibling(attr);
                    if node___0 as libc::c_ulong
                        == 0 as *mut libc::c_void as libc::c_ulong
                    {
                        current_block = 16480064412683800761;
                    } else {
                        current_block = 7333393191927787629;
                    }
                } else {
                    current_block = 7333393191927787629;
                }
                match current_block {
                    16480064412683800761 => {}
                    _ => {
                        tmp___3 = ixmlNode_getNodeName(node___0);
                        tmp___4 = strcasecmp(
                            tmp___3,
                            b"val\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___4 == 0 {
                            tmp___2 = ixmlNode_getNodeValue(node___0);
                            ret = strdup(tmp___2);
                            break;
                        }
                    }
                }
            }
        }
        i = i.wrapping_add(1);
    }
    ixmlNodeList_free(List);
    ixmlDocument_free(ItemDoc);
    return ret;
}
unsafe extern "C" fn _getAttributeNode(
    mut node: *mut IXML_Node,
    mut SearchAttr: *mut libc::c_char,
) -> *mut IXML_Node {
    let mut ret: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut map: *mut IXML_NamedNodeMap = 0 as *mut IXML_NamedNodeMap;
    let mut tmp: *mut IXML_NamedNodeMap = 0 as *mut IXML_NamedNodeMap;
    let mut i: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_ulong = 0;
    tmp = ixmlNode_getAttributes(node);
    map = tmp;
    i = 0 as libc::c_int;
    loop {
        tmp___2 = ixmlNamedNodeMap_getLength(map);
        if !((i as libc::c_ulong) < tmp___2) {
            break;
        }
        ret = ixmlNamedNodeMap_item(map, i as libc::c_ulong);
        tmp___0 = ixmlNode_getNodeName(ret);
        tmp___1 = strcasecmp(tmp___0, SearchAttr as *const libc::c_char);
        if !(tmp___1 != 0) {
            break;
        }
        ret = 0 as *mut libc::c_void as *mut IXML_Node;
        i += 1;
    }
    ixmlNamedNodeMap_free(map);
    return ret;
}
pub unsafe extern "C" fn uPNPEvent2String(mut S: Upnp_EventType) -> *mut libc::c_char {
    match S as libc::c_uint {
        4 => {
            return b"UPNP_DISCOVERY_ADVERTISEMENT_ALIVE\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        5 => {
            return b"UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        6 => {
            return b"UPNP_DISCOVERY_SEARCH_RESULT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        7 => {
            return b"UPNP_DISCOVERY_SEARCH_TIMEOUT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        0 => {
            return b"UPNP_CONTROL_ACTION_REQUEST\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        1 => {
            return b"UPNP_CONTROL_ACTION_COMPLETE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        2 => {
            return b"UPNP_CONTROL_GET_VAR_REQUEST\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        3 => {
            return b"UPNP_CONTROL_GET_VAR_COMPLETE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        8 => {
            return b"UPNP_EVENT_SUBSCRIPTION_REQUEST\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        9 => {
            return b"UPNP_EVENT_RECEIVED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        10 => {
            return b"UPNP_EVENT_RENEWAL_COMPLETE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        11 => {
            return b"UPNP_EVENT_SUBSCRIBE_COMPLETE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        12 => {
            return b"UPNP_EVENT_UNSUBSCRIBE_COMPLETE\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        13 => {
            return b"UPNP_EVENT_AUTORENEWAL_FAILED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        14 => {
            return b"UPNP_EVENT_SUBSCRIPTION_EXPIRED\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        _ => {}
    }
    return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
}
pub unsafe extern "C" fn SaveConfig(
    mut name: *mut libc::c_char,
    mut ref_0: *mut libc::c_void,
    mut full: bool,
) {
    let mut p: *mut sMR = 0 as *mut sMR;
    let mut doc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut tmp: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut old_doc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut root: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut common: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut proto: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut list: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut old_root: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut file: *mut FILE = 0 as *mut FILE;
    let mut i: libc::c_int = 0;
    let mut device: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___0: libc::c_ulong = 0;
    let mut tmp___1: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut tmp___2: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut tmp___3: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___4: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dev_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut udn: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut device___0: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___10: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: libc::c_ulong = 0;
    let mut tmp___14: size_t = 0;
    tmp = ixmlDocument_createDocument();
    doc = tmp;
    old_doc = ref_0 as *mut IXML_Document;
    old_root = ixmlDocument_getElementById(
        old_doc,
        b"airupnp\0" as *const u8 as *const libc::c_char,
    );
    if !full {
        if !old_doc.is_null() {
            ixmlDocument_importNode(
                doc,
                old_root as *mut IXML_Node,
                1 as libc::c_int,
                &mut root,
            );
            ixmlNode_appendChild(doc as *mut IXML_Node, root);
            list = ixmlDocument_getElementsByTagName(
                root as *mut IXML_Document,
                b"device\0" as *const u8 as *const libc::c_char,
            );
            i = 0 as libc::c_int;
            loop {
                tmp___0 = ixmlNodeList_length(list);
                if !(i < tmp___0 as libc::c_int) {
                    break;
                }
                device = ixmlNodeList_item(list, i as libc::c_ulong);
                ixmlNode_removeChild(root, device, &mut device);
                ixmlNode_free(device);
                i += 1;
            }
            if !list.is_null() {
                ixmlNodeList_free(list);
            }
            tmp___1 = ixmlDocument_getElementById(
                root as *mut IXML_Document,
                b"common\0" as *const u8 as *const libc::c_char,
            );
            common = tmp___1 as *mut IXML_Node;
            tmp___2 = ixmlDocument_getElementById(
                common as *mut IXML_Document,
                b"protocolInfo\0" as *const u8 as *const libc::c_char,
            );
            proto = tmp___2 as *mut IXML_Node;
        } else {
            root = XMLAddNode(
                doc,
                0 as *mut libc::c_void as *mut IXML_Node,
                b"airupnp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                0 as *mut libc::c_void as *mut libc::c_char,
            );
            tmp___3 = XMLAddNode(
                doc,
                root,
                b"common\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                0 as *mut libc::c_void as *mut libc::c_char,
            );
            common = tmp___3;
            tmp___4 = XMLAddNode(
                doc,
                common,
                b"protocolInfo\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                0 as *mut libc::c_void as *mut libc::c_char,
            );
            proto = tmp___4;
        }
    } else {
        root = XMLAddNode(
            doc,
            0 as *mut libc::c_void as *mut IXML_Node,
            b"airupnp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            0 as *mut libc::c_void as *mut libc::c_char,
        );
        tmp___3 = XMLAddNode(
            doc,
            root,
            b"common\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            0 as *mut libc::c_void as *mut libc::c_char,
        );
        common = tmp___3;
        tmp___4 = XMLAddNode(
            doc,
            common,
            b"protocolInfo\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            0 as *mut libc::c_void as *mut libc::c_char,
        );
        proto = tmp___4;
    }
    tmp___5 = level2debug(main_loglevel);
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"main_log\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___5,
    );
    tmp___6 = level2debug(upnp_loglevel);
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"upnp_log\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___6,
    );
    tmp___7 = level2debug(util_loglevel);
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"util_log\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___7,
    );
    tmp___8 = level2debug(raop_loglevel);
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"raop_log\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___8,
    );
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"log_limit\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glLogLimit,
    );
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"max_players\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMaxDevices,
    );
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"binding\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glBinding.as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        root,
        0 as libc::c_int != 0,
        b"ports\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%hu:%hu\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glPortBase as libc::c_int,
        glPortRange as libc::c_int,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"enabled\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.Enabled as libc::c_int,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"max_volume\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.MaxVolume,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"http_length\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.HTTPLength,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"upnp_max\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.UPnPMax,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"codec\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.Codec).as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"metadata\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.Metadata as libc::c_int,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"flush\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.Flush as libc::c_int,
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"artwork\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.ArtWork).as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"latency\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.Latency).as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        common,
        0 as libc::c_int != 0,
        b"drift\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        glMRConfig.Drift as libc::c_int,
    );
    XMLUpdateNode(
        doc,
        proto,
        0 as libc::c_int != 0,
        b"pcm\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.ProtocolInfo.pcm).as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        proto,
        0 as libc::c_int != 0,
        b"wav\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.ProtocolInfo.wav).as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        proto,
        0 as libc::c_int != 0,
        b"flac\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.ProtocolInfo.flac).as_mut_ptr(),
    );
    XMLUpdateNode(
        doc,
        proto,
        0 as libc::c_int != 0,
        b"mp3\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (glMRConfig.ProtocolInfo.mp3).as_mut_ptr(),
    );
    i = 0 as libc::c_int;
    while i < glMaxDevices {
        if (*glMRDevices.offset(i as isize)).Running {
            p = glMRDevices.offset(i as isize);
            if old_doc.is_null() {
                dev_node = XMLAddNode(
                    doc,
                    root,
                    b"device\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    0 as *mut libc::c_void as *mut libc::c_char,
                );
                XMLAddNode(
                    doc,
                    dev_node,
                    b"udn\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    ((*p).UDN).as_mut_ptr(),
                );
                XMLAddNode(
                    doc,
                    dev_node,
                    b"name\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    ((*p).Config.Name).as_mut_ptr(),
                );
                XMLAddNode(
                    doc,
                    dev_node,
                    b"mac\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    b"%02x:%02x:%02x:%02x:%02x:%02x\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    (*p).Config.mac[0 as libc::c_int as usize] as libc::c_int,
                    (*p).Config.mac[1 as libc::c_int as usize] as libc::c_int,
                    (*p).Config.mac[2 as libc::c_int as usize] as libc::c_int,
                    (*p).Config.mac[3 as libc::c_int as usize] as libc::c_int,
                    (*p).Config.mac[4 as libc::c_int as usize] as libc::c_int,
                    (*p).Config.mac[5 as libc::c_int as usize] as libc::c_int,
                );
                XMLAddNode(
                    doc,
                    dev_node,
                    b"enabled\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*p).Config.Enabled as libc::c_int,
                );
            } else {
                tmp___9 = FindMRConfig(
                    old_doc as *mut libc::c_void,
                    ((*p).UDN).as_mut_ptr(),
                );
                if tmp___9.is_null() {
                    dev_node = XMLAddNode(
                        doc,
                        root,
                        b"device\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        0 as *mut libc::c_void as *mut libc::c_char,
                    );
                    XMLAddNode(
                        doc,
                        dev_node,
                        b"udn\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        ((*p).UDN).as_mut_ptr(),
                    );
                    XMLAddNode(
                        doc,
                        dev_node,
                        b"name\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        ((*p).Config.Name).as_mut_ptr(),
                    );
                    XMLAddNode(
                        doc,
                        dev_node,
                        b"mac\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        b"%02x:%02x:%02x:%02x:%02x:%02x\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        (*p).Config.mac[0 as libc::c_int as usize] as libc::c_int,
                        (*p).Config.mac[1 as libc::c_int as usize] as libc::c_int,
                        (*p).Config.mac[2 as libc::c_int as usize] as libc::c_int,
                        (*p).Config.mac[3 as libc::c_int as usize] as libc::c_int,
                        (*p).Config.mac[4 as libc::c_int as usize] as libc::c_int,
                        (*p).Config.mac[5 as libc::c_int as usize] as libc::c_int,
                    );
                    XMLAddNode(
                        doc,
                        dev_node,
                        b"enabled\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                        (*p).Config.Enabled as libc::c_int,
                    );
                }
            }
        }
        i += 1;
    }
    list = ixmlDocument_getElementsByTagName(
        old_root as *mut IXML_Document,
        b"device\0" as *const u8 as *const libc::c_char,
    );
    i = 0 as libc::c_int;
    loop {
        tmp___13 = ixmlNodeList_length(list);
        if !(i < tmp___13 as libc::c_int) {
            break;
        }
        device___0 = ixmlNodeList_item(list, i as libc::c_ulong);
        tmp___10 = ixmlDocument_getElementById(
            device___0 as *mut IXML_Document,
            b"udn\0" as *const u8 as *const libc::c_char,
        );
        node = tmp___10 as *mut IXML_Node;
        node = ixmlNode_getFirstChild(node);
        tmp___11 = ixmlNode_getNodeValue(node);
        udn = tmp___11 as *mut libc::c_char;
        tmp___12 = FindMRConfig(doc as *mut libc::c_void, udn);
        if tmp___12.is_null() {
            ixmlDocument_importNode(doc, device___0, 1 as libc::c_int, &mut device___0);
            ixmlNode_appendChild(root, device___0);
        }
        i += 1;
    }
    if !list.is_null() {
        ixmlNodeList_free(list);
    }
    file = fopen(
        name as *const libc::c_char,
        b"wb\0" as *const u8 as *const libc::c_char,
    );
    s = ixmlDocumenttoString(doc);
    tmp___14 = strlen(s as *const libc::c_char);
    fwrite(s as *const libc::c_void, 1 as libc::c_int as size_t, tmp___14, file);
    fclose(file);
    free(s as *mut libc::c_void);
    ixmlDocument_free(doc);
}
unsafe extern "C" fn LoadConfigItem(
    mut Conf: *mut tMRConfig,
    mut name: *mut libc::c_char,
    mut val: *mut libc::c_char,
) {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut mac: [libc::c_uint; 6] = [0; 6];
    let mut i: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_int = 0;
    if val.is_null() {
        return;
    }
    tmp___0 = strcmp(
        name as *const libc::c_char,
        b"enabled\0" as *const u8 as *const libc::c_char,
    );
    if tmp___0 == 0 {
        tmp = atoi(val as *const libc::c_char);
        (*Conf).Enabled = tmp != 0;
    }
    tmp___1 = strcmp(
        name as *const libc::c_char,
        b"max_volume\0" as *const u8 as *const libc::c_char,
    );
    if tmp___1 == 0 {
        (*Conf).MaxVolume = atoi(val as *const libc::c_char);
    }
    tmp___2 = strcmp(
        name as *const libc::c_char,
        b"http_length\0" as *const u8 as *const libc::c_char,
    );
    if tmp___2 == 0 {
        (*Conf).HTTPLength = atoi(val as *const libc::c_char);
    }
    tmp___3 = strcmp(
        name as *const libc::c_char,
        b"upnp_max\0" as *const u8 as *const libc::c_char,
    );
    if tmp___3 == 0 {
        (*Conf).UPnPMax = atoi(val as *const libc::c_char);
    }
    tmp___4 = strcmp(
        name as *const libc::c_char,
        b"use_flac\0" as *const u8 as *const libc::c_char,
    );
    if tmp___4 == 0 {
        strcpy(
            ((*Conf).Codec).as_mut_ptr(),
            b"flac\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___5 = strcmp(
        name as *const libc::c_char,
        b"codec\0" as *const u8 as *const libc::c_char,
    );
    if tmp___5 == 0 {
        strcpy(((*Conf).Codec).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___7 = strcmp(
        name as *const libc::c_char,
        b"metadata\0" as *const u8 as *const libc::c_char,
    );
    if tmp___7 == 0 {
        tmp___6 = atoi(val as *const libc::c_char);
        (*Conf).Metadata = tmp___6 != 0;
    }
    tmp___9 = strcmp(
        name as *const libc::c_char,
        b"flush\0" as *const u8 as *const libc::c_char,
    );
    if tmp___9 == 0 {
        tmp___8 = atoi(val as *const libc::c_char);
        (*Conf).Flush = tmp___8 != 0;
    }
    tmp___10 = strcmp(
        name as *const libc::c_char,
        b"artwork\0" as *const u8 as *const libc::c_char,
    );
    if tmp___10 == 0 {
        strcpy(((*Conf).ArtWork).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___11 = strcmp(
        name as *const libc::c_char,
        b"latency\0" as *const u8 as *const libc::c_char,
    );
    if tmp___11 == 0 {
        strcpy(((*Conf).Latency).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___13 = strcmp(
        name as *const libc::c_char,
        b"drift\0" as *const u8 as *const libc::c_char,
    );
    if tmp___13 == 0 {
        tmp___12 = atoi(val as *const libc::c_char);
        (*Conf).Drift = tmp___12 != 0;
    }
    tmp___14 = strcmp(
        name as *const libc::c_char,
        b"name\0" as *const u8 as *const libc::c_char,
    );
    if tmp___14 == 0 {
        strcpy(((*Conf).Name).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___15 = strcmp(
        name as *const libc::c_char,
        b"mac\0" as *const u8 as *const libc::c_char,
    );
    if tmp___15 == 0 {
        sscanf(
            val as *const libc::c_char,
            b"%2x:%2x:%2x:%2x:%2x:%2x\0" as *const u8 as *const libc::c_char,
            &mut *mac.as_mut_ptr().offset(0 as libc::c_int as isize)
                as *mut libc::c_uint,
            &mut *mac.as_mut_ptr().offset(1 as libc::c_int as isize)
                as *mut libc::c_uint,
            &mut *mac.as_mut_ptr().offset(2 as libc::c_int as isize)
                as *mut libc::c_uint,
            &mut *mac.as_mut_ptr().offset(3 as libc::c_int as isize)
                as *mut libc::c_uint,
            &mut *mac.as_mut_ptr().offset(4 as libc::c_int as isize)
                as *mut libc::c_uint,
            &mut *mac.as_mut_ptr().offset(5 as libc::c_int as isize) as *mut libc::c_uint,
        );
        i = 0 as libc::c_int;
        while i < 6 as libc::c_int {
            (*Conf).mac[i as usize] = mac[i as usize] as u8_t;
            i += 1;
        }
    }
    tmp___16 = strcmp(
        name as *const libc::c_char,
        b"pcm\0" as *const u8 as *const libc::c_char,
    );
    if tmp___16 == 0 {
        strcpy(((*Conf).ProtocolInfo.pcm).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___17 = strcmp(
        name as *const libc::c_char,
        b"wav\0" as *const u8 as *const libc::c_char,
    );
    if tmp___17 == 0 {
        strcpy(((*Conf).ProtocolInfo.wav).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___18 = strcmp(
        name as *const libc::c_char,
        b"flac\0" as *const u8 as *const libc::c_char,
    );
    if tmp___18 == 0 {
        strcpy(((*Conf).ProtocolInfo.flac).as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___19 = strcmp(
        name as *const libc::c_char,
        b"mp3\0" as *const u8 as *const libc::c_char,
    );
    if tmp___19 == 0 {
        strcpy(((*Conf).ProtocolInfo.mp3).as_mut_ptr(), val as *const libc::c_char);
    }
}
unsafe extern "C" fn LoadGlobalItem(
    mut name: *mut libc::c_char,
    mut val: *mut libc::c_char,
) {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_long = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_long = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    if val.is_null() {
        return;
    }
    tmp = strcmp(
        name as *const libc::c_char,
        b"main_log\0" as *const u8 as *const libc::c_char,
    );
    if tmp == 0 {
        main_loglevel = debug2level(val);
    }
    tmp___0 = strcmp(
        name as *const libc::c_char,
        b"upnp_log\0" as *const u8 as *const libc::c_char,
    );
    if tmp___0 == 0 {
        upnp_loglevel = debug2level(val);
    }
    tmp___1 = strcmp(
        name as *const libc::c_char,
        b"util_log\0" as *const u8 as *const libc::c_char,
    );
    if tmp___1 == 0 {
        util_loglevel = debug2level(val);
    }
    tmp___2 = strcmp(
        name as *const libc::c_char,
        b"raop_log\0" as *const u8 as *const libc::c_char,
    );
    if tmp___2 == 0 {
        raop_loglevel = debug2level(val);
    }
    tmp___4 = strcmp(
        name as *const libc::c_char,
        b"log_limit\0" as *const u8 as *const libc::c_char,
    );
    if tmp___4 == 0 {
        tmp___3 = atol(val as *const libc::c_char);
        glLogLimit = tmp___3 as s32_t;
    }
    tmp___6 = strcmp(
        name as *const libc::c_char,
        b"max_players\0" as *const u8 as *const libc::c_char,
    );
    if tmp___6 == 0 {
        tmp___5 = atol(val as *const libc::c_char);
        glMaxDevices = tmp___5 as libc::c_int;
    }
    tmp___7 = strcmp(
        name as *const libc::c_char,
        b"binding\0" as *const u8 as *const libc::c_char,
    );
    if tmp___7 == 0 {
        strcpy(glBinding.as_mut_ptr(), val as *const libc::c_char);
    }
    tmp___8 = strcmp(
        name as *const libc::c_char,
        b"ports\0" as *const u8 as *const libc::c_char,
    );
    if tmp___8 == 0 {
        sscanf(
            val as *const libc::c_char,
            b"%hu:%hu\0" as *const u8 as *const libc::c_char,
            &mut glPortBase as *mut libc::c_ushort,
            &mut glPortRange as *mut libc::c_ushort,
        );
    }
}
pub unsafe extern "C" fn FindMRConfig(
    mut ref_0: *mut libc::c_void,
    mut UDN: *mut libc::c_char,
) -> *mut libc::c_void {
    let mut elm: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut device: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut l1_node_list: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut doc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut v: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_uint = 0;
    let mut l1_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut l1_1_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_ulong = 0;
    device = 0 as *mut libc::c_void as *mut IXML_Node;
    doc = ref_0 as *mut IXML_Document;
    elm = ixmlDocument_getElementById(
        doc,
        b"airupnp\0" as *const u8 as *const libc::c_char,
    );
    l1_node_list = ixmlDocument_getElementsByTagName(
        elm as *mut IXML_Document,
        b"udn\0" as *const u8 as *const libc::c_char,
    );
    i = 0 as libc::c_uint;
    loop {
        tmp___1 = ixmlNodeList_length(l1_node_list);
        if !((i as libc::c_ulong) < tmp___1) {
            break;
        }
        l1_node = ixmlNodeList_item(l1_node_list, i as libc::c_ulong);
        l1_1_node = ixmlNode_getFirstChild(l1_node);
        tmp = ixmlNode_getNodeValue(l1_1_node);
        v = tmp as *mut libc::c_char;
        if !v.is_null() {
            tmp___0 = strcmp(v as *const libc::c_char, UDN as *const libc::c_char);
            if tmp___0 == 0 {
                device = ixmlNode_getParentNode(l1_node);
                break;
            }
        }
        i = i.wrapping_add(1);
    }
    if !l1_node_list.is_null() {
        ixmlNodeList_free(l1_node_list);
    }
    return device as *mut libc::c_void;
}
pub unsafe extern "C" fn LoadMRConfig(
    mut ref_0: *mut libc::c_void,
    mut UDN: *mut libc::c_char,
    mut Conf: *mut sMRConfig,
) -> *mut libc::c_void {
    let mut node_list: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut doc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut n: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut v: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_uint = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut l1_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut l1_1_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: libc::c_ulong = 0;
    doc = ref_0 as *mut IXML_Document;
    tmp = FindMRConfig(doc as *mut libc::c_void, UDN);
    node = tmp as *mut IXML_Node;
    if !node.is_null() {
        node_list = ixmlNode_getChildNodes(node);
        i = 0 as libc::c_uint;
        loop {
            tmp___2 = ixmlNodeList_length(node_list);
            if !((i as libc::c_ulong) < tmp___2) {
                break;
            }
            l1_node = ixmlNodeList_item(node_list, i as libc::c_ulong);
            tmp___0 = ixmlNode_getNodeName(l1_node);
            n = tmp___0 as *mut libc::c_char;
            l1_1_node = ixmlNode_getFirstChild(l1_node);
            tmp___1 = ixmlNode_getNodeValue(l1_1_node);
            v = tmp___1 as *mut libc::c_char;
            LoadConfigItem(Conf, n, v);
            i = i.wrapping_add(1);
        }
        if !node_list.is_null() {
            ixmlNodeList_free(node_list);
        }
    }
    return node as *mut libc::c_void;
}
pub unsafe extern "C" fn LoadConfig(
    mut name: *mut libc::c_char,
    mut Conf: *mut sMRConfig,
) -> *mut libc::c_void {
    let mut elm: *mut IXML_Element = 0 as *mut IXML_Element;
    let mut doc: *mut IXML_Document = 0 as *mut IXML_Document;
    let mut i: libc::c_uint = 0;
    let mut n: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut v: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut l1_node_list: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut l1_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut l1_1_node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_ulong = 0;
    let mut n___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut v___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut l1_node_list___0: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut i___0: libc::c_uint = 0;
    let mut l1_node___0: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut l1_1_node___0: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_ulong = 0;
    let mut n___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut v___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut l1_node_list___1: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut i___1: libc::c_uint = 0;
    let mut l1_node___1: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut l1_1_node___1: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: libc::c_ulong = 0;
    doc = ixmlLoadDocument(name as *const libc::c_char);
    if doc.is_null() {
        return 0 as *mut libc::c_void;
    }
    elm = ixmlDocument_getElementById(
        doc,
        b"airupnp\0" as *const u8 as *const libc::c_char,
    );
    if !elm.is_null() {
        l1_node_list = ixmlNode_getChildNodes(elm as *mut IXML_Node);
        i = 0 as libc::c_uint;
        loop {
            tmp___1 = ixmlNodeList_length(l1_node_list);
            if !((i as libc::c_ulong) < tmp___1) {
                break;
            }
            l1_node = ixmlNodeList_item(l1_node_list, i as libc::c_ulong);
            tmp = ixmlNode_getNodeName(l1_node);
            n = tmp as *mut libc::c_char;
            l1_1_node = ixmlNode_getFirstChild(l1_node);
            tmp___0 = ixmlNode_getNodeValue(l1_1_node);
            v = tmp___0 as *mut libc::c_char;
            LoadGlobalItem(n, v);
            i = i.wrapping_add(1);
        }
        if !l1_node_list.is_null() {
            ixmlNodeList_free(l1_node_list);
        }
    }
    elm = ixmlDocument_getElementById(
        elm as *mut IXML_Document,
        b"common\0" as *const u8 as *const libc::c_char,
    );
    if !elm.is_null() {
        l1_node_list___0 = ixmlNode_getChildNodes(elm as *mut IXML_Node);
        i___0 = 0 as libc::c_uint;
        loop {
            tmp___4 = ixmlNodeList_length(l1_node_list___0);
            if !((i___0 as libc::c_ulong) < tmp___4) {
                break;
            }
            l1_node___0 = ixmlNodeList_item(l1_node_list___0, i___0 as libc::c_ulong);
            tmp___2 = ixmlNode_getNodeName(l1_node___0);
            n___0 = tmp___2 as *mut libc::c_char;
            l1_1_node___0 = ixmlNode_getFirstChild(l1_node___0);
            tmp___3 = ixmlNode_getNodeValue(l1_1_node___0);
            v___0 = tmp___3 as *mut libc::c_char;
            LoadConfigItem(&mut glMRConfig, n___0, v___0);
            i___0 = i___0.wrapping_add(1);
        }
        if !l1_node_list___0.is_null() {
            ixmlNodeList_free(l1_node_list___0);
        }
    }
    elm = ixmlDocument_getElementById(
        elm as *mut IXML_Document,
        b"protocolInfo\0" as *const u8 as *const libc::c_char,
    );
    if !elm.is_null() {
        l1_node_list___1 = ixmlNode_getChildNodes(elm as *mut IXML_Node);
        i___1 = 0 as libc::c_uint;
        loop {
            tmp___7 = ixmlNodeList_length(l1_node_list___1);
            if !((i___1 as libc::c_ulong) < tmp___7) {
                break;
            }
            l1_node___1 = ixmlNodeList_item(l1_node_list___1, i___1 as libc::c_ulong);
            tmp___5 = ixmlNode_getNodeName(l1_node___1);
            n___1 = tmp___5 as *mut libc::c_char;
            l1_1_node___1 = ixmlNode_getFirstChild(l1_node___1);
            tmp___6 = ixmlNode_getNodeValue(l1_1_node___1);
            v___1 = tmp___6 as *mut libc::c_char;
            LoadConfigItem(&mut glMRConfig, n___1, v___1);
            i___1 = i___1.wrapping_add(1);
        }
        if !l1_node_list___1.is_null() {
            ixmlNodeList_free(l1_node_list___1);
        }
    }
    return doc as *mut libc::c_void;
}
static mut host_bigendian: libc::c_int = 0 as libc::c_int;
pub static mut se_struct_24: __anonstruct_se_struct_24_422959015 = __anonstruct_se_struct_24_422959015 {
    x: [0; 3],
    c2rust_padding: [0; 1],
};
pub unsafe extern "C" fn allocate_buffers(mut alac: *mut alac_file) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(
        ((*alac).setinfo_max_samples_per_frame).wrapping_mul(4 as libc::c_uint) as size_t,
    );
    (*alac).predicterror_buffer_a = tmp as *mut int32_t;
    tmp___0 = malloc(
        ((*alac).setinfo_max_samples_per_frame).wrapping_mul(4 as libc::c_uint) as size_t,
    );
    (*alac).predicterror_buffer_b = tmp___0 as *mut int32_t;
    tmp___1 = malloc(
        ((*alac).setinfo_max_samples_per_frame).wrapping_mul(4 as libc::c_uint) as size_t,
    );
    (*alac).outputsamples_buffer_a = tmp___1 as *mut int32_t;
    tmp___2 = malloc(
        ((*alac).setinfo_max_samples_per_frame).wrapping_mul(4 as libc::c_uint) as size_t,
    );
    (*alac).outputsamples_buffer_b = tmp___2 as *mut int32_t;
    tmp___3 = malloc(
        ((*alac).setinfo_max_samples_per_frame).wrapping_mul(4 as libc::c_uint) as size_t,
    );
    (*alac).uncompressed_bytes_buffer_a = tmp___3 as *mut int32_t;
    tmp___4 = malloc(
        ((*alac).setinfo_max_samples_per_frame).wrapping_mul(4 as libc::c_uint) as size_t,
    );
    (*alac).uncompressed_bytes_buffer_b = tmp___4 as *mut int32_t;
}
pub unsafe extern "C" fn alac_set_info(
    mut alac: *mut alac_file,
    mut inputbuffer: *mut libc::c_char,
) {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    ptr = inputbuffer;
    ptr = ptr.offset(4 as libc::c_int as isize);
    ptr = ptr.offset(4 as libc::c_int as isize);
    ptr = ptr.offset(4 as libc::c_int as isize);
    ptr = ptr.offset(4 as libc::c_int as isize);
    ptr = ptr.offset(4 as libc::c_int as isize);
    ptr = ptr.offset(4 as libc::c_int as isize);
    (*alac).setinfo_max_samples_per_frame = *(ptr as *mut uint32_t);
    if host_bigendian == 0 {
        (*alac)
            .setinfo_max_samples_per_frame = ((*alac).setinfo_max_samples_per_frame
            & 255 as libc::c_uint) << 24 as libc::c_int
            | ((*alac).setinfo_max_samples_per_frame & 65280 as libc::c_uint)
                << 8 as libc::c_int
            | ((*alac).setinfo_max_samples_per_frame & 16711680 as libc::c_uint)
                >> 8 as libc::c_int
            | ((*alac).setinfo_max_samples_per_frame & 4278190080 as libc::c_uint)
                >> 24 as libc::c_int;
    }
    ptr = ptr.offset(4 as libc::c_int as isize);
    (*alac).setinfo_7a = *(ptr as *mut uint8_t);
    ptr = ptr.offset(1);
    (*alac).setinfo_sample_size = *(ptr as *mut uint8_t);
    ptr = ptr.offset(1);
    (*alac).setinfo_rice_historymult = *(ptr as *mut uint8_t);
    ptr = ptr.offset(1);
    (*alac).setinfo_rice_initialhistory = *(ptr as *mut uint8_t);
    ptr = ptr.offset(1);
    (*alac).setinfo_rice_kmodifier = *(ptr as *mut uint8_t);
    ptr = ptr.offset(1);
    (*alac).setinfo_7f = *(ptr as *mut uint8_t);
    ptr = ptr.offset(1);
    (*alac).setinfo_80 = *(ptr as *mut uint16_t);
    if host_bigendian == 0 {
        (*alac)
            .setinfo_80 = (((*alac).setinfo_80 as libc::c_int & 255 as libc::c_int)
            << 8 as libc::c_int
            | ((*alac).setinfo_80 as libc::c_int & 65280 as libc::c_int)
                >> 8 as libc::c_int) as uint16_t;
    }
    ptr = ptr.offset(2 as libc::c_int as isize);
    (*alac).setinfo_82 = *(ptr as *mut uint32_t);
    if host_bigendian == 0 {
        (*alac)
            .setinfo_82 = ((*alac).setinfo_82 & 255 as libc::c_uint) << 24 as libc::c_int
            | ((*alac).setinfo_82 & 65280 as libc::c_uint) << 8 as libc::c_int
            | ((*alac).setinfo_82 & 16711680 as libc::c_uint) >> 8 as libc::c_int
            | ((*alac).setinfo_82 & 4278190080 as libc::c_uint) >> 24 as libc::c_int;
    }
    ptr = ptr.offset(4 as libc::c_int as isize);
    (*alac).setinfo_86 = *(ptr as *mut uint32_t);
    if host_bigendian == 0 {
        (*alac)
            .setinfo_86 = ((*alac).setinfo_86 & 255 as libc::c_uint) << 24 as libc::c_int
            | ((*alac).setinfo_86 & 65280 as libc::c_uint) << 8 as libc::c_int
            | ((*alac).setinfo_86 & 16711680 as libc::c_uint) >> 8 as libc::c_int
            | ((*alac).setinfo_86 & 4278190080 as libc::c_uint) >> 24 as libc::c_int;
    }
    ptr = ptr.offset(4 as libc::c_int as isize);
    (*alac).setinfo_8a_rate = *(ptr as *mut uint32_t);
    if host_bigendian == 0 {
        (*alac)
            .setinfo_8a_rate = ((*alac).setinfo_8a_rate & 255 as libc::c_uint)
            << 24 as libc::c_int
            | ((*alac).setinfo_8a_rate & 65280 as libc::c_uint) << 8 as libc::c_int
            | ((*alac).setinfo_8a_rate & 16711680 as libc::c_uint) >> 8 as libc::c_int
            | ((*alac).setinfo_8a_rate & 4278190080 as libc::c_uint)
                >> 24 as libc::c_int;
    }
    allocate_buffers(alac);
}
unsafe extern "C" fn readbits_16(
    mut alac: *mut alac_file,
    mut bits: libc::c_int,
) -> uint32_t {
    let mut result: uint32_t = 0;
    let mut new_accumulator: libc::c_int = 0;
    result = ((*((*alac).input_buffer).offset(0 as libc::c_int as isize) as libc::c_int)
        << 16 as libc::c_int
        | (*((*alac).input_buffer).offset(1 as libc::c_int as isize) as libc::c_int)
            << 8 as libc::c_int
        | *((*alac).input_buffer).offset(2 as libc::c_int as isize) as libc::c_int)
        as uint32_t;
    result <<= (*alac).input_buffer_bitaccumulator;
    result &= 16777215 as libc::c_uint;
    result >>= 24 as libc::c_int - bits;
    new_accumulator = (*alac).input_buffer_bitaccumulator + bits;
    (*alac)
        .input_buffer = ((*alac).input_buffer)
        .offset((new_accumulator >> 3 as libc::c_int) as isize);
    (*alac).input_buffer_bitaccumulator = new_accumulator & 7 as libc::c_int;
    return result;
}
unsafe extern "C" fn readbits(
    mut alac: *mut alac_file,
    mut bits: libc::c_int,
) -> uint32_t {
    let mut result: int32_t = 0;
    let mut tmp: uint32_t = 0;
    let mut tmp___0: uint32_t = 0;
    result = 0 as libc::c_int;
    if bits > 16 as libc::c_int {
        bits -= 16 as libc::c_int;
        tmp = readbits_16(alac, 16 as libc::c_int);
        result = (tmp << bits) as int32_t;
    }
    tmp___0 = readbits_16(alac, bits);
    result = (result as libc::c_uint | tmp___0) as int32_t;
    return result as uint32_t;
}
unsafe extern "C" fn readbit(mut alac: *mut alac_file) -> libc::c_int {
    let mut result: libc::c_int = 0;
    let mut new_accumulator: libc::c_int = 0;
    result = *((*alac).input_buffer).offset(0 as libc::c_int as isize) as libc::c_int;
    result <<= (*alac).input_buffer_bitaccumulator;
    result = result >> 7 as libc::c_int & 1 as libc::c_int;
    new_accumulator = (*alac).input_buffer_bitaccumulator + 1 as libc::c_int;
    (*alac)
        .input_buffer = ((*alac).input_buffer)
        .offset((new_accumulator / 8 as libc::c_int) as isize);
    (*alac).input_buffer_bitaccumulator = new_accumulator % 8 as libc::c_int;
    return result;
}
unsafe extern "C" fn unreadbits(mut alac: *mut alac_file, mut bits: libc::c_int) {
    let mut new_accumulator: libc::c_int = 0;
    new_accumulator = (*alac).input_buffer_bitaccumulator - bits;
    (*alac)
        .input_buffer = ((*alac).input_buffer)
        .offset((new_accumulator >> 3 as libc::c_int) as isize);
    (*alac).input_buffer_bitaccumulator = new_accumulator & 7 as libc::c_int;
    if (*alac).input_buffer_bitaccumulator < 0 as libc::c_int {
        (*alac).input_buffer_bitaccumulator *= -(1 as libc::c_int);
    }
}
unsafe extern "C" fn count_leading_zeros(mut input: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = (input as libc::c_uint).leading_zeros() as i32;
    return tmp;
}
unsafe extern "C" fn entropy_decode_value(
    mut alac: *mut alac_file,
    mut readSampleSize: libc::c_int,
    mut k: libc::c_int,
    mut rice_kmodifier_mask: libc::c_int,
) -> int32_t {
    let mut x: int32_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut value: int32_t = 0;
    let mut tmp___0: uint32_t = 0;
    let mut extraBits: libc::c_int = 0;
    let mut tmp___1: uint32_t = 0;
    x = 0 as libc::c_int;
    while x <= 8 as libc::c_int {
        tmp = readbit(alac);
        if tmp == 0 {
            break;
        }
        x += 1;
    }
    if x > 8 as libc::c_int {
        tmp___0 = readbits(alac, readSampleSize);
        value = tmp___0 as int32_t;
        value = (value as libc::c_uint
            & 4294967295 as libc::c_uint >> 32 as libc::c_int - readSampleSize)
            as int32_t;
        x = value;
    } else if k != 1 as libc::c_int {
        tmp___1 = readbits(alac, k);
        extraBits = tmp___1 as libc::c_int;
        x *= ((1 as libc::c_int) << k) - 1 as libc::c_int & rice_kmodifier_mask;
        if extraBits > 1 as libc::c_int {
            x += extraBits - 1 as libc::c_int;
        } else {
            unreadbits(alac, 1 as libc::c_int);
        }
    }
    return x;
}
unsafe extern "C" fn entropy_rice_decode(
    mut alac: *mut alac_file,
    mut outputBuffer: *mut int32_t,
    mut outputSize: libc::c_int,
    mut readSampleSize: libc::c_int,
    mut rice_initialhistory: libc::c_int,
    mut rice_kmodifier: libc::c_int,
    mut rice_historymult: libc::c_int,
    mut rice_kmodifier_mask: libc::c_int,
) {
    let mut outputCount: libc::c_int = 0;
    let mut history: libc::c_int = 0;
    let mut signModifier: libc::c_int = 0;
    let mut decodedValue: int32_t = 0;
    let mut finalValue: int32_t = 0;
    let mut k: int32_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut blockSize: int32_t = 0;
    let mut tmp___0: libc::c_int = 0;
    history = rice_initialhistory;
    signModifier = 0 as libc::c_int;
    outputCount = 0 as libc::c_int;
    while outputCount < outputSize {
        tmp = count_leading_zeros((history >> 9 as libc::c_int) + 3 as libc::c_int);
        k = 31 as libc::c_int - rice_kmodifier - tmp;
        if k < 0 as libc::c_int {
            k += rice_kmodifier;
        } else {
            k = rice_kmodifier;
        }
        decodedValue = entropy_decode_value(
            alac,
            readSampleSize,
            k,
            -(1 as libc::c_int),
        );
        decodedValue += signModifier;
        finalValue = (decodedValue + 1 as libc::c_int) / 2 as libc::c_int;
        if decodedValue & 1 as libc::c_int != 0 {
            finalValue *= -(1 as libc::c_int);
        }
        *outputBuffer.offset(outputCount as isize) = finalValue;
        signModifier = 0 as libc::c_int;
        history
            += decodedValue * rice_historymult
                - (history * rice_historymult >> 9 as libc::c_int);
        if decodedValue > 65535 as libc::c_int {
            history = 65535 as libc::c_int;
        }
        if history < 128 as libc::c_int {
            if (outputCount + 1 as libc::c_int) < outputSize {
                signModifier = 1 as libc::c_int;
                tmp___0 = count_leading_zeros(history);
                k = tmp___0 + (history + 16 as libc::c_int) / 64 as libc::c_int
                    - 24 as libc::c_int;
                blockSize = entropy_decode_value(
                    alac,
                    16 as libc::c_int,
                    k,
                    rice_kmodifier_mask,
                );
                if blockSize > 0 as libc::c_int {
                    memset(
                        outputBuffer.offset((outputCount + 1 as libc::c_int) as isize)
                            as *mut libc::c_void,
                        0 as libc::c_int,
                        (blockSize as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<int32_t>() as libc::c_ulong,
                            ),
                    );
                    outputCount += blockSize;
                }
                if blockSize > 65535 as libc::c_int {
                    signModifier = 0 as libc::c_int;
                }
                history = 0 as libc::c_int;
            }
        }
        outputCount += 1;
    }
}
unsafe extern "C" fn predictor_decompress_fir_adapt(
    mut error_buffer: *mut int32_t,
    mut buffer_out: *mut int32_t,
    mut output_size: libc::c_int,
    mut readsamplesize: libc::c_int,
    mut predictor_coef_table: *mut int16_t,
    mut predictor_coef_num: libc::c_int,
    mut predictor_quantitization: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut prev_value: int32_t = 0;
    let mut error_value: int32_t = 0;
    let mut i___0: libc::c_int = 0;
    let mut val: int32_t = 0;
    let mut j: libc::c_int = 0;
    let mut sum: libc::c_int = 0;
    let mut outval: libc::c_int = 0;
    let mut error_val: libc::c_int = 0;
    let mut predictor_num: libc::c_int = 0;
    let mut val___0: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut predictor_num___0: libc::c_int = 0;
    let mut val___1: libc::c_int = 0;
    let mut sign___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    *buffer_out = *error_buffer;
    if predictor_coef_num == 0 {
        if output_size <= 1 as libc::c_int {
            return;
        }
        memcpy(
            buffer_out.offset(1 as libc::c_int as isize) as *mut libc::c_void,
            error_buffer.offset(1 as libc::c_int as isize) as *const libc::c_void,
            ((output_size - 1 as libc::c_int) * 4 as libc::c_int) as size_t,
        );
        return;
    }
    if predictor_coef_num == 31 as libc::c_int {
        if output_size <= 1 as libc::c_int {
            return;
        }
        i = 0 as libc::c_int;
        while i < output_size - 1 as libc::c_int {
            prev_value = *buffer_out.offset(i as isize);
            error_value = *error_buffer.offset((i + 1 as libc::c_int) as isize);
            *buffer_out
                .offset(
                    (i + 1 as libc::c_int) as isize,
                ) = prev_value + error_value << 32 as libc::c_int - readsamplesize
                >> 32 as libc::c_int - readsamplesize;
            i += 1;
        }
        return;
    }
    if predictor_coef_num > 0 as libc::c_int {
        i___0 = 0 as libc::c_int;
        while i___0 < predictor_coef_num {
            val = *buffer_out.offset(i___0 as isize)
                + *error_buffer.offset((i___0 + 1 as libc::c_int) as isize);
            val = val << 32 as libc::c_int - readsamplesize
                >> 32 as libc::c_int - readsamplesize;
            *buffer_out.offset((i___0 + 1 as libc::c_int) as isize) = val;
            i___0 += 1;
        }
    }
    if predictor_coef_num > 0 as libc::c_int {
        i = predictor_coef_num + 1 as libc::c_int;
        while i < output_size {
            sum = 0 as libc::c_int;
            error_val = *error_buffer.offset(i as isize);
            j = 0 as libc::c_int;
            while j < predictor_coef_num {
                sum
                    += (*buffer_out.offset((predictor_coef_num - j) as isize)
                        - *buffer_out.offset(0 as libc::c_int as isize))
                        * *predictor_coef_table.offset(j as isize) as int32_t;
                j += 1;
            }
            outval = ((1 as libc::c_int) << predictor_quantitization - 1 as libc::c_int)
                + sum;
            outval >>= predictor_quantitization;
            outval = outval + *buffer_out.offset(0 as libc::c_int as isize) + error_val;
            outval = outval << 32 as libc::c_int - readsamplesize
                >> 32 as libc::c_int - readsamplesize;
            *buffer_out
                .offset((predictor_coef_num + 1 as libc::c_int) as isize) = outval;
            if error_val > 0 as libc::c_int {
                predictor_num = predictor_coef_num - 1 as libc::c_int;
                while predictor_num >= 0 as libc::c_int {
                    if !(error_val > 0 as libc::c_int) {
                        break;
                    }
                    val___0 = *buffer_out.offset(0 as libc::c_int as isize)
                        - *buffer_out
                            .offset((predictor_coef_num - predictor_num) as isize);
                    if val___0 < 0 as libc::c_int {
                        tmp___0 = -(1 as libc::c_int);
                    } else {
                        if val___0 > 0 as libc::c_int {
                            tmp = 1 as libc::c_int;
                        } else {
                            tmp = 0 as libc::c_int;
                        }
                        tmp___0 = tmp;
                    }
                    sign = tmp___0;
                    *predictor_coef_table
                        .offset(
                            predictor_num as isize,
                        ) = (*predictor_coef_table.offset(predictor_num as isize)
                        as libc::c_int - sign) as int16_t;
                    val___0 *= sign;
                    error_val
                        -= (val___0 >> predictor_quantitization)
                            * (predictor_coef_num - predictor_num);
                    predictor_num -= 1;
                }
            } else if error_val < 0 as libc::c_int {
                predictor_num___0 = predictor_coef_num - 1 as libc::c_int;
                while predictor_num___0 >= 0 as libc::c_int {
                    if !(error_val < 0 as libc::c_int) {
                        break;
                    }
                    val___1 = *buffer_out.offset(0 as libc::c_int as isize)
                        - *buffer_out
                            .offset((predictor_coef_num - predictor_num___0) as isize);
                    if val___1 < 0 as libc::c_int {
                        tmp___2 = -(1 as libc::c_int);
                    } else {
                        if val___1 > 0 as libc::c_int {
                            tmp___1 = 1 as libc::c_int;
                        } else {
                            tmp___1 = 0 as libc::c_int;
                        }
                        tmp___2 = tmp___1;
                    }
                    sign___0 = -tmp___2;
                    *predictor_coef_table
                        .offset(
                            predictor_num___0 as isize,
                        ) = (*predictor_coef_table.offset(predictor_num___0 as isize)
                        as libc::c_int - sign___0) as int16_t;
                    val___1 *= sign___0;
                    error_val
                        -= (val___1 >> predictor_quantitization)
                            * (predictor_coef_num - predictor_num___0);
                    predictor_num___0 -= 1;
                }
            }
            buffer_out = buffer_out.offset(1);
            i += 1;
        }
    }
}
unsafe extern "C" fn deinterlace_16(
    mut buffer_a: *mut int32_t,
    mut buffer_b: *mut int32_t,
    mut buffer_out: *mut int16_t,
    mut numchannels: libc::c_int,
    mut numsamples: libc::c_int,
    mut interlacing_shift: uint8_t,
    mut interlacing_leftweight: uint8_t,
) {
    let mut i: libc::c_int = 0;
    let mut difference: int32_t = 0;
    let mut midright: int32_t = 0;
    let mut left: int16_t = 0;
    let mut right: int16_t = 0;
    let mut left___0: int16_t = 0;
    let mut right___0: int16_t = 0;
    if numsamples <= 0 as libc::c_int {
        return;
    }
    if interlacing_leftweight != 0 {
        i = 0 as libc::c_int;
        while i < numsamples {
            midright = *buffer_a.offset(i as isize);
            difference = *buffer_b.offset(i as isize);
            right = (midright
                - (difference * interlacing_leftweight as int32_t
                    >> interlacing_shift as libc::c_int)) as int16_t;
            left = (right as libc::c_int + difference) as int16_t;
            if host_bigendian != 0 {
                left = ((left as libc::c_int & 255 as libc::c_int) << 8 as libc::c_int
                    | (left as libc::c_int & 65280 as libc::c_int) >> 8 as libc::c_int)
                    as int16_t;
                right = ((right as libc::c_int & 255 as libc::c_int) << 8 as libc::c_int
                    | (right as libc::c_int & 65280 as libc::c_int) >> 8 as libc::c_int)
                    as int16_t;
            }
            *buffer_out.offset((i * numchannels) as isize) = left;
            *buffer_out.offset((i * numchannels + 1 as libc::c_int) as isize) = right;
            i += 1;
        }
        return;
    }
    i = 0 as libc::c_int;
    while i < numsamples {
        left___0 = *buffer_a.offset(i as isize) as int16_t;
        right___0 = *buffer_b.offset(i as isize) as int16_t;
        if host_bigendian != 0 {
            left___0 = ((left___0 as libc::c_int & 255 as libc::c_int)
                << 8 as libc::c_int
                | (left___0 as libc::c_int & 65280 as libc::c_int) >> 8 as libc::c_int)
                as int16_t;
            right___0 = ((right___0 as libc::c_int & 255 as libc::c_int)
                << 8 as libc::c_int
                | (right___0 as libc::c_int & 65280 as libc::c_int) >> 8 as libc::c_int)
                as int16_t;
        }
        *buffer_out.offset((i * numchannels) as isize) = left___0;
        *buffer_out.offset((i * numchannels + 1 as libc::c_int) as isize) = right___0;
        i += 1;
    }
}
unsafe extern "C" fn deinterlace_24(
    mut buffer_a: *mut int32_t,
    mut buffer_b: *mut int32_t,
    mut uncompressed_bytes: libc::c_int,
    mut uncompressed_bytes_buffer_a: *mut int32_t,
    mut uncompressed_bytes_buffer_b: *mut int32_t,
    mut buffer_out: *mut libc::c_void,
    mut numchannels: libc::c_int,
    mut numsamples: libc::c_int,
    mut interlacing_shift: uint8_t,
    mut interlacing_leftweight: uint8_t,
) {
    let mut i: libc::c_int = 0;
    let mut difference: int32_t = 0;
    let mut midright: int32_t = 0;
    let mut left: int32_t = 0;
    let mut right: int32_t = 0;
    let mut mask: uint32_t = 0;
    let mut left___0: int32_t = 0;
    let mut right___0: int32_t = 0;
    let mut mask___0: uint32_t = 0;
    if numsamples <= 0 as libc::c_int {
        return;
    }
    if interlacing_leftweight != 0 {
        i = 0 as libc::c_int;
        while i < numsamples {
            midright = *buffer_a.offset(i as isize);
            difference = *buffer_b.offset(i as isize);
            right = midright
                - (difference * interlacing_leftweight as int32_t
                    >> interlacing_shift as libc::c_int);
            left = right + difference;
            if uncompressed_bytes != 0 {
                mask = !((4294967295 as libc::c_uint)
                    << uncompressed_bytes * 8 as libc::c_int);
                left <<= uncompressed_bytes * 8 as libc::c_int;
                right <<= uncompressed_bytes * 8 as libc::c_int;
                left = (left as libc::c_uint
                    | *uncompressed_bytes_buffer_a.offset(i as isize) as libc::c_uint
                        & mask) as int32_t;
                right = (right as libc::c_uint
                    | *uncompressed_bytes_buffer_b.offset(i as isize) as libc::c_uint
                        & mask) as int32_t;
            }
            *(buffer_out as *mut uint8_t)
                .offset(
                    (i * numchannels * 3 as libc::c_int) as isize,
                ) = (left & 255 as libc::c_int) as uint8_t;
            *(buffer_out as *mut uint8_t)
                .offset(
                    (i * numchannels * 3 as libc::c_int + 1 as libc::c_int) as isize,
                ) = (left >> 8 as libc::c_int & 255 as libc::c_int) as uint8_t;
            *(buffer_out as *mut uint8_t)
                .offset(
                    (i * numchannels * 3 as libc::c_int + 2 as libc::c_int) as isize,
                ) = (left >> 16 as libc::c_int & 255 as libc::c_int) as uint8_t;
            *(buffer_out as *mut uint8_t)
                .offset(
                    (i * numchannels * 3 as libc::c_int + 3 as libc::c_int) as isize,
                ) = (right & 255 as libc::c_int) as uint8_t;
            *(buffer_out as *mut uint8_t)
                .offset(
                    (i * numchannels * 3 as libc::c_int + 4 as libc::c_int) as isize,
                ) = (right >> 8 as libc::c_int & 255 as libc::c_int) as uint8_t;
            *(buffer_out as *mut uint8_t)
                .offset(
                    (i * numchannels * 3 as libc::c_int + 5 as libc::c_int) as isize,
                ) = (right >> 16 as libc::c_int & 255 as libc::c_int) as uint8_t;
            i += 1;
        }
        return;
    }
    i = 0 as libc::c_int;
    while i < numsamples {
        left___0 = *buffer_a.offset(i as isize);
        right___0 = *buffer_b.offset(i as isize);
        if uncompressed_bytes != 0 {
            mask___0 = !((4294967295 as libc::c_uint)
                << uncompressed_bytes * 8 as libc::c_int);
            left___0 <<= uncompressed_bytes * 8 as libc::c_int;
            right___0 <<= uncompressed_bytes * 8 as libc::c_int;
            left___0 = (left___0 as libc::c_uint
                | *uncompressed_bytes_buffer_a.offset(i as isize) as libc::c_uint
                    & mask___0) as int32_t;
            right___0 = (right___0 as libc::c_uint
                | *uncompressed_bytes_buffer_b.offset(i as isize) as libc::c_uint
                    & mask___0) as int32_t;
        }
        *(buffer_out as *mut uint8_t)
            .offset(
                (i * numchannels * 3 as libc::c_int) as isize,
            ) = (left___0 & 255 as libc::c_int) as uint8_t;
        *(buffer_out as *mut uint8_t)
            .offset(
                (i * numchannels * 3 as libc::c_int + 1 as libc::c_int) as isize,
            ) = (left___0 >> 8 as libc::c_int & 255 as libc::c_int) as uint8_t;
        *(buffer_out as *mut uint8_t)
            .offset(
                (i * numchannels * 3 as libc::c_int + 2 as libc::c_int) as isize,
            ) = (left___0 >> 16 as libc::c_int & 255 as libc::c_int) as uint8_t;
        *(buffer_out as *mut uint8_t)
            .offset(
                (i * numchannels * 3 as libc::c_int + 3 as libc::c_int) as isize,
            ) = (right___0 & 255 as libc::c_int) as uint8_t;
        *(buffer_out as *mut uint8_t)
            .offset(
                (i * numchannels * 3 as libc::c_int + 4 as libc::c_int) as isize,
            ) = (right___0 >> 8 as libc::c_int & 255 as libc::c_int) as uint8_t;
        *(buffer_out as *mut uint8_t)
            .offset(
                (i * numchannels * 3 as libc::c_int + 5 as libc::c_int) as isize,
            ) = (right___0 >> 16 as libc::c_int & 255 as libc::c_int) as uint8_t;
        i += 1;
    }
}
pub unsafe extern "C" fn decode_frame(
    mut alac: *mut alac_file,
    mut inbuffer: *mut libc::c_uchar,
    mut outbuffer: *mut libc::c_void,
    mut outputsize: *mut libc::c_int,
) {
    let mut channels: libc::c_int = 0;
    let mut outputsamples: int32_t = 0;
    let mut tmp: uint32_t = 0;
    let mut hassize: libc::c_int = 0;
    let mut isnotcompressed: libc::c_int = 0;
    let mut readsamplesize: libc::c_int = 0;
    let mut uncompressed_bytes: libc::c_int = 0;
    let mut ricemodifier: libc::c_int = 0;
    let mut tmp___0: uint32_t = 0;
    let mut tmp___1: uint32_t = 0;
    let mut tmp___2: uint32_t = 0;
    let mut tmp___3: uint32_t = 0;
    let mut predictor_coef_table: [int16_t; 32] = [0; 32];
    let mut predictor_coef_num: libc::c_int = 0;
    let mut prediction_type: libc::c_int = 0;
    let mut prediction_quantitization: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp___4: uint32_t = 0;
    let mut tmp___5: uint32_t = 0;
    let mut tmp___6: uint32_t = 0;
    let mut tmp___7: uint32_t = 0;
    let mut tmp___8: uint32_t = 0;
    let mut i___0: libc::c_int = 0;
    let mut tmp___9: uint32_t = 0;
    let mut i___1: libc::c_int = 0;
    let mut audiobits: int32_t = 0;
    let mut tmp___10: uint32_t = 0;
    let mut i___2: libc::c_int = 0;
    let mut audiobits___0: int32_t = 0;
    let mut tmp___11: uint32_t = 0;
    let mut tmp___12: uint32_t = 0;
    let mut i___3: libc::c_int = 0;
    let mut sample: int16_t = 0;
    let mut i___4: libc::c_int = 0;
    let mut sample___0: int32_t = 0;
    let mut mask: uint32_t = 0;
    let mut hassize___0: libc::c_int = 0;
    let mut isnotcompressed___0: libc::c_int = 0;
    let mut readsamplesize___0: libc::c_int = 0;
    let mut uncompressed_bytes___0: libc::c_int = 0;
    let mut interlacing_shift: uint8_t = 0;
    let mut interlacing_leftweight: uint8_t = 0;
    let mut tmp___13: uint32_t = 0;
    let mut tmp___14: uint32_t = 0;
    let mut tmp___15: uint32_t = 0;
    let mut tmp___16: uint32_t = 0;
    let mut predictor_coef_table_a: [int16_t; 32] = [0; 32];
    let mut predictor_coef_num_a: libc::c_int = 0;
    let mut prediction_type_a: libc::c_int = 0;
    let mut prediction_quantitization_a: libc::c_int = 0;
    let mut ricemodifier_a: libc::c_int = 0;
    let mut predictor_coef_table_b: [int16_t; 32] = [0; 32];
    let mut predictor_coef_num_b: libc::c_int = 0;
    let mut prediction_type_b: libc::c_int = 0;
    let mut prediction_quantitization_b: libc::c_int = 0;
    let mut ricemodifier_b: libc::c_int = 0;
    let mut i___5: libc::c_int = 0;
    let mut tmp___17: uint32_t = 0;
    let mut tmp___18: uint32_t = 0;
    let mut tmp___19: uint32_t = 0;
    let mut tmp___20: uint32_t = 0;
    let mut tmp___21: uint32_t = 0;
    let mut tmp___22: uint32_t = 0;
    let mut tmp___23: uint32_t = 0;
    let mut tmp___24: uint32_t = 0;
    let mut tmp___25: uint32_t = 0;
    let mut tmp___26: uint32_t = 0;
    let mut tmp___27: uint32_t = 0;
    let mut tmp___28: uint32_t = 0;
    let mut i___6: libc::c_int = 0;
    let mut tmp___29: uint32_t = 0;
    let mut tmp___30: uint32_t = 0;
    let mut i___7: libc::c_int = 0;
    let mut audiobits_a: int32_t = 0;
    let mut audiobits_b: int32_t = 0;
    let mut tmp___31: uint32_t = 0;
    let mut tmp___32: uint32_t = 0;
    let mut i___8: libc::c_int = 0;
    let mut audiobits_a___0: int32_t = 0;
    let mut audiobits_b___0: int32_t = 0;
    let mut tmp___33: uint32_t = 0;
    let mut tmp___34: uint32_t = 0;
    let mut tmp___35: uint32_t = 0;
    let mut tmp___36: uint32_t = 0;
    outputsamples = (*alac).setinfo_max_samples_per_frame as int32_t;
    (*alac).input_buffer = inbuffer;
    (*alac).input_buffer_bitaccumulator = 0 as libc::c_int;
    tmp = readbits(alac, 3 as libc::c_int);
    channels = tmp as libc::c_int;
    *outputsize = outputsamples * (*alac).bytespersample;
    match channels {
        0 => {
            readbits(alac, 4 as libc::c_int);
            readbits(alac, 12 as libc::c_int);
            tmp___0 = readbits(alac, 1 as libc::c_int);
            hassize = tmp___0 as libc::c_int;
            tmp___1 = readbits(alac, 2 as libc::c_int);
            uncompressed_bytes = tmp___1 as libc::c_int;
            tmp___2 = readbits(alac, 1 as libc::c_int);
            isnotcompressed = tmp___2 as libc::c_int;
            if hassize != 0 {
                tmp___3 = readbits(alac, 32 as libc::c_int);
                outputsamples = tmp___3 as int32_t;
                *outputsize = outputsamples * (*alac).bytespersample;
            }
            readsamplesize = (*alac).setinfo_sample_size as libc::c_int
                - uncompressed_bytes * 8 as libc::c_int;
            if isnotcompressed == 0 {
                readbits(alac, 8 as libc::c_int);
                readbits(alac, 8 as libc::c_int);
                tmp___4 = readbits(alac, 4 as libc::c_int);
                prediction_type = tmp___4 as libc::c_int;
                tmp___5 = readbits(alac, 4 as libc::c_int);
                prediction_quantitization = tmp___5 as libc::c_int;
                tmp___6 = readbits(alac, 3 as libc::c_int);
                ricemodifier = tmp___6 as libc::c_int;
                tmp___7 = readbits(alac, 5 as libc::c_int);
                predictor_coef_num = tmp___7 as libc::c_int;
                i = 0 as libc::c_int;
                while i < predictor_coef_num {
                    tmp___8 = readbits(alac, 16 as libc::c_int);
                    predictor_coef_table[i as usize] = tmp___8 as int16_t;
                    i += 1;
                }
                if uncompressed_bytes != 0 {
                    i___0 = 0 as libc::c_int;
                    while i___0 < outputsamples {
                        tmp___9 = readbits(alac, uncompressed_bytes * 8 as libc::c_int);
                        *((*alac).uncompressed_bytes_buffer_a)
                            .offset(i___0 as isize) = tmp___9 as int32_t;
                        i___0 += 1;
                    }
                }
                entropy_rice_decode(
                    alac,
                    (*alac).predicterror_buffer_a,
                    outputsamples,
                    readsamplesize,
                    (*alac).setinfo_rice_initialhistory as libc::c_int,
                    (*alac).setinfo_rice_kmodifier as libc::c_int,
                    ricemodifier * (*alac).setinfo_rice_historymult as libc::c_int
                        / 4 as libc::c_int,
                    ((1 as libc::c_int) << (*alac).setinfo_rice_kmodifier as libc::c_int)
                        - 1 as libc::c_int,
                );
                if prediction_type == 0 as libc::c_int {
                    predictor_decompress_fir_adapt(
                        (*alac).predicterror_buffer_a,
                        (*alac).outputsamples_buffer_a,
                        outputsamples,
                        readsamplesize,
                        predictor_coef_table.as_mut_ptr(),
                        predictor_coef_num,
                        prediction_quantitization,
                    );
                } else {
                    _fprintf(
                        stderr,
                        b"FIXME: unhandled predicition type: %i\n\0" as *const u8
                            as *const libc::c_char,
                        prediction_type,
                    );
                }
            } else {
                if (*alac).setinfo_sample_size as libc::c_int <= 16 as libc::c_int {
                    i___1 = 0 as libc::c_int;
                    while i___1 < outputsamples {
                        tmp___10 = readbits(
                            alac,
                            (*alac).setinfo_sample_size as libc::c_int,
                        );
                        audiobits = tmp___10 as int32_t;
                        audiobits = audiobits
                            << 32 as libc::c_int
                                - (*alac).setinfo_sample_size as libc::c_int
                            >> 32 as libc::c_int
                                - (*alac).setinfo_sample_size as libc::c_int;
                        *((*alac).outputsamples_buffer_a)
                            .offset(i___1 as isize) = audiobits;
                        i___1 += 1;
                    }
                } else {
                    i___2 = 0 as libc::c_int;
                    while i___2 < outputsamples {
                        tmp___11 = readbits(alac, 16 as libc::c_int);
                        audiobits___0 = tmp___11 as int32_t;
                        audiobits___0
                            <<= (*alac).setinfo_sample_size as libc::c_int
                                - 16 as libc::c_int;
                        tmp___12 = readbits(
                            alac,
                            (*alac).setinfo_sample_size as libc::c_int
                                - 16 as libc::c_int,
                        );
                        audiobits___0 = (audiobits___0 as libc::c_uint | tmp___12)
                            as int32_t;
                        se_struct_24.set_x(audiobits___0);
                        audiobits___0 = se_struct_24.x();
                        *((*alac).outputsamples_buffer_a)
                            .offset(i___2 as isize) = audiobits___0;
                        i___2 += 1;
                    }
                }
                uncompressed_bytes = 0 as libc::c_int;
            }
            match (*alac).setinfo_sample_size as libc::c_int {
                16 => {
                    i___3 = 0 as libc::c_int;
                    while i___3 < outputsamples {
                        sample = *((*alac).outputsamples_buffer_a).offset(i___3 as isize)
                            as int16_t;
                        if host_bigendian != 0 {
                            sample = ((sample as libc::c_int & 255 as libc::c_int)
                                << 8 as libc::c_int
                                | (sample as libc::c_int & 65280 as libc::c_int)
                                    >> 8 as libc::c_int) as int16_t;
                        }
                        *(outbuffer as *mut int16_t)
                            .offset((i___3 * (*alac).numchannels) as isize) = sample;
                        i___3 += 1;
                    }
                }
                24 => {
                    i___4 = 0 as libc::c_int;
                    while i___4 < outputsamples {
                        sample___0 = *((*alac).outputsamples_buffer_a)
                            .offset(i___4 as isize);
                        if uncompressed_bytes != 0 {
                            sample___0 <<= uncompressed_bytes * 8 as libc::c_int;
                            mask = !((4294967295 as libc::c_uint)
                                << uncompressed_bytes * 8 as libc::c_int);
                            sample___0 = (sample___0 as libc::c_uint
                                | *((*alac).uncompressed_bytes_buffer_a)
                                    .offset(i___4 as isize) as libc::c_uint & mask) as int32_t;
                        }
                        *(outbuffer as *mut uint8_t)
                            .offset(
                                (i___4 * (*alac).numchannels * 3 as libc::c_int) as isize,
                            ) = (sample___0 & 255 as libc::c_int) as uint8_t;
                        *(outbuffer as *mut uint8_t)
                            .offset(
                                (i___4 * (*alac).numchannels * 3 as libc::c_int
                                    + 1 as libc::c_int) as isize,
                            ) = (sample___0 >> 8 as libc::c_int & 255 as libc::c_int)
                            as uint8_t;
                        *(outbuffer as *mut uint8_t)
                            .offset(
                                (i___4 * (*alac).numchannels * 3 as libc::c_int
                                    + 2 as libc::c_int) as isize,
                            ) = (sample___0 >> 16 as libc::c_int & 255 as libc::c_int)
                            as uint8_t;
                        i___4 += 1;
                    }
                }
                32 | 20 => {
                    _fprintf(
                        stderr,
                        b"FIXME: unimplemented sample size %i\n\0" as *const u8
                            as *const libc::c_char,
                        (*alac).setinfo_sample_size as libc::c_int,
                    );
                }
                _ => {}
            }
        }
        1 => {
            readbits(alac, 4 as libc::c_int);
            readbits(alac, 12 as libc::c_int);
            tmp___13 = readbits(alac, 1 as libc::c_int);
            hassize___0 = tmp___13 as libc::c_int;
            tmp___14 = readbits(alac, 2 as libc::c_int);
            uncompressed_bytes___0 = tmp___14 as libc::c_int;
            tmp___15 = readbits(alac, 1 as libc::c_int);
            isnotcompressed___0 = tmp___15 as libc::c_int;
            if hassize___0 != 0 {
                tmp___16 = readbits(alac, 32 as libc::c_int);
                outputsamples = tmp___16 as int32_t;
                *outputsize = outputsamples * (*alac).bytespersample;
            }
            readsamplesize___0 = (*alac).setinfo_sample_size as libc::c_int
                - uncompressed_bytes___0 * 8 as libc::c_int + 1 as libc::c_int;
            if isnotcompressed___0 == 0 {
                tmp___17 = readbits(alac, 8 as libc::c_int);
                interlacing_shift = tmp___17 as uint8_t;
                tmp___18 = readbits(alac, 8 as libc::c_int);
                interlacing_leftweight = tmp___18 as uint8_t;
                tmp___19 = readbits(alac, 4 as libc::c_int);
                prediction_type_a = tmp___19 as libc::c_int;
                tmp___20 = readbits(alac, 4 as libc::c_int);
                prediction_quantitization_a = tmp___20 as libc::c_int;
                tmp___21 = readbits(alac, 3 as libc::c_int);
                ricemodifier_a = tmp___21 as libc::c_int;
                tmp___22 = readbits(alac, 5 as libc::c_int);
                predictor_coef_num_a = tmp___22 as libc::c_int;
                i___5 = 0 as libc::c_int;
                while i___5 < predictor_coef_num_a {
                    tmp___23 = readbits(alac, 16 as libc::c_int);
                    predictor_coef_table_a[i___5 as usize] = tmp___23 as int16_t;
                    i___5 += 1;
                }
                tmp___24 = readbits(alac, 4 as libc::c_int);
                prediction_type_b = tmp___24 as libc::c_int;
                tmp___25 = readbits(alac, 4 as libc::c_int);
                prediction_quantitization_b = tmp___25 as libc::c_int;
                tmp___26 = readbits(alac, 3 as libc::c_int);
                ricemodifier_b = tmp___26 as libc::c_int;
                tmp___27 = readbits(alac, 5 as libc::c_int);
                predictor_coef_num_b = tmp___27 as libc::c_int;
                i___5 = 0 as libc::c_int;
                while i___5 < predictor_coef_num_b {
                    tmp___28 = readbits(alac, 16 as libc::c_int);
                    predictor_coef_table_b[i___5 as usize] = tmp___28 as int16_t;
                    i___5 += 1;
                }
                if uncompressed_bytes___0 != 0 {
                    i___6 = 0 as libc::c_int;
                    while i___6 < outputsamples {
                        tmp___29 = readbits(
                            alac,
                            uncompressed_bytes___0 * 8 as libc::c_int,
                        );
                        *((*alac).uncompressed_bytes_buffer_a)
                            .offset(i___6 as isize) = tmp___29 as int32_t;
                        tmp___30 = readbits(
                            alac,
                            uncompressed_bytes___0 * 8 as libc::c_int,
                        );
                        *((*alac).uncompressed_bytes_buffer_b)
                            .offset(i___6 as isize) = tmp___30 as int32_t;
                        i___6 += 1;
                    }
                }
                entropy_rice_decode(
                    alac,
                    (*alac).predicterror_buffer_a,
                    outputsamples,
                    readsamplesize___0,
                    (*alac).setinfo_rice_initialhistory as libc::c_int,
                    (*alac).setinfo_rice_kmodifier as libc::c_int,
                    ricemodifier_a * (*alac).setinfo_rice_historymult as libc::c_int
                        / 4 as libc::c_int,
                    ((1 as libc::c_int) << (*alac).setinfo_rice_kmodifier as libc::c_int)
                        - 1 as libc::c_int,
                );
                if prediction_type_a == 0 as libc::c_int {
                    predictor_decompress_fir_adapt(
                        (*alac).predicterror_buffer_a,
                        (*alac).outputsamples_buffer_a,
                        outputsamples,
                        readsamplesize___0,
                        predictor_coef_table_a.as_mut_ptr(),
                        predictor_coef_num_a,
                        prediction_quantitization_a,
                    );
                } else {
                    _fprintf(
                        stderr,
                        b"FIXME: unhandled predicition type: %i\n\0" as *const u8
                            as *const libc::c_char,
                        prediction_type_a,
                    );
                }
                entropy_rice_decode(
                    alac,
                    (*alac).predicterror_buffer_b,
                    outputsamples,
                    readsamplesize___0,
                    (*alac).setinfo_rice_initialhistory as libc::c_int,
                    (*alac).setinfo_rice_kmodifier as libc::c_int,
                    ricemodifier_b * (*alac).setinfo_rice_historymult as libc::c_int
                        / 4 as libc::c_int,
                    ((1 as libc::c_int) << (*alac).setinfo_rice_kmodifier as libc::c_int)
                        - 1 as libc::c_int,
                );
                if prediction_type_b == 0 as libc::c_int {
                    predictor_decompress_fir_adapt(
                        (*alac).predicterror_buffer_b,
                        (*alac).outputsamples_buffer_b,
                        outputsamples,
                        readsamplesize___0,
                        predictor_coef_table_b.as_mut_ptr(),
                        predictor_coef_num_b,
                        prediction_quantitization_b,
                    );
                } else {
                    _fprintf(
                        stderr,
                        b"FIXME: unhandled predicition type: %i\n\0" as *const u8
                            as *const libc::c_char,
                        prediction_type_b,
                    );
                }
            } else {
                if (*alac).setinfo_sample_size as libc::c_int <= 16 as libc::c_int {
                    i___7 = 0 as libc::c_int;
                    while i___7 < outputsamples {
                        tmp___31 = readbits(
                            alac,
                            (*alac).setinfo_sample_size as libc::c_int,
                        );
                        audiobits_a = tmp___31 as int32_t;
                        tmp___32 = readbits(
                            alac,
                            (*alac).setinfo_sample_size as libc::c_int,
                        );
                        audiobits_b = tmp___32 as int32_t;
                        audiobits_a = audiobits_a
                            << 32 as libc::c_int
                                - (*alac).setinfo_sample_size as libc::c_int
                            >> 32 as libc::c_int
                                - (*alac).setinfo_sample_size as libc::c_int;
                        audiobits_b = audiobits_b
                            << 32 as libc::c_int
                                - (*alac).setinfo_sample_size as libc::c_int
                            >> 32 as libc::c_int
                                - (*alac).setinfo_sample_size as libc::c_int;
                        *((*alac).outputsamples_buffer_a)
                            .offset(i___7 as isize) = audiobits_a;
                        *((*alac).outputsamples_buffer_b)
                            .offset(i___7 as isize) = audiobits_b;
                        i___7 += 1;
                    }
                } else {
                    i___8 = 0 as libc::c_int;
                    while i___8 < outputsamples {
                        tmp___33 = readbits(alac, 16 as libc::c_int);
                        audiobits_a___0 = tmp___33 as int32_t;
                        audiobits_a___0
                            <<= (*alac).setinfo_sample_size as libc::c_int
                                - 16 as libc::c_int;
                        tmp___34 = readbits(
                            alac,
                            (*alac).setinfo_sample_size as libc::c_int
                                - 16 as libc::c_int,
                        );
                        audiobits_a___0 = (audiobits_a___0 as libc::c_uint | tmp___34)
                            as int32_t;
                        se_struct_24.set_x(audiobits_a___0);
                        audiobits_a___0 = se_struct_24.x();
                        tmp___35 = readbits(alac, 16 as libc::c_int);
                        audiobits_b___0 = tmp___35 as int32_t;
                        audiobits_b___0
                            <<= (*alac).setinfo_sample_size as libc::c_int
                                - 16 as libc::c_int;
                        tmp___36 = readbits(
                            alac,
                            (*alac).setinfo_sample_size as libc::c_int
                                - 16 as libc::c_int,
                        );
                        audiobits_b___0 = (audiobits_b___0 as libc::c_uint | tmp___36)
                            as int32_t;
                        se_struct_24.set_x(audiobits_b___0);
                        audiobits_b___0 = se_struct_24.x();
                        *((*alac).outputsamples_buffer_a)
                            .offset(i___8 as isize) = audiobits_a___0;
                        *((*alac).outputsamples_buffer_b)
                            .offset(i___8 as isize) = audiobits_b___0;
                        i___8 += 1;
                    }
                }
                uncompressed_bytes___0 = 0 as libc::c_int;
                interlacing_shift = 0 as libc::c_int as uint8_t;
                interlacing_leftweight = 0 as libc::c_int as uint8_t;
            }
            match (*alac).setinfo_sample_size as libc::c_int {
                16 => {
                    deinterlace_16(
                        (*alac).outputsamples_buffer_a,
                        (*alac).outputsamples_buffer_b,
                        outbuffer as *mut int16_t,
                        (*alac).numchannels,
                        outputsamples,
                        interlacing_shift,
                        interlacing_leftweight,
                    );
                }
                24 => {
                    deinterlace_24(
                        (*alac).outputsamples_buffer_a,
                        (*alac).outputsamples_buffer_b,
                        uncompressed_bytes___0,
                        (*alac).uncompressed_bytes_buffer_a,
                        (*alac).uncompressed_bytes_buffer_b,
                        outbuffer as *mut int16_t as *mut libc::c_void,
                        (*alac).numchannels,
                        outputsamples,
                        interlacing_shift,
                        interlacing_leftweight,
                    );
                }
                32 | 20 => {
                    _fprintf(
                        stderr,
                        b"FIXME: unimplemented sample size %i\n\0" as *const u8
                            as *const libc::c_char,
                        (*alac).setinfo_sample_size as libc::c_int,
                    );
                }
                _ => {}
            }
        }
        _ => {}
    };
}
pub unsafe extern "C" fn create_alac(
    mut samplesize: libc::c_int,
    mut numchannels: libc::c_int,
) -> *mut alac_file {
    let mut newfile: *mut alac_file = 0 as *mut alac_file;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<alac_file>() as libc::c_ulong);
    newfile = tmp as *mut alac_file;
    (*newfile).samplesize = samplesize;
    (*newfile).numchannels = numchannels;
    (*newfile).bytespersample = samplesize / 8 as libc::c_int * numchannels;
    return newfile;
}
pub unsafe extern "C" fn delete_alac(mut alac: *mut alac_file) {
    free((*alac).predicterror_buffer_a as *mut libc::c_void);
    free((*alac).predicterror_buffer_b as *mut libc::c_void);
    free((*alac).outputsamples_buffer_a as *mut libc::c_void);
    free((*alac).outputsamples_buffer_b as *mut libc::c_void);
    free((*alac).uncompressed_bytes_buffer_a as *mut libc::c_void);
    free((*alac).uncompressed_bytes_buffer_b as *mut libc::c_void);
    free(alac as *mut libc::c_void);
}
static mut base64_chars: [libc::c_char; 65] = [
    'A' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
unsafe extern "C" fn pos(mut c: libc::c_char) -> libc::c_int {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    p = base64_chars.as_mut_ptr();
    while *p != 0 {
        if *p as libc::c_int == c as libc::c_int {
            return p.offset_from(base64_chars.as_mut_ptr()) as libc::c_long
                as libc::c_int;
        }
        p = p.offset(1);
    }
    return -(1 as libc::c_int);
}
pub unsafe extern "C" fn base64_encode(
    mut data: *const libc::c_void,
    mut size: libc::c_int,
    mut str___0: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut q: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    tmp = malloc(
        (size * 4 as libc::c_int / 3 as libc::c_int + 4 as libc::c_int) as size_t,
    );
    s = tmp as *mut libc::c_char;
    p = s;
    if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    q = data as *const libc::c_uchar;
    i = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < size {
        tmp___0 = i;
        i += 1;
        c = *q.offset(tmp___0 as isize) as libc::c_int;
        c *= 256 as libc::c_int;
        if i < size {
            c += *q.offset(i as isize) as libc::c_int;
        }
        i += 1;
        c *= 256 as libc::c_int;
        if i < size {
            c += *q.offset(i as isize) as libc::c_int;
        }
        i += 1;
        *p
            .offset(
                0 as libc::c_int as isize,
            ) = base64_chars[((c & 16515072 as libc::c_int) >> 18 as libc::c_int)
            as usize];
        *p
            .offset(
                1 as libc::c_int as isize,
            ) = base64_chars[((c & 258048 as libc::c_int) >> 12 as libc::c_int)
            as usize];
        *p
            .offset(
                2 as libc::c_int as isize,
            ) = base64_chars[((c & 4032 as libc::c_int) >> 6 as libc::c_int) as usize];
        *p
            .offset(
                3 as libc::c_int as isize,
            ) = base64_chars[(c & 63 as libc::c_int) as usize];
        if i > size {
            *p.offset(3 as libc::c_int as isize) = '=' as i32 as libc::c_char;
        }
        if i > size + 1 as libc::c_int {
            *p.offset(2 as libc::c_int as isize) = '=' as i32 as libc::c_char;
        }
        p = p.offset(4 as libc::c_int as isize);
    }
    *p = 0 as libc::c_int as libc::c_char;
    *str___0 = s;
    tmp___1 = strlen(s as *const libc::c_char);
    return tmp___1 as libc::c_int;
}
unsafe extern "C" fn token_decode(mut token: *const libc::c_char) -> libc::c_uint {
    let mut i: libc::c_int = 0;
    let mut val: libc::c_uint = 0;
    let mut marker: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    val = 0 as libc::c_uint;
    marker = 0 as libc::c_int;
    tmp = strlen(token);
    if tmp < 4 as libc::c_ulong {
        return 4294967295 as libc::c_uint;
    }
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        val = val.wrapping_mul(64 as libc::c_uint);
        if *token.offset(i as isize) as libc::c_int == 61 as libc::c_int {
            marker += 1;
        } else if marker > 0 as libc::c_int {
            return 4294967295 as libc::c_uint
        } else {
            tmp___0 = pos(*token.offset(i as isize));
            val = val.wrapping_add(tmp___0 as libc::c_uint);
        }
        i += 1;
    }
    if marker > 2 as libc::c_int {
        return 4294967295 as libc::c_uint;
    }
    return (marker << 24 as libc::c_int) as libc::c_uint | val;
}
pub unsafe extern "C" fn base64_decode(
    mut str___0: *const libc::c_char,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut q: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut val: libc::c_uint = 0;
    let mut tmp: libc::c_uint = 0;
    let mut marker: libc::c_uint = 0;
    let mut tmp___0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tmp___1: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tmp___2: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    q = data as *mut libc::c_uchar;
    p = str___0;
    while *p != 0 {
        if !(*p as libc::c_int == 61 as libc::c_int) {
            tmp___3 = strchr(
                base64_chars.as_mut_ptr() as *const libc::c_char,
                *p as libc::c_int,
            );
            if tmp___3.is_null() {
                break;
            }
        }
        tmp = token_decode(p);
        val = tmp;
        marker = val >> 24 as libc::c_int & 255 as libc::c_uint;
        if val == 4294967295 as libc::c_uint {
            return -(1 as libc::c_int);
        }
        tmp___0 = q;
        q = q.offset(1);
        *tmp___0 = (val >> 16 as libc::c_int & 255 as libc::c_uint) as libc::c_uchar;
        if marker < 2 as libc::c_uint {
            tmp___1 = q;
            q = q.offset(1);
            *tmp___1 = (val >> 8 as libc::c_int & 255 as libc::c_uint) as libc::c_uchar;
        }
        if marker < 1 as libc::c_uint {
            tmp___2 = q;
            q = q.offset(1);
            *tmp___2 = (val & 255 as libc::c_uint) as libc::c_uchar;
        }
        p = p.offset(4 as libc::c_int as isize);
    }
    return q.offset_from(data as *mut libc::c_uchar) as libc::c_long as libc::c_int;
}
#[inline]
unsafe extern "C" fn __bswap_16(mut __bsx: __uint16_t) -> __uint16_t {
    return (__bsx as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int
        | (__bsx as libc::c_int & 255 as libc::c_int) << 8 as libc::c_int) as __uint16_t;
}
#[inline]
unsafe extern "C" fn __bswap_32(mut __bsx: __uint32_t) -> __uint32_t {
    return (__bsx & 4278190080 as libc::c_uint) >> 24 as libc::c_int
        | (__bsx & 16711680 as libc::c_uint) >> 8 as libc::c_int
        | (__bsx & 65280 as libc::c_uint) << 8 as libc::c_int
        | (__bsx & 255 as libc::c_uint) << 24 as libc::c_int;
}
static mut loglevel___2: *mut log_level = unsafe {
    &raop_loglevel as *const log_level as *mut log_level
};
static mut mime_types: [*mut libc::c_char; 4] = [
    b"audio/mpeg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"audio/flac\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"audio/L16;rate=44100;channels=2\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"audio/wav\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
];
static mut wave_header: wave_header_s = {
    let mut init = wave_header_s {
        chunk_id: [
            'R' as i32 as u8_t,
            'I' as i32 as u8_t,
            'F' as i32 as u8_t,
            'F' as i32 as u8_t,
        ],
        chunk_size: [
            36 as libc::c_int as u8_t,
            255 as libc::c_int as u8_t,
            255 as libc::c_int as u8_t,
            255 as libc::c_int as u8_t,
        ],
        format: [
            'W' as i32 as u8_t,
            'A' as i32 as u8_t,
            'V' as i32 as u8_t,
            'E' as i32 as u8_t,
        ],
        subchunk1_id: [
            'f' as i32 as u8_t,
            'm' as i32 as u8_t,
            't' as i32 as u8_t,
            ' ' as i32 as u8_t,
        ],
        subchunk1_size: [
            16 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
        ],
        audio_format: [1 as libc::c_int as u8_t, 0 as libc::c_int as u8_t],
        channels: [2 as libc::c_int as u8_t, 0 as libc::c_int as u8_t],
        sample_rate: [
            68 as libc::c_int as u8_t,
            172 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
        ],
        byte_rate: [
            16 as libc::c_int as u8_t,
            177 as libc::c_int as u8_t,
            2 as libc::c_int as u8_t,
            0 as libc::c_int as u8_t,
        ],
        block_align: [4 as libc::c_int as u8_t, 0 as libc::c_int as u8_t],
        bits_per_sample: [16 as libc::c_int as u8_t, 0 as libc::c_int as u8_t],
        subchunk2_id: [
            'd' as i32 as u8_t,
            'a' as i32 as u8_t,
            't' as i32 as u8_t,
            'a' as i32 as u8_t,
        ],
        subchunk2_size: [
            0 as libc::c_int as u8_t,
            255 as libc::c_int as u8_t,
            255 as libc::c_int as u8_t,
            255 as libc::c_int as u8_t,
        ],
    };
    init
};
unsafe extern "C" fn flac_init(mut ctx: *mut hairtunes_t) {
    let mut ok: bool = false;
    let mut codec: *mut FLAC__StreamEncoder = 0 as *mut FLAC__StreamEncoder;
    let mut tmp: *mut FLAC__StreamEncoder = 0 as *mut FLAC__StreamEncoder;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: FLAC__bool = 0;
    let mut tmp___2: FLAC__bool = 0;
    let mut tmp___3: FLAC__bool = 0;
    let mut tmp___4: FLAC__bool = 0;
    let mut tmp___5: FLAC__bool = 0;
    let mut tmp___6: FLAC__bool = 0;
    let mut tmp___7: FLAC__bool = 0;
    let mut tmp___8: FLAC__StreamEncoderInitStatus = FLAC__STREAM_ENCODER_INIT_STATUS_OK;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    ok = 1 as libc::c_int != 0;
    (*ctx).encode.len = 0 as libc::c_int;
    (*ctx).encode.header = 1 as libc::c_int != 0;
    tmp = FLAC__stream_encoder_new();
    (*ctx).encode.codec = tmp as *mut libc::c_void;
    codec = (*ctx).encode.codec as *mut FLAC__StreamEncoder;
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: Using FLAC-%u (%p)\n\0" as *const u8 as *const libc::c_char,
            tmp___0,
            b"flac_init\0" as *const u8 as *const libc::c_char,
            220 as libc::c_int,
            ctx,
            (*ctx).encode.config.__annonCompField8.flac.level,
            (*ctx).encode.codec,
        );
    }
    tmp___1 = FLAC__stream_encoder_set_verify(codec, 0 as libc::c_int);
    ok = ok as libc::c_int & tmp___1 != 0;
    tmp___2 = FLAC__stream_encoder_set_compression_level(
        codec,
        (*ctx).encode.config.__annonCompField8.flac.level as uint32_t,
    );
    ok = ok as libc::c_int & tmp___2 != 0;
    tmp___3 = FLAC__stream_encoder_set_channels(codec, 2 as libc::c_int as uint32_t);
    ok = ok as libc::c_int & tmp___3 != 0;
    tmp___4 = FLAC__stream_encoder_set_bits_per_sample(
        codec,
        16 as libc::c_int as uint32_t,
    );
    ok = ok as libc::c_int & tmp___4 != 0;
    tmp___5 = FLAC__stream_encoder_set_sample_rate(
        codec,
        44100 as libc::c_int as uint32_t,
    );
    ok = ok as libc::c_int & tmp___5 != 0;
    tmp___6 = FLAC__stream_encoder_set_blocksize(codec, 1024 as libc::c_int as uint32_t);
    ok = ok as libc::c_int & tmp___6 != 0;
    tmp___7 = FLAC__stream_encoder_set_streamable_subset(codec, 1 as libc::c_int);
    ok = ok as libc::c_int & tmp___7 != 0;
    tmp___8 = FLAC__stream_encoder_init_stream(
        codec,
        Some(
            flac_write_callback
                as unsafe extern "C" fn(
                    *const FLAC__StreamEncoder,
                    *const FLAC__byte,
                    size_t,
                    libc::c_uint,
                    libc::c_uint,
                    *mut libc::c_void,
                ) -> FLAC__StreamEncoderWriteStatus,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *const FLAC__StreamEncoder,
                    FLAC__uint64,
                    *mut libc::c_void,
                ) -> FLAC__StreamEncoderSeekStatus,
            >,
        >(0 as *mut libc::c_void),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *const FLAC__StreamEncoder,
                    *mut FLAC__uint64,
                    *mut libc::c_void,
                ) -> FLAC__StreamEncoderTellStatus,
            >,
        >(0 as *mut libc::c_void),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *const FLAC__StreamEncoder,
                    *const FLAC__StreamMetadata,
                    *mut libc::c_void,
                ) -> (),
            >,
        >(0 as *mut libc::c_void),
        ctx as *mut libc::c_void,
    );
    if tmp___8 as u64 != 0 {
        tmp___9 = 0 as libc::c_int;
    } else {
        tmp___9 = 1 as libc::c_int;
    }
    ok = ok as libc::c_int & tmp___9 != 0;
    if !ok {
        tmp___10 = logtime();
        logprint(
            b"%s %s:%d {%p]: Cannot set FLAC parameters\n\0" as *const u8
                as *const libc::c_char,
            tmp___10,
            b"flac_init\0" as *const u8 as *const libc::c_char,
            232 as libc::c_int,
            ctx,
        );
    }
}
unsafe extern "C" fn flac_write_callback(
    mut encoder: *const FLAC__StreamEncoder,
    mut buffer: *const FLAC__byte,
    mut bytes: size_t,
    mut samples: libc::c_uint,
    mut current_frame: libc::c_uint,
    mut client_data: *mut libc::c_void,
) -> FLAC__StreamEncoderWriteStatus {
    let mut ctx: *mut hairtunes_t = 0 as *mut hairtunes_t;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    ctx = client_data as *mut hairtunes_t;
    if ((*ctx).encode.len as size_t).wrapping_add(bytes) <= 5120 as libc::c_ulong {
        memcpy(
            ((*ctx).encode.buffer).as_mut_ptr().offset((*ctx).encode.len as isize)
                as *mut libc::c_void,
            buffer as *const libc::c_void,
            bytes,
        );
        (*ctx)
            .encode
            .len = ((*ctx).encode.len as size_t).wrapping_add(bytes) as libc::c_int;
    } else if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: flac coded buffer too big %u\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"flac_write_callback\0" as *const u8 as *const libc::c_char,
            244 as libc::c_int,
            ctx,
            bytes,
        );
    }
    return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
}
unsafe extern "C" fn mp3_init(mut ctx: *mut hairtunes_t) {
    let mut config: shine_config_t = shine_config_t {
        wave: shine_wave_t {
            channels: 0 as channels,
            samplerate: 0,
        },
        mpeg: shine_mpeg_t {
            mode: STEREO,
            bitr: 0,
            emph: NONE,
            copyright: 0,
            original: 0,
        },
    };
    let mut tmp: shine_t = 0 as *mut shine_global_flags;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    (*ctx).encode.len = 0 as libc::c_int;
    shine_set_config_mpeg_defaults(&mut config.mpeg);
    config.wave.samplerate = 44100 as libc::c_int;
    config.wave.channels = PCM_STEREO;
    if (*ctx).encode.config.__annonCompField8.mp3.bitrate != 0 {
        config.mpeg.bitr = (*ctx).encode.config.__annonCompField8.mp3.bitrate;
    } else {
        config.mpeg.bitr = 128 as libc::c_int;
    }
    config.mpeg.mode = STEREO;
    tmp = shine_initialise(&mut config);
    (*ctx).encode.codec = tmp as *mut libc::c_void;
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: Using shine MP3-%u (%p)\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"mp3_init\0" as *const u8 as *const libc::c_char,
            263 as libc::c_int,
            ctx,
            (*ctx).encode.config.__annonCompField8.mp3.bitrate,
            (*ctx).encode.codec,
        );
    }
}
unsafe extern "C" fn encoder_close(mut ctx: *mut hairtunes_t) {
    let mut len: libc::c_int = 0;
    if ((*ctx).encode.codec).is_null() {
        return;
    }
    if (*ctx).encode.config.codec as libc::c_uint == 1 as libc::c_uint {
        FLAC__stream_encoder_finish((*ctx).encode.codec as *mut FLAC__StreamEncoder);
        FLAC__stream_encoder_delete((*ctx).encode.codec as *mut FLAC__StreamEncoder);
    } else if (*ctx).encode.config.codec as libc::c_uint == 0 as libc::c_uint {
        shine_flush((*ctx).encode.codec as shine_t, &mut len);
        shine_close((*ctx).encode.codec as shine_t);
    }
    (*ctx).encode.codec = 0 as *mut libc::c_void;
}
unsafe extern "C" fn alac_init(mut fmtp: *mut libc::c_int) -> *mut alac_file {
    let mut alac: *mut alac_file = 0 as *mut alac_file;
    let mut sample_size: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    sample_size = *fmtp.offset(3 as libc::c_int as isize);
    if sample_size != 16 as libc::c_int {
        tmp = logtime();
        logprint(
            b"%s %s:%d sample size must be 16 %d\n\0" as *const u8
                as *const libc::c_char,
            tmp,
            b"alac_init\0" as *const u8 as *const libc::c_char,
            288 as libc::c_int,
            sample_size,
        );
        return 0 as *mut alac_file;
    }
    alac = create_alac(sample_size, 2 as libc::c_int);
    if alac.is_null() {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d cannot create alac codec\n\0" as *const u8 as *const libc::c_char,
            tmp___0,
            b"alac_init\0" as *const u8 as *const libc::c_char,
            295 as libc::c_int,
            0 as *mut libc::c_void,
        );
        return 0 as *mut libc::c_void as *mut alac_file;
    }
    (*alac)
        .setinfo_max_samples_per_frame = *fmtp.offset(1 as libc::c_int as isize)
        as uint32_t;
    (*alac).setinfo_7a = *fmtp.offset(2 as libc::c_int as isize) as uint8_t;
    (*alac).setinfo_sample_size = sample_size as uint8_t;
    (*alac)
        .setinfo_rice_historymult = *fmtp.offset(4 as libc::c_int as isize) as uint8_t;
    (*alac)
        .setinfo_rice_initialhistory = *fmtp.offset(5 as libc::c_int as isize)
        as uint8_t;
    (*alac).setinfo_rice_kmodifier = *fmtp.offset(6 as libc::c_int as isize) as uint8_t;
    (*alac).setinfo_7f = *fmtp.offset(7 as libc::c_int as isize) as uint8_t;
    (*alac).setinfo_80 = *fmtp.offset(8 as libc::c_int as isize) as uint16_t;
    (*alac).setinfo_82 = *fmtp.offset(9 as libc::c_int as isize) as uint32_t;
    (*alac).setinfo_86 = *fmtp.offset(10 as libc::c_int as isize) as uint32_t;
    (*alac).setinfo_8a_rate = *fmtp.offset(11 as libc::c_int as isize) as uint32_t;
    allocate_buffers(alac);
    return alac;
}
pub unsafe extern "C" fn hairtunes_init(
    mut host: in_addr,
    mut codec: encode_t,
    mut sync___0: bool,
    mut drift: bool,
    mut range: bool,
    mut latencies: *mut libc::c_char,
    mut aeskey: *mut libc::c_char,
    mut aesiv: *mut libc::c_char,
    mut fmtpstr: *mut libc::c_char,
    mut pCtrlPort: libc::c_ushort,
    mut pTimingPort: libc::c_ushort,
    mut owner: *mut libc::c_void,
    mut event_cb___0: Option::<
        unsafe extern "C" fn(*mut libc::c_void, hairtunes_event_t) -> (),
    >,
    mut http_cb___0: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut key_data_s, *mut key_data_s) -> (),
    >,
    mut port_base: libc::c_ushort,
    mut port_range: libc::c_ushort,
    mut http_length: libc::c_int,
) -> hairtunes_resp_t {
    let mut i: libc::c_int = 0;
    let mut arg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fmtp: [libc::c_int; 12] = [0; 12];
    let mut rc: bool = false;
    let mut ctx: *mut hairtunes_t = 0 as *mut hairtunes_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut resp: hairtunes_resp_t = hairtunes_resp_t {
        cport: 0,
        tport: 0,
        aport: 0,
        hport: 0,
        ctx: 0 as *mut hairtunes_s,
    };
    let mut port: __anonstruct_port_213969425 = __anonstruct_port_213969425 {
        count: 0,
        offset: 0,
    };
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: libc::c_ushort = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: libc::c_ushort = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    i = 0 as libc::c_int;
    rc = 1 as libc::c_int != 0;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<hairtunes_t>() as libc::c_ulong,
    );
    ctx = tmp as *mut hairtunes_t;
    resp.cport = 0 as libc::c_int as libc::c_ushort;
    resp.tport = 0 as libc::c_int as libc::c_ushort;
    resp.aport = 0 as libc::c_int as libc::c_ushort;
    resp.hport = 0 as libc::c_int as libc::c_ushort;
    resp.ctx = 0 as *mut libc::c_void as *mut hairtunes_s;
    port.count = 0 as libc::c_int as libc::c_ushort;
    port.offset = 0 as libc::c_int as libc::c_ushort;
    if port_base == 0 {
        port_range = 1 as libc::c_int as libc::c_ushort;
    }
    tmp___0 = rand();
    port.offset = (tmp___0 % port_range as libc::c_int) as libc::c_ushort;
    if ctx.is_null() {
        return resp;
    }
    tmp___1 = malloc(2097152 as libc::c_int as size_t);
    (*ctx).http_tail = tmp___1 as *mut libc::c_char;
    if ((*ctx).http_tail).is_null() {
        free(ctx as *mut libc::c_void);
        return resp;
    }
    (*ctx).http_length = http_length;
    (*ctx).host = host;
    (*ctx).rtp_host.sin_family = 2 as libc::c_int as sa_family_t;
    (*ctx).rtp_host.sin_addr.s_addr = 0 as libc::c_int as in_addr_t;
    pthread_mutex_init(&mut (*ctx).ab_mutex, 0 as *const pthread_mutexattr_t);
    (*ctx).flush_seqno = -(1 as libc::c_int);
    (*ctx).encode.config = codec;
    (*ctx).encode.header = 0 as libc::c_int != 0;
    (*ctx).latency = atoi(latencies as *const libc::c_char);
    (*ctx).latency = (*ctx).latency * 44100 as libc::c_int / 1000 as libc::c_int;
    tmp___2 = strstr(
        latencies as *const libc::c_char,
        b":f\0" as *const u8 as *const libc::c_char,
    );
    if !tmp___2.is_null() {
        (*ctx).http_fill = 1 as libc::c_int != 0;
    }
    (*ctx).event_cb = event_cb___0;
    (*ctx).http_cb = http_cb___0;
    (*ctx).owner = owner;
    (*ctx).synchro.required = sync___0;
    (*ctx).timing.drift = drift;
    (*ctx).range = range;
    (*ctx).ab_read = ((*ctx).ab_write as libc::c_int + 1 as libc::c_int) as seq_t;
    (*ctx).rtp_sockets[1 as libc::c_int as usize].rport = pCtrlPort;
    (*ctx).rtp_sockets[2 as libc::c_int as usize].rport = pTimingPort;
    if !aesiv.is_null() {
        if !aeskey.is_null() {
            memcpy(
                ((*ctx).aesiv).as_mut_ptr() as *mut libc::c_void,
                aesiv as *const libc::c_void,
                16 as libc::c_int as size_t,
            );
            AES_set_decrypt_key(
                aeskey as *mut libc::c_uchar as *const libc::c_uchar,
                128 as libc::c_int,
                &mut (*ctx).aes,
            );
            (*ctx).decrypt = 1 as libc::c_int != 0;
        }
    }
    memset(
        fmtp.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_int; 12]>() as libc::c_ulong,
    );
    loop {
        arg = strsep(
            &mut fmtpstr as *mut *mut libc::c_char,
            b" \t\0" as *const u8 as *const libc::c_char,
        );
        if !(arg as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        tmp___3 = i;
        i += 1;
        fmtp[tmp___3 as usize] = atoi(arg as *const libc::c_char);
    }
    (*ctx).frame_size = fmtp[1 as libc::c_int as usize];
    tmp___4 = calloc((*ctx).frame_size as size_t, 4 as libc::c_int as size_t);
    (*ctx).silence_frame = tmp___4 as *mut libc::c_char;
    p = strchr(latencies as *const libc::c_char, ':' as i32);
    if p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*ctx).delay = atoi(p.offset(1 as libc::c_int as isize) as *const libc::c_char);
        (*ctx)
            .delay = (*ctx).delay * 44100 as libc::c_int
            / ((*ctx).frame_size * 1000 as libc::c_int);
    }
    (*ctx).alac_codec = alac_init(fmtp.as_mut_ptr());
    rc = rc as libc::c_int
        & ((*ctx).alac_codec as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong)
            as libc::c_int != 0;
    buffer_alloc(
        ((*ctx).audio_buffer).as_mut_ptr(),
        (*ctx).frame_size * 4 as libc::c_int,
    );
    i = 0 as libc::c_int;
    while rc {
        if !(i < 3 as libc::c_int) {
            break;
        }
        loop {
            tmp___5 = port.count;
            port
                .count = (port.count as libc::c_int + 1 as libc::c_int)
                as libc::c_ushort;
            (*ctx)
                .rtp_sockets[i as usize]
                .lport = (port_base as libc::c_int
                + (port.offset as libc::c_int + tmp___5 as libc::c_int)
                    % port_range as libc::c_int) as libc::c_ushort;
            (*ctx)
                .rtp_sockets[i as usize]
                .sock = bind_socket(
                &mut (*((*ctx).rtp_sockets).as_mut_ptr().offset(i as isize)).lport,
                2 as libc::c_int,
            );
            if !((*ctx).rtp_sockets[i as usize].sock < 0 as libc::c_int) {
                break;
            }
            if !((port.count as libc::c_int) < port_range as libc::c_int) {
                break;
            }
        }
        rc = rc as libc::c_int
            & ((*ctx).rtp_sockets[i as usize].sock > 0 as libc::c_int) as libc::c_int
            != 0;
        if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
            tmp___6 = logtime();
            logprint(
                b"%s %s:%d [%p]: UDP port-%d %hu\n\0" as *const u8
                    as *const libc::c_char,
                tmp___6,
                b"hairtunes_init\0" as *const u8 as *const libc::c_char,
                404 as libc::c_int,
                ctx,
                i,
                (*ctx).rtp_sockets[i as usize].lport as libc::c_int,
            );
        }
        i += 1;
    }
    loop {
        tmp___7 = port.count;
        port.count = (port.count as libc::c_int + 1 as libc::c_int) as libc::c_ushort;
        resp
            .hport = (port_base as libc::c_int
            + (port.offset as libc::c_int + tmp___7 as libc::c_int)
                % port_range as libc::c_int) as libc::c_ushort;
        (*ctx).http_listener = bind_socket(&mut resp.hport, 1 as libc::c_int);
        if !((*ctx).http_listener < 0 as libc::c_int) {
            break;
        }
        if !((port.count as libc::c_int) < port_range as libc::c_int) {
            break;
        }
    }
    i = 131072 as libc::c_int;
    setsockopt(
        (*ctx).http_listener,
        1 as libc::c_int,
        7 as libc::c_int,
        &mut i as *mut libc::c_int as *mut libc::c_void as *const libc::c_void,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
    rc = rc as libc::c_int & ((*ctx).http_listener > 0 as libc::c_int) as libc::c_int
        != 0;
    tmp___8 = listen((*ctx).http_listener, 1 as libc::c_int);
    rc = rc as libc::c_int & (tmp___8 == 0 as libc::c_int) as libc::c_int != 0;
    resp.cport = (*ctx).rtp_sockets[1 as libc::c_int as usize].lport;
    resp.tport = (*ctx).rtp_sockets[2 as libc::c_int as usize].lport;
    resp.aport = (*ctx).rtp_sockets[0 as libc::c_int as usize].lport;
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___9 = logtime();
        logprint(
            b"%s %s:%d [%p]: HTTP listening port %hu\n\0" as *const u8
                as *const libc::c_char,
            tmp___9,
            b"hairtunes_init\0" as *const u8 as *const libc::c_char,
            422 as libc::c_int,
            ctx,
            resp.hport as libc::c_int,
        );
    }
    if rc {
        (*ctx).running = 1 as libc::c_int != 0;
        pthread_create(
            &mut (*ctx).rtp_thread as *mut pthread_t,
            0 as *mut libc::c_void as *const pthread_attr_t,
            Some(
                rtp_thread_func
                    as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
            ),
            ctx as *mut libc::c_void,
        );
        pthread_create(
            &mut (*ctx).http_thread as *mut pthread_t,
            0 as *mut libc::c_void as *const pthread_attr_t,
            Some(
                http_thread_func
                    as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
            ),
            ctx as *mut libc::c_void,
        );
    } else {
        hairtunes_end(ctx);
        ctx = 0 as *mut libc::c_void as *mut hairtunes_t;
    }
    resp.ctx = ctx;
    return resp;
}
pub unsafe extern "C" fn hairtunes_metadata(
    mut ctx: *mut hairtunes_s,
    mut metadata: *mut metadata_s,
) {
    pthread_mutex_lock(&mut (*ctx).ab_mutex);
    free_metadata(&mut (*ctx).metadata);
    dup_metadata(&mut (*ctx).metadata, metadata);
    (*ctx).icy.updated = 1 as libc::c_int != 0;
    pthread_mutex_unlock(&mut (*ctx).ab_mutex);
}
pub unsafe extern "C" fn hairtunes_end(mut ctx: *mut hairtunes_s) {
    let mut i: libc::c_int = 0;
    if ctx.is_null() {
        return;
    }
    if (*ctx).running {
        (*ctx).running = 0 as libc::c_int != 0;
        pthread_join(
            (*ctx).rtp_thread,
            0 as *mut libc::c_void as *mut *mut libc::c_void,
        );
        pthread_join(
            (*ctx).http_thread,
            0 as *mut libc::c_void as *mut *mut libc::c_void,
        );
    }
    shutdown_socket((*ctx).http_listener);
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        if (*ctx).rtp_sockets[i as usize].sock > 0 as libc::c_int {
            close((*ctx).rtp_sockets[i as usize].sock);
        }
        i += 1;
    }
    delete_alac((*ctx).alac_codec);
    if !((*ctx).encode.codec).is_null() {
        if (*ctx).encode.config.codec as libc::c_uint == 1 as libc::c_uint {
            FLAC__stream_encoder_finish((*ctx).encode.codec as *mut FLAC__StreamEncoder);
            FLAC__stream_encoder_delete((*ctx).encode.codec as *mut FLAC__StreamEncoder);
        } else if (*ctx).encode.config.codec as libc::c_uint == 0 as libc::c_uint {
            shine_close((*ctx).encode.codec as shine_t);
        }
    }
    pthread_mutex_destroy(&mut (*ctx).ab_mutex);
    buffer_release(((*ctx).audio_buffer).as_mut_ptr());
    free((*ctx).silence_frame as *mut libc::c_void);
    free((*ctx).http_tail as *mut libc::c_void);
    free_metadata(&mut (*ctx).metadata);
    free(ctx as *mut libc::c_void);
}
pub unsafe extern "C" fn hairtunes_flush(
    mut ctx: *mut hairtunes_s,
    mut seqno: libc::c_ushort,
    mut rtptime: libc::c_uint,
    mut exit_locked: bool,
    mut silence: bool,
) -> bool {
    let mut rc: bool = false;
    let mut now: u32_t = 0;
    let mut tmp: u32_t = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    rc = 1 as libc::c_int != 0;
    tmp = gettime_ms();
    now = tmp;
    if now < ((*ctx).record.time).wrapping_add(250 as libc::c_uint) {
        rc = 0 as libc::c_int != 0;
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: FLUSH ignored as same as RECORD (%hu - %u)\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"hairtunes_flush\0" as *const u8 as *const libc::c_char,
            495 as libc::c_int,
            ctx,
            seqno as libc::c_int,
            rtptime,
        );
    } else {
        let mut current_block_24: u64;
        if (*ctx).record.seqno as libc::c_int == seqno as libc::c_int {
            if (*ctx).record.rtptime == rtptime {
                rc = 0 as libc::c_int != 0;
                tmp___0 = logtime();
                logprint(
                    b"%s %s:%d [%p]: FLUSH ignored as same as RECORD (%hu - %u)\n\0"
                        as *const u8 as *const libc::c_char,
                    tmp___0,
                    b"hairtunes_flush\0" as *const u8 as *const libc::c_char,
                    495 as libc::c_int,
                    ctx,
                    seqno as libc::c_int,
                    rtptime,
                );
                current_block_24 = 11298138898191919651;
            } else {
                current_block_24 = 6627675968226661749;
            }
        } else {
            current_block_24 = 6627675968226661749;
        }
        match current_block_24 {
            6627675968226661749 => {
                pthread_mutex_lock(&mut (*ctx).ab_mutex);
                buffer_reset(((*ctx).audio_buffer).as_mut_ptr());
                (*ctx).flush_seqno = seqno as libc::c_int;
                if silence {
                    (*ctx).pause = 1 as libc::c_int != 0;
                } else {
                    (*ctx).playing = 0 as libc::c_int != 0;
                    (*ctx).synchro.first = 0 as libc::c_int != 0;
                    (*ctx).http_ready = 0 as libc::c_int != 0;
                    encoder_close(ctx);
                }
                if !exit_locked {
                    pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                }
            }
            _ => {}
        }
    }
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___1 = logtime();
        logprint(
            b"%s %s:%d [%p]: flush %hu %u\n\0" as *const u8 as *const libc::c_char,
            tmp___1,
            b"hairtunes_flush\0" as *const u8 as *const libc::c_char,
            511 as libc::c_int,
            ctx,
            seqno as libc::c_int,
            rtptime,
        );
    }
    return rc;
}
pub unsafe extern "C" fn hairtunes_flush_release(mut ctx: *mut hairtunes_s) {
    pthread_mutex_unlock(&mut (*ctx).ab_mutex);
}
pub unsafe extern "C" fn hairtunes_record(
    mut ctx: *mut hairtunes_s,
    mut seqno: libc::c_ushort,
    mut rtptime: libc::c_uint,
) {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    (*ctx).record.seqno = seqno;
    (*ctx).record.rtptime = rtptime;
    (*ctx).record.time = gettime_ms();
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d [%p]: record %hu %u\n\0" as *const u8 as *const libc::c_char,
            tmp,
            b"hairtunes_record\0" as *const u8 as *const libc::c_char,
            529 as libc::c_int,
            ctx,
            seqno as libc::c_int,
            rtptime,
        );
    }
}
unsafe extern "C" fn buffer_alloc(mut audio_buffer: *mut abuf_t, mut size: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    i = 0 as libc::c_int;
    while i < 1024 as libc::c_int {
        tmp = malloc(size as size_t);
        let ref mut fresh0 = (*audio_buffer.offset(i as isize)).data;
        *fresh0 = tmp as *mut s16_t;
        (*audio_buffer.offset(i as isize)).ready = 0 as libc::c_int;
        i += 1;
    }
}
unsafe extern "C" fn buffer_release(mut audio_buffer: *mut abuf_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1024 as libc::c_int {
        free((*audio_buffer.offset(i as isize)).data as *mut libc::c_void);
        i += 1;
    }
}
unsafe extern "C" fn buffer_reset(mut audio_buffer: *mut abuf_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1024 as libc::c_int {
        (*audio_buffer.offset(i as isize)).ready = 0 as libc::c_int;
        i += 1;
    }
}
unsafe extern "C" fn seq_order(mut a: seq_t, mut b: seq_t) -> libc::c_int {
    let mut d: s16_t = 0;
    d = (b as libc::c_int - a as libc::c_int) as s16_t;
    return (d as libc::c_int > 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn alac_decode(
    mut ctx: *mut hairtunes_t,
    mut dest: *mut s16_t,
    mut buf___0: *mut libc::c_char,
    mut len: libc::c_int,
    mut outsize: *mut libc::c_int,
) {
    let mut packet: [libc::c_uchar; 2048] = [0; 2048];
    let mut iv: [libc::c_uchar; 16] = [0; 16];
    let mut aeslen: libc::c_int = 0;
    if (*ctx).decrypt {
        aeslen = len & -(16 as libc::c_int);
        memcpy(
            iv.as_mut_ptr() as *mut libc::c_void,
            ((*ctx).aesiv).as_mut_ptr() as *const libc::c_void,
            ::std::mem::size_of::<[libc::c_uchar; 16]>() as libc::c_ulong,
        );
        AES_cbc_encrypt(
            buf___0 as *mut libc::c_uchar as *const libc::c_uchar,
            packet.as_mut_ptr(),
            aeslen as size_t,
            &mut (*ctx).aes as *mut AES_KEY as *const AES_KEY,
            iv.as_mut_ptr(),
            0 as libc::c_int,
        );
        memcpy(
            packet.as_mut_ptr().offset(aeslen as isize) as *mut libc::c_void,
            buf___0.offset(aeslen as isize) as *const libc::c_void,
            (len - aeslen) as size_t,
        );
        decode_frame(
            (*ctx).alac_codec,
            packet.as_mut_ptr(),
            dest as *mut libc::c_void,
            outsize,
        );
    } else {
        decode_frame(
            (*ctx).alac_codec,
            buf___0 as *mut libc::c_uchar,
            dest as *mut libc::c_void,
            outsize,
        );
    };
}
unsafe extern "C" fn buffer_put_packet(
    mut ctx: *mut hairtunes_t,
    mut seqno: seq_t,
    mut rtptime: libc::c_uint,
    mut first: bool,
    mut data: *mut libc::c_char,
    mut len: libc::c_int,
) {
    let mut abuf: *mut abuf_t = 0 as *mut abuf_t;
    let mut tmp: u32_t = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut i: seq_t = 0;
    let mut now: u32_t = 0;
    let mut tmp___7: u32_t = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: bool = false;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    abuf = 0 as *mut libc::c_void as *mut abuf_t;
    pthread_mutex_lock(&mut (*ctx).ab_mutex);
    if !(*ctx).playing {
        if !((*ctx).flush_seqno == -(1 as libc::c_int)) {
            tmp___0 = seq_order((*ctx).flush_seqno as seq_t, seqno);
            if !(tmp___0 != 0) {
                pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                return;
            }
        }
        let mut current_block_25: u64;
        if (*ctx).synchro.required {
            if (*ctx).synchro.first {
                current_block_25 = 9203816664663851234;
            } else {
                current_block_25 = 1918571039762985921;
            }
        } else {
            current_block_25 = 1918571039762985921;
        }
        match current_block_25 {
            1918571039762985921 => {
                if (*ctx).synchro.required {
                    pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                    return;
                }
            }
            _ => {}
        }
        (*ctx).ab_write = (seqno as libc::c_int - 1 as libc::c_int) as seq_t;
        (*ctx).ab_read = seqno;
        (*ctx).skip = 0 as libc::c_int;
        (*ctx).flush_seqno = -(1 as libc::c_int);
        (*ctx).playing = 1 as libc::c_int != 0;
        (*ctx).silence = 1 as libc::c_int != 0;
        (*ctx).synchro.first = 0 as libc::c_int != 0;
        tmp = 0 as libc::c_int as u32_t;
        (*ctx).silent_frames = tmp;
        (*ctx).resent_frames = tmp;
        (*ctx).http_count = 0 as libc::c_int as size_t;
        if (*ctx).encode.config.codec as libc::c_uint == 1 as libc::c_uint {
            flac_init(ctx);
        } else if (*ctx).encode.config.codec as libc::c_uint == 0 as libc::c_uint {
            mp3_init(ctx);
        } else if (*ctx).encode.config.codec as libc::c_uint == 3 as libc::c_uint {
            (*ctx).encode.header = 1 as libc::c_int != 0;
        }
    }
    if (*ctx).pause {
        tmp___1 = seq_order((*ctx).flush_seqno as seq_t, seqno);
        if tmp___1 != 0 {
            (*ctx).pause = 0 as libc::c_int != 0;
        }
    }
    if seqno as libc::c_int
        == ((*ctx).ab_write as libc::c_int + 1 as libc::c_int) as u16_t as libc::c_int
    {
        abuf = ((*ctx).audio_buffer)
            .as_mut_ptr()
            .offset((seqno as libc::c_int % 1024 as libc::c_int) as isize);
        (*ctx).ab_write = seqno;
        if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
            tmp___2 = logtime();
            logprint(
                b"%s %s:%d [%p]: packet expected seqno:%hu rtptime:%u (W:%hu R:%hu)\n\0"
                    as *const u8 as *const libc::c_char,
                tmp___2,
                b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                614 as libc::c_int,
                ctx,
                seqno as libc::c_int,
                rtptime,
                (*ctx).ab_write as libc::c_int,
                (*ctx).ab_read as libc::c_int,
            );
        }
    } else {
        tmp___14 = seq_order((*ctx).ab_write, seqno);
        if tmp___14 != 0 {
            if (*ctx).latency != 0 {
                tmp___4 = seq_order(
                    ((*ctx).latency / (*ctx).frame_size) as seq_t,
                    (seqno as libc::c_int - (*ctx).ab_write as libc::c_int
                        - 1 as libc::c_int) as seq_t,
                );
                if tmp___4 != 0 {
                    if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
                        tmp___3 = logtime();
                        logprint(
                            b"%s %s:%d [%p] too many missing frames %hu\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___3,
                            b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                            619 as libc::c_int,
                            ctx,
                            seqno as libc::c_int - (*ctx).ab_write as libc::c_int
                                - 1 as libc::c_int,
                        );
                    }
                    (*ctx)
                        .ab_write = (seqno as libc::c_int
                        - (*ctx).latency / (*ctx).frame_size) as seq_t;
                }
            }
            if (*ctx).delay != 0 {
                tmp___6 = seq_order(
                    (*ctx).delay as seq_t,
                    (seqno as libc::c_int - (*ctx).ab_read as libc::c_int) as seq_t,
                );
                if tmp___6 != 0 {
                    if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
                        tmp___5 = logtime();
                        logprint(
                            b"%s %s:%d [%p] on hold for too long %hu\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___5,
                            b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                            624 as libc::c_int,
                            ctx,
                            seqno as libc::c_int - (*ctx).ab_read as libc::c_int
                                + 1 as libc::c_int,
                        );
                    }
                    (*ctx)
                        .ab_read = (seqno as libc::c_int - (*ctx).delay
                        + 1 as libc::c_int) as seq_t;
                }
            }
            tmp___9 = rtp_request_resend(
                ctx,
                ((*ctx).ab_write as libc::c_int + 1 as libc::c_int) as seq_t,
                (seqno as libc::c_int - 1 as libc::c_int) as seq_t,
            );
            if tmp___9 {
                tmp___7 = gettime_ms();
                now = tmp___7;
                i = ((*ctx).ab_write as libc::c_int + 1 as libc::c_int) as seq_t;
                loop {
                    tmp___8 = seq_order(i, seqno);
                    if tmp___8 == 0 {
                        break;
                    }
                    (*ctx)
                        .audio_buffer[(i as libc::c_int % 1024 as libc::c_int) as usize]
                        .rtptime = rtptime
                        .wrapping_sub(
                            ((seqno as libc::c_int - i as libc::c_int)
                                * (*ctx).frame_size) as libc::c_uint,
                        );
                    (*ctx)
                        .audio_buffer[(i as libc::c_int % 1024 as libc::c_int) as usize]
                        .last_resend = now;
                    i = (i as libc::c_int + 1 as libc::c_int) as seq_t;
                }
            }
            if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
                tmp___10 = logtime();
                logprint(
                    b"%s %s:%d [%p]: packet newer seqno:%hu rtptime:%u (W:%hu R:%hu)\n\0"
                        as *const u8 as *const libc::c_char,
                    tmp___10,
                    b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                    635 as libc::c_int,
                    ctx,
                    seqno as libc::c_int,
                    rtptime,
                    (*ctx).ab_write as libc::c_int,
                    (*ctx).ab_read as libc::c_int,
                );
            }
            abuf = ((*ctx).audio_buffer)
                .as_mut_ptr()
                .offset((seqno as libc::c_int % 1024 as libc::c_int) as isize);
            (*ctx).ab_write = seqno;
        } else {
            tmp___13 = seq_order(
                (*ctx).ab_read,
                (seqno as libc::c_int + 1 as libc::c_int) as seq_t,
            );
            if tmp___13 != 0 {
                abuf = ((*ctx).audio_buffer)
                    .as_mut_ptr()
                    .offset((seqno as libc::c_int % 1024 as libc::c_int) as isize);
                if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
                    tmp___11 = logtime();
                    logprint(
                        b"%s %s:%d [%p]: packet recovered seqno:%hu rtptime:%u (W:%hu R:%hu)\n\0"
                            as *const u8 as *const libc::c_char,
                        tmp___11,
                        b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                        641 as libc::c_int,
                        ctx,
                        seqno as libc::c_int,
                        rtptime,
                        (*ctx).ab_write as libc::c_int,
                        (*ctx).ab_read as libc::c_int,
                    );
                }
            } else if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
                tmp___12 = logtime();
                logprint(
                    b"%s %s:%d [%p]: packet too late seqno:%hu rtptime:%u (W:%hu R:%hu)\n\0"
                        as *const u8 as *const libc::c_char,
                    tmp___12,
                    b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                    644 as libc::c_int,
                    ctx,
                    seqno as libc::c_int,
                    rtptime,
                    (*ctx).ab_write as libc::c_int,
                    (*ctx).ab_read as libc::c_int,
                );
            }
        }
    }
    tmp___16 = (*ctx).in_frames;
    (*ctx).in_frames += 1;
    if tmp___16 & 511 as libc::c_int == 0 {
        if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
            tmp___15 = logtime();
            logprint(
                b"%s %s:%d [%p]: fill [level:%hu] [W:%hu R:%hu]\n\0" as *const u8
                    as *const libc::c_char,
                tmp___15,
                b"buffer_put_packet\0" as *const u8 as *const libc::c_char,
                648 as libc::c_int,
                ctx,
                (*ctx).ab_write as libc::c_int - (*ctx).ab_read as libc::c_int
                    + 1 as libc::c_int,
                (*ctx).ab_write as libc::c_int,
                (*ctx).ab_read as libc::c_int,
            );
        }
    }
    if !abuf.is_null() {
        alac_decode(ctx, (*abuf).data, data, len, &mut (*abuf).len);
        (*abuf).ready = 1 as libc::c_int;
        (*abuf).rtptime = rtptime;
        if (*ctx).silence {
            tmp___17 = memcmp(
                (*abuf).data as *const libc::c_void,
                (*ctx).silence_frame as *const libc::c_void,
                (*abuf).len as size_t,
            );
            if tmp___17 != 0 {
                (Some(((*ctx).event_cb).expect("non-null function pointer")))
                    .expect("non-null function pointer")((*ctx).owner, HAIRTUNES_PLAY);
                (*ctx).silence = 0 as libc::c_int != 0;
            }
        }
    }
    pthread_mutex_unlock(&mut (*ctx).ab_mutex);
}
unsafe extern "C" fn rtp_thread_func(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut fds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut i: libc::c_int = 0;
    let mut sock: libc::c_int = 0;
    let mut count___0: libc::c_int = 0;
    let mut ntp_sent: bool = false;
    let mut ctx: *mut hairtunes_t = 0 as *mut hairtunes_t;
    let mut plen: ssize_t = 0;
    let mut type_0: libc::c_char = 0;
    let mut packet: [libc::c_char; 2048] = [0; 2048];
    let mut rtp_client_len: socklen_t = 0;
    let mut idx: libc::c_int = 0;
    let mut pktp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut timeout: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut seqno: seq_t = 0;
    let mut rtptime: libc::c_uint = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut rtp_now_latency: u32_t = 0;
    let mut tmp___3: __uint32_t = 0;
    let mut remote: u64_t = 0;
    let mut tmp___4: __uint32_t = 0;
    let mut tmp___5: __uint32_t = 0;
    let mut rtp_now: u32_t = 0;
    let mut tmp___6: __uint32_t = 0;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: u32_t = 0;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: libc::c_int = 0;
    let mut expected: u64_t = 0;
    let mut delta: s64_t = 0;
    let mut reference: u32_t = 0;
    let mut tmp___11: __uint32_t = 0;
    let mut remote___0: u64_t = 0;
    let mut tmp___12: __uint32_t = 0;
    let mut tmp___13: __uint32_t = 0;
    let mut roundtrip: u32_t = 0;
    let mut tmp___14: u32_t = 0;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___19: u32_t = 0;
    let mut tmp___20: u32_t = 0;
    let mut tmp___21: libc::c_longlong = 0;
    let mut tmp___22: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___23: *const libc::c_char = 0 as *const libc::c_char;
    sock = -(1 as libc::c_int);
    count___0 = 0 as libc::c_int;
    ctx = arg as *mut hairtunes_t;
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        if (*ctx).rtp_sockets[i as usize].sock > sock {
            sock = (*ctx).rtp_sockets[i as usize].sock;
        }
        ntp_sent = rtp_request_timing(ctx);
        i += 1;
    }
    while (*ctx).running {
        rtp_client_len = ::std::mem::size_of::<sockaddr_storage>() as libc::c_ulong
            as socklen_t;
        idx = 0 as libc::c_int;
        pktp = packet.as_mut_ptr();
        timeout.tv_sec = 0 as libc::c_int as __time_t;
        timeout.tv_usec = 50000 as libc::c_int as __suseconds_t;
        let fresh1 = &mut __d0;
        let fresh2;
        let fresh3 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh4 = &mut __d1;
        let fresh5;
        let fresh6 = &mut *(fds.fds_bits).as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh1,
            fresh3) => fresh2, inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh4,
            fresh6) => fresh5, inlateout("ax") 0 as libc::c_int => _,
            options(preserves_flags, att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh1, fresh3, fresh2);
        c2rust_asm_casts::AsmCast::cast_out(fresh4, fresh6, fresh5);
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            fds
                .fds_bits[((*ctx).rtp_sockets[i as usize].sock
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                |= ((1 as libc::c_ulong)
                    << (*ctx).rtp_sockets[i as usize].sock
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask;
            i += 1;
        }
        tmp = select(
            sock + 1 as libc::c_int,
            &mut fds as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut timeout as *mut timeval,
        );
        if tmp <= 0 as libc::c_int {
            continue;
        }
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            if fds
                .fds_bits[((*ctx).rtp_sockets[i as usize].sock
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << (*ctx).rtp_sockets[i as usize].sock
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                idx = i;
            }
            i += 1;
        }
        plen = recvfrom(
            (*ctx).rtp_sockets[idx as usize].sock,
            packet.as_mut_ptr() as *mut libc::c_void,
            ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong,
            0 as libc::c_int,
            &mut (*ctx).rtp_host as *mut sockaddr_in as *mut sockaddr,
            &mut rtp_client_len as *mut socklen_t,
        );
        if !ntp_sent {
            if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
                tmp___0 = logtime();
                logprint(
                    b"%s %s:%d [%p]: NTP request not send yet\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___0,
                    b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                    702 as libc::c_int,
                    ctx,
                );
            }
            ntp_sent = rtp_request_timing(ctx);
        }
        if plen < 0 as libc::c_long {
            continue;
        }
        type_0 = (packet[1 as libc::c_int as usize] as libc::c_int
            & -(129 as libc::c_int)) as libc::c_char;
        pktp = packet.as_mut_ptr();
        let mut current_block_156: u64;
        match type_0 as libc::c_int {
            86 => {
                pktp = pktp.offset(4 as libc::c_int as isize);
                plen -= 4 as libc::c_long;
                current_block_156 = 13825665606959520602;
            }
            96 => {
                current_block_156 = 13825665606959520602;
            }
            84 => {
                tmp___3 = __bswap_32(
                    *(pktp.offset(4 as libc::c_int as isize) as *mut u32_t),
                );
                rtp_now_latency = tmp___3;
                tmp___4 = __bswap_32(
                    *(pktp.offset(8 as libc::c_int as isize) as *mut u32_t),
                );
                tmp___5 = __bswap_32(
                    *(pktp.offset(12 as libc::c_int as isize) as *mut u32_t),
                );
                remote = ((tmp___4 as u64_t) << 32 as libc::c_int)
                    .wrapping_add(tmp___5 as u64_t);
                tmp___6 = __bswap_32(
                    *(pktp.offset(16 as libc::c_int as isize) as *mut u32_t),
                );
                rtp_now = tmp___6;
                pthread_mutex_lock(&mut (*ctx).ab_mutex);
                if (*ctx).latency == 0 {
                    (*ctx)
                        .latency = rtp_now.wrapping_sub(rtp_now_latency) as libc::c_int;
                }
                (*ctx).synchro.rtp = rtp_now.wrapping_sub((*ctx).latency as u32_t);
                (*ctx)
                    .synchro
                    .time = ((*ctx).timing.local)
                    .wrapping_add(
                        ((remote.wrapping_sub((*ctx).timing.remote) >> 10 as libc::c_int)
                            .wrapping_mul(1000 as libc::c_ulong) >> 22 as libc::c_int)
                            as u32_t as u64_t,
                    ) as u32_t;
                (*ctx)
                    .synchro
                    .status = ((*ctx).synchro.status as libc::c_int | 1 as libc::c_int)
                    as u8_t;
                if packet[0 as libc::c_int as usize] as libc::c_int & 16 as libc::c_int
                    != 0
                {
                    (*ctx).synchro.first = 1 as libc::c_int != 0;
                    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                        tmp___7 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: 1st sync packet received\n\0" as *const u8
                                as *const libc::c_char,
                            tmp___7,
                            b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                            764 as libc::c_int,
                            ctx,
                        );
                    }
                }
                pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
                    tmp___8 = gettime_ms();
                    tmp___9 = logtime();
                    logprint(
                        b"%s %s:%d [%p]: sync packet rtp_latency:%u rtp:%u remote ntp:%Lx, local time %u (now:%u)\n\0"
                            as *const u8 as *const libc::c_char,
                        tmp___9,
                        b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                        770 as libc::c_int,
                        ctx,
                        rtp_now_latency,
                        rtp_now,
                        remote,
                        (*ctx).synchro.time,
                        tmp___8,
                    );
                }
                tmp___10 = count___0;
                count___0 -= 1;
                if tmp___10 == 0 {
                    rtp_request_timing(ctx);
                    count___0 = 3 as libc::c_int;
                }
                current_block_156 = 13466984173070679938;
            }
            83 => {
                delta = 0 as libc::c_int as s64_t;
                tmp___11 = __bswap_32(
                    *(pktp.offset(12 as libc::c_int as isize) as *mut u32_t),
                );
                reference = tmp___11;
                tmp___12 = __bswap_32(
                    *(pktp.offset(16 as libc::c_int as isize) as *mut u32_t),
                );
                tmp___13 = __bswap_32(
                    *(pktp.offset(20 as libc::c_int as isize) as *mut u32_t),
                );
                remote___0 = ((tmp___12 as u64_t) << 32 as libc::c_int)
                    .wrapping_add(tmp___13 as u64_t);
                tmp___14 = gettime_ms();
                roundtrip = tmp___14.wrapping_sub(reference);
                if roundtrip > 100 as libc::c_uint {
                    if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
                        tmp___15 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: discarding NTP roundtrip of %u ms\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___15,
                            b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                            790 as libc::c_int,
                            ctx,
                            roundtrip,
                        );
                    }
                } else {
                    expected = ((*ctx).timing.remote)
                        .wrapping_add(
                            ((reference as u64_t).wrapping_sub((*ctx).timing.local)
                                << 22 as libc::c_int)
                                .wrapping_div(1000 as libc::c_ulong) << 10 as libc::c_int,
                        );
                    (*ctx).timing.remote = remote___0;
                    (*ctx).timing.local = reference as u64_t;
                    (*ctx).timing.count = ((*ctx).timing.count).wrapping_add(1);
                    if !(*ctx).timing.drift {
                        if (*ctx).synchro.status as libc::c_int & 2 as libc::c_int != 0 {
                            delta = (expected as s64_t - (*ctx).timing.remote as s64_t
                                >> 10 as libc::c_int) * 1000 as libc::c_long
                                >> 22 as libc::c_int;
                            (*ctx).timing.gap_sum += delta;
                            pthread_mutex_lock(&mut (*ctx).ab_mutex);
                            let mut current_block_141: u64;
                            if (*ctx).timing.gap_sum > 8 as libc::c_long {
                                tmp___20 = (*ctx).timing.gap_count;
                                (*ctx)
                                    .timing
                                    .gap_count = ((*ctx).timing.gap_count).wrapping_add(1);
                                if tmp___20 > 20 as libc::c_uint {
                                    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                                        tmp___16 = logtime();
                                        logprint(
                                            b"%s %s:%d [%p]: Sending packets too fast %Ld [W:%hu R:%hu]\n\0"
                                                as *const u8 as *const libc::c_char,
                                            tmp___16,
                                            b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                                            817 as libc::c_int,
                                            ctx,
                                            (*ctx).timing.gap_sum,
                                            (*ctx).ab_write as libc::c_int,
                                            (*ctx).ab_read as libc::c_int,
                                        );
                                    }
                                    (*ctx)
                                        .ab_read = ((*ctx).ab_read as libc::c_int
                                        - 1 as libc::c_int) as seq_t;
                                    (*ctx)
                                        .audio_buffer[((*ctx).ab_read as libc::c_int
                                            % 1024 as libc::c_int) as usize]
                                        .ready = 1 as libc::c_int;
                                    (*ctx).timing.gap_sum -= 8 as libc::c_long;
                                    (*ctx).timing.gap_adjust -= 8 as libc::c_long;
                                    current_block_141 = 16981061190961355901;
                                } else {
                                    current_block_141 = 10317688821501094214;
                                }
                            } else {
                                current_block_141 = 10317688821501094214;
                            }
                            match current_block_141 {
                                10317688821501094214 => {
                                    if (*ctx).timing.gap_sum < -(8 as libc::c_long) {
                                        tmp___19 = (*ctx).timing.gap_count;
                                        (*ctx)
                                            .timing
                                            .gap_count = ((*ctx).timing.gap_count).wrapping_add(1);
                                        if tmp___19 > 20 as libc::c_uint {
                                            tmp___17 = seq_order((*ctx).ab_read, (*ctx).ab_write);
                                            if tmp___17 != 0 {
                                                (*ctx)
                                                    .audio_buffer[((*ctx).ab_read as libc::c_int
                                                        % 1024 as libc::c_int) as usize]
                                                    .ready = 0 as libc::c_int;
                                                (*ctx)
                                                    .ab_read = ((*ctx).ab_read as libc::c_int
                                                    + 1 as libc::c_int) as seq_t;
                                            } else {
                                                (*ctx).skip += 1;
                                            }
                                            (*ctx).timing.gap_sum += 8 as libc::c_long;
                                            (*ctx).timing.gap_adjust += 8 as libc::c_long;
                                            if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                                                tmp___18 = logtime();
                                                logprint(
                                                    b"%s %s:%d [%p]: Sending packets too slow %Ld (skip: %d)  [W:%hu R:%hu]\n\0"
                                                        as *const u8 as *const libc::c_char,
                                                    tmp___18,
                                                    b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                                                    834 as libc::c_int,
                                                    ctx,
                                                    (*ctx).timing.gap_sum,
                                                    (*ctx).skip,
                                                    (*ctx).ab_write as libc::c_int,
                                                    (*ctx).ab_read as libc::c_int,
                                                );
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            tmp___21 = llabs((*ctx).timing.gap_sum as libc::c_longlong);
                            if tmp___21 < 8 as libc::c_longlong {
                                (*ctx).timing.gap_count = 0 as libc::c_int as u32_t;
                            }
                            pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                        }
                    }
                    (*ctx)
                        .synchro
                        .status = ((*ctx).synchro.status as libc::c_int
                        | 2 as libc::c_int) as u8_t;
                    if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
                        tmp___22 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: Timing references local:%Lu, remote:%Lx (delta:%Ld, sum:%Ld, adjust:%Ld, gaps:%d)\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___22,
                            b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                            846 as libc::c_int,
                            ctx,
                            (*ctx).timing.local,
                            (*ctx).timing.remote,
                            delta,
                            (*ctx).timing.gap_sum,
                            (*ctx).timing.gap_adjust,
                            (*ctx).timing.gap_count,
                        );
                    }
                }
                current_block_156 = 13466984173070679938;
            }
            _ => {
                current_block_156 = 13466984173070679938;
            }
        }
        match current_block_156 {
            13825665606959520602 => {
                seqno = __bswap_16(
                    *(pktp.offset(2 as libc::c_int as isize) as *mut u16_t),
                );
                rtptime = __bswap_32(
                    *(pktp.offset(4 as libc::c_int as isize) as *mut u32_t),
                );
                pktp = pktp.offset(12 as libc::c_int as isize);
                plen -= 12 as libc::c_long;
                if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
                    tmp___1 = logtime();
                    logprint(
                        b"%s %s:%d [%p]: seqno:%hu rtp:%u (type: %x, first: %u)\n\0"
                            as *const u8 as *const libc::c_char,
                        tmp___1,
                        b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                        731 as libc::c_int,
                        ctx,
                        seqno as libc::c_int,
                        rtptime,
                        type_0 as libc::c_int,
                        packet[1 as libc::c_int as usize] as libc::c_int
                            & 128 as libc::c_int,
                    );
                }
                if !(plen < 16 as libc::c_long) {
                    if packet[1 as libc::c_int as usize] as libc::c_int
                        & 128 as libc::c_int != 0
                    {
                        if type_0 as libc::c_int != 86 as libc::c_int {
                            if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                                tmp___2 = logtime();
                                logprint(
                                    b"%s %s:%d [%p]: 1st audio packet received\n\0" as *const u8
                                        as *const libc::c_char,
                                    tmp___2,
                                    b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
                                    737 as libc::c_int,
                                    ctx,
                                );
                            }
                        }
                    }
                    buffer_put_packet(
                        ctx,
                        seqno,
                        rtptime,
                        packet[1 as libc::c_int as usize] as libc::c_int
                            & 128 as libc::c_int != 0,
                        pktp,
                        plen as libc::c_int,
                    );
                }
            }
            _ => {}
        }
    }
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___23 = logtime();
        logprint(
            b"%s %s:%d [%p]: terminating\n\0" as *const u8 as *const libc::c_char,
            tmp___23,
            b"rtp_thread_func\0" as *const u8 as *const libc::c_char,
            853 as libc::c_int,
            ctx,
        );
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn rtp_request_timing(mut ctx: *mut hairtunes_t) -> bool {
    let mut req: [libc::c_uchar; 32] = [0; 32];
    let mut now: u32_t = 0;
    let mut tmp: u32_t = 0;
    let mut i: libc::c_int = 0;
    let mut host: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: ssize_t = 0;
    tmp = gettime_ms();
    now = tmp;
    if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d [%p]: timing request now:%u (port: %hu)\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"rtp_request_timing\0" as *const u8 as *const libc::c_char,
            865 as libc::c_int,
            ctx,
            now,
            (*ctx).rtp_sockets[2 as libc::c_int as usize].rport as libc::c_int,
        );
    }
    req[0 as libc::c_int as usize] = 128 as libc::c_int as libc::c_uchar;
    req[1 as libc::c_int as usize] = 210 as libc::c_int as libc::c_uchar;
    *(req.as_mut_ptr().offset(2 as libc::c_int as isize)
        as *mut u16_t) = __bswap_16(7 as libc::c_int as __uint16_t);
    *(req.as_mut_ptr().offset(4 as libc::c_int as isize)
        as *mut u32_t) = __bswap_32(0 as libc::c_int as __uint32_t);
    i = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        req[(i + 8 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_uchar;
        i += 1;
    }
    *(req.as_mut_ptr().offset(24 as libc::c_int as isize)
        as *mut u32_t) = 0 as libc::c_int as u32_t;
    *(req.as_mut_ptr().offset(28 as libc::c_int as isize)
        as *mut u32_t) = __bswap_32(now);
    if (*ctx).host.s_addr != 0 as libc::c_uint {
        host.sin_family = 2 as libc::c_int as sa_family_t;
        host.sin_addr = (*ctx).host;
    } else {
        host = (*ctx).rtp_host;
    }
    if host.sin_addr.s_addr == 0 as libc::c_uint {
        return 0 as libc::c_int != 0;
    }
    host.sin_port = __bswap_16((*ctx).rtp_sockets[2 as libc::c_int as usize].rport);
    tmp___4 = sendto(
        (*ctx).rtp_sockets[2 as libc::c_int as usize].sock,
        req.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_uchar; 32]>() as libc::c_ulong,
        0 as libc::c_int,
        &mut host as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
    );
    if ::std::mem::size_of::<[libc::c_uchar; 32]>() as libc::c_ulong
        != tmp___4 as libc::c_ulong
    {
        if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
            tmp___1 = __errno_location();
            tmp___2 = strerror(*tmp___1);
            tmp___3 = logtime();
            logprint(
                b"%s %s:%d [%p]: SENDTO failed (%s)\n\0" as *const u8
                    as *const libc::c_char,
                tmp___3,
                b"rtp_request_timing\0" as *const u8 as *const libc::c_char,
                886 as libc::c_int,
                ctx,
                tmp___2,
            );
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn rtp_request_resend(
    mut ctx: *mut hairtunes_t,
    mut first: seq_t,
    mut last: seq_t,
) -> bool {
    let mut req: [libc::c_uchar; 8] = [0; 8];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: ssize_t = 0;
    tmp = seq_order(last, first);
    if tmp != 0 {
        return 0 as libc::c_int != 0
    } else {
        if last as libc::c_int - first as libc::c_int > 512 as libc::c_int {
            return 0 as libc::c_int != 0;
        }
    }
    (*ctx)
        .resent_frames = ((*ctx).resent_frames as libc::c_uint)
        .wrapping_add(
            ((last as libc::c_int - first as libc::c_int) as seq_t as libc::c_int
                + 1 as libc::c_int) as u32_t,
        ) as u32_t as u32_t;
    if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d resend request [W:%hu R:%hu first=%hu last=%hu]\n\0" as *const u8
                as *const libc::c_char,
            tmp___0,
            b"rtp_request_resend\0" as *const u8 as *const libc::c_char,
            901 as libc::c_int,
            (*ctx).ab_write as libc::c_int,
            (*ctx).ab_read as libc::c_int,
            first as libc::c_int,
            last as libc::c_int,
        );
    }
    req[0 as libc::c_int as usize] = 128 as libc::c_int as libc::c_uchar;
    req[1 as libc::c_int as usize] = 213 as libc::c_int as libc::c_uchar;
    *(req.as_mut_ptr().offset(2 as libc::c_int as isize)
        as *mut u16_t) = __bswap_16(1 as libc::c_int as __uint16_t);
    *(req.as_mut_ptr().offset(4 as libc::c_int as isize)
        as *mut u16_t) = __bswap_16(first);
    *(req.as_mut_ptr().offset(6 as libc::c_int as isize)
        as *mut u16_t) = __bswap_16(
        ((last as libc::c_int - first as libc::c_int) as seq_t as libc::c_int
            + 1 as libc::c_int) as __uint16_t,
    );
    (*ctx)
        .rtp_host
        .sin_port = __bswap_16((*ctx).rtp_sockets[1 as libc::c_int as usize].rport);
    tmp___4 = sendto(
        (*ctx).rtp_sockets[1 as libc::c_int as usize].sock,
        req.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong,
        0 as libc::c_int,
        &mut (*ctx).rtp_host as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
    );
    if ::std::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
        != tmp___4 as libc::c_ulong
    {
        if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
            tmp___1 = __errno_location();
            tmp___2 = strerror(*tmp___1);
            tmp___3 = logtime();
            logprint(
                b"%s %s:%d [%p]: SENDTO failed (%s)\n\0" as *const u8
                    as *const libc::c_char,
                tmp___3,
                b"rtp_request_resend\0" as *const u8 as *const libc::c_char,
                912 as libc::c_int,
                ctx,
                tmp___2,
            );
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _buffer_get_frame(
    mut ctx: *mut hairtunes_t,
    mut len: *mut libc::c_int,
) -> *mut libc::c_short {
    let mut current_block: u64;
    let mut buf_fill: libc::c_short = 0;
    let mut curframe: *mut abuf_t = 0 as *mut abuf_t;
    let mut i: libc::c_int = 0;
    let mut now: u32_t = 0;
    let mut playtime: u32_t = 0;
    let mut tmp: u32_t = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut frame: *mut abuf_t = 0 as *mut abuf_t;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: libc::c_int = 0;
    let mut frame___0: *mut abuf_t = 0 as *mut abuf_t;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    curframe = 0 as *mut abuf_t;
    if !(*ctx).playing {
        return 0 as *mut libc::c_void as *mut libc::c_short;
    }
    if (*ctx).silence_count != 0 {
        tmp = (*ctx).silence_count;
        (*ctx).silence_count = ((*ctx).silence_count).wrapping_sub(1);
        if tmp != 0 {
            *len = (*ctx).frame_size * 4 as libc::c_int;
            return (*ctx).silence_frame as *mut libc::c_short;
        }
    }
    if (*ctx).pause {
        *len = (*ctx).frame_size * 4 as libc::c_int;
        return (*ctx).silence_frame as *mut libc::c_short;
    }
    while (*ctx).skip != 0 {
        tmp___1 = seq_order((*ctx).ab_read, (*ctx).ab_write);
        if tmp___1 == 0 {
            break;
        }
        (*ctx)
            .audio_buffer[((*ctx).ab_read as libc::c_int % 1024 as libc::c_int) as usize]
            .ready = 0 as libc::c_int;
        (*ctx).ab_read = ((*ctx).ab_read as libc::c_int + 1 as libc::c_int) as seq_t;
        (*ctx).skip -= 1;
        if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
            tmp___0 = logtime();
            logprint(
                b"%s %s:%d [%p]: Sending packets too slow (skip: %d) [W:%hu R:%hu]\n\0"
                    as *const u8 as *const libc::c_char,
                tmp___0,
                b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
                940 as libc::c_int,
                ctx,
                (*ctx).skip,
                (*ctx).ab_write as libc::c_int,
                (*ctx).ab_read as libc::c_int,
            );
        }
    }
    buf_fill = ((*ctx).ab_write as libc::c_int - (*ctx).ab_read as libc::c_int
        + 1 as libc::c_int) as libc::c_short;
    if buf_fill as libc::c_int >= 1024 as libc::c_int {
        tmp___2 = logtime();
        logprint(
            b"%s %s:%d [%p]: Buffer overrun %hu\n\0" as *const u8 as *const libc::c_char,
            tmp___2,
            b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
            946 as libc::c_int,
            ctx,
            buf_fill as libc::c_int,
        );
        (*ctx).ab_read = ((*ctx).ab_write as libc::c_int - 960 as libc::c_int) as seq_t;
        buf_fill = ((*ctx).ab_write as libc::c_int - (*ctx).ab_read as libc::c_int
            + 1 as libc::c_int) as libc::c_short;
    }
    now = gettime_ms();
    curframe = ((*ctx).audio_buffer)
        .as_mut_ptr()
        .offset(((*ctx).ab_read as libc::c_int % 1024 as libc::c_int) as isize);
    if buf_fill == 0 {
        (*curframe)
            .rtptime = ((*ctx)
            .audio_buffer[(((*ctx).ab_read as libc::c_int - 1 as libc::c_int) as seq_t
                as libc::c_int % 1024 as libc::c_int) as usize]
            .rtptime)
            .wrapping_add((*ctx).frame_size as u32_t);
    }
    playtime = ((*ctx).synchro.time)
        .wrapping_add(
            (((*curframe).rtptime).wrapping_sub((*ctx).synchro.rtp) as s32_t
                * 1000 as libc::c_int / 44100 as libc::c_int) as u32_t,
        );
    if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
        tmp___3 = logtime();
        logprint(
            b"%s %s:%d playtime %u %d [W:%hu R:%hu] %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___3,
            b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
            960 as libc::c_int,
            playtime,
            playtime.wrapping_sub(now),
            (*ctx).ab_write as libc::c_int,
            (*ctx).ab_read as libc::c_int,
            (*curframe).ready,
        );
    }
    if buf_fill == 0 {
        if !(*ctx).http_fill {
            current_block = 9163597468201552611;
        } else {
            current_block = 13851329285764712494;
        }
    } else {
        current_block = 13851329285764712494;
    }
    match current_block {
        13851329285764712494 => {
            if !((*ctx).synchro.status as libc::c_int != 3 as libc::c_int) {
                if now < playtime {
                    if (*curframe).ready == 0 {
                        current_block = 9163597468201552611;
                    } else {
                        current_block = 6281126495347172768;
                    }
                } else {
                    current_block = 6281126495347172768;
                }
                match current_block {
                    9163597468201552611 => {}
                    _ => {
                        if buf_fill == 0 {
                            if (*ctx).filled_frames == 0 {
                                if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
                                    tmp___6 = logtime();
                                    logprint(
                                        b"%s %s:%d [%p]: start silence (late %d ms) [W:%hu R:%hu]\n\0"
                                            as *const u8 as *const libc::c_char,
                                        tmp___6,
                                        b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
                                        979 as libc::c_int,
                                        ctx,
                                        now.wrapping_sub(playtime),
                                        (*ctx).ab_write as libc::c_int,
                                        (*ctx).ab_read as libc::c_int,
                                    );
                                }
                            }
                            (*ctx)
                                .ab_write = ((*ctx).ab_write as libc::c_int
                                + 1 as libc::c_int) as seq_t;
                            (*ctx)
                                .filled_frames = ((*ctx).filled_frames).wrapping_add(1);
                        } else {
                            (*ctx).filled_frames = 0 as libc::c_int as u32_t;
                        }
                        tmp___8 = (*ctx).out_frames;
                        (*ctx).out_frames += 1;
                        if tmp___8 & 511 as libc::c_int == 0 {
                            if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                                tmp___7 = logtime();
                                logprint(
                                    b"%s %s:%d [%p]: drain [level:%hd gap:%d] [W:%hu R:%hu] [R:%u S:%u F:%u]\n\0"
                                        as *const u8 as *const libc::c_char,
                                    tmp___7,
                                    b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
                                    988 as libc::c_int,
                                    ctx,
                                    buf_fill as libc::c_int - 1 as libc::c_int,
                                    playtime.wrapping_sub(now),
                                    (*ctx).ab_write as libc::c_int,
                                    (*ctx).ab_read as libc::c_int,
                                    (*ctx).resent_frames,
                                    (*ctx).silent_frames,
                                    (*ctx).filled_frames,
                                );
                            }
                        }
                        i = 16 as libc::c_int;
                        loop {
                            tmp___9 = seq_order(
                                ((*ctx).ab_read as libc::c_int + i) as seq_t,
                                (*ctx).ab_write,
                            );
                            if tmp___9 == 0 {
                                break;
                            }
                            frame___0 = ((*ctx).audio_buffer)
                                .as_mut_ptr()
                                .offset(
                                    (((*ctx).ab_read as libc::c_int + i) as seq_t as libc::c_int
                                        % 1024 as libc::c_int) as isize,
                                );
                            if (*frame___0).ready == 0 {
                                if now.wrapping_sub((*frame___0).last_resend)
                                    > 200 as libc::c_uint
                                {
                                    rtp_request_resend(
                                        ctx,
                                        ((*ctx).ab_read as libc::c_int + i) as seq_t,
                                        ((*ctx).ab_read as libc::c_int + i) as seq_t,
                                    );
                                    (*frame___0).last_resend = now;
                                }
                            }
                            i += 16 as libc::c_int;
                        }
                        if (*curframe).ready == 0 {
                            if *loglevel___2 as libc::c_uint >= 3 as libc::c_uint {
                                tmp___10 = logtime();
                                logprint(
                                    b"%s %s:%d [%p]: created zero frame (W:%hu R:%hu)\n\0"
                                        as *const u8 as *const libc::c_char,
                                    tmp___10,
                                    b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
                                    1002 as libc::c_int,
                                    ctx,
                                    (*ctx).ab_write as libc::c_int,
                                    (*ctx).ab_read as libc::c_int,
                                );
                            }
                            memset(
                                (*curframe).data as *mut libc::c_void,
                                0 as libc::c_int,
                                ((*ctx).frame_size * 4 as libc::c_int) as size_t,
                            );
                            (*curframe).len = (*ctx).frame_size * 4 as libc::c_int;
                            (*ctx)
                                .silent_frames = ((*ctx).silent_frames).wrapping_add(1);
                        } else if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
                            tmp___11 = logtime();
                            logprint(
                                b"%s %s:%d [%p]: prepared frame (fill:%hd, W:%hu R:%hu)\n\0"
                                    as *const u8 as *const libc::c_char,
                                tmp___11,
                                b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
                                1007 as libc::c_int,
                                ctx,
                                buf_fill as libc::c_int - 1 as libc::c_int,
                                (*ctx).ab_write as libc::c_int,
                                (*ctx).ab_read as libc::c_int,
                            );
                        }
                        *len = (*curframe).len;
                        (*curframe).ready = 0 as libc::c_int;
                        (*ctx)
                            .ab_read = ((*ctx).ab_read as libc::c_int + 1 as libc::c_int)
                            as seq_t;
                        return (*curframe).data;
                    }
                }
            }
        }
        _ => {}
    }
    if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
        tmp___4 = logtime();
        logprint(
            b"%s %s:%d [%p]: waiting (fill:%hd, W:%hu R:%hu) now:%u, playtime:%u, wait:%d\n\0"
                as *const u8 as *const libc::c_char,
            tmp___4,
            b"_buffer_get_frame\0" as *const u8 as *const libc::c_char,
            964 as libc::c_int,
            ctx,
            buf_fill as libc::c_int,
            (*ctx).ab_write as libc::c_int,
            (*ctx).ab_read as libc::c_int,
            now,
            playtime,
            playtime.wrapping_sub(now),
        );
    }
    i = 0 as libc::c_int;
    loop {
        if (16 as libc::c_int) < buf_fill as libc::c_int {
            tmp___5 = 16 as libc::c_int;
        } else {
            tmp___5 = buf_fill as libc::c_int;
        }
        if !(i < tmp___5) {
            break;
        }
        frame = ((*ctx).audio_buffer)
            .as_mut_ptr()
            .offset(
                (((*ctx).ab_read as libc::c_int + i) as seq_t as libc::c_int
                    % 1024 as libc::c_int) as isize,
            );
        if (*frame).ready == 0 {
            if now.wrapping_sub((*frame).last_resend) > 200 as libc::c_uint {
                rtp_request_resend(
                    ctx,
                    ((*ctx).ab_read as libc::c_int + i) as seq_t,
                    ((*ctx).ab_read as libc::c_int + i) as seq_t,
                );
                (*frame).last_resend = now;
            }
        }
        i += 1;
    }
    return 0 as *mut libc::c_void as *mut libc::c_short;
}
pub unsafe extern "C" fn send_data(
    mut chunked: bool,
    mut sock: libc::c_int,
    mut data: *mut libc::c_void,
    mut len: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut chunk: [libc::c_char; 16] = [0; 16];
    let mut bytes: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut sent: libc::c_int = 0;
    let mut tmp___0: ssize_t = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    bytes = len;
    if chunked {
        itoa(len, chunk.as_mut_ptr(), 16 as libc::c_int);
        strcat(chunk.as_mut_ptr(), b"\r\n\0" as *const u8 as *const libc::c_char);
        tmp = strlen(chunk.as_mut_ptr() as *const libc::c_char);
        send(sock, chunk.as_mut_ptr() as *const libc::c_void, tmp, flags);
    }
    while bytes != 0 {
        tmp___0 = send(
            sock,
            (data as *mut u8_t).offset(len as isize).offset(-(bytes as isize))
                as *const libc::c_void,
            bytes as size_t,
            flags,
        );
        sent = tmp___0 as libc::c_int;
        if sent < 0 as libc::c_int {
            tmp___1 = logtime();
            logprint(
                b"%s %s:%d Error sending data %u\n\0" as *const u8
                    as *const libc::c_char,
                tmp___1,
                b"send_data\0" as *const u8 as *const libc::c_char,
                1031 as libc::c_int,
                len,
            );
            return -(1 as libc::c_int);
        }
        bytes -= sent;
    }
    if chunked {
        send(
            sock,
            b"\r\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            2 as libc::c_int as size_t,
            flags,
        );
    }
    return len;
}
unsafe extern "C" fn http_thread_func(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut inbuf: *mut s16_t = 0 as *mut s16_t;
    let mut frame_count: libc::c_int = 0;
    let mut flac_samples: *mut FLAC__int32 = 0 as *mut FLAC__int32;
    let mut ctx: *mut hairtunes_t = 0 as *mut hairtunes_t;
    let mut sock: libc::c_int = 0;
    let mut timeout: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut sent: ssize_t = 0;
    let mut rfds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut n: libc::c_int = 0;
    let mut res: bool = false;
    let mut size: libc::c_int = 0;
    let mut timeout___0: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut on: libc::c_int = 0;
    let mut buf_fill: libc::c_short = 0;
    let mut tmp___2: u32_t = 0;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut __d0___0: libc::c_int = 0;
    let mut __d1___0: libc::c_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: libc::c_int = 0;
    let mut block: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut p: *mut s16_t = 0 as *mut s16_t;
    let mut space: u32_t = 0;
    let mut gap: u32_t = 0;
    let mut tmp___7: u32_t = 0;
    let mut offset: libc::c_int = 0;
    let mut len_16: libc::c_int = 0;
    let mut buffer: [libc::c_char; 4081] = [0; 4081];
    let mut format: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: u32_t = 0;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___19: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___20: *const libc::c_char = 0 as *const libc::c_char;
    frame_count = 0 as libc::c_int;
    flac_samples = 0 as *mut libc::c_void as *mut FLAC__int32;
    ctx = arg as *mut hairtunes_t;
    sock = -(1 as libc::c_int);
    timeout.tv_sec = 0 as libc::c_int as __time_t;
    timeout.tv_usec = 0 as libc::c_int as __suseconds_t;
    if (*ctx).encode.config.codec as libc::c_uint == 1 as libc::c_uint {
        tmp___0 = malloc(
            ((2 as libc::c_int * (*ctx).frame_size) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<FLAC__int32>() as libc::c_ulong),
        );
        flac_samples = tmp___0 as *mut FLAC__int32;
        if flac_samples as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            tmp = logtime();
            logprint(
                b"%s %s:%d [%p]: Cannot allocate FLAC sample buffer %u\n\0" as *const u8
                    as *const libc::c_char,
                tmp,
                b"http_thread_func\0" as *const u8 as *const libc::c_char,
                1052 as libc::c_int,
                ctx,
                (*ctx).frame_size,
            );
        }
    }
    while (*ctx).running {
        res = 1 as libc::c_int != 0;
        size = 0 as libc::c_int;
        if sock == -(1 as libc::c_int) {
            timeout___0.tv_sec = 0 as libc::c_int as __time_t;
            timeout___0.tv_usec = 50000 as libc::c_int as __suseconds_t;
            let fresh7 = &mut __d0;
            let fresh8;
            let fresh9 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
            let fresh10 = &mut __d1;
            let fresh11;
            let fresh12 = &mut *(rfds.fds_bits)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize) as *mut __fd_mask;
            asm!(
                "cld; rep; stosq", inlateout("cx")
                c2rust_asm_casts::AsmCast::cast_in(fresh7, fresh9) => fresh8,
                inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh10, fresh12) =>
                fresh11, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
                att_syntax)
            );
            c2rust_asm_casts::AsmCast::cast_out(fresh7, fresh9, fresh8);
            c2rust_asm_casts::AsmCast::cast_out(fresh10, fresh12, fresh11);
            rfds
                .fds_bits[((*ctx).http_listener
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                |= ((1 as libc::c_ulong)
                    << (*ctx).http_listener
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask;
            tmp___1 = select(
                (*ctx).http_listener + 1 as libc::c_int,
                &mut rfds as *mut fd_set,
                0 as *mut libc::c_void as *mut fd_set,
                0 as *mut libc::c_void as *mut fd_set,
                &mut timeout___0 as *mut timeval,
            );
            if tmp___1 > 0 as libc::c_int {
                sock = accept(
                    (*ctx).http_listener,
                    0 as *mut libc::c_void as *mut sockaddr,
                    0 as *mut libc::c_void as *mut socklen_t,
                );
            }
            if !(sock != -(1 as libc::c_int)) {
                continue;
            }
            if !(*ctx).running {
                continue;
            }
            on = 1 as libc::c_int;
            setsockopt(
                sock,
                6 as libc::c_int,
                1 as libc::c_int,
                &mut on as *mut libc::c_int as *mut libc::c_char as *const libc::c_void,
                ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
            );
            (*ctx).silence_count = (*ctx).delay as u32_t;
            pthread_mutex_lock(&mut (*ctx).ab_mutex);
            if (*ctx).playing {
                buf_fill = ((*ctx).ab_write as libc::c_int
                    - (*ctx).ab_read as libc::c_int + 1 as libc::c_int) as libc::c_short;
                if buf_fill as libc::c_int > 0 as libc::c_int {
                    if (*ctx).silence_count < buf_fill as u32_t {
                        tmp___2 = (*ctx).silence_count;
                    } else {
                        tmp___2 = buf_fill as u32_t;
                    }
                    (*ctx)
                        .silence_count = ((*ctx).silence_count as libc::c_uint)
                        .wrapping_sub(tmp___2) as u32_t as u32_t;
                } else {
                    (*ctx).silence_count = 0 as libc::c_int as u32_t;
                }
            }
            pthread_mutex_unlock(&mut (*ctx).ab_mutex);
            if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                tmp___3 = logtime();
                logprint(
                    b"%s %s:%d [%p]: got HTTP connection %u (silent frames %d)\n\0"
                        as *const u8 as *const libc::c_char,
                    tmp___3,
                    b"http_thread_func\0" as *const u8 as *const libc::c_char,
                    1087 as libc::c_int,
                    ctx,
                    sock,
                    (*ctx).silence_count,
                );
            }
        }
        let fresh13 = &mut __d0___0;
        let fresh14;
        let fresh15 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh16 = &mut __d1___0;
        let fresh17;
        let fresh18 = &mut *(rfds.fds_bits)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh13, fresh15) => fresh14,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh16, fresh18) =>
            fresh17, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh13, fresh15, fresh14);
        c2rust_asm_casts::AsmCast::cast_out(fresh16, fresh18, fresh17);
        rfds
            .fds_bits[(sock
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << sock
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        n = select(
            sock + 1 as libc::c_int,
            &mut rfds as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut timeout as *mut timeval,
        );
        pthread_mutex_lock(&mut (*ctx).ab_mutex);
        if n > 0 as libc::c_int {
            res = handle_http(ctx, sock);
            (*ctx).http_ready = res;
        }
        let mut current_block_63: u64;
        if n < 0 as libc::c_int {
            current_block_63 = 3941487249035511973;
        } else if !res {
            current_block_63 = 3941487249035511973;
        } else {
            current_block_63 = 11796148217846552555;
        }
        match current_block_63 {
            3941487249035511973 => {
                close(sock);
                if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                    tmp___4 = logtime();
                    logprint(
                        b"%s %s:%d HTTP close %u\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___4,
                        b"http_thread_func\0" as *const u8 as *const libc::c_char,
                        1106 as libc::c_int,
                        sock,
                    );
                }
                sock = -(1 as libc::c_int);
                (*ctx).http_ready = 0 as libc::c_int != 0;
            }
            _ => {}
        }
        if (*ctx).http_ready {
            inbuf = _buffer_get_frame(ctx, &mut size);
            if inbuf as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*ctx).encode.config.codec as libc::c_uint == 1 as libc::c_uint {
                    if (*ctx).encode.header {
                        if (*ctx).encode.len != 0 {
                            memcpy(
                                (*ctx).http_tail as *mut libc::c_void,
                                ((*ctx).encode.buffer).as_mut_ptr() as *const libc::c_void,
                                (*ctx).encode.len as size_t,
                            );
                            (*ctx).http_count = (*ctx).encode.len as size_t;
                            send_data(
                                (*ctx).http_length == -(3 as libc::c_int),
                                sock,
                                ((*ctx).encode.buffer).as_mut_ptr() as *mut libc::c_void,
                                (*ctx).encode.len,
                                0 as libc::c_int,
                            );
                            (*ctx).encode.len = 0 as libc::c_int;
                            (*ctx).encode.header = 0 as libc::c_int != 0;
                        }
                    }
                    len = 0 as libc::c_int;
                    while len < 2 as libc::c_int * size / 4 as libc::c_int {
                        *flac_samples
                            .offset(
                                len as isize,
                            ) = *inbuf.offset(len as isize) as FLAC__int32;
                        len += 1;
                    }
                    FLAC__stream_encoder_process_interleaved(
                        (*ctx).encode.codec as *mut FLAC__StreamEncoder,
                        flac_samples as *const FLAC__int32,
                        (size / 4 as libc::c_int) as uint32_t,
                    );
                    inbuf = ((*ctx).encode.buffer).as_mut_ptr() as *mut libc::c_void
                        as *mut s16_t;
                    len = (*ctx).encode.len;
                    (*ctx).encode.len = 0 as libc::c_int;
                } else if (*ctx).encode.config.codec as libc::c_uint == 0 as libc::c_uint
                    {
                    tmp___5 = shine_samples_per_pass((*ctx).encode.codec as shine_t);
                    block = tmp___5 * 4 as libc::c_int;
                    memcpy(
                        ((*ctx).encode.buffer)
                            .as_mut_ptr()
                            .offset((*ctx).encode.len as isize) as *mut libc::c_void,
                        inbuf as *const libc::c_void,
                        size as size_t,
                    );
                    (*ctx).encode.len += size;
                    if (*ctx).encode.len >= block {
                        tmp___6 = shine_encode_buffer_interleaved(
                            (*ctx).encode.codec as shine_t,
                            ((*ctx).encode.buffer).as_mut_ptr() as *mut s16_t,
                            &mut len,
                        );
                        inbuf = tmp___6 as *mut s16_t;
                        (*ctx).encode.len -= block;
                        memcpy(
                            ((*ctx).encode.buffer).as_mut_ptr() as *mut libc::c_void,
                            ((*ctx).encode.buffer).as_mut_ptr().offset(block as isize)
                                as *const libc::c_void,
                            (*ctx).encode.len as size_t,
                        );
                    } else {
                        len = 0 as libc::c_int;
                    }
                } else {
                    if (*ctx).encode.config.codec as libc::c_uint == 2 as libc::c_uint {
                        p = inbuf;
                        len = size * 2 as libc::c_int / 4 as libc::c_int;
                        while len > 0 as libc::c_int {
                            *p = ((*p as u8_t as libc::c_int) << 8 as libc::c_int
                                | (*p as libc::c_int >> 8 as libc::c_int) as u8_t
                                    as libc::c_int) as s16_t;
                            len -= 1;
                            p = p.offset(1);
                        }
                    } else if (*ctx).encode.header {
                        (*ctx)
                            .http_count = ::std::mem::size_of::<wave_header_s>()
                            as libc::c_ulong;
                        memcpy(
                            (*ctx).http_tail as *mut libc::c_void,
                            &mut wave_header as *mut wave_header_s
                                as *const libc::c_void,
                            ::std::mem::size_of::<wave_header_s>() as libc::c_ulong,
                        );
                        send_data(
                            (*ctx).http_length == -(3 as libc::c_int),
                            sock,
                            &mut wave_header as *mut wave_header_s as *mut libc::c_void,
                            ::std::mem::size_of::<wave_header_s>() as libc::c_ulong
                                as libc::c_int,
                            0 as libc::c_int,
                        );
                        (*ctx).encode.header = 0 as libc::c_int != 0;
                    }
                    len = size;
                }
                if len != 0 {
                    tmp___7 = gettime_ms();
                    gap = tmp___7;
                    if (len as libc::c_ulong)
                        < (2097152 as libc::c_ulong)
                            .wrapping_sub(
                                ((*ctx).http_count).wrapping_rem(2097152 as libc::c_ulong),
                            )
                    {
                        space = len as u32_t;
                    } else {
                        space = (2097152 as libc::c_ulong)
                            .wrapping_sub(
                                ((*ctx).http_count).wrapping_rem(2097152 as libc::c_ulong),
                            ) as u32_t;
                    }
                    memcpy(
                        ((*ctx).http_tail)
                            .offset(
                                ((*ctx).http_count).wrapping_rem(2097152 as libc::c_ulong)
                                    as isize,
                            ) as *mut libc::c_void,
                        inbuf as *const libc::c_void,
                        space as size_t,
                    );
                    memcpy(
                        (*ctx).http_tail as *mut libc::c_void,
                        inbuf.offset(space as isize) as *const libc::c_void,
                        (len as u32_t).wrapping_sub(space) as size_t,
                    );
                    (*ctx)
                        .http_count = ((*ctx).http_count as libc::c_ulong)
                        .wrapping_add(len as size_t) as size_t as size_t;
                    if (*ctx).icy.interval != 0 {
                        if len as size_t > (*ctx).icy.remain {
                            len_16 = 0 as libc::c_int;
                            if (*ctx).icy.updated {
                                if !((*ctx).metadata.artwork).is_null() {
                                    format = b"NStreamTitle='%s%s%s';StreamURL='%s';\0"
                                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                                } else {
                                    format = b"NStreamTitle='%s%s%s';\0" as *const u8
                                        as *const libc::c_char as *mut libc::c_char;
                                }
                                if *(*ctx).metadata.artist != 0 {
                                    tmp___8 = b" - \0" as *const u8 as *const libc::c_char;
                                } else {
                                    tmp___8 = b"\0" as *const u8 as *const libc::c_char;
                                }
                                tmp___9 = sprintf(
                                    buffer.as_mut_ptr(),
                                    format as *const libc::c_char,
                                    (*ctx).metadata.artist,
                                    tmp___8,
                                    (*ctx).metadata.title,
                                    (*ctx).metadata.artwork,
                                );
                                len_16 = tmp___9 - 1 as libc::c_int;
                                if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
                                    tmp___10 = logtime();
                                    logprint(
                                        b"%s %s:%d [%p]: ICY update %s\n\0" as *const u8
                                            as *const libc::c_char,
                                        tmp___10,
                                        b"http_thread_func\0" as *const u8 as *const libc::c_char,
                                        1188 as libc::c_int,
                                        ctx,
                                        buffer.as_mut_ptr().offset(1 as libc::c_int as isize),
                                    );
                                }
                                len_16 = (len_16 + 15 as libc::c_int) / 16 as libc::c_int;
                                (*ctx).icy.updated = 0 as libc::c_int != 0;
                            }
                            buffer[0 as libc::c_int as usize] = len_16 as libc::c_char;
                            pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                            offset = (*ctx).icy.remain as libc::c_int;
                            if offset != 0 {
                                send_data(
                                    (*ctx).http_length == -(3 as libc::c_int),
                                    sock,
                                    inbuf as *mut libc::c_void,
                                    offset,
                                    0 as libc::c_int,
                                );
                            }
                            len -= offset;
                            send_data(
                                (*ctx).http_length == -(3 as libc::c_int),
                                sock,
                                buffer.as_mut_ptr() as *mut libc::c_void,
                                len_16 * 16 as libc::c_int + 1 as libc::c_int,
                                0 as libc::c_int,
                            );
                            (*ctx).icy.remain = (*ctx).icy.interval;
                            if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
                                tmp___11 = logtime();
                                logprint(
                                    b"%s %s:%d [%p]: ICY checked %u\n\0" as *const u8
                                        as *const libc::c_char,
                                    tmp___11,
                                    b"http_thread_func\0" as *const u8 as *const libc::c_char,
                                    1207 as libc::c_int,
                                    ctx,
                                    (*ctx).icy.remain,
                                );
                            }
                        } else {
                            offset = 0 as libc::c_int;
                            pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                        }
                    } else {
                        offset = 0 as libc::c_int;
                        pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                    }
                    if *loglevel___2 as libc::c_uint >= 4 as libc::c_uint {
                        tmp___12 = frame_count;
                        frame_count += 1;
                        tmp___13 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: HTTP sent frame count:%u bytes:%u (W:%hu R:%hu)\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___13,
                            b"http_thread_func\0" as *const u8 as *const libc::c_char,
                            1213 as libc::c_int,
                            ctx,
                            tmp___12,
                            len + offset,
                            (*ctx).ab_write as libc::c_int,
                            (*ctx).ab_read as libc::c_int,
                        );
                    }
                    tmp___14 = send_data(
                        (*ctx).http_length == -(3 as libc::c_int),
                        sock,
                        (inbuf as *mut u8_t).offset(offset as isize)
                            as *mut libc::c_void,
                        len,
                        0 as libc::c_int,
                    );
                    sent = tmp___14 as ssize_t;
                    if (*ctx).icy.interval != 0 {
                        (*ctx)
                            .icy
                            .remain = ((*ctx).icy.remain as libc::c_ulong)
                            .wrapping_sub(len as size_t) as size_t as size_t;
                    }
                    tmp___15 = gettime_ms();
                    gap = tmp___15.wrapping_sub(gap);
                    if gap > 50 as libc::c_uint {
                        tmp___16 = logtime();
                        logprint(
                            b"%s %s:%d [%p]: spent %u ms in send for %u bytes (sent %zd)!\n\0"
                                as *const u8 as *const libc::c_char,
                            tmp___16,
                            b"http_thread_func\0" as *const u8 as *const libc::c_char,
                            1222 as libc::c_int,
                            ctx,
                            gap,
                            len,
                            sent,
                        );
                    }
                    if sent != len as ssize_t {
                        if *loglevel___2 as libc::c_uint >= 1 as libc::c_uint {
                            tmp___17 = __errno_location();
                            tmp___18 = strerror(*tmp___17);
                            tmp___19 = logtime();
                            logprint(
                                b"%s %s:%d [%p]: HTTP send() unexpected response: %li (data=%i): %s\n\0"
                                    as *const u8 as *const libc::c_char,
                                tmp___19,
                                b"http_thread_func\0" as *const u8 as *const libc::c_char,
                                1226 as libc::c_int,
                                ctx,
                                sent,
                                len,
                                tmp___18,
                            );
                        }
                    }
                } else {
                    pthread_mutex_unlock(&mut (*ctx).ab_mutex);
                }
                if (*ctx).pause {
                    timeout
                        .tv_usec = ((*ctx).frame_size * 1000000 as libc::c_int
                        / 44100 as libc::c_int) as __suseconds_t;
                } else {
                    timeout.tv_usec = 0 as libc::c_int as __suseconds_t;
                }
            } else {
                timeout
                    .tv_usec = (2 as libc::c_int * (*ctx).frame_size
                    * 1000000 as libc::c_int / 44100 as libc::c_int) as __suseconds_t;
                pthread_mutex_unlock(&mut (*ctx).ab_mutex);
            }
        } else {
            timeout
                .tv_usec = (2 as libc::c_int * (*ctx).frame_size * 1000000 as libc::c_int
                / 44100 as libc::c_int) as __suseconds_t;
            pthread_mutex_unlock(&mut (*ctx).ab_mutex);
        }
    }
    if sock != -(1 as libc::c_int) {
        shutdown_socket(sock);
    }
    if (*ctx).encode.config.codec as libc::c_uint == 1 as libc::c_uint {
        if !flac_samples.is_null() {
            free(flac_samples as *mut libc::c_void);
        }
    }
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___20 = logtime();
        logprint(
            b"%s %s:%d [%p]: terminating\n\0" as *const u8 as *const libc::c_char,
            tmp___20,
            b"http_thread_func\0" as *const u8 as *const libc::c_char,
            1243 as libc::c_int,
            ctx,
        );
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn handle_http(
    mut ctx: *mut hairtunes_t,
    mut sock: libc::c_int,
) -> bool {
    let mut body: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut method: [libc::c_char; 16] = [0; 16];
    let mut tmp: libc::c_uint = 0;
    let mut proto: [libc::c_char; 16] = [0; 16];
    let mut tmp___0: libc::c_uint = 0;
    let mut str___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut head: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut headers: [key_data_t; 64] = [key_data_t {
        key: 0 as *mut libc::c_char,
        data: 0 as *mut libc::c_char,
    }; 64];
    let mut resp: [key_data_t; 16] = [key_data_t {
        key: 0 as *mut libc::c_char,
        data: 0 as *mut libc::c_char,
    }; 16];
    let mut tmp___1: libc::c_uint = 0;
    let mut offset: size_t = 0;
    let mut len: libc::c_int = 0;
    let mut HTTP_11: bool = false;
    let mut tmp___2: bool = false;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut count___0: size_t = 0;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut bytes: size_t = 0;
    let mut tmp___17: size_t = 0;
    let mut sent: libc::c_int = 0;
    let mut tmp___18: *const libc::c_char = 0 as *const libc::c_char;
    body = 0 as *mut libc::c_void as *mut libc::c_char;
    method[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 16 as libc::c_uint) {
        method[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    proto[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp___0 = 1 as libc::c_uint;
    while !(tmp___0 >= 16 as libc::c_uint) {
        proto[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = tmp___0.wrapping_add(1);
    }
    head = 0 as *mut libc::c_void as *mut libc::c_char;
    resp[0 as libc::c_int as usize].key = 0 as *mut libc::c_void as *mut libc::c_char;
    resp[0 as libc::c_int as usize].data = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___1 = 1 as libc::c_uint;
    while !(tmp___1 >= 16 as libc::c_uint) {
        resp[tmp___1 as usize].key = 0 as *mut libc::c_char;
        resp[tmp___1 as usize].data = 0 as *mut libc::c_char;
        tmp___1 = tmp___1.wrapping_add(1);
    }
    offset = 0 as libc::c_int as size_t;
    tmp___2 = http_parse(
        sock,
        method.as_mut_ptr(),
        0 as *mut libc::c_void as *mut libc::c_char,
        proto.as_mut_ptr(),
        headers.as_mut_ptr(),
        &mut body,
        &mut len,
    );
    if !tmp___2 {
        return 0 as libc::c_int != 0;
    }
    tmp___3 = strstr(
        proto.as_mut_ptr() as *const libc::c_char,
        b"1.1\0" as *const u8 as *const libc::c_char,
    );
    HTTP_11 = tmp___3 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong;
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___4 = kd_dump(headers.as_mut_ptr());
        p = tmp___4;
        if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
            tmp___5 = logtime();
            logprint(
                b"%s %s:%d [%p]: received %s %s\n%s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___5,
                b"handle_http\0" as *const u8 as *const libc::c_char,
                1262 as libc::c_int,
                ctx,
                method.as_mut_ptr(),
                proto.as_mut_ptr(),
                p,
            );
        }
        if !p.is_null() {
            free(p as *mut libc::c_void);
            p = 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    kd_add(
        resp.as_mut_ptr(),
        b"Server\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"HairTunes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    kd_add(
        resp.as_mut_ptr(),
        b"Content-Type\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        mime_types[(*ctx).encode.config.codec as usize],
    );
    if (*ctx).range {
        str___0 = kd_lookup(
            headers.as_mut_ptr(),
            b"Range\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if str___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            sscanf(
                str___0 as *const libc::c_char,
                b"bytes=%zu\0" as *const u8 as *const libc::c_char,
                &mut offset as *mut size_t,
            );
            if (*ctx).http_count != 0 {
                if (*ctx).http_count > 2097152 as libc::c_ulong {
                    if offset
                        < ((*ctx).http_count)
                            .wrapping_sub(2097152 as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_ulong)
                    {
                        tmp___6 = offset;
                    } else {
                        tmp___6 = ((*ctx).http_count)
                            .wrapping_sub(2097152 as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_ulong);
                    }
                    offset = tmp___6;
                } else {
                    offset = 0 as libc::c_int as size_t;
                }
            } else {
                offset = 0 as libc::c_int as size_t;
            }
            if offset != 0 {
                if (*ctx).http_length == -(3 as libc::c_int) {
                    if HTTP_11 {
                        head = b"HTTP/1.1 206 Partial Content\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char;
                    } else {
                        head = b"HTTP/1.0 206 Partial Content\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char;
                    }
                } else {
                    head = b"HTTP/1.0 206 Partial Content\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char;
                }
                kd_vadd(
                    resp.as_mut_ptr(),
                    b"Content-Range\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"bytes %zu-%zu/*\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    offset,
                    (*ctx).http_count,
                );
            }
        }
    }
    if (*ctx).encode.config.codec as libc::c_uint == 0 as libc::c_uint {
        if (*ctx).encode.config.__annonCompField8.mp3.icy {
            str___0 = kd_lookup(
                headers.as_mut_ptr(),
                b"Icy-MetaData\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            if str___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___8 = atoi(str___0 as *const libc::c_char);
                if tmp___8 != 0 {
                    kd_vadd(
                        resp.as_mut_ptr(),
                        b"icy-metaint\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        b"%u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                        16384 as libc::c_int,
                    );
                    tmp___7 = 16384 as libc::c_int as size_t;
                    (*ctx).icy.remain = tmp___7;
                    (*ctx).icy.interval = tmp___7;
                } else {
                    (*ctx).icy.interval = 0 as libc::c_int as size_t;
                }
            } else {
                (*ctx).icy.interval = 0 as libc::c_int as size_t;
            }
        } else {
            (*ctx).icy.interval = 0 as libc::c_int as size_t;
        }
    } else {
        (*ctx).icy.interval = 0 as libc::c_int as size_t;
    }
    if ((*ctx).http_cb).is_some() {
        (Some(((*ctx).http_cb).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )((*ctx).owner, headers.as_mut_ptr(), resp.as_mut_ptr());
    }
    let mut current_block_134: u64;
    if (*ctx).http_length == -(3 as libc::c_int) {
        if HTTP_11 {
            tmp___9 = kd_lookup(
                headers.as_mut_ptr(),
                b"Connection\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            value = tmp___9;
            if !value.is_null() {
                tmp___10 = strcasecmp(
                    value as *const libc::c_char,
                    b"close\0" as *const u8 as *const libc::c_char,
                );
                if tmp___10 != 0 {
                    tmp___11 = strcasecmp(
                        value as *const libc::c_char,
                        b"keep-alive\0" as *const u8 as *const libc::c_char,
                    );
                    if tmp___11 != 0 {
                        kd_add(
                            resp.as_mut_ptr(),
                            b"Connection\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            b"close\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                    } else {
                        kd_add(
                            resp.as_mut_ptr(),
                            b"Connection\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            value,
                        );
                    }
                } else {
                    kd_add(
                        resp.as_mut_ptr(),
                        b"Connection\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        value,
                    );
                }
            } else {
                kd_add(
                    resp.as_mut_ptr(),
                    b"Connection\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"close\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            kd_add(
                resp.as_mut_ptr(),
                b"Transfer-Encoding\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                b"chunked\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if !head.is_null() {
                tmp___12 = head as *const libc::c_char;
            } else {
                tmp___12 = b"HTTP/1.1 200 OK\0" as *const u8 as *const libc::c_char;
            }
            str___0 = http_send(sock, tmp___12 as *mut libc::c_char, resp.as_mut_ptr());
            current_block_134 = 9073771928613846474;
        } else {
            current_block_134 = 1882601177311310470;
        }
    } else {
        current_block_134 = 1882601177311310470;
    }
    match current_block_134 {
        1882601177311310470 => {
            if (*ctx).http_length > 0 as libc::c_int {
                kd_vadd(
                    resp.as_mut_ptr(),
                    b"Content-Length\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%d\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*ctx).http_length,
                );
            }
            kd_add(
                resp.as_mut_ptr(),
                b"Connection\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                b"close\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if !head.is_null() {
                tmp___13 = head as *const libc::c_char;
            } else {
                tmp___13 = b"HTTP/1.0 200 OK\0" as *const u8 as *const libc::c_char;
            }
            str___0 = http_send(sock, tmp___13 as *mut libc::c_char, resp.as_mut_ptr());
        }
        _ => {}
    }
    if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
        tmp___14 = logtime();
        logprint(
            b"%s %s:%d [%p]: responding: %s\n\0" as *const u8 as *const libc::c_char,
            tmp___14,
            b"handle_http\0" as *const u8 as *const libc::c_char,
            1308 as libc::c_int,
            ctx,
            str___0,
        );
    }
    if !body.is_null() {
        free(body as *mut libc::c_void);
        body = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    kd_free(resp.as_mut_ptr());
    kd_free(headers.as_mut_ptr());
    tmp___15 = strstr(
        method.as_mut_ptr() as *const libc::c_char,
        b"HEAD\0" as *const u8 as *const libc::c_char,
    );
    if !tmp___15.is_null() {
        return 0 as libc::c_int != 0;
    }
    if offset != 0 {
        count___0 = 0 as libc::c_int as size_t;
        if *loglevel___2 as libc::c_uint >= 2 as libc::c_uint {
            tmp___16 = logtime();
            logprint(
                b"%s %s:%d [%p] re-sending offset %zu/%zu\n\0" as *const u8
                    as *const libc::c_char,
                tmp___16,
                b"handle_http\0" as *const u8 as *const libc::c_char,
                1321 as libc::c_int,
                ctx,
                offset,
                (*ctx).http_count,
            );
        }
        (*ctx).silence_count = 0 as libc::c_int as u32_t;
        while count___0 != ((*ctx).http_count).wrapping_sub(offset) {
            if (*ctx).icy.interval != 0 {
                tmp___17 = (*ctx).icy.remain;
            } else {
                tmp___17 = 16384 as libc::c_int as size_t;
            }
            bytes = tmp___17;
            if bytes < ((*ctx).http_count).wrapping_sub(offset).wrapping_sub(count___0) {
                bytes = bytes;
            } else {
                bytes = ((*ctx).http_count).wrapping_sub(offset).wrapping_sub(count___0);
            }
            sent = send_data(
                (*ctx).http_length == -(3 as libc::c_int),
                sock,
                ((*ctx).http_tail)
                    .offset(
                        offset
                            .wrapping_add(count___0)
                            .wrapping_rem(2097152 as libc::c_ulong) as isize,
                    ) as *mut libc::c_void,
                bytes as libc::c_int,
                0 as libc::c_int,
            );
            if sent < 0 as libc::c_int {
                tmp___18 = logtime();
                logprint(
                    b"%s %s:%d [%p]: error re-sending range %u\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___18,
                    b"handle_http\0" as *const u8 as *const libc::c_char,
                    1331 as libc::c_int,
                    ctx,
                    offset,
                );
                break;
            } else {
                count___0 = (count___0 as libc::c_ulong).wrapping_add(sent as size_t)
                    as size_t as size_t;
                if (*ctx).icy.interval != 0 {
                    (*ctx)
                        .icy
                        .remain = ((*ctx).icy.remain as libc::c_ulong)
                        .wrapping_sub(sent as size_t) as size_t as size_t;
                    if (*ctx).icy.remain == 0 {
                        send_data(
                            (*ctx).http_length == -(3 as libc::c_int),
                            sock,
                            b"\x01\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_void,
                            1 as libc::c_int,
                            0 as libc::c_int,
                        );
                        (*ctx).icy.remain = (*ctx).icy.interval;
                    }
                }
            }
        }
    }
    return 1 as libc::c_int != 0;
}
static mut loglevel___3: *mut log_level = unsafe {
    &raop_loglevel as *const log_level as *mut log_level
};
pub unsafe extern "C" fn raop_create(
    mut host: in_addr,
    mut svr: *mut mdnsd,
    mut name: *mut libc::c_char,
    mut model: *mut libc::c_char,
    mut mac: *mut libc::c_uchar,
    mut codec: *mut libc::c_char,
    mut metadata: bool,
    mut drift: bool,
    mut flush: bool,
    mut latencies: *mut libc::c_char,
    mut owner: *mut libc::c_void,
    mut raop_cb: Option::<
        unsafe extern "C" fn(*mut libc::c_void, raop_event_t, *mut libc::c_void) -> (),
    >,
    mut http_cb___0: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut key_data_s, *mut key_data_s) -> (),
    >,
    mut port_base: libc::c_ushort,
    mut port_range: libc::c_ushort,
    mut http_length: libc::c_int,
) -> *mut raop_ctx_s {
    let mut ctx: *mut raop_ctx_s = 0 as *mut raop_ctx_s;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut id: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut port: __anonstruct_port_213969425___0 = __anonstruct_port_213969425___0 {
        count: 0,
        offset: 0,
    };
    let mut txt: [*mut libc::c_char; 14] = [0 as *mut libc::c_char; 14];
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_ushort = 0;
    let mut tmp___9: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: size_t = 0;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___17: size_t = 0;
    tmp = malloc(::std::mem::size_of::<raop_ctx_s>() as libc::c_ulong);
    ctx = tmp as *mut raop_ctx_s;
    port.count = 0 as libc::c_int as libc::c_ushort;
    port.offset = 0 as libc::c_int as libc::c_ushort;
    txt[0 as libc::c_int as usize] = 0 as *mut libc::c_void as *mut libc::c_char;
    txt[1 as libc::c_int
        as usize] = b"tp=UDP\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[2 as libc::c_int
        as usize] = b"sm=false\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[3 as libc::c_int
        as usize] = b"sv=false\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[4 as libc::c_int
        as usize] = b"ek=1\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[5 as libc::c_int
        as usize] = b"et=0,1\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[6 as libc::c_int
        as usize] = b"md=0,1,2\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[7 as libc::c_int
        as usize] = b"cn=0,1\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[8 as libc::c_int
        as usize] = b"ch=2\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[9 as libc::c_int
        as usize] = b"ss=16\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[10 as libc::c_int
        as usize] = b"sr=44100\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[11 as libc::c_int
        as usize] = b"vn=3\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[12 as libc::c_int
        as usize] = b"txtvers=1\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[13 as libc::c_int as usize] = 0 as *mut libc::c_void as *mut libc::c_char;
    if ctx.is_null() {
        return 0 as *mut libc::c_void as *mut raop_ctx_s;
    }
    memset(
        ctx as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<raop_ctx_t>() as libc::c_ulong,
    );
    (*ctx).http_length = http_length;
    (*ctx).ports.base = port_base;
    (*ctx).ports.range = port_range;
    (*ctx).host = host;
    (*ctx).raop_cb = raop_cb;
    (*ctx).http_cb = http_cb___0;
    (*ctx).flush = flush;
    (*ctx).latencies = strdup(latencies as *const libc::c_char);
    (*ctx).owner = owner;
    (*ctx).drift = drift;
    tmp___6 = strcasecmp(
        codec as *const libc::c_char,
        b"pcm\0" as *const u8 as *const libc::c_char,
    );
    if tmp___6 != 0 {
        tmp___5 = strcasecmp(
            codec as *const libc::c_char,
            b"wav\0" as *const u8 as *const libc::c_char,
        );
        if tmp___5 != 0 {
            tmp___4 = strcasestr(
                codec as *const libc::c_char,
                b"mp3\0" as *const u8 as *const libc::c_char,
            );
            if !tmp___4.is_null() {
                (*ctx).encode.codec = CODEC_MP3;
                (*ctx).encode.__annonCompField8.mp3.icy = metadata;
                tmp___1 = strchr(codec as *const libc::c_char, ':' as i32);
                if !tmp___1.is_null() {
                    tmp___0 = strchr(codec as *const libc::c_char, ':' as i32);
                    (*ctx)
                        .encode
                        .__annonCompField8
                        .mp3
                        .bitrate = atoi(
                        tmp___0.offset(1 as libc::c_int as isize) as *const libc::c_char,
                    );
                }
            } else {
                (*ctx).encode.codec = CODEC_FLAC;
                tmp___3 = strchr(codec as *const libc::c_char, ':' as i32);
                if !tmp___3.is_null() {
                    tmp___2 = strchr(codec as *const libc::c_char, ':' as i32);
                    (*ctx)
                        .encode
                        .__annonCompField8
                        .flac
                        .level = atoi(
                        tmp___2.offset(1 as libc::c_int as isize) as *const libc::c_char,
                    );
                }
            }
        } else {
            (*ctx).encode.codec = CODEC_WAV;
        }
    } else {
        (*ctx).encode.codec = CODEC_PCM;
    }
    if port_base == 0 {
        port_range = 1 as libc::c_int as libc::c_ushort;
    }
    tmp___7 = rand();
    port.offset = (tmp___7 % port_range as libc::c_int) as libc::c_ushort;
    loop {
        tmp___8 = port.count;
        port.count = (port.count as libc::c_int + 1 as libc::c_int) as libc::c_ushort;
        (*ctx)
            .port = (port_base as libc::c_int
            + (port.offset as libc::c_int + tmp___8 as libc::c_int)
                % port_range as libc::c_int) as libc::c_ushort;
        (*ctx).sock = bind_socket(&mut (*ctx).port, 1 as libc::c_int);
        if !((*ctx).sock < 0 as libc::c_int) {
            break;
        }
        if !((port.count as libc::c_int) < port_range as libc::c_int) {
            break;
        }
    }
    's_347: {
        if !((*ctx).sock < 0 as libc::c_int) {
            tmp___12 = listen((*ctx).sock, 1 as libc::c_int);
            if !(tmp___12 != 0) {
                break 's_347;
            }
        }
        tmp___9 = __errno_location();
        tmp___10 = strerror(*tmp___9);
        tmp___11 = logtime();
        logprint(
            b"%s %s:%d Cannot bind or listen RTSP listener: %s\n\0" as *const u8
                as *const libc::c_char,
            tmp___11,
            b"raop_create\0" as *const u8 as *const libc::c_char,
            151 as libc::c_int,
            tmp___10,
        );
        close((*ctx).sock);
        free(ctx as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut raop_ctx_s;
    }
    tmp___13 = asprintf(
        &mut *txt.as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut *mut libc::c_char,
        b"am=%s\0" as *const u8 as *const libc::c_char,
        model,
    );
    if tmp___13 != 0 {
        tmp___14 = 0 as libc::c_int;
    } else {
        tmp___14 = 1 as libc::c_int;
    }
    tmp___15 = strlen(name as *const libc::c_char);
    tmp___16 = malloc(
        tmp___15
            .wrapping_add(12 as libc::c_ulong)
            .wrapping_add(1 as libc::c_ulong)
            .wrapping_add(1 as libc::c_ulong),
    );
    id = tmp___16 as *mut libc::c_char;
    memcpy(
        ((*ctx).mac).as_mut_ptr() as *mut libc::c_void,
        mac as *const libc::c_void,
        6 as libc::c_int as size_t,
    );
    i = 0 as libc::c_int;
    while i < 6 as libc::c_int {
        sprintf(
            id.offset((i * 2 as libc::c_int) as isize),
            b"%02X\0" as *const u8 as *const libc::c_char,
            *mac.offset(i as isize) as libc::c_int,
        );
        i += 1;
    }
    sprintf(
        id.offset(12 as libc::c_int as isize),
        b"@%s\0" as *const u8 as *const libc::c_char,
        name,
    );
    tmp___17 = strlen(id as *const libc::c_char);
    if tmp___17 > 63 as libc::c_ulong {
        *id.offset(63 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    }
    (*ctx).svr = svr;
    (*ctx)
        .svc = mdnsd_register_svc(
        svr,
        id as *const libc::c_char,
        b"_raop._tcp.local\0" as *const u8 as *const libc::c_char,
        (*ctx).port,
        0 as *mut libc::c_void as *const libc::c_char,
        txt.as_mut_ptr() as *mut *const libc::c_char,
    );
    free(txt[0 as libc::c_int as usize] as *mut libc::c_void);
    free(id as *mut libc::c_void);
    (*ctx).running = 1 as libc::c_int != 0;
    pthread_create(
        &mut (*ctx).thread as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        Some(
            rtsp_thread as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        ),
        ctx as *mut libc::c_void,
    );
    return ctx;
}
pub unsafe extern "C" fn raop_update(
    mut ctx: *mut raop_ctx_s,
    mut name: *mut libc::c_char,
    mut model: *mut libc::c_char,
) {
    let mut id: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut txt: [*mut libc::c_char; 14] = [0 as *mut libc::c_char; 14];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: size_t = 0;
    txt[0 as libc::c_int as usize] = 0 as *mut libc::c_void as *mut libc::c_char;
    txt[1 as libc::c_int
        as usize] = b"tp=UDP\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[2 as libc::c_int
        as usize] = b"sm=false\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[3 as libc::c_int
        as usize] = b"sv=false\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[4 as libc::c_int
        as usize] = b"ek=1\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[5 as libc::c_int
        as usize] = b"et=0,1\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[6 as libc::c_int
        as usize] = b"md=0,1,2\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[7 as libc::c_int
        as usize] = b"cn=0,1\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[8 as libc::c_int
        as usize] = b"ch=2\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[9 as libc::c_int
        as usize] = b"ss=16\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[10 as libc::c_int
        as usize] = b"sr=44100\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[11 as libc::c_int
        as usize] = b"vn=3\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    txt[12 as libc::c_int
        as usize] = b"txtvers=1\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    txt[13 as libc::c_int as usize] = 0 as *mut libc::c_void as *mut libc::c_char;
    if ctx.is_null() {
        return;
    }
    mdns_service_remove((*ctx).svr, (*ctx).svc);
    tmp = asprintf(
        &mut *txt.as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut *mut libc::c_char,
        b"am=%s\0" as *const u8 as *const libc::c_char,
        model,
    );
    if tmp != 0 {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp___0 = 1 as libc::c_int;
    }
    tmp___1 = strlen(name as *const libc::c_char);
    tmp___2 = malloc(
        tmp___1
            .wrapping_add(12 as libc::c_ulong)
            .wrapping_add(1 as libc::c_ulong)
            .wrapping_add(1 as libc::c_ulong),
    );
    id = tmp___2 as *mut libc::c_char;
    i = 0 as libc::c_int;
    while i < 6 as libc::c_int {
        sprintf(
            id.offset((i * 2 as libc::c_int) as isize),
            b"%02X\0" as *const u8 as *const libc::c_char,
            (*ctx).mac[i as usize] as libc::c_int,
        );
        i += 1;
    }
    sprintf(
        id.offset(12 as libc::c_int as isize),
        b"@%s\0" as *const u8 as *const libc::c_char,
        name,
    );
    tmp___3 = strlen(id as *const libc::c_char);
    if tmp___3 > 63 as libc::c_ulong {
        *id.offset(63 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    }
    (*ctx)
        .svc = mdnsd_register_svc(
        (*ctx).svr,
        id as *const libc::c_char,
        b"_raop._tcp.local\0" as *const u8 as *const libc::c_char,
        (*ctx).port,
        0 as *mut libc::c_void as *const libc::c_char,
        txt.as_mut_ptr() as *mut *const libc::c_char,
    );
    free(txt[0 as libc::c_int as usize] as *mut libc::c_void);
    free(id as *mut libc::c_void);
}
pub unsafe extern "C" fn raop_delete(mut ctx: *mut raop_ctx_s) {
    let mut sock: libc::c_int = 0;
    let mut addr: sockaddr = sockaddr {
        sa_family: 0,
        sa_data: [0; 14],
    };
    let mut nlen: socklen_t = 0;
    nlen = ::std::mem::size_of::<sockaddr>() as libc::c_ulong as socklen_t;
    if ctx.is_null() {
        return;
    }
    (*ctx).running = 0 as libc::c_int != 0;
    sock = socket(2 as libc::c_int, 1 as libc::c_int, 0 as libc::c_int);
    getsockname((*ctx).sock, &mut addr as *mut sockaddr, &mut nlen as *mut socklen_t);
    connect(
        sock,
        &mut addr as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr>() as libc::c_ulong as socklen_t,
    );
    close(sock);
    pthread_join((*ctx).thread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
    hairtunes_end((*ctx).ht);
    shutdown((*ctx).sock, 2 as libc::c_int);
    close((*ctx).sock);
    if !((*ctx).active_remote.handle).is_null() {
        close_mDNS((*ctx).active_remote.handle);
        pthread_join(
            (*ctx).search_thread,
            0 as *mut libc::c_void as *mut *mut libc::c_void,
        );
    }
    if !((*ctx).rtsp.aeskey).is_null() {
        free((*ctx).rtsp.aeskey as *mut libc::c_void);
        (*ctx).rtsp.aeskey = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*ctx).rtsp.aesiv).is_null() {
        free((*ctx).rtsp.aesiv as *mut libc::c_void);
        (*ctx).rtsp.aesiv = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*ctx).rtsp.fmtp).is_null() {
        free((*ctx).rtsp.fmtp as *mut libc::c_void);
        (*ctx).rtsp.fmtp = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    free((*ctx).latencies as *mut libc::c_void);
    mdns_service_remove((*ctx).svr, (*ctx).svc);
    free(ctx as *mut libc::c_void);
}
pub unsafe extern "C" fn raop_notify(
    mut ctx: *mut raop_ctx_s,
    mut event: raop_event_t,
    mut param: *mut libc::c_void,
) {
    let mut addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut sock: libc::c_int = 0;
    let mut command: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut Volume: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut method: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut buf___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut resp: [libc::c_char; 512] = [0; 512];
    let mut tmp___1: libc::c_uint = 0;
    let mut len: libc::c_int = 0;
    let mut headers: [key_data_t; 4] = [key_data_t {
        key: 0 as *mut libc::c_char,
        data: 0 as *mut libc::c_char,
    }; 4];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: ssize_t = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: libc::c_int = 0;
    command = 0 as *mut libc::c_void as *mut libc::c_char;
    if ctx.is_null() {
        return;
    }
    match event as libc::c_uint {
        3 => {
            command = strdup(b"pause\0" as *const u8 as *const libc::c_char);
        }
        1 => {
            command = strdup(b"play\0" as *const u8 as *const libc::c_char);
        }
        4 => {
            command = strdup(b"stop\0" as *const u8 as *const libc::c_char);
        }
        5 => {
            Volume = *(param as *mut libc::c_double);
            if Volume != 0. {
                Volume = (Volume - 1 as libc::c_int as libc::c_double)
                    * 30 as libc::c_int as libc::c_double;
            } else {
                Volume = -(144 as libc::c_int) as libc::c_double;
            }
            tmp = asprintf(
                &mut command as *mut *mut libc::c_char,
                b"setproperty?dmcp.device-volume=%0.4lf\0" as *const u8
                    as *const libc::c_char,
                Volume,
            );
            if tmp != 0 {
                tmp___0 = 0 as libc::c_int;
            } else {
                tmp___0 = 1 as libc::c_int;
            }
        }
        _ => {}
    }
    's_163: {
        if !command.is_null() {
            if !((*ctx).active_remote.port == 0) {
                break 's_163;
            }
        }
        if !command.is_null() {
            free(command as *mut libc::c_void);
            command = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        return;
    }
    sock = socket(2 as libc::c_int, 1 as libc::c_int, 0 as libc::c_int);
    memset(
        &mut addr as *mut sockaddr_in as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    addr.sin_family = 2 as libc::c_int as sa_family_t;
    addr.sin_addr.s_addr = (*ctx).active_remote.host.s_addr;
    addr.sin_port = __bswap_16((*ctx).active_remote.port);
    tmp___7 = connect(
        sock,
        &mut addr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
    );
    if tmp___7 == 0 {
        resp[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        tmp___1 = 1 as libc::c_uint;
        while !(tmp___1 >= 512 as libc::c_uint) {
            resp[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = tmp___1.wrapping_add(1);
        }
        headers[0 as libc::c_int as usize]
            .key = 0 as *mut libc::c_void as *mut libc::c_char;
        headers[0 as libc::c_int as usize]
            .data = 0 as *mut libc::c_void as *mut libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 4 as libc::c_uint) {
            headers[tmp___2 as usize].key = 0 as *mut libc::c_char;
            headers[tmp___2 as usize].data = 0 as *mut libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = asprintf(
            &mut method as *mut *mut libc::c_char,
            b"GET /ctrl-int/1/%s HTTP/1.0\0" as *const u8 as *const libc::c_char,
            command,
        );
        if tmp___3 != 0 {
            tmp___4 = 0 as libc::c_int;
        } else {
            tmp___4 = 1 as libc::c_int;
        }
        kd_add(
            headers.as_mut_ptr(),
            b"Active-Remote\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ((*ctx).active_remote.id).as_mut_ptr(),
        );
        kd_add(
            headers.as_mut_ptr(),
            b"Connection\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"close\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        buf___0 = http_send(sock, method, headers.as_mut_ptr());
        tmp___5 = recv(
            sock,
            resp.as_mut_ptr() as *mut libc::c_void,
            512 as libc::c_int as size_t,
            0 as libc::c_int,
        );
        len = tmp___5 as libc::c_int;
        if len > 0 as libc::c_int {
            resp[(len - 1 as libc::c_int) as usize] = '\u{0}' as i32 as libc::c_char;
        }
        if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
            tmp___6 = logtime();
            logprint(
                b"%s %s:%d [%p]: sending airplay remote\n%s<== received ==>\n%s\n\0"
                    as *const u8 as *const libc::c_char,
                tmp___6,
                b"raop_notify\0" as *const u8 as *const libc::c_char,
                316 as libc::c_int,
                ctx,
                buf___0,
                resp.as_mut_ptr(),
            );
        }
        if !method.is_null() {
            free(method as *mut libc::c_void);
            method = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if !buf___0.is_null() {
            free(buf___0 as *mut libc::c_void);
            buf___0 = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        kd_free(headers.as_mut_ptr());
    }
    free(command as *mut libc::c_void);
    close(sock);
}
unsafe extern "C" fn rtsp_thread(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut ctx: *mut raop_ctx_t = 0 as *mut raop_ctx_t;
    let mut sock: libc::c_int = 0;
    let mut rfds: fd_set = fd_set { fds_bits: [0; 16] };
    let mut timeout: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut n: libc::c_int = 0;
    let mut res: bool = false;
    let mut peer: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut addrlen: socklen_t = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    ctx = arg as *mut raop_ctx_t;
    sock = -(1 as libc::c_int);
    while (*ctx).running {
        timeout.tv_sec = 0 as libc::c_int as __time_t;
        timeout.tv_usec = 100000 as libc::c_int as __suseconds_t;
        res = 0 as libc::c_int != 0;
        if sock == -(1 as libc::c_int) {
            addrlen = ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
            sock = accept(
                (*ctx).sock,
                &mut peer as *mut sockaddr_in as *mut sockaddr,
                &mut addrlen as *mut socklen_t,
            );
            (*ctx).peer.s_addr = peer.sin_addr.s_addr;
            if !(sock != -(1 as libc::c_int)) {
                continue;
            }
            if !(*ctx).running {
                continue;
            }
            if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
                tmp = logtime();
                logprint(
                    b"%s %s:%d got RTSP connection %u\n\0" as *const u8
                        as *const libc::c_char,
                    tmp,
                    b"rtsp_thread\0" as *const u8 as *const libc::c_char,
                    347 as libc::c_int,
                    sock,
                );
            }
        }
        let fresh19 = &mut __d0;
        let fresh20;
        let fresh21 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh22 = &mut __d1;
        let fresh23;
        let fresh24 = &mut *(rfds.fds_bits)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh19, fresh21) => fresh20,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh22, fresh24) =>
            fresh23, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh19, fresh21, fresh20);
        c2rust_asm_casts::AsmCast::cast_out(fresh22, fresh24, fresh23);
        rfds
            .fds_bits[(sock
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << sock
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        n = select(
            sock + 1 as libc::c_int,
            &mut rfds as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut timeout as *mut timeval,
        );
        if n == 0 {
            continue;
        }
        if n > 0 as libc::c_int {
            res = handle_rtsp(ctx, sock);
        }
        let mut current_block_25: u64;
        if n < 0 as libc::c_int {
            current_block_25 = 9862168255352908997;
        } else if !res {
            current_block_25 = 9862168255352908997;
        } else {
            current_block_25 = 18153031941552419006;
        }
        match current_block_25 {
            9862168255352908997 => {
                close(sock);
                if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
                    tmp___0 = logtime();
                    logprint(
                        b"%s %s:%d RTSP close %u\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___0,
                        b"rtsp_thread\0" as *const u8 as *const libc::c_char,
                        362 as libc::c_int,
                        sock,
                    );
                }
                sock = -(1 as libc::c_int);
            }
            _ => {}
        }
    }
    if sock != -(1 as libc::c_int) {
        close(sock);
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn handle_rtsp(
    mut ctx: *mut raop_ctx_t,
    mut sock: libc::c_int,
) -> bool {
    let mut buf___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut body: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut method: [libc::c_char; 16] = [0; 16];
    let mut tmp: libc::c_uint = 0;
    let mut headers: [key_data_t; 64] = [key_data_t {
        key: 0 as *mut libc::c_char,
        data: 0 as *mut libc::c_char,
    }; 64];
    let mut resp: [key_data_t; 16] = [key_data_t {
        key: 0 as *mut libc::c_char,
        data: 0 as *mut libc::c_char,
    }; 16];
    let mut tmp___0: libc::c_uint = 0;
    let mut len: libc::c_int = 0;
    let mut success: bool = false;
    let mut tmp___1: bool = false;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut buf_pad: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data_b64: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___11: size_t = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut padded: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aeskey: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut len___0: libc::c_int = 0;
    let mut outlen: libc::c_int = 0;
    let mut tmp___13: size_t = 0;
    let mut tmp___14: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___15: size_t = 0;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut p___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ht: hairtunes_resp_t = hairtunes_resp_t {
        cport: 0,
        tport: 0,
        aport: 0,
        hport: 0,
        ctx: 0 as *mut hairtunes_s,
    };
    let mut tport: libc::c_ushort = 0;
    let mut cport: libc::c_ushort = 0;
    let mut transport: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___20: *const libc::c_char = 0 as *const libc::c_char;
    let mut seqno: libc::c_ushort = 0;
    let mut rtptime: libc::c_uint = 0;
    let mut p___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut latency: [libc::c_char; 6] = [0; 6];
    let mut tmp___21: libc::c_int = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut seqno___0: libc::c_ushort = 0;
    let mut rtptime___0: libc::c_uint = 0;
    let mut p___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___23: bool = false;
    let mut p___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut volume: libc::c_double = 0.;
    let mut tmp___24: *const libc::c_char = 0 as *const libc::c_char;
    let mut metadata: metadata_s = metadata_s {
        artist: 0 as *mut libc::c_char,
        album: 0 as *mut libc::c_char,
        title: 0 as *mut libc::c_char,
        genre: 0 as *mut libc::c_char,
        path: 0 as *mut libc::c_char,
        artwork: 0 as *mut libc::c_char,
        remote_title: 0 as *mut libc::c_char,
        track: 0,
        duration: 0,
        track_hash: 0,
        sample_rate: 0,
        sample_size: 0,
        channels: 0,
    };
    let mut settings: dmap_settings = dmap_settings {
        on_dict_start: None,
        on_dict_end: None,
        on_int32: None,
        on_int64: None,
        on_uint32: None,
        on_uint64: None,
        on_date: None,
        on_string: None,
        on_data: None,
        ctx: 0 as *mut libc::c_void,
    };
    let mut tmp___25: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___26: libc::c_int = 0;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: libc::c_int = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: libc::c_int = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut tmp___36: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___37: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___38: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___39: libc::c_int = 0;
    buf___0 = 0 as *mut libc::c_void as *mut libc::c_char;
    body = 0 as *mut libc::c_void as *mut libc::c_char;
    method[0 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 16 as libc::c_uint) {
        method[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    resp[0 as libc::c_int as usize].key = 0 as *mut libc::c_void as *mut libc::c_char;
    resp[0 as libc::c_int as usize].data = 0 as *mut libc::c_void as *mut libc::c_char;
    tmp___0 = 1 as libc::c_uint;
    while !(tmp___0 >= 16 as libc::c_uint) {
        resp[tmp___0 as usize].key = 0 as *mut libc::c_char;
        resp[tmp___0 as usize].data = 0 as *mut libc::c_char;
        tmp___0 = tmp___0.wrapping_add(1);
    }
    success = 1 as libc::c_int != 0;
    tmp___1 = http_parse(
        sock,
        method.as_mut_ptr(),
        0 as *mut libc::c_void as *mut libc::c_char,
        0 as *mut libc::c_void as *mut libc::c_char,
        headers.as_mut_ptr(),
        &mut body,
        &mut len,
    );
    if !tmp___1 {
        if !body.is_null() {
            free(body as *mut libc::c_void);
            body = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        kd_free(headers.as_mut_ptr());
        return 0 as libc::c_int != 0;
    }
    tmp___3 = strcmp(
        method.as_mut_ptr() as *const libc::c_char,
        b"OPTIONS\0" as *const u8 as *const libc::c_char,
    );
    if tmp___3 != 0 {
        if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
            tmp___2 = logtime();
            logprint(
                b"%s %s:%d [%p]: received %s\n\0" as *const u8 as *const libc::c_char,
                tmp___2,
                b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                388 as libc::c_int,
                ctx,
                method.as_mut_ptr(),
            );
        }
    }
    buf___0 = kd_lookup(
        headers.as_mut_ptr(),
        b"Apple-Challenge\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if buf___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        data_b64 = 0 as *mut libc::c_void as *mut libc::c_char;
        if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
            tmp___4 = logtime();
            logprint(
                b"%s %s:%d [%p]: challenge %s\n\0" as *const u8 as *const libc::c_char,
                tmp___4,
                b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                395 as libc::c_int,
                ctx,
                buf___0,
            );
        }
        base64_pad(buf___0, &mut buf_pad);
        tmp___8 = base64_decode(
            buf_pad as *const libc::c_char,
            data.as_mut_ptr() as *mut libc::c_void,
        );
        if tmp___8 < 22 as libc::c_int {
            tmp___6 = base64_decode(
                buf_pad as *const libc::c_char,
                data.as_mut_ptr() as *mut libc::c_void,
            );
            tmp___7 = tmp___6;
        } else {
            tmp___7 = 22 as libc::c_int;
        }
        p = data.as_mut_ptr().offset(tmp___7 as isize);
        tmp___9 = memcpy(
            p as *mut libc::c_void,
            &mut (*ctx).host.s_addr as *mut in_addr_t as *const libc::c_void,
            4 as libc::c_int as size_t,
        );
        p = (tmp___9 as *mut libc::c_char).offset(4 as libc::c_int as isize);
        tmp___10 = memcpy(
            p as *mut libc::c_void,
            ((*ctx).mac).as_mut_ptr() as *const libc::c_void,
            6 as libc::c_int as size_t,
        );
        p = (tmp___10 as *mut libc::c_char).offset(6 as libc::c_int as isize);
        memset(
            p as *mut libc::c_void,
            0 as libc::c_int,
            (32 as libc::c_long - p.offset_from(data.as_mut_ptr()) as libc::c_long)
                as size_t,
        );
        p = rsa_apply(
            data.as_mut_ptr() as *mut libc::c_uchar,
            32 as libc::c_int,
            &mut n,
            1 as libc::c_int,
        );
        n = base64_encode(p as *const libc::c_void, n, &mut data_b64);
        tmp___11 = strlen(data_b64 as *const libc::c_char);
        n = tmp___11.wrapping_sub(1 as libc::c_ulong) as libc::c_int;
        while n > 0 as libc::c_int {
            if !(*data_b64.offset(n as isize) as libc::c_int == 61 as libc::c_int) {
                break;
            }
            tmp___12 = n;
            n -= 1;
            *data_b64.offset(tmp___12 as isize) = '\u{0}' as i32 as libc::c_char;
        }
        kd_add(
            resp.as_mut_ptr(),
            b"Apple-Response\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            data_b64,
        );
        if !p.is_null() {
            free(p as *mut libc::c_void);
            p = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if !buf_pad.is_null() {
            free(buf_pad as *mut libc::c_void);
            buf_pad = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        if !data_b64.is_null() {
            free(data_b64 as *mut libc::c_void);
            data_b64 = 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    tmp___35 = strcmp(
        method.as_mut_ptr() as *const libc::c_char,
        b"OPTIONS\0" as *const u8 as *const libc::c_char,
    );
    if tmp___35 != 0 {
        tmp___34 = strcmp(
            method.as_mut_ptr() as *const libc::c_char,
            b"ANNOUNCE\0" as *const u8 as *const libc::c_char,
        );
        let mut current_block_311: u64;
        if tmp___34 != 0 {
            current_block_311 = 6128504694233661866;
        } else if !body.is_null() {
            if !((*ctx).rtsp.aeskey).is_null() {
                free((*ctx).rtsp.aeskey as *mut libc::c_void);
                (*ctx).rtsp.aeskey = 0 as *mut libc::c_void as *mut libc::c_char;
            }
            if !((*ctx).rtsp.aesiv).is_null() {
                free((*ctx).rtsp.aesiv as *mut libc::c_void);
                (*ctx).rtsp.aesiv = 0 as *mut libc::c_void as *mut libc::c_char;
            }
            if !((*ctx).rtsp.fmtp).is_null() {
                free((*ctx).rtsp.fmtp as *mut libc::c_void);
                (*ctx).rtsp.fmtp = 0 as *mut libc::c_void as *mut libc::c_char;
            }
            p___0 = strcasestr(
                body as *const libc::c_char,
                b"rsaaeskey\0" as *const u8 as *const libc::c_char,
            );
            if p___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                p___0 = strextract(
                    p___0,
                    b":\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    b"\r\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                base64_pad(p___0, &mut padded);
                tmp___13 = strlen(padded as *const libc::c_char);
                tmp___14 = malloc(tmp___13);
                aeskey = tmp___14 as *mut libc::c_uchar;
                len___0 = base64_decode(
                    padded as *const libc::c_char,
                    aeskey as *mut libc::c_void,
                );
                (*ctx)
                    .rtsp
                    .aeskey = rsa_apply(aeskey, len___0, &mut outlen, 0 as libc::c_int);
                if !p___0.is_null() {
                    free(p___0 as *mut libc::c_void);
                    p___0 = 0 as *mut libc::c_void as *mut libc::c_char;
                }
                if !aeskey.is_null() {
                    free(aeskey as *mut libc::c_void);
                    aeskey = 0 as *mut libc::c_void as *mut libc::c_uchar;
                }
                if !padded.is_null() {
                    free(padded as *mut libc::c_void);
                    padded = 0 as *mut libc::c_void as *mut libc::c_char;
                }
            }
            p___0 = strcasestr(
                body as *const libc::c_char,
                b"aesiv\0" as *const u8 as *const libc::c_char,
            );
            if p___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                p___0 = strextract(
                    p___0,
                    b":\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    b"\r\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                base64_pad(p___0, &mut padded);
                tmp___15 = strlen(padded as *const libc::c_char);
                tmp___16 = malloc(tmp___15);
                (*ctx).rtsp.aesiv = tmp___16 as *mut libc::c_char;
                base64_decode(
                    padded as *const libc::c_char,
                    (*ctx).rtsp.aesiv as *mut libc::c_void,
                );
                if !p___0.is_null() {
                    free(p___0 as *mut libc::c_void);
                    p___0 = 0 as *mut libc::c_void as *mut libc::c_char;
                }
                if !padded.is_null() {
                    free(padded as *mut libc::c_void);
                    padded = 0 as *mut libc::c_void as *mut libc::c_char;
                }
            }
            p___0 = strcasestr(
                body as *const libc::c_char,
                b"fmtp\0" as *const u8 as *const libc::c_char,
            );
            if p___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                p___0 = strextract(
                    p___0,
                    b":\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    b"\r\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                (*ctx).rtsp.fmtp = strdup(p___0 as *const libc::c_char);
                if !p___0.is_null() {
                    free(p___0 as *mut libc::c_void);
                    p___0 = 0 as *mut libc::c_void as *mut libc::c_char;
                }
            }
            buf___0 = kd_lookup(
                headers.as_mut_ptr(),
                b"DACP-ID\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if buf___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                strcpy(
                    ((*ctx).active_remote.DACPid).as_mut_ptr(),
                    buf___0 as *const libc::c_char,
                );
            }
            buf___0 = kd_lookup(
                headers.as_mut_ptr(),
                b"Active-Remote\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            if buf___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                strcpy(
                    ((*ctx).active_remote.id).as_mut_ptr(),
                    buf___0 as *const libc::c_char,
                );
            }
            (*ctx).active_remote.handle = init_mDNS(0 as libc::c_int, (*ctx).host);
            pthread_create(
                &mut (*ctx).search_thread as *mut pthread_t,
                0 as *mut libc::c_void as *const pthread_attr_t,
                Some(
                    search_remote
                        as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
                ),
                ctx as *mut libc::c_void,
            );
            current_block_311 = 17249482508640382006;
        } else {
            current_block_311 = 6128504694233661866;
        }
        match current_block_311 {
            6128504694233661866 => {
                tmp___33 = strcmp(
                    method.as_mut_ptr() as *const libc::c_char,
                    b"SETUP\0" as *const u8 as *const libc::c_char,
                );
                let mut current_block_239: u64;
                if tmp___33 != 0 {
                    current_block_239 = 10829458354676386731;
                } else {
                    buf___0 = kd_lookup(
                        headers.as_mut_ptr(),
                        b"Transport\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    if buf___0 as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        tport = 0 as libc::c_int as libc::c_ushort;
                        cport = 0 as libc::c_int as libc::c_ushort;
                        p___1 = strcasestr(
                            buf___0 as *const libc::c_char,
                            b"timing_port\0" as *const u8 as *const libc::c_char,
                        );
                        if p___1 as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            sscanf(
                                p___1 as *const libc::c_char,
                                b"%*[^=]=%hu\0" as *const u8 as *const libc::c_char,
                                &mut tport as *mut libc::c_ushort,
                            );
                        }
                        p___1 = strcasestr(
                            buf___0 as *const libc::c_char,
                            b"control_port\0" as *const u8 as *const libc::c_char,
                        );
                        if p___1 as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            sscanf(
                                p___1 as *const libc::c_char,
                                b"%*[^=]=%hu\0" as *const u8 as *const libc::c_char,
                                &mut cport as *mut libc::c_ushort,
                            );
                        }
                        ht = hairtunes_init(
                            (*ctx).peer,
                            (*ctx).encode,
                            0 as libc::c_int != 0,
                            (*ctx).drift,
                            1 as libc::c_int != 0,
                            (*ctx).latencies,
                            (*ctx).rtsp.aeskey,
                            (*ctx).rtsp.aesiv,
                            (*ctx).rtsp.fmtp,
                            cport,
                            tport,
                            ctx as *mut libc::c_void,
                            Some(
                                event_cb
                                    as unsafe extern "C" fn(
                                        *mut libc::c_void,
                                        hairtunes_event_t,
                                    ) -> (),
                            ),
                            Some(
                                http_cb
                                    as unsafe extern "C" fn(
                                        *mut libc::c_void,
                                        *mut key_data_s,
                                        *mut key_data_s,
                                    ) -> (),
                            ),
                            (*ctx).ports.base,
                            (*ctx).ports.range,
                            (*ctx).http_length,
                        );
                        (*ctx).hport = ht.hport;
                        (*ctx).ht = ht.ctx;
                        let mut current_block_237: u64;
                        if cport as libc::c_int * tport as libc::c_int
                            * ht.cport as libc::c_int * ht.tport as libc::c_int
                            * ht.aport as libc::c_int * ht.hport as libc::c_int != 0
                        {
                            if !(ht.ctx).is_null() {
                                tmp___17 = asprintf(
                                    &mut transport as *mut *mut libc::c_char,
                                    b"RTP/AVP/UDP;unicast;mode=record;control_port=%u;timing_port=%u;server_port=%u\0"
                                        as *const u8 as *const libc::c_char,
                                    ht.cport as libc::c_int,
                                    ht.tport as libc::c_int,
                                    ht.aport as libc::c_int,
                                );
                                if tmp___17 != 0 {
                                    tmp___18 = 0 as libc::c_int;
                                } else {
                                    tmp___18 = 1 as libc::c_int;
                                }
                                if *loglevel___3 as libc::c_uint >= 3 as libc::c_uint {
                                    tmp___19 = logtime();
                                    logprint(
                                        b"%s %s:%d [%p]: http=(%hu) audio=(%hu:%hu), timing=(%hu:%hu), control=(%hu:%hu)\n\0"
                                            as *const u8 as *const libc::c_char,
                                        tmp___19,
                                        b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                                        485 as libc::c_int,
                                        ctx,
                                        ht.hport as libc::c_int,
                                        0 as libc::c_int,
                                        ht.aport as libc::c_int,
                                        tport as libc::c_int,
                                        ht.tport as libc::c_int,
                                        cport as libc::c_int,
                                        ht.cport as libc::c_int,
                                    );
                                }
                                kd_add(
                                    resp.as_mut_ptr(),
                                    b"Transport\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                    transport,
                                );
                                kd_add(
                                    resp.as_mut_ptr(),
                                    b"Session\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                    b"DEADBEEF\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                                free(transport as *mut libc::c_void);
                                current_block_237 = 162359820444412279;
                            } else {
                                current_block_237 = 7202970115922898249;
                            }
                        } else {
                            current_block_237 = 7202970115922898249;
                        }
                        match current_block_237 {
                            7202970115922898249 => {
                                success = 0 as libc::c_int != 0;
                                if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
                                    tmp___20 = logtime();
                                    logprint(
                                        b"%s %s:%d [%p]: cannot start session, missing ports\n\0"
                                            as *const u8 as *const libc::c_char,
                                        tmp___20,
                                        b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                                        491 as libc::c_int,
                                        ctx,
                                    );
                                }
                            }
                            _ => {}
                        }
                        current_block_239 = 12252098823794565961;
                    } else {
                        current_block_239 = 10829458354676386731;
                    }
                }
                match current_block_239 {
                    10829458354676386731 => {
                        tmp___32 = strcmp(
                            method.as_mut_ptr() as *const libc::c_char,
                            b"RECORD\0" as *const u8 as *const libc::c_char,
                        );
                        if tmp___32 != 0 {
                            tmp___31 = strcmp(
                                method.as_mut_ptr() as *const libc::c_char,
                                b"FLUSH\0" as *const u8 as *const libc::c_char,
                            );
                            if tmp___31 != 0 {
                                tmp___30 = strcmp(
                                    method.as_mut_ptr() as *const libc::c_char,
                                    b"TEARDOWN\0" as *const u8 as *const libc::c_char,
                                );
                                if tmp___30 != 0 {
                                    tmp___29 = strcmp(
                                        method.as_mut_ptr() as *const libc::c_char,
                                        b"SET_PARAMETER\0" as *const u8 as *const libc::c_char,
                                    );
                                    if tmp___29 != 0 {
                                        success = 0 as libc::c_int != 0;
                                        tmp___28 = logtime();
                                        logprint(
                                            b"%s %s:%d [%p]: unknown/unhandled method %s\n\0"
                                                as *const u8 as *const libc::c_char,
                                            tmp___28,
                                            b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                                            580 as libc::c_int,
                                            ctx,
                                            method.as_mut_ptr(),
                                        );
                                    } else {
                                        if !body.is_null() {
                                            p___4 = strcasestr(
                                                body as *const libc::c_char,
                                                b"volume\0" as *const u8 as *const libc::c_char,
                                            );
                                            if p___4 as libc::c_ulong
                                                != 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                sscanf(
                                                    p___4 as *const libc::c_char,
                                                    b"%*[^:]:%lf\0" as *const u8 as *const libc::c_char,
                                                    &mut volume as *mut libc::c_double,
                                                );
                                                if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
                                                    tmp___24 = logtime();
                                                    logprint(
                                                        b"%s %s:%d [%p]: SET PARAMETER volume %lf\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        tmp___24,
                                                        b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                                                        555 as libc::c_int,
                                                        ctx,
                                                        volume,
                                                    );
                                                }
                                                if volume == -144.0f64 {
                                                    volume = 0 as libc::c_int as libc::c_double;
                                                } else {
                                                    volume = 1 as libc::c_int as libc::c_double
                                                        + volume / 30 as libc::c_int as libc::c_double;
                                                }
                                                (Some(((*ctx).raop_cb).expect("non-null function pointer")))
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    (*ctx).owner,
                                                    RAOP_VOLUME,
                                                    &mut volume as *mut libc::c_double as *mut libc::c_void,
                                                );
                                            }
                                        }
                                        p___4 = kd_lookup(
                                            headers.as_mut_ptr(),
                                            b"Content-Type\0" as *const u8 as *const libc::c_char
                                                as *mut libc::c_char,
                                        );
                                        if p___4 as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___27 = strcasecmp(
                                                p___4 as *const libc::c_char,
                                                b"application/x-dmap-tagged\0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            if tmp___27 == 0 {
                                                settings
                                                    .on_dict_start = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_dict_end = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_int32 = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            int32_t,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_int64 = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            int64_t,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_uint32 = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            uint32_t,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_uint64 = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            uint64_t,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_date = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            uint32_t,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings
                                                    .on_string = Some(
                                                    on_dmap_string
                                                        as unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            size_t,
                                                        ) -> (),
                                                );
                                                settings
                                                    .on_data = ::std::mem::transmute::<
                                                    *mut libc::c_void,
                                                    Option::<
                                                        unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            *const libc::c_char,
                                                            size_t,
                                                        ) -> (),
                                                    >,
                                                >(0 as *mut libc::c_void);
                                                settings.ctx = 0 as *mut libc::c_void;
                                                settings
                                                    .ctx = &mut metadata as *mut metadata_s
                                                    as *mut libc::c_void;
                                                memset(
                                                    &mut metadata as *mut metadata_s as *mut libc::c_void,
                                                    0 as libc::c_int,
                                                    ::std::mem::size_of::<metadata_s>() as libc::c_ulong,
                                                );
                                                tmp___26 = dmap_parse(
                                                    &mut settings as *mut dmap_settings as *const dmap_settings,
                                                    body as *const libc::c_char,
                                                    len as size_t,
                                                );
                                                if tmp___26 == 0 {
                                                    hairtunes_metadata((*ctx).ht, &mut metadata);
                                                    if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
                                                        tmp___25 = logtime();
                                                        logprint(
                                                            b"%s %s:%d [%p]: received metadata\n\tartist: %s\n\talbum:  %s\n\ttitle:  %s\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            tmp___25,
                                                            b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                                                            572 as libc::c_int,
                                                            ctx,
                                                            metadata.artist,
                                                            metadata.album,
                                                            metadata.title,
                                                        );
                                                    }
                                                    free_metadata(&mut metadata);
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    (Some(((*ctx).raop_cb).expect("non-null function pointer")))
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        (*ctx).owner,
                                        RAOP_STOP,
                                        &mut (*ctx).hport as *mut libc::c_ushort
                                            as *mut libc::c_void,
                                    );
                                    hairtunes_end((*ctx).ht);
                                    (*ctx).ht = 0 as *mut libc::c_void as *mut hairtunes_s;
                                    (*ctx).hport = 65535 as libc::c_int as libc::c_ushort;
                                    if !((*ctx).active_remote.handle).is_null() {
                                        close_mDNS((*ctx).active_remote.handle);
                                    }
                                    pthread_join(
                                        (*ctx).search_thread,
                                        0 as *mut libc::c_void as *mut *mut libc::c_void,
                                    );
                                    memset(
                                        &mut (*ctx).active_remote
                                            as *mut __anonstruct_active_remote_822481794
                                            as *mut libc::c_void,
                                        0 as libc::c_int,
                                        ::std::mem::size_of::<
                                            __anonstruct_active_remote_822481794,
                                        >() as libc::c_ulong,
                                    );
                                    if !((*ctx).rtsp.aeskey).is_null() {
                                        free((*ctx).rtsp.aeskey as *mut libc::c_void);
                                        (*ctx)
                                            .rtsp
                                            .aeskey = 0 as *mut libc::c_void as *mut libc::c_char;
                                    }
                                    if !((*ctx).rtsp.aesiv).is_null() {
                                        free((*ctx).rtsp.aesiv as *mut libc::c_void);
                                        (*ctx)
                                            .rtsp
                                            .aesiv = 0 as *mut libc::c_void as *mut libc::c_char;
                                    }
                                    if !((*ctx).rtsp.fmtp).is_null() {
                                        free((*ctx).rtsp.fmtp as *mut libc::c_void);
                                        (*ctx)
                                            .rtsp
                                            .fmtp = 0 as *mut libc::c_void as *mut libc::c_char;
                                    }
                                }
                            } else {
                                seqno___0 = 0 as libc::c_int as libc::c_ushort;
                                rtptime___0 = 0 as libc::c_uint;
                                buf___0 = kd_lookup(
                                    headers.as_mut_ptr(),
                                    b"RTP-Info\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                                if buf___0 as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    p___3 = strcasestr(
                                        buf___0 as *const libc::c_char,
                                        b"seq\0" as *const u8 as *const libc::c_char,
                                    );
                                    if p___3 as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        sscanf(
                                            p___3 as *const libc::c_char,
                                            b"%*[^=]=%hu\0" as *const u8 as *const libc::c_char,
                                            &mut seqno___0 as *mut libc::c_ushort,
                                        );
                                    }
                                    p___3 = strcasestr(
                                        buf___0 as *const libc::c_char,
                                        b"rtptime\0" as *const u8 as *const libc::c_char,
                                    );
                                    if p___3 as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        sscanf(
                                            p___3 as *const libc::c_char,
                                            b"%*[^=]=%u\0" as *const u8 as *const libc::c_char,
                                            &mut rtptime___0 as *mut libc::c_uint,
                                        );
                                    }
                                }
                                if !((*ctx).ht).is_null() {
                                    tmp___23 = hairtunes_flush(
                                        (*ctx).ht,
                                        seqno___0,
                                        rtptime___0,
                                        1 as libc::c_int != 0,
                                        !(*ctx).flush,
                                    );
                                    if tmp___23 {
                                        (Some(((*ctx).raop_cb).expect("non-null function pointer")))
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            (*ctx).owner,
                                            RAOP_FLUSH,
                                            &mut (*ctx).hport as *mut libc::c_ushort
                                                as *mut libc::c_void,
                                        );
                                        hairtunes_flush_release((*ctx).ht);
                                    }
                                }
                            }
                        } else {
                            seqno = 0 as libc::c_int as libc::c_ushort;
                            rtptime = 0 as libc::c_uint;
                            tmp___22 = atoi((*ctx).latencies as *const libc::c_char);
                            if tmp___22 != 0 {
                                tmp___21 = atoi((*ctx).latencies as *const libc::c_char);
                                snprintf(
                                    latency.as_mut_ptr(),
                                    6 as libc::c_int as size_t,
                                    b"%u\0" as *const u8 as *const libc::c_char,
                                    tmp___21 * 44100 as libc::c_int / 1000 as libc::c_int,
                                );
                                kd_add(
                                    resp.as_mut_ptr(),
                                    b"Audio-Latency\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                    latency.as_mut_ptr(),
                                );
                            }
                            buf___0 = kd_lookup(
                                headers.as_mut_ptr(),
                                b"RTP-Info\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            if buf___0 as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                p___2 = strcasestr(
                                    buf___0 as *const libc::c_char,
                                    b"seq\0" as *const u8 as *const libc::c_char,
                                );
                                if p___2 as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    sscanf(
                                        p___2 as *const libc::c_char,
                                        b"%*[^=]=%hu\0" as *const u8 as *const libc::c_char,
                                        &mut seqno as *mut libc::c_ushort,
                                    );
                                }
                                p___2 = strcasestr(
                                    buf___0 as *const libc::c_char,
                                    b"rtptime\0" as *const u8 as *const libc::c_char,
                                );
                                if p___2 as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    sscanf(
                                        p___2 as *const libc::c_char,
                                        b"%*[^=]=%u\0" as *const u8 as *const libc::c_char,
                                        &mut rtptime as *mut libc::c_uint,
                                    );
                                }
                            }
                            if !((*ctx).ht).is_null() {
                                hairtunes_record((*ctx).ht, seqno, rtptime);
                            }
                            (Some(((*ctx).raop_cb).expect("non-null function pointer")))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*ctx).owner,
                                RAOP_STREAM,
                                &mut (*ctx).hport as *mut libc::c_ushort
                                    as *mut libc::c_void,
                            );
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    } else {
        kd_add(
            resp.as_mut_ptr(),
            b"Public\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"ANNOUNCE, SETUP, RECORD, PAUSE, FLUSH, TEARDOWN, OPTIONS, GET_PARAMETER, SET_PARAMETER\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    kd_add(
        resp.as_mut_ptr(),
        b"Audio-Jack-Status\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"connected; type=analog\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    tmp___36 = kd_lookup(
        headers.as_mut_ptr(),
        b"CSeq\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    kd_add(
        resp.as_mut_ptr(),
        b"CSeq\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        tmp___36,
    );
    if success {
        buf___0 = http_send(
            sock,
            b"RTSP/1.0 200 OK\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            resp.as_mut_ptr(),
        );
    } else {
        buf___0 = http_send(
            sock,
            b"RTSP/1.0 500 ERROR\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            0 as *mut libc::c_void as *mut key_data_t,
        );
    }
    tmp___39 = strcmp(
        method.as_mut_ptr() as *const libc::c_char,
        b"OPTIONS\0" as *const u8 as *const libc::c_char,
    );
    if tmp___39 != 0 {
        if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
            if !buf___0.is_null() {
                tmp___37 = buf___0 as *const libc::c_char;
            } else {
                tmp___37 = b"<void>\0" as *const u8 as *const libc::c_char;
            }
            tmp___38 = logtime();
            logprint(
                b"%s %s:%d [%p]: responding:\n%s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___38,
                b"handle_rtsp\0" as *const u8 as *const libc::c_char,
                592 as libc::c_int,
                ctx,
                tmp___37,
            );
        }
    }
    if !body.is_null() {
        free(body as *mut libc::c_void);
        body = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !buf___0.is_null() {
        free(buf___0 as *mut libc::c_void);
        buf___0 = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    kd_free(resp.as_mut_ptr());
    kd_free(headers.as_mut_ptr());
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn event_cb(
    mut owner: *mut libc::c_void,
    mut event: hairtunes_event_t,
) {
    let mut ctx: *mut raop_ctx_t = 0 as *mut raop_ctx_t;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    ctx = owner as *mut raop_ctx_t;
    match event as libc::c_uint {
        0 => {
            (Some(((*ctx).raop_cb).expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )(
                (*ctx).owner,
                RAOP_PLAY,
                &mut (*ctx).hport as *mut libc::c_ushort as *mut libc::c_void,
            );
        }
        _ => {
            tmp = logtime();
            logprint(
                b"%s %s:%d [%p]: unknown hairtunes event\n\0" as *const u8
                    as *const libc::c_char,
                tmp,
                b"event_cb\0" as *const u8 as *const libc::c_char,
                613 as libc::c_int,
                ctx,
                event as libc::c_uint,
            );
        }
    };
}
unsafe extern "C" fn http_cb(
    mut owner: *mut libc::c_void,
    mut headers: *mut key_data_s,
    mut response: *mut key_data_s,
) {
    let mut ctx: *mut raop_ctx_t = 0 as *mut raop_ctx_t;
    ctx = owner as *mut raop_ctx_t;
    if ((*ctx).http_cb).is_some() {
        (Some(((*ctx).http_cb).expect("non-null function pointer")))
            .expect("non-null function pointer")((*ctx).owner, headers, response);
    }
}
pub unsafe extern "C" fn search_remote_cb(
    mut slist: *mut mDNSservice_t,
    mut cookie: *mut libc::c_void,
    mut stop: *mut bool,
) -> bool {
    let mut s: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut ctx: *mut raop_ctx_t = 0 as *mut raop_ctx_t;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    ctx = cookie as *mut raop_ctx_t;
    s = slist;
    while !s.is_null() {
        tmp___1 = strcasestr(
            (*s).name as *const libc::c_char,
            ((*ctx).active_remote.DACPid).as_mut_ptr() as *const libc::c_char,
        );
        if !tmp___1.is_null() {
            (*ctx).active_remote.host = (*s).addr;
            (*ctx).active_remote.port = (*s).port;
            if *loglevel___3 as libc::c_uint >= 2 as libc::c_uint {
                tmp = inet_ntoa((*ctx).active_remote.host);
                tmp___0 = logtime();
                logprint(
                    b"%s %s:%d [%p]: found ActiveRemote for %s at %s:%u\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___0,
                    b"search_remote_cb\0" as *const u8 as *const libc::c_char,
                    638 as libc::c_int,
                    ctx,
                    ((*ctx).active_remote.DACPid).as_mut_ptr(),
                    tmp,
                    (*ctx).active_remote.port as libc::c_int,
                );
            }
            *stop = 1 as libc::c_int != 0;
            break;
        } else {
            s = (*s).next;
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn search_remote(mut args: *mut libc::c_void) -> *mut libc::c_void {
    let mut ctx: *mut raop_ctx_t = 0 as *mut raop_ctx_t;
    ctx = args as *mut raop_ctx_t;
    query_mDNS(
        (*ctx).active_remote.handle,
        b"_dacp._tcp.local\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        0 as libc::c_int,
        0 as libc::c_int,
        Some(
            search_remote_cb
                as unsafe extern "C" fn(
                    *mut mDNSservice_t,
                    *mut libc::c_void,
                    *mut bool,
                ) -> bool,
        ),
        ctx as *mut libc::c_void,
    );
    return 0 as *mut libc::c_void;
}
static mut super_secret_key: [libc::c_char; 1675] = [
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'C' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    'L' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '+' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'Z' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'O' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'U' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    'H' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'J' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'X' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'F' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    'M' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    'Q' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'B' as i32 as libc::c_char,
    'G' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'W' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '=' as i32 as libc::c_char,
    '\n' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'N' as i32 as libc::c_char,
    'D' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'S' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'P' as i32 as libc::c_char,
    'R' as i32 as libc::c_char,
    'I' as i32 as libc::c_char,
    'V' as i32 as libc::c_char,
    'A' as i32 as libc::c_char,
    'T' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    'K' as i32 as libc::c_char,
    'E' as i32 as libc::c_char,
    'Y' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '-' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
unsafe extern "C" fn rsa_apply(
    mut input: *mut libc::c_uchar,
    mut inlen: libc::c_int,
    mut outlen: *mut libc::c_int,
    mut mode: libc::c_int,
) -> *mut libc::c_char {
    let mut out: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut rsa: *mut RSA = 0 as *mut RSA;
    let mut bmem: *mut BIO = 0 as *mut BIO;
    let mut tmp: *mut BIO = 0 as *mut BIO;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = BIO_new_mem_buf(
        super_secret_key.as_mut_ptr() as *const libc::c_void,
        -(1 as libc::c_int),
    );
    bmem = tmp;
    rsa = PEM_read_bio_RSAPrivateKey(
        bmem,
        0 as *mut libc::c_void as *mut *mut RSA,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<pem_password_cb>,
        >(0 as *mut libc::c_void),
        0 as *mut libc::c_void,
    );
    BIO_free(bmem);
    tmp___0 = RSA_size(rsa as *const RSA);
    tmp___1 = malloc(tmp___0 as size_t);
    out = tmp___1 as *mut libc::c_uchar;
    match mode {
        1 => {
            *outlen = RSA_private_encrypt(
                inlen,
                input as *const libc::c_uchar,
                out,
                rsa,
                1 as libc::c_int,
            );
        }
        0 => {
            *outlen = RSA_private_decrypt(
                inlen,
                input as *const libc::c_uchar,
                out,
                rsa,
                4 as libc::c_int,
            );
        }
        _ => {}
    }
    RSA_free(rsa);
    return out as *mut libc::c_char;
}
unsafe extern "C" fn base64_pad(
    mut src: *mut libc::c_char,
    mut padded: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: size_t = 0;
    tmp = strlen(src as *const libc::c_char);
    tmp___0 = strlen(src as *const libc::c_char);
    n = tmp.wrapping_add(tmp___0.wrapping_rem(4 as libc::c_ulong)) as libc::c_int;
    tmp___1 = malloc((n + 1 as libc::c_int) as size_t);
    *padded = tmp___1 as *mut libc::c_char;
    memset(*padded as *mut libc::c_void, '=' as i32, n as size_t);
    tmp___2 = strlen(src as *const libc::c_char);
    memcpy(*padded as *mut libc::c_void, src as *const libc::c_void, tmp___2);
    *(*padded).offset(n as isize) = '\u{0}' as i32 as libc::c_char;
    tmp___3 = strlen(*padded as *const libc::c_char);
    return tmp___3 as libc::c_int;
}
unsafe extern "C" fn on_dmap_string(
    mut ctx: *mut libc::c_void,
    mut code: *const libc::c_char,
    mut name: *const libc::c_char,
    mut buf___0: *const libc::c_char,
    mut len: size_t,
) {
    let mut metadata: *mut metadata_s = 0 as *mut metadata_s;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    metadata = ctx as *mut metadata_s;
    tmp___1 = strcasecmp(code, b"asar\0" as *const u8 as *const libc::c_char);
    if tmp___1 != 0 {
        tmp___0 = strcasecmp(code, b"asal\0" as *const u8 as *const libc::c_char);
        if tmp___0 != 0 {
            tmp = strcasecmp(code, b"minm\0" as *const u8 as *const libc::c_char);
            if tmp == 0 {
                (*metadata).title = strndup(buf___0, len);
            }
        } else {
            (*metadata).album = strndup(buf___0, len);
        }
    } else {
        (*metadata).artist = strndup(buf___0, len);
    };
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    let mut tmp: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___0: __int32_t = 0;
    if __c >= -(128 as libc::c_int) {
        if __c < 256 as libc::c_int {
            tmp = __ctype_tolower_loc();
            tmp___0 = *(*tmp).offset(__c as isize);
        } else {
            tmp___0 = __c;
        }
    } else {
        tmp___0 = __c;
    }
    return tmp___0;
}
static mut loglevel___4: *mut log_level = unsafe {
    &util_loglevel as *const log_level as *mut log_level
};
static mut wakeMutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
    __data: __pthread_mutex_s {
        __lock: 0,
        __count: 0,
        __owner: 0,
        __nusers: 0,
        __kind: 0,
        __spins: 0,
        __elision: 0,
        __list: __pthread_list_t {
            __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
        },
    },
};
static mut wakeCond: pthread_cond_t = __anonunion_pthread_cond_t_951761805 {
    __data: __pthread_cond_s {
        __annonCompField1: __anonunion____missing_field_name_750625702 {
            __wseq: 0,
        },
        __annonCompField2: __anonunion____missing_field_name_170565820 {
            __g1_start: 0,
        },
        __g_refs: [0; 2],
        __g_size: [0; 2],
        __g1_orig_size: 0,
        __wrefs: 0,
        __g_signals: [0; 2],
    },
};
pub unsafe extern "C" fn InitUtils() {
    pthread_mutex_init(&mut wakeMutex, 0 as *const pthread_mutexattr_t);
    pthread_cond_init(
        &mut wakeCond as *mut pthread_cond_t,
        0 as *const pthread_condattr_t,
    );
}
pub unsafe extern "C" fn EndUtils() {
    pthread_mutex_destroy(&mut wakeMutex);
    pthread_cond_destroy(&mut wakeCond);
}
pub unsafe extern "C" fn WakeableSleep(mut ms: u32_t) {
    pthread_mutex_lock(&mut wakeMutex);
    if ms != 0 {
        pthread_cond_reltimedwait(&mut wakeCond, &mut wakeMutex, ms);
    } else {
        pthread_cond_wait(
            &mut wakeCond as *mut pthread_cond_t,
            &mut wakeMutex as *mut pthread_mutex_t,
        );
    }
    pthread_mutex_unlock(&mut wakeMutex);
}
pub unsafe extern "C" fn WakeAll() {
    pthread_mutex_lock(&mut wakeMutex);
    pthread_cond_broadcast(&mut wakeCond);
    pthread_mutex_unlock(&mut wakeMutex);
}
pub unsafe extern "C" fn pthread_cond_reltimedwait(
    mut cond: *mut pthread_cond_t,
    mut mutex: *mut pthread_mutex_t,
    mut msWait: u32_t,
) -> libc::c_int {
    let mut ts: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut nsec: u32_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    clock_gettime(0 as libc::c_int, &mut ts);
    if msWait == 0 {
        tmp = pthread_cond_wait(cond, mutex);
        return tmp;
    }
    nsec = (ts.tv_nsec
        + msWait.wrapping_rem(1000 as libc::c_uint).wrapping_mul(1000000 as libc::c_uint)
            as __syscall_slong_t) as u32_t;
    ts.tv_sec
        += msWait
            .wrapping_div(1000 as libc::c_uint)
            .wrapping_add(nsec.wrapping_div(1000000000 as libc::c_uint)) as __time_t;
    ts.tv_nsec = nsec.wrapping_rem(1000000000 as libc::c_uint) as __syscall_slong_t;
    tmp___0 = pthread_cond_timedwait(
        cond,
        mutex,
        &mut ts as *mut timespec as *const timespec,
    );
    return tmp___0;
}
pub unsafe extern "C" fn _mutex_timedlock(
    mut m: *mut pthread_mutex_t,
    mut ms_wait: u32_t,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut ts: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut tmp: libc::c_int = 0;
    rc = -(1 as libc::c_int);
    tmp = clock_gettime(0 as libc::c_int, &mut ts);
    if tmp == 0 {
        ts.tv_nsec
            += ms_wait
                .wrapping_rem(1000 as libc::c_uint)
                .wrapping_mul(1000000 as libc::c_uint) as __syscall_slong_t;
        ts.tv_sec
            += ms_wait.wrapping_div(1000 as libc::c_uint) as __syscall_slong_t
                + ts.tv_nsec / 1000000000 as libc::c_long;
        ts.tv_nsec %= 1000000000 as libc::c_long;
        rc = pthread_mutex_timedlock(m, &mut ts as *mut timespec as *const timespec);
    }
    return rc;
}
pub unsafe extern "C" fn QueueInit(
    mut queue: *mut tQueue,
    mut mutex: bool,
    mut cleanup: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    (*queue).cleanup = cleanup;
    (*queue).list.item = 0 as *mut libc::c_void;
    if mutex {
        tmp = malloc(::std::mem::size_of::<pthread_mutex_t>() as libc::c_ulong);
        (*queue).mutex = tmp as *mut pthread_mutex_t;
        pthread_mutex_init(
            (*queue).mutex,
            0 as *mut libc::c_void as *const pthread_mutexattr_t,
        );
    } else {
        (*queue).mutex = 0 as *mut libc::c_void as *mut pthread_mutex_t;
    };
}
pub unsafe extern "C" fn QueueInsert(
    mut queue: *mut tQueue,
    mut item: *mut libc::c_void,
) {
    let mut list: *mut sQueue_e = 0 as *mut sQueue_e;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if !((*queue).mutex).is_null() {
        pthread_mutex_lock((*queue).mutex);
    }
    list = &mut (*queue).list;
    while !((*list).item).is_null() {
        list = (*list).next;
    }
    (*list).item = item;
    tmp = malloc(::std::mem::size_of::<sQueue_e>() as libc::c_ulong);
    (*list).next = tmp as *mut sQueue_e;
    (*(*list).next).item = 0 as *mut libc::c_void;
    if !((*queue).mutex).is_null() {
        pthread_mutex_unlock((*queue).mutex);
    }
}
pub unsafe extern "C" fn QueueExtract(mut queue: *mut tQueue) -> *mut libc::c_void {
    let mut item: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut list: *mut sQueue_e = 0 as *mut sQueue_e;
    let mut next: *mut sQueue_e = 0 as *mut sQueue_e;
    if !((*queue).mutex).is_null() {
        pthread_mutex_lock((*queue).mutex);
    }
    list = &mut (*queue).list;
    item = (*list).item;
    if !item.is_null() {
        next = (*list).next;
        if !((*next).item).is_null() {
            (*list).item = (*next).item;
            (*list).next = (*next).next;
        } else {
            (*list).item = 0 as *mut libc::c_void;
        }
        if !next.is_null() {
            free(next as *mut libc::c_void);
            next = 0 as *mut libc::c_void as *mut sQueue_e;
        }
    }
    if !((*queue).mutex).is_null() {
        pthread_mutex_unlock((*queue).mutex);
    }
    return item;
}
pub unsafe extern "C" fn QueueFlush(mut queue: *mut tQueue) {
    let mut list: *mut sQueue_e = 0 as *mut sQueue_e;
    let mut next: *mut sQueue_e = 0 as *mut sQueue_e;
    if !((*queue).mutex).is_null() {
        pthread_mutex_lock((*queue).mutex);
    }
    list = &mut (*queue).list;
    while !((*list).item).is_null() {
        next = (*list).next;
        if ((*queue).cleanup).is_some() {
            (Some(((*queue).cleanup).expect("non-null function pointer")))
                .expect("non-null function pointer")((*list).item);
        }
        if list as libc::c_ulong != &mut (*queue).list as *mut sQueue_e as libc::c_ulong
        {
            if !list.is_null() {
                free(list as *mut libc::c_void);
                list = 0 as *mut libc::c_void as *mut sQueue_e;
            }
        }
        list = next;
    }
    if list as libc::c_ulong != &mut (*queue).list as *mut sQueue_e as libc::c_ulong {
        if !list.is_null() {
            free(list as *mut libc::c_void);
            list = 0 as *mut libc::c_void as *mut sQueue_e;
        }
    }
    (*queue).list.item = 0 as *mut libc::c_void;
    if !((*queue).mutex).is_null() {
        pthread_mutex_unlock((*queue).mutex);
        pthread_mutex_destroy((*queue).mutex);
        free((*queue).mutex as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn push_item(
    mut item: *mut list_t,
    mut list: *mut *mut list_t,
) -> *mut list_t {
    if !(*list).is_null() {
        (*item).next = *list;
    } else {
        (*item).next = 0 as *mut libc::c_void as *mut list_s;
    }
    *list = item;
    return item;
}
pub unsafe extern "C" fn add_tail_item(
    mut item: *mut list_t,
    mut list: *mut *mut list_t,
) -> *mut list_t {
    let mut p: *mut list_s = 0 as *mut list_s;
    if !(*list).is_null() {
        p = *list;
        while !((*p).next).is_null() {
            p = (*p).next;
        }
        (*item).next = (*p).next;
        (*p).next = item;
    } else {
        (*item).next = 0 as *mut libc::c_void as *mut list_s;
        *list = item;
    }
    return item;
}
pub unsafe extern "C" fn add_ordered_item(
    mut item: *mut list_t,
    mut list: *mut *mut list_t,
    mut compare: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> libc::c_int,
    >,
) -> *mut list_t {
    let mut p: *mut list_s = 0 as *mut list_s;
    let mut tmp: libc::c_int = 0;
    if !(*list).is_null() {
        p = *list;
        while !((*p).next).is_null() {
            tmp = (Some(compare.expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )((*p).next as *mut libc::c_void, item as *mut libc::c_void);
            if !(tmp <= 0 as libc::c_int) {
                break;
            }
            p = (*p).next;
        }
        (*item).next = (*p).next;
        (*p).next = item;
    } else {
        (*item).next = 0 as *mut libc::c_void as *mut list_s;
        *list = item;
    }
    return item;
}
pub unsafe extern "C" fn pop_item(mut list: *mut *mut list_t) -> *mut list_t {
    let mut item: *mut list_t = 0 as *mut list_t;
    if !(*list).is_null() {
        item = *list;
        *list = (*item).next;
        return item;
    } else {
        return 0 as *mut libc::c_void as *mut list_t
    };
}
pub unsafe extern "C" fn remove_item(
    mut item: *mut list_t,
    mut list: *mut *mut list_t,
) -> *mut list_t {
    let mut p: *mut list_s = 0 as *mut list_s;
    if item as libc::c_ulong != *list as libc::c_ulong {
        p = *list;
        while !p.is_null() {
            if !((*p).next as libc::c_ulong != item as libc::c_ulong) {
                break;
            }
            p = (*p).next;
        }
        if !p.is_null() {
            (*p).next = (*item).next;
        }
        (*item).next = 0 as *mut libc::c_void as *mut list_s;
    } else {
        *list = (**list).next;
    }
    return item;
}
pub unsafe extern "C" fn clear_list(
    mut list: *mut *mut list_t,
    mut free_func: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    let mut next: *mut list_s = 0 as *mut list_s;
    if (*list).is_null() {
        return;
    }
    while !(*list).is_null() {
        next = (**list).next;
        if free_func.is_some() {
            (Some(free_func.expect("non-null function pointer")))
                .expect("non-null function pointer")(*list as *mut libc::c_void);
        } else {
            free(*list as *mut libc::c_void);
        }
        *list = next;
    }
    *list = 0 as *mut libc::c_void as *mut list_t;
}
pub unsafe extern "C" fn get_mac(mut mac: *mut u8_t) {
    let mut ifc: ifconf = ifconf {
        ifc_len: 0,
        ifc_ifcu: __anonunion_ifc_ifcu_753034691 {
            ifcu_buf: 0 as *mut libc::c_char,
        },
    };
    let mut ifr: *mut ifreq = 0 as *mut ifreq;
    let mut ifend: *mut ifreq = 0 as *mut ifreq;
    let mut ifreq: ifreq = ifreq {
        ifr_ifrn: __anonunion_ifr_ifrn_352126815 {
            ifrn_name: [0; 16],
        },
        ifr_ifru: __anonunion_ifr_ifru_537349870 {
            ifru_addr: sockaddr {
                sa_family: 0,
                sa_data: [0; 14],
            },
        },
    };
    let mut ifs: [ifreq; 4] = [ifreq {
        ifr_ifrn: __anonunion_ifr_ifrn_352126815 {
            ifrn_name: [0; 16],
        },
        ifr_ifru: __anonunion_ifr_ifru_537349870 {
            ifru_addr: sockaddr {
                sa_family: 0,
                sa_data: [0; 14],
            },
        },
    }; 4];
    let mut tmp: u8_t = 0;
    let mut tmp___0: u8_t = 0;
    let mut tmp___1: u8_t = 0;
    let mut tmp___2: u8_t = 0;
    let mut tmp___3: u8_t = 0;
    let mut s: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    tmp___3 = 0 as libc::c_int as u8_t;
    *mac.offset(5 as libc::c_int as isize) = tmp___3;
    tmp___2 = tmp___3;
    *mac.offset(4 as libc::c_int as isize) = tmp___2;
    tmp___1 = tmp___2;
    *mac.offset(3 as libc::c_int as isize) = tmp___1;
    tmp___0 = tmp___1;
    *mac.offset(2 as libc::c_int as isize) = tmp___0;
    tmp = tmp___0;
    *mac.offset(1 as libc::c_int as isize) = tmp;
    *mac.offset(0 as libc::c_int as isize) = tmp;
    tmp___4 = socket(2 as libc::c_int, 2 as libc::c_int, 0 as libc::c_int);
    s = tmp___4;
    ifc.ifc_len = ::std::mem::size_of::<[ifreq; 4]>() as libc::c_ulong as libc::c_int;
    ifc.ifc_ifcu.ifcu_req = ifs.as_mut_ptr();
    tmp___6 = ioctl(s, 35090 as libc::c_ulong, &mut ifc as *mut ifconf);
    if tmp___6 == 0 as libc::c_int {
        ifend = ifs
            .as_mut_ptr()
            .offset(
                (ifc.ifc_len as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<ifreq>() as libc::c_ulong)
                    as isize,
            );
        ifr = ifc.ifc_ifcu.ifcu_req;
        while (ifr as libc::c_ulong) < ifend as libc::c_ulong {
            if (*ifr).ifr_ifru.ifru_addr.sa_family as libc::c_int == 2 as libc::c_int {
                strncpy(
                    (ifreq.ifr_ifrn.ifrn_name).as_mut_ptr(),
                    ((*ifr).ifr_ifrn.ifrn_name).as_mut_ptr() as *const libc::c_char,
                    ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
                );
                tmp___5 = ioctl(s, 35111 as libc::c_ulong, &mut ifreq as *mut ifreq);
                if tmp___5 == 0 as libc::c_int {
                    memcpy(
                        mac as *mut libc::c_void,
                        (ifreq.ifr_ifru.ifru_hwaddr.sa_data).as_mut_ptr()
                            as *const libc::c_void,
                        6 as libc::c_int as size_t,
                    );
                    if *mac.offset(0 as libc::c_int as isize) as libc::c_int
                        + *mac.offset(1 as libc::c_int as isize) as libc::c_int
                        + *mac.offset(2 as libc::c_int as isize) as libc::c_int
                        != 0 as libc::c_int
                    {
                        break;
                    }
                }
            }
            ifr = ifr.offset(1);
        }
    }
    close(s);
}
pub unsafe extern "C" fn SendARP(
    mut src: in_addr_t,
    mut dst: in_addr_t,
    mut mac: *mut u8_t,
    mut size: *mut libc::c_ulong,
) -> libc::c_int {
    let mut s: libc::c_int = 0;
    let mut areq: arpreq = arpreq {
        arp_pa: sockaddr {
            sa_family: 0,
            sa_data: [0; 14],
        },
        arp_ha: sockaddr {
            sa_family: 0,
            sa_data: [0; 14],
        },
        arp_flags: 0,
        arp_netmask: sockaddr {
            sa_family: 0,
            sa_data: [0; 14],
        },
        arp_dev: [0; 16],
    };
    let mut sin: *mut sockaddr_in = 0 as *mut sockaddr_in;
    let mut tmp: libc::c_int = 0;
    s = socket(2 as libc::c_int, 2 as libc::c_int, 0 as libc::c_int);
    if s == -(1 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    memset(
        &mut areq as *mut arpreq as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<arpreq>() as libc::c_ulong,
    );
    sin = &mut areq.arp_pa as *mut sockaddr as *mut sockaddr_in;
    (*sin).sin_family = 2 as libc::c_int as sa_family_t;
    (*sin).sin_addr.s_addr = src;
    sin = &mut areq.arp_ha as *mut sockaddr as *mut sockaddr_in;
    (*sin).sin_family = 1 as libc::c_int as sa_family_t;
    strncpy(
        (areq.arp_dev).as_mut_ptr(),
        b"eth0\0" as *const u8 as *const libc::c_char,
        15 as libc::c_int as size_t,
    );
    tmp = ioctl(s, 35156 as libc::c_ulong, &mut areq as *mut arpreq as caddr_t);
    if tmp == -(1 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    memcpy(
        mac as *mut libc::c_void,
        &mut areq.arp_ha.sa_data as *mut [libc::c_char; 14] as *const libc::c_void,
        *size,
    );
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn get_interface(mut addr: *mut in_addr) -> bool {
    let mut ifreq: *mut ifreq = 0 as *mut ifreq;
    let mut ifconf: ifconf = ifconf {
        ifc_len: 0,
        ifc_ifcu: __anonunion_ifc_ifcu_753034691 {
            ifcu_buf: 0 as *mut libc::c_char,
        },
    };
    let mut buf___0: [libc::c_char; 512] = [0; 512];
    let mut i: libc::c_uint = 0;
    let mut nb: libc::c_uint = 0;
    let mut fd: libc::c_int = 0;
    let mut valid: bool = false;
    let mut tmp: libc::c_int = 0;
    valid = 0 as libc::c_int != 0;
    fd = socket(2 as libc::c_int, 2 as libc::c_int, 0 as libc::c_int);
    ifconf
        .ifc_len = ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong
        as libc::c_int;
    ifconf.ifc_ifcu.ifcu_buf = buf___0.as_mut_ptr();
    tmp = ioctl(fd, 35090 as libc::c_ulong, &mut ifconf as *mut ifconf);
    if tmp != 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    ifreq = ifconf.ifc_ifcu.ifcu_req;
    nb = (ifconf.ifc_len as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<ifreq>() as libc::c_ulong) as libc::c_uint;
    i = 0 as libc::c_uint;
    while i < nb {
        ioctl(fd, 35091 as libc::c_ulong, ifreq.offset(i as isize));
        if (*ifreq.offset(i as isize)).ifr_ifru.ifru_flags as libc::c_int
            & 1 as libc::c_int != 0
        {
            if (*ifreq.offset(i as isize)).ifr_ifru.ifru_flags as libc::c_int
                & 8 as libc::c_int == 0
            {
                if (*ifreq.offset(i as isize)).ifr_ifru.ifru_flags as libc::c_int
                    & 4096 as libc::c_int != 0
                {
                    *addr = (*(&mut (*ifreq.offset(i as isize)).ifr_ifru.ifru_addr
                        as *mut sockaddr as *mut sockaddr_in))
                        .sin_addr;
                    valid = 1 as libc::c_int != 0;
                    break;
                }
            }
        }
        i = i.wrapping_add(1);
    }
    close(fd);
    return valid;
}
pub unsafe extern "C" fn get_localhost(mut name: *mut *mut libc::c_char) -> in_addr_t {
    let mut szBuffer: [libc::c_char; 10240] = [0; 10240];
    let mut ifConf: ifconf = ifconf {
        ifc_len: 0,
        ifc_ifcu: __anonunion_ifc_ifcu_753034691 {
            ifcu_buf: 0 as *mut libc::c_char,
        },
    };
    let mut ifReq: ifreq = ifreq {
        ifr_ifrn: __anonunion_ifr_ifrn_352126815 {
            ifrn_name: [0; 16],
        },
        ifr_ifru: __anonunion_ifr_ifru_537349870 {
            ifru_addr: sockaddr {
                sa_family: 0,
                sa_data: [0; 14],
            },
        },
    };
    let mut nResult: libc::c_int = 0;
    let mut i: libc::c_ulong = 0;
    let mut LocalSock: libc::c_int = 0;
    let mut LocalAddr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut j: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut pifReq: *mut ifreq = 0 as *mut ifreq;
    let mut tmp___0: __uint32_t = 0;
    j = 0 as libc::c_int;
    if !name.is_null() {
        tmp = malloc(256 as libc::c_int as size_t);
        *name = tmp as *mut libc::c_char;
        gethostname(*name, 256 as libc::c_int as size_t);
    }
    memset(
        &mut ifConf as *mut ifconf as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ifconf>() as libc::c_ulong,
    );
    memset(
        &mut ifReq as *mut ifreq as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ifreq>() as libc::c_ulong,
    );
    memset(
        szBuffer.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 10240]>() as libc::c_ulong,
    );
    memset(
        &mut LocalAddr as *mut sockaddr_in as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    LocalSock = socket(2 as libc::c_int, 2 as libc::c_int, 17 as libc::c_int);
    if LocalSock == -(1 as libc::c_int) {
        return 0 as libc::c_int as in_addr_t;
    }
    ifConf
        .ifc_len = ::std::mem::size_of::<[libc::c_char; 10240]>() as libc::c_ulong
        as libc::c_int;
    ifConf.ifc_ifcu.ifcu_buf = szBuffer.as_mut_ptr();
    nResult = ioctl(LocalSock, 35090 as libc::c_ulong, &mut ifConf as *mut ifconf);
    if nResult < 0 as libc::c_int {
        close(LocalSock);
        return 0 as libc::c_int as in_addr_t;
    }
    i = 0 as libc::c_ulong;
    while i < ifConf.ifc_len as libc::c_ulong {
        if !(j < 1 as libc::c_int) {
            break;
        }
        pifReq = (ifConf.ifc_ifcu.ifcu_req as caddr_t).offset(i as isize) as *mut ifreq;
        i = i.wrapping_add(::std::mem::size_of::<ifreq>() as libc::c_ulong);
        memset(
            (ifReq.ifr_ifrn.ifrn_name).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        );
        strncpy(
            (ifReq.ifr_ifrn.ifrn_name).as_mut_ptr(),
            ((*pifReq).ifr_ifrn.ifrn_name).as_mut_ptr() as *const libc::c_char,
            (::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_ulong),
        );
        ioctl(LocalSock, 35091 as libc::c_ulong, &mut ifReq as *mut ifreq);
        if ifReq.ifr_ifru.ifru_flags as libc::c_int & 8 as libc::c_int != 0 {
            continue;
        }
        if ifReq.ifr_ifru.ifru_flags as libc::c_int & 1 as libc::c_int == 0 {
            continue;
        }
        if (*pifReq).ifr_ifru.ifru_addr.sa_family as libc::c_int == 2 as libc::c_int {
            memcpy(
                &mut LocalAddr as *mut sockaddr_in as *mut libc::c_void,
                &mut (*pifReq).ifr_ifru.ifru_addr as *mut sockaddr
                    as *const libc::c_void,
                ::std::mem::size_of::<sockaddr>() as libc::c_ulong,
            );
            tmp___0 = __bswap_32(2130706433 as libc::c_int as in_addr_t);
            if LocalAddr.sin_addr.s_addr == tmp___0 {
                continue;
            }
        }
        j += 1;
    }
    close(LocalSock);
    return LocalAddr.sin_addr.s_addr;
}
pub unsafe extern "C" fn shutdown_socket(mut sd: libc::c_int) -> libc::c_int {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    if sd <= 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    shutdown(sd, 2 as libc::c_int);
    if *loglevel___4 as libc::c_uint >= 2 as libc::c_uint {
        tmp = logtime();
        logprint(
            b"%s %s:%d closed socket %d\n\0" as *const u8 as *const libc::c_char,
            tmp,
            b"shutdown_socket\0" as *const u8 as *const libc::c_char,
            753 as libc::c_int,
            sd,
        );
    }
    tmp___0 = close(sd);
    return tmp___0;
}
pub unsafe extern "C" fn bind_socket(
    mut port: *mut libc::c_ushort,
    mut mode: libc::c_int,
) -> libc::c_int {
    let mut sock: libc::c_int = 0;
    let mut len: socklen_t = 0;
    let mut addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    len = ::std::mem::size_of::<sockaddr>() as libc::c_ulong as socklen_t;
    sock = socket(2 as libc::c_int, mode, 0 as libc::c_int);
    if sock < 0 as libc::c_int {
        tmp = logtime();
        logprint(
            b"%s %s:%d cannot create socket %d\n\0" as *const u8 as *const libc::c_char,
            tmp,
            b"bind_socket\0" as *const u8 as *const libc::c_char,
            767 as libc::c_int,
            sock,
        );
        return sock;
    }
    memset(
        &mut addr as *mut sockaddr_in as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    addr.sin_family = 2 as libc::c_int as sa_family_t;
    addr.sin_addr.s_addr = __bswap_32(0 as libc::c_int as in_addr_t);
    addr.sin_port = __bswap_16(*port);
    tmp___1 = bind(
        sock,
        &mut addr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
    );
    if tmp___1 < 0 as libc::c_int {
        close(sock);
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d cannot bind socket %d\n\0" as *const u8 as *const libc::c_char,
            tmp___0,
            b"bind_socket\0" as *const u8 as *const libc::c_char,
            782 as libc::c_int,
            sock,
        );
        return -(1 as libc::c_int);
    }
    if *port == 0 {
        getsockname(
            sock,
            &mut addr as *mut sockaddr_in as *mut sockaddr,
            &mut len as *mut socklen_t,
        );
        *port = __bswap_16(addr.sin_port);
    }
    if *loglevel___4 as libc::c_uint >= 2 as libc::c_uint {
        tmp___2 = logtime();
        logprint(
            b"%s %s:%d socket binding %d on port %d\n\0" as *const u8
                as *const libc::c_char,
            tmp___2,
            b"bind_socket\0" as *const u8 as *const libc::c_char,
            791 as libc::c_int,
            sock,
            *port as libc::c_int,
        );
    }
    return sock;
}
pub unsafe extern "C" fn conn_socket(mut port: libc::c_ushort) -> libc::c_int {
    let mut addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut sd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    sd = socket(2 as libc::c_int, 1 as libc::c_int, 0 as libc::c_int);
    addr.sin_family = 2 as libc::c_int as sa_family_t;
    addr.sin_addr.s_addr = __bswap_32(2130706433 as libc::c_int as in_addr_t);
    addr.sin_port = __bswap_16(port);
    if sd < 0 as libc::c_int {
        close(sd);
        return -(1 as libc::c_int);
    } else {
        tmp = connect(
            sd,
            &mut addr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
            ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
        );
        if tmp < 0 as libc::c_int {
            close(sd);
            return -(1 as libc::c_int);
        }
    }
    if *loglevel___4 as libc::c_uint >= 3 as libc::c_uint {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d created socket %d\n\0" as *const u8 as *const libc::c_char,
            tmp___0,
            b"conn_socket\0" as *const u8 as *const libc::c_char,
            814 as libc::c_int,
            sd,
        );
    }
    return sd;
}
pub unsafe extern "C" fn touch_memory(mut buf___0: *mut u8_t, mut size: size_t) {
    let mut ptr: *mut u8_t = 0 as *mut u8_t;
    let mut tmp: libc::c_long = 0;
    ptr = buf___0;
    while (ptr as libc::c_ulong) < buf___0.offset(size as isize) as libc::c_ulong {
        *ptr = 0 as libc::c_int as u8_t;
        tmp = sysconf(30 as libc::c_int);
        ptr = ptr.offset(tmp as isize);
    }
}
pub unsafe extern "C" fn GetTempPath(
    mut size: u16_t,
    mut path: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut tmp: size_t = 0;
    strncpy(path, b"/tmp\0" as *const u8 as *const libc::c_char, size as size_t);
    tmp = strlen(path as *const libc::c_char);
    if tmp == 0 {
        strncpy(path, b"/var/tmp\0" as *const u8 as *const libc::c_char, size as size_t);
    }
    *path
        .offset(
            (size as libc::c_int - 1 as libc::c_int) as isize,
        ) = '\u{0}' as i32 as libc::c_char;
    return path;
}
static mut str: *mut libc::c_char = 0 as *const libc::c_void as *mut libc::c_void
    as *mut libc::c_char;
pub unsafe extern "C" fn next_param(
    mut src: *mut libc::c_char,
    mut c: libc::c_char,
) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    if !src.is_null() {
        str = src;
    }
    if !str.is_null() {
        ptr = strchr(str as *const libc::c_char, c as libc::c_int);
        if !ptr.is_null() {
            ret = str;
            *ptr = '\u{0}' as i32 as libc::c_char;
            str = ptr.offset(1 as libc::c_int as isize);
        } else {
            ret = str;
            str = 0 as *mut libc::c_void as *mut libc::c_char;
        }
    } else {
        ret = str;
        str = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !ret.is_null() {
        if *ret.offset(0 as libc::c_int as isize) != 0 {
            tmp = ret;
        } else {
            tmp = 0 as *mut libc::c_void as *mut libc::c_char;
        }
    } else {
        tmp = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    return tmp;
}
pub unsafe extern "C" fn gettime_ms() -> u32_t {
    let mut ts: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut tmp: libc::c_int = 0;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    tmp = clock_gettime(1 as libc::c_int, &mut ts);
    if tmp == 0 {
        return (ts.tv_sec * 1000 as libc::c_long + ts.tv_nsec / 1000000 as libc::c_long)
            as u32_t;
    }
    gettimeofday(&mut tv as *mut timeval, 0 as *mut libc::c_void);
    return (tv.tv_sec * 1000 as libc::c_long + tv.tv_usec / 1000 as libc::c_long)
        as u32_t;
}
pub unsafe extern "C" fn gettime_ms64() -> u64_t {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    gettimeofday(&mut tv as *mut timeval, 0 as *mut libc::c_void);
    return ((tv.tv_sec + 2208988800 as libc::c_long) as u64_t)
        .wrapping_mul(1000 as libc::c_ulong)
        .wrapping_add((tv.tv_usec / 1000 as libc::c_long) as u64_t);
}
pub unsafe extern "C" fn strlwr(mut str___0: *mut libc::c_char) -> *mut libc::c_char {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    p = str___0;
    while *p != 0 {
        if ::std::mem::size_of::<libc::c_char>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = tolower(*p as libc::c_int);
        } else {
            tmp___0 = __ctype_tolower_loc();
            __res = *(*tmp___0).offset(*p as libc::c_int as isize);
        }
        *p = __res as libc::c_char;
        p = p.offset(1);
    }
    return str___0;
}
pub unsafe extern "C" fn strextract(
    mut s1: *mut libc::c_char,
    mut beg: *mut libc::c_char,
    mut end: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut p1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    p1 = strcasestr(s1 as *const libc::c_char, beg as *const libc::c_char);
    if p1.is_null() {
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmp = strlen(beg as *const libc::c_char);
    p1 = p1.offset(tmp as isize);
    p2 = strcasestr(p1 as *const libc::c_char, end as *const libc::c_char);
    if p2.is_null() {
        tmp___0 = strdup(p1 as *const libc::c_char);
        return tmp___0;
    }
    tmp___1 = malloc((p2.offset_from(p1) as libc::c_long + 1 as libc::c_long) as size_t);
    res = tmp___1 as *mut libc::c_char;
    memcpy(
        res as *mut libc::c_void,
        p1 as *const libc::c_void,
        p2.offset_from(p1) as libc::c_long as size_t,
    );
    *res
        .offset(
            p2.offset_from(p1) as libc::c_long as isize,
        ) = '\u{0}' as i32 as libc::c_char;
    return res;
}
static mut dig: [libc::c_char; 37] = [
    '0' as i32 as libc::c_char,
    '1' as i32 as libc::c_char,
    '2' as i32 as libc::c_char,
    '3' as i32 as libc::c_char,
    '4' as i32 as libc::c_char,
    '5' as i32 as libc::c_char,
    '6' as i32 as libc::c_char,
    '7' as i32 as libc::c_char,
    '8' as i32 as libc::c_char,
    '9' as i32 as libc::c_char,
    'a' as i32 as libc::c_char,
    'b' as i32 as libc::c_char,
    'c' as i32 as libc::c_char,
    'd' as i32 as libc::c_char,
    'e' as i32 as libc::c_char,
    'f' as i32 as libc::c_char,
    'g' as i32 as libc::c_char,
    'h' as i32 as libc::c_char,
    'i' as i32 as libc::c_char,
    'j' as i32 as libc::c_char,
    'k' as i32 as libc::c_char,
    'l' as i32 as libc::c_char,
    'm' as i32 as libc::c_char,
    'n' as i32 as libc::c_char,
    'o' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    'q' as i32 as libc::c_char,
    'r' as i32 as libc::c_char,
    's' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'u' as i32 as libc::c_char,
    'v' as i32 as libc::c_char,
    'w' as i32 as libc::c_char,
    'x' as i32 as libc::c_char,
    'y' as i32 as libc::c_char,
    'z' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
pub unsafe extern "C" fn itoa(
    mut value: libc::c_int,
    mut str___0: *mut libc::c_char,
    mut radix: libc::c_int,
) -> *mut libc::c_char {
    let mut n: libc::c_int = 0;
    let mut neg: libc::c_int = 0;
    let mut v: libc::c_uint = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut c: libc::c_char = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    n = 0 as libc::c_int;
    neg = 0 as libc::c_int;
    if radix == 10 as libc::c_int {
        if value < 0 as libc::c_int {
            value = -value;
            neg = 1 as libc::c_int;
        }
    }
    v = value as libc::c_uint;
    loop {
        tmp = n;
        n += 1;
        *str___0
            .offset(tmp as isize) = dig[v.wrapping_rem(radix as libc::c_uint) as usize];
        v = v.wrapping_div(radix as libc::c_uint);
        if v == 0 {
            break;
        }
    }
    if neg != 0 {
        tmp___0 = n;
        n += 1;
        *str___0.offset(tmp___0 as isize) = '-' as i32 as libc::c_char;
    }
    *str___0.offset(n as isize) = '\u{0}' as i32 as libc::c_char;
    p = str___0;
    q = p.offset((n - 1 as libc::c_int) as isize);
    while (p as libc::c_ulong) < q as libc::c_ulong {
        c = *p;
        *p = *q;
        *q = c;
        p = p.offset(1);
        q = q.offset(-1);
    }
    return str___0;
}
pub unsafe extern "C" fn hash32(mut str___0: *mut libc::c_char) -> u32_t {
    let mut hash: u32_t = 0;
    let mut c: s32_t = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    hash = 5381 as libc::c_int as u32_t;
    if str___0.is_null() {
        return 0 as libc::c_int as u32_t;
    }
    loop {
        tmp = str___0;
        str___0 = str___0.offset(1);
        c = *tmp as s32_t;
        if !(c != 0 as libc::c_int) {
            break;
        }
        hash = (hash << 5 as libc::c_int).wrapping_add(hash).wrapping_add(c as u32_t);
    }
    return hash;
}
pub unsafe extern "C" fn ltrim(mut s: *mut libc::c_char) -> *mut libc::c_char {
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    loop {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*s as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
        s = s.offset(1);
    }
    return s;
}
pub unsafe extern "C" fn rtrim(mut s: *mut libc::c_char) -> *mut libc::c_char {
    let mut back: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    tmp = strlen(s as *const libc::c_char);
    back = s.offset(tmp as isize);
    loop {
        tmp___0 = __ctype_b_loc();
        back = back.offset(-1);
        if *(*tmp___0).offset(*back as libc::c_int as isize) as libc::c_int
            & 8192 as libc::c_int == 0
        {
            break;
        }
    }
    *back.offset(1 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    return s;
}
pub unsafe extern "C" fn trim(mut s: *mut libc::c_char) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = ltrim(s);
    tmp___0 = rtrim(tmp);
    return tmp___0;
}
pub unsafe extern "C" fn http_parse(
    mut sock: libc::c_int,
    mut method: *mut libc::c_char,
    mut resource: *mut libc::c_char,
    mut proto: *mut libc::c_char,
    mut rkd: *mut key_data_t,
    mut body: *mut *mut libc::c_char,
    mut len: *mut libc::c_int,
) -> bool {
    let mut line: [libc::c_char; 512] = [0; 512];
    let mut dp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut j: libc::c_uint = 0;
    let mut i: libc::c_int = 0;
    let mut timeout: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: libc::c_long = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut bytes: libc::c_int = 0;
    let mut tmp___14: ssize_t = 0;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    timeout = 100 as libc::c_int;
    let ref mut fresh25 = (*rkd.offset(0 as libc::c_int as isize)).key;
    *fresh25 = 0 as *mut libc::c_void as *mut libc::c_char;
    i = read_line(
        sock,
        line.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong as libc::c_int,
        timeout,
    );
    if i <= 0 as libc::c_int {
        if i < 0 as libc::c_int {
            tmp = logtime();
            logprint(
                b"%s %s:%d cannot read method\n\0" as *const u8 as *const libc::c_char,
                tmp,
                b"http_parse\0" as *const u8 as *const libc::c_char,
                1130 as libc::c_int,
                0 as *mut libc::c_void,
            );
        }
        return 0 as libc::c_int != 0;
    }
    tmp___1 = sscanf(
        line.as_mut_ptr() as *const libc::c_char,
        b"%s\0" as *const u8 as *const libc::c_char,
        method,
    );
    if tmp___1 == 0 {
        tmp___0 = logtime();
        logprint(
            b"%s %s:%d missing method\n\0" as *const u8 as *const libc::c_char,
            tmp___0,
            b"http_parse\0" as *const u8 as *const libc::c_char,
            1136 as libc::c_int,
            0 as *mut libc::c_void,
        );
        return 0 as libc::c_int != 0;
    }
    if !resource.is_null() {
        sscanf(
            line.as_mut_ptr() as *const libc::c_char,
            b"%*s%s\0" as *const u8 as *const libc::c_char,
            resource,
        );
    }
    if !proto.is_null() {
        sscanf(
            line.as_mut_ptr() as *const libc::c_char,
            b"%*s%*s%s\0" as *const u8 as *const libc::c_char,
            proto,
        );
    }
    tmp___2 = 0 as libc::c_int;
    *len = tmp___2;
    i = tmp___2;
    let mut current_block_56: u64;
    loop {
        tmp___12 = read_line(
            sock,
            line.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong as libc::c_int,
            timeout,
        );
        if !(tmp___12 > 0 as libc::c_int) {
            break;
        }
        if *loglevel___4 as libc::c_uint >= 3 as libc::c_uint {
            tmp___3 = logtime();
            logprint(
                b"%s %s:%d sock: %u, received %s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___3,
                b"http_parse\0" as *const u8 as *const libc::c_char,
                1147 as libc::c_int,
                sock,
                line.as_mut_ptr(),
            );
        }
        if i != 0 {
            if !((*rkd.offset(i as isize)).key).is_null() {
                if line[0 as libc::c_int as usize] as libc::c_int == 32 as libc::c_int {
                    current_block_56 = 9857087869502111836;
                } else if line[0 as libc::c_int as usize] as libc::c_int
                        == 9 as libc::c_int
                    {
                    current_block_56 = 9857087869502111836;
                } else {
                    current_block_56 = 13619784596304402172;
                }
                match current_block_56 {
                    13619784596304402172 => {}
                    _ => {
                        j = 0 as libc::c_uint;
                        loop {
                            tmp___4 = strlen(line.as_mut_ptr() as *const libc::c_char);
                            if !((j as size_t) < tmp___4) {
                                break;
                            }
                            if line[j as usize] as libc::c_int != 32 as libc::c_int {
                                if line[j as usize] as libc::c_int != 9 as libc::c_int {
                                    break;
                                }
                            }
                            j = j.wrapping_add(1);
                        }
                        tmp___5 = strlen(
                            (*rkd.offset(i as isize)).data as *const libc::c_char,
                        );
                        tmp___6 = strlen(
                            line.as_mut_ptr().offset(j as isize) as *const libc::c_char,
                        );
                        tmp___7 = realloc(
                            (*rkd.offset(i as isize)).data as *mut libc::c_void,
                            tmp___5
                                .wrapping_add(tmp___6)
                                .wrapping_add(1 as libc::c_ulong),
                        );
                        let ref mut fresh26 = (*rkd.offset(i as isize)).data;
                        *fresh26 = tmp___7 as *mut libc::c_char;
                        strcat(
                            (*rkd.offset(i as isize)).data,
                            line.as_mut_ptr().offset(j as isize) as *const libc::c_char,
                        );
                        continue;
                    }
                }
            }
        }
        dp = strstr(
            line.as_mut_ptr() as *const libc::c_char,
            b":\0" as *const u8 as *const libc::c_char,
        );
        if dp.is_null() {
            tmp___8 = logtime();
            logprint(
                b"%s %s:%d Request failed, bad header\n\0" as *const u8
                    as *const libc::c_char,
                tmp___8,
                b"http_parse\0" as *const u8 as *const libc::c_char,
                1160 as libc::c_int,
                0 as *mut libc::c_void,
            );
            kd_free(rkd);
            return 0 as libc::c_int != 0;
        }
        *dp = 0 as libc::c_int as libc::c_char;
        let ref mut fresh27 = (*rkd.offset(i as isize)).key;
        *fresh27 = strdup(line.as_mut_ptr() as *const libc::c_char);
        tmp___9 = ltrim(dp.offset(1 as libc::c_int as isize));
        let ref mut fresh28 = (*rkd.offset(i as isize)).data;
        *fresh28 = strdup(tmp___9 as *const libc::c_char);
        tmp___11 = strcasecmp(
            (*rkd.offset(i as isize)).key as *const libc::c_char,
            b"Content-Length\0" as *const u8 as *const libc::c_char,
        );
        if tmp___11 == 0 {
            tmp___10 = atol((*rkd.offset(i as isize)).data as *const libc::c_char);
            *len = tmp___10 as libc::c_int;
        }
        i += 1;
        let ref mut fresh29 = (*rkd.offset(i as isize)).key;
        *fresh29 = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if *len != 0 {
        size = 0 as libc::c_int;
        tmp___13 = malloc((*len + 1 as libc::c_int) as size_t);
        *body = tmp___13 as *mut libc::c_char;
        while !(*body).is_null() {
            if !(size < *len) {
                break;
            }
            tmp___14 = recv(
                sock,
                (*body).offset(size as isize) as *mut libc::c_void,
                (*len - size) as size_t,
                0 as libc::c_int,
            );
            bytes = tmp___14 as libc::c_int;
            if bytes <= 0 as libc::c_int {
                break;
            }
            size += bytes;
        }
        *(*body).offset(*len as isize) = '\u{0}' as i32 as libc::c_char;
        if (*body).is_null() {
            tmp___15 = logtime();
            logprint(
                b"%s %s:%d content length receive error %d %d\n\0" as *const u8
                    as *const libc::c_char,
                tmp___15,
                b"http_parse\0" as *const u8 as *const libc::c_char,
                1188 as libc::c_int,
                *len,
                size,
            );
        } else if size != *len {
            tmp___15 = logtime();
            logprint(
                b"%s %s:%d content length receive error %d %d\n\0" as *const u8
                    as *const libc::c_char,
                tmp___15,
                b"http_parse\0" as *const u8 as *const libc::c_char,
                1188 as libc::c_int,
                *len,
                size,
            );
        }
    }
    return 1 as libc::c_int != 0;
}
pub unsafe extern "C" fn read_line(
    mut fd: libc::c_int,
    mut line: *mut libc::c_char,
    mut maxlen: libc::c_int,
    mut timeout: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut rval: libc::c_int = 0;
    let mut count___0: libc::c_int = 0;
    let mut pfds: pollfd = pollfd {
        fd: 0,
        events: 0,
        revents: 0,
    };
    let mut ch: libc::c_char = 0;
    let mut tmp: ssize_t = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    count___0 = 0 as libc::c_int;
    *line = 0 as libc::c_int as libc::c_char;
    pfds.fd = fd;
    pfds.events = 1 as libc::c_int as libc::c_short;
    i = 0 as libc::c_int;
    while i < maxlen {
        tmp___0 = poll(&mut pfds, 1 as libc::c_int as nfds_t, timeout);
        if tmp___0 != 0 {
            tmp = recv(
                fd,
                &mut ch as *mut libc::c_char as *mut libc::c_void,
                1 as libc::c_int as size_t,
                0 as libc::c_int,
            );
            rval = tmp as libc::c_int;
        } else {
            return 0 as libc::c_int
        }
        if rval == -(1 as libc::c_int) {
            tmp___1 = __errno_location();
            if *tmp___1 == 11 as libc::c_int {
                return 0 as libc::c_int;
            }
            tmp___2 = __errno_location();
            tmp___3 = strerror(*tmp___2);
            tmp___4 = logtime();
            logprint(
                b"%s %s:%d fd: %d read error: %s\n\0" as *const u8
                    as *const libc::c_char,
                tmp___4,
                b"read_line\0" as *const u8 as *const libc::c_char,
                1214 as libc::c_int,
                fd,
                tmp___3,
            );
            return -(1 as libc::c_int);
        }
        if rval == 0 as libc::c_int {
            if *loglevel___4 as libc::c_uint >= 2 as libc::c_uint {
                tmp___5 = logtime();
                logprint(
                    b"%s %s:%d disconnected on the other end %u\n\0" as *const u8
                        as *const libc::c_char,
                    tmp___5,
                    b"read_line\0" as *const u8 as *const libc::c_char,
                    1219 as libc::c_int,
                    fd,
                );
            }
            return 0 as libc::c_int;
        }
        if ch as libc::c_int == 10 as libc::c_int {
            *line = 0 as libc::c_int as libc::c_char;
            return count___0;
        }
        if !(ch as libc::c_int == 13 as libc::c_int) {
            tmp___6 = line;
            line = line.offset(1);
            *tmp___6 = ch;
            count___0 += 1;
            if count___0 >= maxlen - 1 as libc::c_int {
                break;
            }
        }
        i += 1;
    }
    *line = 0 as libc::c_int as libc::c_char;
    return count___0;
}
pub unsafe extern "C" fn http_send(
    mut sock: libc::c_int,
    mut method: *mut libc::c_char,
    mut rkd: *mut key_data_t,
) -> *mut libc::c_char {
    let mut sent: libc::c_uint = 0;
    let mut len: libc::c_uint = 0;
    let mut resp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: ssize_t = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    tmp = kd_dump(rkd);
    resp = tmp;
    tmp___0 = strlen(method as *const libc::c_char);
    tmp___1 = strlen(resp as *const libc::c_char);
    tmp___2 = malloc(
        tmp___0
            .wrapping_add(2 as libc::c_ulong)
            .wrapping_add(tmp___1)
            .wrapping_add(2 as libc::c_ulong)
            .wrapping_add(1 as libc::c_ulong),
    );
    data = tmp___2 as *mut libc::c_char;
    tmp___3 = sprintf(
        data,
        b"%s\r\n%s\r\n\0" as *const u8 as *const libc::c_char,
        method,
        resp,
    );
    len = tmp___3 as libc::c_uint;
    if !resp.is_null() {
        free(resp as *mut libc::c_void);
        resp = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmp___4 = send(sock, data as *const libc::c_void, len as size_t, 0 as libc::c_int);
    sent = tmp___4 as libc::c_uint;
    if sent != len {
        tmp___5 = logtime();
        logprint(
            b"%s %s:%d HTTP send() error:%s %u (strlen=%u)\n\0" as *const u8
                as *const libc::c_char,
            tmp___5,
            b"http_send\0" as *const u8 as *const libc::c_char,
            1253 as libc::c_int,
            data,
            sent,
            len,
        );
        if !data.is_null() {
            free(data as *mut libc::c_void);
            data = 0 as *mut libc::c_void as *mut libc::c_char;
        }
    }
    return data;
}
pub unsafe extern "C" fn kd_lookup(
    mut kd: *mut key_data_t,
    mut key: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !kd.is_null() {
        if ((*kd.offset(i as isize)).key).is_null() {
            break;
        }
        tmp = strcasecmp(
            (*kd.offset(i as isize)).key as *const libc::c_char,
            key as *const libc::c_char,
        );
        if tmp == 0 {
            return (*kd.offset(i as isize)).data;
        }
        i += 1;
    }
    return 0 as *mut libc::c_void as *mut libc::c_char;
}
pub unsafe extern "C" fn kd_add(
    mut kd: *mut key_data_t,
    mut key: *mut libc::c_char,
    mut data: *mut libc::c_char,
) -> bool {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !kd.is_null() {
        if ((*kd.offset(i as isize)).key).is_null() {
            break;
        }
        i += 1;
    }
    let ref mut fresh30 = (*kd.offset(i as isize)).key;
    *fresh30 = strdup(key as *const libc::c_char);
    let ref mut fresh31 = (*kd.offset(i as isize)).data;
    *fresh31 = strdup(data as *const libc::c_char);
    let ref mut fresh32 = (*kd.offset((i + 1 as libc::c_int) as isize)).key;
    *fresh32 = 0 as *mut libc::c_void as *mut libc::c_char;
    return 1 as libc::c_int != 0;
}
pub unsafe extern "C" fn kd_vadd(
    mut kd: *mut key_data_t,
    mut key: *mut libc::c_char,
    mut fmt: *mut libc::c_char,
    mut args: ...
) -> bool {
    let mut i: libc::c_int = 0;
    let mut args_0: ::std::ffi::VaListImpl;
    let mut tmp: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !kd.is_null() {
        if ((*kd.offset(i as isize)).key).is_null() {
            break;
        }
        i += 1;
    }
    args_0 = args.clone();
    tmp = vasprintf(
        &mut (*kd.offset(i as isize)).data as *mut *mut libc::c_char,
        fmt as *const libc::c_char,
        args_0.as_va_list(),
    );
    if tmp != 0 {
        let ref mut fresh33 = (*kd.offset(i as isize)).key;
        *fresh33 = strdup(key as *const libc::c_char);
        let ref mut fresh34 = (*kd.offset((i + 1 as libc::c_int) as isize)).key;
        *fresh34 = 0 as *mut libc::c_void as *mut libc::c_char;
        return 1 as libc::c_int != 0;
    }
    return 0 as libc::c_int != 0;
}
pub unsafe extern "C" fn kd_free(mut kd: *mut key_data_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !kd.is_null() {
        if ((*kd.offset(i as isize)).key).is_null() {
            break;
        }
        free((*kd.offset(i as isize)).key as *mut libc::c_void);
        if !((*kd.offset(i as isize)).data).is_null() {
            free((*kd.offset(i as isize)).data as *mut libc::c_void);
        }
        i += 1;
    }
    let ref mut fresh35 = (*kd.offset(0 as libc::c_int as isize)).key;
    *fresh35 = 0 as *mut libc::c_void as *mut libc::c_char;
}
pub unsafe extern "C" fn kd_dump(mut kd: *mut key_data_t) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut pos___0: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut str___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut buf___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    i = 0 as libc::c_int;
    pos___0 = 0 as libc::c_int;
    size = 0 as libc::c_int;
    str___0 = 0 as *mut libc::c_void as *mut libc::c_char;
    if kd.is_null() {
        tmp = strdup(b"\r\n\0" as *const u8 as *const libc::c_char);
        return tmp;
    } else {
        if ((*kd.offset(0 as libc::c_int as isize)).key).is_null() {
            tmp = strdup(b"\r\n\0" as *const u8 as *const libc::c_char);
            return tmp;
        }
    }
    while !kd.is_null() {
        if ((*kd.offset(i as isize)).key).is_null() {
            break;
        }
        len = asprintf(
            &mut buf___0 as *mut *mut libc::c_char,
            b"%s: %s\r\n\0" as *const u8 as *const libc::c_char,
            (*kd.offset(i as isize)).key,
            (*kd.offset(i as isize)).data,
        );
        while pos___0 + len >= size {
            tmp___0 = realloc(
                str___0 as *mut libc::c_void,
                (size + 1024 as libc::c_int) as size_t,
            );
            p = tmp___0;
            size += 1024 as libc::c_int;
            if p.is_null() {
                free(str___0 as *mut libc::c_void);
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
            str___0 = p as *mut libc::c_char;
        }
        memcpy(
            str___0.offset(pos___0 as isize) as *mut libc::c_void,
            buf___0 as *const libc::c_void,
            len as size_t,
        );
        pos___0 += len;
        free(buf___0 as *mut libc::c_void);
        i += 1;
    }
    *str___0.offset(pos___0 as isize) = '\u{0}' as i32 as libc::c_char;
    return str___0;
}
pub unsafe extern "C" fn XMLAddNode(
    mut doc: *mut IXML_Document,
    mut parent: *mut IXML_Node,
    mut name: *mut libc::c_char,
    mut fmt: *mut libc::c_char,
    mut args: ...
) -> *mut IXML_Node {
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut elm: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut buf___0: [libc::c_char; 256] = [0; 256];
    let mut args_0: ::std::ffi::VaListImpl;
    let mut tmp: *mut IXML_Element = 0 as *mut IXML_Element;
    tmp = ixmlDocument_createElement(doc, name as *const libc::c_char);
    elm = tmp as *mut IXML_Node;
    if !parent.is_null() {
        ixmlNode_appendChild(parent, elm);
    } else {
        ixmlNode_appendChild(doc as *mut IXML_Node, elm);
    }
    if !fmt.is_null() {
        args_0 = args.clone();
        vsprintf(buf___0.as_mut_ptr(), fmt as *const libc::c_char, args_0.as_va_list());
        node = ixmlDocument_createTextNode(
            doc,
            buf___0.as_mut_ptr() as *const libc::c_char,
        );
        ixmlNode_appendChild(elm, node);
    }
    return elm;
}
pub unsafe extern "C" fn XMLUpdateNode(
    mut doc: *mut IXML_Document,
    mut parent: *mut IXML_Node,
    mut refresh: bool,
    mut name: *mut libc::c_char,
    mut fmt: *mut libc::c_char,
    mut args: ...
) -> *mut IXML_Node {
    let mut buf___0: [libc::c_char; 256] = [0; 256];
    let mut args_0: ::std::ffi::VaListImpl;
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp: *mut IXML_Element = 0 as *mut IXML_Element;
    tmp = ixmlDocument_getElementById(
        parent as *mut IXML_Document,
        name as *const libc::c_char,
    );
    node = tmp as *mut IXML_Node;
    args_0 = args.clone();
    vsprintf(buf___0.as_mut_ptr(), fmt as *const libc::c_char, args_0.as_va_list());
    if node.is_null() {
        XMLAddNode(doc, parent, name, buf___0.as_mut_ptr());
    } else if refresh {
        node = ixmlNode_getFirstChild(node);
        ixmlNode_setNodeValue(node, buf___0.as_mut_ptr() as *const libc::c_char);
    }
    return node;
}
pub unsafe extern "C" fn XMLGetFirstDocumentItem(
    mut doc: *mut IXML_Document,
    mut item: *const libc::c_char,
    mut strict: bool,
) -> *mut libc::c_char {
    let mut nodeList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut textNode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmpNode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: libc::c_ulong = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    nodeList = 0 as *mut libc::c_void as *mut IXML_NodeList;
    textNode = 0 as *mut libc::c_void as *mut IXML_Node;
    tmpNode = 0 as *mut libc::c_void as *mut IXML_Node;
    ret = 0 as *mut libc::c_void as *mut libc::c_char;
    nodeList = ixmlDocument_getElementsByTagName(
        doc,
        item as *mut libc::c_char as *const libc::c_char,
    );
    i = 0 as libc::c_int;
    while !nodeList.is_null() {
        tmp___3 = ixmlNodeList_length(nodeList);
        if !(i < tmp___3 as libc::c_int) {
            break;
        }
        tmpNode = ixmlNodeList_item(nodeList, i as libc::c_ulong);
        if !tmpNode.is_null() {
            textNode = ixmlNode_getFirstChild(tmpNode);
            if !textNode.is_null() {
                tmp = ixmlNode_getNodeValue(textNode);
                ret = tmp as *mut libc::c_char;
                if !ret.is_null() {
                    ret = strdup(ret as *const libc::c_char);
                    break;
                } else if *loglevel___4 as libc::c_uint >= 1 as libc::c_uint {
                    tmp___0 = logtime();
                    logprint(
                        b"%s %s:%d ixmlNode_getNodeValue returned NULL\n\0" as *const u8
                            as *const libc::c_char,
                        tmp___0,
                        b"XMLGetFirstDocumentItem\0" as *const u8 as *const libc::c_char,
                        1435 as libc::c_int,
                        0 as *mut libc::c_void,
                    );
                }
            } else if *loglevel___4 as libc::c_uint >= 1 as libc::c_uint {
                tmp___1 = logtime();
                logprint(
                    b"%s %s:%d (BUG) ixmlNode_getFirstChild(tmpNode) returned NULL\n\0"
                        as *const u8 as *const libc::c_char,
                    tmp___1,
                    b"XMLGetFirstDocumentItem\0" as *const u8 as *const libc::c_char,
                    1438 as libc::c_int,
                    0 as *mut libc::c_void,
                );
            }
        } else if *loglevel___4 as libc::c_uint >= 1 as libc::c_uint {
            tmp___2 = logtime();
            logprint(
                b"%s %s:%d ixmlNodeList_item(nodeList, %d) returned NULL\n\0"
                    as *const u8 as *const libc::c_char,
                tmp___2,
                b"XMLGetFirstDocumentItem\0" as *const u8 as *const libc::c_char,
                1441 as libc::c_int,
                i,
                0 as *mut libc::c_void,
            );
        }
        if strict {
            break;
        }
        i += 1;
    }
    if !nodeList.is_null() {
        ixmlNodeList_free(nodeList);
    } else if *loglevel___4 as libc::c_uint >= 4 as libc::c_uint {
        tmp___4 = logtime();
        logprint(
            b"%s %s:%d Error finding %s in XML Node\n\0" as *const u8
                as *const libc::c_char,
            tmp___4,
            b"XMLGetFirstDocumentItem\0" as *const u8 as *const libc::c_char,
            1450 as libc::c_int,
            item,
        );
    }
    return ret;
}
pub unsafe extern "C" fn XMLMatchDocumentItem(
    mut doc: *mut IXML_Document,
    mut item: *const libc::c_char,
    mut s: *const libc::c_char,
    mut match_0: bool,
) -> bool {
    let mut nodeList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut textNode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmpNode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut i: libc::c_int = 0;
    let mut ret: bool = false;
    let mut value: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_ulong = 0;
    nodeList = 0 as *mut libc::c_void as *mut IXML_NodeList;
    textNode = 0 as *mut libc::c_void as *mut IXML_Node;
    tmpNode = 0 as *mut libc::c_void as *mut IXML_Node;
    ret = 0 as libc::c_int != 0;
    nodeList = ixmlDocument_getElementsByTagName(
        doc,
        item as *mut libc::c_char as *const libc::c_char,
    );
    i = 0 as libc::c_int;
    while !nodeList.is_null() {
        tmp___1 = ixmlNodeList_length(nodeList);
        if !(i < tmp___1 as libc::c_int) {
            break;
        }
        tmpNode = ixmlNodeList_item(nodeList, i as libc::c_ulong);
        if !tmpNode.is_null() {
            textNode = ixmlNode_getFirstChild(tmpNode);
            if !textNode.is_null() {
                value = ixmlNode_getNodeValue(textNode);
                if match_0 {
                    tmp = strcmp(value, s);
                    if !(tmp != 0) {
                        ret = 1 as libc::c_int != 0;
                        break;
                    }
                }
                if !match_0 {
                    if !value.is_null() {
                        tmp___0 = strcasestr(value, s);
                        if !tmp___0.is_null() {
                            ret = 1 as libc::c_int != 0;
                            break;
                        }
                    }
                }
            }
        }
        i += 1;
    }
    if !nodeList.is_null() {
        ixmlNodeList_free(nodeList);
    }
    return ret;
}
pub unsafe extern "C" fn XMLGetFirstElementItem(
    mut element: *mut IXML_Element,
    mut item: *const libc::c_char,
) -> *mut libc::c_char {
    let mut nodeList: *mut IXML_NodeList = 0 as *mut IXML_NodeList;
    let mut textNode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmpNode: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    nodeList = 0 as *mut libc::c_void as *mut IXML_NodeList;
    textNode = 0 as *mut libc::c_void as *mut IXML_Node;
    tmpNode = 0 as *mut libc::c_void as *mut IXML_Node;
    ret = 0 as *mut libc::c_void as *mut libc::c_char;
    nodeList = ixmlElement_getElementsByTagName(
        element,
        item as *mut libc::c_char as *const libc::c_char,
    );
    if nodeList as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if *loglevel___4 as libc::c_uint >= 1 as libc::c_uint {
            tmp = logtime();
            logprint(
                b"%s %s:%d Error finding %s in XML Node\n\0" as *const u8
                    as *const libc::c_char,
                tmp,
                b"XMLGetFirstElementItem\0" as *const u8 as *const libc::c_char,
                1497 as libc::c_int,
                item,
            );
        }
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmpNode = ixmlNodeList_item(nodeList, 0 as libc::c_ulong);
    if tmpNode.is_null() {
        if *loglevel___4 as libc::c_uint >= 1 as libc::c_uint {
            tmp___0 = logtime();
            logprint(
                b"%s %s:%d Error finding %s value in XML Node\n\0" as *const u8
                    as *const libc::c_char,
                tmp___0,
                b"XMLGetFirstElementItem\0" as *const u8 as *const libc::c_char,
                1502 as libc::c_int,
                item,
            );
        }
        ixmlNodeList_free(nodeList);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    textNode = ixmlNode_getFirstChild(tmpNode);
    tmp___1 = ixmlNode_getNodeValue(textNode);
    ret = strdup(tmp___1);
    if ret.is_null() {
        tmp___2 = logtime();
        logprint(
            b"%s %s:%d Error allocating memory for %s in XML Node\n\0" as *const u8
                as *const libc::c_char,
            tmp___2,
            b"XMLGetFirstElementItem\0" as *const u8 as *const libc::c_char,
            1509 as libc::c_int,
            item,
        );
        ixmlNodeList_free(nodeList);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    ixmlNodeList_free(nodeList);
    return ret;
}
pub unsafe extern "C" fn XMLAddAttribute(
    mut doc: *mut IXML_Document,
    mut parent: *mut IXML_Node,
    mut name: *mut libc::c_char,
    mut fmt: *mut libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut buf___0: [libc::c_char; 256] = [0; 256];
    let mut ret: libc::c_int = 0;
    let mut args_0: ::std::ffi::VaListImpl;
    args_0 = args.clone();
    vsnprintf(
        buf___0.as_mut_ptr(),
        256 as libc::c_int as size_t,
        fmt as *const libc::c_char,
        args_0.as_va_list(),
    );
    ret = ixmlElement_setAttribute(
        parent as *mut IXML_Element,
        name as *const libc::c_char,
        buf___0.as_mut_ptr() as *const libc::c_char,
    );
    return ret;
}
pub unsafe extern "C" fn XMLGetLocalName(
    mut doc: *mut IXML_Document,
    mut Depth: libc::c_int,
) -> *const libc::c_char {
    let mut node: *mut IXML_Node = 0 as *mut IXML_Node;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    node = doc as *mut IXML_Node;
    loop {
        tmp = Depth;
        Depth -= 1;
        if tmp == 0 {
            break;
        }
        node = ixmlNode_getFirstChild(node);
        if node.is_null() {
            return 0 as *mut libc::c_void as *const libc::c_char;
        }
    }
    tmp___0 = ixmlNode_getLocalName(node);
    return tmp___0;
}
pub unsafe extern "C" fn free_metadata(mut metadata: *mut metadata_s) {
    if !((*metadata).artist).is_null() {
        free((*metadata).artist as *mut libc::c_void);
        (*metadata).artist = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*metadata).album).is_null() {
        free((*metadata).album as *mut libc::c_void);
        (*metadata).album = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*metadata).title).is_null() {
        free((*metadata).title as *mut libc::c_void);
        (*metadata).title = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*metadata).genre).is_null() {
        free((*metadata).genre as *mut libc::c_void);
        (*metadata).genre = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*metadata).path).is_null() {
        free((*metadata).path as *mut libc::c_void);
        (*metadata).path = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*metadata).artwork).is_null() {
        free((*metadata).artwork as *mut libc::c_void);
        (*metadata).artwork = 0 as *mut libc::c_void as *mut libc::c_char;
    }
    if !((*metadata).remote_title).is_null() {
        free((*metadata).remote_title as *mut libc::c_void);
        (*metadata).remote_title = 0 as *mut libc::c_void as *mut libc::c_char;
    }
}
pub unsafe extern "C" fn dup_metadata(
    mut dst: *mut metadata_s,
    mut src: *mut metadata_s,
) {
    free_metadata(dst);
    if !((*src).artist).is_null() {
        (*dst).artist = strdup((*src).artist as *const libc::c_char);
    }
    if !((*src).album).is_null() {
        (*dst).album = strdup((*src).album as *const libc::c_char);
    }
    if !((*src).title).is_null() {
        (*dst).title = strdup((*src).title as *const libc::c_char);
    }
    if !((*src).genre).is_null() {
        (*dst).genre = strdup((*src).genre as *const libc::c_char);
    }
    if !((*src).path).is_null() {
        (*dst).path = strdup((*src).path as *const libc::c_char);
    }
    if !((*src).artwork).is_null() {
        (*dst).artwork = strdup((*src).artwork as *const libc::c_char);
    }
    if !((*src).remote_title).is_null() {
        (*dst).remote_title = strdup((*src).remote_title as *const libc::c_char);
    }
    (*dst).duration = (*src).duration;
    (*dst).track = (*src).track;
    (*dst).track_hash = (*src).track_hash;
}
pub unsafe extern "C" fn _fprintf(mut file: *mut FILE, mut args: ...) -> libc::c_int {
    let mut args_0: ::std::ffi::VaListImpl;
    let mut fmt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    args_0 = args.clone();
    tmp = args_0.arg::<*mut libc::c_char>();
    fmt = tmp;
    n = vfprintf(file, fmt as *const libc::c_char, args_0.as_va_list());
    return n;
}
static mut buf: [libc::c_char; 100] = [0; 100];
pub unsafe extern "C" fn logtime() -> *const libc::c_char {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp: *mut tm = 0 as *mut tm;
    let mut tmp___0: size_t = 0;
    gettimeofday(&mut tv as *mut timeval, 0 as *mut libc::c_void);
    tmp = localtime(&mut tv.tv_sec as *mut __time_t as *const time_t);
    strftime(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
        b"[%T.\0" as *const u8 as *const libc::c_char,
        tmp as *const tm,
    );
    tmp___0 = strlen(buf.as_mut_ptr() as *const libc::c_char);
    sprintf(
        buf.as_mut_ptr().offset(tmp___0 as isize),
        b"%06ld]\0" as *const u8 as *const libc::c_char,
        tv.tv_usec,
    );
    return buf.as_mut_ptr() as *const libc::c_char;
}
pub unsafe extern "C" fn logprint(mut fmt: *const libc::c_char, mut args: ...) {
    let mut args_0: ::std::ffi::VaListImpl;
    args_0 = args.clone();
    vfprintf(stderr, fmt, args_0.as_va_list());
    fflush(stderr);
}
pub unsafe extern "C" fn debug2level(mut level: *mut libc::c_char) -> log_level {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    tmp = strcmp(
        level as *const libc::c_char,
        b"error\0" as *const u8 as *const libc::c_char,
    );
    if tmp == 0 {
        return lERROR;
    }
    tmp___0 = strcmp(
        level as *const libc::c_char,
        b"warn\0" as *const u8 as *const libc::c_char,
    );
    if tmp___0 == 0 {
        return lWARN;
    }
    tmp___1 = strcmp(
        level as *const libc::c_char,
        b"info\0" as *const u8 as *const libc::c_char,
    );
    if tmp___1 == 0 {
        return lINFO;
    }
    tmp___2 = strcmp(
        level as *const libc::c_char,
        b"debug\0" as *const u8 as *const libc::c_char,
    );
    if tmp___2 == 0 {
        return lDEBUG;
    }
    tmp___3 = strcmp(
        level as *const libc::c_char,
        b"sdebug\0" as *const u8 as *const libc::c_char,
    );
    if tmp___3 == 0 {
        return lSDEBUG;
    }
    return lWARN;
}
pub unsafe extern "C" fn level2debug(mut level: log_level) -> *mut libc::c_char {
    match level as libc::c_uint {
        0 => return b"error\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        1 => return b"warn\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        2 => return b"info\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        3 => return b"debug\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        4 => return b"debug\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        _ => return b"warn\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    };
}
static mut dmap_fields: [dmap_field; 268] = [
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"abal\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_STR,
            name: b"daap.browsealbumlisting\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"abar\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_STR,
            name: b"daap.browseartistlisting\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"abcp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_STR,
            name: b"daap.browsecomposerlisting\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"abgn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_STR,
            name: b"daap.browsegenrelisting\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"abpl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.baseplaylist\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"abro\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.databasebrowse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"adbs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.databasesongs\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeAD\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.adam-ids-array\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeAI\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.itms-artistid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCD\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATA,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.flat-chapter-data\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCF\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.cloud-flavor-id\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCI\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.itms-composerid\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCK\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.cloud-library-kind\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCM\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.cloud-match-type\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCR\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.content-rating\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCS\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.artworkchecksum\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCU\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.cloud-user-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeCd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.cloud-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeDE\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.longest-content-description\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeDL\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-downloader-user-id\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeDP\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-platform-id\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeDR\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-user-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeDV\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-versions\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeEN\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.episode-num-str\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeES\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.episode-sort\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeFA\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-family-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGD\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.gapless-enc-dr\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGE\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.gapless-enc-del\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGH\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.gapless-heur\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGI\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.itms-genreid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGR\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.gapless-resy\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGU\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.gapless-dur\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeGs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.can-be-genius-seed\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeHC\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.has-chapter-data\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeHD\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.is-hd-video\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeHV\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.has-video\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeK1\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-key1-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeK2\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.drm-key2-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeMC\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.playlist-contains-media-type-count\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeMK\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.mediakind\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeMX\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.movie-info-xml\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeMk\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.extended-media-kind\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeND\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.non-drm-user-id\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeNN\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.network-name\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeNV\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.norm-volume\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aePC\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.is-podcast\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aePI\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.itms-playlistid\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aePP\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.is-podcast-playlist\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aePS\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.special-playlist\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeRD\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.rental-duration\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeRP\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.rental-pb-start\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeRS\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.rental-start\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeRU\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.rental-pb-duration\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeRf\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.is-featured\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSE\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store-pers-id\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSF\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.itms-storefrontid\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSG\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.saved-genius\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSI\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.itms-songid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSN\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.series-name\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSP\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.smart-playlist\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSU\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.season-num\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeSV\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_VERS,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.music-sharing-version\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeXD\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.xid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aecp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.collection-description\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aels\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.liked-state\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aemi\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.media-kind-listing-item\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aeml\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.media-kind-listing\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"agac\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.groupalbumcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"agma\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.groupmatchedqueryalbumcount\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"agmi\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.groupmatchedqueryitemcount\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"agrp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songgrouping\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajAE\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.ams-episode-type\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajAS\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.ams-episode-sort-order\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajAT\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.ams-show-type\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajAV\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.is-ams-video\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajal\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.album-liked-state\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajcA\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.show-composer-as-artist\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajca\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.show-composer-as-artist\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ajuw\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.store.use-work-name-as-display-name\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"amvc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songmovementcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"amvm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songmovementname\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"amvn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songmovementnumber\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aply\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.databaseplaylists\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aprm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.playlistrepeatmode\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"apro\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_VERS,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.protocolversion\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"apsm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.playlistshufflemode\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"apso\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.playlistsongs\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"arif\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.resolveinfo\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"arsv\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.resolve\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asaa\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songalbumartist\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asac\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songartworkcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asai\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songalbumid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asal\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songalbum\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asar\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songartist\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asas\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songalbumuserratingstatus\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asbk\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.bookmarkable\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asbo\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songbookmark\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asbr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songbitrate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asbt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songbeatsperminute\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ascd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcodectype\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ascm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcomment\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ascn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcontentdescription\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asco\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcompilation\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ascp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcomposer\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ascr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcontentrating\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ascs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcodecsubtype\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asct\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songcategory\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asda\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdateadded\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdb\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdisabled\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdisccount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdk\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdatakind\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdatemodified\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdiscnumber\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdatepurchased\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdatereleased\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asdt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdescription\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ased\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songextradata\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aseq\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songeqpreset\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ases\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songexcludefromshuffle\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asfm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songformat\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asgn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songgenre\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asgp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songgapless\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asgr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.supportsgroups\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ashp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songhasbeenplayed\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"askd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songlastskipdate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"askp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songuserskipcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asky\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songkeywords\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aslc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songlongcontentdescription\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aslr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songalbumuserrating\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asls\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songlongsize\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aspc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songuserplaycount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aspl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdateplayed\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"aspu\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songpodcasturl\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asri\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songartistid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asrs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songuserratingstatus\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asrv\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_INT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songrelativevolume\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assa\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.sortartist\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.sortcomposer\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.sortalbumartist\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.sortname\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songstoptime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songsamplerate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asss\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.sortseriesname\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asst\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songstarttime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assu\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.sortalbum\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"assz\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songsize\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"astc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songtrackcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"astm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songtime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"astn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songtracknumber\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asul\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songdataurl\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asur\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songuserrating\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asvc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songprimaryvideocodec\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"asyr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songyear\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ated\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.supportsextradata\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"avdb\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.serverdatabases\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"awrk\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"daap.songwork\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"caar\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.availablerepeatstates\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"caas\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.availableshufflestates\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"caci\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"caci\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cafe\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.fullscreenenabled\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cafs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.fullscreen\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"caia\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.isactive\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cana\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.nowplayingartist\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cang\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.nowplayinggenre\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"canl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.nowplayingalbum\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cann\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.nowplayingname\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"canp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.nowplayingids\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cant\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.nowplayingtime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"capr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_VERS,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.protocolversion\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"caps\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.playerstate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"carp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.repeatstate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cash\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.shufflestate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"casp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.speakers\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cast\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.songtime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cavc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.volumecontrollable\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cave\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.visualizerenabled\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cavs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dacp.visualizer\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceJC\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.jukebox-client-vote\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceJI\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.jukebox-current\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceJS\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.jukebox-score\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceJV\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.jukebox-vote\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceQR\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.playqueue-contents-response\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceQa\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.playqueue-album\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceQg\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.playqueue-genre\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceQn\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.playqueue-name\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ceQr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.playqueue-artist\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cmgt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmcp.getpropertyresponse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cmmk\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmcp.mediakind\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cmpr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_VERS,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmcp.protocolversion\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cmsr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmcp.serverrevision\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cmst\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmcp.playstatus\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"cmvo\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmcp.volume\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"f\x8Dch\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.haschildcontainers\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ipsa\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.iphotoslideshowadvancedoptions\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ipsl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.iphotoslideshowoptions\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mbcl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.bag\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mccr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.contentcodesresponse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mcna\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.contentcodesname\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mcnm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.contentcodesnumber\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mcon\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.container\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mctc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.containercount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mcti\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.containeritemid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mcty\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.contentcodestype\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mdbk\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.databasekind\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mdcl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.dictionary\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mdst\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.downloadstatus\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"meds\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.editcommandssupported\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"meia\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.itemdateadded\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"meip\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.itemdateplayed\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mext\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.objectextradata\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"miid\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.itemid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mikd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.itemkind\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mimc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.itemcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"minm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.itemname\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mlcl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_DICT,
            name: b"dmap.listing\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mlid\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.sessionid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mlit\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_ITEM,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.listingitem\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mlog\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.loginresponse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mpco\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.parentcontainerid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mper\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.persistentid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mpro\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_VERS,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.protocolversion\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mrco\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.returnedcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mrpr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.remotepersistentid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msal\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsautologout\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msas\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.authenticationschemes\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msau\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.authenticationmethod\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msbr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsbrowse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msdc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.databasescount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msex\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsextensions\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msix\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsindex\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mslr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.loginrequired\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msma\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.machineaddress\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msml\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"msml\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mspi\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportspersistentids\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msqy\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsquery\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msrs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsresolve\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msrv\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.serverinforesponse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mstc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.utctime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mstm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.timeoutinterval\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msto\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_INT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.utcoffset\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msts\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.statusstring\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mstt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.status\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"msup\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.supportsupdate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mtco\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.specifiedtotalcount\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mudl\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.deletedidlisting\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"mupd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.updateresponse\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"musr\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.serverrevision\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"muty\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dmap.updatetype\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pasp\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.aspectratio\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pcmt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagecomments\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"peak\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.photos.album-kind\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"peed\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.photos.exposure-date\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pefc\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.photos.faces\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"peki\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.photos.key-image-id\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pekm\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.photos.key-image\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pemd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"com.apple.itunes.photos.modification-date\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pfai\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.failureids\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pfdt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.filedata\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pfmt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imageformat\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"phgt\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagepixelheight\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"picd\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DATE,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.creationdate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pifs\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagefilesize\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pimf\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_STR,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagefilename\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"plsz\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagelargefilesize\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"ppro\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_VERS,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.protocolversion\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"prat\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagerating\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pret\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_DICT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.retryids\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_dmap_field_217118876 {
            code: b"pwth\0" as *const u8 as *const libc::c_char,
            type_0: DMAP_UINT,
            list_item_type: DMAP_UNKNOWN,
            name: b"dpap.imagepixelwidth\0" as *const u8 as *const libc::c_char,
        };
        init
    },
];
static mut dmap_field_count: libc::c_ulong = 0;
pub unsafe extern "C" fn dmap_version() -> libc::c_int {
    return 1002001 as libc::c_int;
}
pub unsafe extern "C" fn dmap_version_string() -> *const libc::c_char {
    return b"1.2.1\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn dmap_field_sort(
    mut a: *const dmap_field,
    mut b: *const dmap_field,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = memcmp(
        (*a).code as *const libc::c_void,
        (*b).code as *const libc::c_void,
        4 as libc::c_int as size_t,
    );
    return tmp;
}
unsafe extern "C" fn dmap_field_from_code(
    mut code: *const libc::c_char,
) -> *const dmap_field {
    let mut key: dmap_field = dmap_field {
        code: 0 as *const libc::c_char,
        type_0: DMAP_UNKNOWN,
        list_item_type: DMAP_UNKNOWN,
        name: 0 as *const libc::c_char,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    key.code = code;
    tmp = bsearch(
        &mut key as *mut dmap_field as *const libc::c_void,
        dmap_fields.as_ptr() as *const libc::c_void,
        dmap_field_count,
        ::std::mem::size_of::<dmap_field>() as libc::c_ulong,
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*const dmap_field, *const dmap_field) -> libc::c_int,
            >,
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
        >(
            Some(
                dmap_field_sort
                    as unsafe extern "C" fn(
                        *const dmap_field,
                        *const dmap_field,
                    ) -> libc::c_int,
            ),
        ),
    );
    return tmp as *const dmap_field;
}
pub unsafe extern "C" fn dmap_name_from_code(
    mut code: *const libc::c_char,
) -> *const libc::c_char {
    let mut field: *const dmap_field = 0 as *const dmap_field;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if code.is_null() {
        return 0 as *mut libc::c_void as *const libc::c_char;
    }
    field = dmap_field_from_code(code);
    if !field.is_null() {
        tmp = (*field).name;
    } else {
        tmp = 0 as *mut libc::c_void as *const libc::c_char;
    }
    return tmp;
}
unsafe extern "C" fn dmap_read_u16(mut buf___0: *const libc::c_char) -> uint16_t {
    return ((*buf___0.offset(0 as libc::c_int as isize) as libc::c_int
        & 255 as libc::c_int) << 8 as libc::c_int
        | *buf___0.offset(1 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
        as uint16_t;
}
unsafe extern "C" fn dmap_read_i16(mut buf___0: *const libc::c_char) -> int16_t {
    let mut tmp: uint16_t = 0;
    tmp = dmap_read_u16(buf___0);
    return tmp as int16_t;
}
unsafe extern "C" fn dmap_read_u32(mut buf___0: *const libc::c_char) -> uint32_t {
    return ((*buf___0.offset(0 as libc::c_int as isize) as libc::c_int
        & 255 as libc::c_int) as uint32_t) << 24 as libc::c_int
        | ((*buf___0.offset(1 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint32_t) << 16 as libc::c_int
        | ((*buf___0.offset(2 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint32_t) << 8 as libc::c_int
        | (*buf___0.offset(3 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint32_t;
}
unsafe extern "C" fn dmap_read_i32(mut buf___0: *const libc::c_char) -> int32_t {
    let mut tmp: uint32_t = 0;
    tmp = dmap_read_u32(buf___0);
    return tmp as int32_t;
}
unsafe extern "C" fn dmap_read_u64(mut buf___0: *const libc::c_char) -> uint64_t {
    return ((*buf___0.offset(0 as libc::c_int as isize) as libc::c_int
        & 255 as libc::c_int) as uint64_t) << 56 as libc::c_int
        | ((*buf___0.offset(1 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t) << 48 as libc::c_int
        | ((*buf___0.offset(2 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t) << 40 as libc::c_int
        | ((*buf___0.offset(3 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t) << 32 as libc::c_int
        | ((*buf___0.offset(4 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t) << 24 as libc::c_int
        | ((*buf___0.offset(5 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t) << 16 as libc::c_int
        | ((*buf___0.offset(6 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t) << 8 as libc::c_int
        | (*buf___0.offset(7 as libc::c_int as isize) as libc::c_int
            & 255 as libc::c_int) as uint64_t;
}
unsafe extern "C" fn dmap_read_i64(mut buf___0: *const libc::c_char) -> int64_t {
    let mut tmp: uint64_t = 0;
    tmp = dmap_read_u64(buf___0);
    return tmp as int64_t;
}
unsafe extern "C" fn dmap_parse_internal(
    mut settings: *const dmap_settings,
    mut buf___0: *const libc::c_char,
    mut len: size_t,
    mut parent: *const dmap_field,
) -> libc::c_int {
    let mut field: *const dmap_field = 0 as *const dmap_field;
    let mut field_type: DMAP_TYPE = DMAP_UNKNOWN;
    let mut field_len: size_t = 0;
    let mut field_name: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut end: *const libc::c_char = 0 as *const libc::c_char;
    let mut code: [libc::c_char; 5] = [0; 5];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: uint32_t = 0;
    let mut tmp___1: uint32_t = 0;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___3: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___4: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___5: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut i: size_t = 0;
    let mut is_string: libc::c_int = 0;
    let mut tmp___6: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___7: uint16_t = 0;
    let mut tmp___8: uint32_t = 0;
    let mut tmp___9: uint64_t = 0;
    let mut tmp___10: int16_t = 0;
    let mut tmp___11: int32_t = 0;
    let mut tmp___12: int64_t = 0;
    let mut tmp___13: uint32_t = 0;
    let mut version: [libc::c_char; 20] = [0; 20];
    let mut tmp___14: uint16_t = 0;
    let mut tmp___15: uint16_t = 0;
    let mut tmp___16: size_t = 0;
    let mut tmp___17: libc::c_int = 0;
    p = buf___0;
    end = buf___0.offset(len as isize);
    code[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 5 as libc::c_uint) {
        code[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    if settings.is_null() {
        return -(1 as libc::c_int)
    } else {
        if buf___0.is_null() {
            return -(1 as libc::c_int);
        }
    }
    while end.offset_from(p) as libc::c_long >= 8 as libc::c_long {
        memcpy(
            code.as_mut_ptr() as *mut libc::c_void,
            p as *const libc::c_void,
            4 as libc::c_int as size_t,
        );
        field = dmap_field_from_code(code.as_mut_ptr() as *const libc::c_char);
        p = p.offset(4 as libc::c_int as isize);
        tmp___0 = dmap_read_u32(p);
        field_len = tmp___0 as size_t;
        p = p.offset(4 as libc::c_int as isize);
        if p.offset(field_len as isize) as libc::c_ulong > end as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if !field.is_null() {
            field_type = (*field).type_0;
            field_name = (*field).name;
            if field_type as libc::c_uint == 8 as libc::c_uint {
                if parent as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    if (*parent).list_item_type as u64 != 0 {
                        field_type = (*parent).list_item_type;
                    } else {
                        field_type = DMAP_DICT;
                    }
                } else {
                    field_type = DMAP_DICT;
                }
            }
        } else {
            field_type = DMAP_UNKNOWN;
            field_name = code.as_mut_ptr() as *const libc::c_char;
            if field_len >= 8 as libc::c_ulong {
                tmp___2 = __ctype_b_loc();
                if *(*tmp___2)
                    .offset(
                        (*p.offset(0 as libc::c_int as isize) as libc::c_int
                            & 255 as libc::c_int) as isize,
                    ) as libc::c_int & 1024 as libc::c_int != 0
                {
                    tmp___3 = __ctype_b_loc();
                    if *(*tmp___3)
                        .offset(
                            (*p.offset(1 as libc::c_int as isize) as libc::c_int
                                & 255 as libc::c_int) as isize,
                        ) as libc::c_int & 1024 as libc::c_int != 0
                    {
                        tmp___4 = __ctype_b_loc();
                        if *(*tmp___4)
                            .offset(
                                (*p.offset(2 as libc::c_int as isize) as libc::c_int
                                    & 255 as libc::c_int) as isize,
                            ) as libc::c_int & 1024 as libc::c_int != 0
                        {
                            tmp___5 = __ctype_b_loc();
                            if *(*tmp___5)
                                .offset(
                                    (*p.offset(3 as libc::c_int as isize) as libc::c_int
                                        & 255 as libc::c_int) as isize,
                                ) as libc::c_int & 1024 as libc::c_int != 0
                            {
                                tmp___1 = dmap_read_u32(
                                    p.offset(4 as libc::c_int as isize),
                                );
                                if (tmp___1 as size_t) < field_len {
                                    field_type = DMAP_DICT;
                                }
                            }
                        }
                    }
                }
            }
            if field_type as libc::c_uint == 0 as libc::c_uint {
                is_string = 1 as libc::c_int;
                i = 0 as libc::c_int as size_t;
                while i < field_len {
                    tmp___6 = __ctype_b_loc();
                    if *(*tmp___6)
                        .offset(
                            (*p.offset(i as isize) as libc::c_int & 255 as libc::c_int)
                                as isize,
                        ) as libc::c_int & 16384 as libc::c_int == 0
                    {
                        is_string = 0 as libc::c_int;
                        break;
                    } else {
                        i = i.wrapping_add(1);
                    }
                }
                if is_string != 0 {
                    field_type = DMAP_STR;
                } else {
                    field_type = DMAP_UINT;
                }
            }
        }
        match field_type as libc::c_uint {
            1 => {
                match field_len {
                    1 => {
                        if ((*settings).on_uint32).is_some() {
                            (Some(
                                ((*settings).on_uint32).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                *p as libc::c_uchar as uint32_t,
                            );
                        }
                    }
                    2 => {
                        if ((*settings).on_uint32).is_some() {
                            tmp___7 = dmap_read_u16(p);
                            (Some(
                                ((*settings).on_uint32).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                tmp___7 as uint32_t,
                            );
                        }
                    }
                    4 => {
                        if ((*settings).on_uint32).is_some() {
                            tmp___8 = dmap_read_u32(p);
                            (Some(
                                ((*settings).on_uint32).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                tmp___8,
                            );
                        }
                    }
                    8 => {
                        if ((*settings).on_uint64).is_some() {
                            tmp___9 = dmap_read_u64(p);
                            (Some(
                                ((*settings).on_uint64).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                tmp___9,
                            );
                        }
                    }
                    _ => {
                        if ((*settings).on_data).is_some() {
                            (Some(
                                ((*settings).on_data).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                p,
                                field_len,
                            );
                        }
                    }
                }
            }
            2 => {
                match field_len {
                    1 => {
                        if ((*settings).on_int32).is_some() {
                            (Some(
                                ((*settings).on_int32).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                *p as int32_t,
                            );
                        }
                    }
                    2 => {
                        if ((*settings).on_int32).is_some() {
                            tmp___10 = dmap_read_i16(p);
                            (Some(
                                ((*settings).on_int32).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                tmp___10 as int32_t,
                            );
                        }
                    }
                    4 => {
                        if ((*settings).on_int32).is_some() {
                            tmp___11 = dmap_read_i32(p);
                            (Some(
                                ((*settings).on_int32).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                tmp___11,
                            );
                        }
                    }
                    8 => {
                        if ((*settings).on_int64).is_some() {
                            tmp___12 = dmap_read_i64(p);
                            (Some(
                                ((*settings).on_int64).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                tmp___12,
                            );
                        }
                    }
                    _ => {
                        if ((*settings).on_data).is_some() {
                            (Some(
                                ((*settings).on_data).expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*settings).ctx,
                                code.as_mut_ptr() as *const libc::c_char,
                                field_name,
                                p,
                                field_len,
                            );
                        }
                    }
                }
            }
            3 => {
                if ((*settings).on_string).is_some() {
                    (Some(((*settings).on_string).expect("non-null function pointer")))
                        .expect(
                            "non-null function pointer",
                        )(
                        (*settings).ctx,
                        code.as_mut_ptr() as *const libc::c_char,
                        field_name,
                        p,
                        field_len,
                    );
                }
            }
            4 => {
                if ((*settings).on_data).is_some() {
                    (Some(((*settings).on_data).expect("non-null function pointer")))
                        .expect(
                            "non-null function pointer",
                        )(
                        (*settings).ctx,
                        code.as_mut_ptr() as *const libc::c_char,
                        field_name,
                        p,
                        field_len,
                    );
                }
            }
            5 => {
                if ((*settings).on_date).is_some() {
                    tmp___13 = dmap_read_u32(p);
                    (Some(((*settings).on_date).expect("non-null function pointer")))
                        .expect(
                            "non-null function pointer",
                        )(
                        (*settings).ctx,
                        code.as_mut_ptr() as *const libc::c_char,
                        field_name,
                        tmp___13,
                    );
                }
            }
            6 => {
                if ((*settings).on_string).is_some() {
                    if field_len >= 4 as libc::c_ulong {
                        tmp___14 = dmap_read_u16(p.offset(2 as libc::c_int as isize));
                        tmp___15 = dmap_read_u16(p);
                        sprintf(
                            version.as_mut_ptr(),
                            b"%u.%u\0" as *const u8 as *const libc::c_char,
                            tmp___15 as libc::c_int,
                            tmp___14 as libc::c_int,
                        );
                        tmp___16 = strlen(version.as_mut_ptr() as *const libc::c_char);
                        (Some(
                            ((*settings).on_string).expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            (*settings).ctx,
                            code.as_mut_ptr() as *const libc::c_char,
                            field_name,
                            version.as_mut_ptr() as *const libc::c_char,
                            tmp___16,
                        );
                    }
                }
            }
            7 => {
                if ((*settings).on_dict_start).is_some() {
                    (Some(
                        ((*settings).on_dict_start).expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        (*settings).ctx,
                        code.as_mut_ptr() as *const libc::c_char,
                        field_name,
                    );
                }
                tmp___17 = dmap_parse_internal(settings, p, field_len, field);
                if tmp___17 != 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                if ((*settings).on_dict_end).is_some() {
                    (Some(((*settings).on_dict_end).expect("non-null function pointer")))
                        .expect(
                            "non-null function pointer",
                        )(
                        (*settings).ctx,
                        code.as_mut_ptr() as *const libc::c_char,
                        field_name,
                    );
                }
            }
            8 => {
                abort();
            }
            0 | _ => {}
        }
        p = p.offset(field_len as isize);
    }
    if p as libc::c_ulong != end as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn dmap_parse(
    mut settings: *const dmap_settings,
    mut buf___0: *const libc::c_char,
    mut len: size_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = dmap_parse_internal(
        settings,
        buf___0,
        len,
        0 as *mut libc::c_void as *const dmap_field,
    );
    return tmp;
}
static mut debug_mode: libc::c_int = 0;
unsafe extern "C" fn debug(
    mut format: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut args_0: ::std::ffi::VaListImpl;
    let mut ret: libc::c_int = 0;
    if debug_mode == 0 {
        return 0 as libc::c_int;
    }
    args_0 = args.clone();
    ret = vfprintf(stderr, format, args_0.as_va_list());
    return ret;
}
unsafe extern "C" fn gettime() -> uint32_t {
    let mut ts: timespec = timespec { tv_sec: 0, tv_nsec: 0 };
    let mut tmp: libc::c_int = 0;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    tmp = clock_gettime(1 as libc::c_int, &mut ts);
    if tmp == 0 {
        return ts.tv_sec as uint32_t;
    }
    gettimeofday(&mut tv as *mut timeval, 0 as *mut libc::c_void);
    return tv.tv_sec as uint32_t;
}
unsafe extern "C" fn insert_item(
    mut item: *mut item_t,
    mut list: *mut *mut item_t,
) -> *mut item_t {
    if !(*list).is_null() {
        (*item).next = *list;
    } else {
        (*item).next = 0 as *mut libc::c_void as *mut item_s;
    }
    *list = item;
    return item;
}
unsafe extern "C" fn remove_item___0(
    mut item: *mut item_t,
    mut list: *mut *mut item_t,
) -> *mut item_t {
    let mut p: *mut item_s = 0 as *mut item_s;
    if item as libc::c_ulong != *list as libc::c_ulong {
        p = *list;
        while !p.is_null() {
            if !((*p).next as libc::c_ulong != item as libc::c_ulong) {
                break;
            }
            p = (*p).next;
        }
        if !p.is_null() {
            (*p).next = (*item).next;
        }
        (*item).next = 0 as *mut libc::c_void as *mut item_s;
    } else {
        *list = (**list).next;
    }
    return item;
}
unsafe extern "C" fn clear_list___0(
    mut list: *mut item_t,
    mut free_func: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    let mut next: *mut item_s = 0 as *mut item_s;
    if list.is_null() {
        return;
    }
    while !list.is_null() {
        next = (*list).next;
        if free_func.is_some() {
            (Some(free_func.expect("non-null function pointer")))
                .expect("non-null function pointer")(list as *mut libc::c_void);
        } else {
            free(list as *mut libc::c_void);
        }
        list = next;
    }
}
unsafe extern "C" fn free_a(mut a: *mut alist_t) {
    if !((*a).name).is_null() {
        free((*a).name as *mut libc::c_void);
    }
    free(a as *mut libc::c_void);
}
unsafe extern "C" fn free_s(mut s: *mut slist_t) {
    if !((*s).name).is_null() {
        free((*s).name as *mut libc::c_void);
    }
    if !((*s).hostname).is_null() {
        free((*s).hostname as *mut libc::c_void);
    }
    if !((*s).txt).is_null() {
        free((*s).txt as *mut libc::c_void);
    }
    free(s as *mut libc::c_void);
}
unsafe extern "C" fn prepare_query_string(
    mut name: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut count___0: libc::c_int = 0;
    let mut lastdot: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    lastdot = 0 as libc::c_int;
    tmp = strlen(name as *const libc::c_char);
    len = tmp as libc::c_int;
    tmp___0 = malloc((len + 2 as libc::c_int) as size_t);
    result = tmp___0 as *mut libc::c_char;
    if result.is_null() {
        debug(
            b"failed to allocate memory for parsed hostname\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    count___0 = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < len + 1 as libc::c_int {
        if *name.offset(i as isize) as libc::c_int == 46 as libc::c_int {
            *result.offset(lastdot as isize) = count___0 as libc::c_char;
            count___0 = 0 as libc::c_int;
            lastdot = i + 1 as libc::c_int;
        } else if *name.offset(i as isize) as libc::c_int == 0 as libc::c_int {
            *result.offset(lastdot as isize) = count___0 as libc::c_char;
            count___0 = 0 as libc::c_int;
            lastdot = i + 1 as libc::c_int;
        } else {
            *result.offset((i + 1 as libc::c_int) as isize) = *name.offset(i as isize);
            count___0 += 1;
        }
        i += 1;
    }
    *result.offset((len + 1 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
    return result;
}
unsafe extern "C" fn mdns_parse_header_flags(mut data: uint16_t) -> *mut mDNSFlags {
    let mut flags: *mut mDNSFlags = 0 as *mut mDNSFlags;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<mDNSFlags>() as libc::c_ulong);
    flags = tmp as *mut mDNSFlags;
    if flags.is_null() {
        debug(
            b"could not allocate memory for parsing header flags\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut mDNSFlags;
    }
    (*flags).rcode = data as libc::c_int & 15 as libc::c_int;
    (*flags).cd = data as libc::c_int >> 4 as libc::c_int & 1 as libc::c_int;
    (*flags).ad = data as libc::c_int >> 5 as libc::c_int & 1 as libc::c_int;
    (*flags).zero = data as libc::c_int >> 6 as libc::c_int & 1 as libc::c_int;
    (*flags).ra = data as libc::c_int >> 7 as libc::c_int & 1 as libc::c_int;
    (*flags).rd = data as libc::c_int >> 8 as libc::c_int & 1 as libc::c_int;
    (*flags).tc = data as libc::c_int >> 9 as libc::c_int & 1 as libc::c_int;
    (*flags).aa = data as libc::c_int >> 10 as libc::c_int & 1 as libc::c_int;
    (*flags).opcode = data as libc::c_int >> 14 as libc::c_int & 15 as libc::c_int;
    (*flags).qr = data as libc::c_int >> 15 as libc::c_int & 1 as libc::c_int;
    return flags;
}
unsafe extern "C" fn mdns_pack_header_flags(mut flags: mDNSFlags) -> uint16_t {
    let mut packed: uint16_t = 0;
    packed = 0 as libc::c_int as uint16_t;
    packed = (packed as libc::c_int | flags.rcode & 65520 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.cd & 65534 as libc::c_int) << 4 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.ad & 65534 as libc::c_int) << 5 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.zero & 65534 as libc::c_int) << 6 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.ra & 65534 as libc::c_int) << 7 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.rd & 65534 as libc::c_int) << 8 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.tc & 65534 as libc::c_int) << 9 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.aa & 65534 as libc::c_int) << 10 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.opcode & 65520 as libc::c_int) << 14 as libc::c_int) as uint16_t;
    packed = (packed as libc::c_int
        | (flags.qr & 65534 as libc::c_int) << 15 as libc::c_int) as uint16_t;
    return packed;
}
unsafe extern "C" fn mdns_pack_question(
    mut q: *mut mDNSQuestion,
    mut size: *mut size_t,
) -> *mut libc::c_char {
    let mut packed: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut name_length: size_t = 0;
    let mut qtype: uint16_t = 0;
    let mut qclass: uint16_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen((*q).qname as *const libc::c_char);
    name_length = tmp.wrapping_add(1 as libc::c_ulong);
    if name_length > 253 as libc::c_ulong {
        debug(b"domain name too long\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    debug(b"name length: %u\n\0" as *const u8 as *const libc::c_char, name_length);
    *size = name_length
        .wrapping_add(2 as libc::c_ulong)
        .wrapping_add(2 as libc::c_ulong);
    tmp___0 = malloc(*size);
    packed = tmp___0 as *mut libc::c_char;
    if packed.is_null() {
        debug(
            b"could not allocate memory for DNS question\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    memcpy(packed as *mut libc::c_void, (*q).qname as *const libc::c_void, name_length);
    if (*q).prefer_unicast_response != 0 {
        (*q)
            .qclass = ((*q).qclass as libc::c_int
            | (1 as libc::c_int) << 15 as libc::c_int) as uint16_t;
    }
    qtype = __bswap_16((*q).qtype);
    qclass = __bswap_16((*q).qclass);
    memcpy(
        packed.offset(name_length as isize) as *mut libc::c_void,
        &mut qtype as *mut uint16_t as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    memcpy(
        packed.offset(name_length as isize).offset(2 as libc::c_int as isize)
            as *mut libc::c_void,
        &mut qclass as *mut uint16_t as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    return packed;
}
unsafe extern "C" fn mdns_parse_question(
    mut message: *mut libc::c_char,
    mut data: *mut libc::c_char,
    mut size: libc::c_int,
) -> libc::c_int {
    let mut q: mDNSQuestion = mDNSQuestion {
        qname: 0 as *mut libc::c_char,
        qtype: 0,
        qclass: 0,
        prefer_unicast_response: 0,
    };
    let mut cur: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut parsed: libc::c_int = 0;
    parsed = 0 as libc::c_int;
    cur = data;
    q.qname = parse_rr_name(message, data, &mut parsed);
    free(q.qname as *mut libc::c_void);
    cur = cur.offset(parsed as isize);
    if parsed > size {
        debug(b"qname is too long\0" as *const u8 as *const libc::c_char);
        return 0 as libc::c_int;
    }
    memcpy(
        &mut q.qtype as *mut uint16_t as *mut libc::c_void,
        cur as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    q.qtype = __bswap_16(q.qtype);
    cur = cur.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    if parsed > size {
        return 0 as libc::c_int;
    }
    memcpy(
        &mut q.qclass as *mut uint16_t as *mut libc::c_void,
        cur as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    q.qclass = __bswap_16(q.qclass);
    cur = cur.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    if parsed > size {
        return 0 as libc::c_int;
    }
    return parsed;
}
unsafe extern "C" fn mdns_message_print(mut msg: *mut mDNSMessage) {
    let mut flags: *mut mDNSFlags = 0 as *mut mDNSFlags;
    let mut tmp: *mut mDNSFlags = 0 as *mut mDNSFlags;
    tmp = mdns_parse_header_flags((*msg).flags);
    flags = tmp;
    if flags.is_null() {
        return;
    }
    free(flags as *mut libc::c_void);
}
unsafe extern "C" fn mdns_parse_rr_a(
    mut data: *mut libc::c_char,
    mut addr: *mut in_addr,
) -> libc::c_int {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    (*addr).s_addr = 0 as libc::c_int as in_addr_t;
    if *data.offset(0 as libc::c_int as isize) as libc::c_int == -(87 as libc::c_int) {
        if *data.offset(1 as libc::c_int as isize) as libc::c_int == -(2 as libc::c_int)
        {
            return 4 as libc::c_int;
        }
    }
    memcpy(
        &mut (*addr).s_addr as *mut in_addr_t as *mut libc::c_void,
        data as *const libc::c_void,
        4 as libc::c_int as size_t,
    );
    tmp = inet_ntoa(*addr);
    debug(b"        A: %s\n\0" as *const u8 as *const libc::c_char, tmp);
    return 4 as libc::c_int;
}
unsafe extern "C" fn mdns_parse_rr_ptr(
    mut message: *mut libc::c_char,
    mut data: *mut libc::c_char,
    mut name: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut parsed: libc::c_int = 0;
    parsed = 0 as libc::c_int;
    *name = parse_rr_name(message, data, &mut parsed);
    debug(b"        PTR: %s\n\0" as *const u8 as *const libc::c_char, *name);
    return parsed;
}
unsafe extern "C" fn mdns_parse_rr_srv(
    mut message: *mut libc::c_char,
    mut data: *mut libc::c_char,
    mut hostname: *mut *mut libc::c_char,
    mut port: *mut libc::c_ushort,
) -> libc::c_int {
    let mut priority: uint16_t = 0;
    let mut weight: uint16_t = 0;
    let mut parsed: libc::c_int = 0;
    parsed = 0 as libc::c_int;
    memcpy(
        &mut priority as *mut uint16_t as *mut libc::c_void,
        data as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    priority = __bswap_16(priority);
    data = data.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    memcpy(
        &mut weight as *mut uint16_t as *mut libc::c_void,
        data as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    weight = __bswap_16(weight);
    data = data.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    memcpy(
        port as *mut libc::c_void,
        data as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    *port = __bswap_16(*port);
    data = data.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    *hostname = parse_rr_name(message, data, &mut parsed);
    debug(b"        SRV target: %s\n\0" as *const u8 as *const libc::c_char, *hostname);
    debug(
        b"        SRV port: %u\n\0" as *const u8 as *const libc::c_char,
        *port as libc::c_int,
    );
    return parsed;
}
unsafe extern "C" fn mdns_parse_rr_txt(
    mut message: *mut libc::c_char,
    mut rr: *mut mDNSResourceRecord,
    mut txt: *mut *mut libc::c_char,
    mut length: *mut libc::c_int,
) {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp___0 = malloc((*rr).rdata_length as size_t);
    tmp = tmp___0 as *mut libc::c_char;
    *txt = tmp;
    if tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        memcpy(
            *txt as *mut libc::c_void,
            (*rr).rdata as *const libc::c_void,
            (*rr).rdata_length as size_t,
        );
        *length = (*rr).rdata_length as libc::c_int;
    }
}
unsafe extern "C" fn get_offset(mut data: *mut libc::c_char) -> uint16_t {
    let mut offset: uint16_t = 0;
    memcpy(
        &mut offset as *mut uint16_t as *mut libc::c_void,
        data as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    offset = __bswap_16(offset);
    if offset as libc::c_int >> 14 as libc::c_int & 3 as libc::c_int != 0 {
        offset = (offset as libc::c_int & 16383 as libc::c_int) as uint16_t;
        return offset;
    }
    return 0 as libc::c_int as uint16_t;
}
unsafe extern "C" fn parse_rr_name(
    mut message: *mut libc::c_char,
    mut name: *mut libc::c_char,
    mut parsed: *mut libc::c_int,
) -> *mut libc::c_char {
    let mut dereference_count: libc::c_int = 0;
    let mut offset: uint16_t = 0;
    let mut label_len___0: libc::c_int = 0;
    let mut out: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut out_i: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut did_jump: libc::c_int = 0;
    let mut pars: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    dereference_count = 0 as libc::c_int;
    out_i = 0 as libc::c_int;
    i = 0 as libc::c_int;
    did_jump = 0 as libc::c_int;
    pars = 0 as libc::c_int;
    tmp = malloc(256 as libc::c_int as size_t);
    out = tmp as *mut libc::c_char;
    if out.is_null() {
        debug(
            b"could not allocate memory for resource record name\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    loop {
        offset = get_offset(name);
        if offset != 0 {
            if did_jump == 0 {
                pars += 2 as libc::c_int;
            }
            did_jump = 1 as libc::c_int;
            name = message.offset(offset as libc::c_int as isize);
            dereference_count += 1;
            if dereference_count >= 40 as libc::c_int {
                free(out as *mut libc::c_void);
                return 0 as *mut libc::c_void as *mut libc::c_char;
            }
        } else {
            if out_i > 0 as libc::c_int {
                tmp___0 = out_i;
                out_i += 1;
                *out.offset(tmp___0 as isize) = '.' as i32 as libc::c_char;
                if out_i + 1 as libc::c_int >= 256 as libc::c_int {
                    free(out as *mut libc::c_void);
                    return 0 as *mut libc::c_void as *mut libc::c_char;
                }
            }
            label_len___0 = *name.offset(0 as libc::c_int as isize) as libc::c_int;
            name = name.offset(1);
            if did_jump == 0 {
                pars += 1;
            }
            i = 0 as libc::c_int;
            while i < label_len___0 {
                tmp___1 = out_i;
                out_i += 1;
                *out.offset(tmp___1 as isize) = *name.offset(i as isize);
                if out_i + 1 as libc::c_int >= 256 as libc::c_int {
                    free(out as *mut libc::c_void);
                    return 0 as *mut libc::c_void as *mut libc::c_char;
                }
                if did_jump == 0 {
                    pars += 1;
                }
                i += 1;
            }
            name = name.offset(label_len___0 as isize);
            if *name.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            {
                *out.offset(out_i as isize) = '\u{0}' as i32 as libc::c_char;
                if did_jump == 0 {
                    if label_len___0 != 0 {
                        pars += 1;
                    }
                }
                *parsed += pars;
                return out;
            }
        }
    };
}
unsafe extern "C" fn free_resource_record(mut rr: *mut mDNSResourceRecord) {
    if !((*rr).name).is_null() {
        free((*rr).name as *mut libc::c_void);
        (*rr).name = 0 as *mut libc::c_void as *mut libc::c_char;
    }
}
unsafe extern "C" fn mdns_parse_rr(
    mut host: in_addr,
    mut context: *mut context_s,
    mut message: *mut libc::c_char,
    mut rrdata: *mut libc::c_char,
    mut size: libc::c_int,
    mut is_answer: libc::c_int,
) -> libc::c_int {
    let mut rr: mDNSResourceRecord = mDNSResourceRecord {
        name: 0 as *mut libc::c_char,
        type_0: 0,
        class: 0,
        ttl: 0,
        rdata_length: 0,
        rdata: 0 as *mut libc::c_void,
    };
    let mut parsed: libc::c_int = 0;
    let mut cur: *mut libc::c_char = 0 as *mut libc::c_char;
    parsed = 0 as libc::c_int;
    cur = rrdata;
    rr.name = 0 as *mut libc::c_void as *mut libc::c_char;
    rr.name = parse_rr_name(message, rrdata, &mut parsed);
    if (rr.name).is_null() {
        free_resource_record(&mut rr);
        debug(
            b"parsing resource record name failed\n\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    cur = cur.offset(parsed as isize);
    if parsed + 10 as libc::c_int > size {
        free_resource_record(&mut rr);
        return 0 as libc::c_int;
    }
    debug(
        b"      Resource Record Name: %s\n\0" as *const u8 as *const libc::c_char,
        rr.name,
    );
    memcpy(
        &mut rr.type_0 as *mut uint16_t as *mut libc::c_void,
        cur as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    rr.type_0 = __bswap_16(rr.type_0);
    cur = cur.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    debug(
        b"      Resource Record Type: %u\n\0" as *const u8 as *const libc::c_char,
        rr.type_0 as libc::c_int,
    );
    memcpy(
        &mut rr.class as *mut uint16_t as *mut libc::c_void,
        cur as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    rr.class = __bswap_16(rr.class);
    cur = cur.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    memcpy(
        &mut rr.ttl as *mut uint32_t as *mut libc::c_void,
        cur as *const libc::c_void,
        4 as libc::c_int as size_t,
    );
    rr.ttl = __bswap_32(rr.ttl);
    cur = cur.offset(4 as libc::c_int as isize);
    parsed += 4 as libc::c_int;
    debug(b"      ttl: %u\n\0" as *const u8 as *const libc::c_char, rr.ttl);
    memcpy(
        &mut rr.rdata_length as *mut uint16_t as *mut libc::c_void,
        cur as *const libc::c_void,
        2 as libc::c_int as size_t,
    );
    rr.rdata_length = __bswap_16(rr.rdata_length);
    cur = cur.offset(2 as libc::c_int as isize);
    parsed += 2 as libc::c_int;
    if parsed > size {
        free_resource_record(&mut rr);
        return 0 as libc::c_int;
    }
    rr.rdata = cur as *mut libc::c_void;
    parsed += rr.rdata_length as libc::c_int;
    if is_answer != 0 {
        if rr.type_0 as libc::c_int == 1 as libc::c_int {
            store_a(context, &mut rr);
        } else {
            store_other(host, context, message, &mut rr);
        }
    }
    free_resource_record(&mut rr);
    debug(b"    ------------------------------\n\0" as *const u8 as *const libc::c_char);
    return parsed;
}
unsafe extern "C" fn mdns_parse_message_net(
    mut host: in_addr,
    mut context: *mut context_s,
    mut data: *mut libc::c_char,
    mut size: libc::c_int,
    mut msg: *mut mDNSMessage,
) -> libc::c_int {
    let mut parsed: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    parsed = 0 as libc::c_int;
    if size < 12 as libc::c_int {
        return 0 as libc::c_int;
    }
    memcpy(
        msg as *mut libc::c_void,
        data as *const libc::c_void,
        12 as libc::c_int as size_t,
    );
    (*msg).id = __bswap_16((*msg).id);
    (*msg).flags = __bswap_16((*msg).flags);
    (*msg).qd_count = __bswap_16((*msg).qd_count);
    (*msg).an_count = __bswap_16((*msg).an_count);
    (*msg).ns_count = __bswap_16((*msg).ns_count);
    (*msg).ar_count = __bswap_16((*msg).ar_count);
    parsed += 12 as libc::c_int;
    mdns_message_print(msg);
    debug(
        b"  Question records [%u] (not shown)\n\0" as *const u8 as *const libc::c_char,
        (*msg).qd_count as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < (*msg).qd_count as libc::c_int {
        tmp = mdns_parse_question(data, data.offset(parsed as isize), size - parsed);
        parsed += tmp;
        i += 1;
    }
    debug(
        b"  Answer records [%u]\n\0" as *const u8 as *const libc::c_char,
        (*msg).an_count as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < (*msg).an_count as libc::c_int {
        tmp___0 = mdns_parse_rr(
            host,
            context,
            data,
            data.offset(parsed as isize),
            size - parsed,
            1 as libc::c_int,
        );
        parsed += tmp___0;
        i += 1;
    }
    debug(
        b"  Nameserver records [%u] (not shown)\n\0" as *const u8 as *const libc::c_char,
        (*msg).ns_count as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < (*msg).ns_count as libc::c_int {
        tmp___1 = mdns_parse_rr(
            host,
            context,
            data,
            data.offset(parsed as isize),
            size - parsed,
            0 as libc::c_int,
        );
        parsed += tmp___1;
        i += 1;
    }
    debug(
        b"  Additional records [%u] (not shown)\n\0" as *const u8 as *const libc::c_char,
        (*msg).ns_count as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < (*msg).ar_count as libc::c_int {
        tmp___2 = mdns_parse_rr(
            host,
            context,
            data,
            data.offset(parsed as isize),
            size - parsed,
            1 as libc::c_int,
        );
        parsed += tmp___2;
        i += 1;
    }
    return parsed;
}
unsafe extern "C" fn mdns_build_query_message(
    mut query_str: *mut libc::c_char,
    mut query_type: uint16_t,
) -> *mut mDNSMessage {
    let mut msg: *mut mDNSMessage = 0 as *mut mDNSMessage;
    let mut question: mDNSQuestion = mDNSQuestion {
        qname: 0 as *mut libc::c_char,
        qtype: 0,
        qclass: 0,
        prefer_unicast_response: 0,
    };
    let mut flags: mDNSFlags = mDNSFlags {
        qr: 0,
        opcode: 0,
        aa: 0,
        tc: 0,
        rd: 0,
        ra: 0,
        zero: 0,
        ad: 0,
        cd: 0,
        rcode: 0,
    };
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: uint16_t = 0;
    let mut tmp___1: uint16_t = 0;
    let mut tmp___2: uint16_t = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = malloc(::std::mem::size_of::<mDNSMessage>() as libc::c_ulong);
    msg = tmp as *mut mDNSMessage;
    if msg.is_null() {
        debug(
            b"failed to allocate memory for mDNS message\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut mDNSMessage;
    }
    flags.qr = 0 as libc::c_int;
    flags.opcode = 0 as libc::c_int;
    flags.aa = 0 as libc::c_int;
    flags.tc = 0 as libc::c_int;
    flags.rd = 0 as libc::c_int;
    flags.ra = 0 as libc::c_int;
    flags.zero = 0 as libc::c_int;
    flags.ad = 0 as libc::c_int;
    flags.cd = 0 as libc::c_int;
    flags.rcode = 0 as libc::c_int;
    (*msg).id = 0 as libc::c_int as uint16_t;
    tmp___0 = mdns_pack_header_flags(flags);
    (*msg).flags = __bswap_16(tmp___0);
    (*msg).qd_count = __bswap_16(1 as libc::c_int as __uint16_t);
    tmp___2 = 0 as libc::c_int as uint16_t;
    (*msg).ar_count = tmp___2;
    tmp___1 = tmp___2;
    (*msg).ns_count = tmp___1;
    (*msg).an_count = tmp___1;
    question.qname = query_str;
    if (question.qname).is_null() {
        return 0 as *mut libc::c_void as *mut mDNSMessage;
    }
    question.prefer_unicast_response = 0 as libc::c_int;
    question.qtype = query_type;
    question.qclass = 1 as libc::c_int as uint16_t;
    tmp___3 = mdns_pack_question(&mut question, &mut (*msg).data_size);
    (*msg).data = tmp___3;
    if tmp___3 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        free(msg as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut mDNSMessage;
    }
    return msg;
}
unsafe extern "C" fn mdns_pack_message(
    mut msg: *mut mDNSMessage,
    mut pack_length: *mut size_t,
) -> *mut libc::c_char {
    let mut pack: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    *pack_length = (12 as libc::c_ulong).wrapping_add((*msg).data_size);
    if *pack_length > 4096 as libc::c_ulong {
        debug(b"mDNS message too large\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmp = malloc(*pack_length);
    pack = tmp as *mut libc::c_char;
    if pack.is_null() {
        debug(
            b"failed to allocate data for packed mDNS message\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    memcpy(
        pack as *mut libc::c_void,
        msg as *const libc::c_void,
        12 as libc::c_int as size_t,
    );
    memcpy(
        pack.offset(12 as libc::c_int as isize) as *mut libc::c_void,
        (*msg).data as *const libc::c_void,
        (*msg).data_size,
    );
    return pack;
}
unsafe extern "C" fn mdns_parse_txt(
    mut txt: *mut libc::c_char,
    mut txt_length: libc::c_int,
    mut s: *mut mDNSservice_t,
) {
    let mut len: libc::c_int = 0;
    let mut count___0: libc::c_int = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    len = 0 as libc::c_int;
    count___0 = 0 as libc::c_int;
    if txt.is_null() {
        return;
    }
    while len + count___0 < txt_length {
        len += *txt.offset(len as isize).offset(count___0 as isize) as libc::c_int;
        count___0 += 1;
    }
    (*s).attr_count = count___0;
    tmp = malloc(
        (count___0 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<txt_attr_t>() as libc::c_ulong),
    );
    (*s).attr = tmp as *mut txt_attr_t;
    p = txt;
    i = 0 as libc::c_int;
    while i < count___0 {
        tmp___0 = memchr(
            p.offset(1 as libc::c_int as isize) as *const libc::c_void,
            '=' as i32,
            *p as size_t,
        );
        value = tmp___0 as *mut libc::c_char;
        if !value.is_null() {
            len = (*p as libc::c_long
                - value.offset_from(p.offset(1 as libc::c_int as isize)) as libc::c_long
                - 1 as libc::c_long) as libc::c_int;
            tmp___1 = malloc((len + 1 as libc::c_int) as size_t);
            let ref mut fresh36 = (*((*s).attr).offset(i as isize)).value;
            *fresh36 = tmp___1 as *mut libc::c_char;
            memcpy(
                (*((*s).attr).offset(i as isize)).value as *mut libc::c_void,
                value.offset(1 as libc::c_int as isize) as *const libc::c_void,
                len as size_t,
            );
            *((*((*s).attr).offset(i as isize)).value)
                .offset(len as isize) = '\u{0}' as i32 as libc::c_char;
            len = value.offset_from(p.offset(1 as libc::c_int as isize)) as libc::c_long
                as libc::c_int;
            tmp___2 = malloc((len + 1 as libc::c_int) as size_t);
            let ref mut fresh37 = (*((*s).attr).offset(i as isize)).name;
            *fresh37 = tmp___2 as *mut libc::c_char;
            memcpy(
                (*((*s).attr).offset(i as isize)).name as *mut libc::c_void,
                p.offset(1 as libc::c_int as isize) as *const libc::c_void,
                len as size_t,
            );
            *((*((*s).attr).offset(i as isize)).name)
                .offset(len as isize) = '\u{0}' as i32 as libc::c_char;
        } else {
            len = *p as libc::c_int;
            tmp___3 = malloc((len + 1 as libc::c_int) as size_t);
            let ref mut fresh38 = (*((*s).attr).offset(i as isize)).name;
            *fresh38 = tmp___3 as *mut libc::c_char;
            memcpy(
                (*((*s).attr).offset(i as isize)).name as *mut libc::c_void,
                p.offset(1 as libc::c_int as isize) as *const libc::c_void,
                len as size_t,
            );
            *((*((*s).attr).offset(i as isize)).name)
                .offset(len as isize) = '\u{0}' as i32 as libc::c_char;
            let ref mut fresh39 = (*((*s).attr).offset(i as isize)).value;
            *fresh39 = 0 as *mut libc::c_void as *mut libc::c_char;
        }
        p = p.offset((*p as libc::c_int + 1 as libc::c_int) as isize);
        i += 1;
    }
}
unsafe extern "C" fn send_query(
    mut sock: libc::c_int,
    mut query_arg: *mut libc::c_char,
    mut query_type: uint16_t,
) -> libc::c_int {
    let mut msg: *mut mDNSMessage = 0 as *mut mDNSMessage;
    let mut data: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data_size: size_t = 0;
    let mut res: libc::c_int = 0;
    let mut addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut addrlen: socklen_t = 0;
    let mut query_str: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: ssize_t = 0;
    query_str = prepare_query_string(query_arg);
    if query_str as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    addr.sin_family = 2 as libc::c_int as sa_family_t;
    addr.sin_port = __bswap_16(5353 as libc::c_int as __uint16_t);
    addr
        .sin_addr
        .s_addr = inet_addr(b"224.0.0.251\0" as *const u8 as *const libc::c_char);
    addrlen = ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
    msg = mdns_build_query_message(query_str, query_type);
    free(query_str as *mut libc::c_void);
    if msg.is_null() {
        return -(1 as libc::c_int);
    }
    data = mdns_pack_message(msg, &mut data_size);
    free((*msg).data as *mut libc::c_void);
    free(msg as *mut libc::c_void);
    if data.is_null() {
        return -(1 as libc::c_int);
    }
    debug(
        b"Sending DNS message with length: %u\n\0" as *const u8 as *const libc::c_char,
        data_size,
    );
    tmp = sendto(
        sock,
        data as *const libc::c_void,
        data_size,
        0 as libc::c_int,
        &mut addr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        addrlen,
    );
    res = tmp as libc::c_int;
    free(data as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn is_complete(mut s: *mut slist_t) -> libc::c_int {
    if (*s).addr.s_addr != 0 {
        if !((*s).hostname).is_null() {
            if (*s).port != 0 {
                if !((*s).txt).is_null() {
                    return 1 as libc::c_int
                } else {
                    return 0 as libc::c_int
                }
            } else {
                return 0 as libc::c_int
            }
        } else {
            return 0 as libc::c_int
        }
    } else {
        return 0 as libc::c_int
    };
}
unsafe extern "C" fn store_a(
    mut context: *mut context_s,
    mut rr: *mut mDNSResourceRecord,
) {
    let mut b: *mut alist_t = 0 as *mut alist_t;
    let mut addr: in_addr = in_addr { s_addr: 0 };
    let mut tmp: uint32_t = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: uint32_t = 0;
    mdns_parse_rr_a((*rr).rdata as *mut libc::c_char, &mut addr);
    b = (*context).alist;
    while !b.is_null() {
        tmp___0 = strcmp(
            (*b).name as *const libc::c_char,
            (*rr).name as *const libc::c_char,
        );
        if tmp___0 == 0 {
            if addr.s_addr != 0 {
                (*b).addr = addr;
            }
            tmp = gettime();
            (*b).eol = tmp.wrapping_add((*rr).ttl);
            return;
        }
        b = (*b).next;
    }
    tmp___1 = malloc(::std::mem::size_of::<alist_t>() as libc::c_ulong);
    b = tmp___1 as *mut alist_t;
    (*b).addr = addr;
    (*b).name = strdup((*rr).name as *const libc::c_char);
    tmp___2 = gettime();
    (*b).eol = tmp___2.wrapping_add((*rr).ttl);
    insert_item(
        b as *mut item_t,
        &mut (*context).alist as *mut *mut alist_t as *mut *mut item_t,
    );
}
unsafe extern "C" fn create_s(
    mut host: in_addr,
    mut name: *mut libc::c_char,
    mut list: *mut *mut slist_t,
) -> *mut slist_t {
    let mut s: *mut slist_t = 0 as *mut slist_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<slist_t>() as libc::c_ulong,
    );
    s = tmp as *mut slist_t;
    (*s).name = strdup(name as *const libc::c_char);
    (*s).host = host;
    insert_item(s as *mut item_t, list as *mut *mut item_t);
    return s;
}
unsafe extern "C" fn store_other(
    mut host: in_addr,
    mut context: *mut context_s,
    mut message: *mut libc::c_char,
    mut rr: *mut mDNSResourceRecord,
) {
    let mut b: *mut slist_t = 0 as *mut slist_t;
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut now: uint32_t = 0;
    let mut ttl: uint32_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut port: libc::c_ushort = 0;
    let mut hostname: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut txt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut length: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: libc::c_int = 0;
    b = 0 as *mut libc::c_void as *mut slist_t;
    name = 0 as *mut libc::c_void as *mut libc::c_char;
    if (*rr).type_0 as libc::c_int == 12 as libc::c_int {
        tmp = strcmp(
            (*rr).name as *const libc::c_char,
            (*context).query as *const libc::c_char,
        );
        if tmp != 0 {
            return;
        }
    }
    tmp___0 = strstr(
        (*rr).name as *const libc::c_char,
        (*context).query as *const libc::c_char,
    );
    if tmp___0.is_null() {
        return;
    }
    now = gettime();
    if (*context).ttl != 0 {
        if (*context).ttl < (*rr).ttl {
            ttl = (*context).ttl;
        } else {
            ttl = (*rr).ttl;
        }
    } else {
        ttl = (*rr).ttl;
    }
    match (*rr).type_0 as libc::c_int {
        12 => {
            mdns_parse_rr_ptr(message, (*rr).rdata as *mut libc::c_char, &mut name);
            b = (*context).slist;
            while !b.is_null() {
                tmp___1 = strcmp(
                    (*b).name as *const libc::c_char,
                    name as *const libc::c_char,
                );
                if tmp___1 == 0 {
                    if !((*b).host.s_addr != host.s_addr) {
                        break;
                    }
                }
                b = (*b).next;
            }
            if b.is_null() {
                if (*rr).ttl != 0 {
                    b = create_s(host, name, &mut (*context).slist);
                }
            }
            if !b.is_null() {
                (*b).eol[0 as libc::c_int as usize] = now.wrapping_add(ttl);
            }
            free(name as *mut libc::c_void);
        }
        33 => {
            hostname = 0 as *mut libc::c_void as *mut libc::c_char;
            mdns_parse_rr_srv(
                message,
                (*rr).rdata as *mut libc::c_char,
                &mut hostname,
                &mut port,
            );
            b = (*context).slist;
            while !b.is_null() {
                tmp___2 = strcmp(
                    (*b).name as *const libc::c_char,
                    (*rr).name as *const libc::c_char,
                );
                if tmp___2 == 0 {
                    if !((*b).host.s_addr != host.s_addr) {
                        break;
                    }
                }
                b = (*b).next;
            }
            if b.is_null() {
                if (*rr).ttl != 0 {
                    b = create_s(host, (*rr).name, &mut (*context).slist);
                }
            }
            if !b.is_null() {
                if port != 0 {
                    if (*b).port as libc::c_int != port as libc::c_int {
                        (*b).port = port;
                        (*b).status = MDNS_UPDATED;
                    }
                }
                let mut current_block_56: u64;
                if ((*b).hostname).is_null() {
                    current_block_56 = 15021839376248158694;
                } else {
                    tmp___3 = strcmp(
                        (*b).hostname as *const libc::c_char,
                        hostname as *const libc::c_char,
                    );
                    if tmp___3 != 0 {
                        current_block_56 = 15021839376248158694;
                    } else {
                        current_block_56 = 18038362259723567392;
                    }
                }
                match current_block_56 {
                    15021839376248158694 => {
                        if !((*b).hostname).is_null() {
                            free((*b).hostname as *mut libc::c_void);
                        }
                        (*b).status = MDNS_UPDATED;
                        (*b).hostname = strdup(hostname as *const libc::c_char);
                    }
                    _ => {}
                }
                (*b).eol[1 as libc::c_int as usize] = now.wrapping_add(ttl);
            }
            free(hostname as *mut libc::c_void);
        }
        16 => {
            txt = 0 as *mut libc::c_void as *mut libc::c_char;
            length = 0 as libc::c_int;
            mdns_parse_rr_txt(message, rr, &mut txt, &mut length);
            b = (*context).slist;
            while !b.is_null() {
                tmp___4 = strcmp(
                    (*b).name as *const libc::c_char,
                    (*rr).name as *const libc::c_char,
                );
                if tmp___4 == 0 {
                    if !((*b).host.s_addr != host.s_addr) {
                        break;
                    }
                }
                b = (*b).next;
            }
            if b.is_null() {
                if (*rr).ttl != 0 {
                    b = create_s(host, (*rr).name, &mut (*context).slist);
                }
            }
            if !b.is_null() {
                let mut current_block_82: u64;
                if ((*b).txt).is_null() {
                    current_block_82 = 5343102677472960212;
                } else {
                    tmp___6 = memcmp(
                        (*b).txt as *const libc::c_void,
                        txt as *const libc::c_void,
                        length as size_t,
                    );
                    if tmp___6 != 0 {
                        current_block_82 = 5343102677472960212;
                    } else {
                        current_block_82 = 13349765058737954042;
                    }
                }
                match current_block_82 {
                    5343102677472960212 => {
                        if !((*b).txt).is_null() {
                            free((*b).txt as *mut libc::c_void);
                        }
                        tmp___5 = malloc(length as size_t);
                        (*b).txt = tmp___5 as *mut libc::c_char;
                        (*b).txt_length = length;
                        memcpy(
                            (*b).txt as *mut libc::c_void,
                            txt as *const libc::c_void,
                            length as size_t,
                        );
                        (*b).status = MDNS_UPDATED;
                    }
                    _ => {}
                }
                (*b).eol[2 as libc::c_int as usize] = now.wrapping_add(ttl);
            }
            free(txt as *mut libc::c_void);
        }
        _ => {}
    }
    if !b.is_null() {
        if (*rr).ttl != 0 {
            (*b).seen = now;
        }
    }
}
unsafe extern "C" fn build_update(
    mut context: *mut context_s,
    mut build: bool,
) -> *mut mDNSservice_t {
    let mut current_block: u64;
    let mut services: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut now: uint32_t = 0;
    let mut tmp: uint32_t = 0;
    let mut a: *mut alist_t = 0 as *mut alist_t;
    let mut s: *mut slist_t = 0 as *mut slist_t;
    let mut next: *mut alist_t = 0 as *mut alist_t;
    let mut next___0: *mut slist_t = 0 as *mut slist_t;
    let mut ptr_expired: bool = false;
    let mut srv_expired: bool = false;
    let mut txt_expired: bool = false;
    let mut a_expired: bool = false;
    let mut tmp___0: libc::c_int = 0;
    let mut p: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    let mut p___0: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: libc::c_int = 0;
    services = 0 as *mut libc::c_void as *mut mDNSservice_t;
    tmp = gettime();
    now = tmp;
    a = (*context).alist;
    while !a.is_null() {
        next = (*a).next;
        if ((*a).eol).wrapping_sub(now) > 2147483647 as libc::c_uint {
            remove_item___0(
                a as *mut item_t,
                &mut (*context).alist as *mut *mut alist_t as *mut *mut item_t,
            );
            free_a(a);
        }
        a = next;
    }
    s = (*context).slist;
    while !s.is_null() {
        next___0 = (*s).next;
        a_expired = 1 as libc::c_int != 0;
        if !((*s).hostname).is_null() {
            if (*s).port != 0 {
                if !((*s).txt).is_null() {
                    a = (*context).alist;
                    while !a.is_null() {
                        tmp___0 = strcmp(
                            (*s).hostname as *const libc::c_char,
                            (*a).name as *const libc::c_char,
                        );
                        if tmp___0 != 0 {
                            a = (*a).next;
                        } else {
                            if (*s).addr.s_addr != (*a).addr.s_addr {
                                (*s).addr.s_addr = (*a).addr.s_addr;
                                (*s).status = MDNS_UPDATED;
                            }
                            a_expired = 0 as libc::c_int != 0;
                            break;
                        }
                    }
                }
            }
        }
        ptr_expired = ((*s).eol[0 as libc::c_int as usize]).wrapping_sub(now)
            > 2147483647 as libc::c_uint;
        srv_expired = ((*s).eol[1 as libc::c_int as usize]).wrapping_sub(now)
            > 2147483647 as libc::c_uint;
        txt_expired = ((*s).eol[2 as libc::c_int as usize]).wrapping_sub(now)
            > 2147483647 as libc::c_uint;
        if ptr_expired {
            current_block = 4772298819019237972;
        } else if srv_expired {
            current_block = 4772298819019237972;
        } else if txt_expired {
            current_block = 4772298819019237972;
        } else if a_expired {
            current_block = 4772298819019237972;
        } else {
            current_block = 2516253395664191498;
        }
        match current_block {
            4772298819019237972 => {
                if build {
                    tmp___2 = is_complete(s);
                    if tmp___2 != 0 {
                        tmp___1 = malloc(
                            ::std::mem::size_of::<mDNSservice_t>() as libc::c_ulong,
                        );
                        p = tmp___1 as *mut mDNSservice_t;
                        (*p).host = (*s).host;
                        (*p).name = strdup((*s).name as *const libc::c_char);
                        (*p).hostname = strdup((*s).hostname as *const libc::c_char);
                        (*p).addr = (*s).addr;
                        (*p).port = (*s).port;
                        (*p).since = now.wrapping_sub((*s).seen);
                        (*p).expired = 1 as libc::c_int != 0;
                        mdns_parse_txt((*s).txt, (*s).txt_length, p);
                        insert_item(
                            p as *mut item_t,
                            &mut services as *mut *mut mDNSservice_t as *mut *mut item_t,
                        );
                    }
                }
            }
            _ => {}
        }
        if build {
            tmp___4 = is_complete(s);
            if tmp___4 != 0 {
                if (*s).status as libc::c_uint != 0 as libc::c_uint {
                    tmp___3 = malloc(
                        ::std::mem::size_of::<mDNSservice_t>() as libc::c_ulong,
                    );
                    p___0 = tmp___3 as *mut mDNSservice_t;
                    (*p___0).host = (*s).host;
                    (*p___0).name = strdup((*s).name as *const libc::c_char);
                    (*p___0).hostname = strdup((*s).hostname as *const libc::c_char);
                    (*p___0).addr = (*s).addr;
                    (*p___0).port = (*s).port;
                    (*p___0).since = now.wrapping_sub((*s).seen);
                    (*p___0).expired = 0 as libc::c_int != 0;
                    mdns_parse_txt((*s).txt, (*s).txt_length, p___0);
                    insert_item(
                        p___0 as *mut item_t,
                        &mut services as *mut *mut mDNSservice_t as *mut *mut item_t,
                    );
                    (*s).status = MDNS_CURRENT;
                }
            }
        }
        if ptr_expired {
            if srv_expired {
                if txt_expired {
                    remove_item___0(
                        s as *mut item_t,
                        &mut (*context).slist as *mut *mut slist_t as *mut *mut item_t,
                    );
                    free_s(s);
                    current_block = 6040267449472925966;
                } else {
                    current_block = 8925070654090734786;
                }
            } else {
                current_block = 8925070654090734786;
            }
        } else {
            current_block = 8925070654090734786;
        }
        match current_block {
            8925070654090734786 => {
                if ptr_expired {
                    if (*s).eol[0 as libc::c_int as usize] != 0 {
                        (*s)
                            .eol[0 as libc::c_int
                            as usize] = 0 as libc::c_int as uint32_t;
                        (*s).status = MDNS_EXPIRED;
                    }
                }
                if srv_expired {
                    if (*s).eol[1 as libc::c_int as usize] != 0 {
                        (*s)
                            .eol[1 as libc::c_int
                            as usize] = 0 as libc::c_int as uint32_t;
                        if !((*s).hostname).is_null() {
                            free((*s).hostname as *mut libc::c_void);
                        }
                        (*s).port = 0 as libc::c_int as uint16_t;
                        (*s).hostname = 0 as *mut libc::c_void as *mut libc::c_char;
                        (*s).status = MDNS_EXPIRED;
                    }
                }
                if txt_expired {
                    if (*s).eol[2 as libc::c_int as usize] != 0 {
                        (*s)
                            .eol[2 as libc::c_int
                            as usize] = 0 as libc::c_int as uint32_t;
                        if !((*s).txt).is_null() {
                            free((*s).txt as *mut libc::c_void);
                        }
                        (*s).txt_length = 0 as libc::c_int;
                        (*s).txt = 0 as *mut libc::c_void as *mut libc::c_char;
                        (*s).status = MDNS_EXPIRED;
                    }
                }
                if a_expired {
                    (*s).addr.s_addr = 0 as libc::c_int as in_addr_t;
                    (*s).status = MDNS_EXPIRED;
                }
            }
            _ => {}
        }
        s = next___0;
    }
    return services;
}
pub unsafe extern "C" fn init_mDNS(
    mut dbg: libc::c_int,
    mut host: in_addr,
) -> *mut mDNShandle_s {
    let mut sock: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut mreq: ip_mreq = ip_mreq {
        imr_multiaddr: in_addr { s_addr: 0 },
        imr_interface: in_addr { s_addr: 0 },
    };
    let mut addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut addrlen: socklen_t = 0;
    let mut enable: libc::c_int = 0;
    let mut param: libc::c_char = 0;
    let mut handle: *mut mDNShandle_t = 0 as *mut mDNShandle_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: uint32_t = 0;
    enable = 1 as libc::c_int;
    debug_mode = dbg;
    debug(b"Opening socket\n\0" as *const u8 as *const libc::c_char);
    sock = socket(2 as libc::c_int, 2 as libc::c_int, 0 as libc::c_int);
    if sock < 0 as libc::c_int {
        debug(b"error opening socket\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    param = 32 as libc::c_int as libc::c_char;
    tmp = setsockopt(
        sock,
        0 as libc::c_int,
        33 as libc::c_int,
        &mut param as *mut libc::c_char as *mut libc::c_void as *const libc::c_void,
        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong as socklen_t,
    );
    if tmp < 0 as libc::c_int {
        printf(b"error setting multicast TTL\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    tmp___0 = setsockopt(
        sock,
        1 as libc::c_int,
        2 as libc::c_int,
        &mut enable as *mut libc::c_int as *mut libc::c_void as *const libc::c_void,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
    if tmp___0 < 0 as libc::c_int {
        debug(b"error setting reuseaddr\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    param = 1 as libc::c_int as libc::c_char;
    tmp___1 = setsockopt(
        sock,
        0 as libc::c_int,
        34 as libc::c_int,
        &mut param as *mut libc::c_char as *mut libc::c_void as *const libc::c_void,
        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong as socklen_t,
    );
    if tmp___1 < 0 as libc::c_int {
        debug(b"error seeting multicast_loop\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    enable = ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int;
    tmp___3 = getsockopt(
        sock,
        1 as libc::c_int,
        15 as libc::c_int,
        &mut enable as *mut libc::c_int as *mut libc::c_void,
        &mut enable as *mut libc::c_int as *mut libc::c_void as *mut socklen_t,
    );
    if tmp___3 == 0 {
        enable = 1 as libc::c_int;
        tmp___2 = setsockopt(
            sock,
            1 as libc::c_int,
            15 as libc::c_int,
            &mut enable as *mut libc::c_int as *mut libc::c_void as *const libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
        );
        if tmp___2 < 0 as libc::c_int {
            debug(b"error setting reuseport\0" as *const u8 as *const libc::c_char);
        }
    }
    memset(
        &mut addr as *mut sockaddr_in as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    addr.sin_family = 2 as libc::c_int as sa_family_t;
    addr.sin_port = __bswap_16(5353 as libc::c_int as __uint16_t);
    addr.sin_addr.s_addr = 0 as libc::c_int as in_addr_t;
    addrlen = ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
    res = bind(
        sock,
        &mut addr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        addrlen,
    );
    if res < 0 as libc::c_int {
        debug(b"error binding socket\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    memset(
        &mut mreq as *mut ip_mreq as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ip_mreq>() as libc::c_ulong,
    );
    mreq
        .imr_multiaddr
        .s_addr = inet_addr(b"224.0.0.251\0" as *const u8 as *const libc::c_char);
    mreq.imr_interface.s_addr = host.s_addr;
    tmp___4 = setsockopt(
        sock,
        0 as libc::c_int,
        32 as libc::c_int,
        &mut mreq.imr_interface.s_addr as *mut in_addr_t as *mut libc::c_void
            as *const libc::c_void,
        ::std::mem::size_of::<in_addr_t>() as libc::c_ulong as socklen_t,
    );
    if tmp___4 < 0 as libc::c_int {
        debug(b"bound to if failed\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    debug(
        b"Setting socket options for multicast\n\0" as *const u8 as *const libc::c_char,
    );
    tmp___5 = setsockopt(
        sock,
        0 as libc::c_int,
        35 as libc::c_int,
        &mut mreq as *mut ip_mreq as *mut libc::c_void as *const libc::c_void,
        ::std::mem::size_of::<ip_mreq>() as libc::c_ulong as socklen_t,
    );
    if tmp___5 < 0 as libc::c_int {
        debug(b"setsockopt failed\0" as *const u8 as *const libc::c_char);
        return 0 as *mut libc::c_void as *mut mDNShandle_s;
    }
    tmp___6 = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<mDNShandle_t>() as libc::c_ulong,
    );
    handle = tmp___6 as *mut mDNShandle_t;
    (*handle).sock = sock;
    (*handle).state = MDNS_IDLE;
    tmp___7 = gettime();
    (*handle).last = tmp___7.wrapping_sub(3600 as libc::c_uint);
    return handle;
}
pub unsafe extern "C" fn control_mDNS(
    mut handle: *mut mDNShandle_s,
    mut request: mDNScontrol_e,
) {
    if handle.is_null() {
        return;
    }
    if (*handle).state as libc::c_uint == 1 as libc::c_uint {
        (*handle).control = request;
    } else if request as libc::c_uint == 1 as libc::c_uint {
        clear_context(&mut (*handle).context);
    }
}
pub unsafe extern "C" fn close_mDNS(mut handle: *mut mDNShandle_s) {
    if handle.is_null() {
        return;
    }
    if (*handle).state as libc::c_uint == 0 as libc::c_uint {
        clear_context(&mut (*handle).context);
        close((*handle).sock);
        (*handle).sock = -(1 as libc::c_int);
        free(handle as *mut libc::c_void);
    } else {
        (*handle).state = MDNS_IDLE;
    };
}
unsafe extern "C" fn clear_context(mut context: *mut context_s) {
    clear_list___0(
        (*context).alist as *mut libc::c_void as *mut item_t,
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut alist_t) -> ()>,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(Some(free_a as unsafe extern "C" fn(*mut alist_t) -> ())),
    );
    clear_list___0(
        (*context).slist as *mut libc::c_void as *mut item_t,
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut slist_t) -> ()>,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(Some(free_s as unsafe extern "C" fn(*mut slist_t) -> ())),
    );
    (*context).slist = 0 as *mut libc::c_void as *mut slist_t;
    (*context).alist = 0 as *mut libc::c_void as *mut alist_t;
}
unsafe extern "C" fn free_item_mDNS(mut slist: *mut mDNSservice_t) {
    let mut i: libc::c_int = 0;
    free((*slist).name as *mut libc::c_void);
    free((*slist).hostname as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*slist).attr_count {
        if !((*((*slist).attr).offset(i as isize)).name).is_null() {
            free((*((*slist).attr).offset(i as isize)).name as *mut libc::c_void);
        }
        if !((*((*slist).attr).offset(i as isize)).value).is_null() {
            free((*((*slist).attr).offset(i as isize)).value as *mut libc::c_void);
        }
        i += 1;
    }
    free((*slist).attr as *mut libc::c_void);
    free(slist as *mut libc::c_void);
}
pub unsafe extern "C" fn free_list_mDNS(mut slist: *mut mDNSservice_t) {
    clear_list___0(
        slist as *mut libc::c_void as *mut item_t,
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mDNSservice_t) -> ()>,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(Some(free_item_mDNS as unsafe extern "C" fn(*mut mDNSservice_t) -> ())),
    );
}
pub unsafe extern "C" fn get_list_mDNS(
    mut handle: *mut mDNShandle_s,
) -> *mut mDNSservice_t {
    let mut s: *mut slist_t = 0 as *mut slist_t;
    let mut services: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut p: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    services = 0 as *mut libc::c_void as *mut mDNSservice_t;
    s = (*handle).context.slist;
    while !s.is_null() {
        tmp___0 = is_complete(s);
        if tmp___0 != 0 {
            tmp = malloc(::std::mem::size_of::<mDNSservice_t>() as libc::c_ulong);
            p = tmp as *mut mDNSservice_t;
            (*p).name = strdup((*s).name as *const libc::c_char);
            (*p).hostname = strdup((*s).hostname as *const libc::c_char);
            (*p).addr = (*s).addr;
            (*p).port = (*s).port;
            (*p).expired = 0 as libc::c_int != 0;
            mdns_parse_txt((*s).txt, (*s).txt_length, p);
            insert_item(
                s as *mut item_t,
                &mut services as *mut *mut mDNSservice_t as *mut *mut item_t,
            );
        }
        s = (*s).next;
    }
    return services;
}
pub unsafe extern "C" fn query_mDNS(
    mut handle: *mut mDNShandle_s,
    mut query: *mut libc::c_char,
    mut ttl: libc::c_int,
    mut runtime: libc::c_int,
    mut callback: Option::<mdns_callback_t>,
    mut cookie: *mut libc::c_void,
) -> bool {
    let mut addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut addrlen: socklen_t = 0;
    let mut res: libc::c_int = 0;
    let mut parsed: libc::c_int = 0;
    let mut recvdata: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut active_fd_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut read_fd_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut except_fd_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut slist: *mut mDNSservice_t = 0 as *mut mDNSservice_t;
    let mut now: uint32_t = 0;
    let mut stop: bool = false;
    let mut rc: bool = false;
    let mut tmp: uint32_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut sel_time: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp___1: ssize_t = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut resp: libc::c_int = 0;
    let mut msg: mDNSMessage = mDNSMessage {
        id: 0,
        flags: 0,
        qd_count: 0,
        an_count: 0,
        ns_count: 0,
        ar_count: 0,
        data: 0 as *mut libc::c_char,
        data_size: 0,
    };
    let mut tmp___3: bool = false;
    stop = 0 as libc::c_int != 0;
    rc = 1 as libc::c_int != 0;
    if handle.is_null() {
        return 0 as libc::c_int != 0
    } else {
        if (*handle).sock < 0 as libc::c_int {
            return 0 as libc::c_int != 0;
        }
    }
    if *query.offset(0 as libc::c_int as isize) as libc::c_int != 95 as libc::c_int {
        debug(
            b"only service queries currently supported\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as libc::c_int != 0;
    }
    if runtime != 0 {
        tmp = gettime();
        runtime = (runtime as uint32_t).wrapping_add(tmp) as libc::c_int;
    }
    addr.sin_family = 2 as libc::c_int as sa_family_t;
    addr.sin_port = __bswap_16(5353 as libc::c_int as __uint16_t);
    addr
        .sin_addr
        .s_addr = inet_addr(b"224.0.0.251\0" as *const u8 as *const libc::c_char);
    addrlen = ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
    tmp___0 = malloc(32768 as libc::c_int as size_t);
    recvdata = tmp___0 as *mut libc::c_char;
    if recvdata.is_null() {
        return 0 as libc::c_int != 0;
    }
    let fresh40 = &mut __d0;
    let fresh41;
    let fresh42 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
    let fresh43 = &mut __d1;
    let fresh44;
    let fresh45 = &mut *(active_fd_set.fds_bits)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut __fd_mask;
    asm!(
        "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh40,
        fresh42) => fresh41, inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh43,
        fresh45) => fresh44, inlateout("ax") 0 as libc::c_int => _,
        options(preserves_flags, att_syntax)
    );
    c2rust_asm_casts::AsmCast::cast_out(fresh40, fresh42, fresh41);
    c2rust_asm_casts::AsmCast::cast_out(fresh43, fresh45, fresh44);
    active_fd_set
        .fds_bits[((*handle).sock
        / (8 as libc::c_int
            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
        as usize]
        |= ((1 as libc::c_ulong)
            << (*handle).sock
                % (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as __fd_mask;
    debug(b"Entering main loop\n\0" as *const u8 as *const libc::c_char);
    (*handle).context.query = query;
    (*handle).context.ttl = ttl as uint32_t;
    (*handle).state = MDNS_RUNNING;
    loop {
        sel_time.tv_sec = 0 as libc::c_int as __time_t;
        sel_time.tv_usec = 50000 as libc::c_int as __suseconds_t;
        now = gettime();
        if ((*handle).last).wrapping_add(20 as libc::c_uint).wrapping_sub(now)
            > 2147483647 as libc::c_uint
        {
            send_query(
                (*handle).sock,
                (*handle).context.query,
                12 as libc::c_int as uint16_t,
            );
            (*handle).last = now;
        }
        read_fd_set = active_fd_set;
        except_fd_set = active_fd_set;
        res = select(
            (*handle).sock + 1 as libc::c_int,
            &mut read_fd_set as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut except_fd_set as *mut fd_set,
            &mut sel_time as *mut timeval,
        );
        if (*handle).state as libc::c_uint == 0 as libc::c_uint {
            break;
        }
        if (*handle).control as libc::c_uint == 2 as libc::c_uint {
            break;
        }
        if runtime != 0 {
            if now > runtime as uint32_t {
                break;
            }
        }
        if (*handle).control as libc::c_uint == 1 as libc::c_uint {
            clear_context(&mut (*handle).context);
            (*handle).control = MDNS_NONE;
            (*handle).last = now.wrapping_sub(3600 as libc::c_uint);
        }
        if res < 0 as libc::c_int {
            rc = 0 as libc::c_int != 0;
            debug(b"Select error\n\0" as *const u8 as *const libc::c_char);
            break;
        } else {
            if res == 0 as libc::c_int {
                continue;
            }
            if except_fd_set
                .fds_bits[((*handle).sock
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << (*handle).sock
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                rc = 0 as libc::c_int != 0;
                debug(b"exception on socket\0" as *const u8 as *const libc::c_char);
                break;
            } else {
                debug(b"Receiving data\n\0" as *const u8 as *const libc::c_char);
                tmp___1 = recvfrom(
                    (*handle).sock,
                    recvdata as *mut libc::c_void,
                    32768 as libc::c_int as size_t,
                    0 as libc::c_int,
                    &mut addr as *mut sockaddr_in as *mut sockaddr,
                    &mut addrlen as *mut socklen_t,
                );
                res = tmp___1 as libc::c_int;
                if res < 0 as libc::c_int {
                    rc = 0 as libc::c_int != 0;
                    debug(b"error receiving\0" as *const u8 as *const libc::c_char);
                    break;
                } else {
                    if res == 0 as libc::c_int {
                        rc = 0 as libc::c_int != 0;
                        debug(b"unknown error\0" as *const u8 as *const libc::c_char);
                    }
                    tmp___2 = inet_ntoa(addr.sin_addr);
                    debug(
                        b"Received %u bytes from %s\n\0" as *const u8
                            as *const libc::c_char,
                        res,
                        tmp___2,
                    );
                    parsed = 0 as libc::c_int;
                    debug(
                        b"Attempting to parse received data\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    loop {
                        resp = mdns_parse_message_net(
                            addr.sin_addr,
                            &mut (*handle).context,
                            recvdata.offset(parsed as isize),
                            res,
                            &mut msg,
                        );
                        if resp <= 0 as libc::c_int {
                            break;
                        }
                        parsed += resp;
                        debug(
                            b"--Parsed %u bytes of %u received bytes\n\0" as *const u8
                                as *const libc::c_char,
                            parsed,
                            res,
                        );
                        if !(parsed < res) {
                            break;
                        }
                    }
                    debug(
                        b"Finished parsing received data\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    slist = build_update(
                        &mut (*handle).context,
                        ::std::mem::transmute::<
                            Option::<mdns_callback_t>,
                            libc::c_ulong,
                        >(callback) != 0 as *mut libc::c_void as libc::c_ulong,
                    );
                    if !slist.is_null() {
                        if callback.is_some() {
                            tmp___3 = (Some(
                                callback.expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(slist, cookie, &mut stop);
                            if !tmp___3 {
                                free_list_mDNS(slist);
                            }
                        }
                    }
                    if stop {
                        break;
                    }
                }
            }
        }
    }
    free(recvdata as *mut libc::c_void);
    if (*handle).state as libc::c_uint == 0 as libc::c_uint {
        clear_context(&mut (*handle).context);
        close((*handle).sock);
        (*handle).sock = -(1 as libc::c_int);
        free(handle as *mut libc::c_void);
    } else {
        (*handle).control = MDNS_NONE;
        (*handle).state = MDNS_IDLE;
    }
    return rc;
}
#[inline]
unsafe extern "C" fn cmp_nlabel(
    mut L1: *const uint8_t,
    mut L2: *const uint8_t,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = strcmp(
        L1 as *mut libc::c_char as *const libc::c_char,
        L2 as *mut libc::c_char as *const libc::c_char,
    );
    return tmp;
}
pub unsafe extern "C" fn dup_nlabel(mut n: *const uint8_t) -> *mut uint8_t {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = strdup(n as *mut libc::c_char as *const libc::c_char);
    return tmp as *mut uint8_t;
}
pub unsafe extern "C" fn dup_label(mut label: *const uint8_t) -> *mut uint8_t {
    let mut len: libc::c_int = 0;
    let mut newlabel: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    len = *label as libc::c_int + 1 as libc::c_int;
    if len > 63 as libc::c_int {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    tmp = malloc((len + 1 as libc::c_int) as size_t);
    newlabel = tmp as *mut uint8_t;
    strncpy(
        newlabel as *mut libc::c_char,
        label as *mut libc::c_char as *const libc::c_char,
        len as size_t,
    );
    *newlabel.offset(len as isize) = '\u{0}' as i32 as uint8_t;
    return newlabel;
}
pub unsafe extern "C" fn join_nlabel(
    mut n1: *const uint8_t,
    mut n2: *const uint8_t,
) -> *mut uint8_t {
    let mut len1: libc::c_int = 0;
    let mut len2: libc::c_int = 0;
    let mut s: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(n1 as *mut libc::c_char as *const libc::c_char);
    len1 = tmp as libc::c_int;
    tmp___0 = strlen(n2 as *mut libc::c_char as *const libc::c_char);
    len2 = tmp___0 as libc::c_int;
    tmp___1 = malloc((len1 + len2 + 1 as libc::c_int) as size_t);
    s = tmp___1 as *mut uint8_t;
    strncpy(
        s as *mut libc::c_char,
        n1 as *mut libc::c_char as *const libc::c_char,
        len1 as size_t,
    );
    strncpy(
        (s as *mut libc::c_char).offset(len1 as isize),
        n2 as *mut libc::c_char as *const libc::c_char,
        len2 as size_t,
    );
    *s.offset((len1 + len2) as isize) = '\u{0}' as i32 as uint8_t;
    return s;
}
pub unsafe extern "C" fn nlabel_to_str(mut name: *const uint8_t) -> *mut libc::c_char {
    let mut label: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut labelp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut buf_len: size_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut label_len___0: uint8_t = 0;
    buf_len = 256 as libc::c_int as size_t;
    tmp = malloc(buf_len);
    labelp = tmp as *mut libc::c_char;
    label = labelp;
    p = name;
    while *p != 0 {
        label_len___0 = *p;
        if buf_len <= label_len___0 as size_t {
            break;
        }
        strncpy(
            labelp,
            (p as *mut libc::c_char).offset(1 as libc::c_int as isize)
                as *const libc::c_char,
            label_len___0 as size_t,
        );
        labelp = labelp.offset(label_len___0 as libc::c_int as isize);
        *labelp = '.' as i32 as libc::c_char;
        labelp = labelp.offset(1);
        buf_len = (buf_len as libc::c_ulong)
            .wrapping_sub((label_len___0 as libc::c_int + 1 as libc::c_int) as size_t)
            as size_t as size_t;
        p = p.offset(label_len___0 as libc::c_int as isize);
        p = p.offset(1);
    }
    if buf_len == 0 as libc::c_ulong {
        labelp = labelp.offset(-1);
    }
    *labelp = '\u{0}' as i32 as libc::c_char;
    return label;
}
unsafe extern "C" fn label_len(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
) -> size_t {
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut e: *mut uint8_t = 0 as *mut uint8_t;
    let mut len: size_t = 0;
    e = pkt_buf.offset(pkt_len as isize);
    len = 0 as libc::c_int as size_t;
    p = pkt_buf.offset(off as isize);
    while (p as libc::c_ulong) < e as libc::c_ulong {
        if *p as libc::c_int == 0 as libc::c_int {
            return len.wrapping_add(1 as libc::c_ulong)
        } else {
            if *p as libc::c_int & 192 as libc::c_int == 192 as libc::c_int {
                return len.wrapping_add(2 as libc::c_ulong)
            } else {
                len = (len as libc::c_ulong)
                    .wrapping_add((*p as libc::c_int + 1 as libc::c_int) as size_t)
                    as size_t as size_t;
                p = p.offset(*p as libc::c_int as isize);
            }
        }
        p = p.offset(1);
    }
    return len;
}
pub unsafe extern "C" fn create_label(mut txt: *const libc::c_char) -> *mut uint8_t {
    let mut len: libc::c_int = 0;
    let mut s: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(txt);
    len = tmp as libc::c_int;
    if len > 63 as libc::c_int {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    tmp___0 = malloc((len + 2 as libc::c_int) as size_t);
    s = tmp___0 as *mut uint8_t;
    *s.offset(0 as libc::c_int as isize) = len as uint8_t;
    strncpy(
        (s as *mut libc::c_char).offset(1 as libc::c_int as isize),
        txt,
        len as size_t,
    );
    *s.offset((len + 1 as libc::c_int) as isize) = '\u{0}' as i32 as uint8_t;
    return s;
}
pub unsafe extern "C" fn create_nlabel(mut name: *const libc::c_char) -> *mut uint8_t {
    let mut label: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut lenpos: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut dot: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    len = 0 as libc::c_int;
    tmp = strlen(name);
    len = tmp as libc::c_int;
    tmp___0 = malloc((len + 1 as libc::c_int + 1 as libc::c_int) as size_t);
    label = tmp___0 as *mut libc::c_char;
    if label as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    strncpy(label.offset(1 as libc::c_int as isize), name, len as size_t);
    *label.offset((len + 1 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char;
    p = label;
    e = p.offset(len as isize);
    lenpos = p;
    while (p as libc::c_ulong) < e as libc::c_ulong {
        tmp___1 = memchr(
            p.offset(1 as libc::c_int as isize) as *const libc::c_void,
            '.' as i32,
            (e.offset_from(p) as libc::c_long - 1 as libc::c_long) as size_t,
        );
        dot = tmp___1 as *mut libc::c_char;
        *lenpos = 0 as libc::c_int as libc::c_char;
        if dot as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            dot = e.offset(1 as libc::c_int as isize);
        }
        *lenpos = (dot.offset_from(p) as libc::c_long - 1 as libc::c_long)
            as libc::c_char;
        p = dot;
        lenpos = dot;
    }
    return label as *mut uint8_t;
}
unsafe extern "C" fn copy_label(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
) -> *mut uint8_t {
    let mut len: libc::c_int = 0;
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    if off > pkt_len {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    len = *pkt_buf.offset(off as isize) as libc::c_int + 1 as libc::c_int;
    if off.wrapping_add(len as size_t) > pkt_len {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    tmp = dup_label(pkt_buf.offset(off as isize) as *const uint8_t);
    return tmp;
}
unsafe extern "C" fn uncompress_nlabel(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
) -> *mut uint8_t {
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut e: *mut uint8_t = 0 as *mut uint8_t;
    let mut len: size_t = 0;
    let mut str___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut llen: size_t = 0;
    let mut p2: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut llen___0: size_t = 0;
    let mut p2___0: *mut uint8_t = 0 as *mut uint8_t;
    e = pkt_buf.offset(pkt_len as isize);
    len = 0 as libc::c_int as size_t;
    if off >= pkt_len {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    p = pkt_buf.offset(off as isize);
    while *p != 0 {
        if !((p as libc::c_ulong) < e as libc::c_ulong) {
            break;
        }
        llen = 0 as libc::c_int as size_t;
        if *p as libc::c_int & 192 as libc::c_int == 192 as libc::c_int {
            p2 = pkt_buf
                .offset(
                    ((*p.offset(0 as libc::c_int as isize) as libc::c_int
                        & -(193 as libc::c_int)) << 8 as libc::c_int
                        | *p.offset(1 as libc::c_int as isize) as libc::c_int) as isize,
                );
            llen = (*p2 as libc::c_int + 1 as libc::c_int) as size_t;
            p = p2.offset(llen as isize).offset(-(1 as libc::c_int as isize));
        } else {
            llen = (*p as libc::c_int + 1 as libc::c_int) as size_t;
            p = p.offset(llen.wrapping_sub(1 as libc::c_ulong) as isize);
        }
        len = (len as libc::c_ulong).wrapping_add(llen) as size_t as size_t;
        p = p.offset(1);
    }
    tmp = malloc(len.wrapping_add(1 as libc::c_ulong));
    sp = tmp as *mut libc::c_char;
    str___0 = sp;
    if str___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut uint8_t;
    }
    p = pkt_buf.offset(off as isize);
    while *p != 0 {
        if !((p as libc::c_ulong) < e as libc::c_ulong) {
            break;
        }
        llen___0 = 0 as libc::c_int as size_t;
        if *p as libc::c_int & 192 as libc::c_int == 192 as libc::c_int {
            p2___0 = pkt_buf
                .offset(
                    ((*p.offset(0 as libc::c_int as isize) as libc::c_int
                        & -(193 as libc::c_int)) << 8 as libc::c_int
                        | *p.offset(1 as libc::c_int as isize) as libc::c_int) as isize,
                );
            llen___0 = (*p2___0 as libc::c_int + 1 as libc::c_int) as size_t;
            strncpy(sp, p2___0 as *mut libc::c_char as *const libc::c_char, llen___0);
            p = p2___0.offset(llen___0 as isize).offset(-(1 as libc::c_int as isize));
        } else {
            llen___0 = (*p as libc::c_int + 1 as libc::c_int) as size_t;
            strncpy(sp, p as *mut libc::c_char as *const libc::c_char, llen___0);
            p = p.offset(llen___0.wrapping_sub(1 as libc::c_ulong) as isize);
        }
        sp = sp.offset(llen___0 as isize);
        p = p.offset(1);
    }
    *sp = '\u{0}' as i32 as libc::c_char;
    return str___0 as *mut uint8_t;
}
pub unsafe extern "C" fn rr_get_type_name(mut type_0: rr_type) -> *const libc::c_char {
    match type_0 as libc::c_uint {
        1 => return b"A\0" as *const u8 as *const libc::c_char,
        12 => return b"PTR\0" as *const u8 as *const libc::c_char,
        16 => return b"TXT\0" as *const u8 as *const libc::c_char,
        28 => return b"AAAA\0" as *const u8 as *const libc::c_char,
        33 => return b"SRV\0" as *const u8 as *const libc::c_char,
        47 => return b"NSEC\0" as *const u8 as *const libc::c_char,
        255 => return b"ANY\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    return 0 as *mut libc::c_void as *const libc::c_char;
}
pub unsafe extern "C" fn rr_entry_destroy(mut rr: *mut rr_entry) {
    let mut txt_rec: *mut rr_data_txt = 0 as *mut rr_data_txt;
    let mut next: *mut rr_data_txt = 0 as *mut rr_data_txt;
    match (*rr).type_0 as libc::c_uint {
        12 => {
            if !((*rr).data.PTR.name).is_null() {
                free((*rr).data.PTR.name as *mut libc::c_void);
            }
        }
        16 => {
            txt_rec = &mut (*rr).data.TXT;
            while !txt_rec.is_null() {
                next = (*txt_rec).next;
                if !((*txt_rec).txt).is_null() {
                    free((*txt_rec).txt as *mut libc::c_void);
                }
                if txt_rec as libc::c_ulong
                    != &mut (*rr).data.TXT as *mut rr_data_txt as libc::c_ulong
                {
                    free(txt_rec as *mut libc::c_void);
                }
                txt_rec = next;
            }
        }
        33 => {
            if !((*rr).data.SRV.target).is_null() {
                free((*rr).data.SRV.target as *mut libc::c_void);
            }
        }
        28 => {
            if !((*rr).data.AAAA.addr).is_null() {
                free((*rr).data.AAAA.addr as *mut libc::c_void);
            }
        }
        _ => {}
    }
    free((*rr).name as *mut libc::c_void);
    free(rr as *mut libc::c_void);
}
pub unsafe extern "C" fn rr_list_destroy(
    mut rr: *mut rr_list,
    mut destroy_items: libc::c_char,
) {
    let mut rr_next: *mut rr_list = 0 as *mut rr_list;
    while !rr.is_null() {
        rr_next = (*rr).next;
        if destroy_items != 0 {
            rr_entry_destroy((*rr).e);
        }
        free(rr as *mut libc::c_void);
        rr = rr_next;
    }
}
pub unsafe extern "C" fn rr_list_count(mut rr: *mut rr_list) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !rr.is_null() {
        i += 1;
        rr = (*rr).next;
    }
    return i;
}
pub unsafe extern "C" fn rr_entry_remove(
    mut group: *mut rr_group,
    mut entry: *mut rr_entry,
    mut type_0: rr_type,
) -> *mut rr_entry {
    let mut g: *mut rr_group = 0 as *mut rr_group;
    let mut lrr: *mut rr_list = 0 as *mut rr_list;
    let mut prr: *mut rr_list = 0 as *mut rr_list;
    let mut e: *mut rr_entry = 0 as *mut rr_entry;
    g = group;
    while !g.is_null() {
        lrr = (*g).rr;
        prr = 0 as *mut libc::c_void as *mut rr_list;
        while !lrr.is_null() {
            if (*(*lrr).e).type_0 as libc::c_uint == type_0 as libc::c_uint {
                match type_0 as libc::c_uint {
                    12 => {
                        if (*(*lrr).e).data.PTR.entry as libc::c_ulong
                            == entry as libc::c_ulong
                        {
                            e = (*lrr).e;
                            if prr as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                (*g).rr = (*lrr).next;
                            } else {
                                (*prr).next = (*lrr).next;
                            }
                            free(lrr as *mut libc::c_void);
                            return e;
                        }
                    }
                    _ => {}
                }
            }
            prr = lrr;
            lrr = (*lrr).next;
        }
        g = (*g).next;
    }
    return 0 as *mut libc::c_void as *mut rr_entry;
}
pub unsafe extern "C" fn rr_list_remove(
    mut rr_head: *mut *mut rr_list,
    mut rr: *mut rr_entry,
) -> *mut rr_entry {
    let mut le: *mut rr_list = 0 as *mut rr_list;
    let mut pe: *mut rr_list = 0 as *mut rr_list;
    le = *rr_head;
    pe = 0 as *mut libc::c_void as *mut rr_list;
    while !le.is_null() {
        if (*le).e as libc::c_ulong == rr as libc::c_ulong {
            if pe as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                *rr_head = (*le).next;
                free(le as *mut libc::c_void);
                return rr;
            } else {
                (*pe).next = (*le).next;
                free(le as *mut libc::c_void);
                return rr;
            }
        }
        pe = le;
        le = (*le).next;
    }
    return 0 as *mut libc::c_void as *mut rr_entry;
}
pub unsafe extern "C" fn rr_group_clean(mut head: *mut *mut rr_group) {
    let mut le: *mut rr_group = 0 as *mut rr_group;
    let mut pe: *mut rr_group = 0 as *mut rr_group;
    le = *head;
    pe = 0 as *mut libc::c_void as *mut rr_group;
    while !le.is_null() {
        if (*le).rr as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            free((*le).name as *mut libc::c_void);
            if pe as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                *head = (*le).next;
                free(le as *mut libc::c_void);
                le = *head;
            } else {
                (*pe).next = (*le).next;
                free(le as *mut libc::c_void);
                le = (*pe).next;
            }
        } else {
            pe = le;
            le = (*le).next;
        }
    }
}
pub unsafe extern "C" fn rr_list_append(
    mut rr_head: *mut *mut rr_list,
    mut rr: *mut rr_entry,
) -> libc::c_int {
    let mut node: *mut rr_list = 0 as *mut rr_list;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut e: *mut rr_list = 0 as *mut rr_list;
    let mut taile: *mut rr_list = 0 as *mut rr_list;
    tmp = malloc(::std::mem::size_of::<rr_list>() as libc::c_ulong);
    node = tmp as *mut rr_list;
    (*node).e = rr;
    (*node).next = 0 as *mut libc::c_void as *mut rr_list;
    if *rr_head as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        *rr_head = node;
    } else {
        e = *rr_head;
        while !e.is_null() {
            if (*e).e as libc::c_ulong == rr as libc::c_ulong {
                free(node as *mut libc::c_void);
                return 0 as libc::c_int;
            }
            if (*e).next as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                taile = e;
            }
            e = (*e).next;
        }
        (*taile).next = node;
    }
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn rr_create_a(
    mut name: *mut uint8_t,
    mut addr: in_addr,
) -> *mut rr_entry {
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    (*rr).name = name;
    (*rr).type_0 = RR_A;
    (*rr).ttl = 4500 as libc::c_int as uint32_t;
    (*rr).cache_flush = 1 as libc::c_int as libc::c_char;
    (*rr).rr_class = 1 as libc::c_int as uint16_t;
    (*rr).data.A.addr = addr.s_addr;
    (*rr).ttl = 120 as libc::c_int as uint32_t;
    return rr;
}
pub unsafe extern "C" fn rr_create_aaaa(
    mut name: *mut uint8_t,
    mut addr: *mut in6_addr,
) -> *mut rr_entry {
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    (*rr).name = name;
    (*rr).type_0 = RR_AAAA;
    (*rr).ttl = 4500 as libc::c_int as uint32_t;
    (*rr).cache_flush = 1 as libc::c_int as libc::c_char;
    (*rr).rr_class = 1 as libc::c_int as uint16_t;
    (*rr).data.AAAA.addr = addr;
    (*rr).ttl = 120 as libc::c_int as uint32_t;
    return rr;
}
pub unsafe extern "C" fn rr_create_srv(
    mut name: *mut uint8_t,
    mut port: uint16_t,
    mut target: *mut uint8_t,
) -> *mut rr_entry {
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    (*rr).name = name;
    (*rr).type_0 = RR_SRV;
    (*rr).ttl = 4500 as libc::c_int as uint32_t;
    (*rr).cache_flush = 1 as libc::c_int as libc::c_char;
    (*rr).rr_class = 1 as libc::c_int as uint16_t;
    (*rr).data.SRV.port = port;
    (*rr).data.SRV.target = target;
    (*rr).ttl = 120 as libc::c_int as uint32_t;
    return rr;
}
pub unsafe extern "C" fn rr_create_ptr(
    mut name: *mut uint8_t,
    mut d_rr: *mut rr_entry,
) -> *mut rr_entry {
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    (*rr).name = name;
    (*rr).type_0 = RR_PTR;
    (*rr).ttl = 4500 as libc::c_int as uint32_t;
    (*rr).cache_flush = 1 as libc::c_int as libc::c_char;
    (*rr).rr_class = 1 as libc::c_int as uint16_t;
    (*rr).cache_flush = 0 as libc::c_int as libc::c_char;
    (*rr).data.PTR.entry = d_rr;
    (*rr).ttl = 120 as libc::c_int as uint32_t;
    return rr;
}
pub unsafe extern "C" fn rr_create(
    mut name: *mut uint8_t,
    mut type_0: rr_type,
) -> *mut rr_entry {
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    (*rr).name = name;
    (*rr).type_0 = type_0;
    (*rr).ttl = 4500 as libc::c_int as uint32_t;
    (*rr).cache_flush = 1 as libc::c_int as libc::c_char;
    (*rr).rr_class = 1 as libc::c_int as uint16_t;
    return rr;
}
pub unsafe extern "C" fn rr_set_nsec(mut rr_nsec: *mut rr_entry, mut type_0: rr_type) {
    (*rr_nsec)
        .data
        .NSEC
        .bitmap[(type_0 as libc::c_uint).wrapping_div(8 as libc::c_uint)
        as usize] = ((1 as libc::c_int)
        << (7 as libc::c_uint)
            .wrapping_sub((type_0 as libc::c_uint).wrapping_rem(8 as libc::c_uint)))
        as uint8_t;
}
pub unsafe extern "C" fn rr_add_txt(
    mut rr_txt: *mut rr_entry,
    mut txt: *const libc::c_char,
) {
    let mut txt_rec: *mut rr_data_txt = 0 as *mut rr_data_txt;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    txt_rec = &mut (*rr_txt).data.TXT;
    if (*txt_rec).txt as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*txt_rec).txt = create_label(txt);
        return;
    }
    while !((*txt_rec).next).is_null() {
        txt_rec = (*txt_rec).next;
    }
    tmp = malloc(::std::mem::size_of::<rr_data_txt>() as libc::c_ulong);
    (*txt_rec).next = tmp as *mut rr_data_txt;
    txt_rec = (*txt_rec).next;
    (*txt_rec).txt = create_label(txt);
    (*txt_rec).next = 0 as *mut libc::c_void as *mut rr_data_txt;
}
pub unsafe extern "C" fn rr_group_add(
    mut group: *mut *mut rr_group,
    mut rr: *mut rr_entry,
) {
    let mut g: *mut rr_group = 0 as *mut rr_group;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if !(*group).is_null() {
        g = rr_group_find(*group, (*rr).name);
        if !g.is_null() {
            rr_list_append(&mut (*g).rr, rr);
            return;
        }
    }
    tmp = malloc(::std::mem::size_of::<rr_group>() as libc::c_ulong);
    g = tmp as *mut rr_group;
    memset(
        g as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_group>() as libc::c_ulong,
    );
    (*g).name = dup_nlabel((*rr).name as *const uint8_t);
    rr_list_append(&mut (*g).rr, rr);
    (*g).next = *group;
    *group = g;
}
pub unsafe extern "C" fn rr_group_find(
    mut g: *mut rr_group,
    mut name: *mut uint8_t,
) -> *mut rr_group {
    let mut tmp: libc::c_int = 0;
    while !g.is_null() {
        tmp = cmp_nlabel((*g).name as *const uint8_t, name as *const uint8_t);
        if tmp == 0 as libc::c_int {
            return g;
        }
        g = (*g).next;
    }
    return 0 as *mut libc::c_void as *mut rr_group;
}
pub unsafe extern "C" fn rr_entry_find(
    mut rr_list: *mut rr_list,
    mut name: *mut uint8_t,
    mut type_0: uint16_t,
) -> *mut rr_entry {
    let mut rr: *mut rr_list = 0 as *mut rr_list;
    let mut tmp: libc::c_int = 0;
    rr = rr_list;
    while !rr.is_null() {
        if (*(*rr).e).type_0 as libc::c_uint == type_0 as libc::c_uint {
            tmp = cmp_nlabel((*(*rr).e).name as *const uint8_t, name as *const uint8_t);
            if tmp == 0 as libc::c_int {
                return (*rr).e;
            }
        }
        rr = (*rr).next;
    }
    return 0 as *mut libc::c_void as *mut rr_entry;
}
pub unsafe extern "C" fn rr_entry_match(
    mut rr_list: *mut rr_list,
    mut entry: *mut rr_entry,
) -> *mut rr_entry {
    let mut rr: *mut rr_list = 0 as *mut rr_list;
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    rr = rr_list;
    while !rr.is_null() {
        if (*(*rr).e).type_0 as libc::c_uint == (*entry).type_0 as libc::c_uint {
            tmp___2 = cmp_nlabel(
                (*(*rr).e).name as *const uint8_t,
                (*entry).name as *const uint8_t,
            );
            if tmp___2 == 0 as libc::c_int {
                if (*entry).type_0 as libc::c_uint != 12 as libc::c_uint {
                    return (*rr).e
                } else {
                    if (*(*rr).e).data.PTR.name as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        tmp = (*(*rr).e).data.PTR.name;
                    } else {
                        tmp = (*(*(*rr).e).data.PTR.entry).name;
                    }
                    if (*entry).data.PTR.name as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        tmp___0 = (*entry).data.PTR.name;
                    } else {
                        tmp___0 = (*(*entry).data.PTR.entry).name;
                    }
                    tmp___1 = cmp_nlabel(
                        tmp___0 as *const uint8_t,
                        tmp as *const uint8_t,
                    );
                    if tmp___1 == 0 as libc::c_int {
                        return (*rr).e;
                    }
                }
            }
        }
        rr = (*rr).next;
    }
    return 0 as *mut libc::c_void as *mut rr_entry;
}
pub unsafe extern "C" fn rr_group_destroy(mut group: *mut rr_group) {
    let mut g: *mut rr_group = 0 as *mut rr_group;
    let mut nextg: *mut rr_group = 0 as *mut rr_group;
    g = group;
    while !g.is_null() {
        nextg = (*g).next;
        free((*g).name as *mut libc::c_void);
        rr_list_destroy((*g).rr, 1 as libc::c_int as libc::c_char);
        free(g as *mut libc::c_void);
        g = nextg;
    }
}
pub unsafe extern "C" fn mdns_write_u16(
    mut ptr: *mut uint8_t,
    v: uint16_t,
) -> *mut uint8_t {
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    tmp = ptr;
    ptr = ptr.offset(1);
    *tmp = ((v as libc::c_int >> 8 as libc::c_int) as uint8_t as libc::c_int
        & 255 as libc::c_int) as uint8_t;
    tmp___0 = ptr;
    ptr = ptr.offset(1);
    *tmp___0 = (v as libc::c_int as uint8_t as libc::c_int & 255 as libc::c_int)
        as uint8_t;
    return ptr;
}
pub unsafe extern "C" fn mdns_write_u32(
    mut ptr: *mut uint8_t,
    v: uint32_t,
) -> *mut uint8_t {
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___1: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___2: *mut uint8_t = 0 as *mut uint8_t;
    tmp = ptr;
    ptr = ptr.offset(1);
    *tmp = ((v >> 24 as libc::c_int) as uint8_t as libc::c_int & 255 as libc::c_int)
        as uint8_t;
    tmp___0 = ptr;
    ptr = ptr.offset(1);
    *tmp___0 = ((v >> 16 as libc::c_int) as uint8_t as libc::c_int & 255 as libc::c_int)
        as uint8_t;
    tmp___1 = ptr;
    ptr = ptr.offset(1);
    *tmp___1 = ((v >> 8 as libc::c_int) as uint8_t as libc::c_int & 255 as libc::c_int)
        as uint8_t;
    tmp___2 = ptr;
    ptr = ptr.offset(1);
    *tmp___2 = (v as uint8_t as libc::c_int & 255 as libc::c_int) as uint8_t;
    return ptr;
}
pub unsafe extern "C" fn mdns_read_u16(mut ptr: *const uint8_t) -> uint16_t {
    return ((*ptr.offset(0 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
        << 8 as libc::c_int
        | *ptr.offset(1 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
        as uint16_t;
}
pub unsafe extern "C" fn mdns_read_u32(mut ptr: *const uint8_t) -> uint32_t {
    return ((*ptr.offset(0 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
        << 24 as libc::c_int
        | (*ptr.offset(1 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
            << 16 as libc::c_int
        | (*ptr.offset(2 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
            << 8 as libc::c_int
        | *ptr.offset(3 as libc::c_int as isize) as libc::c_int & 255 as libc::c_int)
        as uint32_t;
}
pub unsafe extern "C" fn mdns_init_reply(mut pkt: *mut mdns_pkt, mut id: uint16_t) {
    (*pkt).id = id;
    (*pkt)
        .flags = ((1 as libc::c_int) << 15 as libc::c_int
        | (1 as libc::c_int) << 10 as libc::c_int) as uint16_t;
    rr_list_destroy((*pkt).rr_qn, 0 as libc::c_int as libc::c_char);
    rr_list_destroy((*pkt).rr_ans, 0 as libc::c_int as libc::c_char);
    rr_list_destroy((*pkt).rr_auth, 0 as libc::c_int as libc::c_char);
    rr_list_destroy((*pkt).rr_add, 0 as libc::c_int as libc::c_char);
    (*pkt).rr_qn = 0 as *mut libc::c_void as *mut rr_list;
    (*pkt).rr_ans = 0 as *mut libc::c_void as *mut rr_list;
    (*pkt).rr_auth = 0 as *mut libc::c_void as *mut rr_list;
    (*pkt).rr_add = 0 as *mut libc::c_void as *mut rr_list;
    (*pkt).num_qn = 0 as libc::c_int as uint16_t;
    (*pkt).num_ans_rr = 0 as libc::c_int as uint16_t;
    (*pkt).num_auth_rr = 0 as libc::c_int as uint16_t;
    (*pkt).num_add_rr = 0 as libc::c_int as uint16_t;
}
pub unsafe extern "C" fn mdns_pkt_destroy(mut p: *mut mdns_pkt) {
    rr_list_destroy((*p).rr_qn, 1 as libc::c_int as libc::c_char);
    rr_list_destroy((*p).rr_ans, 1 as libc::c_int as libc::c_char);
    rr_list_destroy((*p).rr_auth, 1 as libc::c_int as libc::c_char);
    rr_list_destroy((*p).rr_add, 1 as libc::c_int as libc::c_char);
    free(p as *mut libc::c_void);
}
unsafe extern "C" fn mdns_parse_qn(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
    mut pkt: *mut mdns_pkt,
) -> size_t {
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut name: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: uint16_t = 0;
    let mut tmp___2: uint16_t = 0;
    p = pkt_buf.offset(off as isize) as *const uint8_t;
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    name = uncompress_nlabel(pkt_buf, pkt_len, off);
    tmp___0 = label_len(pkt_buf, pkt_len, off);
    p = p.offset(tmp___0 as isize);
    (*rr).name = name;
    tmp___1 = mdns_read_u16(p);
    (*rr).type_0 = tmp___1 as rr_type;
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*rr)
        .unicast_query = (*p as libc::c_int & 128 as libc::c_int == 128 as libc::c_int)
        as libc::c_int as libc::c_char;
    tmp___2 = mdns_read_u16(p);
    (*rr).rr_class = (tmp___2 as libc::c_int & -(129 as libc::c_int)) as uint16_t;
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    rr_list_append(&mut (*pkt).rr_qn, rr);
    return p.offset_from(pkt_buf.offset(off as isize) as *const uint8_t) as libc::c_long
        as size_t;
}
unsafe extern "C" fn mdns_parse_rr___0(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
    mut pkt: *mut mdns_pkt,
) -> size_t {
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut e: *const uint8_t = 0 as *const uint8_t;
    let mut rr: *mut rr_entry = 0 as *mut rr_entry;
    let mut name: *mut uint8_t = 0 as *mut uint8_t;
    let mut rr_data_len: size_t = 0;
    let mut txt_rec: *mut rr_data_txt = 0 as *mut rr_data_txt;
    let mut parse_error: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: uint16_t = 0;
    let mut tmp___2: uint16_t = 0;
    let mut tmp___3: uint16_t = 0;
    let mut tmp___4: uint32_t = 0;
    let mut i: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    p = pkt_buf.offset(off as isize) as *const uint8_t;
    e = pkt_buf.offset(pkt_len as isize) as *const uint8_t;
    rr_data_len = 0 as libc::c_int as size_t;
    parse_error = 0 as libc::c_int;
    if off > pkt_len {
        return 0 as libc::c_int as size_t;
    }
    tmp = malloc(::std::mem::size_of::<rr_entry>() as libc::c_ulong);
    rr = tmp as *mut rr_entry;
    memset(
        rr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<rr_entry>() as libc::c_ulong,
    );
    name = uncompress_nlabel(pkt_buf, pkt_len, off);
    tmp___0 = label_len(pkt_buf, pkt_len, off);
    p = p.offset(tmp___0 as isize);
    (*rr).name = name;
    tmp___1 = mdns_read_u16(p);
    (*rr).type_0 = tmp___1 as rr_type;
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*rr)
        .cache_flush = (*p as libc::c_int & 128 as libc::c_int == 128 as libc::c_int)
        as libc::c_int as libc::c_char;
    tmp___2 = mdns_read_u16(p);
    (*rr).rr_class = (tmp___2 as libc::c_int & -(129 as libc::c_int)) as uint16_t;
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*rr).ttl = mdns_read_u32(p);
    p = p.offset(::std::mem::size_of::<uint32_t>() as libc::c_ulong as isize);
    tmp___3 = mdns_read_u16(p);
    rr_data_len = tmp___3 as size_t;
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    if p.offset(rr_data_len as isize) as libc::c_ulong > e as libc::c_ulong {
        rr_entry_destroy(rr);
        return 0 as libc::c_int as size_t;
    }
    e = p.offset(rr_data_len as isize);
    match (*rr).type_0 as libc::c_uint {
        1 => {
            if rr_data_len < ::std::mem::size_of::<uint32_t>() as libc::c_ulong {
                parse_error = 1 as libc::c_int;
            } else {
                tmp___4 = mdns_read_u32(p);
                (*rr).data.A.addr = __bswap_32(tmp___4);
                p = p
                    .offset(::std::mem::size_of::<uint32_t>() as libc::c_ulong as isize);
            }
        }
        28 => {
            if rr_data_len < ::std::mem::size_of::<in6_addr>() as libc::c_ulong {
                parse_error = 1 as libc::c_int;
            } else {
                tmp___5 = malloc(::std::mem::size_of::<in6_addr>() as libc::c_ulong);
                (*rr).data.AAAA.addr = tmp___5 as *mut in6_addr;
                i = 0 as libc::c_int;
                while (i as libc::c_ulong)
                    < ::std::mem::size_of::<in6_addr>() as libc::c_ulong
                {
                    (*(*rr).data.AAAA.addr)
                        .__in6_u
                        .__u6_addr8[i as usize] = *p.offset(i as isize);
                    i += 1;
                }
                p = p
                    .offset(::std::mem::size_of::<in6_addr>() as libc::c_ulong as isize);
            }
        }
        12 => {
            (*rr)
                .data
                .PTR
                .name = uncompress_nlabel(
                pkt_buf,
                pkt_len,
                p.offset_from(pkt_buf as *const uint8_t) as libc::c_long as size_t,
            );
            if (*rr).data.PTR.name as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                parse_error = 1 as libc::c_int;
            } else {
                p = p.offset(rr_data_len as isize);
            }
        }
        16 => {
            txt_rec = &mut (*rr).data.TXT;
            if rr_data_len == 0 as libc::c_ulong {
                (*txt_rec).txt = create_label(b"\0" as *const u8 as *const libc::c_char);
            } else {
                loop {
                    (*txt_rec)
                        .txt = copy_label(
                        pkt_buf,
                        pkt_len,
                        p.offset_from(pkt_buf as *const uint8_t) as libc::c_long
                            as size_t,
                    );
                    if (*txt_rec).txt as libc::c_ulong
                        == 0 as *mut libc::c_void as libc::c_ulong
                    {
                        parse_error = 1 as libc::c_int;
                        break;
                    } else {
                        p = p
                            .offset(
                                (*((*txt_rec).txt).offset(0 as libc::c_int as isize)
                                    as libc::c_int + 1 as libc::c_int) as isize,
                            );
                        if p as libc::c_ulong >= e as libc::c_ulong {
                            break;
                        }
                        tmp___6 = malloc(
                            ::std::mem::size_of::<rr_data_txt>() as libc::c_ulong,
                        );
                        (*txt_rec).next = tmp___6 as *mut rr_data_txt;
                        txt_rec = (*txt_rec).next;
                        (*txt_rec).next = 0 as *mut libc::c_void as *mut rr_data_txt;
                    }
                }
            }
        }
        _ => {
            p = e;
        }
    }
    if parse_error != 0 {
        rr_entry_destroy(rr);
        return 0 as libc::c_int as size_t;
    }
    rr_list_append(&mut (*pkt).rr_ans, rr);
    return p.offset_from(pkt_buf.offset(off as isize) as *const uint8_t) as libc::c_long
        as size_t;
}
pub unsafe extern "C" fn mdns_parse_pkt(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
) -> *mut mdns_pkt {
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut off: size_t = 0;
    let mut pkt: *mut mdns_pkt = 0 as *mut mdns_pkt;
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut l: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut l___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    p = pkt_buf;
    if pkt_len < 12 as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut mdns_pkt;
    }
    tmp = malloc(::std::mem::size_of::<mdns_pkt>() as libc::c_ulong);
    pkt = tmp as *mut mdns_pkt;
    memset(
        pkt as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<mdns_pkt>() as libc::c_ulong,
    );
    (*pkt).id = mdns_read_u16(p as *const uint8_t);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*pkt).flags = mdns_read_u16(p as *const uint8_t);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*pkt).num_qn = mdns_read_u16(p as *const uint8_t);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*pkt).num_ans_rr = mdns_read_u16(p as *const uint8_t);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*pkt).num_auth_rr = mdns_read_u16(p as *const uint8_t);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    (*pkt).num_add_rr = mdns_read_u16(p as *const uint8_t);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    off = p.offset_from(pkt_buf) as libc::c_long as size_t;
    i = 0 as libc::c_int;
    while i < (*pkt).num_qn as libc::c_int {
        tmp___0 = mdns_parse_qn(pkt_buf, pkt_len, off, pkt);
        l = tmp___0;
        if l == 0 {
            mdns_pkt_destroy(pkt);
            return 0 as *mut libc::c_void as *mut mdns_pkt;
        }
        off = (off as libc::c_ulong).wrapping_add(l) as size_t as size_t;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*pkt).num_ans_rr as libc::c_int {
        tmp___1 = mdns_parse_rr___0(pkt_buf, pkt_len, off, pkt);
        l___0 = tmp___1;
        if l___0 == 0 {
            mdns_pkt_destroy(pkt);
            return 0 as *mut libc::c_void as *mut mdns_pkt;
        }
        off = (off as libc::c_ulong).wrapping_add(l___0) as size_t as size_t;
        i += 1;
    }
    return pkt;
}
unsafe extern "C" fn mdns_encode_name(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
    mut name: *const uint8_t,
    mut comp: *mut name_comp,
) -> size_t {
    let mut c: *mut name_comp = 0 as *mut name_comp;
    let mut c_tail: *mut name_comp = 0 as *mut name_comp;
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut len: size_t = 0;
    let mut segment_len: libc::c_int = 0;
    let mut new_c: *mut name_comp = 0 as *mut name_comp;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    c_tail = 0 as *mut libc::c_void as *mut name_comp;
    p = pkt_buf.offset(off as isize);
    len = 0 as libc::c_int as size_t;
    if !name.is_null() {
        while *name != 0 {
            c = comp;
            while !c.is_null() {
                tmp = cmp_nlabel(name, (*c).label as *const uint8_t);
                if tmp == 0 as libc::c_int {
                    mdns_write_u16(
                        p,
                        (49152 as libc::c_ulong
                            | (*c).pos & 0xffffffffffff3fff as libc::c_ulong) as uint16_t,
                    );
                    return len
                        .wrapping_add(
                            ::std::mem::size_of::<uint16_t>() as libc::c_ulong,
                        );
                }
                if (*c).next as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                {
                    c_tail = c;
                }
                c = (*c).next;
            }
            segment_len = *name as libc::c_int + 1 as libc::c_int;
            strncpy(
                p as *mut libc::c_char,
                name as *mut libc::c_char as *const libc::c_char,
                segment_len as size_t,
            );
            tmp___0 = malloc(::std::mem::size_of::<name_comp>() as libc::c_ulong);
            new_c = tmp___0 as *mut name_comp;
            memset(
                new_c as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<name_comp>() as libc::c_ulong,
            );
            (*new_c).label = name as *mut uint8_t;
            (*new_c).pos = p.offset_from(pkt_buf) as libc::c_long as size_t;
            (*c_tail).next = new_c;
            p = p.offset(segment_len as isize);
            len = (len as libc::c_ulong).wrapping_add(segment_len as size_t) as size_t
                as size_t;
            name = name.offset(segment_len as isize);
        }
    }
    *p = '\u{0}' as i32 as uint8_t;
    len = len.wrapping_add(1);
    return len;
}
unsafe extern "C" fn mdns_encode_rr(
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
    mut off: size_t,
    mut rr: *mut rr_entry,
    mut comp: *mut name_comp,
) -> size_t {
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut p_data: *mut uint8_t = 0 as *mut uint8_t;
    let mut l: size_t = 0;
    let mut txt_rec: *mut rr_data_txt = 0 as *mut rr_data_txt;
    let mut label: *mut uint8_t = 0 as *mut uint8_t;
    let mut i: libc::c_int = 0;
    let mut tmp: __uint32_t = 0;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___1: size_t = 0;
    let mut len: libc::c_int = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___5: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___6: *mut uint8_t = 0 as *mut uint8_t;
    p = pkt_buf.offset(off as isize);
    l = mdns_encode_name(pkt_buf, pkt_len, off, (*rr).name as *const uint8_t, comp);
    p = p.offset(l as isize);
    p = mdns_write_u16(p, (*rr).type_0 as uint16_t);
    p = mdns_write_u16(
        p,
        ((*rr).rr_class as libc::c_int & -(32769 as libc::c_int)
            | ((*rr).cache_flush as libc::c_int) << 15 as libc::c_int) as uint16_t,
    );
    p = mdns_write_u32(p, (*rr).ttl);
    p = p.offset(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize);
    p_data = p;
    match (*rr).type_0 as libc::c_uint {
        1 => {
            tmp = __bswap_32((*rr).data.A.addr);
            p = mdns_write_u32(p, tmp);
        }
        28 => {
            i = 0 as libc::c_int;
            while (i as libc::c_ulong)
                < ::std::mem::size_of::<in6_addr>() as libc::c_ulong
            {
                tmp___0 = p;
                p = p.offset(1);
                *tmp___0 = (*(*rr).data.AAAA.addr).__in6_u.__u6_addr8[i as usize];
                i += 1;
            }
        }
        12 => {
            if !((*rr).data.PTR.name).is_null() {
                label = (*rr).data.PTR.name;
            } else {
                label = (*(*rr).data.PTR.entry).name;
            }
            tmp___1 = mdns_encode_name(
                pkt_buf,
                pkt_len,
                p.offset_from(pkt_buf) as libc::c_long as size_t,
                label as *const uint8_t,
                comp,
            );
            p = p.offset(tmp___1 as isize);
        }
        16 => {
            txt_rec = &mut (*rr).data.TXT;
            while !txt_rec.is_null() {
                len = *((*txt_rec).txt).offset(0 as libc::c_int as isize) as libc::c_int
                    + 1 as libc::c_int;
                strncpy(
                    p as *mut libc::c_char,
                    (*txt_rec).txt as *mut libc::c_char as *const libc::c_char,
                    len as size_t,
                );
                p = p.offset(len as isize);
                txt_rec = (*txt_rec).next;
            }
        }
        33 => {
            p = mdns_write_u16(p, (*rr).data.SRV.priority);
            p = mdns_write_u16(p, (*rr).data.SRV.weight);
            p = mdns_write_u16(p, (*rr).data.SRV.port);
            tmp___2 = mdns_encode_name(
                pkt_buf,
                pkt_len,
                p.offset_from(pkt_buf) as libc::c_long as size_t,
                (*rr).data.SRV.target as *const uint8_t,
                comp,
            );
            p = p.offset(tmp___2 as isize);
        }
        47 => {
            tmp___3 = mdns_encode_name(
                pkt_buf,
                pkt_len,
                p.offset_from(pkt_buf) as libc::c_long as size_t,
                (*rr).name as *const uint8_t,
                comp,
            );
            p = p.offset(tmp___3 as isize);
            tmp___4 = p;
            p = p.offset(1);
            *tmp___4 = 0 as libc::c_int as uint8_t;
            tmp___5 = p;
            p = p.offset(1);
            *tmp___5 = ::std::mem::size_of::<[uint8_t; 5]>() as libc::c_ulong as uint8_t;
            i = 0 as libc::c_int;
            while (i as libc::c_ulong)
                < ::std::mem::size_of::<[uint8_t; 5]>() as libc::c_ulong
            {
                tmp___6 = p;
                p = p.offset(1);
                *tmp___6 = (*rr).data.NSEC.bitmap[i as usize];
                i += 1;
            }
        }
        _ => {}
    }
    l = p.offset_from(p_data) as libc::c_long as size_t;
    mdns_write_u16(
        p
            .offset(-(l as isize))
            .offset(-(::std::mem::size_of::<uint16_t>() as libc::c_ulong as isize)),
        l as uint16_t,
    );
    return (p.offset_from(pkt_buf) as libc::c_long as size_t).wrapping_sub(off);
}
pub unsafe extern "C" fn mdns_encode_pkt(
    mut answer: *mut mdns_pkt,
    mut pkt_buf: *mut uint8_t,
    mut pkt_len: size_t,
) -> size_t {
    let mut comp: *mut name_comp = 0 as *mut name_comp;
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut off: size_t = 0;
    let mut i: libc::c_int = 0;
    let mut rr_set: [*mut rr_list; 3] = [0 as *mut rr_list; 3];
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut rr: *mut rr_list = 0 as *mut rr_list;
    let mut l: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut c: *mut name_comp = 0 as *mut name_comp;
    p = pkt_buf;
    if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int) as size_t;
    }
    p = mdns_write_u16(p, (*answer).id);
    p = mdns_write_u16(p, (*answer).flags);
    p = mdns_write_u16(p, (*answer).num_qn);
    p = mdns_write_u16(p, (*answer).num_ans_rr);
    p = mdns_write_u16(p, (*answer).num_auth_rr);
    p = mdns_write_u16(p, (*answer).num_add_rr);
    off = p.offset_from(pkt_buf) as libc::c_long as size_t;
    tmp = malloc(::std::mem::size_of::<name_comp>() as libc::c_ulong);
    comp = tmp as *mut name_comp;
    if comp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return -(1 as libc::c_int) as size_t;
    }
    memset(
        comp as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<name_comp>() as libc::c_ulong,
    );
    (*comp).label = b"\0" as *const u8 as *const libc::c_char as *mut uint8_t;
    (*comp).pos = 0 as libc::c_int as size_t;
    rr_set[0 as libc::c_int as usize] = (*answer).rr_ans;
    rr_set[1 as libc::c_int as usize] = (*answer).rr_auth;
    rr_set[2 as libc::c_int as usize] = (*answer).rr_add;
    i = 0 as libc::c_int;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[*mut rr_list; 3]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<*mut rr_list>() as libc::c_ulong)
    {
        rr = rr_set[i as usize];
        while !rr.is_null() {
            tmp___0 = mdns_encode_rr(pkt_buf, pkt_len, off, (*rr).e, comp);
            l = tmp___0;
            off = (off as libc::c_ulong).wrapping_add(l) as size_t as size_t;
            if off >= pkt_len {
                return -(1 as libc::c_int) as size_t;
            }
            rr = (*rr).next;
        }
        i += 1;
    }
    while !comp.is_null() {
        c = (*comp).next;
        free(comp as *mut libc::c_void);
        comp = c;
    }
    return off;
}
unsafe extern "C" fn log_message(
    mut loglevel___5: libc::c_int,
    mut fmt_str: *mut libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    let mut buf___0: [libc::c_char; 2048] = [0; 2048];
    ap = args.clone();
    vsnprintf(
        buf___0.as_mut_ptr(),
        2047 as libc::c_int as size_t,
        fmt_str as *const libc::c_char,
        ap.as_va_list(),
    );
    buf___0[2047 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    fprintf(stderr, b"%s\n\0" as *const u8 as *const libc::c_char, buf___0.as_mut_ptr());
}
unsafe extern "C" fn create_recv_sock(mut host: uint32_t) -> libc::c_int {
    let mut sd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut on: libc::c_int = 0;
    let mut onChar: libc::c_char = 0;
    let mut serveraddr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut mreq: ip_mreq = ip_mreq {
        imr_multiaddr: in_addr { s_addr: 0 },
        imr_interface: in_addr { s_addr: 0 },
    };
    let mut ttl: libc::c_uchar = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = socket(2 as libc::c_int, 2 as libc::c_int, 0 as libc::c_int);
    sd = tmp;
    r = -(1 as libc::c_int);
    on = 1 as libc::c_int;
    onChar = 1 as libc::c_int as libc::c_char;
    ttl = 255 as libc::c_int as libc::c_uchar;
    if sd < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv socket(): %m\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return sd;
    }
    r = setsockopt(
        sd,
        1 as libc::c_int,
        2 as libc::c_int,
        &mut on as *mut libc::c_int as *mut libc::c_char as *const libc::c_void,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv setsockopt(SO_REUSEADDR): %m\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return r;
    }
    on = ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int;
    tmp___0 = getsockopt(
        sd,
        1 as libc::c_int,
        15 as libc::c_int,
        &mut on as *mut libc::c_int as *mut libc::c_char as *mut libc::c_void,
        &mut on as *mut libc::c_int as *mut libc::c_void as *mut socklen_t,
    );
    if tmp___0 == 0 {
        on = 1 as libc::c_int;
        r = setsockopt(
            sd,
            1 as libc::c_int,
            15 as libc::c_int,
            &mut on as *mut libc::c_int as *mut libc::c_char as *const libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
        );
        if r < 0 as libc::c_int {
            log_message(
                3 as libc::c_int,
                b"recv setsockopt(SO_REUSEPORT): %m\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                r,
            );
        }
    }
    memset(
        &mut serveraddr as *mut sockaddr_in as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    serveraddr.sin_family = 2 as libc::c_int as sa_family_t;
    serveraddr.sin_port = __bswap_16(5353 as libc::c_int as __uint16_t);
    serveraddr.sin_addr.s_addr = __bswap_32(0 as libc::c_int as in_addr_t);
    r = bind(
        sd,
        &mut serveraddr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv bind(): %m\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return r;
    }
    memset(
        &mut mreq as *mut ip_mreq as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ip_mreq>() as libc::c_ulong,
    );
    mreq.imr_interface.s_addr = host;
    r = setsockopt(
        sd,
        0 as libc::c_int,
        32 as libc::c_int,
        &mut mreq.imr_interface.s_addr as *mut in_addr_t as *mut libc::c_char
            as *const libc::c_void,
        ::std::mem::size_of::<in_addr_t>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv setsockopt(IP_PROTO_IP): %m\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return r;
    }
    r = setsockopt(
        sd,
        0 as libc::c_int,
        33 as libc::c_int,
        &mut ttl as *mut libc::c_uchar as *mut libc::c_void as *const libc::c_void,
        ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv setsockopt(IP_MULTICAST_IP): %m\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return r;
    }
    mreq
        .imr_multiaddr
        .s_addr = inet_addr(b"224.0.0.251\0" as *const u8 as *const libc::c_char);
    r = setsockopt(
        sd,
        0 as libc::c_int,
        35 as libc::c_int,
        &mut mreq as *mut ip_mreq as *mut libc::c_char as *const libc::c_void,
        ::std::mem::size_of::<ip_mreq>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv setsockopt(IP_ADD_MEMBERSHIP): %m\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        return r;
    }
    r = setsockopt(
        sd,
        0 as libc::c_int,
        34 as libc::c_int,
        &mut onChar as *mut libc::c_char as *const libc::c_void,
        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv setsockopt(IP_MULTICAST_LOOP): %m\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        return r;
    }
    on = 1 as libc::c_int;
    r = setsockopt(
        sd,
        0 as libc::c_int,
        8 as libc::c_int,
        &mut on as *mut libc::c_int as *mut libc::c_char as *const libc::c_void,
        ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
    if r < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"recv setsockopt(IP_PKTINFO): %m\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return r;
    }
    return sd;
}
static mut toaddr: sockaddr_in = sockaddr_in {
    sin_family: 0,
    sin_port: 0,
    sin_addr: in_addr { s_addr: 0 },
    sin_zero: [0; 8],
};
unsafe extern "C" fn send_packet(
    mut fd: libc::c_int,
    mut data: *const libc::c_void,
    mut len: size_t,
) -> ssize_t {
    let mut tmp: ssize_t = 0;
    if toaddr.sin_family as libc::c_int != 2 as libc::c_int {
        memset(
            &mut toaddr as *mut sockaddr_in as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
        );
        toaddr.sin_family = 2 as libc::c_int as sa_family_t;
        toaddr.sin_port = __bswap_16(5353 as libc::c_int as __uint16_t);
        toaddr
            .sin_addr
            .s_addr = inet_addr(b"224.0.0.251\0" as *const u8 as *const libc::c_char);
    }
    tmp = sendto(
        fd,
        data,
        len,
        0 as libc::c_int,
        &mut toaddr as *mut sockaddr_in as *mut sockaddr as *const sockaddr,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
    );
    return tmp;
}
unsafe extern "C" fn populate_answers(
    mut svr: *mut mdnsd,
    mut rr_head: *mut *mut rr_list,
    mut name: *mut uint8_t,
    mut type_0: rr_type,
) -> libc::c_int {
    let mut num_ans: libc::c_int = 0;
    let mut ans_grp: *mut rr_group = 0 as *mut rr_group;
    let mut n: *mut rr_list = 0 as *mut rr_list;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    num_ans = 0 as libc::c_int;
    pthread_mutex_lock(&mut (*svr).data_lock);
    ans_grp = rr_group_find((*svr).group, name);
    if ans_grp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        pthread_mutex_unlock(&mut (*svr).data_lock);
        return num_ans;
    }
    n = (*ans_grp).rr;
    while !n.is_null() {
        let mut current_block_14: u64;
        if type_0 as libc::c_uint == 255 as libc::c_uint {
            if (*(*n).e).type_0 as libc::c_uint == 47 as libc::c_uint {
                current_block_14 = 14912004961369314318;
            } else {
                current_block_14 = 2868539653012386629;
            }
        } else {
            current_block_14 = 2868539653012386629;
        }
        match current_block_14 {
            2868539653012386629 => {
                let mut current_block_12: u64;
                if type_0 as libc::c_uint == (*(*n).e).type_0 as libc::c_uint {
                    current_block_12 = 3617308618798626320;
                } else if type_0 as libc::c_uint == 255 as libc::c_uint {
                    current_block_12 = 3617308618798626320;
                } else {
                    current_block_12 = 15652330335145281839;
                }
                match current_block_12 {
                    3617308618798626320 => {
                        tmp___0 = cmp_nlabel(
                            name as *const uint8_t,
                            (*(*n).e).name as *const uint8_t,
                        );
                        if tmp___0 == 0 as libc::c_int {
                            tmp = rr_list_append(rr_head, (*n).e);
                            num_ans += tmp;
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        n = (*n).next;
    }
    pthread_mutex_unlock(&mut (*svr).data_lock);
    return num_ans;
}
unsafe extern "C" fn add_related_rr(
    mut svr: *mut mdnsd,
    mut list: *mut rr_list,
    mut reply: *mut mdns_pkt,
) {
    let mut ans: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    while !list.is_null() {
        ans = (*list).e;
        match (*ans).type_0 as libc::c_uint {
            12 => {
                if (*ans).data.PTR.name as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    tmp = (*ans).data.PTR.name;
                } else {
                    tmp = (*(*ans).data.PTR.entry).name;
                }
                tmp___0 = populate_answers(svr, &mut (*reply).rr_add, tmp, RR_ANY);
                (*reply)
                    .num_add_rr = ((*reply).num_add_rr as libc::c_int + tmp___0)
                    as uint16_t;
            }
            33 => {
                tmp___1 = populate_answers(
                    svr,
                    &mut (*reply).rr_add,
                    (*ans).data.SRV.target,
                    RR_ANY,
                );
                (*reply)
                    .num_add_rr = ((*reply).num_add_rr as libc::c_int + tmp___1)
                    as uint16_t;
                tmp___2 = populate_answers(
                    svr,
                    &mut (*reply).rr_add,
                    (*ans).name,
                    RR_TXT,
                );
                (*reply)
                    .num_add_rr = ((*reply).num_add_rr as libc::c_int + tmp___2)
                    as uint16_t;
            }
            28 | 1 => {
                tmp___3 = populate_answers(
                    svr,
                    &mut (*reply).rr_add,
                    (*ans).name,
                    RR_NSEC,
                );
                (*reply)
                    .num_add_rr = ((*reply).num_add_rr as libc::c_int + tmp___3)
                    as uint16_t;
            }
            _ => {}
        }
        list = (*list).next;
    }
}
unsafe extern "C" fn announce_srv(
    mut svr: *mut mdnsd,
    mut reply: *mut mdns_pkt,
    mut name: *mut uint8_t,
) {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    mdns_init_reply(reply, 0 as libc::c_int as uint16_t);
    tmp = populate_answers(svr, &mut (*reply).rr_ans, name, RR_PTR);
    (*reply).num_ans_rr = ((*reply).num_ans_rr as libc::c_int + tmp) as uint16_t;
    tmp___0 = populate_answers(
        svr,
        &mut (*reply).rr_ans,
        b"\t_services\x07_dns-sd\x04_udp\x05local\0" as *const u8 as *const libc::c_char
            as *mut uint8_t,
        RR_PTR,
    );
    (*reply).num_ans_rr = ((*reply).num_ans_rr as libc::c_int + tmp___0) as uint16_t;
    add_related_rr(svr, (*reply).rr_ans, reply);
    add_related_rr(svr, (*reply).rr_add, reply);
}
unsafe extern "C" fn process_mdns_pkt(
    mut svr: *mut mdnsd,
    mut pkt: *mut mdns_pkt,
    mut reply: *mut mdns_pkt,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut qnl: *mut rr_list = 0 as *mut rr_list;
    let mut ans: *mut rr_list = 0 as *mut rr_list;
    let mut prev_ans: *mut rr_list = 0 as *mut rr_list;
    let mut qn: *mut rr_entry = 0 as *mut rr_entry;
    let mut num_ans_added: libc::c_int = 0;
    let mut namestr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut next_ans: *mut rr_list = 0 as *mut rr_list;
    let mut known_ans: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp___0: *mut rr_entry = 0 as *mut rr_entry;
    let mut namestr___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*pkt).flags as libc::c_int & (1 as libc::c_int) << 15 as libc::c_int
        == 0 as libc::c_int
    {
        if (*pkt).flags as libc::c_int >> 11 as libc::c_int & 15 as libc::c_int
            == 0 as libc::c_int
        {
            mdns_init_reply(reply, (*pkt).id);
            qnl = (*pkt).rr_qn;
            i = 0 as libc::c_int;
            while i < (*pkt).num_qn as libc::c_int {
                qn = (*qnl).e;
                num_ans_added = 0 as libc::c_int;
                tmp = nlabel_to_str((*qn).name as *const uint8_t);
                namestr = tmp;
                free(namestr as *mut libc::c_void);
                if !((*qn).unicast_query != 0) {
                    num_ans_added = populate_answers(
                        svr,
                        &mut (*reply).rr_ans,
                        (*qn).name,
                        (*qn).type_0,
                    );
                    (*reply)
                        .num_ans_rr = ((*reply).num_ans_rr as libc::c_int
                        + num_ans_added) as uint16_t;
                }
                i += 1;
                qnl = (*qnl).next;
            }
            ans = 0 as *mut libc::c_void as *mut rr_list;
            prev_ans = 0 as *mut libc::c_void as *mut rr_list;
            ans = (*reply).rr_ans;
            while !ans.is_null() {
                next_ans = (*ans).next;
                tmp___0 = rr_entry_match((*pkt).rr_ans, (*ans).e);
                known_ans = tmp___0;
                if known_ans as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
                {
                    if (*known_ans).ttl
                        >= ((*(*ans).e).ttl).wrapping_div(2 as libc::c_uint)
                    {
                        tmp___1 = nlabel_to_str((*(*ans).e).name as *const uint8_t);
                        namestr___0 = tmp___1;
                        free(namestr___0 as *mut libc::c_void);
                        if prev_ans as libc::c_ulong
                            == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            (*reply).rr_ans = (*ans).next;
                        } else {
                            (*prev_ans).next = (*ans).next;
                        }
                        free(ans as *mut libc::c_void);
                        ans = prev_ans;
                        (*reply)
                            .num_ans_rr = ((*reply).num_ans_rr as libc::c_int
                            - 1 as libc::c_int) as uint16_t;
                    }
                }
                prev_ans = ans;
                ans = next_ans;
            }
            add_related_rr(svr, (*reply).rr_ans, reply);
            add_related_rr(svr, (*reply).rr_add, reply);
            return (*reply).num_ans_rr as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn create_pipe(mut handles: *mut libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = pipe(handles);
    return tmp;
}
pub unsafe extern "C" fn read_pipe(
    mut s: libc::c_int,
    mut buf___0: *mut libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut tmp: ssize_t = 0;
    tmp = read(s, buf___0 as *mut libc::c_void, len as size_t);
    return tmp as libc::c_int;
}
pub unsafe extern "C" fn write_pipe(
    mut s: libc::c_int,
    mut buf___0: *mut libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut tmp: ssize_t = 0;
    tmp = write(s, buf___0 as *const libc::c_void, len as size_t);
    return tmp as libc::c_int;
}
pub unsafe extern "C" fn close_pipe(mut s: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = close(s);
    return tmp;
}
unsafe extern "C" fn main_loop(mut svr: *mut mdnsd) {
    let mut sockfd_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut max_fd: libc::c_int = 0;
    let mut notify_buf: [libc::c_char; 2] = [0; 2];
    let mut mdns_reply: *mut mdns_pkt = 0 as *mut mdns_pkt;
    let mut mdns: *mut mdns_pkt = 0 as *mut mdns_pkt;
    let mut svc_le: *mut rr_list = 0 as *mut rr_list;
    let mut pkt_buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut fromaddr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut sockaddr_size: socklen_t = 0;
    let mut recvsize: ssize_t = 0;
    let mut tmp___1: ssize_t = 0;
    let mut replylen: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut ann_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut namestr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut replylen___0: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut leave_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut namestr___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: libc::c_int = 0;
    let mut replylen___1: size_t = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut replylen___2: size_t = 0;
    let mut tmp___8: size_t = 0;
    max_fd = (*svr).sockfd;
    tmp = malloc(65536 as libc::c_int as size_t);
    pkt_buffer = tmp;
    if (*svr).notify_pipe[0 as libc::c_int as usize] > max_fd {
        max_fd = (*svr).notify_pipe[0 as libc::c_int as usize];
    }
    tmp___0 = malloc(::std::mem::size_of::<mdns_pkt>() as libc::c_ulong);
    mdns_reply = tmp___0 as *mut mdns_pkt;
    memset(
        mdns_reply as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<mdns_pkt>() as libc::c_ulong,
    );
    while (*svr).stop_flag == 0 {
        let fresh46 = &mut __d0;
        let fresh47;
        let fresh48 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
        let fresh49 = &mut __d1;
        let fresh50;
        let fresh51 = &mut *(sockfd_set.fds_bits)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize) as *mut __fd_mask;
        asm!(
            "cld; rep; stosq", inlateout("cx")
            c2rust_asm_casts::AsmCast::cast_in(fresh46, fresh48) => fresh47,
            inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh49, fresh51) =>
            fresh50, inlateout("ax") 0 as libc::c_int => _, options(preserves_flags,
            att_syntax)
        );
        c2rust_asm_casts::AsmCast::cast_out(fresh46, fresh48, fresh47);
        c2rust_asm_casts::AsmCast::cast_out(fresh49, fresh51, fresh50);
        sockfd_set
            .fds_bits[((*svr).sockfd
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << (*svr).sockfd
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        sockfd_set
            .fds_bits[((*svr).notify_pipe[0 as libc::c_int as usize]
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            |= ((1 as libc::c_ulong)
                << (*svr).notify_pipe[0 as libc::c_int as usize]
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask;
        select(
            max_fd + 1 as libc::c_int,
            &mut sockfd_set as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut timeval,
        );
        if sockfd_set
            .fds_bits[((*svr).notify_pipe[0 as libc::c_int as usize]
            / (8 as libc::c_int
                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
            as usize]
            & ((1 as libc::c_ulong)
                << (*svr).notify_pipe[0 as libc::c_int as usize]
                    % (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as __fd_mask != 0 as libc::c_long
        {
            read_pipe(
                (*svr).notify_pipe[0 as libc::c_int as usize],
                &mut notify_buf as *mut [libc::c_char; 2] as *mut libc::c_char,
                1 as libc::c_int,
            );
        } else if sockfd_set
                .fds_bits[((*svr).sockfd
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << (*svr).sockfd
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
            sockaddr_size = ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong
                as socklen_t;
            tmp___1 = recvfrom(
                (*svr).sockfd,
                pkt_buffer,
                65536 as libc::c_int as size_t,
                0 as libc::c_int,
                &mut fromaddr as *mut sockaddr_in as *mut sockaddr,
                &mut sockaddr_size as *mut socklen_t,
            );
            recvsize = tmp___1;
            if recvsize < 0 as libc::c_long {
                log_message(
                    3 as libc::c_int,
                    b"recv(): %m\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
            }
            mdns = mdns_parse_pkt(pkt_buffer as *mut uint8_t, recvsize as size_t);
            if mdns as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___3 = process_mdns_pkt(svr, mdns, mdns_reply);
                if tmp___3 != 0 {
                    tmp___2 = mdns_encode_pkt(
                        mdns_reply,
                        pkt_buffer as *mut uint8_t,
                        65536 as libc::c_int as size_t,
                    );
                    replylen = tmp___2;
                    send_packet(
                        (*svr).sockfd,
                        pkt_buffer as *const libc::c_void,
                        replylen,
                    );
                }
                mdns_pkt_destroy(mdns);
            }
        }
        loop {
            ann_e = 0 as *mut libc::c_void as *mut rr_entry;
            pthread_mutex_lock(&mut (*svr).data_lock);
            if !((*svr).announce).is_null() {
                ann_e = rr_list_remove(&mut (*svr).announce, (*(*svr).announce).e);
            }
            pthread_mutex_unlock(&mut (*svr).data_lock);
            if ann_e.is_null() {
                break;
            }
            namestr = nlabel_to_str((*ann_e).name as *const uint8_t);
            free(namestr as *mut libc::c_void);
            announce_srv(svr, mdns_reply, (*ann_e).name);
            if (*mdns_reply).num_ans_rr as libc::c_int > 0 as libc::c_int {
                tmp___4 = mdns_encode_pkt(
                    mdns_reply,
                    pkt_buffer as *mut uint8_t,
                    65536 as libc::c_int as size_t,
                );
                replylen___0 = tmp___4;
                send_packet(
                    (*svr).sockfd,
                    pkt_buffer as *const libc::c_void,
                    replylen___0,
                );
            }
        }
        loop {
            leave_e = 0 as *mut libc::c_void as *mut rr_entry;
            pthread_mutex_lock(&mut (*svr).data_lock);
            if !((*svr).leave).is_null() {
                leave_e = rr_list_remove(&mut (*svr).leave, (*(*svr).leave).e);
            }
            pthread_mutex_unlock(&mut (*svr).data_lock);
            if leave_e.is_null() {
                break;
            }
            mdns_init_reply(mdns_reply, 0 as libc::c_int as uint16_t);
            namestr___0 = nlabel_to_str((*leave_e).name as *const uint8_t);
            free(namestr___0 as *mut libc::c_void);
            (*leave_e).ttl = 0 as libc::c_int as uint32_t;
            tmp___5 = rr_list_append(&mut (*mdns_reply).rr_ans, leave_e);
            (*mdns_reply)
                .num_ans_rr = ((*mdns_reply).num_ans_rr as libc::c_int + tmp___5)
                as uint16_t;
            if (*mdns_reply).num_ans_rr as libc::c_int > 0 as libc::c_int {
                tmp___6 = mdns_encode_pkt(
                    mdns_reply,
                    pkt_buffer as *mut uint8_t,
                    65536 as libc::c_int as size_t,
                );
                replylen___1 = tmp___6;
                send_packet(
                    (*svr).sockfd,
                    pkt_buffer as *const libc::c_void,
                    replylen___1,
                );
            }
            rr_entry_destroy((*leave_e).data.PTR.entry);
            rr_entry_destroy(leave_e);
        }
    }
    mdns_init_reply(mdns_reply, 0 as libc::c_int as uint16_t);
    pthread_mutex_lock(&mut (*svr).data_lock);
    svc_le = (*svr).services;
    while !svc_le.is_null() {
        (*(*svc_le).e).ttl = 0 as libc::c_int as uint32_t;
        tmp___7 = rr_list_append(&mut (*mdns_reply).rr_ans, (*svc_le).e);
        (*mdns_reply)
            .num_ans_rr = ((*mdns_reply).num_ans_rr as libc::c_int + tmp___7)
            as uint16_t;
        svc_le = (*svc_le).next;
    }
    pthread_mutex_unlock(&mut (*svr).data_lock);
    if (*mdns_reply).num_ans_rr as libc::c_int > 0 as libc::c_int {
        tmp___8 = mdns_encode_pkt(
            mdns_reply,
            pkt_buffer as *mut uint8_t,
            65536 as libc::c_int as size_t,
        );
        replylen___2 = tmp___8;
        send_packet((*svr).sockfd, pkt_buffer as *const libc::c_void, replylen___2);
    }
    mdns_init_reply(mdns_reply, 0 as libc::c_int as uint16_t);
    free(mdns_reply as *mut libc::c_void);
    free(pkt_buffer);
    close_pipe((*svr).sockfd);
    (*svr).stop_flag = 2 as libc::c_int;
}
pub unsafe extern "C" fn mdnsd_set_hostname(
    mut svr: *mut mdnsd,
    mut hostname: *const libc::c_char,
    mut addr: in_addr,
) {
    let mut a_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut nsec_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    a_e = 0 as *mut libc::c_void as *mut rr_entry;
    nsec_e = 0 as *mut libc::c_void as *mut rr_entry;
    tmp = create_nlabel(hostname);
    a_e = rr_create_a(tmp, addr);
    tmp___0 = create_nlabel(hostname);
    nsec_e = rr_create(tmp___0, RR_NSEC);
    (*nsec_e).ttl = 120 as libc::c_int as uint32_t;
    rr_set_nsec(nsec_e, RR_A);
    pthread_mutex_lock(&mut (*svr).data_lock);
    (*svr).hostname = create_nlabel(hostname);
    rr_group_add(&mut (*svr).group, a_e);
    rr_group_add(&mut (*svr).group, nsec_e);
    pthread_mutex_unlock(&mut (*svr).data_lock);
}
pub unsafe extern "C" fn mdnsd_set_hostname_v6(
    mut svr: *mut mdnsd,
    mut hostname: *const libc::c_char,
    mut addr: *mut in6_addr,
) {
    let mut aaaa_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut nsec_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut tmp: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    aaaa_e = 0 as *mut libc::c_void as *mut rr_entry;
    nsec_e = 0 as *mut libc::c_void as *mut rr_entry;
    tmp = create_nlabel(hostname);
    aaaa_e = rr_create_aaaa(tmp, addr);
    tmp___0 = create_nlabel(hostname);
    nsec_e = rr_create(tmp___0, RR_NSEC);
    (*nsec_e).ttl = 120 as libc::c_int as uint32_t;
    rr_set_nsec(nsec_e, RR_AAAA);
    pthread_mutex_lock(&mut (*svr).data_lock);
    (*svr).hostname = create_nlabel(hostname);
    rr_group_add(&mut (*svr).group, aaaa_e);
    rr_group_add(&mut (*svr).group, nsec_e);
    pthread_mutex_unlock(&mut (*svr).data_lock);
}
pub unsafe extern "C" fn mdnsd_add_rr(mut svr: *mut mdnsd, mut rr: *mut rr_entry) {
    pthread_mutex_lock(&mut (*svr).data_lock);
    rr_group_add(&mut (*svr).group, rr);
    pthread_mutex_unlock(&mut (*svr).data_lock);
}
pub unsafe extern "C" fn mdnsd_register_svc(
    mut svr: *mut mdnsd,
    mut instance_name: *const libc::c_char,
    mut type_0: *const libc::c_char,
    mut port: uint16_t,
    mut hostname: *const libc::c_char,
    mut txt: *mut *const libc::c_char,
) -> *mut mdns_service {
    let mut txt_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut srv_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut ptr_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut bptr_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut target: *mut uint8_t = 0 as *mut uint8_t;
    let mut inst_nlabel: *mut uint8_t = 0 as *mut uint8_t;
    let mut type_nlabel: *mut uint8_t = 0 as *mut uint8_t;
    let mut nlabel: *mut uint8_t = 0 as *mut uint8_t;
    let mut service: *mut mdns_service = 0 as *mut mdns_service;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___1: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___2: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___3: *mut uint8_t = 0 as *mut uint8_t;
    let mut tmp___4: *mut uint8_t = 0 as *mut uint8_t;
    txt_e = 0 as *mut libc::c_void as *mut rr_entry;
    srv_e = 0 as *mut libc::c_void as *mut rr_entry;
    ptr_e = 0 as *mut libc::c_void as *mut rr_entry;
    bptr_e = 0 as *mut libc::c_void as *mut rr_entry;
    tmp = malloc(::std::mem::size_of::<mdns_service>() as libc::c_ulong);
    service = tmp as *mut mdns_service;
    memset(
        service as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<mdns_service>() as libc::c_ulong,
    );
    type_nlabel = create_nlabel(type_0);
    inst_nlabel = create_label(instance_name);
    nlabel = join_nlabel(inst_nlabel as *const uint8_t, type_nlabel as *const uint8_t);
    if !txt.is_null() {
        if !(*txt).is_null() {
            tmp___0 = dup_nlabel(nlabel as *const uint8_t);
            txt_e = rr_create(tmp___0, RR_TXT);
            rr_list_append(&mut (*service).entries, txt_e);
            while !(*txt).is_null() {
                rr_add_txt(txt_e, *txt);
                txt = txt.offset(1);
            }
        }
    }
    if !hostname.is_null() {
        tmp___1 = create_nlabel(hostname);
        target = tmp___1;
    } else {
        tmp___2 = dup_nlabel((*svr).hostname as *const uint8_t);
        target = tmp___2;
    }
    tmp___3 = dup_nlabel(nlabel as *const uint8_t);
    srv_e = rr_create_srv(tmp___3, port, target);
    rr_list_append(&mut (*service).entries, srv_e);
    ptr_e = rr_create_ptr(type_nlabel, srv_e);
    tmp___4 = dup_nlabel(
        b"\t_services\x07_dns-sd\x04_udp\x05local\0" as *const u8 as *const libc::c_char
            as *mut uint8_t as *const uint8_t,
    );
    bptr_e = rr_create_ptr(tmp___4, ptr_e);
    pthread_mutex_lock(&mut (*svr).data_lock);
    if !txt_e.is_null() {
        rr_group_add(&mut (*svr).group, txt_e);
    }
    rr_group_add(&mut (*svr).group, srv_e);
    rr_group_add(&mut (*svr).group, ptr_e);
    rr_group_add(&mut (*svr).group, bptr_e);
    rr_list_append(&mut (*svr).announce, ptr_e);
    rr_list_append(&mut (*svr).services, ptr_e);
    pthread_mutex_unlock(&mut (*svr).data_lock);
    free(nlabel as *mut libc::c_void);
    free(inst_nlabel as *mut libc::c_void);
    write_pipe(
        (*svr).notify_pipe[1 as libc::c_int as usize],
        b".\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        1 as libc::c_int,
    );
    return service;
}
pub unsafe extern "C" fn mdns_service_remove(
    mut svr: *mut mdnsd,
    mut svc: *mut mdns_service,
) {
    let mut rr: *mut rr_list = 0 as *mut rr_list;
    let mut g: *mut rr_group = 0 as *mut rr_group;
    let mut ptr_e: *mut rr_entry = 0 as *mut rr_entry;
    let mut bptr_e: *mut rr_entry = 0 as *mut rr_entry;
    pthread_mutex_lock(&mut (*svr).data_lock);
    rr = (*svc).entries;
    while !rr.is_null() {
        g = rr_group_find((*svr).group, (*(*rr).e).name);
        if g as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            rr_list_remove(&mut (*g).rr, (*rr).e);
        }
        ptr_e = rr_entry_remove((*svr).group, (*rr).e, RR_PTR);
        if ptr_e as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            rr_list_remove(&mut (*svr).announce, ptr_e);
            rr_list_remove(&mut (*svr).services, ptr_e);
            bptr_e = rr_entry_remove((*svr).group, ptr_e, RR_PTR);
            rr_entry_destroy(bptr_e);
            rr_list_append(&mut (*svr).leave, ptr_e);
        } else {
            rr_entry_destroy((*rr).e);
        }
        rr = (*rr).next;
    }
    rr_group_clean(&mut (*svr).group);
    rr_list_destroy((*svc).entries, 0 as libc::c_int as libc::c_char);
    free(svc as *mut libc::c_void);
    pthread_mutex_unlock(&mut (*svr).data_lock);
}
pub unsafe extern "C" fn mdns_service_destroy(mut srv: *mut mdns_service) {
    rr_list_destroy((*srv).entries, 0 as libc::c_int as libc::c_char);
    free(srv as *mut libc::c_void);
}
pub unsafe extern "C" fn mdnsd_start(mut host: in_addr) -> *mut mdnsd {
    let mut tid: pthread_t = 0;
    let mut attr: pthread_attr_t = pthread_attr_t { __size: [0; 56] };
    let mut server: *mut mdnsd = 0 as *mut mdnsd;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = malloc(::std::mem::size_of::<mdnsd>() as libc::c_ulong);
    server = tmp as *mut mdnsd;
    memset(
        server as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<mdnsd>() as libc::c_ulong,
    );
    tmp___0 = create_pipe(((*server).notify_pipe).as_mut_ptr());
    if tmp___0 != 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"pipe(): %m\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        free(server as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut mdnsd;
    }
    (*server).sockfd = create_recv_sock(host.s_addr);
    if (*server).sockfd < 0 as libc::c_int {
        log_message(
            3 as libc::c_int,
            b"unable to create recv socket\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        free(server as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut mdnsd;
    }
    pthread_mutex_init(
        &mut (*server).data_lock,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    pthread_attr_init(&mut attr);
    pthread_attr_setdetachstate(&mut attr, 1 as libc::c_int);
    tmp___1 = pthread_create(
        &mut tid as *mut pthread_t,
        &mut attr as *mut pthread_attr_t as *const pthread_attr_t,
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mdnsd) -> ()>,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
        >(Some(main_loop as unsafe extern "C" fn(*mut mdnsd) -> ())),
        server as *mut libc::c_void,
    );
    if tmp___1 != 0 as libc::c_int {
        pthread_mutex_destroy(&mut (*server).data_lock);
        free(server as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut mdnsd;
    }
    return server;
}
pub unsafe extern "C" fn mdnsd_stop(mut s: *mut mdnsd) {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    if s.is_null() {
        return;
    }
    tv.tv_sec = 0 as libc::c_int as __time_t;
    tv.tv_usec = 500000 as libc::c_int as __suseconds_t;
    (*s).stop_flag = 1 as libc::c_int;
    write_pipe(
        (*s).notify_pipe[1 as libc::c_int as usize],
        b".\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        1 as libc::c_int,
    );
    while (*s).stop_flag != 2 as libc::c_int {
        select(
            0 as libc::c_int,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            &mut tv as *mut timeval,
        );
    }
    close_pipe((*s).notify_pipe[0 as libc::c_int as usize]);
    close_pipe((*s).notify_pipe[1 as libc::c_int as usize]);
    pthread_mutex_destroy(&mut (*s).data_lock);
    rr_group_destroy((*s).group);
    rr_list_destroy((*s).announce, 0 as libc::c_int as libc::c_char);
    rr_list_destroy((*s).services, 0 as libc::c_int as libc::c_char);
    rr_list_destroy((*s).leave, 0 as libc::c_int as libc::c_char);
    if !((*s).hostname).is_null() {
        free((*s).hostname as *mut libc::c_void);
    }
    free(s as *mut libc::c_void);
}
static mut SSLhandle: *mut libc::c_void = 0 as *const libc::c_void as *mut libc::c_void;
static mut CRYPThandle: *mut libc::c_void = 0 as *const libc::c_void
    as *mut libc::c_void;
pub unsafe extern "C" fn load_ssl_symbols() -> bool {
    return 1 as libc::c_int != 0;
}
pub unsafe extern "C" fn free_ssl_symbols() {
    if !SSLhandle.is_null() {
        dlclose(SSLhandle);
    }
    if !CRYPThandle.is_null() {
        dlclose(CRYPThandle);
    }
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
unsafe extern "C" fn run_static_initializers() {
    dmap_field_count = (::std::mem::size_of::<[dmap_field; 268]>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<dmap_field>() as libc::c_ulong);
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
