use ::libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    static mut stderr: *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn abort() -> !;
    fn exit(_: libc::c_int) -> !;
    fn longjmp(_: *mut __jmp_buf_tag, _: libc::c_int) -> !;
    fn signal(
        __sig: libc::c_int,
        __handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    ) -> __sighandler_t;
    static mut stdout: *mut FILE;
    fn vsprintf(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn vsscanf(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    static mut stdin: *mut FILE;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn atexit(__func: Option::<unsafe extern "C" fn() -> ()>) -> libc::c_int;
    fn pthread_kill(__threadid: pthread_t, __signo: libc::c_int) -> libc::c_int;
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option::<
            unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_self() -> pthread_t;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn pthread_key_delete(__key: pthread_key_t) -> libc::c_int;
    fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
    fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const libc::c_void,
    ) -> libc::c_int;
    fn _setjmp(_: *mut __jmp_buf_tag) -> libc::c_int;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn vfscanf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn feof(__stream: *mut FILE) -> libc::c_int;
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type int64_t = __int64_t;
pub type uint64_t = __uint64_t;
pub type var = *mut libc::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Header {
    pub type_0: var,
    pub alloc: var,
    pub magic: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Int {
    pub val: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Tuple {
    pub items: *mut var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Example {
    pub name: *const libc::c_char,
    pub body: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Method {
    pub name: *const libc::c_char,
    pub definition: *const libc::c_char,
    pub description: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Doc {
    pub name: Option::<unsafe extern "C" fn() -> *const libc::c_char>,
    pub brief: Option::<unsafe extern "C" fn() -> *const libc::c_char>,
    pub description: Option::<unsafe extern "C" fn() -> *const libc::c_char>,
    pub definition: Option::<unsafe extern "C" fn() -> *const libc::c_char>,
    pub examples: Option::<unsafe extern "C" fn() -> *mut Example>,
    pub methods: Option::<unsafe extern "C" fn() -> *mut Method>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct New {
    pub construct_with: Option::<unsafe extern "C" fn(var, var) -> ()>,
    pub destruct: Option::<unsafe extern "C" fn(var) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Assign {
    pub assign: Option::<unsafe extern "C" fn(var, var) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Cmp {
    pub cmp: Option::<unsafe extern "C" fn(var, var) -> libc::c_int>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Hash {
    pub hash: Option::<unsafe extern "C" fn(var) -> uint64_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Len {
    pub len: Option::<unsafe extern "C" fn(var) -> size_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Get {
    pub get: Option::<unsafe extern "C" fn(var, var) -> var>,
    pub set: Option::<unsafe extern "C" fn(var, var, var) -> ()>,
    pub mem: Option::<unsafe extern "C" fn(var, var) -> bool>,
    pub rem: Option::<unsafe extern "C" fn(var, var) -> ()>,
    pub key_type: Option::<unsafe extern "C" fn(var) -> var>,
    pub val_type: Option::<unsafe extern "C" fn(var) -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Iter {
    pub iter_init: Option::<unsafe extern "C" fn(var) -> var>,
    pub iter_next: Option::<unsafe extern "C" fn(var, var) -> var>,
    pub iter_last: Option::<unsafe extern "C" fn(var) -> var>,
    pub iter_prev: Option::<unsafe extern "C" fn(var, var) -> var>,
    pub iter_type: Option::<unsafe extern "C" fn(var) -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Resize {
    pub resize: Option::<unsafe extern "C" fn(var, size_t) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Show {
    pub show: Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
    pub look: Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Mark {
    pub mark: Option::<
        unsafe extern "C" fn(
            var,
            var,
            Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Table {
    pub data: var,
    pub ktype: var,
    pub vtype: var,
    pub ksize: size_t,
    pub vsize: size_t,
    pub nslots: size_t,
    pub nitems: size_t,
    pub sspace0: var,
    pub sspace1: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Range {
    pub value: var,
    pub start: int64_t,
    pub stop: int64_t,
    pub step: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Slice {
    pub iter: var,
    pub range: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Zip {
    pub iters: var,
    pub values: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Filter {
    pub iter: var,
    pub func: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Map {
    pub iter: var,
    pub curr: var,
    pub func: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Call {
    pub call_with: Option::<unsafe extern "C" fn(var, var) -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Swap {
    pub swap: Option::<unsafe extern "C" fn(var, var) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Push {
    pub push: Option::<unsafe extern "C" fn(var, var) -> ()>,
    pub pop: Option::<unsafe extern "C" fn(var) -> ()>,
    pub push_at: Option::<unsafe extern "C" fn(var, var, var) -> ()>,
    pub pop_at: Option::<unsafe extern "C" fn(var, var) -> ()>,
}
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___sigset_t_991265788 {
    pub __val: [libc::c_ulong; 16],
}
pub type __sigset_t = __anonstruct___sigset_t_991265788;
pub type __jmp_buf = [libc::c_long; 8];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
    pub __saved_mask: __sigset_t,
}
pub type jmp_buf = [__jmp_buf_tag; 1];
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct String_0 {
    pub val: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct File {
    pub file: *mut FILE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Current {
    pub current: Option::<unsafe extern "C" fn() -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Start {
    pub start: Option::<unsafe extern "C" fn(var) -> ()>,
    pub stop: Option::<unsafe extern "C" fn(var) -> ()>,
    pub join: Option::<unsafe extern "C" fn(var) -> ()>,
    pub running: Option::<unsafe extern "C" fn(var) -> bool>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Exception {
    pub obj: var,
    pub msg: var,
    pub depth: size_t,
    pub active: bool,
    pub buffers: [*mut jmp_buf; 2048],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Help {
    pub help_to: Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list___0 = __gnuc_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Concat {
    pub concat: Option::<unsafe extern "C" fn(var, var) -> ()>,
    pub append: Option::<unsafe extern "C" fn(var, var) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C_Str {
    pub c_str: Option::<unsafe extern "C" fn(var) -> *mut libc::c_char>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Format {
    pub format_to: Option::<
        unsafe extern "C" fn(
            var,
            libc::c_int,
            *const libc::c_char,
            ::std::ffi::VaList,
        ) -> libc::c_int,
    >,
    pub format_from: Option::<
        unsafe extern "C" fn(
            var,
            libc::c_int,
            *const libc::c_char,
            ::std::ffi::VaList,
        ) -> libc::c_int,
    >,
}
pub type uintptr_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Type {
    pub cls: var,
    pub name: var,
    pub inst: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Cast {
    pub cast: Option::<unsafe extern "C" fn(var, var) -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Size {
    pub size: Option::<unsafe extern "C" fn() -> size_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Alloc {
    pub alloc: Option::<unsafe extern "C" fn() -> var>,
    pub dealloc: Option::<unsafe extern "C" fn(var) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Copy_0 {
    pub copy: Option::<unsafe extern "C" fn(var) -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct List {
    pub type_0: var,
    pub head: var,
    pub tail: var,
    pub tsize: size_t,
    pub nitems: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Sort {
    pub sort_by: Option::<
        unsafe extern "C" fn(var, Option::<unsafe extern "C" fn(var, var) -> bool>) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Ref {
    pub val: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Box_0 {
    pub val: var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Pointer {
    pub ref_0: Option::<unsafe extern "C" fn(var, var) -> ()>,
    pub deref: Option::<unsafe extern "C" fn(var) -> var>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Tree {
    pub root: var,
    pub ktype: var,
    pub vtype: var,
    pub ksize: size_t,
    pub vsize: size_t,
    pub nitems: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Float {
    pub val: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Function {
    pub func: Option::<unsafe extern "C" fn(var) -> var>,
}
pub type intptr_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C_Int {
    pub c_int: Option::<unsafe extern "C" fn(var) -> int64_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C_Float {
    pub c_float: Option::<unsafe extern "C" fn(var) -> libc::c_double>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union interp_cast {
    pub as_flt: libc::c_double,
    pub as_int: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
pub type pthread_key_t = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Lock {
    pub lock: Option::<unsafe extern "C" fn(var) -> ()>,
    pub unlock: Option::<unsafe extern "C" fn(var) -> ()>,
    pub trylock: Option::<unsafe extern "C" fn(var) -> bool>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Thread {
    pub func: var,
    pub args: var,
    pub tls: var,
    pub is_main: bool,
    pub is_running: bool,
    pub thread: pthread_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GC {
    pub entries: *mut GCEntry,
    pub nslots: size_t,
    pub nitems: size_t,
    pub mitems: size_t,
    pub maxptr: uintptr_t,
    pub minptr: uintptr_t,
    pub bottom: var,
    pub running: bool,
    pub freenum: uintptr_t,
    pub freelist: *mut var,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GCEntry {
    pub ptr: var,
    pub hash: uint64_t,
    pub root: bool,
    pub marked: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Mutex {
    pub mutex: pthread_mutex_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Array {
    pub type_0: var,
    pub data: var,
    pub tsize: size_t,
    pub nitems: size_t,
    pub nslots: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Process {
    pub proc_0: *mut FILE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Stream {
    pub sopen: Option::<unsafe extern "C" fn(var, var, var) -> var>,
    pub sclose: Option::<unsafe extern "C" fn(var) -> ()>,
    pub sseek: Option::<unsafe extern "C" fn(var, int64_t, libc::c_int) -> ()>,
    pub stell: Option::<unsafe extern "C" fn(var) -> int64_t>,
    pub sflush: Option::<unsafe extern "C" fn(var) -> ()>,
    pub seof: Option::<unsafe extern "C" fn(var) -> bool>,
    pub sread: Option::<unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t>,
    pub swrite: Option::<unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t>,
}
unsafe extern "C" fn Table_Name() -> *const libc::c_char {
    return b"Table\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Table_Brief() -> *const libc::c_char {
    return b"Hash table\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Table_Description() -> *const libc::c_char {
    return b"The `Table` type is a hash table data structure that maps keys to values. It uses an open-addressing robin-hood hashing scheme which requires `Hash` and `Cmp` to be defined on the key type. Keys and values are copied into the collection using the `Assign` class and intially have zero'd memory.\n\nHash tables provide `O(1)` lookup, insertion and removal can but require long pauses when the table must be _rehashed_ and all entries processed.\n\nThis is largely equivalent to the C++ construct [std::unordered_map](http://www.cplusplus.com/reference/unordered_map/unordered_map/)\0"
        as *const u8 as *const libc::c_char;
}
static mut examples: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var prices = new(Table, String, Int);\nset(prices, $S(\"Apple\"),  $I(12));\nset(prices, $S(\"Banana\"), $I( 6));\nset(prices, $S(\"Pear\"),   $I(55));\n\nforeach (key in prices) {\n  var price = get(prices, key);\n  println(\"Price of %$ is %$\", key, price);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Manipulation\0" as *const u8 as *const libc::c_char,
            body: b"var t = new(Table, String, Int);\nset(t, $S(\"Hello\"), $I(2));\nset(t, $S(\"There\"), $I(5));\n\nshow($I(len(t))); /* 2 */\nshow($I(mem(t, $S(\"Hello\")))); /* 1 */\n\nrem(t, $S(\"Hello\"));\n\nshow($I(len(t))); /* 1 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 1 */\n\nresize(t, 0);\n\nshow($I(len(t))); /* 0 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 0 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Table_Examples() -> *mut Example {
    return examples.as_mut_ptr();
}
static mut Table_Primes: [size_t; 24] = [
    0 as libc::c_int as size_t,
    1 as libc::c_int as size_t,
    5 as libc::c_int as size_t,
    11 as libc::c_int as size_t,
    23 as libc::c_int as size_t,
    53 as libc::c_int as size_t,
    101 as libc::c_int as size_t,
    197 as libc::c_int as size_t,
    389 as libc::c_int as size_t,
    683 as libc::c_int as size_t,
    1259 as libc::c_int as size_t,
    2417 as libc::c_int as size_t,
    4733 as libc::c_int as size_t,
    9371 as libc::c_int as size_t,
    18617 as libc::c_int as size_t,
    37097 as libc::c_int as size_t,
    74093 as libc::c_int as size_t,
    148073 as libc::c_int as size_t,
    296099 as libc::c_int as size_t,
    592019 as libc::c_int as size_t,
    1100009 as libc::c_int as size_t,
    2200013 as libc::c_int as size_t,
    4400021 as libc::c_int as size_t,
    8800019 as libc::c_int as size_t,
];
static mut Table_Load_Factor: libc::c_double = 0.9f64;
unsafe extern "C" fn Table_Ideal_Size(mut size___0: size_t) -> size_t {
    let mut i: size_t = 0;
    let mut last: size_t = 0;
    let mut i___0: size_t = 0;
    size___0 = (size___0.wrapping_add(1 as libc::c_ulong) as libc::c_double
        / Table_Load_Factor) as size_t;
    i = 0 as libc::c_int as size_t;
    while i < 24 as libc::c_ulong {
        if Table_Primes[i as usize] >= size___0 {
            return Table_Primes[i as usize];
        }
        i = i.wrapping_add(1);
    }
    last = Table_Primes[23 as libc::c_int as usize];
    i___0 = 0 as libc::c_int as size_t;
    loop {
        if last.wrapping_mul(i___0) >= size___0 {
            return last.wrapping_mul(i___0);
        }
        i___0 = i___0.wrapping_add(1);
    };
}
unsafe extern "C" fn Table_Step(mut t: *mut Table) -> size_t {
    return (::std::mem::size_of::<uint64_t>() as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong)
        .wrapping_add((*t).ksize)
        .wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong)
        .wrapping_add((*t).vsize);
}
unsafe extern "C" fn Table_Key_Hash(mut t: *mut Table, mut i: uint64_t) -> uint64_t {
    let mut tmp: size_t = 0;
    tmp = Table_Step(t);
    return *(((*t).data as *mut libc::c_char).offset(i.wrapping_mul(tmp) as isize)
        as *mut uint64_t);
}
unsafe extern "C" fn Table_Key(mut t: *mut Table, mut i: uint64_t) -> var {
    let mut tmp: size_t = 0;
    tmp = Table_Step(t);
    return ((*t).data as *mut libc::c_char)
        .offset(i.wrapping_mul(tmp) as isize)
        .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Table_Val(mut t: *mut Table, mut i: uint64_t) -> var {
    let mut tmp: size_t = 0;
    tmp = Table_Step(t);
    return ((*t).data as *mut libc::c_char)
        .offset(i.wrapping_mul(tmp) as isize)
        .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
        .offset((*t).ksize as isize)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Table_Probe(
    mut t: *mut Table,
    mut i: uint64_t,
    mut h: uint64_t,
) -> uint64_t {
    let mut v: int64_t = 0;
    v = i.wrapping_sub(h.wrapping_sub(1 as libc::c_ulong)) as int64_t;
    if v < 0 as libc::c_long {
        v = ((*t).nslots).wrapping_add(v as size_t) as int64_t;
    }
    return v as uint64_t;
}
unsafe extern "C" fn Table_Size_Round(mut s: size_t) -> size_t {
    return s
        .wrapping_add(::std::mem::size_of::<var>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<var>() as libc::c_ulong)
        .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong);
}
unsafe extern "C" fn Table_New(mut self_0: var, mut args: var) {
    let mut current_block: u64;
    let mut t: *mut Table = 0 as *mut Table;
    let mut __constr_expr_0: Int = Int { val: 0 };
    let mut __constr_expr_1: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_2: Int = Int { val: 0 };
    let mut __constr_expr_3: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut nargs: size_t = 0;
    let mut tmp___9: size_t = 0;
    let mut __constr_expr_4: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_5: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_6: [libc::c_char; 32] = [0; 32];
    let mut tmp___10: libc::c_uint = 0;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: size_t = 0;
    let mut tmp___14: size_t = 0;
    let mut tmp___15: size_t = 0;
    let mut __constr_expr_7: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_8: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_9: [libc::c_char; 32] = [0; 32];
    let mut tmp___16: libc::c_uint = 0;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut tmp___18: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut key: var = 0 as *mut libc::c_void;
    let mut __constr_expr_10: Int = Int { val: 0 };
    let mut __constr_expr_11: [libc::c_char; 32] = [0; 32];
    let mut tmp___19: libc::c_uint = 0;
    let mut tmp___20: var = 0 as *mut libc::c_void;
    let mut tmp___21: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___22: var = 0 as *mut libc::c_void;
    let mut val: var = 0 as *mut libc::c_void;
    let mut __constr_expr_12: Int = Int { val: 0 };
    let mut __constr_expr_13: [libc::c_char; 32] = [0; 32];
    let mut tmp___23: libc::c_uint = 0;
    let mut tmp___24: var = 0 as *mut libc::c_void;
    let mut tmp___25: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___26: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Table;
    __constr_expr_0.val = 0 as libc::c_int as int64_t;
    __constr_expr_1[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_1.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_0 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    (*t).ktype = cast(tmp___2, Type);
    __constr_expr_2.val = 1 as libc::c_int as int64_t;
    __constr_expr_3[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___3 = 1 as libc::c_uint;
    while !(tmp___3 >= 32 as libc::c_uint) {
        __constr_expr_3[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = tmp___3.wrapping_add(1);
    }
    tmp___4 = header_init(__constr_expr_3.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___5 = memcpy(
        tmp___4 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_2 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___6 = get(args, tmp___5 as *mut Int as var);
    (*t).vtype = cast(tmp___6, Type);
    tmp___7 = size((*t).ktype);
    (*t).ksize = Table_Size_Round(tmp___7);
    tmp___8 = size((*t).vtype);
    (*t).vsize = Table_Size_Round(tmp___8);
    tmp___9 = len(args);
    nargs = tmp___9;
    if nargs.wrapping_rem(2 as libc::c_ulong) != 0 as libc::c_ulong {
        __constr_expr_5[0 as libc::c_int as usize] = Terminal;
        __constr_expr_4.items = __constr_expr_5.as_mut_ptr();
        __constr_expr_6[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___10 = 1 as libc::c_uint;
        while !(tmp___10 >= 32 as libc::c_uint) {
            __constr_expr_6[tmp___10 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___10 = tmp___10.wrapping_add(1);
        }
        tmp___11 = header_init(
            __constr_expr_6.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___12 = memcpy(
            tmp___11 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_4 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Received non multiple of two argument count to Table constructor.\0"
                as *const u8 as *const libc::c_char,
            tmp___12 as *mut Tuple as var,
        );
    }
    (*t)
        .nslots = Table_Ideal_Size(
        nargs.wrapping_sub(2 as libc::c_ulong).wrapping_div(2 as libc::c_ulong),
    );
    (*t).nitems = 0 as libc::c_int as size_t;
    if (*t).nslots == 0 as libc::c_ulong {
        (*t).data = 0 as *mut libc::c_void;
        return;
    }
    tmp___13 = Table_Step(t);
    (*t).data = calloc((*t).nslots, tmp___13);
    tmp___14 = Table_Step(t);
    (*t).sspace0 = calloc(1 as libc::c_int as size_t, tmp___14);
    tmp___15 = Table_Step(t);
    (*t).sspace1 = calloc(1 as libc::c_int as size_t, tmp___15);
    if (*t).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        current_block = 893840610683604123;
    } else if (*t).sspace0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        current_block = 893840610683604123;
    } else if (*t).sspace1 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        current_block = 893840610683604123;
    } else {
        current_block = 15970011996474399071;
    }
    match current_block {
        893840610683604123 => {
            __constr_expr_8[0 as libc::c_int as usize] = Terminal;
            __constr_expr_7.items = __constr_expr_8.as_mut_ptr();
            __constr_expr_9[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___16 = 1 as libc::c_uint;
            while !(tmp___16 >= 32 as libc::c_uint) {
                __constr_expr_9[tmp___16 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___16 = tmp___16.wrapping_add(1);
            }
            tmp___17 = header_init(
                __constr_expr_9.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___18 = memcpy(
                tmp___17 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_7 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                OutOfMemoryError,
                b"Cannot allocate Table, out of memory!\0" as *const u8
                    as *const libc::c_char,
                tmp___18 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    i = 0 as libc::c_int as size_t;
    while i < nargs.wrapping_sub(2 as libc::c_ulong).wrapping_div(2 as libc::c_ulong) {
        __constr_expr_10
            .val = (2 as libc::c_ulong).wrapping_add(i.wrapping_mul(2 as libc::c_ulong))
            as int64_t;
        __constr_expr_11[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___19 = 1 as libc::c_uint;
        while !(tmp___19 >= 32 as libc::c_uint) {
            __constr_expr_11[tmp___19 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___19 = tmp___19.wrapping_add(1);
        }
        tmp___20 = header_init(
            __constr_expr_11.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___21 = memcpy(
            tmp___20 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_10 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___22 = get(args, tmp___21 as *mut Int as var);
        key = tmp___22;
        __constr_expr_12
            .val = (2 as libc::c_ulong)
            .wrapping_add(i.wrapping_mul(2 as libc::c_ulong))
            .wrapping_add(1 as libc::c_ulong) as int64_t;
        __constr_expr_13[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___23 = 1 as libc::c_uint;
        while !(tmp___23 >= 32 as libc::c_uint) {
            __constr_expr_13[tmp___23 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___23 = tmp___23.wrapping_add(1);
        }
        tmp___24 = header_init(
            __constr_expr_13.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___25 = memcpy(
            tmp___24 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_12 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___26 = get(args, tmp___25 as *mut Int as var);
        val = tmp___26;
        Table_Set_Move(t as var, key, val, 0 as libc::c_int != 0);
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn Table_Del(mut self_0: var) {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: uint64_t = 0;
    t = self_0 as *mut Table;
    i = 0 as libc::c_int as size_t;
    while i < (*t).nslots {
        tmp___1 = Table_Key_Hash(t, i);
        if tmp___1 != 0 as libc::c_ulong {
            tmp = Table_Key(t, i);
            destruct(tmp);
            tmp___0 = Table_Val(t, i);
            destruct(tmp___0);
        }
        i = i.wrapping_add(1);
    }
    free((*t).data);
    free((*t).sspace0);
    free((*t).sspace1);
}
unsafe extern "C" fn Table_Key_Type(mut self_0: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    t = self_0 as *mut Table;
    return (*t).ktype;
}
unsafe extern "C" fn Table_Val_Type(mut self_0: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    t = self_0 as *mut Table;
    return (*t).vtype;
}
unsafe extern "C" fn Table_Clear(mut self_0: var) {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: uint64_t = 0;
    t = self_0 as *mut Table;
    i = 0 as libc::c_int as size_t;
    while i < (*t).nslots {
        tmp___1 = Table_Key_Hash(t, i);
        if tmp___1 != 0 as libc::c_ulong {
            tmp = Table_Key(t, i);
            destruct(tmp);
            tmp___0 = Table_Val(t, i);
            destruct(tmp___0);
        }
        i = i.wrapping_add(1);
    }
    free((*t).data);
    (*t).nslots = 0 as libc::c_int as size_t;
    (*t).nitems = 0 as libc::c_int as size_t;
    (*t).data = 0 as *mut libc::c_void;
}
unsafe extern "C" fn Table_Assign(mut self_0: var, mut obj: var) {
    let mut current_block: u64;
    let mut t: *mut Table = 0 as *mut Table;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: bool = false;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: size_t = 0;
    let mut __constr_expr_14: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_15: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_16: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: size_t = 0;
    let mut tmp___15: size_t = 0;
    let mut __key: var = 0 as *mut libc::c_void;
    let mut __Iterkey: var = 0 as *mut libc::c_void;
    let mut tmp___16: var = 0 as *mut libc::c_void;
    let mut key: var = 0 as *mut libc::c_void;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut tmp___18: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Table;
    Table_Clear(t as var);
    tmp___1 = implements_method_at_offset(
        obj,
        Get,
        &mut (*(0 as *mut Get)).key_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
    );
    if tmp___1 {
        tmp___0 = key_type(obj);
        (*t).ktype = tmp___0;
    } else {
        (*t).ktype = Ref;
    }
    tmp___4 = implements_method_at_offset(
        obj,
        Get,
        &mut (*(0 as *mut Get)).val_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
    );
    if tmp___4 {
        tmp___3 = val_type(obj);
        (*t).vtype = tmp___3;
    } else {
        (*t).vtype = Ref;
    }
    tmp___5 = size((*t).ktype);
    (*t).ksize = Table_Size_Round(tmp___5);
    tmp___6 = size((*t).vtype);
    (*t).vsize = Table_Size_Round(tmp___6);
    (*t).nitems = 0 as libc::c_int as size_t;
    tmp___7 = len(obj);
    (*t).nslots = Table_Ideal_Size(tmp___7);
    if (*t).nslots == 0 as libc::c_ulong {
        (*t).data = 0 as *mut libc::c_void;
        return;
    }
    tmp___8 = Table_Step(t);
    (*t).data = calloc((*t).nslots, tmp___8);
    tmp___9 = Table_Step(t);
    (*t).sspace0 = realloc((*t).sspace0, tmp___9);
    tmp___10 = Table_Step(t);
    (*t).sspace1 = realloc((*t).sspace1, tmp___10);
    if (*t).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        current_block = 7614542266110962583;
    } else if (*t).sspace0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        current_block = 7614542266110962583;
    } else if (*t).sspace1 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        current_block = 7614542266110962583;
    } else {
        current_block = 1356832168064818221;
    }
    match current_block {
        7614542266110962583 => {
            __constr_expr_15[0 as libc::c_int as usize] = Terminal;
            __constr_expr_14.items = __constr_expr_15.as_mut_ptr();
            __constr_expr_16[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___11 = 1 as libc::c_uint;
            while !(tmp___11 >= 32 as libc::c_uint) {
                __constr_expr_16[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___11 = tmp___11.wrapping_add(1);
            }
            tmp___12 = header_init(
                __constr_expr_16.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___13 = memcpy(
                tmp___12 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_14 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                OutOfMemoryError,
                b"Cannot allocate Table, out of memory!\0" as *const u8
                    as *const libc::c_char,
                tmp___13 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___14 = Table_Step(t);
    memset((*t).sspace0, 0 as libc::c_int, tmp___14);
    tmp___15 = Table_Step(t);
    memset((*t).sspace1, 0 as libc::c_int, tmp___15);
    __key = obj;
    tmp___16 = instance(__key, Iter);
    __Iterkey = tmp___16;
    tmp___17 = (Some(
        ((*(__Iterkey as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__key);
    key = tmp___17;
    while key as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___18 = get(obj, key);
        Table_Set_Move(t as var, key, tmp___18, 0 as libc::c_int != 0);
        key = (Some(
            ((*(__Iterkey as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__key, key);
    }
}
unsafe extern "C" fn Table_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut item0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item1: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    tmp = Table_Iter_Init(self_0);
    item0 = tmp;
    tmp___0 = iter_init(obj);
    item1 = tmp___0;
    loop {
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            if item1 as libc::c_ulong == Terminal as libc::c_ulong {
                return 0 as libc::c_int;
            }
        }
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if item1 as libc::c_ulong == Terminal as libc::c_ulong {
            return 1 as libc::c_int;
        }
        c = cmp(item0, item1);
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        tmp___1 = get(obj, item1);
        tmp___2 = Table_Get(self_0, item0);
        c = cmp(tmp___2, tmp___1);
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        item0 = Table_Iter_Next(self_0, item0);
        item1 = iter_next(obj, item1);
    };
}
unsafe extern "C" fn Table_Hash(mut self_0: var) -> uint64_t {
    let mut t: *mut Table = 0 as *mut Table;
    let mut h: uint64_t = 0;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut vurr: var = 0 as *mut libc::c_void;
    let mut tmp___0: uint64_t = 0;
    let mut tmp___1: uint64_t = 0;
    t = self_0 as *mut Table;
    h = 0 as libc::c_int as uint64_t;
    tmp = Table_Iter_Init(self_0);
    curr = tmp;
    while curr as libc::c_ulong != Terminal as libc::c_ulong {
        vurr = (curr as *mut libc::c_char)
            .offset((*t).ksize as isize)
            .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
        tmp___0 = hash(curr);
        tmp___1 = hash(vurr);
        h = h ^ tmp___0 ^ tmp___1;
        curr = Table_Iter_Next(self_0, curr);
    }
    return h;
}
unsafe extern "C" fn Table_Len(mut self_0: var) -> size_t {
    let mut t: *mut Table = 0 as *mut Table;
    t = self_0 as *mut Table;
    return (*t).nitems;
}
unsafe extern "C" fn Table_Swapspace_Key(mut t: *mut Table, mut space: var) -> var {
    return (space as *mut libc::c_char)
        .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Table_Set_Move(
    mut self_0: var,
    mut key: var,
    mut val: var,
    mut move_0: bool,
) {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut ihash: uint64_t = 0;
    let mut khead: *mut Header = 0 as *mut Header;
    let mut vhead: *mut Header = 0 as *mut Header;
    let mut ihash___0: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___2: uint64_t = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: bool = false;
    let mut p: uint64_t = 0;
    let mut tmp___12: uint64_t = 0;
    let mut tmp___13: size_t = 0;
    let mut tmp___14: size_t = 0;
    let mut tmp___15: size_t = 0;
    let mut tmp___16: size_t = 0;
    let mut tmp___17: size_t = 0;
    t = self_0 as *mut Table;
    key = cast(key, (*t).ktype);
    val = cast(val, (*t).vtype);
    tmp = hash(key);
    i = tmp.wrapping_rem((*t).nslots);
    j = 0 as libc::c_int as uint64_t;
    tmp___0 = Table_Step(t);
    memset((*t).sspace0, 0 as libc::c_int, tmp___0);
    tmp___1 = Table_Step(t);
    memset((*t).sspace1, 0 as libc::c_int, tmp___1);
    if move_0 {
        ihash = i.wrapping_add(1 as libc::c_ulong);
        memcpy(
            (*t).sspace0 as *mut libc::c_char as *mut libc::c_void,
            &mut ihash as *mut uint64_t as *const libc::c_void,
            ::std::mem::size_of::<uint64_t>() as libc::c_ulong,
        );
        memcpy(
            ((*t).sspace0 as *mut libc::c_char)
                .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
                as *mut libc::c_void,
            (key as *mut libc::c_char)
                .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
                as *const libc::c_void,
            ((*t).ksize).wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong),
        );
        memcpy(
            ((*t).sspace0 as *mut libc::c_char)
                .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                .offset((*t).ksize as isize) as *mut libc::c_void,
            (val as *mut libc::c_char)
                .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
                as *const libc::c_void,
            ((*t).vsize).wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong),
        );
    } else {
        khead = ((*t).sspace0 as *mut libc::c_char)
            .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
            as *mut Header;
        vhead = ((*t).sspace0 as *mut libc::c_char)
            .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
            .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
            .offset((*t).ksize as isize) as *mut Header;
        header_init(khead as var, (*t).ktype, 4 as libc::c_int);
        header_init(vhead as var, (*t).vtype, 4 as libc::c_int);
        ihash___0 = i.wrapping_add(1 as libc::c_ulong);
        memcpy(
            (*t).sspace0 as *mut libc::c_char as *mut libc::c_void,
            &mut ihash___0 as *mut uint64_t as *const libc::c_void,
            ::std::mem::size_of::<uint64_t>() as libc::c_ulong,
        );
        assign(
            ((*t).sspace0 as *mut libc::c_char)
                .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                as var,
            key,
        );
        assign(
            ((*t).sspace0 as *mut libc::c_char)
                .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                .offset((*t).ksize as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                as var,
            val,
        );
    }
    loop {
        tmp___2 = Table_Key_Hash(t, i);
        h = tmp___2;
        if h == 0 as libc::c_ulong {
            tmp___3 = Table_Step(t);
            tmp___4 = Table_Step(t);
            memcpy(
                ((*t).data as *mut libc::c_char).offset(i.wrapping_mul(tmp___4) as isize)
                    as *mut libc::c_void,
                (*t).sspace0 as *const libc::c_void,
                tmp___3,
            );
            (*t).nitems = ((*t).nitems).wrapping_add(1);
            return;
        }
        tmp___9 = Table_Swapspace_Key(t, (*t).sspace0);
        tmp___10 = Table_Key(t, i);
        tmp___11 = eq(tmp___10, tmp___9);
        if tmp___11 {
            tmp___5 = Table_Key(t, i);
            destruct(tmp___5);
            tmp___6 = Table_Val(t, i);
            destruct(tmp___6);
            tmp___7 = Table_Step(t);
            tmp___8 = Table_Step(t);
            memcpy(
                ((*t).data as *mut libc::c_char).offset(i.wrapping_mul(tmp___8) as isize)
                    as *mut libc::c_void,
                (*t).sspace0 as *const libc::c_void,
                tmp___7,
            );
            return;
        }
        tmp___12 = Table_Probe(t, i, h);
        p = tmp___12;
        if j >= p {
            tmp___13 = Table_Step(t);
            tmp___14 = Table_Step(t);
            memcpy(
                (*t).sspace1 as *mut libc::c_char as *mut libc::c_void,
                ((*t).data as *mut libc::c_char)
                    .offset(i.wrapping_mul(tmp___14) as isize) as *const libc::c_void,
                tmp___13,
            );
            tmp___15 = Table_Step(t);
            tmp___16 = Table_Step(t);
            memcpy(
                ((*t).data as *mut libc::c_char)
                    .offset(i.wrapping_mul(tmp___16) as isize) as *mut libc::c_void,
                (*t).sspace0 as *mut libc::c_char as *const libc::c_void,
                tmp___15,
            );
            tmp___17 = Table_Step(t);
            memcpy(
                (*t).sspace0 as *mut libc::c_char as *mut libc::c_void,
                (*t).sspace1 as *mut libc::c_char as *const libc::c_void,
                tmp___17,
            );
            j = p;
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*t).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn Table_Rehash(mut t: *mut Table, mut new_size: size_t) {
    let mut old_data: var = 0 as *mut libc::c_void;
    let mut old_size: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __constr_expr_17: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_18: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_19: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___3: size_t = 0;
    let mut key: var = 0 as *mut libc::c_void;
    let mut tmp___4: size_t = 0;
    let mut val: var = 0 as *mut libc::c_void;
    let mut tmp___5: size_t = 0;
    old_data = (*t).data;
    old_size = (*t).nslots;
    (*t).nslots = new_size;
    (*t).nitems = 0 as libc::c_int as size_t;
    tmp = Table_Step(t);
    (*t).data = calloc((*t).nslots, tmp);
    if (*t).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_18[0 as libc::c_int as usize] = Terminal;
        __constr_expr_17.items = __constr_expr_18.as_mut_ptr();
        __constr_expr_19[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_19[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_19.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_17 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate Table, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    i = 0 as libc::c_int as size_t;
    while i < old_size {
        tmp___3 = Table_Step(t);
        h = *((old_data as *mut libc::c_char).offset(i.wrapping_mul(tmp___3) as isize)
            as *mut uint64_t);
        if h != 0 as libc::c_ulong {
            tmp___4 = Table_Step(t);
            key = (old_data as *mut libc::c_char)
                .offset(i.wrapping_mul(tmp___4) as isize)
                .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                as var;
            tmp___5 = Table_Step(t);
            val = (old_data as *mut libc::c_char)
                .offset(i.wrapping_mul(tmp___5) as isize)
                .offset(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                .offset((*t).ksize as isize)
                .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
                as var;
            Table_Set_Move(t as var, key, val, 1 as libc::c_int != 0);
        }
        i = i.wrapping_add(1);
    }
    free(old_data);
}
unsafe extern "C" fn Table_Resize_More(mut t: *mut Table) {
    let mut new_size: size_t = 0;
    let mut tmp: size_t = 0;
    let mut old_size: size_t = 0;
    tmp = Table_Ideal_Size((*t).nitems);
    new_size = tmp;
    old_size = (*t).nslots;
    if new_size > old_size {
        Table_Rehash(t, new_size);
    }
}
unsafe extern "C" fn Table_Resize_Less(mut t: *mut Table) {
    let mut new_size: size_t = 0;
    let mut tmp: size_t = 0;
    let mut old_size: size_t = 0;
    tmp = Table_Ideal_Size((*t).nitems);
    new_size = tmp;
    old_size = (*t).nslots;
    if new_size < old_size {
        Table_Rehash(t, new_size);
    }
}
unsafe extern "C" fn Table_Mem(mut self_0: var, mut key: var) -> bool {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___0: uint64_t = 0;
    let mut tmp___1: uint64_t = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: bool = false;
    t = self_0 as *mut Table;
    key = cast(key, (*t).ktype);
    if (*t).nslots == 0 as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    tmp = hash(key);
    i = tmp.wrapping_rem((*t).nslots);
    j = 0 as libc::c_int as uint64_t;
    loop {
        tmp___0 = Table_Key_Hash(t, i);
        h = tmp___0;
        if h == 0 as libc::c_ulong {
            return 0 as libc::c_int != 0
        } else {
            tmp___1 = Table_Probe(t, i, h);
            if j > tmp___1 {
                return 0 as libc::c_int != 0;
            }
        }
        tmp___2 = Table_Key(t, i);
        tmp___3 = eq(tmp___2, key);
        if tmp___3 {
            return 1 as libc::c_int != 0;
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*t).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn Table_Rem(mut self_0: var, mut key: var) {
    let mut t: *mut Table = 0 as *mut Table;
    let mut __constr_expr_20: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_21: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_22: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: uint64_t = 0;
    let mut tmp___2: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___3: uint64_t = 0;
    let mut __constr_expr_23: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_24: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_25: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: uint64_t = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: size_t = 0;
    let mut tmp___11: size_t = 0;
    let mut ni: uint64_t = 0;
    let mut nh: uint64_t = 0;
    let mut tmp___12: uint64_t = 0;
    let mut tmp___13: size_t = 0;
    let mut tmp___14: size_t = 0;
    let mut tmp___15: size_t = 0;
    let mut tmp___16: size_t = 0;
    let mut tmp___17: size_t = 0;
    let mut tmp___18: uint64_t = 0;
    let mut tmp___19: var = 0 as *mut libc::c_void;
    let mut tmp___20: bool = false;
    t = self_0 as *mut Table;
    key = cast(key, (*t).ktype);
    if (*t).nslots == 0 as libc::c_ulong {
        __constr_expr_21[0 as libc::c_int as usize] = key;
        __constr_expr_21[1 as libc::c_int as usize] = Terminal;
        __constr_expr_20.items = __constr_expr_21.as_mut_ptr();
        __constr_expr_22[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_22[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_22.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_20 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            KeyError,
            b"Key %$ not in Table!\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = hash(key);
    i = tmp___2.wrapping_rem((*t).nslots);
    j = 0 as libc::c_int as uint64_t;
    loop {
        tmp___3 = Table_Key_Hash(t, i);
        h = tmp___3;
        let mut current_block_33: u64;
        if h == 0 as libc::c_ulong {
            current_block_33 = 10629591937497148734;
        } else {
            tmp___7 = Table_Probe(t, i, h);
            if j > tmp___7 {
                current_block_33 = 10629591937497148734;
            } else {
                current_block_33 = 7427571413727699167;
            }
        }
        match current_block_33 {
            10629591937497148734 => {
                __constr_expr_24[0 as libc::c_int as usize] = key;
                __constr_expr_24[1 as libc::c_int as usize] = Terminal;
                __constr_expr_23.items = __constr_expr_24.as_mut_ptr();
                __constr_expr_25[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___4 = 1 as libc::c_uint;
                while !(tmp___4 >= 32 as libc::c_uint) {
                    __constr_expr_25[tmp___4
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___4 = tmp___4.wrapping_add(1);
                }
                tmp___5 = header_init(
                    __constr_expr_25.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___6 = memcpy(
                    tmp___5 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_23 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    KeyError,
                    b"Key %$ not in Table!\0" as *const u8 as *const libc::c_char,
                    tmp___6 as *mut Tuple as var,
                );
            }
            _ => {}
        }
        tmp___19 = Table_Key(t, i);
        tmp___20 = eq(tmp___19, key);
        if tmp___20 {
            tmp___8 = Table_Key(t, i);
            destruct(tmp___8);
            tmp___9 = Table_Val(t, i);
            destruct(tmp___9);
            tmp___10 = Table_Step(t);
            tmp___11 = Table_Step(t);
            memset(
                ((*t).data as *mut libc::c_char)
                    .offset(i.wrapping_mul(tmp___11) as isize) as *mut libc::c_void,
                0 as libc::c_int,
                tmp___10,
            );
            loop {
                ni = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*t).nslots);
                tmp___12 = Table_Key_Hash(t, ni);
                nh = tmp___12;
                if !(nh != 0 as libc::c_ulong) {
                    break;
                }
                tmp___18 = Table_Probe(t, ni, nh);
                if !(tmp___18 > 0 as libc::c_ulong) {
                    break;
                }
                tmp___13 = Table_Step(t);
                tmp___14 = Table_Step(t);
                tmp___15 = Table_Step(t);
                memcpy(
                    ((*t).data as *mut libc::c_char)
                        .offset(i.wrapping_mul(tmp___15) as isize) as *mut libc::c_void,
                    ((*t).data as *mut libc::c_char)
                        .offset(ni.wrapping_mul(tmp___14) as isize)
                        as *const libc::c_void,
                    tmp___13,
                );
                tmp___16 = Table_Step(t);
                tmp___17 = Table_Step(t);
                memset(
                    ((*t).data as *mut libc::c_char)
                        .offset(ni.wrapping_mul(tmp___17) as isize) as *mut libc::c_void,
                    0 as libc::c_int,
                    tmp___16,
                );
                i = ni;
            }
            (*t).nitems = ((*t).nitems).wrapping_sub(1);
            Table_Resize_Less(t);
            return;
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*t).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn Table_Get(mut self_0: var, mut key: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    let mut tmp: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: size_t = 0;
    let mut __constr_expr_26: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_27: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_28: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: uint64_t = 0;
    let mut tmp___5: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___6: uint64_t = 0;
    let mut __constr_expr_29: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_30: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_31: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: uint64_t = 0;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: bool = false;
    t = self_0 as *mut Table;
    if key as libc::c_ulong >= (*t).data as libc::c_ulong {
        tmp___1 = Table_Step(self_0 as *mut Table);
        if (key as *mut libc::c_char as libc::c_ulong)
            < ((*t).data as *mut libc::c_char)
                .offset(((*t).nslots).wrapping_mul(tmp___1) as isize) as libc::c_ulong
        {
            tmp = Table_Step(self_0 as *mut Table);
            tmp___0 = Table_Val(
                self_0 as *mut Table,
                ((key as *mut libc::c_char).offset_from((*t).data as *mut libc::c_char)
                    as libc::c_long as size_t)
                    .wrapping_div(tmp),
            );
            return tmp___0;
        }
    }
    key = cast(key, (*t).ktype);
    if (*t).nslots == 0 as libc::c_ulong {
        __constr_expr_27[0 as libc::c_int as usize] = key;
        __constr_expr_27[1 as libc::c_int as usize] = Terminal;
        __constr_expr_26.items = __constr_expr_27.as_mut_ptr();
        __constr_expr_28[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_28[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_28.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_26 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            KeyError,
            b"Key %$ not in Table!\0" as *const u8 as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
    }
    tmp___5 = hash(key);
    i = tmp___5.wrapping_rem((*t).nslots);
    j = 0 as libc::c_int as uint64_t;
    loop {
        tmp___6 = Table_Key_Hash(t, i);
        h = tmp___6;
        let mut current_block_41: u64;
        if h == 0 as libc::c_ulong {
            current_block_41 = 7870890146965796931;
        } else {
            tmp___10 = Table_Probe(t, i, h);
            if j > tmp___10 {
                current_block_41 = 7870890146965796931;
            } else {
                current_block_41 = 10758786907990354186;
            }
        }
        match current_block_41 {
            7870890146965796931 => {
                __constr_expr_30[0 as libc::c_int as usize] = key;
                __constr_expr_30[1 as libc::c_int as usize] = Terminal;
                __constr_expr_29.items = __constr_expr_30.as_mut_ptr();
                __constr_expr_31[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___7 = 1 as libc::c_uint;
                while !(tmp___7 >= 32 as libc::c_uint) {
                    __constr_expr_31[tmp___7
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___7 = tmp___7.wrapping_add(1);
                }
                tmp___8 = header_init(
                    __constr_expr_31.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___9 = memcpy(
                    tmp___8 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_29 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    KeyError,
                    b"Key %$ not in Table!\0" as *const u8 as *const libc::c_char,
                    tmp___9 as *mut Tuple as var,
                );
            }
            _ => {}
        }
        tmp___12 = Table_Key(t, i);
        tmp___13 = eq(tmp___12, key);
        if tmp___13 {
            tmp___11 = Table_Val(t, i);
            return tmp___11;
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*t).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn Table_Set(mut self_0: var, mut key: var, mut val: var) {
    Table_Set_Move(self_0, key, val, 0 as libc::c_int != 0);
    Table_Resize_More(self_0 as *mut Table);
}
unsafe extern "C" fn Table_Iter_Init(mut self_0: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: uint64_t = 0;
    t = self_0 as *mut Table;
    if (*t).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    i = 0 as libc::c_int as size_t;
    while i < (*t).nslots {
        tmp___0 = Table_Key_Hash(t, i);
        if tmp___0 != 0 as libc::c_ulong {
            tmp = Table_Key(t, i);
            return tmp;
        }
        i = i.wrapping_add(1);
    }
    return Terminal;
}
unsafe extern "C" fn Table_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    let mut tmp: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut h: uint64_t = 0;
    let mut tmp___1: size_t = 0;
    t = self_0 as *mut Table;
    tmp = Table_Step(t);
    curr = (curr as *mut libc::c_char).offset(tmp as isize) as var;
    loop {
        tmp___0 = Table_Key(t, ((*t).nslots).wrapping_sub(1 as libc::c_ulong));
        if curr as libc::c_ulong > tmp___0 as libc::c_ulong {
            return Terminal;
        }
        h = *((curr as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            .offset(-(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize))
            as *mut uint64_t);
        if h != 0 as libc::c_ulong {
            return curr;
        }
        tmp___1 = Table_Step(t);
        curr = (curr as *mut libc::c_char).offset(tmp___1 as isize) as var;
    };
}
unsafe extern "C" fn Table_Iter_Last(mut self_0: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: uint64_t = 0;
    t = self_0 as *mut Table;
    if (*t).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    i = ((*t).nslots).wrapping_sub(1 as libc::c_ulong);
    loop {
        tmp___0 = Table_Key_Hash(t, i);
        if tmp___0 != 0 as libc::c_ulong {
            tmp = Table_Key(t, i);
            return tmp;
        }
        if i == 0 as libc::c_ulong {
            break;
        }
        i = i.wrapping_sub(1);
    }
    return Terminal;
}
unsafe extern "C" fn Table_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    let mut tmp: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut h: uint64_t = 0;
    let mut tmp___1: size_t = 0;
    t = self_0 as *mut Table;
    tmp = Table_Step(t);
    curr = (curr as *mut libc::c_char).offset(-(tmp as isize)) as var;
    loop {
        tmp___0 = Table_Key(t, 0 as libc::c_int as uint64_t);
        if (curr as libc::c_ulong) < tmp___0 as libc::c_ulong {
            return Terminal;
        }
        h = *((curr as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            .offset(-(::std::mem::size_of::<uint64_t>() as libc::c_ulong as isize))
            as *mut uint64_t);
        if h != 0 as libc::c_ulong {
            return curr;
        }
        tmp___1 = Table_Step(t);
        curr = (curr as *mut libc::c_char).offset(-(tmp___1 as isize)) as var;
    };
}
unsafe extern "C" fn Table_Iter_Type(mut self_0: var) -> var {
    let mut t: *mut Table = 0 as *mut Table;
    t = self_0 as *mut Table;
    return (*t).ktype;
}
unsafe extern "C" fn Table_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut t: *mut Table = 0 as *mut Table;
    let mut __constr_expr_32: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_33: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_34: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut j: size_t = 0;
    let mut i: size_t = 0;
    let mut __constr_expr_35: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_36: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut __constr_expr_37: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_38: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_39: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_40: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: size_t = 0;
    let mut tmp___11: uint64_t = 0;
    let mut __constr_expr_41: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_42: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_43: [libc::c_char; 32] = [0; 32];
    let mut tmp___12: libc::c_uint = 0;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___15: libc::c_int = 0;
    t = self_0 as *mut Table;
    __constr_expr_33[0 as libc::c_int as usize] = self_0;
    __constr_expr_33[1 as libc::c_int as usize] = Terminal;
    __constr_expr_32.items = __constr_expr_33.as_mut_ptr();
    __constr_expr_34[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_34[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_34.as_mut_ptr() as var, Tuple, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_32 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"<'Table' At 0x%p {\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    j = 0 as libc::c_int as size_t;
    i = 0 as libc::c_int as size_t;
    while i < (*t).nslots {
        tmp___11 = Table_Key_Hash(t, i);
        if tmp___11 != 0 as libc::c_ulong {
            tmp___2 = Table_Key(t, i);
            tmp___3 = Table_Val(t, i);
            __constr_expr_36[0 as libc::c_int as usize] = tmp___2;
            __constr_expr_36[1 as libc::c_int as usize] = tmp___3;
            __constr_expr_36[2 as libc::c_int as usize] = Terminal;
            __constr_expr_35.items = __constr_expr_36.as_mut_ptr();
            __constr_expr_37[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = 1 as libc::c_uint;
            while !(tmp___4 >= 32 as libc::c_uint) {
                __constr_expr_37[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___4 = tmp___4.wrapping_add(1);
            }
            tmp___5 = header_init(
                __constr_expr_37.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___6 = memcpy(
                tmp___5 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_35 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b"%$:%$\0" as *const u8 as *const libc::c_char,
                tmp___6 as *mut Tuple as var,
            );
            tmp___10 = Table_Len(t as var);
            if j < tmp___10.wrapping_sub(1 as libc::c_ulong) {
                __constr_expr_39[0 as libc::c_int as usize] = Terminal;
                __constr_expr_38.items = __constr_expr_39.as_mut_ptr();
                __constr_expr_40[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___7 = 1 as libc::c_uint;
                while !(tmp___7 >= 32 as libc::c_uint) {
                    __constr_expr_40[tmp___7
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___7 = tmp___7.wrapping_add(1);
                }
                tmp___8 = header_init(
                    __constr_expr_40.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___9 = memcpy(
                    tmp___8 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_38 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    output,
                    pos,
                    b", \0" as *const u8 as *const libc::c_char,
                    tmp___9 as *mut Tuple as var,
                );
            }
            j = j.wrapping_add(1);
        }
        i = i.wrapping_add(1);
    }
    __constr_expr_42[0 as libc::c_int as usize] = Terminal;
    __constr_expr_41.items = __constr_expr_42.as_mut_ptr();
    __constr_expr_43[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___12 = 1 as libc::c_uint;
    while !(tmp___12 >= 32 as libc::c_uint) {
        __constr_expr_43[tmp___12 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___12 = tmp___12.wrapping_add(1);
    }
    tmp___13 = header_init(
        __constr_expr_43.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___14 = memcpy(
        tmp___13 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_41 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___15 = print_to_with(
        output,
        pos,
        b"}>\0" as *const u8 as *const libc::c_char,
        tmp___14 as *mut Tuple as var,
    );
    return tmp___15;
}
unsafe extern "C" fn Table_Resize(mut self_0: var, mut n: size_t) {
    let mut t: *mut Table = 0 as *mut Table;
    let mut __constr_expr_44: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_45: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_46: Int = Int { val: 0 };
    let mut __constr_expr_47: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_48: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: size_t = 0;
    t = self_0 as *mut Table;
    if n == 0 as libc::c_ulong {
        Table_Clear(t as var);
        return;
    }
    if n < (*t).nitems {
        __constr_expr_46.val = (*t).nitems as int64_t;
        __constr_expr_47[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_47[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_47.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_46 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_45[0 as libc::c_int as usize] = tmp___1 as *mut Int as var;
        __constr_expr_45[1 as libc::c_int as usize] = Terminal;
        __constr_expr_44.items = __constr_expr_45.as_mut_ptr();
        __constr_expr_48[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_48[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_48.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_44 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Cannot resize Table to make it smaller than %li items\0" as *const u8
                as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
    }
    tmp___5 = Table_Ideal_Size(n);
    Table_Rehash(t, tmp___5);
}
unsafe extern "C" fn Table_Mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut t: *mut Table = 0 as *mut Table;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: uint64_t = 0;
    t = self_0 as *mut Table;
    i = 0 as libc::c_int as size_t;
    while i < (*t).nslots {
        tmp___1 = Table_Key_Hash(t, i);
        if tmp___1 != 0 as libc::c_ulong {
            tmp = Table_Key(t, i);
            (Some(f.expect("non-null function pointer")))
                .expect("non-null function pointer")(gc, tmp);
            tmp___0 = Table_Val(t, i);
            (Some(f.expect("non-null function pointer")))
                .expect("non-null function pointer")(gc, tmp___0);
        }
        i = i.wrapping_add(1);
    }
}
static mut __constr_expr_50: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Table_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Table_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Table_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Table_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_51: New = {
    let mut init = New {
        construct_with: Some(Table_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Table_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_52: Assign = {
    let mut init = Assign {
        assign: Some(Table_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_53: Mark = {
    let mut init = Mark {
        mark: Some(
            Table_Mark
                as unsafe extern "C" fn(
                    var,
                    var,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_54: Cmp = {
    let mut init = Cmp {
        cmp: Some(Table_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_55: Hash = {
    let mut init = Hash {
        hash: Some(Table_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_56: Len = {
    let mut init = Len {
        len: Some(Table_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_57: Get = {
    let mut init = Get {
        get: Some(Table_Get as unsafe extern "C" fn(var, var) -> var),
        set: Some(Table_Set as unsafe extern "C" fn(var, var, var) -> ()),
        mem: Some(Table_Mem as unsafe extern "C" fn(var, var) -> bool),
        rem: Some(Table_Rem as unsafe extern "C" fn(var, var) -> ()),
        key_type: Some(Table_Key_Type as unsafe extern "C" fn(var) -> var),
        val_type: Some(Table_Val_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_58: Iter = {
    let mut init = Iter {
        iter_init: Some(Table_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Table_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Table_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Table_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Table_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_59: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Table_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_60: Resize = {
    let mut init = Resize {
        resize: Some(Table_Resize as unsafe extern "C" fn(var, size_t) -> ()),
    };
    init
};
static mut __constr_expr_49: [var; 63] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Table\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Table>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_50 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_51 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_52 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_53 as *const Mark as *mut Mark as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_54 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_55 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_56 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_57 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_58 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_59 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_60 as *const Resize as *mut Resize as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Table: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Resize_Name() -> *const libc::c_char {
    return b"Reserve\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Resize_Brief() -> *const libc::c_char {
    return b"Object can be resized\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Resize_Description() -> *const libc::c_char {
    return b"The `Resize` class can be implemented by objects which can be resized in some way. Resizing to a larger size than the current may allow for some resource or other to be preallocated or reserved. For example this class is implemented by `Array` and `Table` to either remove a number of items quickly or to preallocate memory space if it is known that many items are going to be added at a later date.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Resize_Definition() -> *const libc::c_char {
    return b"struct Resize {\n  void (*resize)(var, size_t);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut methods: [Method; 2] = [
    {
        let mut init = Method {
            name: b"resize\0" as *const u8 as *const libc::c_char,
            definition: b"void resize(var self, size_t n);\0" as *const u8
                as *const libc::c_char,
            description: b"Resize to some size `n`, perhaps reserving some resource for object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Resize_Methods() -> *mut Method {
    return methods.as_mut_ptr();
}
static mut examples___0: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int);\nresize(x, 10000); /* Reserve space in Array */ \nfor (size_t i = 0; i < 10000; i++) {\n  push(x, $I(i));\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 2\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int, $I(0), $I(1), $I(2));\nresize(x, 0); /* Clear Array of items */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Resize_Examples() -> *mut Example {
    return examples___0.as_mut_ptr();
}
static mut __constr_expr_62: Doc = {
    let mut init = Doc {
        name: Some(Resize_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Resize_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Resize_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Resize_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Resize_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Resize_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_61: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Resize>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_62 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Resize: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn resize(mut self_0: var, mut n: size_t) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Resize,
        &mut (*(0 as *mut Resize)).resize
            as *mut Option::<unsafe extern "C" fn(var, size_t) -> ()> as libc::c_ulong,
        b"resize\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Resize)).resize).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, n);
}
static mut __constr_expr_63: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"_\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};

static mut __constr_expr_64: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Terminal\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Terminal: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Iter_Name() -> *const libc::c_char {
    return b"Iter\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Iter_Brief() -> *const libc::c_char {
    return b"Iterable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Iter_Description() -> *const libc::c_char {
    return b"The `Iter` class is implemented by types which can be looped over. This allows them to be used in conjunction with the `foreach` macro as well as various other components of Cello.\n\nTo signal that an interation has finished an iteration should return the Cello object `Terminal`. Due to this - the `Terminal` object cannot be placed inside of Tuples because it artificially shortens their length.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Iter_Definition() -> *const libc::c_char {
    return b"struct Iter {\n  var (*iter_init)(var);\n  var (*iter_next)(var, var);\n  var (*iter_prev)(var, var);\n  var (*iter_last)(var);\n  var (*iter_type)(var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___1: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int, $I(1), $I(2), $I(5));\n\nforeach(o in x) {\n  show(o); /* 1, 2, 5 */\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Table\0" as *const u8 as *const libc::c_char,
            body: b"var prices = new(Table, String, Int);\nset(prices, $S(\"Apple\"),  $I(12));\nset(prices, $S(\"Banana\"), $I( 6));\nset(prices, $S(\"Pear\"),   $I(55));\n\nforeach(key in prices) {\n  var price = get(prices, key);\n  print(\"Price of %$ is %$\\n\", key, price);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Iter_Examples() -> *mut Example {
    return examples___1.as_mut_ptr();
}
static mut methods___0: [Method; 5] = [
    {
        let mut init = Method {
            name: b"foreach\0" as *const u8 as *const libc::c_char,
            definition: b"#define foreach(...)\n\0" as *const u8 as *const libc::c_char,
            description: b"Iterate over elements in a loop.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"iter_init\0" as *const u8 as *const libc::c_char,
            definition: b"var iter_init(var self);\nvar iter_last(var self);\0"
                as *const u8 as *const libc::c_char,
            description: b"Return the initial item (or final item) in the iteration over `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"iter_next\0" as *const u8 as *const libc::c_char,
            definition: b"var iter_next(var self, var curr);\nvar iter_prev(var self, var curr);\0"
                as *const u8 as *const libc::c_char,
            description: b"Given the current item `curr`, return the next (or previous) item in the iteration over `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"iter_type\0" as *const u8 as *const libc::c_char,
            definition: b"var iter_type(var self);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns the type of item that can be expected to be returned by the iterable.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Iter_Methods() -> *mut Method {
    return methods___0.as_mut_ptr();
}
static mut __constr_expr_66: Doc = {
    let mut init = Doc {
        name: Some(Iter_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Iter_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Iter_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Iter_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Iter_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Iter_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_65: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Iter>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_66 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Iter: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn iter_init(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Iter,
        &mut (*(0 as *mut Iter)).iter_init
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
        b"iter_init\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn iter_next(mut self_0: var, mut curr: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Iter,
        &mut (*(0 as *mut Iter)).iter_next
            as *mut Option::<unsafe extern "C" fn(var, var) -> var> as libc::c_ulong,
        b"iter_next\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Iter)).iter_next).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0, curr);
    return tmp___0;
}
pub unsafe extern "C" fn iter_last(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Iter,
        &mut (*(0 as *mut Iter)).iter_last
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
        b"iter_last\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Iter)).iter_last).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn iter_prev(mut self_0: var, mut curr: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Iter,
        &mut (*(0 as *mut Iter)).iter_prev
            as *mut Option::<unsafe extern "C" fn(var, var) -> var> as libc::c_ulong,
        b"iter_prev\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Iter)).iter_prev).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0, curr);
    return tmp___0;
}
pub unsafe extern "C" fn iter_type(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Iter,
        &mut (*(0 as *mut Iter)).iter_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
        b"iter_type\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Iter)).iter_type).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
unsafe extern "C" fn Range_Name() -> *const libc::c_char {
    return b"Range\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Range_Brief() -> *const libc::c_char {
    return b"Integer Sequence\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Range_Description() -> *const libc::c_char {
    return b"The `Range` type is a basic iterable which acts as a virtual sequence of integers, starting from some value, stopping at some value and incrementing by some step.\n\nThis can be a useful replacement for the standard C `for` loop with decent performance but returning a Cello `Int`. It is constructable on the stack with the `range` macro which makes it practical and easy to use.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Range_Definition() -> *const libc::c_char {
    return b"struct Range {\n  var value;\n  int64_t start;\n  int64_t stop;\n  int64_t step;\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___2: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"/* Iterate 0 to 10 */\nforeach (i in range($I(10))) {\n  print(\"%i\\n\", i);\n}\n\n/* Iterate 10 to 20 */\nforeach (i in range($I(10), $I(20))) {\n  print(\"%i\\n\", i);\n}\n\n/* Iterate 10 to 20 with a step of 5 */\nforeach (i in range($I(10), $I(20), $I(5))) {\n  print(\"%i\\n\", i);\n}\n\n/* Iterate 20 to 10 */\nforeach (i in range($I(10), $I(20), $I(-1))) {\n  print(\"%i\\n\", i);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Range_Examples() -> *mut Example {
    return examples___2.as_mut_ptr();
}
static mut methods___1: [Method; 2] = [
    {
        let mut init = Method {
            name: b"range\0" as *const u8 as *const libc::c_char,
            definition: b"#define range(...)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Range` object on the stack.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Range_Methods() -> *mut Method {
    return methods___1.as_mut_ptr();
}
pub unsafe extern "C" fn range_stack(mut self_0: var, mut args: var) -> var {
    let mut r: *mut Range = 0 as *mut Range;
    let mut nargs: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __constr_expr_67: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_68: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_69: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_70: Int = Int { val: 0 };
    let mut __constr_expr_71: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut __constr_expr_74: Int = Int { val: 0 };
    let mut __constr_expr_75: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: var = 0 as *mut libc::c_void;
    let mut tmp___15: int64_t = 0;
    let mut __constr_expr_76: Int = Int { val: 0 };
    let mut __constr_expr_77: [libc::c_char; 32] = [0; 32];
    let mut tmp___16: libc::c_uint = 0;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut tmp___18: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___19: var = 0 as *mut libc::c_void;
    let mut __constr_expr_78: Int = Int { val: 0 };
    let mut __constr_expr_79: [libc::c_char; 32] = [0; 32];
    let mut tmp___20: libc::c_uint = 0;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___23: var = 0 as *mut libc::c_void;
    let mut __constr_expr_82: Int = Int { val: 0 };
    let mut __constr_expr_83: [libc::c_char; 32] = [0; 32];
    let mut tmp___28: libc::c_uint = 0;
    let mut tmp___29: var = 0 as *mut libc::c_void;
    let mut tmp___30: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___31: var = 0 as *mut libc::c_void;
    let mut tmp___32: int64_t = 0;
    let mut __constr_expr_84: Int = Int { val: 0 };
    let mut __constr_expr_85: [libc::c_char; 32] = [0; 32];
    let mut tmp___33: libc::c_uint = 0;
    let mut tmp___34: var = 0 as *mut libc::c_void;
    let mut tmp___35: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___36: var = 0 as *mut libc::c_void;
    let mut __constr_expr_86: Int = Int { val: 0 };
    let mut __constr_expr_87: [libc::c_char; 32] = [0; 32];
    let mut tmp___37: libc::c_uint = 0;
    let mut tmp___38: var = 0 as *mut libc::c_void;
    let mut tmp___39: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___40: var = 0 as *mut libc::c_void;
    let mut __constr_expr_90: Int = Int { val: 0 };
    let mut __constr_expr_91: [libc::c_char; 32] = [0; 32];
    let mut tmp___45: libc::c_uint = 0;
    let mut tmp___46: var = 0 as *mut libc::c_void;
    let mut tmp___47: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___48: var = 0 as *mut libc::c_void;
    let mut tmp___49: int64_t = 0;
    let mut __constr_expr_92: Int = Int { val: 0 };
    let mut __constr_expr_93: [libc::c_char; 32] = [0; 32];
    let mut tmp___50: libc::c_uint = 0;
    let mut tmp___51: var = 0 as *mut libc::c_void;
    let mut tmp___52: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___53: var = 0 as *mut libc::c_void;
    r = self_0 as *mut Range;
    tmp = len(args);
    nargs = tmp;
    if nargs > 3 as libc::c_ulong {
        __constr_expr_68[0 as libc::c_int as usize] = Terminal;
        __constr_expr_67.items = __constr_expr_68.as_mut_ptr();
        __constr_expr_69[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_69[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_69.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_67 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Received too many arguments to Range constructor\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    match nargs {
        0 => {
            (*r).start = 0 as libc::c_int as int64_t;
            (*r).stop = 0 as libc::c_int as int64_t;
            (*r).step = 1 as libc::c_int as int64_t;
        }
        1 => {
            (*r).start = 0 as libc::c_int as int64_t;
            __constr_expr_70.val = 0 as libc::c_int as int64_t;
            __constr_expr_71[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = 1 as libc::c_uint;
            while !(tmp___3 >= 32 as libc::c_uint) {
                __constr_expr_71[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___3 = tmp___3.wrapping_add(1);
            }
            tmp___4 = header_init(
                __constr_expr_71.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___5 = memcpy(
                tmp___4 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_70 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___6 = get(args, tmp___5 as *mut Int as var);
            (*r).stop = c_int(tmp___6);
            (*r).step = 1 as libc::c_int as int64_t;
        }
        2 => {
            __constr_expr_76.val = 0 as libc::c_int as int64_t;
            __constr_expr_77[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___16 = 1 as libc::c_uint;
            while !(tmp___16 >= 32 as libc::c_uint) {
                __constr_expr_77[tmp___16 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___16 = tmp___16.wrapping_add(1);
            }
            tmp___17 = header_init(
                __constr_expr_77.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___18 = memcpy(
                tmp___17 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_76 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___19 = get(args, tmp___18 as *mut Int as var);
            if tmp___19 as libc::c_ulong == 0 as libc::c_ulong {
                (*r).start = 0 as libc::c_int as int64_t;
            } else {
                __constr_expr_74.val = 0 as libc::c_int as int64_t;
                __constr_expr_75[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___11 = 1 as libc::c_uint;
                while !(tmp___11 >= 32 as libc::c_uint) {
                    __constr_expr_75[tmp___11
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___11 = tmp___11.wrapping_add(1);
                }
                tmp___12 = header_init(
                    __constr_expr_75.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___13 = memcpy(
                    tmp___12 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_74 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                tmp___14 = get(args, tmp___13 as *mut Int as var);
                tmp___15 = c_int(tmp___14);
                (*r).start = tmp___15;
            }
            __constr_expr_78.val = 1 as libc::c_int as int64_t;
            __constr_expr_79[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___20 = 1 as libc::c_uint;
            while !(tmp___20 >= 32 as libc::c_uint) {
                __constr_expr_79[tmp___20 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___20 = tmp___20.wrapping_add(1);
            }
            tmp___21 = header_init(
                __constr_expr_79.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___22 = memcpy(
                tmp___21 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_78 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___23 = get(args, tmp___22 as *mut Int as var);
            (*r).stop = c_int(tmp___23);
            (*r).step = 1 as libc::c_int as int64_t;
        }
        3 => {
            __constr_expr_84.val = 0 as libc::c_int as int64_t;
            __constr_expr_85[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___33 = 1 as libc::c_uint;
            while !(tmp___33 >= 32 as libc::c_uint) {
                __constr_expr_85[tmp___33 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___33 = tmp___33.wrapping_add(1);
            }
            tmp___34 = header_init(
                __constr_expr_85.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___35 = memcpy(
                tmp___34 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_84 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___36 = get(args, tmp___35 as *mut Int as var);
            if tmp___36 as libc::c_ulong == 0 as libc::c_ulong {
                (*r).start = 0 as libc::c_int as int64_t;
            } else {
                __constr_expr_82.val = 0 as libc::c_int as int64_t;
                __constr_expr_83[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___28 = 1 as libc::c_uint;
                while !(tmp___28 >= 32 as libc::c_uint) {
                    __constr_expr_83[tmp___28
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___28 = tmp___28.wrapping_add(1);
                }
                tmp___29 = header_init(
                    __constr_expr_83.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___30 = memcpy(
                    tmp___29 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_82 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                tmp___31 = get(args, tmp___30 as *mut Int as var);
                tmp___32 = c_int(tmp___31);
                (*r).start = tmp___32;
            }
            __constr_expr_86.val = 1 as libc::c_int as int64_t;
            __constr_expr_87[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___37 = 1 as libc::c_uint;
            while !(tmp___37 >= 32 as libc::c_uint) {
                __constr_expr_87[tmp___37 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___37 = tmp___37.wrapping_add(1);
            }
            tmp___38 = header_init(
                __constr_expr_87.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___39 = memcpy(
                tmp___38 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_86 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___40 = get(args, tmp___39 as *mut Int as var);
            (*r).stop = c_int(tmp___40);
            __constr_expr_92.val = 2 as libc::c_int as int64_t;
            __constr_expr_93[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___50 = 1 as libc::c_uint;
            while !(tmp___50 >= 32 as libc::c_uint) {
                __constr_expr_93[tmp___50 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___50 = tmp___50.wrapping_add(1);
            }
            tmp___51 = header_init(
                __constr_expr_93.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___52 = memcpy(
                tmp___51 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_92 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___53 = get(args, tmp___52 as *mut Int as var);
            if tmp___53 as libc::c_ulong == 0 as libc::c_ulong {
                (*r).step = 1 as libc::c_int as int64_t;
            } else {
                __constr_expr_90.val = 2 as libc::c_int as int64_t;
                __constr_expr_91[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___45 = 1 as libc::c_uint;
                while !(tmp___45 >= 32 as libc::c_uint) {
                    __constr_expr_91[tmp___45
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___45 = tmp___45.wrapping_add(1);
                }
                tmp___46 = header_init(
                    __constr_expr_91.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___47 = memcpy(
                    tmp___46 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_90 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                tmp___48 = get(args, tmp___47 as *mut Int as var);
                tmp___49 = c_int(tmp___48);
                (*r).step = tmp___49;
            }
        }
        _ => {}
    }
    return self_0;
}
unsafe extern "C" fn Range_New(mut self_0: var, mut args: var) {
    let mut r: *mut Range = 0 as *mut Range;
    let mut __constr_expr_94: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_95: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_96: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    r = self_0 as *mut Range;
    __constr_expr_95[0 as libc::c_int as usize] = Terminal;
    __constr_expr_94.items = __constr_expr_95.as_mut_ptr();
    __constr_expr_96[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_96[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_96.as_mut_ptr() as var, Tuple, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_94 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = new_with(Int, tmp___1 as *mut Tuple as var);
    (*r).value = tmp___2 as *mut Int as var;
    range_stack(self_0, args);
}
unsafe extern "C" fn Range_Del(mut self_0: var) {
    let mut r: *mut Range = 0 as *mut Range;
    r = self_0 as *mut Range;
    del((*r).value);
}
unsafe extern "C" fn Range_Assign(mut self_0: var, mut obj: var) {
    let mut r: *mut Range = 0 as *mut Range;
    let mut o: *mut Range = 0 as *mut Range;
    let mut tmp: var = 0 as *mut libc::c_void;
    r = self_0 as *mut Range;
    tmp = cast(obj, Range);
    o = tmp as *mut Range;
    assign((*r).value, (*o).value);
    (*r).start = (*o).start;
    (*r).stop = (*o).stop;
    (*r).step = (*o).step;
}
unsafe extern "C" fn Range_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut r: *mut Range = 0 as *mut Range;
    let mut o: *mut Range = 0 as *mut Range;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    r = self_0 as *mut Range;
    tmp = cast(obj, Range);
    o = tmp as *mut Range;
    tmp___0 = memcmp(
        &mut (*r).start as *mut int64_t as *const libc::c_void,
        &mut (*o).start as *mut int64_t as *const libc::c_void,
        (::std::mem::size_of::<int64_t>() as libc::c_ulong)
            .wrapping_mul(3 as libc::c_ulong),
    );
    return tmp___0;
}
unsafe extern "C" fn Range_Iter_Init(mut self_0: var) -> var {
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: *mut Int = 0 as *mut Int;
    r = self_0 as *mut Range;
    i = (*r).value as *mut Int;
    if (*r).step == 0 as libc::c_long {
        return Terminal;
    }
    if (*r).step > 0 as libc::c_long {
        (*i).val = (*r).start;
    }
    if (*r).step < 0 as libc::c_long {
        (*i).val = (*r).stop - 1 as libc::c_long;
    }
    if (*r).step > 0 as libc::c_long {
        if (*i).val >= (*r).stop {
            return Terminal;
        }
    }
    if (*r).step < 0 as libc::c_long {
        if (*i).val < (*r).start {
            return Terminal;
        }
    }
    return i as var;
}
unsafe extern "C" fn Range_Iter_Last(mut self_0: var) -> var {
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: *mut Int = 0 as *mut Int;
    r = self_0 as *mut Range;
    i = (*r).value as *mut Int;
    if (*r).step == 0 as libc::c_long {
        return Terminal;
    }
    if (*r).step > 0 as libc::c_long {
        (*i).val = (*r).stop - 1 as libc::c_long;
    }
    if (*r).step < 0 as libc::c_long {
        (*i).val = (*r).start;
    }
    if (*r).step > 0 as libc::c_long {
        if (*i).val < (*r).start {
            return Terminal;
        }
    }
    if (*r).step < 0 as libc::c_long {
        if (*i).val >= (*r).stop {
            return Terminal;
        }
    }
    return i as var;
}
unsafe extern "C" fn Range_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: *mut Int = 0 as *mut Int;
    r = self_0 as *mut Range;
    i = (*r).value as *mut Int;
    (*i).val += (*r).step;
    if (*r).step == 0 as libc::c_long {
        return Terminal;
    }
    if (*r).step > 0 as libc::c_long {
        if (*i).val >= (*r).stop {
            return Terminal;
        }
    }
    if (*r).step < 0 as libc::c_long {
        if (*i).val < (*r).start {
            return Terminal;
        }
    }
    return i as var;
}
unsafe extern "C" fn Range_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: *mut Int = 0 as *mut Int;
    r = self_0 as *mut Range;
    i = (*r).value as *mut Int;
    (*i).val -= (*r).step;
    if (*r).step == 0 as libc::c_long {
        return Terminal;
    }
    if (*r).step > 0 as libc::c_long {
        if (*i).val < (*r).start {
            return Terminal;
        }
    }
    if (*r).step < 0 as libc::c_long {
        if (*i).val >= (*r).stop {
            return Terminal;
        }
    }
    return i as var;
}
unsafe extern "C" fn Range_Iter_Type(mut self_0: var) -> var {
    return Int;
}
unsafe extern "C" fn Range_Len(mut self_0: var) -> size_t {
    let mut r: *mut Range = 0 as *mut Range;
    r = self_0 as *mut Range;
    if (*r).step == 0 as libc::c_long {
        return 0 as libc::c_int as size_t;
    }
    if (*r).step > 0 as libc::c_long {
        return (((*r).stop - 1 as libc::c_long - (*r).start) / (*r).step
            + 1 as libc::c_long) as size_t;
    }
    if (*r).step < 0 as libc::c_long {
        return (((*r).stop - 1 as libc::c_long - (*r).start) / -(*r).step
            + 1 as libc::c_long) as size_t;
    }
    return 0 as libc::c_int as size_t;
}
unsafe extern "C" fn Range_Get(mut self_0: var, mut key: var) -> var {
    let mut r: *mut Range = 0 as *mut Range;
    let mut x: *mut Int = 0 as *mut Int;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut tmp___0: size_t = 0;
    let mut __constr_expr_97: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_98: [var; 5] = [0 as *mut libc::c_void; 5];
    let mut __constr_expr_99: Int = Int { val: 0 };
    let mut __constr_expr_100: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_101: Int = Int { val: 0 };
    let mut __constr_expr_102: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_103: Int = Int { val: 0 };
    let mut __constr_expr_104: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_105: [libc::c_char; 32] = [0; 32];
    let mut tmp___10: libc::c_uint = 0;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    r = self_0 as *mut Range;
    x = (*r).value as *mut Int;
    tmp = c_int(key);
    i = tmp;
    if i < 0 as libc::c_long {
        tmp___0 = Range_Len(r as var);
        i = tmp___0.wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    if (*r).step == 0 as libc::c_long {
        (*x).val = 0 as libc::c_int as int64_t;
        return x as var;
    }
    if (*r).step > 0 as libc::c_long {
        if (*r).start + (*r).step * i < (*r).stop {
            (*x).val = (*r).start + (*r).step * i;
            return x as var;
        }
    }
    if (*r).step < 0 as libc::c_long {
        if (*r).stop - 1 as libc::c_long + (*r).step * i >= (*r).start {
            (*x).val = (*r).stop - 1 as libc::c_long + (*r).step * i;
            return x as var;
        }
    }
    __constr_expr_99.val = (*r).start;
    __constr_expr_100[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___1 = 1 as libc::c_uint;
    while !(tmp___1 >= 32 as libc::c_uint) {
        __constr_expr_100[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = tmp___1.wrapping_add(1);
    }
    tmp___2 = header_init(__constr_expr_100.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___3 = memcpy(
        tmp___2 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_99 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    __constr_expr_101.val = (*r).stop;
    __constr_expr_102[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___4 = 1 as libc::c_uint;
    while !(tmp___4 >= 32 as libc::c_uint) {
        __constr_expr_102[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = tmp___4.wrapping_add(1);
    }
    tmp___5 = header_init(__constr_expr_102.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___6 = memcpy(
        tmp___5 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_101 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    __constr_expr_103.val = (*r).step;
    __constr_expr_104[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___7 = 1 as libc::c_uint;
    while !(tmp___7 >= 32 as libc::c_uint) {
        __constr_expr_104[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = tmp___7.wrapping_add(1);
    }
    tmp___8 = header_init(__constr_expr_104.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___9 = memcpy(
        tmp___8 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_103 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    __constr_expr_98[0 as libc::c_int as usize] = key;
    __constr_expr_98[1 as libc::c_int as usize] = tmp___3 as *mut Int as var;
    __constr_expr_98[2 as libc::c_int as usize] = tmp___6 as *mut Int as var;
    __constr_expr_98[3 as libc::c_int as usize] = tmp___9 as *mut Int as var;
    __constr_expr_98[4 as libc::c_int as usize] = Terminal;
    __constr_expr_97.items = __constr_expr_98.as_mut_ptr();
    __constr_expr_105[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___10 = 1 as libc::c_uint;
    while !(tmp___10 >= 32 as libc::c_uint) {
        __constr_expr_105[tmp___10 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___10 = tmp___10.wrapping_add(1);
    }
    tmp___11 = header_init(
        __constr_expr_105.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___12 = memcpy(
        tmp___11 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_97 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___13 = exception_throw(
        IndexOutOfBoundsError,
        b"Index '%i' out of bounds for Range of start %i, stop %i and step %i.\0"
            as *const u8 as *const libc::c_char,
        tmp___12 as *mut Tuple as var,
    );
    return tmp___13;
}
unsafe extern "C" fn Range_Mem(mut self_0: var, mut key: var) -> bool {
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    r = self_0 as *mut Range;
    tmp = c_int(key);
    i = tmp;
    if i < 0 as libc::c_long {
        tmp___0 = Range_Len(r as var);
        i = tmp___0.wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    if (*r).step == 0 as libc::c_long {
        return 0 as libc::c_int != 0;
    }
    if (*r).step > 0 as libc::c_long {
        if i >= (*r).start {
            if i < (*r).stop {
                if (i - (*r).start) % (*r).step == 0 as libc::c_long {
                    tmp___1 = 1 as libc::c_int;
                } else {
                    tmp___1 = 0 as libc::c_int;
                }
            } else {
                tmp___1 = 0 as libc::c_int;
            }
        } else {
            tmp___1 = 0 as libc::c_int;
        }
        return tmp___1 != 0;
    }
    if (*r).step < 0 as libc::c_long {
        if i >= (*r).start {
            if i < (*r).stop {
                if (i - ((*r).stop - 1 as libc::c_long)) % -(*r).step
                    == 0 as libc::c_long
                {
                    tmp___2 = 1 as libc::c_int;
                } else {
                    tmp___2 = 0 as libc::c_int;
                }
            } else {
                tmp___2 = 0 as libc::c_int;
            }
        } else {
            tmp___2 = 0 as libc::c_int;
        }
        return tmp___2 != 0;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Range_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut r: *mut Range = 0 as *mut Range;
    let mut __constr_expr_106: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_107: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_108: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_109: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_110: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_111: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_112: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_113: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_114: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_115: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_116: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_117: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: libc::c_int = 0;
    r = self_0 as *mut Range;
    __constr_expr_107[0 as libc::c_int as usize] = self_0;
    __constr_expr_107[1 as libc::c_int as usize] = Terminal;
    __constr_expr_106.items = __constr_expr_107.as_mut_ptr();
    __constr_expr_108[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_108[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_108.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_106 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"<'Range' At 0x%p [\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    tmp___2 = Range_Iter_Init(self_0);
    curr = tmp___2;
    while curr as libc::c_ulong != Terminal as libc::c_ulong {
        __constr_expr_110[0 as libc::c_int as usize] = curr;
        __constr_expr_110[1 as libc::c_int as usize] = Terminal;
        __constr_expr_109.items = __constr_expr_110.as_mut_ptr();
        __constr_expr_111[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_111[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_111.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_109 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            output,
            pos,
            b"%i\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        curr = Range_Iter_Next(self_0, curr);
        if curr as libc::c_ulong != Terminal as libc::c_ulong {
            __constr_expr_113[0 as libc::c_int as usize] = Terminal;
            __constr_expr_112.items = __constr_expr_113.as_mut_ptr();
            __constr_expr_114[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = 1 as libc::c_uint;
            while !(tmp___6 >= 32 as libc::c_uint) {
                __constr_expr_114[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = tmp___6.wrapping_add(1);
            }
            tmp___7 = header_init(
                __constr_expr_114.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___8 = memcpy(
                tmp___7 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_112 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b", \0" as *const u8 as *const libc::c_char,
                tmp___8 as *mut Tuple as var,
            );
        }
    }
    __constr_expr_116[0 as libc::c_int as usize] = Terminal;
    __constr_expr_115.items = __constr_expr_116.as_mut_ptr();
    __constr_expr_117[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___9 = 1 as libc::c_uint;
    while !(tmp___9 >= 32 as libc::c_uint) {
        __constr_expr_117[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = tmp___9.wrapping_add(1);
    }
    tmp___10 = header_init(
        __constr_expr_117.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___11 = memcpy(
        tmp___10 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_115 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___12 = print_to_with(
        output,
        pos,
        b"]>\0" as *const u8 as *const libc::c_char,
        tmp___11 as *mut Tuple as var,
    );
    return tmp___12;
}
static mut __constr_expr_119: Doc = {
    let mut init = Doc {
        name: Some(Range_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Range_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Range_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Range_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Range_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Range_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_120: New = {
    let mut init = New {
        construct_with: Some(Range_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Range_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_121: Assign = {
    let mut init = Assign {
        assign: Some(Range_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_122: Cmp = {
    let mut init = Cmp {
        cmp: Some(Range_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_123: Len = {
    let mut init = Len {
        len: Some(Range_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_124: Get = unsafe {
    {
        let mut init = Get {
            get: Some(Range_Get as unsafe extern "C" fn(var, var) -> var),
            set: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            mem: Some(Range_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_125: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Range_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_126: Iter = {
    let mut init = Iter {
        iter_init: Some(Range_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Range_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Range_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Range_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Range_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_118: [var; 54] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Range\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Range>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_119 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_120 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_121 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_122 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_123 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_124 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_125 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_126 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Range: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Slice_Name() -> *const libc::c_char {
    return b"Slice\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Slice_Brief() -> *const libc::c_char {
    return b"Partial Iterable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Slice_Description() -> *const libc::c_char {
    return b"The `Slice` type is an iterable that allows one to only iterate over part of another iterable. Given some start, stop and step, only those entries described by the `Slice` are returned in the iteration.\n\nUnder the hood the `Slice` object still iterates over the whole iterable but it only returns those values in the range given.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Slice_Definition() -> *const libc::c_char {
    return b"struct Slice {\n  var iter;\n  var range;\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___3: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = tuple(\n  $S(\"Hello\"), $S(\"There\"), $S(\"World\"), $S(\"!\"));\n\n/* Iterate over elements 0 to 2 */\nforeach (s in slice(x, $I(2))) {\n  print(\"%s\\n\", s);\n}\n\n/* Iterate over elements 1 to 2 */\nforeach (s in slice(x, $I(1), $I(2))) {\n  print(\"%s\\n\", s);\n}\n\n/* Iterate over every other element */\nforeach (s in slice(x, _, _, $I(2))) {\n  print(\"%s\\n\", s);\n}\n\n/* Iterate backwards, starting from element 3 */\nforeach (s in slice(x, _, $I(2), $I(-1))) {\n  print(\"%s\\n\", s);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Slice_Examples() -> *mut Example {
    return examples___3.as_mut_ptr();
}
static mut methods___2: [Method; 3] = [
    {
        let mut init = Method {
            name: b"slice\0" as *const u8 as *const libc::c_char,
            definition: b"#define slice(I, ...)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Slice` object on the stack over iterable `I`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"reverse\0" as *const u8 as *const libc::c_char,
            definition: b"#define reverse(I)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Slice` object that iterates over iterable `I` in reverse order.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Slice_Methods() -> *mut Method {
    return methods___2.as_mut_ptr();
}
unsafe extern "C" fn Slice_Arg(
    mut part: libc::c_int,
    mut n: size_t,
    mut arg: var,
) -> int64_t {
    let mut a: int64_t = 0;
    let mut tmp: int64_t = 0;
    if arg as libc::c_ulong == 0 as libc::c_ulong {
        if part == 0 as libc::c_int {
            return 0 as libc::c_int as int64_t;
        }
        if part == 1 as libc::c_int {
            return n as int64_t;
        }
        if part == 2 as libc::c_int {
            return 1 as libc::c_int as int64_t;
        }
    }
    tmp = c_int(arg);
    a = tmp;
    if part != 2 as libc::c_int {
        if a < 0 as libc::c_long {
            a = n.wrapping_add(a as size_t) as int64_t;
        } else {
            a = a;
        }
        if a as size_t > n {
            a = n as int64_t;
        } else {
            a = a;
        }
        if a < 0 as libc::c_long {
            a = 0 as libc::c_int as int64_t;
        } else {
            a = a;
        }
    }
    return a;
}
pub unsafe extern "C" fn slice_stack(mut self_0: var, mut args: var) -> var {
    let mut nargs: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __constr_expr_127: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_128: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_129: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_130: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_131: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_132: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut __constr_expr_133: Int = Int { val: 0 };
    let mut __constr_expr_134: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: *mut Range = 0 as *mut Range;
    let mut n: size_t = 0;
    let mut tmp___9: size_t = 0;
    let mut __constr_expr_135: Int = Int { val: 0 };
    let mut __constr_expr_136: [libc::c_char; 32] = [0; 32];
    let mut tmp___10: libc::c_uint = 0;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut __constr_expr_137: Int = Int { val: 0 };
    let mut __constr_expr_138: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut __constr_expr_139: Int = Int { val: 0 };
    let mut __constr_expr_140: [libc::c_char; 32] = [0; 32];
    let mut tmp___18: libc::c_uint = 0;
    let mut tmp___19: var = 0 as *mut libc::c_void;
    let mut tmp___20: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut __constr_expr_141: Int = Int { val: 0 };
    let mut __constr_expr_142: [libc::c_char; 32] = [0; 32];
    let mut tmp___22: libc::c_uint = 0;
    let mut tmp___23: var = 0 as *mut libc::c_void;
    let mut tmp___24: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___25: var = 0 as *mut libc::c_void;
    let mut __constr_expr_143: Int = Int { val: 0 };
    let mut __constr_expr_144: [libc::c_char; 32] = [0; 32];
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: var = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___29: var = 0 as *mut libc::c_void;
    let mut __constr_expr_145: Int = Int { val: 0 };
    let mut __constr_expr_146: [libc::c_char; 32] = [0; 32];
    let mut tmp___30: libc::c_uint = 0;
    let mut tmp___31: var = 0 as *mut libc::c_void;
    let mut tmp___32: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___33: var = 0 as *mut libc::c_void;
    tmp = len(args);
    nargs = tmp;
    if nargs > 4 as libc::c_ulong {
        __constr_expr_128[0 as libc::c_int as usize] = Terminal;
        __constr_expr_127.items = __constr_expr_128.as_mut_ptr();
        __constr_expr_129[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_129[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_129.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_127 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Received too many arguments to Slice constructor\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    if nargs < 1 as libc::c_ulong {
        __constr_expr_131[0 as libc::c_int as usize] = Terminal;
        __constr_expr_130.items = __constr_expr_131.as_mut_ptr();
        __constr_expr_132[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_132[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_132.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_130 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Received too few arguments to Slice constructor\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
    s = self_0 as *mut Slice;
    __constr_expr_133.val = 0 as libc::c_int as int64_t;
    __constr_expr_134[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___6 = 1 as libc::c_uint;
    while !(tmp___6 >= 32 as libc::c_uint) {
        __constr_expr_134[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = tmp___6.wrapping_add(1);
    }
    tmp___7 = header_init(__constr_expr_134.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___8 = memcpy(
        tmp___7 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_133 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*s).iter = get(args, tmp___8 as *mut Int as var);
    r = (*s).range as *mut Range;
    tmp___9 = len((*s).iter);
    n = tmp___9;
    match nargs {
        1 => {
            (*r).start = 0 as libc::c_int as int64_t;
            (*r).stop = n as int64_t;
            (*r).step = 1 as libc::c_int as int64_t;
        }
        2 => {
            (*r).start = 0 as libc::c_int as int64_t;
            __constr_expr_135.val = 1 as libc::c_int as int64_t;
            __constr_expr_136[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___10 = 1 as libc::c_uint;
            while !(tmp___10 >= 32 as libc::c_uint) {
                __constr_expr_136[tmp___10 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___10 = tmp___10.wrapping_add(1);
            }
            tmp___11 = header_init(
                __constr_expr_136.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___12 = memcpy(
                tmp___11 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_135 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___13 = get(args, tmp___12 as *mut Int as var);
            (*r).stop = Slice_Arg(1 as libc::c_int, n, tmp___13);
            (*r).step = 1 as libc::c_int as int64_t;
        }
        3 => {
            __constr_expr_137.val = 1 as libc::c_int as int64_t;
            __constr_expr_138[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___14 = 1 as libc::c_uint;
            while !(tmp___14 >= 32 as libc::c_uint) {
                __constr_expr_138[tmp___14 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___14 = tmp___14.wrapping_add(1);
            }
            tmp___15 = header_init(
                __constr_expr_138.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___16 = memcpy(
                tmp___15 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_137 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___17 = get(args, tmp___16 as *mut Int as var);
            (*r).start = Slice_Arg(0 as libc::c_int, n, tmp___17);
            __constr_expr_139.val = 2 as libc::c_int as int64_t;
            __constr_expr_140[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___18 = 1 as libc::c_uint;
            while !(tmp___18 >= 32 as libc::c_uint) {
                __constr_expr_140[tmp___18 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___18 = tmp___18.wrapping_add(1);
            }
            tmp___19 = header_init(
                __constr_expr_140.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___20 = memcpy(
                tmp___19 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_139 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___21 = get(args, tmp___20 as *mut Int as var);
            (*r).stop = Slice_Arg(1 as libc::c_int, n, tmp___21);
            (*r).step = 1 as libc::c_int as int64_t;
        }
        4 => {
            __constr_expr_141.val = 1 as libc::c_int as int64_t;
            __constr_expr_142[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___22 = 1 as libc::c_uint;
            while !(tmp___22 >= 32 as libc::c_uint) {
                __constr_expr_142[tmp___22 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___22 = tmp___22.wrapping_add(1);
            }
            tmp___23 = header_init(
                __constr_expr_142.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___24 = memcpy(
                tmp___23 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_141 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___25 = get(args, tmp___24 as *mut Int as var);
            (*r).start = Slice_Arg(0 as libc::c_int, n, tmp___25);
            __constr_expr_143.val = 2 as libc::c_int as int64_t;
            __constr_expr_144[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___26 = 1 as libc::c_uint;
            while !(tmp___26 >= 32 as libc::c_uint) {
                __constr_expr_144[tmp___26 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___26 = tmp___26.wrapping_add(1);
            }
            tmp___27 = header_init(
                __constr_expr_144.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___28 = memcpy(
                tmp___27 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_143 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___29 = get(args, tmp___28 as *mut Int as var);
            (*r).stop = Slice_Arg(1 as libc::c_int, n, tmp___29);
            __constr_expr_145.val = 3 as libc::c_int as int64_t;
            __constr_expr_146[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___30 = 1 as libc::c_uint;
            while !(tmp___30 >= 32 as libc::c_uint) {
                __constr_expr_146[tmp___30 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___30 = tmp___30.wrapping_add(1);
            }
            tmp___31 = header_init(
                __constr_expr_146.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___32 = memcpy(
                tmp___31 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_145 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___33 = get(args, tmp___32 as *mut Int as var);
            (*r).step = Slice_Arg(2 as libc::c_int, n, tmp___33);
        }
        _ => {}
    }
    return self_0;
}
unsafe extern "C" fn Slice_New(mut self_0: var, mut args: var) {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut __constr_expr_147: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_148: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_149: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    s = self_0 as *mut Slice;
    __constr_expr_148[0 as libc::c_int as usize] = Terminal;
    __constr_expr_147.items = __constr_expr_148.as_mut_ptr();
    __constr_expr_149[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_149[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_149.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_147 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = new_with(Range, tmp___1 as *mut Tuple as var);
    (*s).range = tmp___2 as *mut Range as var;
    slice_stack(self_0, args);
}
unsafe extern "C" fn Slice_Del(mut self_0: var) {
    let mut s: *mut Slice = 0 as *mut Slice;
    s = self_0 as *mut Slice;
    del((*s).range);
}
unsafe extern "C" fn Slice_Assign(mut self_0: var, mut obj: var) {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut o: *mut Slice = 0 as *mut Slice;
    let mut tmp: var = 0 as *mut libc::c_void;
    s = self_0 as *mut Slice;
    tmp = cast(obj, Slice);
    o = tmp as *mut Slice;
    (*s).iter = (*o).iter;
    assign((*s).range, (*o).range);
}
unsafe extern "C" fn Slice_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut o: *mut Slice = 0 as *mut Slice;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    s = self_0 as *mut Slice;
    tmp = cast(obj, Slice);
    o = tmp as *mut Slice;
    if (*s).iter as libc::c_ulong > (*o).iter as libc::c_ulong {
        return 1 as libc::c_int;
    }
    if ((*s).iter as libc::c_ulong) < (*o).iter as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    tmp___0 = cmp((*s).range, (*o).range);
    return tmp___0;
}
unsafe extern "C" fn Slice_Iter_Init(mut self_0: var) -> var {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut r: *mut Range = 0 as *mut Range;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut i: int64_t = 0;
    let mut curr___0: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut i___0: int64_t = 0;
    let mut tmp___1: size_t = 0;
    s = self_0 as *mut Slice;
    r = (*s).range as *mut Range;
    if (*r).step > 0 as libc::c_long {
        tmp = iter_init((*s).iter);
        curr = tmp;
        i = 0 as libc::c_int as int64_t;
        while i < (*r).start {
            curr = iter_next((*s).iter, curr);
            i += 1;
        }
        return curr;
    }
    if (*r).step < 0 as libc::c_long {
        tmp___0 = iter_last((*s).iter);
        curr___0 = tmp___0;
        i___0 = 0 as libc::c_int as int64_t;
        loop {
            tmp___1 = len((*s).iter);
            if !(i___0 < tmp___1 as int64_t - (*r).stop) {
                break;
            }
            curr___0 = iter_prev((*s).iter, curr___0);
            i___0 += 1;
        }
        return curr___0;
    }
    return Terminal;
}
unsafe extern "C" fn Slice_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: int64_t = 0;
    let mut i___0: int64_t = 0;
    s = self_0 as *mut Slice;
    r = (*s).range as *mut Range;
    if (*r).step > 0 as libc::c_long {
        i = 0 as libc::c_int as int64_t;
        while i < (*r).step {
            curr = iter_next((*s).iter, curr);
            i += 1;
        }
    }
    if (*r).step < 0 as libc::c_long {
        i___0 = 0 as libc::c_int as int64_t;
        while i___0 < -(*r).step {
            curr = iter_prev((*s).iter, curr);
            i___0 += 1;
        }
    }
    return curr;
}
unsafe extern "C" fn Slice_Iter_Type(mut self_0: var) -> var {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut tmp: var = 0 as *mut libc::c_void;
    s = self_0 as *mut Slice;
    tmp = iter_type((*s).iter);
    return tmp;
}
unsafe extern "C" fn Slice_Iter_Last(mut self_0: var) -> var {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut r: *mut Range = 0 as *mut Range;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut i: int64_t = 0;
    let mut tmp___0: size_t = 0;
    let mut curr___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut i___0: int64_t = 0;
    s = self_0 as *mut Slice;
    r = (*s).range as *mut Range;
    if (*r).step > 0 as libc::c_long {
        tmp = iter_last((*s).iter);
        curr = tmp;
        i = 0 as libc::c_int as int64_t;
        loop {
            tmp___0 = len((*s).iter);
            if !(i < tmp___0 as int64_t - (*r).stop) {
                break;
            }
            curr = iter_prev((*s).iter, curr);
            i += 1;
        }
        return curr;
    }
    if (*r).step < 0 as libc::c_long {
        tmp___1 = iter_init((*s).iter);
        curr___0 = tmp___1;
        i___0 = 0 as libc::c_int as int64_t;
        while i___0 < (*r).start {
            curr___0 = iter_next((*s).iter, curr___0);
            i___0 += 1;
        }
        return curr___0;
    }
    return Terminal;
}
unsafe extern "C" fn Slice_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut r: *mut Range = 0 as *mut Range;
    let mut i: int64_t = 0;
    let mut i___0: int64_t = 0;
    s = self_0 as *mut Slice;
    r = (*s).range as *mut Range;
    if (*r).step > 0 as libc::c_long {
        i = 0 as libc::c_int as int64_t;
        while i < (*r).step {
            curr = iter_prev((*s).iter, curr);
            i += 1;
        }
    }
    if (*r).step < 0 as libc::c_long {
        i___0 = 0 as libc::c_int as int64_t;
        while i___0 < -(*r).step {
            curr = iter_next((*s).iter, curr);
            i___0 += 1;
        }
    }
    return curr;
}
unsafe extern "C" fn Slice_Len(mut self_0: var) -> size_t {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut tmp: size_t = 0;
    s = self_0 as *mut Slice;
    tmp = Range_Len((*s).range);
    return tmp;
}
unsafe extern "C" fn Slice_Get(mut self_0: var, mut key: var) -> var {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    s = self_0 as *mut Slice;
    tmp = Range_Get((*s).range, key);
    tmp___0 = get((*s).iter, tmp);
    return tmp___0;
}
unsafe extern "C" fn Slice_Mem(mut self_0: var, mut key: var) -> bool {
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = Slice_Iter_Init(self_0);
    curr = tmp;
    while !curr.is_null() {
        tmp___0 = eq(curr, key);
        if tmp___0 {
            return 1 as libc::c_int != 0;
        }
        curr = Slice_Iter_Next(self_0, curr);
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Slice_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut s: *mut Slice = 0 as *mut Slice;
    let mut __constr_expr_150: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_151: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_152: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_153: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_154: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_155: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_156: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_157: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_158: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_159: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_160: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_161: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: libc::c_int = 0;
    s = self_0 as *mut Slice;
    __constr_expr_151[0 as libc::c_int as usize] = self_0;
    __constr_expr_151[1 as libc::c_int as usize] = Terminal;
    __constr_expr_150.items = __constr_expr_151.as_mut_ptr();
    __constr_expr_152[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_152[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_152.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_150 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"<'Slice' At 0x%p [\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    tmp___2 = Slice_Iter_Init(self_0);
    curr = tmp___2;
    while curr as libc::c_ulong != Terminal as libc::c_ulong {
        __constr_expr_154[0 as libc::c_int as usize] = curr;
        __constr_expr_154[1 as libc::c_int as usize] = Terminal;
        __constr_expr_153.items = __constr_expr_154.as_mut_ptr();
        __constr_expr_155[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_155[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_155.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_153 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            output,
            pos,
            b"%$\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        curr = Slice_Iter_Next(self_0, curr);
        if curr as libc::c_ulong != Terminal as libc::c_ulong {
            __constr_expr_157[0 as libc::c_int as usize] = Terminal;
            __constr_expr_156.items = __constr_expr_157.as_mut_ptr();
            __constr_expr_158[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = 1 as libc::c_uint;
            while !(tmp___6 >= 32 as libc::c_uint) {
                __constr_expr_158[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = tmp___6.wrapping_add(1);
            }
            tmp___7 = header_init(
                __constr_expr_158.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___8 = memcpy(
                tmp___7 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_156 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b", \0" as *const u8 as *const libc::c_char,
                tmp___8 as *mut Tuple as var,
            );
        }
    }
    __constr_expr_160[0 as libc::c_int as usize] = Terminal;
    __constr_expr_159.items = __constr_expr_160.as_mut_ptr();
    __constr_expr_161[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___9 = 1 as libc::c_uint;
    while !(tmp___9 >= 32 as libc::c_uint) {
        __constr_expr_161[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = tmp___9.wrapping_add(1);
    }
    tmp___10 = header_init(
        __constr_expr_161.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___11 = memcpy(
        tmp___10 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_159 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___12 = print_to_with(
        output,
        pos,
        b"]>\0" as *const u8 as *const libc::c_char,
        tmp___11 as *mut Tuple as var,
    );
    return tmp___12;
}
static mut __constr_expr_163: Doc = {
    let mut init = Doc {
        name: Some(Slice_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Slice_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Slice_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Slice_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Slice_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Slice_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_164: New = {
    let mut init = New {
        construct_with: Some(Slice_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Slice_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_165: Assign = {
    let mut init = Assign {
        assign: Some(Slice_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_166: Cmp = {
    let mut init = Cmp {
        cmp: Some(Slice_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_167: Len = {
    let mut init = Len {
        len: Some(Slice_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_168: Get = unsafe {
    {
        let mut init = Get {
            get: Some(Slice_Get as unsafe extern "C" fn(var, var) -> var),
            set: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            mem: Some(Slice_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_169: Iter = {
    let mut init = Iter {
        iter_init: Some(Slice_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Slice_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Slice_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Slice_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Slice_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_170: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Slice_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_162: [var; 54] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Slice\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Slice>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_163 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_164 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_165 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_166 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_167 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_168 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_169 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_170 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Slice: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Zip_Name() -> *const libc::c_char {
    return b"Zip\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Zip_Brief() -> *const libc::c_char {
    return b"Multiple Iterator\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Zip_Description() -> *const libc::c_char {
    return b"The `Zip` type can be used to combine multiple iterables into one which is then iterated over all at once and returned as a Tuple. The Zip object only iterates when all of it's sub iterators have valid items. More specifically the Zip iteration will terminate if _any_ of the sub iterators terminate.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Zip_Definition() -> *const libc::c_char {
    return b"struct Zip {\n  var iters;\n  var values;\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___4: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"/* Iterate over two iterables at once */\nvar x = new(Array, Int, $I(100), $I(200), $I(130));\nvar y = new(Array, Float, $F(0.1), $F(0.2), $F(1.3));\nforeach (pair in zip(x, y)) {\n  print(\"x: %$\\n\", get(pair, $I(0)));\n  print(\"y: %$\\n\", get(pair, $I(1)));\n}\n\n/* Iterate over iterable with count */\nforeach (pair in enumerate(x)) {\n  print(\"%i: %$\\n\", get(pair, $I(0)), get(pair, $I(1)));\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Zip_Examples() -> *mut Example {
    return examples___4.as_mut_ptr();
}
static mut methods___3: [Method; 3] = [
    {
        let mut init = Method {
            name: b"zip\0" as *const u8 as *const libc::c_char,
            definition: b"#define zip(...)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Zip` object on the stack.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"enumerate\0" as *const u8 as *const libc::c_char,
            definition: b"#define enumerate(I)\0" as *const u8 as *const libc::c_char,
            description: b"Zip the iterable `I` with a `Range` object of the same length.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Zip_Methods() -> *mut Method {
    return methods___3.as_mut_ptr();
}
pub unsafe extern "C" fn zip_stack(mut self_0: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut nargs: size_t = 0;
    let mut tmp: size_t = 0;
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    z = self_0 as *mut Zip;
    tmp = len((*z).iters);
    nargs = tmp;
    t = (*z).values as *mut Tuple;
    i = 0 as libc::c_int as size_t;
    while i < nargs {
        let ref mut fresh0 = *((*t).items).offset(i as isize);
        *fresh0 = 0 as _;
        i = i.wrapping_add(1);
    }
    let ref mut fresh1 = *((*t).items).offset(nargs as isize);
    *fresh1 = Terminal;
    return z as var;
}
unsafe extern "C" fn Zip_New(mut self_0: var, mut args: var) {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut __constr_expr_171: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_172: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_173: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_174: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_175: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_176: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut tmp___7: size_t = 0;
    z = self_0 as *mut Zip;
    __constr_expr_172[0 as libc::c_int as usize] = Terminal;
    __constr_expr_171.items = __constr_expr_172.as_mut_ptr();
    __constr_expr_173[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_173[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_173.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_171 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = new_with(Tuple, tmp___1 as *mut Tuple as var);
    (*z).iters = tmp___2 as *mut Tuple as var;
    __constr_expr_175[0 as libc::c_int as usize] = Terminal;
    __constr_expr_174.items = __constr_expr_175.as_mut_ptr();
    __constr_expr_176[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___3 = 1 as libc::c_uint;
    while !(tmp___3 >= 32 as libc::c_uint) {
        __constr_expr_176[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = tmp___3.wrapping_add(1);
    }
    tmp___4 = header_init(
        __constr_expr_176.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___5 = memcpy(
        tmp___4 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_174 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___6 = new_with(Tuple, tmp___5 as *mut Tuple as var);
    (*z).values = tmp___6 as *mut Tuple as var;
    assign((*z).iters, args);
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___7 = len(args);
        if !(i < tmp___7) {
            break;
        }
        push((*z).values, 0 as _);
        i = i.wrapping_add(1);
    };
}
unsafe extern "C" fn Zip_Del(mut self_0: var) {
    let mut z: *mut Zip = 0 as *mut Zip;
    z = self_0 as *mut Zip;
    del((*z).iters);
    del((*z).values);
}
unsafe extern "C" fn Zip_Assign(mut self_0: var, mut obj: var) {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut o: *mut Zip = 0 as *mut Zip;
    let mut tmp: var = 0 as *mut libc::c_void;
    z = self_0 as *mut Zip;
    tmp = cast(obj, Zip);
    o = tmp as *mut Zip;
    assign((*z).iters, (*o).iters);
    assign((*z).values, (*o).values);
}
unsafe extern "C" fn Zip_Iter_Init(mut self_0: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut values: *mut Tuple = 0 as *mut Tuple;
    let mut iters: *mut Tuple = 0 as *mut Tuple;
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: size_t = 0;
    let mut init: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    z = self_0 as *mut Zip;
    values = (*z).values as *mut Tuple;
    iters = (*z).iters as *mut Tuple;
    tmp = len(iters as var);
    num = tmp;
    if num == 0 as libc::c_ulong {
        return Terminal;
    }
    i = 0 as libc::c_int as size_t;
    while i < num {
        tmp___0 = iter_init(*((*iters).items).offset(i as isize));
        init = tmp___0;
        if init as libc::c_ulong == Terminal as libc::c_ulong {
            return Terminal;
        }
        let ref mut fresh2 = *((*values).items).offset(i as isize);
        *fresh2 = init;
        i = i.wrapping_add(1);
    }
    return values as var;
}
unsafe extern "C" fn Zip_Iter_Last(mut self_0: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut values: *mut Tuple = 0 as *mut Tuple;
    let mut iters: *mut Tuple = 0 as *mut Tuple;
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: size_t = 0;
    let mut last: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    z = self_0 as *mut Zip;
    values = (*z).values as *mut Tuple;
    iters = (*z).iters as *mut Tuple;
    tmp = len(iters as var);
    num = tmp;
    if num == 0 as libc::c_ulong {
        return Terminal;
    }
    i = 0 as libc::c_int as size_t;
    while i < num {
        tmp___0 = iter_last(*((*iters).items).offset(i as isize));
        last = tmp___0;
        if last as libc::c_ulong == Terminal as libc::c_ulong {
            return Terminal;
        }
        let ref mut fresh3 = *((*values).items).offset(i as isize);
        *fresh3 = last;
        i = i.wrapping_add(1);
    }
    return values as var;
}
unsafe extern "C" fn Zip_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut values: *mut Tuple = 0 as *mut Tuple;
    let mut iters: *mut Tuple = 0 as *mut Tuple;
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: size_t = 0;
    let mut next: var = 0 as *mut libc::c_void;
    let mut __constr_expr_177: Int = Int { val: 0 };
    let mut __constr_expr_178: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    z = self_0 as *mut Zip;
    values = (*z).values as *mut Tuple;
    iters = (*z).iters as *mut Tuple;
    tmp = len(iters as var);
    num = tmp;
    if num == 0 as libc::c_ulong {
        return Terminal;
    }
    i = 0 as libc::c_int as size_t;
    while i < num {
        __constr_expr_177.val = i as int64_t;
        __constr_expr_178[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_178[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_178.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_177 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___3 = get(curr, tmp___2 as *mut Int as var);
        tmp___4 = iter_next(*((*iters).items).offset(i as isize), tmp___3);
        next = tmp___4;
        if next as libc::c_ulong == Terminal as libc::c_ulong {
            return Terminal;
        }
        let ref mut fresh4 = *((*values).items).offset(i as isize);
        *fresh4 = next;
        i = i.wrapping_add(1);
    }
    return values as var;
}
unsafe extern "C" fn Zip_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut values: *mut Tuple = 0 as *mut Tuple;
    let mut iters: *mut Tuple = 0 as *mut Tuple;
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: size_t = 0;
    let mut prev: var = 0 as *mut libc::c_void;
    let mut __constr_expr_179: Int = Int { val: 0 };
    let mut __constr_expr_180: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    z = self_0 as *mut Zip;
    values = (*z).values as *mut Tuple;
    iters = (*z).iters as *mut Tuple;
    tmp = len(iters as var);
    num = tmp;
    if num == 0 as libc::c_ulong {
        return Terminal;
    }
    i = 0 as libc::c_int as size_t;
    while i < num {
        __constr_expr_179.val = i as int64_t;
        __constr_expr_180[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_180[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_180.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_179 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___3 = get(curr, tmp___2 as *mut Int as var);
        tmp___4 = iter_prev(*((*iters).items).offset(i as isize), tmp___3);
        prev = tmp___4;
        if prev as libc::c_ulong == Terminal as libc::c_ulong {
            return Terminal;
        }
        let ref mut fresh5 = *((*values).items).offset(i as isize);
        *fresh5 = prev;
        i = i.wrapping_add(1);
    }
    return values as var;
}
unsafe extern "C" fn Zip_Iter_Type(mut self_0: var) -> var {
    return Tuple;
}
unsafe extern "C" fn Zip_Len(mut self_0: var) -> size_t {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut values: *mut Tuple = 0 as *mut Tuple;
    let mut iters: *mut Tuple = 0 as *mut Tuple;
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut mlen: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut i: size_t = 0;
    let mut num___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    z = self_0 as *mut Zip;
    values = (*z).values as *mut Tuple;
    iters = (*z).iters as *mut Tuple;
    tmp = len(iters as var);
    num = tmp;
    if num == 0 as libc::c_ulong {
        return 0 as libc::c_int as size_t;
    }
    tmp___0 = len(*((*iters).items).offset(0 as libc::c_int as isize));
    mlen = tmp___0;
    i = 1 as libc::c_int as size_t;
    while i < num {
        tmp___1 = len(*((*iters).items).offset(i as isize));
        num___0 = tmp___1;
        if num___0 < mlen {
            mlen = num___0;
        } else {
            mlen = mlen;
        }
        i = i.wrapping_add(1);
    }
    return mlen;
}
unsafe extern "C" fn Zip_Get(mut self_0: var, mut key: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut values: *mut Tuple = 0 as *mut Tuple;
    let mut iters: *mut Tuple = 0 as *mut Tuple;
    let mut num: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: size_t = 0;
    z = self_0 as *mut Zip;
    values = (*z).values as *mut Tuple;
    iters = (*z).iters as *mut Tuple;
    tmp = len(iters as var);
    num = tmp;
    i = 0 as libc::c_int as size_t;
    while i < num {
        let ref mut fresh6 = *((*values).items).offset(i as isize);
        *fresh6 = get(*((*iters).items).offset(i as isize), key);
        i = i.wrapping_add(1);
    }
    return values as var;
}
unsafe extern "C" fn Zip_Mem(mut self_0: var, mut key: var) -> bool {
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    __item = self_0;
    tmp = instance(__item, Iter);
    __Iteritem = tmp;
    tmp___0 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___0;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___1 = eq(item, key);
        if tmp___1 {
            return 1 as libc::c_int != 0;
        }
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
    return 0 as libc::c_int != 0;
}
static mut __constr_expr_182: Doc = {
    let mut init = Doc {
        name: Some(Zip_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Zip_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Zip_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Zip_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Zip_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Zip_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_183: New = {
    let mut init = New {
        construct_with: Some(Zip_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Zip_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_184: Assign = {
    let mut init = Assign {
        assign: Some(Zip_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_185: Len = {
    let mut init = Len {
        len: Some(Zip_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_186: Get = unsafe {
    {
        let mut init = Get {
            get: Some(Zip_Get as unsafe extern "C" fn(var, var) -> var),
            set: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            mem: Some(Zip_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_187: Iter = {
    let mut init = Iter {
        iter_init: Some(Zip_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Zip_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Zip_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Zip_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Zip_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_181: [var; 48] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Zip\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Zip>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_182 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_183 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_184 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_185 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_186 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_187 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Zip: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn enumerate_stack(mut self_0: var) -> var {
    let mut z: *mut Zip = 0 as *mut Zip;
    let mut r: *mut Range = 0 as *mut Range;
    let mut __constr_expr_188: Int = Int { val: 0 };
    let mut __constr_expr_189: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_190: Int = Int { val: 0 };
    let mut __constr_expr_191: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    z = self_0 as *mut Zip;
    __constr_expr_188.val = 0 as libc::c_int as int64_t;
    __constr_expr_189[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_189[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_189.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_188 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get((*z).iters, tmp___1 as *mut Int as var);
    r = tmp___2 as *mut Range;
    __constr_expr_190.val = 1 as libc::c_int as int64_t;
    __constr_expr_191[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___3 = 1 as libc::c_uint;
    while !(tmp___3 >= 32 as libc::c_uint) {
        __constr_expr_191[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = tmp___3.wrapping_add(1);
    }
    tmp___4 = header_init(__constr_expr_191.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___5 = memcpy(
        tmp___4 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_190 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___6 = get((*z).iters, tmp___5 as *mut Int as var);
    tmp___7 = len(tmp___6);
    (*r).stop = tmp___7 as int64_t;
    return self_0;
}
unsafe extern "C" fn Filter_Name() -> *const libc::c_char {
    return b"Filter\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Filter_Brief() -> *const libc::c_char {
    return b"Filtered Iterable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Filter_Description() -> *const libc::c_char {
    return b"The `Filter` type can be used to filter the results of some iterable. Given a callable object `Filter` iterable returns only those items in the original iterable for where calling the function returns a non-`NULL` value.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Filter_Definition() -> *const libc::c_char {
    return b"struct Filter {\n  var iter;\n  var func;\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___5: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var greater_than_two(var x) {\n  return c_int(x) > 2 ? x : NULL;\n}\n\nvar x = new(Array, Int, $I(0), $I(5), $I(2), $I(9));\n\nforeach (n in filter(x, $(Function, greater_than_two))) {\n  show(n); /* 5, 9 */\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 2\0" as *const u8 as *const libc::c_char,
            body: b"var mem_hello(var x) {\n  return mem(x, $S(\"Hello\")) ? x : NULL;\n}\n\nvar x = new(Tuple, \n  $S(\"Hello World\"), $S(\"Hello Dan\"), \n  $S(\"Bonjour\"));\n\nvar y = new(Tuple);\nassign(y, filter(x, $(Function, mem_hello)));\nshow(y); /* tuple(\"Hello World\", \"Hello Dan\") */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Filter_Examples() -> *mut Example {
    return examples___5.as_mut_ptr();
}
static mut methods___4: [Method; 2] = [
    {
        let mut init = Method {
            name: b"filter\0" as *const u8 as *const libc::c_char,
            definition: b"#define filter(I, F)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Filter` object on the stack over iterable `I` with filter function `F`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Filter_Methods() -> *mut Method {
    return methods___4.as_mut_ptr();
}
unsafe extern "C" fn Filter_New(mut self_0: var, mut args: var) {
    let mut f: *mut Filter = 0 as *mut Filter;
    let mut __constr_expr_192: Int = Int { val: 0 };
    let mut __constr_expr_193: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_194: Int = Int { val: 0 };
    let mut __constr_expr_195: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut Filter;
    __constr_expr_192.val = 0 as libc::c_int as int64_t;
    __constr_expr_193[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_193[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_193.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_192 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*f).iter = get(args, tmp___1 as *mut Int as var);
    __constr_expr_194.val = 1 as libc::c_int as int64_t;
    __constr_expr_195[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_195[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(__constr_expr_195.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___4 = memcpy(
        tmp___3 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_194 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*f).func = get(args, tmp___4 as *mut Int as var);
}
unsafe extern "C" fn Filter_Iter_Init(mut self_0: var) -> var {
    let mut f: *mut Filter = 0 as *mut Filter;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    f = self_0 as *mut Filter;
    tmp = iter_init((*f).iter);
    curr = tmp;
    loop {
        if curr as libc::c_ulong == Terminal as libc::c_ulong {
            return curr
        } else {
            tmp___0 = call_with((*f).func, curr);
            if !tmp___0.is_null() {
                return curr
            } else {
                curr = iter_next((*f).iter, curr);
            }
        }
    };
}
unsafe extern "C" fn Filter_Iter_Last(mut self_0: var) -> var {
    let mut f: *mut Filter = 0 as *mut Filter;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    f = self_0 as *mut Filter;
    tmp = iter_last((*f).iter);
    curr = tmp;
    loop {
        if curr as libc::c_ulong == Terminal as libc::c_ulong {
            return curr
        } else {
            tmp___0 = call_with((*f).func, curr);
            if !tmp___0.is_null() {
                return curr
            } else {
                curr = iter_prev((*f).iter, curr);
            }
        }
    };
}
unsafe extern "C" fn Filter_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut f: *mut Filter = 0 as *mut Filter;
    let mut tmp: var = 0 as *mut libc::c_void;
    f = self_0 as *mut Filter;
    curr = iter_next((*f).iter, curr);
    loop {
        if curr as libc::c_ulong == Terminal as libc::c_ulong {
            return curr
        } else {
            tmp = call_with((*f).func, curr);
            if !tmp.is_null() {
                return curr
            } else {
                curr = iter_next((*f).iter, curr);
            }
        }
    };
}
unsafe extern "C" fn Filter_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut f: *mut Filter = 0 as *mut Filter;
    let mut tmp: var = 0 as *mut libc::c_void;
    f = self_0 as *mut Filter;
    curr = iter_prev((*f).iter, curr);
    loop {
        if curr as libc::c_ulong == Terminal as libc::c_ulong {
            return curr
        } else {
            tmp = call_with((*f).func, curr);
            if !tmp.is_null() {
                return curr
            } else {
                curr = iter_prev((*f).iter, curr);
            }
        }
    };
}
unsafe extern "C" fn Filter_Iter_Type(mut self_0: var) -> var {
    let mut f: *mut Filter = 0 as *mut Filter;
    let mut tmp: var = 0 as *mut libc::c_void;
    f = self_0 as *mut Filter;
    tmp = iter_type((*f).iter);
    return tmp;
}
unsafe extern "C" fn Filter_Mem(mut self_0: var, mut key: var) -> bool {
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    __item = self_0;
    tmp = instance(__item, Iter);
    __Iteritem = tmp;
    tmp___0 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___0;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___1 = eq(item, key);
        if tmp___1 {
            return 1 as libc::c_int != 0;
        }
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
    return 0 as libc::c_int != 0;
}
static mut __constr_expr_197: Doc = {
    let mut init = Doc {
        name: Some(Filter_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Filter_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Filter_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Filter_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Filter_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Filter_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_198: New = unsafe {
    {
        let mut init = New {
            construct_with: Some(Filter_New as unsafe extern "C" fn(var, var) -> ()),
            destruct: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_199: Get = unsafe {
    {
        let mut init = Get {
            get: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> var>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            set: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            mem: Some(Filter_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_200: Iter = {
    let mut init = Iter {
        iter_init: Some(Filter_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Filter_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Filter_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Filter_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Filter_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_196: [var; 42] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Filter\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Filter>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_197 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_198 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_199 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_200 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Filter: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Map_Name() -> *const libc::c_char {
    return b"Map\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Map_Brief() -> *const libc::c_char {
    return b"Apply Function to Iterable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Map_Description() -> *const libc::c_char {
    return b"The `Map` type is an iterable that applies some callable to to each item in another iterable and returns the result. This can be useful to make more concise iteration when there are callback functions available.\n\nIf the mapping callable is a purely side-effect callable it is possible to use the `call` function on the `Map` object directly for a quick way to perform the iteration.\n\nOne downside of `Map` is that the `iter_type` becomes unknown (there is no way to know what type the callable will return so some objects such as `Array`s may revert to using `Ref` as the object type when assigned a `Map`.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Map_Definition() -> *const libc::c_char {
    return b"struct Map {\n  var iter;\n  var curr;\n  var func;\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut methods___5: [Method; 2] = [
    {
        let mut init = Method {
            name: b"map\0" as *const u8 as *const libc::c_char,
            definition: b"#define map(I, F)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Map` object on the stack over iterable `I` applying function `F`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Map_Methods() -> *mut Method {
    return methods___5.as_mut_ptr();
}
static mut examples___6: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var convert_to_int(var x) {\n  var y = new(Int);\n  look_from(y, x, 0);\n  return y;\n}\n\nvar x = tuple($S(\"1\"), $S(\"2\"), $S(\"3\"));\n\nforeach (y in map(x, $(Function, convert_to_int))) {\n  show(y); /* 1, 2, 3 */\n};\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 2\0" as *const u8 as *const libc::c_char,
            body: b"var print_object(var x) {\n  println(\"Object %$ is of type %$\", x, type_of(x));\n  return NULL;\n}\n\nvar x = tuple($I(0), $S(\"Hello!\"), $F(2.4));\n\ncall(map(x, $(Function, print_object)));\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Map_Examples() -> *mut Example {
    return examples___6.as_mut_ptr();
}
unsafe extern "C" fn Map_New(mut self_0: var, mut args: var) {
    let mut m: *mut Map = 0 as *mut Map;
    let mut __constr_expr_201: Int = Int { val: 0 };
    let mut __constr_expr_202: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_203: Int = Int { val: 0 };
    let mut __constr_expr_204: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    m = self_0 as *mut Map;
    __constr_expr_201.val = 0 as libc::c_int as int64_t;
    __constr_expr_202[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_202[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_202.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_201 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*m).iter = get(args, tmp___1 as *mut Int as var);
    __constr_expr_203.val = 1 as libc::c_int as int64_t;
    __constr_expr_204[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_204[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(__constr_expr_204.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___4 = memcpy(
        tmp___3 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_203 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*m).func = get(args, tmp___4 as *mut Int as var);
}
unsafe extern "C" fn Map_Iter_Init(mut self_0: var) -> var {
    let mut m: *mut Map = 0 as *mut Map;
    let mut tmp: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Map;
    (*m).curr = iter_init((*m).iter);
    if (*m).curr as libc::c_ulong == Terminal as libc::c_ulong {
        return (*m).curr
    } else {
        tmp = call_with((*m).func, (*m).curr);
        return tmp;
    };
}
unsafe extern "C" fn Map_Iter_Last(mut self_0: var) -> var {
    let mut m: *mut Map = 0 as *mut Map;
    let mut tmp: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Map;
    (*m).curr = iter_last((*m).iter);
    if (*m).curr as libc::c_ulong == Terminal as libc::c_ulong {
        return (*m).curr
    } else {
        tmp = call_with((*m).func, (*m).curr);
        return tmp;
    };
}
unsafe extern "C" fn Map_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut m: *mut Map = 0 as *mut Map;
    let mut tmp: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Map;
    (*m).curr = iter_next((*m).iter, (*m).curr);
    if (*m).curr as libc::c_ulong == Terminal as libc::c_ulong {
        return (*m).curr
    } else {
        tmp = call_with((*m).func, (*m).curr);
        return tmp;
    };
}
unsafe extern "C" fn Map_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut m: *mut Map = 0 as *mut Map;
    let mut tmp: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Map;
    (*m).curr = iter_prev((*m).iter, (*m).curr);
    if (*m).curr as libc::c_ulong == Terminal as libc::c_ulong {
        return (*m).curr
    } else {
        tmp = call_with((*m).func, (*m).curr);
        return tmp;
    };
}
unsafe extern "C" fn Map_Len(mut self_0: var) -> size_t {
    let mut m: *mut Map = 0 as *mut Map;
    let mut tmp: size_t = 0;
    m = self_0 as *mut Map;
    tmp = len((*m).iter);
    return tmp;
}
unsafe extern "C" fn Map_Get(mut self_0: var, mut key: var) -> var {
    let mut m: *mut Map = 0 as *mut Map;
    let mut tmp: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Map;
    (*m).curr = get((*m).iter, key);
    if (*m).curr as libc::c_ulong == Terminal as libc::c_ulong {
        return (*m).curr
    } else {
        tmp = call_with((*m).func, (*m).curr);
        return tmp;
    };
}
unsafe extern "C" fn Map_Mem(mut self_0: var, mut key: var) -> bool {
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    __item = self_0;
    tmp = instance(__item, Iter);
    __Iteritem = tmp;
    tmp___0 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___0;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___1 = eq(item, key);
        if tmp___1 {
            return 1 as libc::c_int != 0;
        }
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Map_Call(mut self_0: var, mut args: var) -> var {
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    __item = self_0;
    tmp = instance(__item, Iter);
    __Iteritem = tmp;
    tmp___0 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___0;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
    return Terminal;
}
static mut __constr_expr_206: Doc = {
    let mut init = Doc {
        name: Some(Map_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Map_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Map_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Map_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Map_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Map_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_207: New = unsafe {
    {
        let mut init = New {
            construct_with: Some(Map_New as unsafe extern "C" fn(var, var) -> ()),
            destruct: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_208: Len = {
    let mut init = Len {
        len: Some(Map_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_209: Get = unsafe {
    {
        let mut init = Get {
            get: Some(Map_Get as unsafe extern "C" fn(var, var) -> var),
            set: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            mem: Some(Map_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_210: Call = {
    let mut init = Call {
        call_with: Some(Map_Call as unsafe extern "C" fn(var, var) -> var),
    };
    init
};
static mut __constr_expr_211: Iter = unsafe {
    {
        let mut init = Iter {
            iter_init: Some(Map_Iter_Init as unsafe extern "C" fn(var) -> var),
            iter_next: Some(Map_Iter_Next as unsafe extern "C" fn(var, var) -> var),
            iter_last: Some(Map_Iter_Last as unsafe extern "C" fn(var) -> var),
            iter_prev: Some(Map_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
            iter_type: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> var>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_205: [var; 48] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Map\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Map>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_206 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_207 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_208 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_209 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Call\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_210 as *const Call as *mut Call as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_211 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Map: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Assign_Name() -> *const libc::c_char {
    return b"Assign\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Assign_Brief() -> *const libc::c_char {
    return b"Assignment\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Assign_Description() -> *const libc::c_char {
    return b"`Assign` is potentially the most important class in Cello. It is used throughout Cello to initialise objects using other objects. In C++ this is called the _copy constructor_ and it is used to assign the value of one object to another.\n\nBy default the `Assign` class uses the `Size` class to copy the memory from one object to another. But for more complex objects which maintain their own behaviours and state this may need to be overridden.\n\nThe most important thing about the `Assign` class is that it must work on the assumption that the target object may not have had it's constructor called and could be uninitialised with just zero'd memory. This is often the case when copying contents into containers.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Assign_Definition() -> *const libc::c_char {
    return b"struct Assign {\n  void (*assign)(var, var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___7: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Int, $I(10));\nvar y = new(Int, $I(20));\n\nshow(x); /* 10 */\nshow(y); /* 20 */\n\nassign(x, y);\n\nshow(x); /* 20 */\nshow(y); /* 20 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Assign_Examples() -> *mut Example {
    return examples___7.as_mut_ptr();
}
static mut methods___6: [Method; 2] = [
    {
        let mut init = Method {
            name: b"assign\0" as *const u8 as *const libc::c_char,
            definition: b"var assign(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Assign the object `obj` to the object `self`. The assigned object `self` is returned.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Assign_Methods() -> *mut Method {
    return methods___6.as_mut_ptr();
}
static mut __constr_expr_213: Doc = {
    let mut init = Doc {
        name: Some(Assign_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Assign_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Assign_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Assign_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Assign_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Assign_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_212: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Assign>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_213 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Assign: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn assign(mut self_0: var, mut obj: var) -> var {
    let mut a: *mut Assign = 0 as *mut Assign;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut s: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut __constr_expr_214: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_215: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut __constr_expr_216: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    tmp = instance(self_0, Assign);
    a = tmp as *mut Assign;
    if !a.is_null() {
        if ((*a).assign).is_some() {
            (Some(((*a).assign).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, obj);
            return self_0;
        }
    }
    tmp___0 = type_of(self_0);
    tmp___1 = size(tmp___0);
    s = tmp___1;
    tmp___3 = type_of(self_0);
    tmp___4 = type_of(obj);
    if tmp___3 as libc::c_ulong == tmp___4 as libc::c_ulong {
        if s != 0 {
            tmp___2 = memcpy(self_0, obj as *const libc::c_void, s);
            return tmp___2;
        }
    }
    tmp___5 = type_of(obj);
    tmp___6 = type_of(self_0);
    __constr_expr_215[0 as libc::c_int as usize] = tmp___5;
    __constr_expr_215[1 as libc::c_int as usize] = tmp___6;
    __constr_expr_215[2 as libc::c_int as usize] = Terminal;
    __constr_expr_214.items = __constr_expr_215.as_mut_ptr();
    __constr_expr_216[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___7 = 1 as libc::c_uint;
    while !(tmp___7 >= 32 as libc::c_uint) {
        __constr_expr_216[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = tmp___7.wrapping_add(1);
    }
    tmp___8 = header_init(
        __constr_expr_216.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___9 = memcpy(
        tmp___8 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_214 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___10 = exception_throw(
        TypeError,
        b"Cannot assign type %s to type %s\0" as *const u8 as *const libc::c_char,
        tmp___9 as *mut Tuple as var,
    );
    return tmp___10;
}
unsafe extern "C" fn Swap_Name() -> *const libc::c_char {
    return b"Swap\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Swap_Brief() -> *const libc::c_char {
    return b"Swapable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Swap_Description() -> *const libc::c_char {
    return b"The `Swap` class can be used to override the behaviour of swapping two objects. By default the `Swap` class simply swaps the memory of the two objects passed in as parameters making use of the `Size` class. In almost all cases this default behaviour should be fine, even if the objects have custom assignment functions.\n\nSwapping can be used internally by various collections and algorithms.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Swap_Definition() -> *const libc::c_char {
    return b"struct Swap {\n  void (*swap)(var, var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___8: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = $S(\"Hello\");\nvar y = $S(\"World\");\nshow(x); /* Hello */\nshow(y); /* World */\nswap(x, y);\nshow(x); /* World */\nshow(y); /* Hello */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Swap_Examples() -> *mut Example {
    return examples___8.as_mut_ptr();
}
static mut methods___7: [Method; 2] = [
    {
        let mut init = Method {
            name: b"swap\0" as *const u8 as *const libc::c_char,
            definition: b"void swap(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Swap the object `self` for the object `obj`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Swap_Methods() -> *mut Method {
    return methods___7.as_mut_ptr();
}
static mut __constr_expr_218: Doc = {
    let mut init = Doc {
        name: Some(Swap_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Swap_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Swap_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Swap_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Swap_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Swap_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_217: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Swap\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Swap>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_218 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Swap: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn memswap(
    mut p0: *mut libc::c_void,
    mut p1: *mut libc::c_void,
    mut s: size_t,
) {
    let mut i: size_t = 0;
    let mut t: libc::c_char = 0;
    if p0 as libc::c_ulong == p1 as libc::c_ulong {
        return;
    }
    i = 0 as libc::c_int as size_t;
    while i < s {
        t = *(p0 as *mut libc::c_char).offset(i as isize);
        *(p0 as *mut libc::c_char)
            .offset(i as isize) = *(p1 as *mut libc::c_char).offset(i as isize);
        *(p1 as *mut libc::c_char).offset(i as isize) = t;
        i = i.wrapping_add(1);
    }
}
pub unsafe extern "C" fn swap(mut self_0: var, mut obj: var) {
    let mut s: *mut Swap = 0 as *mut Swap;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut n: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut __constr_expr_219: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_220: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut __constr_expr_221: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = instance(self_0, Swap);
    s = tmp as *mut Swap;
    if !s.is_null() {
        if ((*s).swap).is_some() {
            (Some(((*s).swap).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, obj);
            return;
        }
    }
    tmp___0 = type_of(self_0);
    tmp___1 = size(tmp___0);
    n = tmp___1;
    tmp___2 = type_of(self_0);
    tmp___3 = type_of(obj);
    if tmp___2 as libc::c_ulong == tmp___3 as libc::c_ulong {
        if n != 0 {
            memswap(self_0, obj, n);
            return;
        }
    }
    tmp___4 = type_of(obj);
    tmp___5 = type_of(self_0);
    __constr_expr_220[0 as libc::c_int as usize] = tmp___4;
    __constr_expr_220[1 as libc::c_int as usize] = tmp___5;
    __constr_expr_220[2 as libc::c_int as usize] = Terminal;
    __constr_expr_219.items = __constr_expr_220.as_mut_ptr();
    __constr_expr_221[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___6 = 1 as libc::c_uint;
    while !(tmp___6 >= 32 as libc::c_uint) {
        __constr_expr_221[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = tmp___6.wrapping_add(1);
    }
    tmp___7 = header_init(
        __constr_expr_221.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___8 = memcpy(
        tmp___7 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_219 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    exception_throw(
        TypeError,
        b"Cannot swap type %s and type %s\0" as *const u8 as *const libc::c_char,
        tmp___8 as *mut Tuple as var,
    );
}
unsafe extern "C" fn Hash_Name() -> *const libc::c_char {
    return b"Hash\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Hash_Brief() -> *const libc::c_char {
    return b"Hashable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Hash_Description() -> *const libc::c_char {
    return b"The `Hash` class provides a mechanism for hashing an object. This hash value should remain the same across objects that are also considered equal by the `Cmp` class. For objects that are not considered equal this value should aim to be evenly distributed across integers.\n\nThis is not a cryptographic hash. It is used for various objects or data structures that require fast hashing such as the `Table` type. Due to this it should not be used for cryptography or security.\n\nBy default an object is hashed by using its raw memory with the [Murmurhash](http://en.wikipedia.org/wiki/MurmurHash) algorithm. Due to the link between them it is recommended to only override `Hash` and `Cmp` in conjunction.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Hash_Definition() -> *const libc::c_char {
    return b"struct Hash {\n  uint64_t (*hash)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___9: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"println(\"%li\", $I(hash($I(  1)))); /*   1 */\nprintln(\"%li\", $I(hash($I(123)))); /* 123 */\n\n/* 866003103 */\nprintln(\"%li\", $I(hash_data($I(123), size(Int))));\n\nprintln(\"%li\", $I(hash($S(\"Hello\"))));  /* -1838682532 */\nprintln(\"%li\", $I(hash($S(\"There\"))));  /*   961387266 */\nprintln(\"%li\", $I(hash($S(\"People\")))); /*   697467069 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Hash_Examples() -> *mut Example {
    return examples___9.as_mut_ptr();
}
static mut methods___8: [Method; 3] = [
    {
        let mut init = Method {
            name: b"hash\0" as *const u8 as *const libc::c_char,
            definition: b"uint64_t hash(var self);\0" as *const u8
                as *const libc::c_char,
            description: b"Get the hash value for the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"hash_data\0" as *const u8 as *const libc::c_char,
            definition: b"uint64_t hash_data(void* data, size_t num);\0" as *const u8
                as *const libc::c_char,
            description: b"Hash `num` bytes pointed to by `data` using [Murmurhash](http://en.wikipedia.org/wiki/MurmurHash).\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Hash_Methods() -> *mut Method {
    return methods___8.as_mut_ptr();
}
static mut __constr_expr_223: Doc = {
    let mut init = Doc {
        name: Some(Hash_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Hash_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Hash_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Hash_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Hash_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Hash_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_222: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Hash>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_223 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Hash: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn hash_data(
    mut data: *const libc::c_void,
    mut size___0: size_t,
) -> uint64_t {
    let mut m: uint64_t = 0;
    let mut r: libc::c_int = 0;
    let mut d: *const uint64_t = 0 as *const uint64_t;
    let mut end: *const uint64_t = 0 as *const uint64_t;
    let mut h: uint64_t = 0;
    let mut k: uint64_t = 0;
    let mut tmp: *const uint64_t = 0 as *const uint64_t;
    let mut data2: *const libc::c_uchar = 0 as *const libc::c_uchar;
    m = 14313749767032793493 as libc::c_ulonglong as uint64_t;
    r = 47 as libc::c_int;
    d = data as *const uint64_t;
    end = d.offset(size___0.wrapping_div(8 as libc::c_ulong) as isize);
    h = 844048 as libc::c_ulong ^ size___0.wrapping_mul(m);
    while d as libc::c_ulong != end as libc::c_ulong {
        tmp = d;
        d = d.offset(1);
        k = *tmp;
        k = (k as libc::c_ulong).wrapping_mul(m) as uint64_t as uint64_t;
        k ^= k >> r;
        k = (k as libc::c_ulong).wrapping_mul(m) as uint64_t as uint64_t;
        h ^= k;
        h = (h as libc::c_ulong).wrapping_mul(m) as uint64_t as uint64_t;
    }
    data2 = d as *const libc::c_uchar;
    let mut current_block_23: u64;
    match size___0 & 7 as libc::c_ulong {
        7 => {
            h
                ^= (*data2.offset(6 as libc::c_int as isize) as uint64_t)
                    << 48 as libc::c_int;
            current_block_23 = 8405287931522655854;
        }
        6 => {
            current_block_23 = 8405287931522655854;
        }
        5 => {
            current_block_23 = 13615137227603337129;
        }
        4 => {
            current_block_23 = 175827181993450723;
        }
        3 => {
            current_block_23 = 4675412497779601446;
        }
        2 => {
            current_block_23 = 11664391011415821987;
        }
        1 => {
            current_block_23 = 14448515372204423094;
        }
        _ => {
            current_block_23 = 18317007320854588510;
        }
    }
    match current_block_23 {
        8405287931522655854 => {
            h
                ^= (*data2.offset(5 as libc::c_int as isize) as uint64_t)
                    << 40 as libc::c_int;
            current_block_23 = 13615137227603337129;
        }
        _ => {}
    }
    match current_block_23 {
        13615137227603337129 => {
            h
                ^= (*data2.offset(4 as libc::c_int as isize) as uint64_t)
                    << 32 as libc::c_int;
            current_block_23 = 175827181993450723;
        }
        _ => {}
    }
    match current_block_23 {
        175827181993450723 => {
            h
                ^= (*data2.offset(3 as libc::c_int as isize) as uint64_t)
                    << 24 as libc::c_int;
            current_block_23 = 4675412497779601446;
        }
        _ => {}
    }
    match current_block_23 {
        4675412497779601446 => {
            h
                ^= (*data2.offset(2 as libc::c_int as isize) as uint64_t)
                    << 16 as libc::c_int;
            current_block_23 = 11664391011415821987;
        }
        _ => {}
    }
    match current_block_23 {
        11664391011415821987 => {
            h
                ^= (*data2.offset(1 as libc::c_int as isize) as uint64_t)
                    << 8 as libc::c_int;
            current_block_23 = 14448515372204423094;
        }
        _ => {}
    }
    match current_block_23 {
        14448515372204423094 => {
            h ^= *data2.offset(0 as libc::c_int as isize) as uint64_t;
            h = (h as libc::c_ulong).wrapping_mul(m) as uint64_t as uint64_t;
        }
        _ => {}
    }
    h ^= h >> r;
    h = (h as libc::c_ulong).wrapping_mul(m) as uint64_t as uint64_t;
    h ^= h >> r;
    return h;
}
pub unsafe extern "C" fn hash(mut self_0: var) -> uint64_t {
    let mut h: *mut Hash = 0 as *mut Hash;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: uint64_t = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: uint64_t = 0;
    tmp = instance(self_0, Hash);
    h = tmp as *mut Hash;
    if !h.is_null() {
        if ((*h).hash).is_some() {
            tmp___0 = (Some(((*h).hash).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0);
            return tmp___0;
        }
    }
    tmp___1 = type_of(self_0);
    tmp___2 = size(tmp___1);
    tmp___3 = hash_data(self_0 as *const libc::c_void, tmp___2);
    return tmp___3;
}
unsafe extern "C" fn Push_Name() -> *const libc::c_char {
    return b"Push\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Push_Brief() -> *const libc::c_char {
    return b"Pushable and Popable object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Push_Description() -> *const libc::c_char {
    return b"The `Push` class provides an interface for the addition and removal of objects from another in a positional sense.\n\n`push` can be used to add new objects to a collection and `pop` to remove them. Usage of `push` can require `assign` to be defined on the argument.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Push_Definition() -> *const libc::c_char {
    return b"struct Push {\n  void (*push)(var, var);\n  void (*pop)(var);\n  void (*push_at)(var, var, var);\n  void (*pop_at)(var, var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___10: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int);\n\npush(x, $I( 0));\npush(x, $I( 5));\npush(x, $I(10));\n\nshow(get(x, $I(0))); /*  0 */\nshow(get(x, $I(1))); /*  5 */\nshow(get(x, $I(2))); /* 10 */\n\npop_at(x, $I(1));\n\nshow(get(x, $I(0))); /*  0 */\nshow(get(x, $I(1))); /* 10 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Push_Examples() -> *mut Example {
    return examples___10.as_mut_ptr();
}
static mut methods___9: [Method; 5] = [
    {
        let mut init = Method {
            name: b"push\0" as *const u8 as *const libc::c_char,
            definition: b"void push(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Push the object `obj` onto the top of object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"pop\0" as *const u8 as *const libc::c_char,
            definition: b"void pop(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Pop the top item from the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"push_at\0" as *const u8 as *const libc::c_char,
            definition: b"void push_at(var self, var obj, var key);\0" as *const u8
                as *const libc::c_char,
            description: b"Push the object `obj` onto the object `self` at a given `key`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"pop_at\0" as *const u8 as *const libc::c_char,
            definition: b"void pop_at(var self, var key);\0" as *const u8
                as *const libc::c_char,
            description: b"Pop the object from the object `self` at a given `key`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Push_Methods() -> *mut Method {
    return methods___9.as_mut_ptr();
}
static mut __constr_expr_225: Doc = {
    let mut init = Doc {
        name: Some(Push_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Push_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Push_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Push_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Push_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Push_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_224: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Push\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Push>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_225 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Push: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn push(mut self_0: var, mut val: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Push,
        &mut (*(0 as *mut Push)).push
            as *mut Option::<unsafe extern "C" fn(var, var) -> ()> as libc::c_ulong,
        b"push\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Push)).push).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, val);
}
pub unsafe extern "C" fn push_at(mut self_0: var, mut val: var, mut i: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Push,
        &mut (*(0 as *mut Push)).push_at
            as *mut Option::<unsafe extern "C" fn(var, var, var) -> ()> as libc::c_ulong,
        b"push_at\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Push)).push_at).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, val, i);
}
pub unsafe extern "C" fn pop(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Push,
        &mut (*(0 as *mut Push)).pop as *mut Option::<unsafe extern "C" fn(var) -> ()>
            as libc::c_ulong,
        b"pop\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Push)).pop).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn pop_at(mut self_0: var, mut i: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Push,
        &mut (*(0 as *mut Push)).pop_at
            as *mut Option::<unsafe extern "C" fn(var, var) -> ()> as libc::c_ulong,
        b"pop_at\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Push)).pop_at).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, i);
}
unsafe extern "C" fn Len_Name() -> *const libc::c_char {
    return b"Len\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Len_Brief() -> *const libc::c_char {
    return b"Has a length\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Len_Description() -> *const libc::c_char {
    return b"The `Len` class can be implemented by any type that has a length associated with it. It is typically implemented by collections and is often used in conjunction with `Iter` or `Get`.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Len_Definition() -> *const libc::c_char {
    return b"struct Len {\n  size_t (*len)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___11: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int, $I(1), $I(2), $I(5));\nshow($I(len(x))); /* 3 */\nvar y = $S(\"Test\");\nshow($I(len(y))); /* 4 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Len_Examples() -> *mut Example {
    return examples___11.as_mut_ptr();
}
static mut methods___10: [Method; 2] = [
    {
        let mut init = Method {
            name: b"len\0" as *const u8 as *const libc::c_char,
            definition: b"size_t len(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the length of object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Len_Methods() -> *mut Method {
    return methods___10.as_mut_ptr();
}
static mut __constr_expr_227: Doc = {
    let mut init = Doc {
        name: Some(Len_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Len_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Len_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Len_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Len_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Len_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_226: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Len>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_227 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Len: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn len(mut self_0: var) -> size_t {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    tmp = method_at_offset(
        self_0,
        Len,
        &mut (*(0 as *mut Len)).len as *mut Option::<unsafe extern "C" fn(var) -> size_t>
            as libc::c_ulong,
        b"len\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Len)).len).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn empty(mut self_0: var) -> bool {
    let mut tmp: size_t = 0;
    tmp = len(self_0);
    return tmp == 0 as libc::c_ulong;
}
static mut __constr_expr_228: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"TypeError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut TypeError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_229: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"ValueError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut ValueError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_230: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"ClassError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut ClassError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_231: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"IndexOutOfBoundsError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut IndexOutOfBoundsError: var = 0 as *const libc::c_void
    as *mut libc::c_void;
static mut __constr_expr_232: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"KeyError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut KeyError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_233: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"OutOfMemoryError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut OutOfMemoryError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_234: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"IOError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut IOError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_235: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"FormatError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut FormatError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_236: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"BusyError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut BusyError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_237: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"ResourceError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut ResourceError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_238: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"ProgramAbortedError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut ProgramAbortedError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_239: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"DivisionByZeroError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut DivisionByZeroError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_240: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"IllegalInstructionError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut IllegalInstructionError: var = 0 as *const libc::c_void
    as *mut libc::c_void;
static mut __constr_expr_241: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"ProgramInterruptedError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut ProgramInterruptedError: var = 0 as *const libc::c_void
    as *mut libc::c_void;
static mut __constr_expr_242: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"SegmentationError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut SegmentationError: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut __constr_expr_243: [var; 30] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"ProgramTerminationError\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut ProgramTerminationError: var = 0 as *const libc::c_void
    as *mut libc::c_void;
unsafe extern "C" fn Exception_Name() -> *const libc::c_char {
    return b"Exception\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Exception_Brief() -> *const libc::c_char {
    return b"Exception Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Exception_Description() -> *const libc::c_char {
    return b"The `Exception` type provides an interface to the Cello Exception System. One instance of this type is created for each `Thread` and stores the various bits of data required for the exception system. It can be retrieved using the `current` function, although not much can be done with it.\n\nExceptions are available via the `try`, `catch` and `throw` macros. It is important that the `catch` part of the exception block is always evaluated otherwise the internal state of the exception system can go out of sync. For this reason please never use `return` inside a `try` block. \n\nThe `exception_signals` method can be used to register some exception to be thrown for any of the [standard C signals](https://en.wikipedia.org/wiki/C_signal_handling).\n\nTo get the current exception object or message use the `exception_message` or `exception_object` methods.\0"
        as *const u8 as *const libc::c_char;
}
static mut methods___11: [Method; 7] = [
    {
        let mut init = Method {
            name: b"try\0" as *const u8 as *const libc::c_char,
            definition: b"#define try\0" as *const u8 as *const libc::c_char,
            description: b"Start an exception `try` block.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"catch\0" as *const u8 as *const libc::c_char,
            definition: b"#define catch(...)\0" as *const u8 as *const libc::c_char,
            description: b"Start an exception `catch` block, catching any objects listed in `...` as the first name given. To catch any exception object leave argument list empty other than caught variable name.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"#define throw\0" as *const u8 as *const libc::c_char,
            definition: b"throw(E, F, ...)\0" as *const u8 as *const libc::c_char,
            description: b"Throw exception object `E` with format string `F` and arguments `...`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"exception_signals\0" as *const u8 as *const libc::c_char,
            definition: b"void exception_signals(void);\0" as *const u8
                as *const libc::c_char,
            description: b"Register the standard C signals to throw corresponding exceptions.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"exception_object\0" as *const u8 as *const libc::c_char,
            definition: b"void exception_object(void);\n\0" as *const u8
                as *const libc::c_char,
            description: b"Retrieve the current exception object.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"exception_message\0" as *const u8 as *const libc::c_char,
            definition: b"void exception_message(void);\n\0" as *const u8
                as *const libc::c_char,
            description: b"Retrieve the current exception message.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Exception_Methods() -> *mut Method {
    return methods___11.as_mut_ptr();
}
static mut examples___12: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Table, String, Int);\nset(x, $S(\"Hello\"), $I(1));\nset(x, $S(\"World\"), $I(2));\n\ntry {\n  get(x, $S(\"Missing\"));\n} catch (e in KeyError) {\n  println(\"Got Exception: %$\", e);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Exception_Examples() -> *mut Example {
    return examples___12.as_mut_ptr();
}
unsafe extern "C" fn Exception_New(mut self_0: var, mut args: var) {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut __constr_expr_244: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_245: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_246: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_247: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_248: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    e = self_0 as *mut Exception;
    (*e).active = 0 as libc::c_int != 0;
    (*e).depth = 0 as libc::c_int as size_t;
    (*e).obj = 0 as *mut libc::c_void;
    __constr_expr_245[0 as libc::c_int as usize] = Terminal;
    __constr_expr_244.items = __constr_expr_245.as_mut_ptr();
    __constr_expr_246[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_246[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_246.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_244 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = new_raw_with(String, tmp___1 as *mut Tuple as var);
    (*e).msg = tmp___2 as *mut String_0 as var;
    memset(
        ((*e).buffers).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (::std::mem::size_of::<*mut jmp_buf>() as libc::c_ulong)
            .wrapping_mul(2048 as libc::c_ulong),
    );
    __constr_expr_247
        .val = b"__Exception\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    __constr_expr_248[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___3 = 1 as libc::c_uint;
    while !(tmp___3 >= 32 as libc::c_uint) {
        __constr_expr_248[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = tmp___3.wrapping_add(1);
    }
    tmp___4 = header_init(
        __constr_expr_248.as_mut_ptr() as var,
        String,
        2 as libc::c_int,
    );
    tmp___5 = memcpy(
        tmp___4 as *mut String_0 as *mut libc::c_void,
        &mut __constr_expr_247 as *mut String_0 as *const libc::c_void,
        ::std::mem::size_of::<String_0>() as libc::c_ulong,
    );
    tmp___6 = current(Thread);
    set(tmp___6, tmp___5 as *mut String_0 as var, self_0);
}
unsafe extern "C" fn Exception_Del(mut self_0: var) {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut __constr_expr_249: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_250: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    e = self_0 as *mut Exception;
    del_raw((*e).msg);
    __constr_expr_249
        .val = b"__Exception\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    __constr_expr_250[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_250[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_250.as_mut_ptr() as var,
        String,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut String_0 as *mut libc::c_void,
        &mut __constr_expr_249 as *mut String_0 as *const libc::c_void,
        ::std::mem::size_of::<String_0>() as libc::c_ulong,
    );
    tmp___2 = current(Thread);
    rem(tmp___2, tmp___1 as *mut String_0 as var);
}
unsafe extern "C" fn Exception_Assign(mut self_0: var, mut obj: var) {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut o: *mut Exception = 0 as *mut Exception;
    let mut tmp: var = 0 as *mut libc::c_void;
    e = self_0 as *mut Exception;
    tmp = cast(obj, Exception);
    o = tmp as *mut Exception;
    (*e).obj = (*o).obj;
    assign((*e).msg, (*o).msg);
    (*e).depth = (*o).depth;
    (*e).active = (*o).active;
    memcpy(
        ((*e).buffers).as_mut_ptr() as *mut libc::c_void,
        ((*o).buffers).as_mut_ptr() as *const libc::c_void,
        (::std::mem::size_of::<*mut jmp_buf>() as libc::c_ulong)
            .wrapping_mul(2048 as libc::c_ulong),
    );
}
unsafe extern "C" fn Exception_Current() -> var {
    let mut __constr_expr_251: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_252: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    __constr_expr_251
        .val = b"__Exception\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    __constr_expr_252[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_252[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_252.as_mut_ptr() as var,
        String,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut String_0 as *mut libc::c_void,
        &mut __constr_expr_251 as *mut String_0 as *const libc::c_void,
        ::std::mem::size_of::<String_0>() as libc::c_ulong,
    );
    tmp___2 = current(Thread);
    tmp___3 = get(tmp___2, tmp___1 as *mut String_0 as var);
    return tmp___3;
}
unsafe extern "C" fn Exception_Signal(mut sig: libc::c_int) {
    let mut __constr_expr_253: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_254: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_255: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_256: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_257: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_258: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_259: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_260: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_261: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_262: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_263: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_264: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_265: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_266: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_267: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_268: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_269: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_270: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut current_block_65: u64;
    match sig {
        6 => {
            __constr_expr_254[0 as libc::c_int as usize] = Terminal;
            __constr_expr_253.items = __constr_expr_254.as_mut_ptr();
            __constr_expr_255[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_255[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_255.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_253 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ProgramAbortedError,
                b"Program Aborted\0" as *const u8 as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
            current_block_65 = 16770244113040668849;
        }
        8 => {
            current_block_65 = 16770244113040668849;
        }
        4 => {
            current_block_65 = 2266920289652099341;
        }
        2 => {
            current_block_65 = 1757707648172662095;
        }
        11 => {
            current_block_65 = 6141434347333366014;
        }
        15 => {
            current_block_65 = 8900964276641706671;
        }
        _ => {
            current_block_65 = 17075014677070940716;
        }
    }
    match current_block_65 {
        16770244113040668849 => {
            __constr_expr_257[0 as libc::c_int as usize] = Terminal;
            __constr_expr_256.items = __constr_expr_257.as_mut_ptr();
            __constr_expr_258[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = 1 as libc::c_uint;
            while !(tmp___2 >= 32 as libc::c_uint) {
                __constr_expr_258[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___2 = tmp___2.wrapping_add(1);
            }
            tmp___3 = header_init(
                __constr_expr_258.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___4 = memcpy(
                tmp___3 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_256 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                DivisionByZeroError,
                b"Division by Zero\0" as *const u8 as *const libc::c_char,
                tmp___4 as *mut Tuple as var,
            );
            current_block_65 = 2266920289652099341;
        }
        _ => {}
    }
    match current_block_65 {
        2266920289652099341 => {
            __constr_expr_260[0 as libc::c_int as usize] = Terminal;
            __constr_expr_259.items = __constr_expr_260.as_mut_ptr();
            __constr_expr_261[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = 1 as libc::c_uint;
            while !(tmp___5 >= 32 as libc::c_uint) {
                __constr_expr_261[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___5 = tmp___5.wrapping_add(1);
            }
            tmp___6 = header_init(
                __constr_expr_261.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___7 = memcpy(
                tmp___6 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_259 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                IllegalInstructionError,
                b"Illegal Instruction\0" as *const u8 as *const libc::c_char,
                tmp___7 as *mut Tuple as var,
            );
            current_block_65 = 1757707648172662095;
        }
        _ => {}
    }
    match current_block_65 {
        1757707648172662095 => {
            __constr_expr_263[0 as libc::c_int as usize] = Terminal;
            __constr_expr_262.items = __constr_expr_263.as_mut_ptr();
            __constr_expr_264[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = 1 as libc::c_uint;
            while !(tmp___8 >= 32 as libc::c_uint) {
                __constr_expr_264[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___8 = tmp___8.wrapping_add(1);
            }
            tmp___9 = header_init(
                __constr_expr_264.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___10 = memcpy(
                tmp___9 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_262 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ProgramInterruptedError,
                b"Program Interrupted\0" as *const u8 as *const libc::c_char,
                tmp___10 as *mut Tuple as var,
            );
            current_block_65 = 6141434347333366014;
        }
        _ => {}
    }
    match current_block_65 {
        6141434347333366014 => {
            __constr_expr_266[0 as libc::c_int as usize] = Terminal;
            __constr_expr_265.items = __constr_expr_266.as_mut_ptr();
            __constr_expr_267[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___11 = 1 as libc::c_uint;
            while !(tmp___11 >= 32 as libc::c_uint) {
                __constr_expr_267[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___11 = tmp___11.wrapping_add(1);
            }
            tmp___12 = header_init(
                __constr_expr_267.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___13 = memcpy(
                tmp___12 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_265 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                SegmentationError,
                b"Segmentation fault\0" as *const u8 as *const libc::c_char,
                tmp___13 as *mut Tuple as var,
            );
            current_block_65 = 8900964276641706671;
        }
        _ => {}
    }
    match current_block_65 {
        8900964276641706671 => {
            __constr_expr_269[0 as libc::c_int as usize] = Terminal;
            __constr_expr_268.items = __constr_expr_269.as_mut_ptr();
            __constr_expr_270[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___14 = 1 as libc::c_uint;
            while !(tmp___14 >= 32 as libc::c_uint) {
                __constr_expr_270[tmp___14 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___14 = tmp___14.wrapping_add(1);
            }
            tmp___15 = header_init(
                __constr_expr_270.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___16 = memcpy(
                tmp___15 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_268 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ProgramTerminationError,
                b"Program Terminated\0" as *const u8 as *const libc::c_char,
                tmp___16 as *mut Tuple as var,
            );
        }
        _ => {}
    };
}
unsafe extern "C" fn Exception_Buffer(mut e: *mut Exception) -> *mut jmp_buf {
    if (*e).depth == 0 as libc::c_ulong {
        fprintf(
            stderr,
            b"Cello Fatal Error: Exception Buffer Out of Bounds!\n\0" as *const u8
                as *const libc::c_char,
        );
        abort();
    }
    return (*e).buffers[((*e).depth).wrapping_sub(1 as libc::c_ulong) as usize];
}
unsafe extern "C" fn Exception_Len(mut self_0: var) -> size_t {
    let mut e: *mut Exception = 0 as *mut Exception;
    e = self_0 as *mut Exception;
    return (*e).depth;
}
unsafe extern "C" fn Exception_Running(mut self_0: var) -> bool {
    let mut e: *mut Exception = 0 as *mut Exception;
    e = self_0 as *mut Exception;
    return (*e).active;
}
unsafe extern "C" fn Exception_Backtrace() {}
unsafe extern "C" fn Exception_Error(mut e: *mut Exception) {
    let mut __constr_expr_271: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_272: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_273: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_274: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_275: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_276: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_277: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_278: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_279: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_280: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_281: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_282: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_283: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_284: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_285: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_286: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_287: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_288: [libc::c_char; 32] = [0; 32];
    let mut tmp___17: libc::c_uint = 0;
    let mut tmp___18: var = 0 as *mut libc::c_void;
    let mut tmp___19: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_289: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_290: [libc::c_char; 32] = [0; 32];
    let mut tmp___20: libc::c_uint = 0;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_291: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_292: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_293: [libc::c_char; 32] = [0; 32];
    let mut tmp___23: libc::c_uint = 0;
    let mut tmp___24: var = 0 as *mut libc::c_void;
    let mut tmp___25: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_294: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_295: [libc::c_char; 32] = [0; 32];
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: var = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_296: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_297: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_298: [libc::c_char; 32] = [0; 32];
    let mut tmp___29: libc::c_uint = 0;
    let mut tmp___30: var = 0 as *mut libc::c_void;
    let mut tmp___31: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_299: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_300: [libc::c_char; 32] = [0; 32];
    let mut tmp___32: libc::c_uint = 0;
    let mut tmp___33: var = 0 as *mut libc::c_void;
    let mut tmp___34: *mut libc::c_void = 0 as *mut libc::c_void;
    __constr_expr_272[0 as libc::c_int as usize] = Terminal;
    __constr_expr_271.items = __constr_expr_272.as_mut_ptr();
    __constr_expr_273[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_273[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_273.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_271 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_274.file = stderr;
    __constr_expr_275[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_275[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(__constr_expr_275.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___4 = memcpy(
        tmp___3 as *mut File as *mut libc::c_void,
        &mut __constr_expr_274 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    print_to_with(
        tmp___4 as *mut File as var,
        0 as libc::c_int,
        b"\n\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    __constr_expr_277[0 as libc::c_int as usize] = Terminal;
    __constr_expr_276.items = __constr_expr_277.as_mut_ptr();
    __constr_expr_278[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___5 = 1 as libc::c_uint;
    while !(tmp___5 >= 32 as libc::c_uint) {
        __constr_expr_278[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = tmp___5.wrapping_add(1);
    }
    tmp___6 = header_init(
        __constr_expr_278.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___7 = memcpy(
        tmp___6 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_276 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_279.file = stderr;
    __constr_expr_280[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___8 = 1 as libc::c_uint;
    while !(tmp___8 >= 32 as libc::c_uint) {
        __constr_expr_280[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___8 = tmp___8.wrapping_add(1);
    }
    tmp___9 = header_init(__constr_expr_280.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___10 = memcpy(
        tmp___9 as *mut File as *mut libc::c_void,
        &mut __constr_expr_279 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    print_to_with(
        tmp___10 as *mut File as var,
        0 as libc::c_int,
        b"!!\t\n\0" as *const u8 as *const libc::c_char,
        tmp___7 as *mut Tuple as var,
    );
    __constr_expr_282[0 as libc::c_int as usize] = (*e).obj;
    __constr_expr_282[1 as libc::c_int as usize] = Terminal;
    __constr_expr_281.items = __constr_expr_282.as_mut_ptr();
    __constr_expr_283[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___11 = 1 as libc::c_uint;
    while !(tmp___11 >= 32 as libc::c_uint) {
        __constr_expr_283[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___11 = tmp___11.wrapping_add(1);
    }
    tmp___12 = header_init(
        __constr_expr_283.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___13 = memcpy(
        tmp___12 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_281 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_284.file = stderr;
    __constr_expr_285[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___14 = 1 as libc::c_uint;
    while !(tmp___14 >= 32 as libc::c_uint) {
        __constr_expr_285[tmp___14 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___14 = tmp___14.wrapping_add(1);
    }
    tmp___15 = header_init(
        __constr_expr_285.as_mut_ptr() as var,
        File,
        2 as libc::c_int,
    );
    tmp___16 = memcpy(
        tmp___15 as *mut File as *mut libc::c_void,
        &mut __constr_expr_284 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    print_to_with(
        tmp___16 as *mut File as var,
        0 as libc::c_int,
        b"!!\tUncaught %$\n\0" as *const u8 as *const libc::c_char,
        tmp___13 as *mut Tuple as var,
    );
    __constr_expr_287[0 as libc::c_int as usize] = Terminal;
    __constr_expr_286.items = __constr_expr_287.as_mut_ptr();
    __constr_expr_288[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___17 = 1 as libc::c_uint;
    while !(tmp___17 >= 32 as libc::c_uint) {
        __constr_expr_288[tmp___17 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___17 = tmp___17.wrapping_add(1);
    }
    tmp___18 = header_init(
        __constr_expr_288.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___19 = memcpy(
        tmp___18 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_286 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_289.file = stderr;
    __constr_expr_290[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___20 = 1 as libc::c_uint;
    while !(tmp___20 >= 32 as libc::c_uint) {
        __constr_expr_290[tmp___20 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___20 = tmp___20.wrapping_add(1);
    }
    tmp___21 = header_init(
        __constr_expr_290.as_mut_ptr() as var,
        File,
        2 as libc::c_int,
    );
    tmp___22 = memcpy(
        tmp___21 as *mut File as *mut libc::c_void,
        &mut __constr_expr_289 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    print_to_with(
        tmp___22 as *mut File as var,
        0 as libc::c_int,
        b"!!\t\n\0" as *const u8 as *const libc::c_char,
        tmp___19 as *mut Tuple as var,
    );
    __constr_expr_292[0 as libc::c_int as usize] = (*e).msg;
    __constr_expr_292[1 as libc::c_int as usize] = Terminal;
    __constr_expr_291.items = __constr_expr_292.as_mut_ptr();
    __constr_expr_293[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___23 = 1 as libc::c_uint;
    while !(tmp___23 >= 32 as libc::c_uint) {
        __constr_expr_293[tmp___23 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___23 = tmp___23.wrapping_add(1);
    }
    tmp___24 = header_init(
        __constr_expr_293.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___25 = memcpy(
        tmp___24 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_291 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_294.file = stderr;
    __constr_expr_295[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___26 = 1 as libc::c_uint;
    while !(tmp___26 >= 32 as libc::c_uint) {
        __constr_expr_295[tmp___26 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___26 = tmp___26.wrapping_add(1);
    }
    tmp___27 = header_init(
        __constr_expr_295.as_mut_ptr() as var,
        File,
        2 as libc::c_int,
    );
    tmp___28 = memcpy(
        tmp___27 as *mut File as *mut libc::c_void,
        &mut __constr_expr_294 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    print_to_with(
        tmp___28 as *mut File as var,
        0 as libc::c_int,
        b"!!\t\t %s\n\0" as *const u8 as *const libc::c_char,
        tmp___25 as *mut Tuple as var,
    );
    __constr_expr_297[0 as libc::c_int as usize] = Terminal;
    __constr_expr_296.items = __constr_expr_297.as_mut_ptr();
    __constr_expr_298[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___29 = 1 as libc::c_uint;
    while !(tmp___29 >= 32 as libc::c_uint) {
        __constr_expr_298[tmp___29 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___29 = tmp___29.wrapping_add(1);
    }
    tmp___30 = header_init(
        __constr_expr_298.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___31 = memcpy(
        tmp___30 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_296 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_299.file = stderr;
    __constr_expr_300[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___32 = 1 as libc::c_uint;
    while !(tmp___32 >= 32 as libc::c_uint) {
        __constr_expr_300[tmp___32 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___32 = tmp___32.wrapping_add(1);
    }
    tmp___33 = header_init(
        __constr_expr_300.as_mut_ptr() as var,
        File,
        2 as libc::c_int,
    );
    tmp___34 = memcpy(
        tmp___33 as *mut File as *mut libc::c_void,
        &mut __constr_expr_299 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    print_to_with(
        tmp___34 as *mut File as var,
        0 as libc::c_int,
        b"!!\t\n\0" as *const u8 as *const libc::c_char,
        tmp___31 as *mut Tuple as var,
    );
    Exception_Backtrace();
    exit(1 as libc::c_int);
}
unsafe extern "C" fn Exception_Show(
    mut self_0: var,
    mut out: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut __constr_expr_301: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_302: [var; 4] = [0 as *mut libc::c_void; 4];
    let mut __constr_expr_303: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    e = self_0 as *mut Exception;
    __constr_expr_302[0 as libc::c_int as usize] = self_0;
    __constr_expr_302[1 as libc::c_int as usize] = (*e).obj;
    __constr_expr_302[2 as libc::c_int as usize] = (*e).msg;
    __constr_expr_302[3 as libc::c_int as usize] = Terminal;
    __constr_expr_301.items = __constr_expr_302.as_mut_ptr();
    __constr_expr_303[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_303[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_303.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_301 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = print_to_with(
        out,
        pos,
        b"<'Exception' At 0x%p %$ - %$>\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    return tmp___2;
}
static mut __constr_expr_305: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Exception_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(
                Exception_Brief as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            description: Some(
                Exception_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Exception_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: Some(Exception_Methods as unsafe extern "C" fn() -> *mut Method),
        };
        init
    }
};
static mut __constr_expr_306: New = {
    let mut init = New {
        construct_with: Some(Exception_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Exception_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_307: Assign = {
    let mut init = Assign {
        assign: Some(Exception_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_308: Len = {
    let mut init = Len {
        len: Some(Exception_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_309: Current = {
    let mut init = Current {
        current: Some(Exception_Current as unsafe extern "C" fn() -> var),
    };
    init
};
static mut __constr_expr_310: Start = unsafe {
    {
        let mut init = Start {
            start: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            stop: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            join: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            running: Some(Exception_Running as unsafe extern "C" fn(var) -> bool),
        };
        init
    }
};
static mut __constr_expr_311: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Exception_Show
                    as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_304: [var; 51] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Exception\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Exception>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_305 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_306 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_307 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_308 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Current\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_309 as *const Current as *mut Current as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_310 as *const Start as *mut Start as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_311 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Exception: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn exception_signals() {
    signal(
        6 as libc::c_int,
        Some(Exception_Signal as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        8 as libc::c_int,
        Some(Exception_Signal as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        4 as libc::c_int,
        Some(Exception_Signal as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        2 as libc::c_int,
        Some(Exception_Signal as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        11 as libc::c_int,
        Some(Exception_Signal as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    signal(
        15 as libc::c_int,
        Some(Exception_Signal as unsafe extern "C" fn(libc::c_int) -> ()),
    );
}
pub unsafe extern "C" fn exception_try(mut env: *mut jmp_buf) {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = current(Exception);
    e = tmp as *mut Exception;
    if (*e).depth == 2048 as libc::c_ulong {
        fprintf(
            stderr,
            b"Cello Fatal Error: Exception Buffer Overflow!\n\0" as *const u8
                as *const libc::c_char,
        );
        abort();
    }
    (*e).depth = ((*e).depth).wrapping_add(1);
    (*e).active = 0 as libc::c_int != 0;
    (*e).buffers[((*e).depth).wrapping_sub(1 as libc::c_ulong) as usize] = env;
}
pub unsafe extern "C" fn exception_throw(
    mut obj: var,
    mut fmt: *const libc::c_char,
    mut args: var,
) -> var {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut jmp_buf = 0 as *mut jmp_buf;
    let mut tmp___1: size_t = 0;
    tmp = current(Exception);
    e = tmp as *mut Exception;
    (*e).obj = obj;
    print_to_with((*e).msg, 0 as libc::c_int, fmt, args);
    tmp___1 = Exception_Len(e as var);
    if tmp___1 >= 1 as libc::c_ulong {
        tmp___0 = Exception_Buffer(e);
        longjmp((*tmp___0).as_mut_ptr(), 1 as libc::c_int);
    } else {
        Exception_Error(e);
    }
    return 0 as *mut libc::c_void;
}
pub unsafe extern "C" fn exception_catch(mut args: var) -> var {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    let mut __arg: var = 0 as *mut libc::c_void;
    let mut __Iterarg: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut arg: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: bool = false;
    let mut tmp___4: *mut jmp_buf = 0 as *mut jmp_buf;
    tmp = current(Exception);
    e = tmp as *mut Exception;
    if !(*e).active {
        return 0 as *mut libc::c_void;
    }
    tmp___0 = len(args);
    if tmp___0 == 0 as libc::c_ulong {
        return (*e).obj;
    }
    __arg = args;
    tmp___1 = instance(__arg, Iter);
    __Iterarg = tmp___1;
    tmp___2 = (Some(
        ((*(__Iterarg as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__arg);
    arg = tmp___2;
    while arg as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___3 = eq(arg, (*e).obj);
        if tmp___3 {
            return (*e).obj;
        }
        arg = (Some(
            ((*(__Iterarg as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__arg, arg);
    }
    if (*e).depth >= 1 as libc::c_ulong {
        tmp___4 = Exception_Buffer(e);
        longjmp((*tmp___4).as_mut_ptr(), 1 as libc::c_int);
    } else {
        Exception_Error(e);
    }
    return 0 as *mut libc::c_void;
}
pub unsafe extern "C" fn exception_try_end() {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = current(Exception);
    e = tmp as *mut Exception;
    if (*e).depth == 0 as libc::c_ulong {
        fprintf(
            stderr,
            b"Cello Fatal Error: Exception Buffer Underflow!\n\0" as *const u8
                as *const libc::c_char,
        );
        abort();
    }
    (*e).depth = ((*e).depth).wrapping_sub(1);
}
pub unsafe extern "C" fn exception_try_fail() {
    let mut e: *mut Exception = 0 as *mut Exception;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = current(Exception);
    e = tmp as *mut Exception;
    (*e).active = 1 as libc::c_int != 0;
}
unsafe extern "C" fn Doc_Name() -> *const libc::c_char {
    return b"Doc\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Doc_Brief() -> *const libc::c_char {
    return b"Provides Documentation\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Doc_Description() -> *const libc::c_char {
    return b"The `Doc` class can be used to give documentation to a certain class or type. This documentation can then be accessed using the `help` function or by other tools used to generate documentation such as for the Cello website. Documentation can be written in Markdown.\n\nThe `examples` and `methods` entries should be provided as `NULL` terminated arrays allocated statically.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Doc_Definition() -> *const libc::c_char {
    return b"struct Example {\n  const char* name;\n  const char* body;\n};\n\nstruct Method {\n  const char* name;\n  const char* definition;\n  const char* description;\n};\n\nstruct Doc {\n  const char* (*name)(void);\n  const char* (*brief)(void);\n  const char* (*description)(void);\n  const char* (*definition)(void);\n  struct Example* (*examples)(void);\n  struct Method* (*methods)(void);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut methods___12: [Method; 5] = [
    {
        let mut init = Method {
            name: b"name\0" as *const u8 as *const libc::c_char,
            definition: b"const char* name(var type);\0" as *const u8
                as *const libc::c_char,
            description: b"Return the name of a given `type`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"brief\0" as *const u8 as *const libc::c_char,
            definition: b"const char* brief(var type);\0" as *const u8
                as *const libc::c_char,
            description: b"Return a brief description of a given `type`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"description\0" as *const u8 as *const libc::c_char,
            definition: b"const char* description(var type);\0" as *const u8
                as *const libc::c_char,
            description: b"Return a longer description of a given `type`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"definition\0" as *const u8 as *const libc::c_char,
            definition: b"const char* definition(var type);\0" as *const u8
                as *const libc::c_char,
            description: b"Return the C definition of a given `type`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Doc_Methods() -> *mut Method {
    return methods___12.as_mut_ptr();
}
static mut examples___13: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"show($S(name(Int))); /* Int */\nshow($S(brief(Int))); /* Integer Object */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Doc_Examples() -> *mut Example {
    return examples___13.as_mut_ptr();
}
static mut __constr_expr_313: Doc = {
    let mut init = Doc {
        name: Some(Doc_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Doc_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Doc_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Doc_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Doc_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Doc_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_312: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Doc>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_313 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Doc: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn name(mut type_0: var) -> *const libc::c_char {
    let mut doc: *mut Doc = 0 as *mut Doc;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = type_instance(type_0, Doc);
    doc = tmp as *mut Doc;
    if ((*doc).name).is_some() {
        tmp___0 = (Some(((*doc).name).expect("non-null function pointer")))
            .expect("non-null function pointer")();
        return tmp___0;
    }
    tmp___1 = c_str(type_0);
    return tmp___1 as *const libc::c_char;
}
pub unsafe extern "C" fn brief(mut type_0: var) -> *const libc::c_char {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    tmp = type_method_at_offset(
        type_0,
        Doc,
        &mut (*(0 as *mut Doc)).brief
            as *mut Option::<unsafe extern "C" fn() -> *const libc::c_char>
            as libc::c_ulong,
        b"brief\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Doc)).brief).expect("non-null function pointer")))
        .expect("non-null function pointer")();
    return tmp___0;
}
pub unsafe extern "C" fn description(mut type_0: var) -> *const libc::c_char {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    tmp = type_method_at_offset(
        type_0,
        Doc,
        &mut (*(0 as *mut Doc)).description
            as *mut Option::<unsafe extern "C" fn() -> *const libc::c_char>
            as libc::c_ulong,
        b"description\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Doc)).description).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")();
    return tmp___0;
}
pub unsafe extern "C" fn definition(mut type_0: var) -> *const libc::c_char {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    tmp = type_method_at_offset(
        type_0,
        Doc,
        &mut (*(0 as *mut Doc)).definition
            as *mut Option::<unsafe extern "C" fn() -> *const libc::c_char>
            as libc::c_ulong,
        b"definition\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Doc)).definition).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")();
    return tmp___0;
}
unsafe extern "C" fn Help_Name() -> *const libc::c_char {
    return b"Help\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Help_Brief() -> *const libc::c_char {
    return b"Usage information\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Help_Description() -> *const libc::c_char {
    return b"The `Help` class can be implemented to let an object provide helpful information about itself. In the standard library this class is implemented by `Type` and it prints out the documentation provided by the `Doc` class in a friendly way.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Help_Definition() -> *const libc::c_char {
    return b"struct Help {\n  int (*help_to)(var, int);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut methods___13: [Method; 2] = [
    {
        let mut init = Method {
            name: b"help\0" as *const u8 as *const libc::c_char,
            definition: b"void help(var self);\nint help_to(var out, int pos, var self);\0"
                as *const u8 as *const libc::c_char,
            description: b"Print help information about the object `self` either to `stdout` or to the object `out` at some position `pos`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Help_Methods() -> *mut Method {
    return methods___13.as_mut_ptr();
}
static mut examples___14: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"help(Int);\n\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Help_Examples() -> *mut Example {
    return examples___14.as_mut_ptr();
}
static mut __constr_expr_315: Doc = {
    let mut init = Doc {
        name: Some(Help_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Help_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Help_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Help_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Help_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Help_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_314: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Help\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Help>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_315 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Help: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn help_to(
    mut out: var,
    mut pos: libc::c_int,
    mut self_0: var,
) -> libc::c_int {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    tmp = method_at_offset(
        self_0,
        Help,
        &mut (*(0 as *mut Help)).help_to
            as *mut Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>
            as libc::c_ulong,
        b"help_to\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Help)).help_to).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, out, pos);
    return tmp___0;
}
pub unsafe extern "C" fn help(mut self_0: var) {
    let mut __constr_expr_316: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_317: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    __constr_expr_316.file = stdout;
    __constr_expr_317[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_317[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_317.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_316 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    help_to(tmp___1 as *mut File as var, 0 as libc::c_int, self_0);
}
unsafe extern "C" fn C_Str_Name() -> *const libc::c_char {
    return b"C_Str\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Str_Brief() -> *const libc::c_char {
    return b"Interpret as C String\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Str_Description() -> *const libc::c_char {
    return b"The `C_Str` class should be overridden by types which are representable as a C style String.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Str_Definition() -> *const libc::c_char {
    return b"struct C_Str {\n  char* (*c_str)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___15: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"puts(c_str($S(\"Hello\"))); /* Hello */\nputs(c_str($S(\"There\"))); /* There */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn C_Str_Examples() -> *mut Example {
    return examples___15.as_mut_ptr();
}
static mut methods___14: [Method; 2] = [
    {
        let mut init = Method {
            name: b"c_str\0" as *const u8 as *const libc::c_char,
            definition: b"char* c_str(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the object `self` represented as a `char*`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn C_Str_Methods() -> *mut Method {
    return methods___14.as_mut_ptr();
}
static mut __constr_expr_319: Doc = {
    let mut init = Doc {
        name: Some(C_Str_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(C_Str_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            C_Str_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            C_Str_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(C_Str_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(C_Str_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_318: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"C_Str\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<C_Str>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_319 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut C_Str: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn c_str(mut self_0: var) -> *mut libc::c_char {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = type_of(self_0);
    if tmp as libc::c_ulong == String as libc::c_ulong {
        return (*(self_0 as *mut String_0)).val;
    }
    tmp___0 = method_at_offset(
        self_0,
        C_Str,
        &mut (*(0 as *mut C_Str)).c_str
            as *mut Option::<unsafe extern "C" fn(var) -> *mut libc::c_char>
            as libc::c_ulong,
        b"c_str\0" as *const u8 as *const libc::c_char,
    );
    tmp___1 = (Some(
        ((*(tmp___0 as *mut C_Str)).c_str).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___1;
}
unsafe extern "C" fn String_Name() -> *const libc::c_char {
    return b"String\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn String_Brief() -> *const libc::c_char {
    return b"String Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn String_Description() -> *const libc::c_char {
    return b"The `String` type is a wrapper around the native C string type. This includes strings that are allocated on either the Stack or the Heap.\n\nFor strings allocated on the heap a number of extra operations are provided overs standard C strings such as concatenation.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn String_Definition() -> *const libc::c_char {
    return b"struct String {\n  char* val;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___16: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var s0 = $(String, \"Hello\");\nvar s1 = new(String, $S(\"Hello\"));\nappend(s1, $S(\" There\"));\nshow(s0); /* Hello */\nshow(s1); /* Hello There */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Manipulation\0" as *const u8 as *const libc::c_char,
            body: b"var s0 = new(String, $S(\"Balloons\"));\n\nshow($I(len(s0))); /* 8 */\nshow($I(mem(s0, $S(\"Ball\"))));     /* 1 */\nshow($I(mem(s0, $S(\"oon\"))));      /* 1 */\nshow($I(mem(s0, $S(\"Balloons\")))); /* 1 */\nshow($I(mem(s0, $S(\"l\"))));        /* 1 */\n\nrem(s0, $S(\"oons\"));\n\nshow($I(eq(s0, $S(\"Ball\")))); /* 1 */\n\nresize(s0, 0);\n\nshow($I(len(s0))); /* 0 */\nshow($I(eq(s0, $S(\"\")))); /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn String_Examples() -> *mut Example {
    return examples___16.as_mut_ptr();
}
unsafe extern "C" fn String_New(mut self_0: var, mut args: var) {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_320: Int = Int { val: 0 };
    let mut __constr_expr_321: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: size_t = 0;
    let mut __constr_expr_322: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_323: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_324: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    s = self_0 as *mut String_0;
    tmp___4 = len(args);
    if tmp___4 > 0 as libc::c_ulong {
        __constr_expr_320.val = 0 as libc::c_int as int64_t;
        __constr_expr_321[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_321[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_321.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_320 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___2 = get(args, tmp___1 as *mut Int as var);
        String_Assign(self_0, tmp___2);
    } else {
        tmp___3 = calloc(1 as libc::c_int as size_t, 1 as libc::c_int as size_t);
        (*s).val = tmp___3 as *mut libc::c_char;
    }
    if (*s).val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_323[0 as libc::c_int as usize] = Terminal;
        __constr_expr_322.items = __constr_expr_323.as_mut_ptr();
        __constr_expr_324[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_324[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_324.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_322 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate String, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn String_Del(mut self_0: var) {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_325: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_326: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_327: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut Header = 0 as *mut Header;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    s = self_0 as *mut String_0;
    tmp___2 = header(self_0);
    let mut current_block_13: u64;
    if (*tmp___2).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_13 = 13629532434328005020;
    } else {
        tmp___3 = header(self_0);
        if (*tmp___3).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_13 = 13629532434328005020;
        } else {
            current_block_13 = 7149356873433890176;
        }
    }
    match current_block_13 {
        13629532434328005020 => {
            __constr_expr_326[0 as libc::c_int as usize] = Terminal;
            __constr_expr_325.items = __constr_expr_326.as_mut_ptr();
            __constr_expr_327[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_327[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_327.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_325 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot destruct String, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    free((*s).val as *mut libc::c_void);
}
unsafe extern "C" fn String_Assign(mut self_0: var, mut obj: var) {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut val: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __constr_expr_328: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_329: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_330: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut tmp___4: *mut Header = 0 as *mut Header;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_331: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_332: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_333: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    s = self_0 as *mut String_0;
    tmp = c_str(obj);
    val = tmp;
    tmp___3 = header(self_0);
    let mut current_block_15: u64;
    if (*tmp___3).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_15 = 15151996724262430117;
    } else {
        tmp___4 = header(self_0);
        if (*tmp___4).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_15 = 15151996724262430117;
        } else {
            current_block_15 = 5783071609795492627;
        }
    }
    match current_block_15 {
        15151996724262430117 => {
            __constr_expr_329[0 as libc::c_int as usize] = Terminal;
            __constr_expr_328.items = __constr_expr_329.as_mut_ptr();
            __constr_expr_330[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = 1 as libc::c_uint;
            while !(tmp___0 >= 32 as libc::c_uint) {
                __constr_expr_330[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___0 = tmp___0.wrapping_add(1);
            }
            tmp___1 = header_init(
                __constr_expr_330.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___2 = memcpy(
                tmp___1 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_328 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate String, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___2 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___5 = strlen(val as *const libc::c_char);
    tmp___6 = realloc(
        (*s).val as *mut libc::c_void,
        tmp___5.wrapping_add(1 as libc::c_ulong),
    );
    (*s).val = tmp___6 as *mut libc::c_char;
    if (*s).val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_332[0 as libc::c_int as usize] = Terminal;
        __constr_expr_331.items = __constr_expr_332.as_mut_ptr();
        __constr_expr_333[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = 1 as libc::c_uint;
        while !(tmp___7 >= 32 as libc::c_uint) {
            __constr_expr_333[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___7 = tmp___7.wrapping_add(1);
        }
        tmp___8 = header_init(
            __constr_expr_333.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___9 = memcpy(
            tmp___8 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_331 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate String, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___9 as *mut Tuple as var,
        );
    }
    strcpy((*s).val, val as *const libc::c_char);
}
unsafe extern "C" fn String_C_Str(mut self_0: var) -> *mut libc::c_char {
    let mut s: *mut String_0 = 0 as *mut String_0;
    s = self_0 as *mut String_0;
    return (*s).val;
}
unsafe extern "C" fn String_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    tmp = c_str(obj);
    tmp___0 = String_C_Str(self_0);
    tmp___1 = strcmp(tmp___0 as *const libc::c_char, tmp as *const libc::c_char);
    return tmp___1;
}
unsafe extern "C" fn String_Len(mut self_0: var) -> size_t {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut tmp: size_t = 0;
    s = self_0 as *mut String_0;
    tmp = strlen((*s).val as *const libc::c_char);
    return tmp;
}
unsafe extern "C" fn String_Clear(mut self_0: var) {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_334: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_335: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_336: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut Header = 0 as *mut Header;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_337: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_338: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_339: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    s = self_0 as *mut String_0;
    tmp___2 = header(self_0);
    let mut current_block_13: u64;
    if (*tmp___2).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_13 = 12747171876953351391;
    } else {
        tmp___3 = header(self_0);
        if (*tmp___3).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_13 = 12747171876953351391;
        } else {
            current_block_13 = 7175849428784450219;
        }
    }
    match current_block_13 {
        12747171876953351391 => {
            __constr_expr_335[0 as libc::c_int as usize] = Terminal;
            __constr_expr_334.items = __constr_expr_335.as_mut_ptr();
            __constr_expr_336[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_336[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_336.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_334 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate String, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___4 = realloc((*s).val as *mut libc::c_void, 1 as libc::c_int as size_t);
    (*s).val = tmp___4 as *mut libc::c_char;
    if (*s).val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_338[0 as libc::c_int as usize] = Terminal;
        __constr_expr_337.items = __constr_expr_338.as_mut_ptr();
        __constr_expr_339[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_339[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_339.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_337 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate String, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
    }
    *((*s).val).offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
}
unsafe extern "C" fn String_Mem(mut self_0: var, mut obj: var) -> bool {
    let mut c: *mut C_Str = 0 as *mut C_Str;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = instance(obj, C_Str);
    c = tmp as *mut C_Str;
    if !c.is_null() {
        if ((*c).c_str).is_some() {
            tmp___0 = (Some(((*c).c_str).expect("non-null function pointer")))
                .expect("non-null function pointer")(obj);
            tmp___1 = String_C_Str(self_0);
            tmp___2 = strstr(
                tmp___1 as *const libc::c_char,
                tmp___0 as *const libc::c_char,
            );
            return !tmp___2.is_null();
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn String_Rem(mut self_0: var, mut obj: var) {
    let mut c: *mut C_Str = 0 as *mut C_Str;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut pos: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut count: size_t = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: size_t = 0;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: size_t = 0;
    tmp = instance(obj, C_Str);
    c = tmp as *mut C_Str;
    if !c.is_null() {
        if ((*c).c_str).is_some() {
            tmp___0 = (Some(((*c).c_str).expect("non-null function pointer")))
                .expect("non-null function pointer")(obj);
            tmp___1 = String_C_Str(self_0);
            tmp___2 = strstr(
                tmp___1 as *const libc::c_char,
                tmp___0 as *const libc::c_char,
            );
            pos = tmp___2;
            tmp___3 = String_C_Str(self_0);
            tmp___4 = strlen(tmp___3 as *const libc::c_char);
            tmp___5 = strlen(pos as *const libc::c_char);
            tmp___6 = (Some(((*c).c_str).expect("non-null function pointer")))
                .expect("non-null function pointer")(obj);
            tmp___7 = strlen(tmp___6 as *const libc::c_char);
            count = tmp___4
                .wrapping_sub(tmp___5)
                .wrapping_sub(tmp___7)
                .wrapping_add(1 as libc::c_ulong);
            tmp___8 = (Some(((*c).c_str).expect("non-null function pointer")))
                .expect("non-null function pointer")(obj);
            tmp___9 = strlen(tmp___8 as *const libc::c_char);
            memmove(
                pos as *mut libc::c_void,
                pos.offset(tmp___9 as isize) as *const libc::c_void,
                count,
            );
        }
    }
}
unsafe extern "C" fn String_Hash(mut self_0: var) -> uint64_t {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut tmp: size_t = 0;
    let mut tmp___0: uint64_t = 0;
    s = self_0 as *mut String_0;
    tmp = strlen((*s).val as *const libc::c_char);
    tmp___0 = hash_data((*s).val as *const libc::c_void, tmp);
    return tmp___0;
}
unsafe extern "C" fn String_Concat(mut self_0: var, mut obj: var) {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_340: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_341: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_342: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut Header = 0 as *mut Header;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_343: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_344: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_345: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    s = self_0 as *mut String_0;
    tmp___2 = header(self_0);
    let mut current_block_13: u64;
    if (*tmp___2).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_13 = 6427614278190608954;
    } else {
        tmp___3 = header(self_0);
        if (*tmp___3).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_13 = 6427614278190608954;
        } else {
            current_block_13 = 224731115979188411;
        }
    }
    match current_block_13 {
        6427614278190608954 => {
            __constr_expr_341[0 as libc::c_int as usize] = Terminal;
            __constr_expr_340.items = __constr_expr_341.as_mut_ptr();
            __constr_expr_342[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_342[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_342.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_340 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate String, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___4 = strlen((*s).val as *const libc::c_char);
    tmp___5 = c_str(obj);
    tmp___6 = strlen(tmp___5 as *const libc::c_char);
    tmp___7 = realloc(
        (*s).val as *mut libc::c_void,
        tmp___4.wrapping_add(tmp___6).wrapping_add(1 as libc::c_ulong),
    );
    (*s).val = tmp___7 as *mut libc::c_char;
    if (*s).val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_344[0 as libc::c_int as usize] = Terminal;
        __constr_expr_343.items = __constr_expr_344.as_mut_ptr();
        __constr_expr_345[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___8 = 1 as libc::c_uint;
        while !(tmp___8 >= 32 as libc::c_uint) {
            __constr_expr_345[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = tmp___8.wrapping_add(1);
        }
        tmp___9 = header_init(
            __constr_expr_345.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___10 = memcpy(
            tmp___9 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_343 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate String, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___10 as *mut Tuple as var,
        );
    }
    tmp___11 = c_str(obj);
    strcat((*s).val, tmp___11 as *const libc::c_char);
}
unsafe extern "C" fn String_Resize(mut self_0: var, mut n: size_t) {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_346: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_347: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_348: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut Header = 0 as *mut Header;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut m: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_349: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_350: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_351: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    s = self_0 as *mut String_0;
    tmp___2 = header(self_0);
    let mut current_block_13: u64;
    if (*tmp___2).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_13 = 9285901432815978511;
    } else {
        tmp___3 = header(self_0);
        if (*tmp___3).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_13 = 9285901432815978511;
        } else {
            current_block_13 = 4808432441040389987;
        }
    }
    match current_block_13 {
        9285901432815978511 => {
            __constr_expr_347[0 as libc::c_int as usize] = Terminal;
            __constr_expr_346.items = __constr_expr_347.as_mut_ptr();
            __constr_expr_348[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_348[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_348.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_346 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate String, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___4 = String_Len(self_0);
    m = tmp___4;
    tmp___5 = realloc((*s).val as *mut libc::c_void, n.wrapping_add(1 as libc::c_ulong));
    (*s).val = tmp___5 as *mut libc::c_char;
    if n > m {
        memset(
            ((*s).val).offset(m as isize) as *mut libc::c_void,
            0 as libc::c_int,
            n.wrapping_sub(m),
        );
    } else {
        *((*s).val).offset(n as isize) = '\u{0}' as i32 as libc::c_char;
    }
    if (*s).val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_350[0 as libc::c_int as usize] = Terminal;
        __constr_expr_349.items = __constr_expr_350.as_mut_ptr();
        __constr_expr_351[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_351[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_351.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_349 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate String, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn String_Format_To(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut va_tmp: ::std::ffi::VaListImpl;
    let mut size___0: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_352: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_353: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_354: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut tmp___4: *mut Header = 0 as *mut Header;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_355: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_356: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_357: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: libc::c_int = 0;
    s = self_0 as *mut String_0;
    va_tmp = va.clone();
    tmp = vsnprintf(
        0 as *mut libc::c_void as *mut libc::c_char,
        0 as libc::c_int as size_t,
        fmt,
        va_tmp.as_va_list(),
    );
    size___0 = tmp;
    tmp___3 = header(self_0);
    let mut current_block_17: u64;
    if (*tmp___3).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_17 = 2629698461612833301;
    } else {
        tmp___4 = header(self_0);
        if (*tmp___4).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_17 = 2629698461612833301;
        } else {
            current_block_17 = 11307063007268554308;
        }
    }
    match current_block_17 {
        2629698461612833301 => {
            __constr_expr_353[0 as libc::c_int as usize] = Terminal;
            __constr_expr_352.items = __constr_expr_353.as_mut_ptr();
            __constr_expr_354[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = 1 as libc::c_uint;
            while !(tmp___0 >= 32 as libc::c_uint) {
                __constr_expr_354[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___0 = tmp___0.wrapping_add(1);
            }
            tmp___1 = header_init(
                __constr_expr_354.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___2 = memcpy(
                tmp___1 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_352 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate String, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___2 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___5 = realloc(
        (*s).val as *mut libc::c_void,
        (pos + size___0 + 1 as libc::c_int) as size_t,
    );
    (*s).val = tmp___5 as *mut libc::c_char;
    if (*s).val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_356[0 as libc::c_int as usize] = Terminal;
        __constr_expr_355.items = __constr_expr_356.as_mut_ptr();
        __constr_expr_357[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_357[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_357.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_355 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate String, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    tmp___9 = vsprintf(((*s).val).offset(pos as isize), fmt, va.as_va_list());
    return tmp___9;
}
unsafe extern "C" fn String_Format_From(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut tmp: libc::c_int = 0;
    s = self_0 as *mut String_0;
    tmp = vsscanf(
        ((*s).val).offset(pos as isize) as *const libc::c_char,
        fmt,
        va.as_va_list(),
    );
    return tmp;
}
unsafe extern "C" fn String_Show(
    mut self_0: var,
    mut out: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut s: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_358: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_359: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_360: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut v: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __constr_expr_361: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_362: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_363: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_364: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_365: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_366: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_367: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_368: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_369: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_370: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_371: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_372: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_373: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_374: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_375: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_376: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_377: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_378: [libc::c_char; 32] = [0; 32];
    let mut tmp___17: libc::c_uint = 0;
    let mut tmp___18: var = 0 as *mut libc::c_void;
    let mut tmp___19: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_379: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_380: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_381: [libc::c_char; 32] = [0; 32];
    let mut tmp___20: libc::c_uint = 0;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_382: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_383: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_384: [libc::c_char; 32] = [0; 32];
    let mut tmp___23: libc::c_uint = 0;
    let mut tmp___24: var = 0 as *mut libc::c_void;
    let mut tmp___25: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_385: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_386: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_387: [libc::c_char; 32] = [0; 32];
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: var = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_388: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_389: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_390: [libc::c_char; 32] = [0; 32];
    let mut tmp___29: libc::c_uint = 0;
    let mut tmp___30: var = 0 as *mut libc::c_void;
    let mut tmp___31: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_391: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_392: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_393: [libc::c_char; 32] = [0; 32];
    let mut tmp___32: libc::c_uint = 0;
    let mut tmp___33: var = 0 as *mut libc::c_void;
    let mut tmp___34: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_394: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_395: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_396: Int = Int { val: 0 };
    let mut __constr_expr_397: [libc::c_char; 32] = [0; 32];
    let mut tmp___35: libc::c_uint = 0;
    let mut tmp___36: var = 0 as *mut libc::c_void;
    let mut tmp___37: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_398: [libc::c_char; 32] = [0; 32];
    let mut tmp___38: libc::c_uint = 0;
    let mut tmp___39: var = 0 as *mut libc::c_void;
    let mut tmp___40: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_399: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_400: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_401: [libc::c_char; 32] = [0; 32];
    let mut tmp___41: libc::c_uint = 0;
    let mut tmp___42: var = 0 as *mut libc::c_void;
    let mut tmp___43: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___44: libc::c_int = 0;
    s = self_0 as *mut String_0;
    __constr_expr_359[0 as libc::c_int as usize] = self_0;
    __constr_expr_359[1 as libc::c_int as usize] = Terminal;
    __constr_expr_358.items = __constr_expr_359.as_mut_ptr();
    __constr_expr_360[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_360[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_360.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_358 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        out,
        pos,
        b"\"\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    v = (*s).val;
    while *v != 0 {
        match *v as libc::c_int {
            7 => {
                __constr_expr_362[0 as libc::c_int as usize] = Terminal;
                __constr_expr_361.items = __constr_expr_362.as_mut_ptr();
                __constr_expr_363[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___2 = 1 as libc::c_uint;
                while !(tmp___2 >= 32 as libc::c_uint) {
                    __constr_expr_363[tmp___2
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___2 = tmp___2.wrapping_add(1);
                }
                tmp___3 = header_init(
                    __constr_expr_363.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___4 = memcpy(
                    tmp___3 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_361 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\a\0" as *const u8 as *const libc::c_char,
                    tmp___4 as *mut Tuple as var,
                );
            }
            8 => {
                __constr_expr_365[0 as libc::c_int as usize] = Terminal;
                __constr_expr_364.items = __constr_expr_365.as_mut_ptr();
                __constr_expr_366[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___5 = 1 as libc::c_uint;
                while !(tmp___5 >= 32 as libc::c_uint) {
                    __constr_expr_366[tmp___5
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___5 = tmp___5.wrapping_add(1);
                }
                tmp___6 = header_init(
                    __constr_expr_366.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___7 = memcpy(
                    tmp___6 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_364 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\b\0" as *const u8 as *const libc::c_char,
                    tmp___7 as *mut Tuple as var,
                );
            }
            12 => {
                __constr_expr_368[0 as libc::c_int as usize] = Terminal;
                __constr_expr_367.items = __constr_expr_368.as_mut_ptr();
                __constr_expr_369[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___8 = 1 as libc::c_uint;
                while !(tmp___8 >= 32 as libc::c_uint) {
                    __constr_expr_369[tmp___8
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___8 = tmp___8.wrapping_add(1);
                }
                tmp___9 = header_init(
                    __constr_expr_369.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___10 = memcpy(
                    tmp___9 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_367 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\f\0" as *const u8 as *const libc::c_char,
                    tmp___10 as *mut Tuple as var,
                );
            }
            10 => {
                __constr_expr_371[0 as libc::c_int as usize] = Terminal;
                __constr_expr_370.items = __constr_expr_371.as_mut_ptr();
                __constr_expr_372[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___11 = 1 as libc::c_uint;
                while !(tmp___11 >= 32 as libc::c_uint) {
                    __constr_expr_372[tmp___11
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___11 = tmp___11.wrapping_add(1);
                }
                tmp___12 = header_init(
                    __constr_expr_372.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___13 = memcpy(
                    tmp___12 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_370 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\n\0" as *const u8 as *const libc::c_char,
                    tmp___13 as *mut Tuple as var,
                );
            }
            13 => {
                __constr_expr_374[0 as libc::c_int as usize] = Terminal;
                __constr_expr_373.items = __constr_expr_374.as_mut_ptr();
                __constr_expr_375[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___14 = 1 as libc::c_uint;
                while !(tmp___14 >= 32 as libc::c_uint) {
                    __constr_expr_375[tmp___14
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___14 = tmp___14.wrapping_add(1);
                }
                tmp___15 = header_init(
                    __constr_expr_375.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___16 = memcpy(
                    tmp___15 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_373 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\r\0" as *const u8 as *const libc::c_char,
                    tmp___16 as *mut Tuple as var,
                );
            }
            9 => {
                __constr_expr_377[0 as libc::c_int as usize] = Terminal;
                __constr_expr_376.items = __constr_expr_377.as_mut_ptr();
                __constr_expr_378[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___17 = 1 as libc::c_uint;
                while !(tmp___17 >= 32 as libc::c_uint) {
                    __constr_expr_378[tmp___17
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___17 = tmp___17.wrapping_add(1);
                }
                tmp___18 = header_init(
                    __constr_expr_378.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___19 = memcpy(
                    tmp___18 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_376 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\t\0" as *const u8 as *const libc::c_char,
                    tmp___19 as *mut Tuple as var,
                );
            }
            11 => {
                __constr_expr_380[0 as libc::c_int as usize] = Terminal;
                __constr_expr_379.items = __constr_expr_380.as_mut_ptr();
                __constr_expr_381[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___20 = 1 as libc::c_uint;
                while !(tmp___20 >= 32 as libc::c_uint) {
                    __constr_expr_381[tmp___20
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___20 = tmp___20.wrapping_add(1);
                }
                tmp___21 = header_init(
                    __constr_expr_381.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___22 = memcpy(
                    tmp___21 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_379 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\v\0" as *const u8 as *const libc::c_char,
                    tmp___22 as *mut Tuple as var,
                );
            }
            92 => {
                __constr_expr_383[0 as libc::c_int as usize] = Terminal;
                __constr_expr_382.items = __constr_expr_383.as_mut_ptr();
                __constr_expr_384[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___23 = 1 as libc::c_uint;
                while !(tmp___23 >= 32 as libc::c_uint) {
                    __constr_expr_384[tmp___23
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___23 = tmp___23.wrapping_add(1);
                }
                tmp___24 = header_init(
                    __constr_expr_384.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___25 = memcpy(
                    tmp___24 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_382 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\\\\0" as *const u8 as *const libc::c_char,
                    tmp___25 as *mut Tuple as var,
                );
            }
            39 => {
                __constr_expr_386[0 as libc::c_int as usize] = Terminal;
                __constr_expr_385.items = __constr_expr_386.as_mut_ptr();
                __constr_expr_387[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___26 = 1 as libc::c_uint;
                while !(tmp___26 >= 32 as libc::c_uint) {
                    __constr_expr_387[tmp___26
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___26 = tmp___26.wrapping_add(1);
                }
                tmp___27 = header_init(
                    __constr_expr_387.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___28 = memcpy(
                    tmp___27 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_385 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\'\0" as *const u8 as *const libc::c_char,
                    tmp___28 as *mut Tuple as var,
                );
            }
            34 => {
                __constr_expr_389[0 as libc::c_int as usize] = Terminal;
                __constr_expr_388.items = __constr_expr_389.as_mut_ptr();
                __constr_expr_390[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___29 = 1 as libc::c_uint;
                while !(tmp___29 >= 32 as libc::c_uint) {
                    __constr_expr_390[tmp___29
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___29 = tmp___29.wrapping_add(1);
                }
                tmp___30 = header_init(
                    __constr_expr_390.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___31 = memcpy(
                    tmp___30 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_388 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\\"\0" as *const u8 as *const libc::c_char,
                    tmp___31 as *mut Tuple as var,
                );
            }
            63 => {
                __constr_expr_392[0 as libc::c_int as usize] = Terminal;
                __constr_expr_391.items = __constr_expr_392.as_mut_ptr();
                __constr_expr_393[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___32 = 1 as libc::c_uint;
                while !(tmp___32 >= 32 as libc::c_uint) {
                    __constr_expr_393[tmp___32
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___32 = tmp___32.wrapping_add(1);
                }
                tmp___33 = header_init(
                    __constr_expr_393.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___34 = memcpy(
                    tmp___33 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_391 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"\\?\0" as *const u8 as *const libc::c_char,
                    tmp___34 as *mut Tuple as var,
                );
            }
            _ => {
                __constr_expr_396.val = *v as int64_t;
                __constr_expr_397[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___35 = 1 as libc::c_uint;
                while !(tmp___35 >= 32 as libc::c_uint) {
                    __constr_expr_397[tmp___35
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___35 = tmp___35.wrapping_add(1);
                }
                tmp___36 = header_init(
                    __constr_expr_397.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___37 = memcpy(
                    tmp___36 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_396 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                __constr_expr_395[0 as libc::c_int
                    as usize] = tmp___37 as *mut Int as var;
                __constr_expr_395[1 as libc::c_int as usize] = Terminal;
                __constr_expr_394.items = __constr_expr_395.as_mut_ptr();
                __constr_expr_398[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___38 = 1 as libc::c_uint;
                while !(tmp___38 >= 32 as libc::c_uint) {
                    __constr_expr_398[tmp___38
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___38 = tmp___38.wrapping_add(1);
                }
                tmp___39 = header_init(
                    __constr_expr_398.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___40 = memcpy(
                    tmp___39 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_394 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                pos = print_to_with(
                    out,
                    pos,
                    b"%c\0" as *const u8 as *const libc::c_char,
                    tmp___40 as *mut Tuple as var,
                );
            }
        }
        v = v.offset(1);
    }
    __constr_expr_400[0 as libc::c_int as usize] = self_0;
    __constr_expr_400[1 as libc::c_int as usize] = Terminal;
    __constr_expr_399.items = __constr_expr_400.as_mut_ptr();
    __constr_expr_401[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___41 = 1 as libc::c_uint;
    while !(tmp___41 >= 32 as libc::c_uint) {
        __constr_expr_401[tmp___41 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___41 = tmp___41.wrapping_add(1);
    }
    tmp___42 = header_init(
        __constr_expr_401.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___43 = memcpy(
        tmp___42 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_399 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___44 = print_to_with(
        out,
        pos,
        b"\"\0" as *const u8 as *const libc::c_char,
        tmp___43 as *mut Tuple as var,
    );
    return tmp___44;
}
unsafe extern "C" fn String_Look(
    mut self_0: var,
    mut input: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut chr: var = 0 as *mut libc::c_void;
    let mut __constr_expr_402: Int = Int { val: 0 };
    let mut __constr_expr_403: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_404: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_405: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_406: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_407: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_408: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_409: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: int64_t = 0;
    let mut __constr_expr_410: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_411: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_412: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: int64_t = 0;
    let mut __constr_expr_413: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_414: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_415: [libc::c_char; 32] = [0; 32];
    let mut tmp___13: libc::c_uint = 0;
    let mut tmp___14: var = 0 as *mut libc::c_void;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: int64_t = 0;
    let mut __constr_expr_416: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_417: [libc::c_char; 32] = [0; 32];
    let mut tmp___17: libc::c_uint = 0;
    let mut tmp___18: var = 0 as *mut libc::c_void;
    let mut tmp___19: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_418: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_419: [libc::c_char; 32] = [0; 32];
    let mut tmp___20: libc::c_uint = 0;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_420: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_421: [libc::c_char; 32] = [0; 32];
    let mut tmp___23: libc::c_uint = 0;
    let mut tmp___24: var = 0 as *mut libc::c_void;
    let mut tmp___25: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_422: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_423: [libc::c_char; 32] = [0; 32];
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: var = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_424: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_425: [libc::c_char; 32] = [0; 32];
    let mut tmp___29: libc::c_uint = 0;
    let mut tmp___30: var = 0 as *mut libc::c_void;
    let mut tmp___31: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_426: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_427: [libc::c_char; 32] = [0; 32];
    let mut tmp___32: libc::c_uint = 0;
    let mut tmp___33: var = 0 as *mut libc::c_void;
    let mut tmp___34: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_428: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_429: [libc::c_char; 32] = [0; 32];
    let mut tmp___35: libc::c_uint = 0;
    let mut tmp___36: var = 0 as *mut libc::c_void;
    let mut tmp___37: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_430: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_431: [libc::c_char; 32] = [0; 32];
    let mut tmp___38: libc::c_uint = 0;
    let mut tmp___39: var = 0 as *mut libc::c_void;
    let mut tmp___40: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_432: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_433: [libc::c_char; 32] = [0; 32];
    let mut tmp___41: libc::c_uint = 0;
    let mut tmp___42: var = 0 as *mut libc::c_void;
    let mut tmp___43: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_434: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_435: [libc::c_char; 32] = [0; 32];
    let mut tmp___44: libc::c_uint = 0;
    let mut tmp___45: var = 0 as *mut libc::c_void;
    let mut tmp___46: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_436: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_437: [libc::c_char; 32] = [0; 32];
    let mut tmp___47: libc::c_uint = 0;
    let mut tmp___48: var = 0 as *mut libc::c_void;
    let mut tmp___49: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_438: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_439: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_440: [libc::c_char; 32] = [0; 32];
    let mut tmp___50: libc::c_uint = 0;
    let mut tmp___51: var = 0 as *mut libc::c_void;
    let mut tmp___52: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___53: int64_t = 0;
    let mut buffer: [libc::c_char; 2] = [0; 2];
    let mut tmp___54: int64_t = 0;
    let mut __constr_expr_441: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_442: [libc::c_char; 32] = [0; 32];
    let mut tmp___55: libc::c_uint = 0;
    let mut tmp___56: var = 0 as *mut libc::c_void;
    let mut tmp___57: *mut libc::c_void = 0 as *mut libc::c_void;
    String_Clear(self_0);
    __constr_expr_402.val = 0 as libc::c_int as int64_t;
    __constr_expr_403[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_403[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_403.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_402 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    chr = tmp___1 as *mut Int as var;
    __constr_expr_405[0 as libc::c_int as usize] = chr;
    __constr_expr_405[1 as libc::c_int as usize] = Terminal;
    __constr_expr_404.items = __constr_expr_405.as_mut_ptr();
    __constr_expr_406[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_406[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(
        __constr_expr_406.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___4 = memcpy(
        tmp___3 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_404 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = scan_from_with(
        input,
        pos,
        b"%c\0" as *const u8 as *const libc::c_char,
        tmp___4 as *mut Tuple as var,
    );
    tmp___8 = c_int(chr);
    if tmp___8 != 34 as libc::c_long {
        __constr_expr_408[0 as libc::c_int as usize] = Terminal;
        __constr_expr_407.items = __constr_expr_408.as_mut_ptr();
        __constr_expr_409[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_409[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_409.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_407 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"String literal does not start with quotation marks!\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
    }
    loop {
        __constr_expr_411[0 as libc::c_int as usize] = chr;
        __constr_expr_411[1 as libc::c_int as usize] = Terminal;
        __constr_expr_410.items = __constr_expr_411.as_mut_ptr();
        __constr_expr_412[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = 1 as libc::c_uint;
        while !(tmp___9 >= 32 as libc::c_uint) {
            __constr_expr_412[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___9 = tmp___9.wrapping_add(1);
        }
        tmp___10 = header_init(
            __constr_expr_412.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___11 = memcpy(
            tmp___10 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_410 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = scan_from_with(
            input,
            pos,
            b"%c\0" as *const u8 as *const libc::c_char,
            tmp___11 as *mut Tuple as var,
        );
        tmp___12 = c_int(chr);
        if tmp___12 == 34 as libc::c_long {
            break;
        }
        tmp___53 = c_int(chr);
        if tmp___53 == 92 as libc::c_long {
            __constr_expr_414[0 as libc::c_int as usize] = chr;
            __constr_expr_414[1 as libc::c_int as usize] = Terminal;
            __constr_expr_413.items = __constr_expr_414.as_mut_ptr();
            __constr_expr_415[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___13 = 1 as libc::c_uint;
            while !(tmp___13 >= 32 as libc::c_uint) {
                __constr_expr_415[tmp___13 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___13 = tmp___13.wrapping_add(1);
            }
            tmp___14 = header_init(
                __constr_expr_415.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___15 = memcpy(
                tmp___14 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_413 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = scan_from_with(
                input,
                pos,
                b"%c\0" as *const u8 as *const libc::c_char,
                tmp___15 as *mut Tuple as var,
            );
            tmp___16 = c_int(chr);
            match tmp___16 {
                97 => {
                    __constr_expr_416
                        .val = b"\x07\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_417[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___17 = 1 as libc::c_uint;
                    while !(tmp___17 >= 32 as libc::c_uint) {
                        __constr_expr_417[tmp___17
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___17 = tmp___17.wrapping_add(1);
                    }
                    tmp___18 = header_init(
                        __constr_expr_417.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___19 = memcpy(
                        tmp___18 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_416 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___19 as *mut String_0 as var);
                }
                98 => {
                    __constr_expr_418
                        .val = b"\x08\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_419[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___20 = 1 as libc::c_uint;
                    while !(tmp___20 >= 32 as libc::c_uint) {
                        __constr_expr_419[tmp___20
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___20 = tmp___20.wrapping_add(1);
                    }
                    tmp___21 = header_init(
                        __constr_expr_419.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___22 = memcpy(
                        tmp___21 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_418 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___22 as *mut String_0 as var);
                }
                102 => {
                    __constr_expr_420
                        .val = b"\x0C\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_421[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___23 = 1 as libc::c_uint;
                    while !(tmp___23 >= 32 as libc::c_uint) {
                        __constr_expr_421[tmp___23
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___23 = tmp___23.wrapping_add(1);
                    }
                    tmp___24 = header_init(
                        __constr_expr_421.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___25 = memcpy(
                        tmp___24 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_420 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___25 as *mut String_0 as var);
                }
                110 => {
                    __constr_expr_422
                        .val = b"\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_423[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___26 = 1 as libc::c_uint;
                    while !(tmp___26 >= 32 as libc::c_uint) {
                        __constr_expr_423[tmp___26
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___26 = tmp___26.wrapping_add(1);
                    }
                    tmp___27 = header_init(
                        __constr_expr_423.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___28 = memcpy(
                        tmp___27 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_422 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___28 as *mut String_0 as var);
                }
                114 => {
                    __constr_expr_424
                        .val = b"\r\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_425[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___29 = 1 as libc::c_uint;
                    while !(tmp___29 >= 32 as libc::c_uint) {
                        __constr_expr_425[tmp___29
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___29 = tmp___29.wrapping_add(1);
                    }
                    tmp___30 = header_init(
                        __constr_expr_425.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___31 = memcpy(
                        tmp___30 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_424 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___31 as *mut String_0 as var);
                }
                116 => {
                    __constr_expr_426
                        .val = b"\t\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_427[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___32 = 1 as libc::c_uint;
                    while !(tmp___32 >= 32 as libc::c_uint) {
                        __constr_expr_427[tmp___32
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___32 = tmp___32.wrapping_add(1);
                    }
                    tmp___33 = header_init(
                        __constr_expr_427.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___34 = memcpy(
                        tmp___33 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_426 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___34 as *mut String_0 as var);
                }
                118 => {
                    __constr_expr_428
                        .val = b"\x0B\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_429[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___35 = 1 as libc::c_uint;
                    while !(tmp___35 >= 32 as libc::c_uint) {
                        __constr_expr_429[tmp___35
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___35 = tmp___35.wrapping_add(1);
                    }
                    tmp___36 = header_init(
                        __constr_expr_429.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___37 = memcpy(
                        tmp___36 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_428 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___37 as *mut String_0 as var);
                }
                92 => {
                    __constr_expr_430
                        .val = b"\\\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_431[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___38 = 1 as libc::c_uint;
                    while !(tmp___38 >= 32 as libc::c_uint) {
                        __constr_expr_431[tmp___38
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___38 = tmp___38.wrapping_add(1);
                    }
                    tmp___39 = header_init(
                        __constr_expr_431.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___40 = memcpy(
                        tmp___39 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_430 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___40 as *mut String_0 as var);
                }
                39 => {
                    __constr_expr_432
                        .val = b"'\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_433[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___41 = 1 as libc::c_uint;
                    while !(tmp___41 >= 32 as libc::c_uint) {
                        __constr_expr_433[tmp___41
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___41 = tmp___41.wrapping_add(1);
                    }
                    tmp___42 = header_init(
                        __constr_expr_433.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___43 = memcpy(
                        tmp___42 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_432 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___43 as *mut String_0 as var);
                }
                34 => {
                    __constr_expr_434
                        .val = b"\"\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_435[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___44 = 1 as libc::c_uint;
                    while !(tmp___44 >= 32 as libc::c_uint) {
                        __constr_expr_435[tmp___44
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___44 = tmp___44.wrapping_add(1);
                    }
                    tmp___45 = header_init(
                        __constr_expr_435.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___46 = memcpy(
                        tmp___45 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_434 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___46 as *mut String_0 as var);
                }
                63 => {
                    __constr_expr_436
                        .val = b"?\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    __constr_expr_437[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___47 = 1 as libc::c_uint;
                    while !(tmp___47 >= 32 as libc::c_uint) {
                        __constr_expr_437[tmp___47
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___47 = tmp___47.wrapping_add(1);
                    }
                    tmp___48 = header_init(
                        __constr_expr_437.as_mut_ptr() as var,
                        String,
                        2 as libc::c_int,
                    );
                    tmp___49 = memcpy(
                        tmp___48 as *mut String_0 as *mut libc::c_void,
                        &mut __constr_expr_436 as *mut String_0 as *const libc::c_void,
                        ::std::mem::size_of::<String_0>() as libc::c_ulong,
                    );
                    String_Concat(self_0, tmp___49 as *mut String_0 as var);
                }
                _ => {
                    __constr_expr_439[0 as libc::c_int as usize] = chr;
                    __constr_expr_439[1 as libc::c_int as usize] = Terminal;
                    __constr_expr_438.items = __constr_expr_439.as_mut_ptr();
                    __constr_expr_440[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___50 = 1 as libc::c_uint;
                    while !(tmp___50 >= 32 as libc::c_uint) {
                        __constr_expr_440[tmp___50
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___50 = tmp___50.wrapping_add(1);
                    }
                    tmp___51 = header_init(
                        __constr_expr_440.as_mut_ptr() as var,
                        Tuple,
                        2 as libc::c_int,
                    );
                    tmp___52 = memcpy(
                        tmp___51 as *mut Tuple as *mut libc::c_void,
                        &mut __constr_expr_438 as *mut Tuple as *const libc::c_void,
                        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                    );
                    exception_throw(
                        FormatError,
                        b"Unknown Escape Sequence '\\%c'!\0" as *const u8
                            as *const libc::c_char,
                        tmp___52 as *mut Tuple as var,
                    );
                }
            }
        }
        tmp___54 = c_int(chr);
        buffer[0 as libc::c_int as usize] = tmp___54 as libc::c_char;
        buffer[1 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        __constr_expr_441.val = buffer.as_mut_ptr();
        __constr_expr_442[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___55 = 1 as libc::c_uint;
        while !(tmp___55 >= 32 as libc::c_uint) {
            __constr_expr_442[tmp___55 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___55 = tmp___55.wrapping_add(1);
        }
        tmp___56 = header_init(
            __constr_expr_442.as_mut_ptr() as var,
            String,
            2 as libc::c_int,
        );
        tmp___57 = memcpy(
            tmp___56 as *mut String_0 as *mut libc::c_void,
            &mut __constr_expr_441 as *mut String_0 as *const libc::c_void,
            ::std::mem::size_of::<String_0>() as libc::c_ulong,
        );
        String_Concat(self_0, tmp___57 as *mut String_0 as var);
    }
    return pos;
}
static mut __constr_expr_444: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(String_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(String_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                String_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                String_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(String_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_445: New = {
    let mut init = New {
        construct_with: Some(String_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(String_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_446: Assign = {
    let mut init = Assign {
        assign: Some(String_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_447: Cmp = {
    let mut init = Cmp {
        cmp: Some(String_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_448: Hash = {
    let mut init = Hash {
        hash: Some(String_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_449: Len = {
    let mut init = Len {
        len: Some(String_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_450: Get = unsafe {
    {
        let mut init = Get {
            get: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> var>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            set: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            mem: Some(String_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: Some(String_Rem as unsafe extern "C" fn(var, var) -> ()),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_451: Resize = {
    let mut init = Resize {
        resize: Some(String_Resize as unsafe extern "C" fn(var, size_t) -> ()),
    };
    init
};
static mut __constr_expr_452: Concat = {
    let mut init = Concat {
        concat: Some(String_Concat as unsafe extern "C" fn(var, var) -> ()),
        append: Some(String_Concat as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_453: C_Str = {
    let mut init = C_Str {
        c_str: Some(String_C_Str as unsafe extern "C" fn(var) -> *mut libc::c_char),
    };
    init
};
static mut __constr_expr_454: Format = {
    let mut init = Format {
        format_to: Some(
            String_Format_To
                as unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
        ),
        format_from: Some(
            String_Format_From
                as unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_455: Show = {
    let mut init = Show {
        show: Some(
            String_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
        look: Some(
            String_Look as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_443: [var; 66] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"String\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<String_0>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_444 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_445 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_446 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_447 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_448 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_449 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_450 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_451 as *const Resize as *mut Resize as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Concat\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_452 as *const Concat as *mut Concat as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"C_Str\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_453 as *const C_Str as *mut C_Str as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Format\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_454 as *const Format as *mut Format as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_455 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut String: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Cast_Name() -> *const libc::c_char {
    return b"Cast\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Cast_Brief() -> *const libc::c_char {
    return b"Runtime Type Checking\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Cast_Description() -> *const libc::c_char {
    return b"The `Cast` class provides a rudimentary run-time type checking. By default it simply checks that the passed in object is of a given type but it can be overridden by types which have to do more complex checking to ensure the types are correct.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Cast_Definition() -> *const libc::c_char {
    return b"struct Cast {\n  var (*cast)(var, var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___17: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = $I(100);\nstruct Int* y = cast(x, Int);\nshow(y);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Cast_Examples() -> *mut Example {
    return examples___17.as_mut_ptr();
}
static mut methods___15: [Method; 2] = [
    {
        let mut init = Method {
            name: b"cast\0" as *const u8 as *const libc::c_char,
            definition: b"var cast(var self, var type);\0" as *const u8
                as *const libc::c_char,
            description: b"Ensures the object `self` is of the given `type` and returns it if it is.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Cast_Methods() -> *mut Method {
    return methods___15.as_mut_ptr();
}
static mut __constr_expr_457: Doc = {
    let mut init = Doc {
        name: Some(Cast_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Cast_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Cast_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Cast_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Cast_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Cast_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_456: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Cast\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Cast>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_457 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Cast: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn cast(mut self_0: var, mut type_0: var) -> var {
    let mut c: *mut Cast = 0 as *mut Cast;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut __constr_expr_458: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_459: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut __constr_expr_460: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    tmp = instance(self_0, Cast);
    c = tmp as *mut Cast;
    if !c.is_null() {
        if ((*c).cast).is_some() {
            tmp___0 = (Some(((*c).cast).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, type_0);
            return tmp___0;
        }
    }
    tmp___6 = type_of(self_0);
    if tmp___6 as libc::c_ulong == type_0 as libc::c_ulong {
        return self_0
    } else {
        tmp___1 = type_of(self_0);
        __constr_expr_459[0 as libc::c_int as usize] = tmp___1;
        __constr_expr_459[1 as libc::c_int as usize] = type_0;
        __constr_expr_459[2 as libc::c_int as usize] = Terminal;
        __constr_expr_458.items = __constr_expr_459.as_mut_ptr();
        __constr_expr_460[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_460[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_460.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_458 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___5 = exception_throw(
            ValueError,
            b"cast expected type %s, got type %s\0" as *const u8 as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
        return tmp___5;
    };
}
unsafe extern "C" fn Type_Name() -> *const libc::c_char {
    return b"Type\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Type_Brief() -> *const libc::c_char {
    return b"Metadata Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Type_Description() -> *const libc::c_char {
    return b"The `Type` type is one of the most important types in Cello. It is the object which specifies the meta-data associated with a particular object. Most importantly this says what classes an object implements and what their instances are.\n\nOne can get the type of an object using the `type_of` function.\n\nTo see if an object implements a class `implements` can be used. To call a member of a class with an object `method` can be used.\n\nTo see if a type implements a class `type_implements` can be used. To call a member of a class, implemented `type_method` can be used.\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___18: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var t = type_of($I(5));\nshow(t); /* Int */\n\nshow($I(type_implements(t, New)));  /* 1 */\nshow($I(type_implements(t, Cmp)));  /* 1 */\nshow($I(type_implements(t, Hash))); /* 1 */\n\nshow($I(type_method(t, Cmp, cmp, $I(5), $I(6))));\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Type_Examples() -> *mut Example {
    return examples___18.as_mut_ptr();
}
static mut methods___16: [Method; 6] = [
    {
        let mut init = Method {
            name: b"type_of\0" as *const u8 as *const libc::c_char,
            definition: b"var type_of(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the `Type` of an object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"instance\0" as *const u8 as *const libc::c_char,
            definition: b"var instance(var self, var cls);\nvar type_instance(var type, var cls);\0"
                as *const u8 as *const libc::c_char,
            description: b"Returns the instance of class `cls` implemented by object `self` or type `type`. If class is not implemented then returns `NULL`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"implements\0" as *const u8 as *const libc::c_char,
            definition: b"bool implements(var self, var cls);\nbool type_implements(var type, var cls);\0"
                as *const u8 as *const libc::c_char,
            description: b"Returns if the object `self` or type `type` implements the class `cls`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"method\0" as *const u8 as *const libc::c_char,
            definition: b"#define method(X, C, M, ...)\n#define type_method(T, C, M, ...)\0"
                as *const u8 as *const libc::c_char,
            description: b"Returns the result of the call to method `M` of class `C` for object `X`or type `T`. If class is not implemented then an error is thrown.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"implements_method\0" as *const u8 as *const libc::c_char,
            definition: b"#define implements_method(X, C, M)\n#define type_implements_method(T, C, M)\0"
                as *const u8 as *const libc::c_char,
            description: b"Returns if the type `T` or object `X` implements the method `M` of class C.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Type_Methods() -> *mut Method {
    return methods___16.as_mut_ptr();
}
unsafe extern "C" fn Type_Alloc() -> var {
    let mut head: *mut Header = 0 as *mut Header;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_461: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_462: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_463: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        (::std::mem::size_of::<Header>() as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<Type>() as libc::c_ulong)
                    .wrapping_mul(265 as libc::c_ulong),
            ),
    );
    head = tmp as *mut Header;
    if head as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_462[0 as libc::c_int as usize] = Terminal;
        __constr_expr_461.items = __constr_expr_462.as_mut_ptr();
        __constr_expr_463[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_463[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_463.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_461 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot create new 'Type', out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    tmp___3 = header_init(head as var, Type, 3 as libc::c_int);
    return tmp___3;
}
unsafe extern "C" fn Type_New(mut self_0: var, mut args: var) {
    let mut t: *mut Type = 0 as *mut Type;
    let mut name___0: var = 0 as *mut libc::c_void;
    let mut __constr_expr_464: Int = Int { val: 0 };
    let mut __constr_expr_465: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut size___0: var = 0 as *mut libc::c_void;
    let mut __constr_expr_466: Int = Int { val: 0 };
    let mut __constr_expr_467: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut __constr_expr_468: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_469: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_470: Int = Int { val: 0 };
    let mut tmp___7: size_t = 0;
    let mut __constr_expr_471: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_472: Int = Int { val: 0 };
    let mut __constr_expr_473: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_474: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___17: size_t = 0;
    let mut cache_entries: size_t = 0;
    let mut i: size_t = 0;
    let mut __constr_expr_475: Type = Type {
        cls: 0 as *mut libc::c_void,
        name: 0 as *mut libc::c_void,
        inst: 0 as *mut libc::c_void,
    };
    let mut __constr_expr_476: Type = Type {
        cls: 0 as *mut libc::c_void,
        name: 0 as *mut libc::c_void,
        inst: 0 as *mut libc::c_void,
    };
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __constr_expr_477: Type = Type {
        cls: 0 as *mut libc::c_void,
        name: 0 as *mut libc::c_void,
        inst: 0 as *mut libc::c_void,
    };
    let mut tmp___19: int64_t = 0;
    let mut i___0: size_t = 0;
    let mut ins: var = 0 as *mut libc::c_void;
    let mut __constr_expr_478: Int = Int { val: 0 };
    let mut __constr_expr_479: [libc::c_char; 32] = [0; 32];
    let mut tmp___20: libc::c_uint = 0;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___23: var = 0 as *mut libc::c_void;
    let mut __constr_expr_480: Type = Type {
        cls: 0 as *mut libc::c_void,
        name: 0 as *mut libc::c_void,
        inst: 0 as *mut libc::c_void,
    };
    let mut tmp___24: var = 0 as *mut libc::c_void;
    let mut tmp___25: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___26: size_t = 0;
    let mut tmp___27: size_t = 0;
    let mut __constr_expr_481: Type = Type {
        cls: 0 as *mut libc::c_void,
        name: 0 as *mut libc::c_void,
        inst: 0 as *mut libc::c_void,
    };
    t = self_0 as *mut Type;
    __constr_expr_464.val = 0 as libc::c_int as int64_t;
    __constr_expr_465[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_465[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_465.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_464 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    name___0 = tmp___2;
    __constr_expr_466.val = 1 as libc::c_int as int64_t;
    __constr_expr_467[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___3 = 1 as libc::c_uint;
    while !(tmp___3 >= 32 as libc::c_uint) {
        __constr_expr_467[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = tmp___3.wrapping_add(1);
    }
    tmp___4 = header_init(__constr_expr_467.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___5 = memcpy(
        tmp___4 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_466 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___6 = get(args, tmp___5 as *mut Int as var);
    size___0 = tmp___6;
    tmp___17 = len(args);
    if tmp___17.wrapping_sub(2 as libc::c_ulong) > 256 as libc::c_ulong {
        tmp___7 = len(args);
        __constr_expr_470.val = tmp___7 as int64_t;
        __constr_expr_471[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___8 = 1 as libc::c_uint;
        while !(tmp___8 >= 32 as libc::c_uint) {
            __constr_expr_471[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = tmp___8.wrapping_add(1);
        }
        tmp___9 = header_init(
            __constr_expr_471.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___10 = memcpy(
            tmp___9 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_470 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_472.val = 256 as libc::c_int as int64_t;
        __constr_expr_473[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___11 = 1 as libc::c_uint;
        while !(tmp___11 >= 32 as libc::c_uint) {
            __constr_expr_473[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___11 = tmp___11.wrapping_add(1);
        }
        tmp___12 = header_init(
            __constr_expr_473.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___13 = memcpy(
            tmp___12 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_472 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_469[0 as libc::c_int as usize] = tmp___10 as *mut Int as var;
        __constr_expr_469[1 as libc::c_int as usize] = tmp___13 as *mut Int as var;
        __constr_expr_469[2 as libc::c_int as usize] = Terminal;
        __constr_expr_468.items = __constr_expr_469.as_mut_ptr();
        __constr_expr_474[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___14 = 1 as libc::c_uint;
        while !(tmp___14 >= 32 as libc::c_uint) {
            __constr_expr_474[tmp___14 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___14 = tmp___14.wrapping_add(1);
        }
        tmp___15 = header_init(
            __constr_expr_474.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___16 = memcpy(
            tmp___15 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_468 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot construct 'Type' with %i instances, maximum is %i.\0" as *const u8
                as *const libc::c_char,
            tmp___16 as *mut Tuple as var,
        );
    }
    cache_entries = 6 as libc::c_int as size_t;
    i = 0 as libc::c_int as size_t;
    while i < cache_entries {
        __constr_expr_475.cls = 0 as *mut libc::c_void;
        __constr_expr_475.name = 0 as *mut libc::c_void;
        __constr_expr_475.inst = 0 as *mut libc::c_void;
        *t.offset(i as isize) = __constr_expr_475;
        i = i.wrapping_add(1);
    }
    tmp___18 = c_str(name___0);
    __constr_expr_476.cls = 0 as *mut libc::c_void;
    __constr_expr_476.name = b"__Name\0" as *const u8 as *const libc::c_char as var;
    __constr_expr_476.inst = tmp___18 as var;
    *t.offset(cache_entries as isize) = __constr_expr_476;
    tmp___19 = c_int(size___0);
    __constr_expr_477.cls = 0 as *mut libc::c_void;
    __constr_expr_477.name = b"__Size\0" as *const u8 as *const libc::c_char as var;
    __constr_expr_477.inst = tmp___19 as uintptr_t as var;
    *t
        .offset(
            cache_entries.wrapping_add(1 as libc::c_ulong) as isize,
        ) = __constr_expr_477;
    i___0 = 2 as libc::c_int as size_t;
    loop {
        tmp___26 = len(args);
        if !(i___0 < tmp___26) {
            break;
        }
        __constr_expr_478.val = i___0 as int64_t;
        __constr_expr_479[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___20 = 1 as libc::c_uint;
        while !(tmp___20 >= 32 as libc::c_uint) {
            __constr_expr_479[tmp___20 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___20 = tmp___20.wrapping_add(1);
        }
        tmp___21 = header_init(
            __constr_expr_479.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___22 = memcpy(
            tmp___21 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_478 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___23 = get(args, tmp___22 as *mut Int as var);
        ins = tmp___23;
        tmp___24 = type_of(ins);
        tmp___25 = c_str(tmp___24);
        __constr_expr_480.cls = 0 as *mut libc::c_void;
        __constr_expr_480.name = tmp___25 as var;
        __constr_expr_480.inst = ins;
        *t.offset((6 as libc::c_ulong).wrapping_add(i___0) as isize) = __constr_expr_480;
        i___0 = i___0.wrapping_add(1);
    }
    tmp___27 = len(args);
    __constr_expr_481.cls = 0 as *mut libc::c_void;
    __constr_expr_481.name = 0 as *mut libc::c_void;
    __constr_expr_481.inst = 0 as *mut libc::c_void;
    *t
        .offset(
            (8 as libc::c_ulong).wrapping_add(tmp___27).wrapping_sub(2 as libc::c_ulong)
                as isize,
        ) = __constr_expr_481;
}
unsafe extern "C" fn Type_Builtin_Name(mut t: *mut Type) -> *mut libc::c_char {
    return (*t.offset(6 as libc::c_int as isize)).inst as *mut libc::c_char;
}
unsafe extern "C" fn Type_Builtin_Size(mut t: *mut Type) -> size_t {
    return (*t.offset(7 as libc::c_int as isize)).inst as size_t;
}
unsafe extern "C" fn Type_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_int = 0;
    tmp = Type_Builtin_Name(self_0 as *mut Type);
    tmp___0 = format_to(output, pos, b"%s\0" as *const u8 as *const libc::c_char, tmp);
    return tmp___0;
}
unsafe extern "C" fn Type_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut objt: *mut Type = 0 as *mut Type;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: libc::c_int = 0;
    tmp = cast(obj, Type);
    objt = tmp as *mut Type;
    tmp___0 = Type_Builtin_Name(objt);
    tmp___1 = Type_Builtin_Name(self_0 as *mut Type);
    tmp___2 = strcmp(tmp___1 as *const libc::c_char, tmp___0 as *const libc::c_char);
    return tmp___2;
}
unsafe extern "C" fn Type_Hash(mut self_0: var) -> uint64_t {
    let mut name___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: uint64_t = 0;
    tmp = Type_Builtin_Name(self_0 as *mut Type);
    name___0 = tmp as *const libc::c_char;
    tmp___0 = strlen(name___0);
    tmp___1 = hash_data(name___0 as *const libc::c_void, tmp___0);
    return tmp___1;
}
unsafe extern "C" fn Type_C_Str(mut self_0: var) -> *mut libc::c_char {
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = Type_Builtin_Name(self_0 as *mut Type);
    return tmp;
}
unsafe extern "C" fn Type_Assign(mut self_0: var, mut obj: var) {
    let mut __constr_expr_482: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_483: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_484: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    __constr_expr_483[0 as libc::c_int as usize] = Terminal;
    __constr_expr_482.items = __constr_expr_483.as_mut_ptr();
    __constr_expr_484[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_484[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_484.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_482 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    exception_throw(
        ValueError,
        b"Type objects cannot be assigned.\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
}
unsafe extern "C" fn Type_Copy(mut self_0: var) -> var {
    let mut __constr_expr_485: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_486: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_487: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    __constr_expr_486[0 as libc::c_int as usize] = Terminal;
    __constr_expr_485.items = __constr_expr_486.as_mut_ptr();
    __constr_expr_487[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_487[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_487.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_485 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = exception_throw(
        ValueError,
        b"Type objects cannot be copied.\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    return tmp___2;
}
unsafe extern "C" fn print_indent(
    mut out: var,
    mut pos: libc::c_int,
    mut str: *const libc::c_char,
) -> libc::c_int {
    let mut __constr_expr_488: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_489: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_490: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_491: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_492: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_493: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_494: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_495: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_496: Int = Int { val: 0 };
    let mut __constr_expr_497: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_498: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    __constr_expr_489[0 as libc::c_int as usize] = Terminal;
    __constr_expr_488.items = __constr_expr_489.as_mut_ptr();
    __constr_expr_490[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_490[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_490.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_488 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        out,
        pos,
        b"    \0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    while *str != 0 {
        if *str as libc::c_int == 10 as libc::c_int {
            __constr_expr_492[0 as libc::c_int as usize] = Terminal;
            __constr_expr_491.items = __constr_expr_492.as_mut_ptr();
            __constr_expr_493[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = 1 as libc::c_uint;
            while !(tmp___2 >= 32 as libc::c_uint) {
                __constr_expr_493[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___2 = tmp___2.wrapping_add(1);
            }
            tmp___3 = header_init(
                __constr_expr_493.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___4 = memcpy(
                tmp___3 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_491 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"\n    \0" as *const u8 as *const libc::c_char,
                tmp___4 as *mut Tuple as var,
            );
        } else {
            __constr_expr_496.val = *str as int64_t;
            __constr_expr_497[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = 1 as libc::c_uint;
            while !(tmp___5 >= 32 as libc::c_uint) {
                __constr_expr_497[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___5 = tmp___5.wrapping_add(1);
            }
            tmp___6 = header_init(
                __constr_expr_497.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___7 = memcpy(
                tmp___6 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_496 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            __constr_expr_495[0 as libc::c_int as usize] = tmp___7 as *mut Int as var;
            __constr_expr_495[1 as libc::c_int as usize] = Terminal;
            __constr_expr_494.items = __constr_expr_495.as_mut_ptr();
            __constr_expr_498[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = 1 as libc::c_uint;
            while !(tmp___8 >= 32 as libc::c_uint) {
                __constr_expr_498[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___8 = tmp___8.wrapping_add(1);
            }
            tmp___9 = header_init(
                __constr_expr_498.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___10 = memcpy(
                tmp___9 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_494 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"%c\0" as *const u8 as *const libc::c_char,
                tmp___10 as *mut Tuple as var,
            );
        }
        str = str.offset(1);
    }
    return pos;
}
unsafe extern "C" fn Type_Help_To(
    mut self_0: var,
    mut out: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut doc: *mut Doc = 0 as *mut Doc;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut __constr_expr_499: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_500: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_501: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: libc::c_int = 0;
    let mut __constr_expr_502: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_503: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_504: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_505: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_506: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_507: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_508: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_509: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_510: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut __constr_expr_511: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_512: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_513: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_514: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_515: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut tmp___17: *const libc::c_char = 0 as *const libc::c_char;
    let mut __constr_expr_516: [libc::c_char; 32] = [0; 32];
    let mut tmp___18: libc::c_uint = 0;
    let mut tmp___19: var = 0 as *mut libc::c_void;
    let mut tmp___20: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_517: [libc::c_char; 32] = [0; 32];
    let mut tmp___21: libc::c_uint = 0;
    let mut tmp___22: var = 0 as *mut libc::c_void;
    let mut tmp___23: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_518: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_519: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_520: [libc::c_char; 32] = [0; 32];
    let mut tmp___24: libc::c_uint = 0;
    let mut tmp___25: var = 0 as *mut libc::c_void;
    let mut tmp___26: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___27: *const libc::c_char = 0 as *const libc::c_char;
    let mut __constr_expr_521: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_522: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_523: [libc::c_char; 32] = [0; 32];
    let mut tmp___28: libc::c_uint = 0;
    let mut tmp___29: var = 0 as *mut libc::c_void;
    let mut tmp___30: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_524: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_525: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_526: [libc::c_char; 32] = [0; 32];
    let mut tmp___31: libc::c_uint = 0;
    let mut tmp___32: var = 0 as *mut libc::c_void;
    let mut tmp___33: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut methods___37: *mut Method = 0 as *mut Method;
    let mut tmp___34: *mut Method = 0 as *mut Method;
    let mut __constr_expr_527: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_528: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_529: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_530: [libc::c_char; 32] = [0; 32];
    let mut tmp___35: libc::c_uint = 0;
    let mut tmp___36: var = 0 as *mut libc::c_void;
    let mut tmp___37: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_531: [libc::c_char; 32] = [0; 32];
    let mut tmp___38: libc::c_uint = 0;
    let mut tmp___39: var = 0 as *mut libc::c_void;
    let mut tmp___40: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_532: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_533: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_534: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_535: [libc::c_char; 32] = [0; 32];
    let mut tmp___41: libc::c_uint = 0;
    let mut tmp___42: var = 0 as *mut libc::c_void;
    let mut tmp___43: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_536: [libc::c_char; 32] = [0; 32];
    let mut tmp___44: libc::c_uint = 0;
    let mut tmp___45: var = 0 as *mut libc::c_void;
    let mut tmp___46: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_537: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_538: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_539: [libc::c_char; 32] = [0; 32];
    let mut tmp___47: libc::c_uint = 0;
    let mut tmp___48: var = 0 as *mut libc::c_void;
    let mut tmp___49: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut examples___51: *mut Example = 0 as *mut Example;
    let mut tmp___50: *mut Example = 0 as *mut Example;
    let mut __constr_expr_540: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_541: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_542: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_543: [libc::c_char; 32] = [0; 32];
    let mut tmp___51: libc::c_uint = 0;
    let mut tmp___52: var = 0 as *mut libc::c_void;
    let mut tmp___53: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_544: [libc::c_char; 32] = [0; 32];
    let mut tmp___54: libc::c_uint = 0;
    let mut tmp___55: var = 0 as *mut libc::c_void;
    let mut tmp___56: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_545: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_546: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_547: [libc::c_char; 32] = [0; 32];
    let mut tmp___57: libc::c_uint = 0;
    let mut tmp___58: var = 0 as *mut libc::c_void;
    let mut tmp___59: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_548: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_549: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_550: [libc::c_char; 32] = [0; 32];
    let mut tmp___60: libc::c_uint = 0;
    let mut tmp___61: var = 0 as *mut libc::c_void;
    let mut tmp___62: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = type_instance(self_0, Doc);
    doc = tmp as *mut Doc;
    if doc as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_500[0 as libc::c_int as usize] = self_0;
        __constr_expr_500[1 as libc::c_int as usize] = Terminal;
        __constr_expr_499.items = __constr_expr_500.as_mut_ptr();
        __constr_expr_501[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_501[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_501.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_499 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___3 = print_to_with(
            out,
            pos,
            b"\nNo Documentation Found for Type %s\n\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
        return tmp___3;
    }
    __constr_expr_503[0 as libc::c_int as usize] = Terminal;
    __constr_expr_502.items = __constr_expr_503.as_mut_ptr();
    __constr_expr_504[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___4 = 1 as libc::c_uint;
    while !(tmp___4 >= 32 as libc::c_uint) {
        __constr_expr_504[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = tmp___4.wrapping_add(1);
    }
    tmp___5 = header_init(
        __constr_expr_504.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___6 = memcpy(
        tmp___5 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_502 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        out,
        pos,
        b"\n\0" as *const u8 as *const libc::c_char,
        tmp___6 as *mut Tuple as var,
    );
    __constr_expr_506[0 as libc::c_int as usize] = self_0;
    __constr_expr_506[1 as libc::c_int as usize] = Terminal;
    __constr_expr_505.items = __constr_expr_506.as_mut_ptr();
    __constr_expr_507[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___7 = 1 as libc::c_uint;
    while !(tmp___7 >= 32 as libc::c_uint) {
        __constr_expr_507[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = tmp___7.wrapping_add(1);
    }
    tmp___8 = header_init(
        __constr_expr_507.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___9 = memcpy(
        tmp___8 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_505 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        out,
        pos,
        b"# %s \0" as *const u8 as *const libc::c_char,
        tmp___9 as *mut Tuple as var,
    );
    if ((*doc).brief).is_some() {
        tmp___10 = (Some(((*doc).brief).expect("non-null function pointer")))
            .expect("non-null function pointer")();
        __constr_expr_510.val = tmp___10 as *mut libc::c_char;
        __constr_expr_511[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___11 = 1 as libc::c_uint;
        while !(tmp___11 >= 32 as libc::c_uint) {
            __constr_expr_511[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___11 = tmp___11.wrapping_add(1);
        }
        tmp___12 = header_init(
            __constr_expr_511.as_mut_ptr() as var,
            String,
            2 as libc::c_int,
        );
        tmp___13 = memcpy(
            tmp___12 as *mut String_0 as *mut libc::c_void,
            &mut __constr_expr_510 as *mut String_0 as *const libc::c_void,
            ::std::mem::size_of::<String_0>() as libc::c_ulong,
        );
        __constr_expr_509[0 as libc::c_int as usize] = tmp___13 as *mut String_0 as var;
        __constr_expr_509[1 as libc::c_int as usize] = Terminal;
        __constr_expr_508.items = __constr_expr_509.as_mut_ptr();
        __constr_expr_512[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___14 = 1 as libc::c_uint;
        while !(tmp___14 >= 32 as libc::c_uint) {
            __constr_expr_512[tmp___14 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___14 = tmp___14.wrapping_add(1);
        }
        tmp___15 = header_init(
            __constr_expr_512.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___16 = memcpy(
            tmp___15 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_508 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b" - %s\n\n\0" as *const u8 as *const libc::c_char,
            tmp___16 as *mut Tuple as var,
        );
    }
    if ((*doc).description).is_some() {
        tmp___17 = (Some(((*doc).description).expect("non-null function pointer")))
            .expect("non-null function pointer")();
        __constr_expr_515.val = tmp___17 as *mut libc::c_char;
        __constr_expr_516[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___18 = 1 as libc::c_uint;
        while !(tmp___18 >= 32 as libc::c_uint) {
            __constr_expr_516[tmp___18 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___18 = tmp___18.wrapping_add(1);
        }
        tmp___19 = header_init(
            __constr_expr_516.as_mut_ptr() as var,
            String,
            2 as libc::c_int,
        );
        tmp___20 = memcpy(
            tmp___19 as *mut String_0 as *mut libc::c_void,
            &mut __constr_expr_515 as *mut String_0 as *const libc::c_void,
            ::std::mem::size_of::<String_0>() as libc::c_ulong,
        );
        __constr_expr_514[0 as libc::c_int as usize] = tmp___20 as *mut String_0 as var;
        __constr_expr_514[1 as libc::c_int as usize] = Terminal;
        __constr_expr_513.items = __constr_expr_514.as_mut_ptr();
        __constr_expr_517[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___21 = 1 as libc::c_uint;
        while !(tmp___21 >= 32 as libc::c_uint) {
            __constr_expr_517[tmp___21 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___21 = tmp___21.wrapping_add(1);
        }
        tmp___22 = header_init(
            __constr_expr_517.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___23 = memcpy(
            tmp___22 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_513 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b"%s\n\n\0" as *const u8 as *const libc::c_char,
            tmp___23 as *mut Tuple as var,
        );
    }
    if ((*doc).definition).is_some() {
        __constr_expr_519[0 as libc::c_int as usize] = Terminal;
        __constr_expr_518.items = __constr_expr_519.as_mut_ptr();
        __constr_expr_520[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___24 = 1 as libc::c_uint;
        while !(tmp___24 >= 32 as libc::c_uint) {
            __constr_expr_520[tmp___24 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___24 = tmp___24.wrapping_add(1);
        }
        tmp___25 = header_init(
            __constr_expr_520.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___26 = memcpy(
            tmp___25 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_518 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b"\n### Definition\n\n\0" as *const u8 as *const libc::c_char,
            tmp___26 as *mut Tuple as var,
        );
        tmp___27 = (Some(((*doc).definition).expect("non-null function pointer")))
            .expect("non-null function pointer")();
        pos = print_indent(out, pos, tmp___27);
        __constr_expr_522[0 as libc::c_int as usize] = Terminal;
        __constr_expr_521.items = __constr_expr_522.as_mut_ptr();
        __constr_expr_523[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___28 = 1 as libc::c_uint;
        while !(tmp___28 >= 32 as libc::c_uint) {
            __constr_expr_523[tmp___28 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___28 = tmp___28.wrapping_add(1);
        }
        tmp___29 = header_init(
            __constr_expr_523.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___30 = memcpy(
            tmp___29 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_521 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b"\n\n\0" as *const u8 as *const libc::c_char,
            tmp___30 as *mut Tuple as var,
        );
    }
    if ((*doc).methods).is_some() {
        __constr_expr_525[0 as libc::c_int as usize] = Terminal;
        __constr_expr_524.items = __constr_expr_525.as_mut_ptr();
        __constr_expr_526[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___31 = 1 as libc::c_uint;
        while !(tmp___31 >= 32 as libc::c_uint) {
            __constr_expr_526[tmp___31 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___31 = tmp___31.wrapping_add(1);
        }
        tmp___32 = header_init(
            __constr_expr_526.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___33 = memcpy(
            tmp___32 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_524 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b"\n### Methods\n\n\0" as *const u8 as *const libc::c_char,
            tmp___33 as *mut Tuple as var,
        );
        tmp___34 = (Some(((*doc).methods).expect("non-null function pointer")))
            .expect("non-null function pointer")();
        methods___37 = tmp___34;
        while !((*methods___37.offset(0 as libc::c_int as isize)).name).is_null() {
            __constr_expr_529
                .val = (*methods___37.offset(0 as libc::c_int as isize)).name
                as *mut libc::c_char;
            __constr_expr_530[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___35 = 1 as libc::c_uint;
            while !(tmp___35 >= 32 as libc::c_uint) {
                __constr_expr_530[tmp___35 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___35 = tmp___35.wrapping_add(1);
            }
            tmp___36 = header_init(
                __constr_expr_530.as_mut_ptr() as var,
                String,
                2 as libc::c_int,
            );
            tmp___37 = memcpy(
                tmp___36 as *mut String_0 as *mut libc::c_void,
                &mut __constr_expr_529 as *mut String_0 as *const libc::c_void,
                ::std::mem::size_of::<String_0>() as libc::c_ulong,
            );
            __constr_expr_528[0 as libc::c_int
                as usize] = tmp___37 as *mut String_0 as var;
            __constr_expr_528[1 as libc::c_int as usize] = Terminal;
            __constr_expr_527.items = __constr_expr_528.as_mut_ptr();
            __constr_expr_531[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___38 = 1 as libc::c_uint;
            while !(tmp___38 >= 32 as libc::c_uint) {
                __constr_expr_531[tmp___38 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___38 = tmp___38.wrapping_add(1);
            }
            tmp___39 = header_init(
                __constr_expr_531.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___40 = memcpy(
                tmp___39 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_527 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"__%s__\n\n\0" as *const u8 as *const libc::c_char,
                tmp___40 as *mut Tuple as var,
            );
            pos = print_indent(
                out,
                pos,
                (*methods___37.offset(0 as libc::c_int as isize)).definition,
            );
            __constr_expr_534
                .val = (*methods___37.offset(0 as libc::c_int as isize)).description
                as *mut libc::c_char;
            __constr_expr_535[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___41 = 1 as libc::c_uint;
            while !(tmp___41 >= 32 as libc::c_uint) {
                __constr_expr_535[tmp___41 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___41 = tmp___41.wrapping_add(1);
            }
            tmp___42 = header_init(
                __constr_expr_535.as_mut_ptr() as var,
                String,
                2 as libc::c_int,
            );
            tmp___43 = memcpy(
                tmp___42 as *mut String_0 as *mut libc::c_void,
                &mut __constr_expr_534 as *mut String_0 as *const libc::c_void,
                ::std::mem::size_of::<String_0>() as libc::c_ulong,
            );
            __constr_expr_533[0 as libc::c_int
                as usize] = tmp___43 as *mut String_0 as var;
            __constr_expr_533[1 as libc::c_int as usize] = Terminal;
            __constr_expr_532.items = __constr_expr_533.as_mut_ptr();
            __constr_expr_536[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___44 = 1 as libc::c_uint;
            while !(tmp___44 >= 32 as libc::c_uint) {
                __constr_expr_536[tmp___44 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___44 = tmp___44.wrapping_add(1);
            }
            tmp___45 = header_init(
                __constr_expr_536.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___46 = memcpy(
                tmp___45 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_532 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"\n\n%s\n\n\0" as *const u8 as *const libc::c_char,
                tmp___46 as *mut Tuple as var,
            );
            methods___37 = methods___37.offset(1);
        }
    }
    if ((*doc).examples).is_some() {
        __constr_expr_538[0 as libc::c_int as usize] = Terminal;
        __constr_expr_537.items = __constr_expr_538.as_mut_ptr();
        __constr_expr_539[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___47 = 1 as libc::c_uint;
        while !(tmp___47 >= 32 as libc::c_uint) {
            __constr_expr_539[tmp___47 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___47 = tmp___47.wrapping_add(1);
        }
        tmp___48 = header_init(
            __constr_expr_539.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___49 = memcpy(
            tmp___48 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_537 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b"\n### Examples\n\n\0" as *const u8 as *const libc::c_char,
            tmp___49 as *mut Tuple as var,
        );
        tmp___50 = (Some(((*doc).examples).expect("non-null function pointer")))
            .expect("non-null function pointer")();
        examples___51 = tmp___50;
        while !((*examples___51.offset(0 as libc::c_int as isize)).name).is_null() {
            __constr_expr_542
                .val = (*examples___51.offset(0 as libc::c_int as isize)).name
                as *mut libc::c_char;
            __constr_expr_543[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___51 = 1 as libc::c_uint;
            while !(tmp___51 >= 32 as libc::c_uint) {
                __constr_expr_543[tmp___51 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___51 = tmp___51.wrapping_add(1);
            }
            tmp___52 = header_init(
                __constr_expr_543.as_mut_ptr() as var,
                String,
                2 as libc::c_int,
            );
            tmp___53 = memcpy(
                tmp___52 as *mut String_0 as *mut libc::c_void,
                &mut __constr_expr_542 as *mut String_0 as *const libc::c_void,
                ::std::mem::size_of::<String_0>() as libc::c_ulong,
            );
            __constr_expr_541[0 as libc::c_int
                as usize] = tmp___53 as *mut String_0 as var;
            __constr_expr_541[1 as libc::c_int as usize] = Terminal;
            __constr_expr_540.items = __constr_expr_541.as_mut_ptr();
            __constr_expr_544[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___54 = 1 as libc::c_uint;
            while !(tmp___54 >= 32 as libc::c_uint) {
                __constr_expr_544[tmp___54 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___54 = tmp___54.wrapping_add(1);
            }
            tmp___55 = header_init(
                __constr_expr_544.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___56 = memcpy(
                tmp___55 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_540 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"__%s__\n\n\0" as *const u8 as *const libc::c_char,
                tmp___56 as *mut Tuple as var,
            );
            pos = print_indent(
                out,
                pos,
                (*examples___51.offset(0 as libc::c_int as isize)).body,
            );
            __constr_expr_546[0 as libc::c_int as usize] = Terminal;
            __constr_expr_545.items = __constr_expr_546.as_mut_ptr();
            __constr_expr_547[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___57 = 1 as libc::c_uint;
            while !(tmp___57 >= 32 as libc::c_uint) {
                __constr_expr_547[tmp___57 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___57 = tmp___57.wrapping_add(1);
            }
            tmp___58 = header_init(
                __constr_expr_547.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___59 = memcpy(
                tmp___58 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_545 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"\n\n\0" as *const u8 as *const libc::c_char,
                tmp___59 as *mut Tuple as var,
            );
            examples___51 = examples___51.offset(1);
        }
        __constr_expr_549[0 as libc::c_int as usize] = Terminal;
        __constr_expr_548.items = __constr_expr_549.as_mut_ptr();
        __constr_expr_550[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___60 = 1 as libc::c_uint;
        while !(tmp___60 >= 32 as libc::c_uint) {
            __constr_expr_550[tmp___60 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___60 = tmp___60.wrapping_add(1);
        }
        tmp___61 = header_init(
            __constr_expr_550.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___62 = memcpy(
            tmp___61 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_548 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            out,
            pos,
            b"\n\n\0" as *const u8 as *const libc::c_char,
            tmp___62 as *mut Tuple as var,
        );
    }
    return pos;
}
static mut __constr_expr_552: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Type_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Type_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Type_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Type_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: Some(Type_Methods as unsafe extern "C" fn() -> *mut Method),
        };
        init
    }
};
static mut __constr_expr_553: Assign = {
    let mut init = Assign {
        assign: Some(Type_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_554: Copy_0 = {
    let mut init = Copy_0 {
        copy: Some(Type_Copy as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_555: Alloc = unsafe {
    {
        let mut init = Alloc {
            alloc: Some(Type_Alloc as unsafe extern "C" fn() -> var),
            dealloc: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_556: New = unsafe {
    {
        let mut init = New {
            construct_with: Some(Type_New as unsafe extern "C" fn(var, var) -> ()),
            destruct: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_557: Cmp = {
    let mut init = Cmp {
        cmp: Some(Type_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_558: Hash = {
    let mut init = Hash {
        hash: Some(Type_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_559: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Type_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_560: C_Str = {
    let mut init = C_Str {
        c_str: Some(Type_C_Str as unsafe extern "C" fn(var) -> *mut libc::c_char),
    };
    init
};
static mut __constr_expr_561: Help = {
    let mut init = Help {
        help_to: Some(
            Type_Help_To as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_551: [var; 60] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Type\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_552 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_553 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Copy\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_554 as *const Copy_0 as *mut Copy_0 as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Alloc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_555 as *const Alloc as *mut Alloc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_556 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_557 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_558 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_559 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"C_Str\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_560 as *const C_Str as *mut C_Str as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Help\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_561 as *const Help as *mut Help as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Type: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Type_Scan(mut self_0: var, mut cls: var) -> var {
    let mut __constr_expr_562: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_563: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut __constr_expr_564: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut t: *mut Type = 0 as *mut Type;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    tmp___4 = type_of(self_0);
    if tmp___4 as libc::c_ulong != Type as libc::c_ulong {
        tmp = type_of(self_0);
        __constr_expr_563[0 as libc::c_int as usize] = tmp;
        __constr_expr_563[1 as libc::c_int as usize] = Terminal;
        __constr_expr_562.items = __constr_expr_563.as_mut_ptr();
        __constr_expr_564[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_564[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_564.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_562 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___3 = exception_throw(
            TypeError,
            b"Method call got non type '%s'\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
        return tmp___3;
    }
    t = (self_0 as *mut Type).offset(8 as libc::c_int as isize);
    while !((*t).name).is_null() {
        if (*t).cls as libc::c_ulong == cls as libc::c_ulong {
            return (*t).inst;
        }
        t = t.offset(1);
    }
    t = (self_0 as *mut Type).offset(8 as libc::c_int as isize);
    while !((*t).name).is_null() {
        tmp___5 = Type_Builtin_Name(cls as *mut Type);
        tmp___6 = strcmp(
            (*t).name as *const libc::c_char,
            tmp___5 as *const libc::c_char,
        );
        if tmp___6 == 0 as libc::c_int {
            (*t).cls = cls;
            return (*t).inst;
        }
        t = t.offset(1);
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn Type_Implements(mut self_0: var, mut cls: var) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = Type_Scan(self_0, cls);
    return tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong;
}
pub unsafe extern "C" fn type_implements(mut self_0: var, mut cls: var) -> bool {
    let mut tmp: bool = false;
    tmp = Type_Implements(self_0, cls);
    return tmp;
}
unsafe extern "C" fn Type_Method_At_Offset(
    mut self_0: var,
    mut cls: var,
    mut offset: size_t,
    mut method_name: *const libc::c_char,
) -> var {
    let mut inst: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut __constr_expr_565: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_566: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_567: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut meth: var = 0 as *mut libc::c_void;
    let mut __constr_expr_568: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_569: [var; 4] = [0 as *mut libc::c_void; 4];
    let mut __constr_expr_570: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_571: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_572: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    tmp = Type_Instance(self_0, cls);
    inst = tmp;
    if inst as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_566[0 as libc::c_int as usize] = self_0;
        __constr_expr_566[1 as libc::c_int as usize] = cls;
        __constr_expr_566[2 as libc::c_int as usize] = Terminal;
        __constr_expr_565.items = __constr_expr_566.as_mut_ptr();
        __constr_expr_567[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_567[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_567.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_565 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___3 = exception_throw(
            ClassError,
            b"Type '%s' does not implement class '%s'\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
        return tmp___3;
    }
    meth = *((inst as *mut libc::c_char).offset(offset as isize) as *mut var);
    if meth as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_570.val = method_name as *mut libc::c_char;
        __constr_expr_571[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = 1 as libc::c_uint;
        while !(tmp___4 >= 32 as libc::c_uint) {
            __constr_expr_571[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = tmp___4.wrapping_add(1);
        }
        tmp___5 = header_init(
            __constr_expr_571.as_mut_ptr() as var,
            String,
            2 as libc::c_int,
        );
        tmp___6 = memcpy(
            tmp___5 as *mut String_0 as *mut libc::c_void,
            &mut __constr_expr_570 as *mut String_0 as *const libc::c_void,
            ::std::mem::size_of::<String_0>() as libc::c_ulong,
        );
        __constr_expr_569[0 as libc::c_int as usize] = self_0;
        __constr_expr_569[1 as libc::c_int as usize] = cls;
        __constr_expr_569[2 as libc::c_int as usize] = tmp___6 as *mut String_0 as var;
        __constr_expr_569[3 as libc::c_int as usize] = Terminal;
        __constr_expr_568.items = __constr_expr_569.as_mut_ptr();
        __constr_expr_572[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = 1 as libc::c_uint;
        while !(tmp___7 >= 32 as libc::c_uint) {
            __constr_expr_572[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___7 = tmp___7.wrapping_add(1);
        }
        tmp___8 = header_init(
            __constr_expr_572.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___9 = memcpy(
            tmp___8 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_568 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___10 = exception_throw(
            ClassError,
            b"Type '%s' implements class '%s' but not the method '%s' required\0"
                as *const u8 as *const libc::c_char,
            tmp___9 as *mut Tuple as var,
        );
        return tmp___10;
    }
    return inst;
}
pub unsafe extern "C" fn type_method_at_offset(
    mut self_0: var,
    mut cls: var,
    mut offset: size_t,
    mut method_name: *const libc::c_char,
) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = Type_Method_At_Offset(self_0, cls, offset, method_name);
    return tmp;
}
unsafe extern "C" fn Type_Implements_Method_At_Offset(
    mut self_0: var,
    mut cls: var,
    mut offset: size_t,
) -> bool {
    let mut inst: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut meth: var = 0 as *mut libc::c_void;
    tmp = Type_Scan(self_0, cls);
    inst = tmp;
    if inst as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    meth = *((inst as *mut libc::c_char).offset(offset as isize) as *mut var);
    if meth as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
pub unsafe extern "C" fn type_implements_method_at_offset(
    mut self_0: var,
    mut cls: var,
    mut offset: size_t,
) -> bool {
    let mut tmp: bool = false;
    tmp = Type_Implements_Method_At_Offset(self_0, cls, offset);
    return tmp;
}
unsafe extern "C" fn Type_Instance(mut self_0: var, mut cls: var) -> var {
    let mut inst: var = 0 as *mut libc::c_void;
    let mut inst___0: var = 0 as *mut libc::c_void;
    let mut inst___1: var = 0 as *mut libc::c_void;
    let mut inst___2: var = 0 as *mut libc::c_void;
    let mut inst___3: var = 0 as *mut libc::c_void;
    let mut inst___4: var = 0 as *mut libc::c_void;
    let mut inst___5: var = 0 as *mut libc::c_void;
    let mut inst___6: var = 0 as *mut libc::c_void;
    let mut inst___7: var = 0 as *mut libc::c_void;
    let mut inst___8: var = 0 as *mut libc::c_void;
    let mut inst___9: var = 0 as *mut libc::c_void;
    let mut inst___10: var = 0 as *mut libc::c_void;
    let mut inst___11: var = 0 as *mut libc::c_void;
    let mut inst___12: var = 0 as *mut libc::c_void;
    let mut inst___13: var = 0 as *mut libc::c_void;
    let mut inst___14: var = 0 as *mut libc::c_void;
    let mut inst___15: var = 0 as *mut libc::c_void;
    let mut inst___16: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    if cls as libc::c_ulong == Size as libc::c_ulong {
        inst = *(self_0 as *mut var).offset(0 as libc::c_int as isize);
        if inst as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst = Type_Scan(self_0, Size);
            let ref mut fresh7 = *(self_0 as *mut var).offset(0 as libc::c_int as isize);
            *fresh7 = inst;
        }
        return inst;
    }
    if cls as libc::c_ulong == Alloc as libc::c_ulong {
        inst___0 = *(self_0 as *mut var).offset(1 as libc::c_int as isize);
        if inst___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___0 = Type_Scan(self_0, Alloc);
            let ref mut fresh8 = *(self_0 as *mut var).offset(1 as libc::c_int as isize);
            *fresh8 = inst___0;
        }
        return inst___0;
    }
    if cls as libc::c_ulong == New as libc::c_ulong {
        inst___1 = *(self_0 as *mut var).offset(2 as libc::c_int as isize);
        if inst___1 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___1 = Type_Scan(self_0, New);
            let ref mut fresh9 = *(self_0 as *mut var).offset(2 as libc::c_int as isize);
            *fresh9 = inst___1;
        }
        return inst___1;
    }
    if cls as libc::c_ulong == Assign as libc::c_ulong {
        inst___2 = *(self_0 as *mut var).offset(3 as libc::c_int as isize);
        if inst___2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___2 = Type_Scan(self_0, Assign);
            let ref mut fresh10 = *(self_0 as *mut var)
                .offset(3 as libc::c_int as isize);
            *fresh10 = inst___2;
        }
        return inst___2;
    }
    if cls as libc::c_ulong == Cmp as libc::c_ulong {
        inst___3 = *(self_0 as *mut var).offset(4 as libc::c_int as isize);
        if inst___3 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___3 = Type_Scan(self_0, Cmp);
            let ref mut fresh11 = *(self_0 as *mut var)
                .offset(4 as libc::c_int as isize);
            *fresh11 = inst___3;
        }
        return inst___3;
    }
    if cls as libc::c_ulong == Mark as libc::c_ulong {
        inst___4 = *(self_0 as *mut var).offset(5 as libc::c_int as isize);
        if inst___4 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___4 = Type_Scan(self_0, Mark);
            let ref mut fresh12 = *(self_0 as *mut var)
                .offset(5 as libc::c_int as isize);
            *fresh12 = inst___4;
        }
        return inst___4;
    }
    if cls as libc::c_ulong == Hash as libc::c_ulong {
        inst___5 = *(self_0 as *mut var).offset(6 as libc::c_int as isize);
        if inst___5 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___5 = Type_Scan(self_0, Hash);
            let ref mut fresh13 = *(self_0 as *mut var)
                .offset(6 as libc::c_int as isize);
            *fresh13 = inst___5;
        }
        return inst___5;
    }
    if cls as libc::c_ulong == Len as libc::c_ulong {
        inst___6 = *(self_0 as *mut var).offset(7 as libc::c_int as isize);
        if inst___6 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___6 = Type_Scan(self_0, Len);
            let ref mut fresh14 = *(self_0 as *mut var)
                .offset(7 as libc::c_int as isize);
            *fresh14 = inst___6;
        }
        return inst___6;
    }
    if cls as libc::c_ulong == Iter as libc::c_ulong {
        inst___7 = *(self_0 as *mut var).offset(8 as libc::c_int as isize);
        if inst___7 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___7 = Type_Scan(self_0, Iter);
            let ref mut fresh15 = *(self_0 as *mut var)
                .offset(8 as libc::c_int as isize);
            *fresh15 = inst___7;
        }
        return inst___7;
    }
    if cls as libc::c_ulong == Push as libc::c_ulong {
        inst___8 = *(self_0 as *mut var).offset(9 as libc::c_int as isize);
        if inst___8 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___8 = Type_Scan(self_0, Push);
            let ref mut fresh16 = *(self_0 as *mut var)
                .offset(9 as libc::c_int as isize);
            *fresh16 = inst___8;
        }
        return inst___8;
    }
    if cls as libc::c_ulong == Concat as libc::c_ulong {
        inst___9 = *(self_0 as *mut var).offset(10 as libc::c_int as isize);
        if inst___9 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___9 = Type_Scan(self_0, Concat);
            let ref mut fresh17 = *(self_0 as *mut var)
                .offset(10 as libc::c_int as isize);
            *fresh17 = inst___9;
        }
        return inst___9;
    }
    if cls as libc::c_ulong == Get as libc::c_ulong {
        inst___10 = *(self_0 as *mut var).offset(11 as libc::c_int as isize);
        if inst___10 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___10 = Type_Scan(self_0, Get);
            let ref mut fresh18 = *(self_0 as *mut var)
                .offset(11 as libc::c_int as isize);
            *fresh18 = inst___10;
        }
        return inst___10;
    }
    if cls as libc::c_ulong == C_Str as libc::c_ulong {
        inst___11 = *(self_0 as *mut var).offset(12 as libc::c_int as isize);
        if inst___11 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___11 = Type_Scan(self_0, C_Str);
            let ref mut fresh19 = *(self_0 as *mut var)
                .offset(12 as libc::c_int as isize);
            *fresh19 = inst___11;
        }
        return inst___11;
    }
    if cls as libc::c_ulong == C_Int as libc::c_ulong {
        inst___12 = *(self_0 as *mut var).offset(13 as libc::c_int as isize);
        if inst___12 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___12 = Type_Scan(self_0, C_Int);
            let ref mut fresh20 = *(self_0 as *mut var)
                .offset(13 as libc::c_int as isize);
            *fresh20 = inst___12;
        }
        return inst___12;
    }
    if cls as libc::c_ulong == C_Float as libc::c_ulong {
        inst___13 = *(self_0 as *mut var).offset(14 as libc::c_int as isize);
        if inst___13 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___13 = Type_Scan(self_0, C_Float);
            let ref mut fresh21 = *(self_0 as *mut var)
                .offset(14 as libc::c_int as isize);
            *fresh21 = inst___13;
        }
        return inst___13;
    }
    if cls as libc::c_ulong == Current as libc::c_ulong {
        inst___14 = *(self_0 as *mut var).offset(15 as libc::c_int as isize);
        if inst___14 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___14 = Type_Scan(self_0, Current);
            let ref mut fresh22 = *(self_0 as *mut var)
                .offset(15 as libc::c_int as isize);
            *fresh22 = inst___14;
        }
        return inst___14;
    }
    if cls as libc::c_ulong == Cast as libc::c_ulong {
        inst___15 = *(self_0 as *mut var).offset(16 as libc::c_int as isize);
        if inst___15 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___15 = Type_Scan(self_0, Cast);
            let ref mut fresh23 = *(self_0 as *mut var)
                .offset(16 as libc::c_int as isize);
            *fresh23 = inst___15;
        }
        return inst___15;
    }
    if cls as libc::c_ulong == Pointer as libc::c_ulong {
        inst___16 = *(self_0 as *mut var).offset(17 as libc::c_int as isize);
        if inst___16 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            inst___16 = Type_Scan(self_0, Pointer);
            let ref mut fresh24 = *(self_0 as *mut var)
                .offset(17 as libc::c_int as isize);
            *fresh24 = inst___16;
        }
        return inst___16;
    }
    tmp = Type_Scan(self_0, cls);
    return tmp;
}
pub unsafe extern "C" fn type_instance(mut self_0: var, mut cls: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = Type_Instance(self_0, cls);
    return tmp;
}
unsafe extern "C" fn Type_Of(mut self_0: var) -> var {
    let mut __constr_expr_573: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_574: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_575: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut head: *mut Header = 0 as *mut Header;
    let mut __constr_expr_576: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_577: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_578: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_579: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_580: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_581: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    if self_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_574[0 as libc::c_int as usize] = Terminal;
        __constr_expr_573.items = __constr_expr_574.as_mut_ptr();
        __constr_expr_575[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_575[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_575.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_573 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___2 = exception_throw(
            ValueError,
            b"Received NULL as value to 'type_of'\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
        return tmp___2;
    }
    head = (self_0 as *mut libc::c_char)
        .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
        as *mut Header;
    if (*head).magic as libc::c_ulong
        == 59774918928 as libc::c_long as var as libc::c_ulong
    {
        __constr_expr_577[0 as libc::c_int as usize] = self_0;
        __constr_expr_577[1 as libc::c_int as usize] = Terminal;
        __constr_expr_576.items = __constr_expr_577.as_mut_ptr();
        __constr_expr_578[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_578[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_578.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_576 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Pointer '%p' passed to 'type_of' has bad magic number, it looks like it was already deallocated.\0"
                as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
    if (*head).magic as libc::c_ulong != 844048 as libc::c_int as var as libc::c_ulong {
        __constr_expr_580[0 as libc::c_int as usize] = self_0;
        __constr_expr_580[1 as libc::c_int as usize] = Terminal;
        __constr_expr_579.items = __constr_expr_580.as_mut_ptr();
        __constr_expr_581[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_581[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_581.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_579 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Pointer '%p' passed to 'type_of' has bad magic number, perhaps it wasn't allocated by Cello.\0"
                as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    if (*head).type_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*head).type_0 = Type;
    }
    return (*head).type_0;
}
pub unsafe extern "C" fn type_of(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = Type_Of(self_0);
    return tmp;
}
pub unsafe extern "C" fn instance(mut self_0: var, mut cls: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = Type_Of(self_0);
    tmp___0 = Type_Instance(tmp, cls);
    return tmp___0;
}
pub unsafe extern "C" fn implements(mut self_0: var, mut cls: var) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = Type_Of(self_0);
    tmp___0 = Type_Implements(tmp, cls);
    return tmp___0;
}
pub unsafe extern "C" fn method_at_offset(
    mut self_0: var,
    mut cls: var,
    mut offset: size_t,
    mut method_name: *const libc::c_char,
) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = Type_Of(self_0);
    tmp___0 = Type_Method_At_Offset(tmp, cls, offset, method_name);
    return tmp___0;
}
pub unsafe extern "C" fn implements_method_at_offset(
    mut self_0: var,
    mut cls: var,
    mut offset: size_t,
) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = Type_Of(self_0);
    tmp___0 = Type_Implements_Method_At_Offset(tmp, cls, offset);
    return tmp___0;
}
unsafe extern "C" fn Size_Name() -> *const libc::c_char {
    return b"Size\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Size_Brief() -> *const libc::c_char {
    return b"Type Size\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Size_Description() -> *const libc::c_char {
    return b"The `Size` class is a very important class in Cello because it gives the size in bytes you can expect an object of a given type to be. This is used by many methods to allocate, assign, or compare various objects.\n\nBy default this size is automatically found and recorded by the `Cello` macro, but if the type does it's own allocation, or the size cannot be found naturally then it may be necessary to override this method.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Size_Definition() -> *const libc::c_char {
    return b"struct Size {\n  size_t (*size)(void);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___19: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"show($I(size(Int)));\nshow($I(size(Float)));\nshow($I(size(Array)));\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Size_Examples() -> *mut Example {
    return examples___19.as_mut_ptr();
}
static mut methods___17: [Method; 2] = [
    {
        let mut init = Method {
            name: b"size\0" as *const u8 as *const libc::c_char,
            definition: b"size_t size(var type);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the associated size of a given `type` in bytes.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Size_Methods() -> *mut Method {
    return methods___17.as_mut_ptr();
}
static mut __constr_expr_583: Doc = {
    let mut init = Doc {
        name: Some(Size_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Size_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Size_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Size_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Size_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Size_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_582: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Size\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Size>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_583 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Size: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn size(mut type_0: var) -> size_t {
    let mut s: *mut Size = 0 as *mut Size;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    tmp = type_instance(type_0, Size);
    s = tmp as *mut Size;
    if !s.is_null() {
        if ((*s).size).is_some() {
            tmp___0 = (Some(((*s).size).expect("non-null function pointer")))
                .expect("non-null function pointer")();
            return tmp___0;
        }
    }
    tmp___1 = Type_Builtin_Size(type_0 as *mut Type);
    return tmp___1;
}
unsafe extern "C" fn List_Name() -> *const libc::c_char {
    return b"List\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn List_Brief() -> *const libc::c_char {
    return b"Linked List\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn List_Description() -> *const libc::c_char {
    return b"The `List` type is a linked list data structure. Elements can be added and removed from the list and their memory is allocated and deallocated by the structure. Additionally destructors will be called on objects once removed.\n\nElements are copied into the List using `assign` and will initially have zero'd memory.\n\nLists can provide fast insertion and removal at arbitrary locations although most other operations will be slow due to having to traverse the linked list data structure.\n\nThis is largely equivalent to the C++ construct [std::list](http://www.cplusplus.com/reference/list/list/)\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___20: [Example; 5] = [
    {
        let mut init = Example {
            name: b"Construction & Deletion\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(List, Int);\npush(x, $I(32));\npush(x, $I(6));\n\n/* <'List' At 0x0000000000414603 [32, 6]> */\nshow(x);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Element Access\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(List, Float, $F(0.01), $F(5.12));\n\nshow(get(x, $I(0))); /* 0.01 */\nshow(get(x, $I(1))); /* 5.12 */\n\nset(x, $I(0), $F(500.1));\nshow(get(x, $I(0))); /* 500.1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Membership\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(List, Int, $I(1), $I(2), $I(3), $I(4));\n\nshow($I(mem(x, $I(1)))); /* 1 */\nshow($I(len(x)));        /* 4 */\n\nrem(x, $I(3));\n\nshow($I(mem(x, $I(3)))); /* 0 */\nshow($I(len(x)));        /* 3 */\nshow($I(empty(x)));      /* 0 */\n\nresize(x, 0);\n\nshow($I(empty(x)));      /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Iteration\0" as *const u8 as *const libc::c_char,
            body: b"var greetings = new(List, String, \n  $S(\"Hello\"), $S(\"Bonjour\"), $S(\"Hej\"));\n\nforeach(greet in greetings) {\n  show(greet);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn List_Examples() -> *mut Example {
    return examples___20.as_mut_ptr();
}
unsafe extern "C" fn List_Alloc(mut l: *mut List) -> var {
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_584: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_585: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_586: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        (2 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong)
            .wrapping_add((*l).tsize),
    );
    item = tmp;
    if item as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_585[0 as libc::c_int as usize] = Terminal;
        __constr_expr_584.items = __constr_expr_585.as_mut_ptr();
        __constr_expr_586[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_586[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_586.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_584 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate List entry, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    tmp___3 = header_init(
        (item as *mut libc::c_char)
            .offset(
                (2 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            ) as *mut Header as var,
        (*l).type_0,
        4 as libc::c_int,
    );
    return tmp___3;
}
unsafe extern "C" fn List_Free(mut l: *mut List, mut self_0: var) {
    free(
        (self_0 as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            .offset(
                -((2 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
                    as isize),
            ) as *mut libc::c_void,
    );
}
unsafe extern "C" fn List_Next(mut l: *mut List, mut self_0: var) -> *mut var {
    return (self_0 as *mut libc::c_char)
        .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
        .offset(-(::std::mem::size_of::<var>() as libc::c_ulong as isize)) as *mut var;
}
unsafe extern "C" fn List_Prev(mut l: *mut List, mut self_0: var) -> *mut var {
    return (self_0 as *mut libc::c_char)
        .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
        .offset(
            -((2 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize),
        ) as *mut var;
}
unsafe extern "C" fn List_At(mut l: *mut List, mut i: int64_t) -> var {
    let mut __constr_expr_587: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_588: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_589: Int = Int { val: 0 };
    let mut __constr_expr_590: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_591: Int = Int { val: 0 };
    let mut __constr_expr_592: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_593: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut var = 0 as *mut var;
    let mut tmp___10: *mut var = 0 as *mut var;
    if i < 0 as libc::c_long {
        i = ((*l).nitems).wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_184: {
        if !(i < 0 as libc::c_long) {
            if !(i >= (*l).nitems as int64_t) {
                break 's_184;
            }
        }
        __constr_expr_589.val = i;
        __constr_expr_590[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_590[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_590.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_589 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_591.val = (*l).nitems as int64_t;
        __constr_expr_592[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_592[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_592.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_591 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_588[0 as libc::c_int as usize] = tmp___1 as *mut Int as var;
        __constr_expr_588[1 as libc::c_int as usize] = tmp___4 as *mut Int as var;
        __constr_expr_588[2 as libc::c_int as usize] = Terminal;
        __constr_expr_587.items = __constr_expr_588.as_mut_ptr();
        __constr_expr_593[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_593[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_593.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_587 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___8 = exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for List of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
        return tmp___8;
    }
    if i <= ((*l).nitems).wrapping_div(2 as libc::c_ulong) as int64_t {
        item = (*l).head;
        while i != 0 {
            tmp___9 = List_Next(l, item);
            item = *tmp___9;
            i -= 1;
        }
    } else {
        i = ((*l).nitems).wrapping_sub(i as size_t).wrapping_sub(1 as libc::c_ulong)
            as int64_t;
        item = (*l).tail;
        while i != 0 {
            tmp___10 = List_Prev(l, item);
            item = *tmp___10;
            i -= 1;
        }
    }
    return item;
}
unsafe extern "C" fn List_New(mut self_0: var, mut args: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut __constr_expr_594: Int = Int { val: 0 };
    let mut __constr_expr_595: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut nargs: size_t = 0;
    let mut tmp___3: size_t = 0;
    let mut i: size_t = 0;
    let mut __constr_expr_596: Int = Int { val: 0 };
    let mut __constr_expr_597: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    __constr_expr_594.val = 0 as libc::c_int as int64_t;
    __constr_expr_595[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_595[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_595.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_594 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    (*l).type_0 = cast(tmp___2, Type);
    (*l).tsize = size((*l).type_0);
    (*l).nitems = 0 as libc::c_int as size_t;
    (*l).head = 0 as *mut libc::c_void;
    (*l).tail = 0 as *mut libc::c_void;
    tmp___3 = len(args);
    nargs = tmp___3;
    i = 0 as libc::c_int as size_t;
    while i < nargs.wrapping_sub(1 as libc::c_ulong) {
        __constr_expr_596.val = i.wrapping_add(1 as libc::c_ulong) as int64_t;
        __constr_expr_597[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = 1 as libc::c_uint;
        while !(tmp___4 >= 32 as libc::c_uint) {
            __constr_expr_597[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = tmp___4.wrapping_add(1);
        }
        tmp___5 = header_init(
            __constr_expr_597.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___6 = memcpy(
            tmp___5 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_596 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___7 = get(args, tmp___6 as *mut Int as var);
        List_Push(self_0, tmp___7);
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn List_Clear(mut self_0: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut next: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    l = self_0 as *mut List;
    item = (*l).head;
    while !item.is_null() {
        tmp = List_Next(l, item);
        next = *tmp;
        destruct(item);
        List_Free(l, item);
        item = next;
    }
    (*l).tail = 0 as *mut libc::c_void;
    (*l).head = 0 as *mut libc::c_void;
    (*l).nitems = 0 as libc::c_int as size_t;
}
unsafe extern "C" fn List_Del(mut self_0: var) {
    let mut l: *mut List = 0 as *mut List;
    l = self_0 as *mut List;
    List_Clear(self_0);
}
unsafe extern "C" fn List_Assign(mut self_0: var, mut obj: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    let mut nargs: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut i: size_t = 0;
    let mut __constr_expr_598: Int = Int { val: 0 };
    let mut __constr_expr_599: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    List_Clear(self_0);
    tmp___1 = implements_method_at_offset(
        obj,
        Iter,
        &mut (*(0 as *mut Iter)).iter_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
    );
    if tmp___1 {
        tmp___0 = iter_type(obj);
        (*l).type_0 = tmp___0;
    } else {
        (*l).type_0 = Ref;
    }
    (*l).tsize = size((*l).type_0);
    tmp___2 = len(obj);
    nargs = tmp___2;
    i = 0 as libc::c_int as size_t;
    while i < nargs {
        __constr_expr_598.val = i as int64_t;
        __constr_expr_599[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_599[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_599.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_598 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___6 = get(obj, tmp___5 as *mut Int as var);
        List_Push(self_0, tmp___6);
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn List_Concat(mut self_0: var, mut obj: var) {
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    __item = obj;
    tmp = instance(__item, Iter);
    __Iteritem = tmp;
    tmp___0 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___0;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        List_Push(self_0, item);
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
}
unsafe extern "C" fn List_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut item0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item1: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = List_Iter_Init(self_0);
    item0 = tmp;
    tmp___0 = iter_init(obj);
    item1 = tmp___0;
    loop {
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            if item1 as libc::c_ulong == Terminal as libc::c_ulong {
                return 0 as libc::c_int;
            }
        }
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if item1 as libc::c_ulong == Terminal as libc::c_ulong {
            return 1 as libc::c_int;
        }
        tmp___1 = cmp(item0, item1);
        c = tmp___1;
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        item0 = List_Iter_Next(self_0, item0);
        item1 = iter_next(obj, item1);
    };
}
unsafe extern "C" fn List_Hash(mut self_0: var) -> uint64_t {
    let mut l: *mut List = 0 as *mut List;
    let mut h: uint64_t = 0;
    let mut item: var = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut tmp: uint64_t = 0;
    let mut tmp___0: *mut var = 0 as *mut var;
    l = self_0 as *mut List;
    h = 0 as libc::c_int as uint64_t;
    item = (*l).head;
    i = 0 as libc::c_int as size_t;
    while i < (*l).nitems {
        tmp = hash(item);
        h ^= tmp;
        tmp___0 = List_Next(l, item);
        item = *tmp___0;
        i = i.wrapping_add(1);
    }
    return h;
}
unsafe extern "C" fn List_Len(mut self_0: var) -> size_t {
    let mut l: *mut List = 0 as *mut List;
    l = self_0 as *mut List;
    return (*l).nitems;
}
unsafe extern "C" fn List_Mem(mut self_0: var, mut obj: var) -> bool {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp: bool = false;
    let mut tmp___0: *mut var = 0 as *mut var;
    l = self_0 as *mut List;
    item = (*l).head;
    while !item.is_null() {
        tmp = eq(item, obj);
        if tmp {
            return 1 as libc::c_int != 0;
        }
        tmp___0 = List_Next(l, item);
        item = *tmp___0;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn List_Unlink(mut l: *mut List, mut item: var) {
    let mut next: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    let mut prev: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: *mut var = 0 as *mut var;
    let mut tmp___4: *mut var = 0 as *mut var;
    tmp = List_Next(l, item);
    next = *tmp;
    tmp___0 = List_Prev(l, item);
    prev = *tmp___0;
    let mut current_block_21: u64;
    if item as libc::c_ulong == (*l).head as libc::c_ulong {
        if item as libc::c_ulong == (*l).tail as libc::c_ulong {
            (*l).head = 0 as *mut libc::c_void;
            (*l).tail = 0 as *mut libc::c_void;
            current_block_21 = 5783071609795492627;
        } else {
            current_block_21 = 102037729193945510;
        }
    } else {
        current_block_21 = 102037729193945510;
    }
    match current_block_21 {
        102037729193945510 => {
            if item as libc::c_ulong == (*l).head as libc::c_ulong {
                (*l).head = next;
                tmp___1 = List_Prev(l, next);
                *tmp___1 = 0 as *mut libc::c_void;
            } else if item as libc::c_ulong == (*l).tail as libc::c_ulong {
                (*l).tail = prev;
                tmp___2 = List_Next(l, prev);
                *tmp___2 = 0 as *mut libc::c_void;
            } else {
                tmp___3 = List_Next(l, prev);
                *tmp___3 = next;
                tmp___4 = List_Prev(l, next);
                *tmp___4 = prev;
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn List_Link(
    mut l: *mut List,
    mut item: var,
    mut prev: var,
    mut next: var,
) {
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    if prev as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*l).head = item;
    } else {
        tmp = List_Next(l, prev);
        *tmp = item;
    }
    if next as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*l).tail = item;
    } else {
        tmp___0 = List_Prev(l, next);
        *tmp___0 = item;
    }
    tmp___1 = List_Next(l, item);
    *tmp___1 = next;
    tmp___2 = List_Prev(l, item);
    *tmp___2 = prev;
}
unsafe extern "C" fn List_Pop_At(mut self_0: var, mut key: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    tmp = c_int(key);
    i = tmp;
    tmp___0 = List_At(l, i);
    item = tmp___0;
    List_Unlink(l, item);
    destruct(item);
    List_Free(l, item);
    (*l).nitems = ((*l).nitems).wrapping_sub(1);
}
unsafe extern "C" fn List_Rem(mut self_0: var, mut obj: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp: bool = false;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut __constr_expr_600: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_601: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_602: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    item = (*l).head;
    while !item.is_null() {
        tmp = eq(item, obj);
        if tmp {
            List_Unlink(l, item);
            destruct(item);
            List_Free(l, item);
            (*l).nitems = ((*l).nitems).wrapping_sub(1);
            return;
        }
        tmp___0 = List_Next(l, item);
        item = *tmp___0;
    }
    __constr_expr_601[0 as libc::c_int as usize] = obj;
    __constr_expr_601[1 as libc::c_int as usize] = Terminal;
    __constr_expr_600.items = __constr_expr_601.as_mut_ptr();
    __constr_expr_602[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___1 = 1 as libc::c_uint;
    while !(tmp___1 >= 32 as libc::c_uint) {
        __constr_expr_602[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = tmp___1.wrapping_add(1);
    }
    tmp___2 = header_init(
        __constr_expr_602.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___3 = memcpy(
        tmp___2 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_600 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    exception_throw(
        ValueError,
        b"Object %$ not in List!\0" as *const u8 as *const libc::c_char,
        tmp___3 as *mut Tuple as var,
    );
}
unsafe extern "C" fn List_Push(mut self_0: var, mut obj: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    tmp = List_Alloc(l);
    item = tmp;
    assign(item, obj);
    List_Link(l, item, (*l).tail, 0 as *mut libc::c_void);
    (*l).nitems = ((*l).nitems).wrapping_add(1);
}
unsafe extern "C" fn List_Push_At(mut self_0: var, mut obj: var, mut key: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut i: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut var = 0 as *mut var;
    l = self_0 as *mut List;
    tmp = List_Alloc(l);
    item = tmp;
    assign(item, obj);
    tmp___0 = c_int(key);
    i = tmp___0;
    if i == 0 as libc::c_long {
        List_Link(l, item, 0 as *mut libc::c_void, (*l).head);
    } else {
        tmp___1 = List_At(l, i);
        curr = tmp___1;
        tmp___2 = List_Prev(l, curr);
        List_Link(l, item, *tmp___2, curr);
    }
    (*l).nitems = ((*l).nitems).wrapping_add(1);
}
unsafe extern "C" fn List_Pop(mut self_0: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut __constr_expr_603: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_604: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_605: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    if (*l).nitems == 0 as libc::c_ulong {
        __constr_expr_604[0 as libc::c_int as usize] = Terminal;
        __constr_expr_603.items = __constr_expr_604.as_mut_ptr();
        __constr_expr_605[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_605[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_605.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_603 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Cannot pop. List is empty!\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
        return;
    }
    item = (*l).tail;
    List_Unlink(l, item);
    destruct(item);
    List_Free(l, item);
    (*l).nitems = ((*l).nitems).wrapping_sub(1);
}
unsafe extern "C" fn List_Get(mut self_0: var, mut key: var) -> var {
    let mut l: *mut List = 0 as *mut List;
    let mut tmp: int64_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    tmp = c_int(key);
    tmp___0 = List_At(l, tmp);
    return tmp___0;
}
unsafe extern "C" fn List_Set(mut self_0: var, mut key: var, mut val: var) {
    let mut l: *mut List = 0 as *mut List;
    let mut tmp: int64_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    tmp = c_int(key);
    tmp___0 = List_At(l, tmp);
    assign(tmp___0, val);
}
unsafe extern "C" fn List_Iter_Init(mut self_0: var) -> var {
    let mut l: *mut List = 0 as *mut List;
    l = self_0 as *mut List;
    if (*l).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    return (*l).head;
}
unsafe extern "C" fn List_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut l: *mut List = 0 as *mut List;
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    tmp = List_Next(l, curr);
    curr = *tmp;
    if !curr.is_null() {
        tmp___0 = curr;
    } else {
        tmp___0 = Terminal;
    }
    return tmp___0;
}
unsafe extern "C" fn List_Iter_Last(mut self_0: var) -> var {
    let mut l: *mut List = 0 as *mut List;
    l = self_0 as *mut List;
    if (*l).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    return (*l).tail;
}
unsafe extern "C" fn List_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut l: *mut List = 0 as *mut List;
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    tmp = List_Prev(l, curr);
    curr = *tmp;
    if !curr.is_null() {
        tmp___0 = curr;
    } else {
        tmp___0 = Terminal;
    }
    return tmp___0;
}
unsafe extern "C" fn List_Iter_Type(mut self_0: var) -> var {
    let mut l: *mut List = 0 as *mut List;
    l = self_0 as *mut List;
    return (*l).type_0;
}
unsafe extern "C" fn List_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut l: *mut List = 0 as *mut List;
    let mut __constr_expr_606: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_607: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_608: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut __constr_expr_609: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_610: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_611: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: *mut var = 0 as *mut var;
    let mut __constr_expr_612: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_613: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_614: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_615: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_616: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_617: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: libc::c_int = 0;
    l = self_0 as *mut List;
    __constr_expr_607[0 as libc::c_int as usize] = self_0;
    __constr_expr_607[1 as libc::c_int as usize] = Terminal;
    __constr_expr_606.items = __constr_expr_607.as_mut_ptr();
    __constr_expr_608[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_608[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_608.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_606 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"<'List' At 0x%p [\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    item = (*l).head;
    while !item.is_null() {
        __constr_expr_610[0 as libc::c_int as usize] = item;
        __constr_expr_610[1 as libc::c_int as usize] = Terminal;
        __constr_expr_609.items = __constr_expr_610.as_mut_ptr();
        __constr_expr_611[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_611[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_611.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_609 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            output,
            pos,
            b"%$\0" as *const u8 as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
        tmp___5 = List_Next(l, item);
        item = *tmp___5;
        if !item.is_null() {
            __constr_expr_613[0 as libc::c_int as usize] = Terminal;
            __constr_expr_612.items = __constr_expr_613.as_mut_ptr();
            __constr_expr_614[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = 1 as libc::c_uint;
            while !(tmp___6 >= 32 as libc::c_uint) {
                __constr_expr_614[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = tmp___6.wrapping_add(1);
            }
            tmp___7 = header_init(
                __constr_expr_614.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___8 = memcpy(
                tmp___7 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_612 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b", \0" as *const u8 as *const libc::c_char,
                tmp___8 as *mut Tuple as var,
            );
        }
    }
    __constr_expr_616[0 as libc::c_int as usize] = Terminal;
    __constr_expr_615.items = __constr_expr_616.as_mut_ptr();
    __constr_expr_617[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___9 = 1 as libc::c_uint;
    while !(tmp___9 >= 32 as libc::c_uint) {
        __constr_expr_617[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = tmp___9.wrapping_add(1);
    }
    tmp___10 = header_init(
        __constr_expr_617.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___11 = memcpy(
        tmp___10 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_615 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___12 = print_to_with(
        output,
        pos,
        b"]>\0" as *const u8 as *const libc::c_char,
        tmp___11 as *mut Tuple as var,
    );
    return tmp___12;
}
unsafe extern "C" fn List_Resize(mut self_0: var, mut n: size_t) {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut item___0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    l = self_0 as *mut List;
    if n == 0 as libc::c_ulong {
        List_Clear(self_0);
        return;
    }
    while n < (*l).nitems {
        item = (*l).tail;
        List_Unlink(l, item);
        destruct(item);
        List_Free(l, item);
        (*l).nitems = ((*l).nitems).wrapping_sub(1);
    }
    while n > (*l).nitems {
        tmp = List_Alloc(l);
        item___0 = tmp;
        List_Link(l, item___0, (*l).tail, 0 as *mut libc::c_void);
        (*l).nitems = ((*l).nitems).wrapping_add(1);
    }
}
unsafe extern "C" fn List_Mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut l: *mut List = 0 as *mut List;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    l = self_0 as *mut List;
    item = (*l).head;
    while !item.is_null() {
        (Some(f.expect("non-null function pointer")))
            .expect("non-null function pointer")(gc, item);
        tmp = List_Next(l, item);
        item = *tmp;
    }
}
static mut __constr_expr_619: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(List_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(List_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                List_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(List_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_620: New = {
    let mut init = New {
        construct_with: Some(List_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(List_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_621: Assign = {
    let mut init = Assign {
        assign: Some(List_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_622: Mark = {
    let mut init = Mark {
        mark: Some(
            List_Mark
                as unsafe extern "C" fn(
                    var,
                    var,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_623: Cmp = {
    let mut init = Cmp {
        cmp: Some(List_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_624: Hash = {
    let mut init = Hash {
        hash: Some(List_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_625: Push = {
    let mut init = Push {
        push: Some(List_Push as unsafe extern "C" fn(var, var) -> ()),
        pop: Some(List_Pop as unsafe extern "C" fn(var) -> ()),
        push_at: Some(List_Push_At as unsafe extern "C" fn(var, var, var) -> ()),
        pop_at: Some(List_Pop_At as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_626: Concat = {
    let mut init = Concat {
        concat: Some(List_Concat as unsafe extern "C" fn(var, var) -> ()),
        append: Some(List_Push as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_627: Len = {
    let mut init = Len {
        len: Some(List_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_628: Get = {
    let mut init = Get {
        get: Some(List_Get as unsafe extern "C" fn(var, var) -> var),
        set: Some(List_Set as unsafe extern "C" fn(var, var, var) -> ()),
        mem: Some(List_Mem as unsafe extern "C" fn(var, var) -> bool),
        rem: Some(List_Rem as unsafe extern "C" fn(var, var) -> ()),
        key_type: None,
        val_type: None,
    };
    init
};
static mut __constr_expr_629: Iter = {
    let mut init = Iter {
        iter_init: Some(List_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(List_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(List_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(List_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(List_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_630: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                List_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_631: Resize = {
    let mut init = Resize {
        resize: Some(List_Resize as unsafe extern "C" fn(var, size_t) -> ()),
    };
    init
};
static mut __constr_expr_618: [var; 69] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"List\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<List>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_619 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_620 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_621 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_622 as *const Mark as *mut Mark as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_623 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_624 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Push\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_625 as *const Push as *mut Push as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Concat\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_626 as *const Concat as *mut Concat as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_627 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_628 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_629 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_630 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_631 as *const Resize as *mut Resize as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut List: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Tuple_Name() -> *const libc::c_char {
    return b"Tuple\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Tuple_Brief() -> *const libc::c_char {
    return b"Basic Collection\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Tuple_Description() -> *const libc::c_char {
    return b"The `Tuple` type provides a basic way to create a simple collection of objects. Its main use is the fact that it can be constructed on the stack using the `tuple` macro. This makes it suitable for a number of purposes such as use in functions that take a variable number of arguments.\n\nTuples can also be constructed on the heap and stored in collections. This makes them also useful as a simple _untyped_ list of objects.\n\nInternally Tuples are just an array of pointers terminated with a pointer to the Cello `Terminal` object. This makes positional access fast, but many other operations slow including iteration and counting the number of elements. Due to this it is only recommended Tuples are used for small collections. \n\nBecause Tuples are terminated with the Cello `Terminal` object this can't naturally be included within them. This object should therefore only be returned from iteration functions.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Tuple_Definition() -> *const libc::c_char {
    return b"struct Tuple {\n  var* items;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___21: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = tuple($I(100), $I(200), $S(\"Hello\"));\nshow(x);\nvar y = tuple(Int, $I(10), $I(20));\nvar z = new_with(Array, y);\nshow(z);\n\nforeach (item in x) {\n  println(\"%$\", item);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Tuple_Examples() -> *mut Example {
    return examples___21.as_mut_ptr();
}
static mut methods___18: [Method; 2] = [
    {
        let mut init = Method {
            name: b"tuple\0" as *const u8 as *const libc::c_char,
            definition: b"#define tuple(...)\0" as *const u8 as *const libc::c_char,
            description: b"Construct a `Tuple` object on the stack.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Tuple_Methods() -> *mut Method {
    return methods___18.as_mut_ptr();
}
unsafe extern "C" fn Tuple_New(mut self_0: var, mut args: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nargs: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_632: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_633: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_634: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_635: Int = Int { val: 0 };
    let mut __constr_expr_636: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = len(args);
    nargs = tmp;
    tmp___0 = malloc(
        (::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_mul(nargs.wrapping_add(1 as libc::c_ulong)),
    );
    (*t).items = tmp___0 as *mut var;
    if (*t).items as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_633[0 as libc::c_int as usize] = Terminal;
        __constr_expr_632.items = __constr_expr_633.as_mut_ptr();
        __constr_expr_634[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = 1 as libc::c_uint;
        while !(tmp___1 >= 32 as libc::c_uint) {
            __constr_expr_634[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = tmp___1.wrapping_add(1);
        }
        tmp___2 = header_init(
            __constr_expr_634.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___3 = memcpy(
            tmp___2 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_632 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot create Tuple, out of memory!\0" as *const u8 as *const libc::c_char,
            tmp___3 as *mut Tuple as var,
        );
    }
    i = 0 as libc::c_int as size_t;
    while i < nargs {
        __constr_expr_635.val = i as int64_t;
        __constr_expr_636[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = 1 as libc::c_uint;
        while !(tmp___4 >= 32 as libc::c_uint) {
            __constr_expr_636[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = tmp___4.wrapping_add(1);
        }
        tmp___5 = header_init(
            __constr_expr_636.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___6 = memcpy(
            tmp___5 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_635 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        let ref mut fresh25 = *((*t).items).offset(i as isize);
        *fresh25 = get(args, tmp___6 as *mut Int as var);
        i = i.wrapping_add(1);
    }
    let ref mut fresh26 = *((*t).items).offset(nargs as isize);
    *fresh26 = Terminal;
}
unsafe extern "C" fn Tuple_Del(mut self_0: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut __constr_expr_637: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_638: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_639: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut Header = 0 as *mut Header;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    t = self_0 as *mut Tuple;
    tmp___2 = header(self_0);
    let mut current_block_13: u64;
    if (*tmp___2).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_13 = 3471263507372628464;
    } else {
        tmp___3 = header(self_0);
        if (*tmp___3).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_13 = 3471263507372628464;
        } else {
            current_block_13 = 7149356873433890176;
        }
    }
    match current_block_13 {
        3471263507372628464 => {
            __constr_expr_638[0 as libc::c_int as usize] = Terminal;
            __constr_expr_637.items = __constr_expr_638.as_mut_ptr();
            __constr_expr_639[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_639[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_639.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_637 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot destruct Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    free((*t).items as *mut libc::c_void);
}
unsafe extern "C" fn Tuple_Assign(mut self_0: var, mut obj: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nargs: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __constr_expr_640: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_641: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_642: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut tmp___4: *mut Header = 0 as *mut Header;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_643: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_644: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_645: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_646: Int = Int { val: 0 };
    let mut __constr_expr_647: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: bool = false;
    let mut tmp___15: bool = false;
    t = self_0 as *mut Tuple;
    tmp___14 = implements_method_at_offset(
        obj,
        Len,
        &mut (*(0 as *mut Len)).len as *mut Option::<unsafe extern "C" fn(var) -> size_t>
            as libc::c_ulong,
    );
    let mut current_block_58: u64;
    if tmp___14 {
        tmp___15 = implements_method_at_offset(
            obj,
            Get,
            &mut (*(0 as *mut Get)).get
                as *mut Option::<unsafe extern "C" fn(var, var) -> var> as libc::c_ulong,
        );
        if tmp___15 {
            tmp = len(obj);
            nargs = tmp;
            tmp___3 = header(self_0);
            let mut current_block_17: u64;
            if (*tmp___3).alloc as libc::c_ulong
                == 2 as libc::c_int as var as libc::c_ulong
            {
                current_block_17 = 2605862499974545740;
            } else {
                tmp___4 = header(self_0);
                if (*tmp___4).alloc as libc::c_ulong
                    == 1 as libc::c_int as var as libc::c_ulong
                {
                    current_block_17 = 2605862499974545740;
                } else {
                    current_block_17 = 4761528863920922185;
                }
            }
            match current_block_17 {
                2605862499974545740 => {
                    __constr_expr_641[0 as libc::c_int as usize] = Terminal;
                    __constr_expr_640.items = __constr_expr_641.as_mut_ptr();
                    __constr_expr_642[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___0 = 1 as libc::c_uint;
                    while !(tmp___0 >= 32 as libc::c_uint) {
                        __constr_expr_642[tmp___0
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___0 = tmp___0.wrapping_add(1);
                    }
                    tmp___1 = header_init(
                        __constr_expr_642.as_mut_ptr() as var,
                        Tuple,
                        2 as libc::c_int,
                    );
                    tmp___2 = memcpy(
                        tmp___1 as *mut Tuple as *mut libc::c_void,
                        &mut __constr_expr_640 as *mut Tuple as *const libc::c_void,
                        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                    );
                    exception_throw(
                        ValueError,
                        b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                            as *const libc::c_char,
                        tmp___2 as *mut Tuple as var,
                    );
                }
                _ => {}
            }
            tmp___5 = realloc(
                (*t).items as *mut libc::c_void,
                (::std::mem::size_of::<var>() as libc::c_ulong)
                    .wrapping_mul(nargs.wrapping_add(1 as libc::c_ulong)),
            );
            (*t).items = tmp___5 as *mut var;
            if (*t).items as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                __constr_expr_644[0 as libc::c_int as usize] = Terminal;
                __constr_expr_643.items = __constr_expr_644.as_mut_ptr();
                __constr_expr_645[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = 1 as libc::c_uint;
                while !(tmp___6 >= 32 as libc::c_uint) {
                    __constr_expr_645[tmp___6
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___6 = tmp___6.wrapping_add(1);
                }
                tmp___7 = header_init(
                    __constr_expr_645.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___8 = memcpy(
                    tmp___7 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_643 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    OutOfMemoryError,
                    b"Cannot allocate Tuple, out of memory!\0" as *const u8
                        as *const libc::c_char,
                    tmp___8 as *mut Tuple as var,
                );
            }
            i = 0 as libc::c_int as size_t;
            while i < nargs {
                __constr_expr_646.val = i as int64_t;
                __constr_expr_647[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___9 = 1 as libc::c_uint;
                while !(tmp___9 >= 32 as libc::c_uint) {
                    __constr_expr_647[tmp___9
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___9 = tmp___9.wrapping_add(1);
                }
                tmp___10 = header_init(
                    __constr_expr_647.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___11 = memcpy(
                    tmp___10 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_646 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                let ref mut fresh27 = *((*t).items).offset(i as isize);
                *fresh27 = get(obj, tmp___11 as *mut Int as var);
                i = i.wrapping_add(1);
            }
            let ref mut fresh28 = *((*t).items).offset(nargs as isize);
            *fresh28 = Terminal;
            current_block_58 = 13303144130133872306;
        } else {
            current_block_58 = 3104122067454557842;
        }
    } else {
        current_block_58 = 3104122067454557842;
    }
    match current_block_58 {
        3104122067454557842 => {
            __item = obj;
            tmp___12 = instance(__item, Iter);
            __Iteritem = tmp___12;
            tmp___13 = (Some(
                ((*(__Iteritem as *mut Iter)).iter_init)
                    .expect("non-null function pointer"),
            ))
                .expect("non-null function pointer")(__item);
            item = tmp___13;
            while item as libc::c_ulong != Terminal as libc::c_ulong {
                Tuple_Push(self_0, item);
                item = (Some(
                    ((*(__Iteritem as *mut Iter)).iter_next)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(__item, item);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn Tuple_Len(mut self_0: var) -> size_t {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    t = self_0 as *mut Tuple;
    i = 0 as libc::c_int as size_t;
    while !((*t).items).is_null() {
        if !(*((*t).items).offset(i as isize) as libc::c_ulong
            != Terminal as libc::c_ulong)
        {
            break;
        }
        i = i.wrapping_add(1);
    }
    return i;
}
unsafe extern "C" fn Tuple_Iter_Init(mut self_0: var) -> var {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    t = self_0 as *mut Tuple;
    return *((*t).items).offset(0 as libc::c_int as isize);
}
unsafe extern "C" fn Tuple_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    t = self_0 as *mut Tuple;
    i = 0 as libc::c_int as size_t;
    while *((*t).items).offset(i as isize) as libc::c_ulong != Terminal as libc::c_ulong
    {
        if *((*t).items).offset(i as isize) as libc::c_ulong == curr as libc::c_ulong {
            return *((*t).items).offset(i.wrapping_add(1 as libc::c_ulong) as isize);
        }
        i = i.wrapping_add(1);
    }
    return Terminal;
}
unsafe extern "C" fn Tuple_Iter_Last(mut self_0: var) -> var {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut tmp: size_t = 0;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    return *((*t).items).offset(tmp.wrapping_sub(1 as libc::c_ulong) as isize);
}
unsafe extern "C" fn Tuple_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    t = self_0 as *mut Tuple;
    if curr as libc::c_ulong
        == *((*t).items).offset(0 as libc::c_int as isize) as libc::c_ulong
    {
        return Terminal;
    }
    i = 0 as libc::c_int as size_t;
    while *((*t).items).offset(i as isize) as libc::c_ulong != Terminal as libc::c_ulong
    {
        if *((*t).items).offset(i as isize) as libc::c_ulong == curr as libc::c_ulong {
            return *((*t).items).offset(i.wrapping_sub(1 as libc::c_ulong) as isize);
        }
        i = i.wrapping_add(1);
    }
    return Terminal;
}
unsafe extern "C" fn Tuple_Get(mut self_0: var, mut key: var) -> var {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    let mut __constr_expr_648: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_649: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_650: Int = Int { val: 0 };
    let mut tmp___1: size_t = 0;
    let mut __constr_expr_651: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_652: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    tmp___0 = c_int(key);
    i = tmp___0;
    if i < 0 as libc::c_long {
        i = nitems.wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_167: {
        if !(i < 0 as libc::c_long) {
            if !(i >= nitems as int64_t) {
                break 's_167;
            }
        }
        tmp___1 = Tuple_Len(t as var);
        __constr_expr_650.val = tmp___1 as int64_t;
        __constr_expr_651[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_651[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_651.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_650 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_649[0 as libc::c_int as usize] = key;
        __constr_expr_649[1 as libc::c_int as usize] = tmp___4 as *mut Int as var;
        __constr_expr_649[2 as libc::c_int as usize] = Terminal;
        __constr_expr_648.items = __constr_expr_649.as_mut_ptr();
        __constr_expr_652[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_652[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_652.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_648 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___8 = exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for Tuple of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
        return tmp___8;
    }
    return *((*t).items).offset(i as isize);
}
unsafe extern "C" fn Tuple_Set(mut self_0: var, mut key: var, mut val: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    let mut __constr_expr_653: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_654: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_655: Int = Int { val: 0 };
    let mut tmp___1: size_t = 0;
    let mut __constr_expr_656: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_657: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    tmp___0 = c_int(key);
    i = tmp___0;
    if i < 0 as libc::c_long {
        i = nitems.wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_165: {
        if !(i < 0 as libc::c_long) {
            if !(i >= nitems as int64_t) {
                break 's_165;
            }
        }
        tmp___1 = Tuple_Len(t as var);
        __constr_expr_655.val = tmp___1 as int64_t;
        __constr_expr_656[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_656[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_656.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_655 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_654[0 as libc::c_int as usize] = key;
        __constr_expr_654[1 as libc::c_int as usize] = tmp___4 as *mut Int as var;
        __constr_expr_654[2 as libc::c_int as usize] = Terminal;
        __constr_expr_653.items = __constr_expr_654.as_mut_ptr();
        __constr_expr_657[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_657[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_657.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_653 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for Tuple of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
        return;
    }
    let ref mut fresh29 = *((*t).items).offset(i as isize);
    *fresh29 = val;
}
unsafe extern "C" fn Tuple_Mem(mut self_0: var, mut item: var) -> bool {
    let mut __obj: var = 0 as *mut libc::c_void;
    let mut __Iterobj: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut obj: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    __obj = self_0;
    tmp = instance(__obj, Iter);
    __Iterobj = tmp;
    tmp___0 = (Some(
        ((*(__Iterobj as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__obj);
    obj = tmp___0;
    while obj as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___1 = eq(obj, item);
        if tmp___1 {
            return 1 as libc::c_int != 0;
        }
        obj = (Some(
            ((*(__Iterobj as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__obj, obj);
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Tuple_Rem(mut self_0: var, mut item: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    let mut __constr_expr_658: Int = Int { val: 0 };
    let mut __constr_expr_659: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: bool = false;
    t = self_0 as *mut Tuple;
    i = 0 as libc::c_int as size_t;
    while *((*t).items).offset(i as isize) as libc::c_ulong != Terminal as libc::c_ulong
    {
        tmp___2 = eq(item, *((*t).items).offset(i as isize));
        if tmp___2 {
            __constr_expr_658.val = i as int64_t;
            __constr_expr_659[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_659[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_659.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_658 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            Tuple_Pop_At(self_0, tmp___1 as *mut Int as var);
            return;
        }
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn Tuple_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut __constr_expr_660: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_661: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_662: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_663: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_664: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_665: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_666: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_667: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_668: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_669: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_670: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_671: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___11: libc::c_int = 0;
    t = self_0 as *mut Tuple;
    __constr_expr_661[0 as libc::c_int as usize] = self_0;
    __constr_expr_661[1 as libc::c_int as usize] = Terminal;
    __constr_expr_660.items = __constr_expr_661.as_mut_ptr();
    __constr_expr_662[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_662[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_662.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_660 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"tuple(\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    i = 0 as libc::c_int as size_t;
    while *((*t).items).offset(i as isize) as libc::c_ulong != Terminal as libc::c_ulong
    {
        __constr_expr_664[0 as libc::c_int as usize] = *((*t).items).offset(i as isize);
        __constr_expr_664[1 as libc::c_int as usize] = Terminal;
        __constr_expr_663.items = __constr_expr_664.as_mut_ptr();
        __constr_expr_665[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_665[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_665.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_663 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            output,
            pos,
            b"%$\0" as *const u8 as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
        if *((*t).items).offset(i.wrapping_add(1 as libc::c_ulong) as isize)
            as libc::c_ulong != Terminal as libc::c_ulong
        {
            __constr_expr_667[0 as libc::c_int as usize] = Terminal;
            __constr_expr_666.items = __constr_expr_667.as_mut_ptr();
            __constr_expr_668[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = 1 as libc::c_uint;
            while !(tmp___5 >= 32 as libc::c_uint) {
                __constr_expr_668[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___5 = tmp___5.wrapping_add(1);
            }
            tmp___6 = header_init(
                __constr_expr_668.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___7 = memcpy(
                tmp___6 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_666 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b", \0" as *const u8 as *const libc::c_char,
                tmp___7 as *mut Tuple as var,
            );
        }
        i = i.wrapping_add(1);
    }
    __constr_expr_670[0 as libc::c_int as usize] = Terminal;
    __constr_expr_669.items = __constr_expr_670.as_mut_ptr();
    __constr_expr_671[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___8 = 1 as libc::c_uint;
    while !(tmp___8 >= 32 as libc::c_uint) {
        __constr_expr_671[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___8 = tmp___8.wrapping_add(1);
    }
    tmp___9 = header_init(
        __constr_expr_671.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___10 = memcpy(
        tmp___9 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_669 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___11 = print_to_with(
        output,
        pos,
        b")\0" as *const u8 as *const libc::c_char,
        tmp___10 as *mut Tuple as var,
    );
    return tmp___11;
}
unsafe extern "C" fn Tuple_Push(mut self_0: var, mut obj: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __constr_expr_672: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_673: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_674: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut tmp___4: *mut Header = 0 as *mut Header;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_675: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_676: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_677: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    tmp___3 = header(self_0);
    let mut current_block_15: u64;
    if (*tmp___3).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_15 = 12086246458938025729;
    } else {
        tmp___4 = header(self_0);
        if (*tmp___4).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_15 = 12086246458938025729;
        } else {
            current_block_15 = 4495394744059808450;
        }
    }
    match current_block_15 {
        12086246458938025729 => {
            __constr_expr_673[0 as libc::c_int as usize] = Terminal;
            __constr_expr_672.items = __constr_expr_673.as_mut_ptr();
            __constr_expr_674[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = 1 as libc::c_uint;
            while !(tmp___0 >= 32 as libc::c_uint) {
                __constr_expr_674[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___0 = tmp___0.wrapping_add(1);
            }
            tmp___1 = header_init(
                __constr_expr_674.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___2 = memcpy(
                tmp___1 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_672 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___2 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___5 = realloc(
        (*t).items as *mut libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_mul(nitems.wrapping_add(2 as libc::c_ulong)),
    );
    (*t).items = tmp___5 as *mut var;
    if (*t).items as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_676[0 as libc::c_int as usize] = Terminal;
        __constr_expr_675.items = __constr_expr_676.as_mut_ptr();
        __constr_expr_677[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_677[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_677.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_675 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot grow Tuple, out of memory!\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    let ref mut fresh30 = *((*t).items).offset(nitems as isize);
    *fresh30 = obj;
    let ref mut fresh31 = *((*t).items)
        .offset(nitems.wrapping_add(1 as libc::c_ulong) as isize);
    *fresh31 = Terminal;
}
unsafe extern "C" fn Tuple_Pop(mut self_0: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __constr_expr_678: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_679: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_680: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_681: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_682: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_683: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut Header = 0 as *mut Header;
    let mut tmp___7: *mut Header = 0 as *mut Header;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    if nitems == 0 as libc::c_ulong {
        __constr_expr_679[0 as libc::c_int as usize] = Terminal;
        __constr_expr_678.items = __constr_expr_679.as_mut_ptr();
        __constr_expr_680[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_680[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_680.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_678 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Cannot pop. Tuple is empty!\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
        return;
    }
    tmp___6 = header(self_0);
    let mut current_block_29: u64;
    if (*tmp___6).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_29 = 10648086570338929952;
    } else {
        tmp___7 = header(self_0);
        if (*tmp___7).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_29 = 10648086570338929952;
        } else {
            current_block_29 = 11459959175219260272;
        }
    }
    match current_block_29 {
        10648086570338929952 => {
            __constr_expr_682[0 as libc::c_int as usize] = Terminal;
            __constr_expr_681.items = __constr_expr_682.as_mut_ptr();
            __constr_expr_683[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = 1 as libc::c_uint;
            while !(tmp___3 >= 32 as libc::c_uint) {
                __constr_expr_683[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___3 = tmp___3.wrapping_add(1);
            }
            tmp___4 = header_init(
                __constr_expr_683.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___5 = memcpy(
                tmp___4 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_681 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___5 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___8 = realloc(
        (*t).items as *mut libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong).wrapping_mul(nitems),
    );
    (*t).items = tmp___8 as *mut var;
    let ref mut fresh32 = *((*t).items)
        .offset(nitems.wrapping_sub(1 as libc::c_ulong) as isize);
    *fresh32 = Terminal;
}
unsafe extern "C" fn Tuple_Push_At(mut self_0: var, mut obj: var, mut key: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    let mut __constr_expr_684: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_685: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_686: Int = Int { val: 0 };
    let mut __constr_expr_687: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_688: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_689: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_690: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_691: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *mut Header = 0 as *mut Header;
    let mut tmp___11: *mut Header = 0 as *mut Header;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_692: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_693: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_694: [libc::c_char; 32] = [0; 32];
    let mut tmp___13: libc::c_uint = 0;
    let mut tmp___14: var = 0 as *mut libc::c_void;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    tmp___0 = c_int(key);
    i = tmp___0;
    if i < 0 as libc::c_long {
        i = nitems.wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    let mut current_block_31: u64;
    if i < 0 as libc::c_long {
        current_block_31 = 12931577853055194354;
    } else if i >= nitems as int64_t {
        current_block_31 = 12931577853055194354;
    } else {
        current_block_31 = 8845338526596852646;
    }
    match current_block_31 {
        12931577853055194354 => {
            __constr_expr_686.val = nitems as int64_t;
            __constr_expr_687[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = 1 as libc::c_uint;
            while !(tmp___1 >= 32 as libc::c_uint) {
                __constr_expr_687[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___1 = tmp___1.wrapping_add(1);
            }
            tmp___2 = header_init(
                __constr_expr_687.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___3 = memcpy(
                tmp___2 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_686 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            __constr_expr_685[0 as libc::c_int as usize] = key;
            __constr_expr_685[1 as libc::c_int as usize] = tmp___3 as *mut Int as var;
            __constr_expr_685[2 as libc::c_int as usize] = Terminal;
            __constr_expr_684.items = __constr_expr_685.as_mut_ptr();
            __constr_expr_688[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = 1 as libc::c_uint;
            while !(tmp___4 >= 32 as libc::c_uint) {
                __constr_expr_688[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___4 = tmp___4.wrapping_add(1);
            }
            tmp___5 = header_init(
                __constr_expr_688.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___6 = memcpy(
                tmp___5 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_684 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                IndexOutOfBoundsError,
                b"Index '%i' out of bounds for Tuple of size %i.\0" as *const u8
                    as *const libc::c_char,
                tmp___6 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___10 = header(self_0);
    let mut current_block_45: u64;
    if (*tmp___10).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_45 = 697634517029150985;
    } else {
        tmp___11 = header(self_0);
        if (*tmp___11).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_45 = 697634517029150985;
        } else {
            current_block_45 = 1423531122933789233;
        }
    }
    match current_block_45 {
        697634517029150985 => {
            __constr_expr_690[0 as libc::c_int as usize] = Terminal;
            __constr_expr_689.items = __constr_expr_690.as_mut_ptr();
            __constr_expr_691[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___7 = 1 as libc::c_uint;
            while !(tmp___7 >= 32 as libc::c_uint) {
                __constr_expr_691[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___7 = tmp___7.wrapping_add(1);
            }
            tmp___8 = header_init(
                __constr_expr_691.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___9 = memcpy(
                tmp___8 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_689 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___9 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___12 = realloc(
        (*t).items as *mut libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_mul(nitems.wrapping_add(2 as libc::c_ulong)),
    );
    (*t).items = tmp___12 as *mut var;
    if (*t).items as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_693[0 as libc::c_int as usize] = Terminal;
        __constr_expr_692.items = __constr_expr_693.as_mut_ptr();
        __constr_expr_694[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___13 = 1 as libc::c_uint;
        while !(tmp___13 >= 32 as libc::c_uint) {
            __constr_expr_694[tmp___13 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___13 = tmp___13.wrapping_add(1);
        }
        tmp___14 = header_init(
            __constr_expr_694.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___15 = memcpy(
            tmp___14 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_692 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot grow Tuple, out of memory!\0" as *const u8 as *const libc::c_char,
            tmp___15 as *mut Tuple as var,
        );
    }
    memmove(
        ((*t).items).offset((i + 1 as libc::c_long) as isize) as *mut libc::c_void,
        ((*t).items).offset(i as isize) as *const libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_mul(
                nitems.wrapping_sub(i as size_t).wrapping_add(1 as libc::c_ulong),
            ),
    );
    let ref mut fresh33 = *((*t).items).offset(i as isize);
    *fresh33 = obj;
}
unsafe extern "C" fn Tuple_Pop_At(mut self_0: var, mut key: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    let mut __constr_expr_695: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_696: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_697: Int = Int { val: 0 };
    let mut __constr_expr_698: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_699: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_700: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_701: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_702: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *mut Header = 0 as *mut Header;
    let mut tmp___11: *mut Header = 0 as *mut Header;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    tmp___0 = c_int(key);
    i = tmp___0;
    if i < 0 as libc::c_long {
        i = nitems.wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    let mut current_block_31: u64;
    if i < 0 as libc::c_long {
        current_block_31 = 558594861731530761;
    } else if i >= nitems as int64_t {
        current_block_31 = 558594861731530761;
    } else {
        current_block_31 = 7333393191927787629;
    }
    match current_block_31 {
        558594861731530761 => {
            __constr_expr_697.val = nitems as int64_t;
            __constr_expr_698[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = 1 as libc::c_uint;
            while !(tmp___1 >= 32 as libc::c_uint) {
                __constr_expr_698[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___1 = tmp___1.wrapping_add(1);
            }
            tmp___2 = header_init(
                __constr_expr_698.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___3 = memcpy(
                tmp___2 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_697 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            __constr_expr_696[0 as libc::c_int as usize] = key;
            __constr_expr_696[1 as libc::c_int as usize] = tmp___3 as *mut Int as var;
            __constr_expr_696[2 as libc::c_int as usize] = Terminal;
            __constr_expr_695.items = __constr_expr_696.as_mut_ptr();
            __constr_expr_699[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = 1 as libc::c_uint;
            while !(tmp___4 >= 32 as libc::c_uint) {
                __constr_expr_699[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___4 = tmp___4.wrapping_add(1);
            }
            tmp___5 = header_init(
                __constr_expr_699.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___6 = memcpy(
                tmp___5 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_695 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                IndexOutOfBoundsError,
                b"Index '%i' out of bounds for Tuple of size %i.\0" as *const u8
                    as *const libc::c_char,
                tmp___6 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    memmove(
        ((*t).items).offset(i as isize) as *mut libc::c_void,
        ((*t).items).offset((i + 1 as libc::c_long) as isize) as *const libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_mul(nitems.wrapping_sub(i as size_t)),
    );
    tmp___10 = header(self_0);
    let mut current_block_46: u64;
    if (*tmp___10).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_46 = 2711208435497962651;
    } else {
        tmp___11 = header(self_0);
        if (*tmp___11).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_46 = 2711208435497962651;
        } else {
            current_block_46 = 2989495919056355252;
        }
    }
    match current_block_46 {
        2711208435497962651 => {
            __constr_expr_701[0 as libc::c_int as usize] = Terminal;
            __constr_expr_700.items = __constr_expr_701.as_mut_ptr();
            __constr_expr_702[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___7 = 1 as libc::c_uint;
            while !(tmp___7 >= 32 as libc::c_uint) {
                __constr_expr_702[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___7 = tmp___7.wrapping_add(1);
            }
            tmp___8 = header_init(
                __constr_expr_702.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___9 = memcpy(
                tmp___8 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_700 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___9 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___12 = realloc(
        (*t).items as *mut libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong).wrapping_mul(nitems),
    );
    (*t).items = tmp___12 as *mut var;
}
unsafe extern "C" fn Tuple_Concat(mut self_0: var, mut obj: var) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut nitems: size_t = 0;
    let mut tmp: size_t = 0;
    let mut objlen: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut __constr_expr_703: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_704: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_705: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut Header = 0 as *mut Header;
    let mut tmp___5: *mut Header = 0 as *mut Header;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_706: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_707: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_708: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp = Tuple_Len(t as var);
    nitems = tmp;
    tmp___0 = len(obj);
    objlen = tmp___0;
    tmp___4 = header(self_0);
    let mut current_block_17: u64;
    if (*tmp___4).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_17 = 3888413915540750809;
    } else {
        tmp___5 = header(self_0);
        if (*tmp___5).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_17 = 3888413915540750809;
        } else {
            current_block_17 = 18386322304582297246;
        }
    }
    match current_block_17 {
        3888413915540750809 => {
            __constr_expr_704[0 as libc::c_int as usize] = Terminal;
            __constr_expr_703.items = __constr_expr_704.as_mut_ptr();
            __constr_expr_705[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = 1 as libc::c_uint;
            while !(tmp___1 >= 32 as libc::c_uint) {
                __constr_expr_705[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___1 = tmp___1.wrapping_add(1);
            }
            tmp___2 = header_init(
                __constr_expr_705.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___3 = memcpy(
                tmp___2 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_703 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___3 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___6 = realloc(
        (*t).items as *mut libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_mul(nitems.wrapping_add(1 as libc::c_ulong).wrapping_add(objlen)),
    );
    (*t).items = tmp___6 as *mut var;
    if (*t).items as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_707[0 as libc::c_int as usize] = Terminal;
        __constr_expr_706.items = __constr_expr_707.as_mut_ptr();
        __constr_expr_708[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = 1 as libc::c_uint;
        while !(tmp___7 >= 32 as libc::c_uint) {
            __constr_expr_708[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___7 = tmp___7.wrapping_add(1);
        }
        tmp___8 = header_init(
            __constr_expr_708.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___9 = memcpy(
            tmp___8 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_706 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot grow Tuple, out of memory!\0" as *const u8 as *const libc::c_char,
            tmp___9 as *mut Tuple as var,
        );
    }
    i = nitems;
    __item = obj;
    tmp___10 = instance(__item, Iter);
    __Iteritem = tmp___10;
    tmp___11 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___11;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        let ref mut fresh34 = *((*t).items).offset(i as isize);
        *fresh34 = item;
        i = i.wrapping_add(1);
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
    let ref mut fresh35 = *((*t).items).offset(nitems.wrapping_add(objlen) as isize);
    *fresh35 = Terminal;
}
unsafe extern "C" fn Tuple_Resize(mut self_0: var, mut n: size_t) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut __constr_expr_709: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_710: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_711: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut Header = 0 as *mut Header;
    let mut tmp___3: *mut Header = 0 as *mut Header;
    let mut m: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_712: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_713: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_714: Int = Int { val: 0 };
    let mut __constr_expr_715: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_716: Int = Int { val: 0 };
    let mut __constr_expr_717: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_718: [libc::c_char; 32] = [0; 32];
    let mut tmp___12: libc::c_uint = 0;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Tuple;
    tmp___2 = header(self_0);
    let mut current_block_13: u64;
    if (*tmp___2).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        current_block_13 = 12144115004353157458;
    } else {
        tmp___3 = header(self_0);
        if (*tmp___3).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong
        {
            current_block_13 = 12144115004353157458;
        } else {
            current_block_13 = 10043043949733653460;
        }
    }
    match current_block_13 {
        12144115004353157458 => {
            __constr_expr_710[0 as libc::c_int as usize] = Terminal;
            __constr_expr_709.items = __constr_expr_710.as_mut_ptr();
            __constr_expr_711[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_711[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_711.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_709 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                ValueError,
                b"Cannot reallocate Tuple, not on heap!\0" as *const u8
                    as *const libc::c_char,
                tmp___1 as *mut Tuple as var,
            );
        }
        _ => {}
    }
    tmp___4 = Tuple_Len(self_0);
    m = tmp___4;
    if n < m {
        tmp___5 = realloc(
            (*t).items as *mut libc::c_void,
            (::std::mem::size_of::<var>() as libc::c_ulong)
                .wrapping_mul(n.wrapping_add(1 as libc::c_ulong)),
        );
        (*t).items = tmp___5 as *mut var;
        let ref mut fresh36 = *((*t).items).offset(n as isize);
        *fresh36 = Terminal;
    } else {
        __constr_expr_714.val = n as int64_t;
        __constr_expr_715[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_715[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_715.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_714 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_716.val = m as int64_t;
        __constr_expr_717[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = 1 as libc::c_uint;
        while !(tmp___9 >= 32 as libc::c_uint) {
            __constr_expr_717[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___9 = tmp___9.wrapping_add(1);
        }
        tmp___10 = header_init(
            __constr_expr_717.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___11 = memcpy(
            tmp___10 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_716 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_713[0 as libc::c_int as usize] = tmp___8 as *mut Int as var;
        __constr_expr_713[1 as libc::c_int as usize] = tmp___11 as *mut Int as var;
        __constr_expr_713[2 as libc::c_int as usize] = Terminal;
        __constr_expr_712.items = __constr_expr_713.as_mut_ptr();
        __constr_expr_718[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___12 = 1 as libc::c_uint;
        while !(tmp___12 >= 32 as libc::c_uint) {
            __constr_expr_718[tmp___12 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___12 = tmp___12.wrapping_add(1);
        }
        tmp___13 = header_init(
            __constr_expr_718.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___14 = memcpy(
            tmp___13 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_712 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Cannot resize Tuple to %li as it only contains %li items\0" as *const u8
                as *const libc::c_char,
            tmp___14 as *mut Tuple as var,
        );
    };
}
unsafe extern "C" fn Tuple_Mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    t = self_0 as *mut Tuple;
    i = 0 as libc::c_int as size_t;
    if (*t).items as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    while *((*t).items).offset(i as isize) as libc::c_ulong != Terminal as libc::c_ulong
    {
        (Some(f.expect("non-null function pointer")))
            .expect("non-null function pointer")(gc, *((*t).items).offset(i as isize));
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn Tuple_Swap(mut t: *mut Tuple, mut i: size_t, mut j: size_t) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = *((*t).items).offset(i as isize);
    let ref mut fresh37 = *((*t).items).offset(i as isize);
    *fresh37 = *((*t).items).offset(j as isize);
    let ref mut fresh38 = *((*t).items).offset(j as isize);
    *fresh38 = tmp;
}
unsafe extern "C" fn Tuple_Sort_Partition(
    mut t: *mut Tuple,
    mut l: int64_t,
    mut r: int64_t,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) -> size_t {
    let mut p: int64_t = 0;
    let mut s: int64_t = 0;
    let mut i: int64_t = 0;
    let mut tmp: bool = false;
    p = l + (r - l) / 2 as libc::c_long;
    Tuple_Swap(t, p as size_t, r as size_t);
    s = l;
    i = l;
    while i < r {
        tmp = (Some(f.expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(*((*t).items).offset(i as isize), *((*t).items).offset(r as isize));
        if tmp {
            Tuple_Swap(t, i as size_t, s as size_t);
            s += 1;
        }
        i += 1;
    }
    Tuple_Swap(t, s as size_t, r as size_t);
    return s as size_t;
}
unsafe extern "C" fn Tuple_Sort_Part(
    mut t: *mut Tuple,
    mut l: int64_t,
    mut r: int64_t,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) {
    let mut s: int64_t = 0;
    let mut tmp: size_t = 0;
    if l < r {
        tmp = Tuple_Sort_Partition(t, l, r, f);
        s = tmp as int64_t;
        Tuple_Sort_Part(t, l, s - 1 as libc::c_long, f);
        Tuple_Sort_Part(t, s + 1 as libc::c_long, r, f);
    }
}
unsafe extern "C" fn Tuple_Sort_By(
    mut self_0: var,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) {
    let mut tmp: size_t = 0;
    tmp = Tuple_Len(self_0);
    Tuple_Sort_Part(
        self_0 as *mut Tuple,
        0 as libc::c_int as int64_t,
        tmp.wrapping_sub(1 as libc::c_ulong) as int64_t,
        f,
    );
}
unsafe extern "C" fn Tuple_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut i: size_t = 0;
    let mut item0: var = 0 as *mut libc::c_void;
    let mut item1: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    t = self_0 as *mut Tuple;
    i = 0 as libc::c_int as size_t;
    item0 = *((*t).items).offset(i as isize);
    tmp = iter_init(obj);
    item1 = tmp;
    loop {
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            if item1 as libc::c_ulong == Terminal as libc::c_ulong {
                return 0 as libc::c_int;
            }
        }
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if item1 as libc::c_ulong == Terminal as libc::c_ulong {
            return 1 as libc::c_int;
        }
        tmp___0 = cmp(item0, item1);
        c = tmp___0;
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        i = i.wrapping_add(1);
        item0 = *((*t).items).offset(i as isize);
        item1 = iter_next(obj, item1);
    };
}
unsafe extern "C" fn Tuple_Hash(mut self_0: var) -> uint64_t {
    let mut t: *mut Tuple = 0 as *mut Tuple;
    let mut h: uint64_t = 0;
    let mut n: size_t = 0;
    let mut tmp: size_t = 0;
    let mut i: size_t = 0;
    let mut tmp___0: uint64_t = 0;
    t = self_0 as *mut Tuple;
    h = 0 as libc::c_int as uint64_t;
    tmp = Tuple_Len(self_0);
    n = tmp;
    i = 0 as libc::c_int as size_t;
    while i < n {
        tmp___0 = hash(*((*t).items).offset(i as isize));
        h ^= tmp___0;
        i = i.wrapping_add(1);
    }
    return h;
}
static mut __constr_expr_720: Doc = {
    let mut init = Doc {
        name: Some(Tuple_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Tuple_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Tuple_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Tuple_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Tuple_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Tuple_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_721: New = {
    let mut init = New {
        construct_with: Some(Tuple_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Tuple_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_722: Assign = {
    let mut init = Assign {
        assign: Some(Tuple_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_723: Cmp = {
    let mut init = Cmp {
        cmp: Some(Tuple_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_724: Hash = {
    let mut init = Hash {
        hash: Some(Tuple_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_725: Len = {
    let mut init = Len {
        len: Some(Tuple_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_726: Get = {
    let mut init = Get {
        get: Some(Tuple_Get as unsafe extern "C" fn(var, var) -> var),
        set: Some(Tuple_Set as unsafe extern "C" fn(var, var, var) -> ()),
        mem: Some(Tuple_Mem as unsafe extern "C" fn(var, var) -> bool),
        rem: Some(Tuple_Rem as unsafe extern "C" fn(var, var) -> ()),
        key_type: None,
        val_type: None,
    };
    init
};
static mut __constr_expr_727: Push = {
    let mut init = Push {
        push: Some(Tuple_Push as unsafe extern "C" fn(var, var) -> ()),
        pop: Some(Tuple_Pop as unsafe extern "C" fn(var) -> ()),
        push_at: Some(Tuple_Push_At as unsafe extern "C" fn(var, var, var) -> ()),
        pop_at: Some(Tuple_Pop_At as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_728: Concat = {
    let mut init = Concat {
        concat: Some(Tuple_Concat as unsafe extern "C" fn(var, var) -> ()),
        append: Some(Tuple_Push as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_729: Resize = {
    let mut init = Resize {
        resize: Some(Tuple_Resize as unsafe extern "C" fn(var, size_t) -> ()),
    };
    init
};
static mut __constr_expr_730: Iter = unsafe {
    {
        let mut init = Iter {
            iter_init: Some(Tuple_Iter_Init as unsafe extern "C" fn(var) -> var),
            iter_next: Some(Tuple_Iter_Next as unsafe extern "C" fn(var, var) -> var),
            iter_last: Some(Tuple_Iter_Last as unsafe extern "C" fn(var) -> var),
            iter_prev: Some(Tuple_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
            iter_type: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> var>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_731: Mark = {
    let mut init = Mark {
        mark: Some(
            Tuple_Mark
                as unsafe extern "C" fn(
                    var,
                    var,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_732: Sort = {
    let mut init = Sort {
        sort_by: Some(
            Tuple_Sort_By
                as unsafe extern "C" fn(
                    var,
                    Option::<unsafe extern "C" fn(var, var) -> bool>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_733: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Tuple_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_719: [var; 72] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Tuple\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_720 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_721 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_722 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_723 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_724 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_725 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_726 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Push\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_727 as *const Push as *mut Push as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Concat\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_728 as *const Concat as *mut Concat as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_729 as *const Resize as *mut Resize as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_730 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_731 as *const Mark as *mut Mark as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Sort\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_732 as *const Sort as *mut Sort as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_733 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Tuple: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Pointer_Name() -> *const libc::c_char {
    return b"Pointer\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Pointer_Brief() -> *const libc::c_char {
    return b"Reference to other object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Pointer_Description() -> *const libc::c_char {
    return b"The `Pointer` class is implemented by types which act as references to other objects. Primarily this class is implemented by `Ref` and `Box` which provide the two main pointer types in Cello.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Pointer_Definition() -> *const libc::c_char {
    return b"struct Pointer {\n  void (*ref)(var, var);\n  var (*deref)(var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___22: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var obj0 = $F(1.0), obj1 = $F(2.0);\nvar r = $(Ref, obj0);\nshow(r);\nshow(deref(r)); /* 1.0 */\nref(r, obj1);\nshow(deref(r)); /* 2.0 */\nassign(r, obj0);\nshow(deref(r)); /* 1.0 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Pointer_Examples() -> *mut Example {
    return examples___22.as_mut_ptr();
}
static mut methods___19: [Method; 3] = [
    {
        let mut init = Method {
            name: b"ref\0" as *const u8 as *const libc::c_char,
            definition: b"void ref(var self, var item);\0" as *const u8
                as *const libc::c_char,
            description: b"Set the object `self` to reference the object `item`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"deref\0" as *const u8 as *const libc::c_char,
            definition: b"var deref(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Get the object referenced by `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Pointer_Methods() -> *mut Method {
    return methods___19.as_mut_ptr();
}
static mut __constr_expr_735: Doc = {
    let mut init = Doc {
        name: Some(Pointer_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Pointer_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Pointer_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Pointer_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Pointer_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Pointer_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_734: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Pointer\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Pointer>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_735 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Pointer: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn ref_0(mut self_0: var, mut item: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Pointer,
        &mut (*(0 as *mut Pointer)).ref_0
            as *mut Option::<unsafe extern "C" fn(var, var) -> ()> as libc::c_ulong,
        b"ref\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Pointer)).ref_0).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, item);
}
pub unsafe extern "C" fn deref(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Pointer,
        &mut (*(0 as *mut Pointer)).deref
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
        b"deref\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Pointer)).deref).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
unsafe extern "C" fn Ref_Name() -> *const libc::c_char {
    return b"Ref\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Ref_Brief() -> *const libc::c_char {
    return b"Shared Pointer\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Ref_Description() -> *const libc::c_char {
    return b"The `Ref` type is a basic wrapper around a C pointer. It can be used as a type argument to collections to allow them to store generic types. It may also be useful in various circumstances where another level of indirection or mutability is required.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Ref_Definition() -> *const libc::c_char {
    return b"struct Ref {\n  var val;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___23: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var obj0 = $F(1.0), obj1 = $F(2.0);\nvar r = $(Ref, obj0);\nshow(r);\nshow(deref(r)); /* 1.0 */\nref(r, obj1);\nshow(deref(r)); /* 2.0 */\nassign(r, obj0);\nshow(deref(r)); /* 1.0 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Collections\0" as *const u8 as *const libc::c_char,
            body: b"var i0 = new(Int, $I(100));\nvar i1 = new(Int, $I(200));\nvar x = new(Array, Ref, i0, i1);\n\nprint(deref(get(x, $I(0)))); /* 100 */\ndel(x); /* Contents of `x` still alive */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Ref_Examples() -> *mut Example {
    return examples___23.as_mut_ptr();
}
unsafe extern "C" fn Ref_Assign(mut self_0: var, mut obj: var) {
    let mut p: *mut Pointer = 0 as *mut Pointer;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = instance(obj, Pointer);
    p = tmp as *mut Pointer;
    if !p.is_null() {
        if ((*p).deref).is_some() {
            tmp___0 = (Some(((*p).deref).expect("non-null function pointer")))
                .expect("non-null function pointer")(obj);
            Ref_Ref(self_0, tmp___0);
        } else {
            Ref_Ref(self_0, obj);
        }
    } else {
        Ref_Ref(self_0, obj);
    };
}
unsafe extern "C" fn Ref_Ref(mut self_0: var, mut val: var) {
    let mut r: *mut Ref = 0 as *mut Ref;
    r = self_0 as *mut Ref;
    (*r).val = val;
}
unsafe extern "C" fn Ref_Deref(mut self_0: var) -> var {
    let mut r: *mut Ref = 0 as *mut Ref;
    r = self_0 as *mut Ref;
    return (*r).val;
}
static mut __constr_expr_737: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Ref_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Ref_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Ref_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Ref_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(Ref_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_738: Assign = {
    let mut init = Assign {
        assign: Some(Ref_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_739: Pointer = {
    let mut init = Pointer {
        ref_0: Some(Ref_Ref as unsafe extern "C" fn(var, var) -> ()),
        deref: Some(Ref_Deref as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_736: [var; 39] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Ref\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Ref>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_737 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_738 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Pointer\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_739 as *const Pointer as *mut Pointer as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Ref: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Box_Name() -> *const libc::c_char {
    return b"Box\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Box_Brief() -> *const libc::c_char {
    return b"Unique Pointer\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Box_Description() -> *const libc::c_char {
    return b"The `Box` type is another wrapper around a C pointer with one additional behaviour as compared to `Ref`. When a `Box` object is deleted it will also call `del` on the object it points to. The means a `Box` is considered a pointer type that _owns_ the object it points to, and so is responsible for it's destruction. Due to this `Box`s must point to valid Cello objects and so can't be initalised with `NULL` or anything else invalid. \n\nWhile this might not seem that useful when there is Garbage Collection this can be very useful when Garbage Collection is turned off, and when used in conjunction with collections.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Box_Definition() -> *const libc::c_char {
    return b"struct Box {\n  var val;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___24: [Example; 4] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var obj0 = $F(1.0), obj1 = $F(2.0);\nvar r = $(Box, obj0);\nshow(r);\nshow(deref(r)); /* 1.0 */\nref(r, obj1);\nshow(deref(r)); /* 2.0 */\nassign(r, obj0);\nshow(deref(r)); /* 1.0 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Lifetimes\0" as *const u8 as *const libc::c_char,
            body: b"var quote = $S(\"Life is long\");\n\nwith (r in $B(new(String, quote))) {\n  println(\"This reference is: %$\", r);\n  println(\"This string is alive: '%s'\", deref(r));\n}\n\nprint(\"Now it has been cleared up!\\n\");\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Collection\0" as *const u8 as *const libc::c_char,
            body: b"/* Multiple Types in one Collection */\nvar x = new(Array, Box, \n  new(String, $S(\"Hello\")), \n  new(String, $S(\"There\")), \n  new(Int, $I(10)));\n\nprint(deref(get(x, $I(0)))); /* Hello */ \n\ndel(x); /* Contents of `x` deleted with it */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Box_Examples() -> *mut Example {
    return examples___24.as_mut_ptr();
}
unsafe extern "C" fn Box_New(mut self_0: var, mut args: var) {
    let mut __constr_expr_740: Int = Int { val: 0 };
    let mut __constr_expr_741: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    __constr_expr_740.val = 0 as libc::c_int as int64_t;
    __constr_expr_741[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_741[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_741.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_740 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    Box_Assign(self_0, tmp___2);
}
unsafe extern "C" fn Box_Del(mut self_0: var) {
    let mut obj: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = Box_Deref(self_0);
    obj = tmp;
    if !obj.is_null() {
        del(obj);
    }
    Box_Ref(self_0, 0 as *mut libc::c_void);
}
unsafe extern "C" fn Box_Assign(mut self_0: var, mut obj: var) {
    let mut p: *mut Pointer = 0 as *mut Pointer;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = instance(obj, Pointer);
    p = tmp as *mut Pointer;
    if !p.is_null() {
        if ((*p).deref).is_some() {
            tmp___0 = (Some(((*p).deref).expect("non-null function pointer")))
                .expect("non-null function pointer")(obj);
            Box_Ref(self_0, tmp___0);
        } else {
            Box_Ref(self_0, obj);
        }
    } else {
        Box_Ref(self_0, obj);
    };
}
unsafe extern "C" fn Box_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut __constr_expr_742: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_743: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut __constr_expr_744: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: libc::c_int = 0;
    tmp = Box_Deref(self_0);
    __constr_expr_743[0 as libc::c_int as usize] = self_0;
    __constr_expr_743[1 as libc::c_int as usize] = tmp;
    __constr_expr_743[2 as libc::c_int as usize] = Terminal;
    __constr_expr_742.items = __constr_expr_743.as_mut_ptr();
    __constr_expr_744[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___0 = 1 as libc::c_uint;
    while !(tmp___0 >= 32 as libc::c_uint) {
        __constr_expr_744[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = tmp___0.wrapping_add(1);
    }
    tmp___1 = header_init(
        __constr_expr_744.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___2 = memcpy(
        tmp___1 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_742 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___3 = print_to_with(
        output,
        pos,
        b"<'Box' at 0x%p (%$)>\0" as *const u8 as *const libc::c_char,
        tmp___2 as *mut Tuple as var,
    );
    return tmp___3;
}
unsafe extern "C" fn Box_Ref(mut self_0: var, mut val: var) {
    let mut b: *mut Box_0 = 0 as *mut Box_0;
    b = self_0 as *mut Box_0;
    (*b).val = val;
}
unsafe extern "C" fn Box_Deref(mut self_0: var) -> var {
    let mut b: *mut Box_0 = 0 as *mut Box_0;
    b = self_0 as *mut Box_0;
    return (*b).val;
}
static mut __constr_expr_746: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Box_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Box_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Box_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Box_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(Box_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_747: New = {
    let mut init = New {
        construct_with: Some(Box_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Box_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_748: Assign = {
    let mut init = Assign {
        assign: Some(Box_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_749: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Box_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_750: Pointer = {
    let mut init = Pointer {
        ref_0: Some(Box_Ref as unsafe extern "C" fn(var, var) -> ()),
        deref: Some(Box_Deref as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_745: [var; 45] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Box\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Box_0>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_746 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_747 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_748 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_749 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Pointer\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_750 as *const Pointer as *mut Pointer as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Box: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Tree_Name() -> *const libc::c_char {
    return b"Tree\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Tree_Brief() -> *const libc::c_char {
    return b"Balanced Binary Tree\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Tree_Description() -> *const libc::c_char {
    return b"The `Tree` type is a self balancing binary tree implemented as a red-black tree. It provides key-value access and requires the `Cmp` class to be defined on the key type.\n\nElement lookup and insertion are provided as an `O(log(n))` operation. This means in general a `Tree` is slower than a `Table` but it has several other nice properties such as being able to iterate over the items in order and not having large pauses for rehashing on some insertions.\n\nThis is largely equivalent to the C++ construct [std::map](http://www.cplusplus.com/reference/map/map/)\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___25: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var prices = new(Tree, String, Int);\nset(prices, $S(\"Apple\"),  $I(12));\nset(prices, $S(\"Banana\"), $I( 6));\nset(prices, $S(\"Pear\"),   $I(55));\n\nforeach (key in prices) {\n  var price = get(prices, key);\n  println(\"Price of %$ is %$\", key, price);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Manipulation\0" as *const u8 as *const libc::c_char,
            body: b"var t = new(Tree, String, Int);\nset(t, $S(\"Hello\"), $I(2));\nset(t, $S(\"There\"), $I(5));\n\nshow($I(len(t))); /* 2 */\nshow($I(mem(t, $S(\"Hello\")))); /* 1 */\n\nrem(t, $S(\"Hello\"));\n\nshow($I(len(t))); /* 1 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 1 */\n\nresize(t, 0);\n\nshow($I(len(t))); /* 0 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 0 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Tree_Examples() -> *mut Example {
    return examples___25.as_mut_ptr();
}
unsafe extern "C" fn Tree_Left(mut m: *mut Tree, mut node: var) -> *mut var {
    return (node as *mut libc::c_char).offset(0 as libc::c_ulong as isize) as *mut var;
}
unsafe extern "C" fn Tree_Right(mut m: *mut Tree, mut node: var) -> *mut var {
    return (node as *mut libc::c_char)
        .offset(::std::mem::size_of::<var>() as libc::c_ulong as isize) as *mut var;
}
unsafe extern "C" fn Tree_Get_Parent(mut m: *mut Tree, mut node: var) -> var {
    let mut ptr: var = 0 as *mut libc::c_void;
    ptr = *((node as *mut libc::c_char)
        .offset(
            (2 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
        ) as *mut var);
    return (ptr as uintptr_t & 0xfffffffffffffffe as libc::c_ulong) as var;
}
unsafe extern "C" fn Tree_Set_Parent(mut m: *mut Tree, mut node: var, mut ptr: var) {
    let mut tmp: bool = false;
    tmp = Tree_Is_Red(m, node);
    if tmp {
        let ref mut fresh39 = *((node as *mut libc::c_char)
            .offset(
                (2 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            ) as *mut var);
        *fresh39 = (ptr as uintptr_t | 1 as libc::c_ulong) as var;
    } else {
        let ref mut fresh40 = *((node as *mut libc::c_char)
            .offset(
                (2 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            ) as *mut var);
        *fresh40 = ptr;
    };
}
unsafe extern "C" fn Tree_Key(mut m: *mut Tree, mut node: var) -> var {
    return (node as *mut libc::c_char)
        .offset(
            (3 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
        )
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Tree_Val(mut m: *mut Tree, mut node: var) -> var {
    return (node as *mut libc::c_char)
        .offset(
            (3 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
        )
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
        .offset((*m).ksize as isize)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Tree_Set_Color(mut m: *mut Tree, mut node: var, mut col: bool) {
    let mut ptr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = Tree_Get_Parent(m, node);
    ptr = tmp;
    if col {
        let ref mut fresh41 = *((node as *mut libc::c_char)
            .offset(
                (2 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            ) as *mut var);
        *fresh41 = (ptr as uintptr_t | 1 as libc::c_ulong) as var;
    } else {
        let ref mut fresh42 = *((node as *mut libc::c_char)
            .offset(
                (2 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            ) as *mut var);
        *fresh42 = ptr;
    };
}
unsafe extern "C" fn Tree_Get_Color(mut m: *mut Tree, mut node: var) -> bool {
    let mut ptr: var = 0 as *mut libc::c_void;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    ptr = *((node as *mut libc::c_char)
        .offset(
            (2 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
        ) as *mut var);
    return ptr as uintptr_t & 1 as libc::c_ulong != 0;
}
unsafe extern "C" fn Tree_Set_Black(mut m: *mut Tree, mut node: var) {
    Tree_Set_Color(m, node, 0 as libc::c_int != 0);
}
unsafe extern "C" fn Tree_Set_Red(mut m: *mut Tree, mut node: var) {
    Tree_Set_Color(m, node, 1 as libc::c_int != 0);
}
unsafe extern "C" fn Tree_Is_Red(mut m: *mut Tree, mut node: var) -> bool {
    let mut tmp: bool = false;
    tmp = Tree_Get_Color(m, node);
    return tmp;
}
unsafe extern "C" fn Tree_Is_Black(mut m: *mut Tree, mut node: var) -> bool {
    let mut tmp: bool = false;
    let mut tmp___0: libc::c_int = 0;
    tmp = Tree_Get_Color(m, node);
    if tmp {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp___0 = 1 as libc::c_int;
    }
    return tmp___0 != 0;
}
unsafe extern "C" fn Tree_Alloc(mut m: *mut Tree) -> var {
    let mut node: var = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_751: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_752: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_753: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut val: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut var = 0 as *mut var;
    let mut tmp___6: *mut var = 0 as *mut var;
    tmp = calloc(
        1 as libc::c_int as size_t,
        (3 as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong)
            .wrapping_add((*m).ksize)
            .wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong)
            .wrapping_add((*m).vsize),
    );
    node = tmp;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_752[0 as libc::c_int as usize] = Terminal;
        __constr_expr_751.items = __constr_expr_752.as_mut_ptr();
        __constr_expr_753[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_753[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_753.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_751 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate Tree entry, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    tmp___3 = header_init(
        (node as *mut libc::c_char)
            .offset(
                (3 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            ) as *mut Header as var,
        (*m).ktype,
        4 as libc::c_int,
    );
    key = tmp___3;
    tmp___4 = header_init(
        (node as *mut libc::c_char)
            .offset(
                (3 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize,
            )
            .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize)
            .offset((*m).ksize as isize) as *mut Header as var,
        (*m).vtype,
        4 as libc::c_int,
    );
    val = tmp___4;
    tmp___5 = Tree_Left(m, node);
    *tmp___5 = 0 as *mut libc::c_void;
    tmp___6 = Tree_Right(m, node);
    *tmp___6 = 0 as *mut libc::c_void;
    Tree_Set_Parent(m, node, 0 as *mut libc::c_void);
    Tree_Set_Red(m, node);
    return node;
}
unsafe extern "C" fn Tree_New(mut self_0: var, mut args: var) {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut __constr_expr_754: Int = Int { val: 0 };
    let mut __constr_expr_755: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_756: Int = Int { val: 0 };
    let mut __constr_expr_757: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut nargs: size_t = 0;
    let mut tmp___5: size_t = 0;
    let mut __constr_expr_758: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_759: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_760: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut key: var = 0 as *mut libc::c_void;
    let mut __constr_expr_761: Int = Int { val: 0 };
    let mut __constr_expr_762: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut val: var = 0 as *mut libc::c_void;
    let mut __constr_expr_763: Int = Int { val: 0 };
    let mut __constr_expr_764: [libc::c_char; 32] = [0; 32];
    let mut tmp___13: libc::c_uint = 0;
    let mut tmp___14: var = 0 as *mut libc::c_void;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    __constr_expr_754.val = 0 as libc::c_int as int64_t;
    __constr_expr_755[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_755[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_755.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_754 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*m).ktype = get(args, tmp___1 as *mut Int as var);
    __constr_expr_756.val = 1 as libc::c_int as int64_t;
    __constr_expr_757[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_757[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(__constr_expr_757.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___4 = memcpy(
        tmp___3 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_756 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    (*m).vtype = get(args, tmp___4 as *mut Int as var);
    (*m).ksize = size((*m).ktype);
    (*m).vsize = size((*m).vtype);
    (*m).nitems = 0 as libc::c_int as size_t;
    (*m).root = 0 as *mut libc::c_void;
    tmp___5 = len(args);
    nargs = tmp___5;
    if nargs.wrapping_rem(2 as libc::c_ulong) != 0 as libc::c_ulong {
        __constr_expr_759[0 as libc::c_int as usize] = Terminal;
        __constr_expr_758.items = __constr_expr_759.as_mut_ptr();
        __constr_expr_760[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_760[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_760.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_758 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Received non multiple of two argument count to Tree constructor.\0"
                as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    i = 0 as libc::c_int as size_t;
    while i < nargs.wrapping_sub(2 as libc::c_ulong).wrapping_div(2 as libc::c_ulong) {
        __constr_expr_761
            .val = (2 as libc::c_ulong).wrapping_add(i.wrapping_mul(2 as libc::c_ulong))
            as int64_t;
        __constr_expr_762[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = 1 as libc::c_uint;
        while !(tmp___9 >= 32 as libc::c_uint) {
            __constr_expr_762[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___9 = tmp___9.wrapping_add(1);
        }
        tmp___10 = header_init(
            __constr_expr_762.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___11 = memcpy(
            tmp___10 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_761 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___12 = get(args, tmp___11 as *mut Int as var);
        key = tmp___12;
        __constr_expr_763
            .val = (2 as libc::c_ulong)
            .wrapping_add(i.wrapping_mul(2 as libc::c_ulong))
            .wrapping_add(1 as libc::c_ulong) as int64_t;
        __constr_expr_764[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___13 = 1 as libc::c_uint;
        while !(tmp___13 >= 32 as libc::c_uint) {
            __constr_expr_764[tmp___13 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___13 = tmp___13.wrapping_add(1);
        }
        tmp___14 = header_init(
            __constr_expr_764.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___15 = memcpy(
            tmp___14 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_763 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___16 = get(args, tmp___15 as *mut Int as var);
        val = tmp___16;
        Tree_Set(m as var, key, val);
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn Tree_Clear_Entry(mut m: *mut Tree, mut node: var) {
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    if node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = Tree_Left(m, node);
        Tree_Clear_Entry(m, *tmp);
        tmp___0 = Tree_Right(m, node);
        Tree_Clear_Entry(m, *tmp___0);
        tmp___1 = Tree_Key(m, node);
        destruct(tmp___1);
        tmp___2 = Tree_Val(m, node);
        destruct(tmp___2);
        free(node);
    }
}
unsafe extern "C" fn Tree_Clear(mut self_0: var) {
    let mut m: *mut Tree = 0 as *mut Tree;
    m = self_0 as *mut Tree;
    Tree_Clear_Entry(m, (*m).root);
    (*m).nitems = 0 as libc::c_int as size_t;
    (*m).root = 0 as *mut libc::c_void;
}
unsafe extern "C" fn Tree_Del(mut self_0: var) {
    let mut m: *mut Tree = 0 as *mut Tree;
    m = self_0 as *mut Tree;
    Tree_Clear(self_0);
}
unsafe extern "C" fn Tree_Assign(mut self_0: var, mut obj: var) {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: bool = false;
    let mut __key: var = 0 as *mut libc::c_void;
    let mut __Iterkey: var = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut key: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    Tree_Clear(self_0);
    tmp___1 = implements_method_at_offset(
        obj,
        Get,
        &mut (*(0 as *mut Get)).key_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
    );
    if tmp___1 {
        tmp___0 = key_type(obj);
        (*m).ktype = tmp___0;
    } else {
        (*m).ktype = Ref;
    }
    tmp___4 = implements_method_at_offset(
        obj,
        Get,
        &mut (*(0 as *mut Get)).val_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
    );
    if tmp___4 {
        tmp___3 = val_type(obj);
        (*m).vtype = tmp___3;
    } else {
        (*m).vtype = Ref;
    }
    (*m).ksize = size((*m).ktype);
    (*m).vsize = size((*m).vtype);
    __key = obj;
    tmp___5 = instance(__key, Iter);
    __Iterkey = tmp___5;
    tmp___6 = (Some(
        ((*(__Iterkey as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__key);
    key = tmp___6;
    while key as libc::c_ulong != Terminal as libc::c_ulong {
        tmp___7 = get(obj, key);
        Tree_Set(self_0, key, tmp___7);
        key = (Some(
            ((*(__Iterkey as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__key, key);
    }
}
unsafe extern "C" fn Tree_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut item0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item1: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    tmp = Tree_Iter_Init(self_0);
    item0 = tmp;
    tmp___0 = iter_init(obj);
    item1 = tmp___0;
    loop {
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            if item1 as libc::c_ulong == Terminal as libc::c_ulong {
                return 0 as libc::c_int;
            }
        }
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if item1 as libc::c_ulong == Terminal as libc::c_ulong {
            return 1 as libc::c_int;
        }
        c = cmp(item0, item1);
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        tmp___1 = get(obj, item1);
        tmp___2 = Tree_Get(self_0, item0);
        c = cmp(tmp___2, tmp___1);
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        item0 = Tree_Iter_Next(self_0, item0);
        item1 = iter_next(obj, item1);
    };
}
unsafe extern "C" fn Tree_Hash(mut self_0: var) -> uint64_t {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut h: uint64_t = 0;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut node: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: uint64_t = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: uint64_t = 0;
    m = self_0 as *mut Tree;
    h = 0 as libc::c_int as uint64_t;
    tmp = Tree_Iter_Init(self_0);
    curr = tmp;
    while curr as libc::c_ulong != Terminal as libc::c_ulong {
        node = (curr as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            .offset(
                -((3 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
                    as isize),
            ) as var;
        tmp___0 = Tree_Key(m, node);
        tmp___1 = hash(tmp___0);
        tmp___2 = Tree_Val(m, node);
        tmp___3 = hash(tmp___2);
        h = h ^ tmp___1 ^ tmp___3;
        curr = Tree_Iter_Next(self_0, curr);
    }
    return h;
}
unsafe extern "C" fn Tree_Len(mut self_0: var) -> size_t {
    let mut m: *mut Tree = 0 as *mut Tree;
    m = self_0 as *mut Tree;
    return (*m).nitems;
}
unsafe extern "C" fn Tree_Mem(mut self_0: var, mut key: var) -> bool {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    m = self_0 as *mut Tree;
    key = cast(key, (*m).ktype);
    node = (*m).root;
    while node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = Tree_Key(m, node);
        tmp___0 = cmp(tmp, key);
        c = tmp___0;
        if c == 0 as libc::c_int {
            return 1 as libc::c_int != 0;
        }
        if c < 0 as libc::c_int {
            tmp___1 = Tree_Left(m, node);
            node = *tmp___1;
        } else {
            tmp___2 = Tree_Right(m, node);
            node = *tmp___2;
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Tree_Get(mut self_0: var, mut key: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: *mut var = 0 as *mut var;
    let mut __constr_expr_765: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_766: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_767: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    key = cast(key, (*m).ktype);
    node = (*m).root;
    while node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = Tree_Key(m, node);
        tmp___0 = cmp(tmp, key);
        c = tmp___0;
        if c == 0 as libc::c_int {
            tmp___1 = Tree_Val(m, node);
            return tmp___1;
        }
        if c < 0 as libc::c_int {
            tmp___2 = Tree_Left(m, node);
            node = *tmp___2;
        } else {
            tmp___3 = Tree_Right(m, node);
            node = *tmp___3;
        }
    }
    __constr_expr_766[0 as libc::c_int as usize] = key;
    __constr_expr_766[1 as libc::c_int as usize] = Terminal;
    __constr_expr_765.items = __constr_expr_766.as_mut_ptr();
    __constr_expr_767[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___4 = 1 as libc::c_uint;
    while !(tmp___4 >= 32 as libc::c_uint) {
        __constr_expr_767[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = tmp___4.wrapping_add(1);
    }
    tmp___5 = header_init(
        __constr_expr_767.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___6 = memcpy(
        tmp___5 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_765 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___7 = exception_throw(
        KeyError,
        b"Key %$ not in Tree!\0" as *const u8 as *const libc::c_char,
        tmp___6 as *mut Tuple as var,
    );
    return tmp___7;
}
unsafe extern "C" fn Tree_Key_Type(mut self_0: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    m = self_0 as *mut Tree;
    return (*m).ktype;
}
unsafe extern "C" fn Tree_Val_Type(mut self_0: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    m = self_0 as *mut Tree;
    return (*m).vtype;
}
unsafe extern "C" fn Tree_Maximum(mut m: *mut Tree, mut node: var) -> var {
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    loop {
        tmp___0 = Tree_Right(m, node);
        if !(*tmp___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        tmp = Tree_Right(m, node);
        node = *tmp;
    }
    return node;
}
unsafe extern "C" fn Tree_Sibling(mut m: *mut Tree, mut node: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut var = 0 as *mut var;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut var = 0 as *mut var;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void
    } else {
        tmp = Tree_Get_Parent(m, node);
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return 0 as *mut libc::c_void;
        }
    }
    tmp___4 = Tree_Get_Parent(m, node);
    tmp___5 = Tree_Left(m, tmp___4);
    if node as libc::c_ulong == *tmp___5 as libc::c_ulong {
        tmp___0 = Tree_Get_Parent(m, node);
        tmp___1 = Tree_Right(m, tmp___0);
        return *tmp___1;
    } else {
        tmp___2 = Tree_Get_Parent(m, node);
        tmp___3 = Tree_Left(m, tmp___2);
        return *tmp___3;
    };
}
unsafe extern "C" fn Tree_Grandparent(mut m: *mut Tree, mut node: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    if node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___1 = Tree_Get_Parent(m, node);
        if tmp___1 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp = Tree_Get_Parent(m, node);
            tmp___0 = Tree_Get_Parent(m, tmp);
            return tmp___0;
        } else {
            return 0 as *mut libc::c_void
        }
    } else {
        return 0 as *mut libc::c_void
    };
}
unsafe extern "C" fn Tree_Uncle(mut m: *mut Tree, mut node: var) -> var {
    let mut gpar: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut var = 0 as *mut var;
    tmp = Tree_Grandparent(m, node);
    gpar = tmp;
    if gpar as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void;
    }
    tmp___2 = Tree_Get_Parent(m, node);
    tmp___3 = Tree_Left(m, gpar);
    if tmp___2 as libc::c_ulong == *tmp___3 as libc::c_ulong {
        tmp___0 = Tree_Right(m, gpar);
        return *tmp___0;
    } else {
        tmp___1 = Tree_Left(m, gpar);
        return *tmp___1;
    };
}
pub unsafe extern "C" fn Tree_Replace(mut m: *mut Tree, mut oldn: var, mut newn: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut var = 0 as *mut var;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    tmp___5 = Tree_Get_Parent(m, oldn);
    if tmp___5 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*m).root = newn;
    } else {
        tmp___3 = Tree_Get_Parent(m, oldn);
        tmp___4 = Tree_Left(m, tmp___3);
        if oldn as libc::c_ulong == *tmp___4 as libc::c_ulong {
            tmp = Tree_Get_Parent(m, oldn);
            tmp___0 = Tree_Left(m, tmp);
            *tmp___0 = newn;
        } else {
            tmp___1 = Tree_Get_Parent(m, oldn);
            tmp___2 = Tree_Right(m, tmp___1);
            *tmp___2 = newn;
        }
    }
    if newn as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___6 = Tree_Get_Parent(m, oldn);
        Tree_Set_Parent(m, newn, tmp___6);
    }
}
unsafe extern "C" fn Tree_Rotate_Left(mut m: *mut Tree, mut node: var) {
    let mut r: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: *mut var = 0 as *mut var;
    let mut tmp___4: *mut var = 0 as *mut var;
    tmp = Tree_Right(m, node);
    r = *tmp;
    Tree_Replace(m, node, r);
    tmp___0 = Tree_Right(m, node);
    tmp___1 = Tree_Left(m, r);
    *tmp___0 = *tmp___1;
    tmp___3 = Tree_Left(m, r);
    if *tmp___3 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = Tree_Left(m, r);
        Tree_Set_Parent(m, *tmp___2, node);
    }
    tmp___4 = Tree_Left(m, r);
    *tmp___4 = node;
    Tree_Set_Parent(m, node, r);
}
unsafe extern "C" fn Tree_Rotate_Right(mut m: *mut Tree, mut node: var) {
    let mut l: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: *mut var = 0 as *mut var;
    let mut tmp___4: *mut var = 0 as *mut var;
    tmp = Tree_Left(m, node);
    l = *tmp;
    Tree_Replace(m, node, l);
    tmp___0 = Tree_Left(m, node);
    tmp___1 = Tree_Right(m, l);
    *tmp___0 = *tmp___1;
    tmp___3 = Tree_Right(m, l);
    if *tmp___3 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = Tree_Right(m, l);
        Tree_Set_Parent(m, *tmp___2, node);
    }
    tmp___4 = Tree_Right(m, l);
    *tmp___4 = node;
    Tree_Set_Parent(m, node, l);
}
unsafe extern "C" fn Tree_Set_Fix(mut m: *mut Tree, mut node: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: bool = false;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut var = 0 as *mut var;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut var = 0 as *mut var;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut var = 0 as *mut var;
    let mut tmp___14: var = 0 as *mut libc::c_void;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut var = 0 as *mut var;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut tmp___18: *mut var = 0 as *mut var;
    let mut tmp___19: var = 0 as *mut libc::c_void;
    let mut tmp___20: var = 0 as *mut libc::c_void;
    let mut tmp___21: *mut var = 0 as *mut var;
    let mut tmp___22: var = 0 as *mut libc::c_void;
    let mut tmp___23: var = 0 as *mut libc::c_void;
    let mut tmp___24: var = 0 as *mut libc::c_void;
    let mut tmp___25: var = 0 as *mut libc::c_void;
    let mut tmp___26: var = 0 as *mut libc::c_void;
    let mut tmp___27: *mut var = 0 as *mut var;
    loop {
        tmp = Tree_Get_Parent(m, node);
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            Tree_Set_Black(m, node);
            return;
        }
        tmp___0 = Tree_Get_Parent(m, node);
        tmp___1 = Tree_Is_Black(m, tmp___0);
        if tmp___1 {
            return;
        }
        tmp___5 = Tree_Uncle(m, node);
        if tmp___5 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___6 = Tree_Uncle(m, node);
            tmp___7 = Tree_Is_Red(m, tmp___6);
            if tmp___7 {
                tmp___2 = Tree_Get_Parent(m, node);
                Tree_Set_Black(m, tmp___2);
                tmp___3 = Tree_Uncle(m, node);
                Tree_Set_Black(m, tmp___3);
                tmp___4 = Tree_Grandparent(m, node);
                Tree_Set_Red(m, tmp___4);
                node = Tree_Grandparent(m, node);
                continue;
            }
        }
        tmp___17 = Tree_Get_Parent(m, node);
        tmp___18 = Tree_Right(m, tmp___17);
        let mut current_block_42: u64;
        if node as libc::c_ulong == *tmp___18 as libc::c_ulong {
            tmp___19 = Tree_Get_Parent(m, node);
            tmp___20 = Tree_Grandparent(m, node);
            tmp___21 = Tree_Left(m, tmp___20);
            if tmp___19 as libc::c_ulong == *tmp___21 as libc::c_ulong {
                tmp___8 = Tree_Get_Parent(m, node);
                Tree_Rotate_Left(m, tmp___8);
                tmp___9 = Tree_Left(m, node);
                node = *tmp___9;
                current_block_42 = 3160140712158701372;
            } else {
                current_block_42 = 6802312254456459861;
            }
        } else {
            current_block_42 = 6802312254456459861;
        }
        match current_block_42 {
            6802312254456459861 => {
                tmp___12 = Tree_Get_Parent(m, node);
                tmp___13 = Tree_Left(m, tmp___12);
                if node as libc::c_ulong == *tmp___13 as libc::c_ulong {
                    tmp___14 = Tree_Get_Parent(m, node);
                    tmp___15 = Tree_Grandparent(m, node);
                    tmp___16 = Tree_Right(m, tmp___15);
                    if tmp___14 as libc::c_ulong == *tmp___16 as libc::c_ulong {
                        tmp___10 = Tree_Get_Parent(m, node);
                        Tree_Rotate_Right(m, tmp___10);
                        tmp___11 = Tree_Right(m, node);
                        node = *tmp___11;
                    }
                }
            }
            _ => {}
        }
        tmp___22 = Tree_Get_Parent(m, node);
        Tree_Set_Black(m, tmp___22);
        tmp___23 = Tree_Grandparent(m, node);
        Tree_Set_Red(m, tmp___23);
        tmp___26 = Tree_Get_Parent(m, node);
        tmp___27 = Tree_Left(m, tmp___26);
        if node as libc::c_ulong == *tmp___27 as libc::c_ulong {
            tmp___24 = Tree_Grandparent(m, node);
            Tree_Rotate_Right(m, tmp___24);
        } else {
            tmp___25 = Tree_Grandparent(m, node);
            Tree_Rotate_Left(m, tmp___25);
        }
        return;
    };
}
unsafe extern "C" fn Tree_Set(mut self_0: var, mut key: var, mut val: var) {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut node___0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut newn: var = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut var = 0 as *mut var;
    let mut tmp___10: *mut var = 0 as *mut var;
    let mut tmp___11: *mut var = 0 as *mut var;
    let mut newn___0: var = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: var = 0 as *mut libc::c_void;
    let mut tmp___15: *mut var = 0 as *mut var;
    let mut tmp___16: *mut var = 0 as *mut var;
    let mut tmp___17: *mut var = 0 as *mut var;
    m = self_0 as *mut Tree;
    key = cast(key, (*m).ktype);
    val = cast(val, (*m).vtype);
    node = (*m).root;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp = Tree_Alloc(m);
        node___0 = tmp;
        tmp___0 = Tree_Key(m, node___0);
        assign(tmp___0, key);
        tmp___1 = Tree_Val(m, node___0);
        assign(tmp___1, val);
        (*m).root = node___0;
        (*m).nitems = ((*m).nitems).wrapping_add(1);
        Tree_Set_Fix(m, node___0);
        return;
    }
    loop {
        tmp___2 = Tree_Key(m, node);
        tmp___3 = cmp(tmp___2, key);
        c = tmp___3;
        if c == 0 as libc::c_int {
            tmp___4 = Tree_Key(m, node);
            assign(tmp___4, key);
            tmp___5 = Tree_Val(m, node);
            assign(tmp___5, val);
            return;
        }
        if c < 0 as libc::c_int {
            tmp___10 = Tree_Left(m, node);
            if *tmp___10 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___6 = Tree_Alloc(m);
                newn = tmp___6;
                tmp___7 = Tree_Key(m, newn);
                assign(tmp___7, key);
                tmp___8 = Tree_Val(m, newn);
                assign(tmp___8, val);
                tmp___9 = Tree_Left(m, node);
                *tmp___9 = newn;
                Tree_Set_Parent(m, newn, node);
                Tree_Set_Fix(m, newn);
                (*m).nitems = ((*m).nitems).wrapping_add(1);
                return;
            }
            tmp___11 = Tree_Left(m, node);
            node = *tmp___11;
        }
        if c > 0 as libc::c_int {
            tmp___16 = Tree_Right(m, node);
            if *tmp___16 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___12 = Tree_Alloc(m);
                newn___0 = tmp___12;
                tmp___13 = Tree_Key(m, newn___0);
                assign(tmp___13, key);
                tmp___14 = Tree_Val(m, newn___0);
                assign(tmp___14, val);
                tmp___15 = Tree_Right(m, node);
                *tmp___15 = newn___0;
                Tree_Set_Parent(m, newn___0, node);
                Tree_Set_Fix(m, newn___0);
                (*m).nitems = ((*m).nitems).wrapping_add(1);
                return;
            }
            tmp___17 = Tree_Right(m, node);
            node = *tmp___17;
        }
    };
}
unsafe extern "C" fn Tree_Rem_Fix(mut m: *mut Tree, mut node: var) {
    let mut current_block: u64;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut var = 0 as *mut var;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: bool = false;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: bool = false;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: bool = false;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: *mut var = 0 as *mut var;
    let mut tmp___15: bool = false;
    let mut tmp___16: var = 0 as *mut libc::c_void;
    let mut tmp___17: *mut var = 0 as *mut var;
    let mut tmp___18: bool = false;
    let mut tmp___19: var = 0 as *mut libc::c_void;
    let mut tmp___20: var = 0 as *mut libc::c_void;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: bool = false;
    let mut tmp___23: var = 0 as *mut libc::c_void;
    let mut tmp___24: bool = false;
    let mut tmp___25: var = 0 as *mut libc::c_void;
    let mut tmp___26: *mut var = 0 as *mut var;
    let mut tmp___27: bool = false;
    let mut tmp___28: var = 0 as *mut libc::c_void;
    let mut tmp___29: *mut var = 0 as *mut var;
    let mut tmp___30: bool = false;
    let mut tmp___31: var = 0 as *mut libc::c_void;
    let mut tmp___32: var = 0 as *mut libc::c_void;
    let mut tmp___33: *mut var = 0 as *mut var;
    let mut tmp___34: var = 0 as *mut libc::c_void;
    let mut tmp___35: var = 0 as *mut libc::c_void;
    let mut tmp___36: var = 0 as *mut libc::c_void;
    let mut tmp___37: *mut var = 0 as *mut var;
    let mut tmp___38: var = 0 as *mut libc::c_void;
    let mut tmp___39: var = 0 as *mut libc::c_void;
    let mut tmp___40: *mut var = 0 as *mut var;
    let mut tmp___41: var = 0 as *mut libc::c_void;
    let mut tmp___42: *mut var = 0 as *mut var;
    let mut tmp___43: bool = false;
    let mut tmp___44: var = 0 as *mut libc::c_void;
    let mut tmp___45: *mut var = 0 as *mut var;
    let mut tmp___46: bool = false;
    let mut tmp___47: var = 0 as *mut libc::c_void;
    let mut tmp___48: *mut var = 0 as *mut var;
    let mut tmp___49: var = 0 as *mut libc::c_void;
    let mut tmp___50: *mut var = 0 as *mut var;
    let mut tmp___51: bool = false;
    let mut tmp___52: var = 0 as *mut libc::c_void;
    let mut tmp___53: *mut var = 0 as *mut var;
    let mut tmp___54: bool = false;
    let mut tmp___55: var = 0 as *mut libc::c_void;
    let mut tmp___56: bool = false;
    let mut tmp___57: var = 0 as *mut libc::c_void;
    let mut tmp___58: bool = false;
    let mut tmp___59: var = 0 as *mut libc::c_void;
    let mut tmp___60: var = 0 as *mut libc::c_void;
    let mut tmp___61: var = 0 as *mut libc::c_void;
    let mut tmp___62: *mut var = 0 as *mut var;
    let mut tmp___63: var = 0 as *mut libc::c_void;
    let mut tmp___64: var = 0 as *mut libc::c_void;
    let mut tmp___65: *mut var = 0 as *mut var;
    let mut tmp___66: var = 0 as *mut libc::c_void;
    let mut tmp___67: var = 0 as *mut libc::c_void;
    let mut tmp___68: *mut var = 0 as *mut var;
    loop {
        tmp = Tree_Get_Parent(m, node);
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return;
        }
        tmp___6 = Tree_Sibling(m, node);
        tmp___7 = Tree_Is_Red(m, tmp___6);
        if tmp___7 {
            tmp___0 = Tree_Get_Parent(m, node);
            Tree_Set_Red(m, tmp___0);
            tmp___1 = Tree_Sibling(m, node);
            Tree_Set_Black(m, tmp___1);
            tmp___4 = Tree_Get_Parent(m, node);
            tmp___5 = Tree_Left(m, tmp___4);
            if node as libc::c_ulong == *tmp___5 as libc::c_ulong {
                tmp___2 = Tree_Get_Parent(m, node);
                Tree_Rotate_Left(m, tmp___2);
            } else {
                tmp___3 = Tree_Get_Parent(m, node);
                Tree_Rotate_Right(m, tmp___3);
            }
        }
        tmp___9 = Tree_Get_Parent(m, node);
        tmp___10 = Tree_Is_Black(m, tmp___9);
        if tmp___10 {
            tmp___11 = Tree_Sibling(m, node);
            tmp___12 = Tree_Is_Black(m, tmp___11);
            if tmp___12 {
                tmp___13 = Tree_Sibling(m, node);
                tmp___14 = Tree_Left(m, tmp___13);
                tmp___15 = Tree_Is_Black(m, *tmp___14);
                if tmp___15 {
                    tmp___16 = Tree_Sibling(m, node);
                    tmp___17 = Tree_Right(m, tmp___16);
                    tmp___18 = Tree_Is_Black(m, *tmp___17);
                    if tmp___18 {
                        tmp___8 = Tree_Sibling(m, node);
                        Tree_Set_Red(m, tmp___8);
                        node = Tree_Get_Parent(m, node);
                        continue;
                    }
                }
            }
        }
        tmp___21 = Tree_Get_Parent(m, node);
        tmp___22 = Tree_Is_Red(m, tmp___21);
        if tmp___22 {
            tmp___23 = Tree_Sibling(m, node);
            tmp___24 = Tree_Is_Black(m, tmp___23);
            if tmp___24 {
                tmp___25 = Tree_Sibling(m, node);
                tmp___26 = Tree_Left(m, tmp___25);
                tmp___27 = Tree_Is_Black(m, *tmp___26);
                if tmp___27 {
                    tmp___28 = Tree_Sibling(m, node);
                    tmp___29 = Tree_Right(m, tmp___28);
                    tmp___30 = Tree_Is_Black(m, *tmp___29);
                    if tmp___30 {
                        tmp___19 = Tree_Sibling(m, node);
                        Tree_Set_Red(m, tmp___19);
                        tmp___20 = Tree_Get_Parent(m, node);
                        Tree_Set_Black(m, tmp___20);
                        return;
                    }
                }
            }
        }
        tmp___55 = Tree_Sibling(m, node);
        tmp___56 = Tree_Is_Black(m, tmp___55);
        if tmp___56 {
            tmp___47 = Tree_Get_Parent(m, node);
            tmp___48 = Tree_Left(m, tmp___47);
            if node as libc::c_ulong == *tmp___48 as libc::c_ulong {
                tmp___49 = Tree_Sibling(m, node);
                tmp___50 = Tree_Left(m, tmp___49);
                tmp___51 = Tree_Is_Red(m, *tmp___50);
                if tmp___51 {
                    tmp___52 = Tree_Sibling(m, node);
                    tmp___53 = Tree_Right(m, tmp___52);
                    tmp___54 = Tree_Is_Black(m, *tmp___53);
                    if tmp___54 {
                        tmp___31 = Tree_Sibling(m, node);
                        Tree_Set_Red(m, tmp___31);
                        tmp___32 = Tree_Sibling(m, node);
                        tmp___33 = Tree_Left(m, tmp___32);
                        Tree_Set_Black(m, *tmp___33);
                        tmp___34 = Tree_Sibling(m, node);
                        Tree_Rotate_Right(m, tmp___34);
                        current_block = 14155412868135599428;
                    } else {
                        current_block = 11207273645145225353;
                    }
                } else {
                    current_block = 11207273645145225353;
                }
            } else {
                current_block = 11207273645145225353;
            }
            match current_block {
                14155412868135599428 => {}
                _ => {
                    tmp___39 = Tree_Get_Parent(m, node);
                    tmp___40 = Tree_Right(m, tmp___39);
                    if node as libc::c_ulong == *tmp___40 as libc::c_ulong {
                        tmp___41 = Tree_Sibling(m, node);
                        tmp___42 = Tree_Right(m, tmp___41);
                        tmp___43 = Tree_Is_Red(m, *tmp___42);
                        if tmp___43 {
                            tmp___44 = Tree_Sibling(m, node);
                            tmp___45 = Tree_Left(m, tmp___44);
                            tmp___46 = Tree_Is_Black(m, *tmp___45);
                            if tmp___46 {
                                tmp___35 = Tree_Sibling(m, node);
                                Tree_Set_Red(m, tmp___35);
                                tmp___36 = Tree_Sibling(m, node);
                                tmp___37 = Tree_Right(m, tmp___36);
                                Tree_Set_Black(m, *tmp___37);
                                tmp___38 = Tree_Sibling(m, node);
                                Tree_Rotate_Left(m, tmp___38);
                            }
                        }
                    }
                }
            }
        }
        tmp___57 = Tree_Get_Parent(m, node);
        tmp___58 = Tree_Get_Color(m, tmp___57);
        tmp___59 = Tree_Sibling(m, node);
        Tree_Set_Color(m, tmp___59, tmp___58);
        tmp___60 = Tree_Get_Parent(m, node);
        Tree_Set_Black(m, tmp___60);
        tmp___67 = Tree_Get_Parent(m, node);
        tmp___68 = Tree_Left(m, tmp___67);
        if node as libc::c_ulong == *tmp___68 as libc::c_ulong {
            tmp___61 = Tree_Sibling(m, node);
            tmp___62 = Tree_Right(m, tmp___61);
            Tree_Set_Black(m, *tmp___62);
            tmp___63 = Tree_Get_Parent(m, node);
            Tree_Rotate_Left(m, tmp___63);
        } else {
            tmp___64 = Tree_Sibling(m, node);
            tmp___65 = Tree_Left(m, tmp___64);
            Tree_Set_Black(m, *tmp___65);
            tmp___66 = Tree_Get_Parent(m, node);
            Tree_Rotate_Right(m, tmp___66);
        }
        return;
    };
}
unsafe extern "C" fn Tree_Rem(mut self_0: var, mut key: var) {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut found: bool = false;
    let mut node: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut __constr_expr_768: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_769: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_770: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut pred: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut var = 0 as *mut var;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut ncol: bool = false;
    let mut tmp___10: bool = false;
    let mut tmp___11: *mut var = 0 as *mut var;
    let mut tmp___12: *mut var = 0 as *mut var;
    let mut chld: var = 0 as *mut libc::c_void;
    let mut tmp___14: *mut var = 0 as *mut var;
    let mut tmp___15: *mut var = 0 as *mut var;
    let mut tmp___16: var = 0 as *mut libc::c_void;
    let mut tmp___17: *mut var = 0 as *mut var;
    let mut tmp___18: bool = false;
    let mut tmp___19: bool = false;
    let mut tmp___20: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    key = cast(key, (*m).ktype);
    found = 0 as libc::c_int != 0;
    node = (*m).root;
    while node as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = Tree_Key(m, node);
        tmp___0 = cmp(tmp, key);
        c = tmp___0;
        if c == 0 as libc::c_int {
            found = 1 as libc::c_int != 0;
            break;
        } else if c < 0 as libc::c_int {
            tmp___1 = Tree_Left(m, node);
            node = *tmp___1;
        } else {
            tmp___2 = Tree_Right(m, node);
            node = *tmp___2;
        }
    }
    if !found {
        __constr_expr_769[0 as libc::c_int as usize] = key;
        __constr_expr_769[1 as libc::c_int as usize] = Terminal;
        __constr_expr_768.items = __constr_expr_769.as_mut_ptr();
        __constr_expr_770[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_770[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_770.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_768 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            KeyError,
            b"Key %$ not in Tree!\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        return;
    }
    tmp___6 = Tree_Key(m, node);
    destruct(tmp___6);
    tmp___7 = Tree_Val(m, node);
    destruct(tmp___7);
    tmp___11 = Tree_Left(m, node);
    if *tmp___11 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___12 = Tree_Right(m, node);
        if *tmp___12 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___8 = Tree_Left(m, node);
            tmp___9 = Tree_Maximum(m, *tmp___8);
            pred = tmp___9;
            tmp___10 = Tree_Get_Color(m, node);
            ncol = tmp___10;
            memcpy(
                (node as *mut libc::c_char)
                    .offset(
                        (3 as libc::c_ulong)
                            .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
                            as isize,
                    ) as *mut libc::c_void,
                (pred as *mut libc::c_char)
                    .offset(
                        (3 as libc::c_ulong)
                            .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
                            as isize,
                    ) as *const libc::c_void,
                (::std::mem::size_of::<Header>() as libc::c_ulong)
                    .wrapping_add((*m).ksize)
                    .wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong)
                    .wrapping_add((*m).vsize),
            );
            Tree_Set_Color(m, node, ncol);
            node = pred;
        }
    }
    tmp___17 = Tree_Right(m, node);
    if *tmp___17 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___14 = Tree_Left(m, node);
        tmp___16 = *tmp___14;
    } else {
        tmp___15 = Tree_Right(m, node);
        tmp___16 = *tmp___15;
    }
    chld = tmp___16;
    tmp___19 = Tree_Is_Black(m, node);
    if tmp___19 {
        tmp___18 = Tree_Get_Color(m, chld);
        Tree_Set_Color(m, node, tmp___18);
        Tree_Rem_Fix(m, node);
    }
    Tree_Replace(m, node, chld);
    tmp___20 = Tree_Get_Parent(m, node);
    if tmp___20 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if chld as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            Tree_Set_Black(m, chld);
        }
    }
    (*m).nitems = ((*m).nitems).wrapping_sub(1);
    free(node);
}
unsafe extern "C" fn Tree_Iter_Init(mut self_0: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    if (*m).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    node = (*m).root;
    loop {
        tmp___0 = Tree_Left(m, node);
        if !(*tmp___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        tmp = Tree_Left(m, node);
        node = *tmp;
    }
    tmp___1 = Tree_Key(m, node);
    return tmp___1;
}
unsafe extern "C" fn Tree_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut prnt: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut var = 0 as *mut var;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut var = 0 as *mut var;
    let mut tmp___7: *mut var = 0 as *mut var;
    m = self_0 as *mut Tree;
    node = (curr as *mut libc::c_char)
        .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
        .offset(
            -((3 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize),
        ) as var;
    tmp = Tree_Get_Parent(m, node);
    prnt = tmp;
    tmp___4 = Tree_Right(m, node);
    if *tmp___4 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = Tree_Right(m, node);
        node = *tmp___0;
        loop {
            tmp___2 = Tree_Left(m, node);
            if !(*tmp___2 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                break;
            }
            tmp___1 = Tree_Left(m, node);
            node = *tmp___1;
        }
        tmp___3 = Tree_Key(m, node);
        return tmp___3;
    }
    loop {
        if prnt as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return Terminal;
        }
        tmp___6 = Tree_Left(m, prnt);
        if node as libc::c_ulong == *tmp___6 as libc::c_ulong {
            tmp___5 = Tree_Key(m, prnt);
            return tmp___5;
        }
        tmp___7 = Tree_Right(m, prnt);
        if node as libc::c_ulong == *tmp___7 as libc::c_ulong {
            prnt = Tree_Get_Parent(m, prnt);
            node = Tree_Get_Parent(m, node);
        }
    };
}
unsafe extern "C" fn Tree_Iter_Last(mut self_0: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut tmp: *mut var = 0 as *mut var;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    if (*m).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    node = (*m).root;
    loop {
        tmp___0 = Tree_Right(m, node);
        if !(*tmp___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
        tmp = Tree_Right(m, node);
        node = *tmp;
    }
    tmp___1 = Tree_Key(m, node);
    return tmp___1;
}
unsafe extern "C" fn Tree_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut node: var = 0 as *mut libc::c_void;
    let mut prnt: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: *mut var = 0 as *mut var;
    let mut tmp___1: *mut var = 0 as *mut var;
    let mut tmp___2: *mut var = 0 as *mut var;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut var = 0 as *mut var;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut var = 0 as *mut var;
    let mut tmp___7: *mut var = 0 as *mut var;
    m = self_0 as *mut Tree;
    node = (curr as *mut libc::c_char)
        .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
        .offset(
            -((3 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong) as isize),
        ) as var;
    tmp = Tree_Get_Parent(m, node);
    prnt = tmp;
    tmp___4 = Tree_Left(m, node);
    if *tmp___4 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = Tree_Left(m, node);
        node = *tmp___0;
        loop {
            tmp___2 = Tree_Right(m, node);
            if !(*tmp___2 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                break;
            }
            tmp___1 = Tree_Right(m, node);
            node = *tmp___1;
        }
        tmp___3 = Tree_Key(m, node);
        return tmp___3;
    }
    loop {
        if prnt as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return Terminal;
        }
        tmp___6 = Tree_Right(m, prnt);
        if node as libc::c_ulong == *tmp___6 as libc::c_ulong {
            tmp___5 = Tree_Key(m, prnt);
            return tmp___5;
        }
        tmp___7 = Tree_Left(m, prnt);
        if node as libc::c_ulong == *tmp___7 as libc::c_ulong {
            prnt = Tree_Get_Parent(m, prnt);
            node = Tree_Get_Parent(m, node);
        }
    };
}
unsafe extern "C" fn Tree_Iter_Type(mut self_0: var) -> var {
    let mut m: *mut Tree = 0 as *mut Tree;
    m = self_0 as *mut Tree;
    return (*m).ktype;
}
unsafe extern "C" fn Tree_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut __constr_expr_771: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_772: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_773: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut node: var = 0 as *mut libc::c_void;
    let mut __constr_expr_774: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_775: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut __constr_expr_776: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_777: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_778: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_779: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_780: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_781: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_782: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: libc::c_int = 0;
    m = self_0 as *mut Tree;
    __constr_expr_772[0 as libc::c_int as usize] = self_0;
    __constr_expr_772[1 as libc::c_int as usize] = Terminal;
    __constr_expr_771.items = __constr_expr_772.as_mut_ptr();
    __constr_expr_773[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_773[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_773.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_771 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"<'Tree' At 0x%p {\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    tmp___2 = Tree_Iter_Init(self_0);
    curr = tmp___2;
    while curr as libc::c_ulong != Terminal as libc::c_ulong {
        node = (curr as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            .offset(
                -((3 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
                    as isize),
            ) as var;
        tmp___3 = Tree_Key(m, node);
        tmp___4 = Tree_Val(m, node);
        __constr_expr_775[0 as libc::c_int as usize] = tmp___3;
        __constr_expr_775[1 as libc::c_int as usize] = tmp___4;
        __constr_expr_775[2 as libc::c_int as usize] = Terminal;
        __constr_expr_774.items = __constr_expr_775.as_mut_ptr();
        __constr_expr_776[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_776[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_776.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_774 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            output,
            pos,
            b"%$:%$\0" as *const u8 as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
        curr = Tree_Iter_Next(self_0, curr);
        if curr as libc::c_ulong != Terminal as libc::c_ulong {
            __constr_expr_778[0 as libc::c_int as usize] = Terminal;
            __constr_expr_777.items = __constr_expr_778.as_mut_ptr();
            __constr_expr_779[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = 1 as libc::c_uint;
            while !(tmp___8 >= 32 as libc::c_uint) {
                __constr_expr_779[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___8 = tmp___8.wrapping_add(1);
            }
            tmp___9 = header_init(
                __constr_expr_779.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___10 = memcpy(
                tmp___9 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_777 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b", \0" as *const u8 as *const libc::c_char,
                tmp___10 as *mut Tuple as var,
            );
        }
    }
    __constr_expr_781[0 as libc::c_int as usize] = Terminal;
    __constr_expr_780.items = __constr_expr_781.as_mut_ptr();
    __constr_expr_782[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___11 = 1 as libc::c_uint;
    while !(tmp___11 >= 32 as libc::c_uint) {
        __constr_expr_782[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___11 = tmp___11.wrapping_add(1);
    }
    tmp___12 = header_init(
        __constr_expr_782.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___13 = memcpy(
        tmp___12 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_780 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___14 = print_to_with(
        output,
        pos,
        b"}>\0" as *const u8 as *const libc::c_char,
        tmp___13 as *mut Tuple as var,
    );
    return tmp___14;
}
unsafe extern "C" fn Tree_Mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut m: *mut Tree = 0 as *mut Tree;
    let mut curr: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut node: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    m = self_0 as *mut Tree;
    tmp = Tree_Iter_Init(self_0);
    curr = tmp;
    while curr as libc::c_ulong != Terminal as libc::c_ulong {
        node = (curr as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            .offset(
                -((3 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong)
                    as isize),
            ) as var;
        tmp___0 = Tree_Key(m, node);
        (Some(f.expect("non-null function pointer")))
            .expect("non-null function pointer")(gc, tmp___0);
        tmp___1 = Tree_Val(m, node);
        (Some(f.expect("non-null function pointer")))
            .expect("non-null function pointer")(gc, tmp___1);
        curr = Tree_Iter_Next(self_0, curr);
    }
}
unsafe extern "C" fn Tree_Resize(mut self_0: var, mut n: size_t) {
    let mut __constr_expr_783: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_784: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_785: Int = Int { val: 0 };
    let mut __constr_expr_786: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_787: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    if n == 0 as libc::c_ulong {
        Tree_Clear(self_0);
    } else {
        __constr_expr_785.val = n as int64_t;
        __constr_expr_786[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_786[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_786.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_785 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_784[0 as libc::c_int as usize] = tmp___1 as *mut Int as var;
        __constr_expr_784[1 as libc::c_int as usize] = Terminal;
        __constr_expr_783.items = __constr_expr_784.as_mut_ptr();
        __constr_expr_787[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_787[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_787.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_783 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            FormatError,
            b"Cannot resize Tree to %li items. Trees can only be resized to 0 items.\0"
                as *const u8 as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
    };
}
static mut __constr_expr_789: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Tree_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Tree_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Tree_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Tree_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_790: New = {
    let mut init = New {
        construct_with: Some(Tree_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Tree_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_791: Assign = {
    let mut init = Assign {
        assign: Some(Tree_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_792: Mark = {
    let mut init = Mark {
        mark: Some(
            Tree_Mark
                as unsafe extern "C" fn(
                    var,
                    var,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_793: Cmp = {
    let mut init = Cmp {
        cmp: Some(Tree_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_794: Hash = {
    let mut init = Hash {
        hash: Some(Tree_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_795: Len = {
    let mut init = Len {
        len: Some(Tree_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_796: Get = {
    let mut init = Get {
        get: Some(Tree_Get as unsafe extern "C" fn(var, var) -> var),
        set: Some(Tree_Set as unsafe extern "C" fn(var, var, var) -> ()),
        mem: Some(Tree_Mem as unsafe extern "C" fn(var, var) -> bool),
        rem: Some(Tree_Rem as unsafe extern "C" fn(var, var) -> ()),
        key_type: Some(Tree_Key_Type as unsafe extern "C" fn(var) -> var),
        val_type: Some(Tree_Val_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_797: Resize = {
    let mut init = Resize {
        resize: Some(Tree_Resize as unsafe extern "C" fn(var, size_t) -> ()),
    };
    init
};
static mut __constr_expr_798: Iter = {
    let mut init = Iter {
        iter_init: Some(Tree_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Tree_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Tree_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Tree_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Tree_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_799: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Tree_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_788: [var; 63] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Tree\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Tree>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_789 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_790 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_791 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_792 as *const Mark as *mut Mark as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_793 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_794 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_795 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_796 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_797 as *const Resize as *mut Resize as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_798 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_799 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Tree: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Cmp_Name() -> *const libc::c_char {
    return b"Cmp\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Cmp_Brief() -> *const libc::c_char {
    return b"Comparison\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Cmp_Description() -> *const libc::c_char {
    return b"The `Cmp` class is used to define comparison between two object values. This class is important as it is used by many data structures to test equality or ordering of objects.\n\nBy default, if passed two objects of the same type, the `Cmp` class will simply compare the raw memory of both objects, using the `Size` class.\n\nTo implement this class a `cmp` function must be provided which returns `< 0` if the first object is _less than_ the second, `> 0` if the first object is _greater than_ the second, and `0` if they are _equal_. \n\nFor objects that manage their own data this class may need to be overridden to ensure that objects of the same _value_ are still treated as equal. E.G. for string types.\n\nThis class to used to test for _value_ equality between objects, I.E. if they represent the same thing. For _object_ equality the `is` keyword can be used, which will return `true` only if two variables are pointing to the same object in memory.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Cmp_Definition() -> *const libc::c_char {
    return b"struct Cmp {\n  int (*cmp)(var, var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___26: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage 1\0" as *const u8 as *const libc::c_char,
            body: b"show($I( eq($I(1), $I( 1)))); /* 1 */\nshow($I(neq($I(2), $I(20)))); /* 1 */\nshow($I(neq($S(\"Hello\"), $S(\"Hello\")))); /* 0 */\nshow($I( eq($S(\"Hello\"), $S(\"There\")))); /* 0 */\n\nvar a = $I(1); var b = $I(1);\n\nshow($I(eq(a, b))); /* 1 */\nshow($I(a is b));   /* 0 */\nshow($I(a isnt b)); /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 2\0" as *const u8 as *const libc::c_char,
            body: b"show($I(gt($I(15), $I(3 )))); /* 1 */\nshow($I(lt($I(70), $I(81)))); /* 1 */\nshow($I(lt($I(71), $I(71)))); /* 0 */\nshow($I(ge($I(78), $I(71)))); /* 1 */\nshow($I(gt($I(32), $I(32)))); /* 0 */\nshow($I(le($I(21), $I(32)))); /* 1 */\n\nshow($I(cmp($I(20), $I(20)))); /*  0 */\nshow($I(cmp($I(21), $I(20)))); /*  1 */\nshow($I(cmp($I(20), $I(21)))); /* -1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Cmp_Examples() -> *mut Example {
    return examples___26.as_mut_ptr();
}
static mut methods___20: [Method; 8] = [
    {
        let mut init = Method {
            name: b"cmp\0" as *const u8 as *const libc::c_char,
            definition: b"int cmp(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"The return value of `cmp` is `< 0` if `self` is less than `obj`, `> 0` if `self` is greater than `obj` and `0` if they are equal.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"eq\0" as *const u8 as *const libc::c_char,
            definition: b"bool eq(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns true if the object `self` is equal to the object `obj`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"neq\0" as *const u8 as *const libc::c_char,
            definition: b"bool neq(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns false if the object `self` is equal to the object `obj`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"gt\0" as *const u8 as *const libc::c_char,
            definition: b"bool gt(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns true if the object `self` is greater than the object `obj`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"lt\0" as *const u8 as *const libc::c_char,
            definition: b"bool lt(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns false if the object `self` is less than the object `obj`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"ge\0" as *const u8 as *const libc::c_char,
            definition: b"bool ge(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns false if the object `self` is greater than or equal to the object `obj`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"le\0" as *const u8 as *const libc::c_char,
            definition: b"bool le(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns false if the object `self` is less than or equal to the object `obj`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Cmp_Methods() -> *mut Method {
    return methods___20.as_mut_ptr();
}
static mut __constr_expr_801: Doc = {
    let mut init = Doc {
        name: Some(Cmp_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Cmp_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Cmp_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Cmp_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Cmp_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Cmp_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_800: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Cmp>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_801 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Cmp: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut c: *mut Cmp = 0 as *mut Cmp;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut s: size_t = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut __constr_expr_802: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_803: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut __constr_expr_804: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = instance(self_0, Cmp);
    c = tmp as *mut Cmp;
    if !c.is_null() {
        if ((*c).cmp).is_some() {
            tmp___0 = (Some(((*c).cmp).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, obj);
            return tmp___0;
        }
    }
    tmp___1 = type_of(self_0);
    tmp___2 = size(tmp___1);
    s = tmp___2;
    tmp___4 = type_of(self_0);
    tmp___5 = type_of(obj);
    if tmp___4 as libc::c_ulong == tmp___5 as libc::c_ulong {
        if s != 0 {
            tmp___3 = memcmp(
                self_0 as *const libc::c_void,
                obj as *const libc::c_void,
                s,
            );
            return tmp___3;
        }
    }
    tmp___6 = type_of(obj);
    tmp___7 = type_of(self_0);
    __constr_expr_803[0 as libc::c_int as usize] = tmp___6;
    __constr_expr_803[1 as libc::c_int as usize] = tmp___7;
    __constr_expr_803[2 as libc::c_int as usize] = Terminal;
    __constr_expr_802.items = __constr_expr_803.as_mut_ptr();
    __constr_expr_804[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___8 = 1 as libc::c_uint;
    while !(tmp___8 >= 32 as libc::c_uint) {
        __constr_expr_804[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___8 = tmp___8.wrapping_add(1);
    }
    tmp___9 = header_init(
        __constr_expr_804.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___10 = memcpy(
        tmp___9 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_802 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    exception_throw(
        TypeError,
        b"Cannot compare type %s to type %s\0" as *const u8 as *const libc::c_char,
        tmp___10 as *mut Tuple as var,
    );
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn eq(mut self_0: var, mut obj: var) -> bool {
    let mut tmp: libc::c_int = 0;
    tmp = cmp(self_0, obj);
    return tmp == 0 as libc::c_int;
}
pub unsafe extern "C" fn neq(mut self_0: var, mut obj: var) -> bool {
    let mut tmp: bool = false;
    let mut tmp___0: libc::c_int = 0;
    tmp = eq(self_0, obj);
    if tmp {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp___0 = 1 as libc::c_int;
    }
    return tmp___0 != 0;
}
pub unsafe extern "C" fn gt(mut self_0: var, mut obj: var) -> bool {
    let mut tmp: libc::c_int = 0;
    tmp = cmp(self_0, obj);
    return tmp > 0 as libc::c_int;
}
pub unsafe extern "C" fn lt(mut self_0: var, mut obj: var) -> bool {
    let mut tmp: libc::c_int = 0;
    tmp = cmp(self_0, obj);
    return tmp < 0 as libc::c_int;
}
pub unsafe extern "C" fn ge(mut self_0: var, mut obj: var) -> bool {
    let mut tmp: bool = false;
    let mut tmp___0: libc::c_int = 0;
    tmp = lt(self_0, obj);
    if tmp {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp___0 = 1 as libc::c_int;
    }
    return tmp___0 != 0;
}
pub unsafe extern "C" fn le(mut self_0: var, mut obj: var) -> bool {
    let mut tmp: bool = false;
    let mut tmp___0: libc::c_int = 0;
    tmp = gt(self_0, obj);
    if tmp {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp___0 = 1 as libc::c_int;
    }
    return tmp___0 != 0;
}
unsafe extern "C" fn Sort_Name() -> *const libc::c_char {
    return b"Sort\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Sort_Brief() -> *const libc::c_char {
    return b"Sortable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Sort_Description() -> *const libc::c_char {
    return b"The `Sort` class can be implemented by types which can be sorted in some way such as `Array`. By default the sorting function uses the `lt` method to compare elements, but a custom function can also be provided.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Sort_Definition() -> *const libc::c_char {
    return b"struct Sort {\n  void (*sort_by)(var,bool(*f)(var,var));\n};\0" as *const u8
        as *const libc::c_char;
}
static mut examples___27: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Float, \n  $F(5.2), $F(7.1), $F(2.2));\n\nshow(x); /* <'Array' At 0x00414603 [5.2, 7.1, 2.2]> */\nsort(x);\nshow(x); /* <'Array' At 0x00414603 [2.2, 5.2, 7.1]> */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Sort_Examples() -> *mut Example {
    return examples___27.as_mut_ptr();
}
static mut methods___21: [Method; 3] = [
    {
        let mut init = Method {
            name: b"sort\0" as *const u8 as *const libc::c_char,
            definition: b"void sort(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Sorts the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"sort_by\0" as *const u8 as *const libc::c_char,
            definition: b"void sort_by(var self, bool(*f)(var,var));\0" as *const u8
                as *const libc::c_char,
            description: b"Sorts the object `self` using the function `f`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Sort_Methods() -> *mut Method {
    return methods___21.as_mut_ptr();
}
static mut __constr_expr_806: Doc = {
    let mut init = Doc {
        name: Some(Sort_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Sort_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Sort_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Sort_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Sort_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Sort_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_805: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Sort\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Sort>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_806 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Sort: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn sort(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Sort,
        &mut (*(0 as *mut Sort)).sort_by
            as *mut Option::<
                unsafe extern "C" fn(
                    var,
                    Option::<unsafe extern "C" fn(var, var) -> bool>,
                ) -> (),
            > as libc::c_ulong,
        b"sort_by\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Sort)).sort_by).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(self_0, Some(lt as unsafe extern "C" fn(var, var) -> bool));
}
pub unsafe extern "C" fn sort_by(
    mut self_0: var,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Sort,
        &mut (*(0 as *mut Sort)).sort_by
            as *mut Option::<
                unsafe extern "C" fn(
                    var,
                    Option::<unsafe extern "C" fn(var, var) -> bool>,
                ) -> (),
            > as libc::c_ulong,
        b"sort_by\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Sort)).sort_by).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, f);
}
unsafe extern "C" fn Format_Name() -> *const libc::c_char {
    return b"Format\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Format_Brief() -> *const libc::c_char {
    return b"Read or Write with Format String\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Format_Description() -> *const libc::c_char {
    return b"Format abstracts the class of operations such as `scanf`, `sprintf` and `fprintf` with matching semantics. It provides general `printf` and `scanf` functionality for several different types objects in a uniform way. This class is essentially an in-between class, used by the `Show` class to read and write output.\n\nIt is important to note that the semantics of these operations match `printf` and not the newly defined `Show` class. For example it is perfectly valid to pass a C `int` to these functions, while the `println` function from `Show` must be passed only `var` objects.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Format_Definition() -> *const libc::c_char {
    return b"struct Format {\n  int (*format_to)(var,int,const char*,va_list);\n  int (*format_from)(var,int,const char*,va_list);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___28: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"/* printf(\"Hello my name is %s, I'm %i\\n\", \"Dan\", 23); */\nformat_to($(File, stdout), 0, \n  \"Hello my name is %s, I'm %i\\n\", \"Dan\", 23);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Format_Examples() -> *mut Example {
    return examples___28.as_mut_ptr();
}
static mut methods___22: [Method; 3] = [
    {
        let mut init = Method {
            name: b"format_to\0" as *const u8 as *const libc::c_char,
            definition: b"int format_to(var self, int pos, const char* fmt, ...);\nint format_to_va(var self, int pos, const char* fmt, va_list va);\0"
                as *const u8 as *const libc::c_char,
            description: b"Write a formatted string `fmt` to the object `self` at position `pos`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"format_from\0" as *const u8 as *const libc::c_char,
            definition: b"int format_from(var self, int pos, const char* fmt, ...);\nint format_from_va(var self, int pos, const char* fmt, va_list va);\0"
                as *const u8 as *const libc::c_char,
            description: b"Read a formatted string `fmt` from the object `self` at position `pos`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Format_Methods() -> *mut Method {
    return methods___22.as_mut_ptr();
}
static mut __constr_expr_808: Doc = {
    let mut init = Doc {
        name: Some(Format_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Format_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Format_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Format_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Format_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Format_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_807: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Format\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Format>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_808 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Format: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn format_to_va(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    tmp = method_at_offset(
        self_0,
        Format,
        &mut (*(0 as *mut Format)).format_to
            as *mut Option::<
                unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
            > as libc::c_ulong,
        b"format_to\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Format)).format_to).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0, pos, fmt, va.as_va_list());
    return tmp___0;
}
pub unsafe extern "C" fn format_from_va(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    tmp = method_at_offset(
        self_0,
        Format,
        &mut (*(0 as *mut Format)).format_from
            as *mut Option::<
                unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
            > as libc::c_ulong,
        b"format_from\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Format)).format_from).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0, pos, fmt, va.as_va_list());
    return tmp___0;
}
pub unsafe extern "C" fn format_to(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut va: ::std::ffi::VaListImpl;
    let mut ret: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    va = args.clone();
    tmp = format_to_va(self_0, pos, fmt, va.as_va_list());
    ret = tmp;
    return ret;
}
pub unsafe extern "C" fn format_from(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut va: ::std::ffi::VaListImpl;
    let mut ret: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    va = args.clone();
    tmp = format_from_va(self_0, pos, fmt, va.as_va_list());
    ret = tmp;
    return ret;
}
unsafe extern "C" fn Show_Name() -> *const libc::c_char {
    return b"Show\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Show_Brief() -> *const libc::c_char {
    return b"Convert To or From String\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Show_Description() -> *const libc::c_char {
    return b"The `Show` class is used to convert objects to, and from, a `String` representation. Objects which implement `Show` should expect the input/output object to be one that support the `Format` class, such as `File` or `String`.\n\nThe `print`, `println` and `print_to` functions provide a mechanism for writing formatted strings with Cello objects. To do this they provide a new format specifier `%$` which uses an object's `Show` functionality to write that part of the string. All objects which don't support `Show` can still be shown via a default implementation.\n\nAll the Show methods which are variable arguments only take `var` objects as input. To print native C types wrap them in Cello types using `$`.\n\nStandard format specifiers such as `%f` and `%d` will call functions such as `c_float` and `c_int` on their passed arguments to convert objects to C types before performing the standard C formatting behaviour.\n\nSee [printf](http://www.cplusplus.com/reference/cstdio/printf/) for more information on format specifiers.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Show_Definition() -> *const libc::c_char {
    return b"struct Show {\n  int (*show)(var, var, int);\n  int (*look)(var, var, int);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___29: [Example; 5] = [
    {
        let mut init = Example {
            name: b"Hello World\0" as *const u8 as *const libc::c_char,
            body: b"println(\"Hello %s!\", $S(\"World\"));\n\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"File Writing\0" as *const u8 as *const libc::c_char,
            body: b"with (f in new(File, $S(\"prices.txt\"), $S(\"wb\"))) {\n  print_to(f, 0, \"%$ :: %$\\n\", $S(\"Banana\"), $I(57));\n  print_to(f, 0, \"%$ :: %$\\n\", $S(\"Apple\"),  $I(22));\n  print_to(f, 0, \"%$ :: %$\\n\", $S(\"Pear\"),   $I(16));\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"String Scanning\0" as *const u8 as *const libc::c_char,
            body: b"var input = $S(\"1 and 52 then 78\");\n\nvar i0 = $I(0), i1 = $I(0), i2 = $I(0);\nscan_from(input, 0, \"%i and %i then %i\", i0, i1, i2);\n\n/* i0: 1, i1: 52, i2: 78 */\nprintln(\"i0: %$, i1: %$, i2: %$\", i0, i1, i2);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"String Printing\0" as *const u8 as *const libc::c_char,
            body: b"var greeting = new(String);\nprint_to(greeting, 0, \"Hello %s %s, %s?\", \n  $S(\"Mr\"), $S(\"Johnson\"), $S(\"how are you?\"));\n\n/* Hello Mr Johnson, how are you? */\nshow(greeting);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Show_Examples() -> *mut Example {
    return examples___29.as_mut_ptr();
}
static mut methods___23: [Method; 5] = [
    {
        let mut init = Method {
            name: b"show\0" as *const u8 as *const libc::c_char,
            definition: b"int show(var self);\nint show_to(var self, var out, int pos);\0"
                as *const u8 as *const libc::c_char,
            description: b"Show the object `self` either to `stdout` or to the object `output`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"look\0" as *const u8 as *const libc::c_char,
            definition: b"int look(var self);\nint look_from(var self, var input, int pos);\0"
                as *const u8 as *const libc::c_char,
            description: b"Read the object `self` either from `stdout` or from the object `input`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"print\0" as *const u8 as *const libc::c_char,
            definition: b"#define print(fmt, ...)\n#define println(fmt, ...)\n#define print_to(out, pos, fmt, ...)\nint print_with(const char* fmt, var args);\nint println_with(const char* fmt, var args);\nint print_to_with(var out, int pos, const char* fmt, var args);\0"
                as *const u8 as *const libc::c_char,
            description: b"Print the format string `fmt` either to `stdout` or to the object `out` at positions `pos`. Returns new position in output.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"scan\0" as *const u8 as *const libc::c_char,
            definition: b"#define scan(fmt, ...)\n#define scanln(fmt, ...)\n#define scan_from(input, pos, fmt, ...)\nint scan_with(const char* fmt, var args);\nint scanln_with(const char* fmt, var args);\nint scan_from_with(var input, int pos, const char* fmt, var args);\0"
                as *const u8 as *const libc::c_char,
            description: b"Scan the format string `fmt` either from `stdin` or from the object `input` at position `pos`. Returns new position in output.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Show_Methods() -> *mut Method {
    return methods___23.as_mut_ptr();
}
static mut __constr_expr_810: Doc = {
    let mut init = Doc {
        name: Some(Show_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Show_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Show_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Show_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Show_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Show_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_809: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Show>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_810 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Show: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn show(mut self_0: var) -> libc::c_int {
    let mut __constr_expr_811: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_812: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_811.file = stdout;
    __constr_expr_812[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_812[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_812.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_811 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    tmp___2 = show_to(self_0, tmp___1 as *mut File as var, 0 as libc::c_int);
    return tmp___2;
}
pub unsafe extern "C" fn show_to(
    mut self_0: var,
    mut out: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut s: *mut Show = 0 as *mut Show;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut __constr_expr_813: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_814: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut __constr_expr_815: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: libc::c_int = 0;
    tmp = instance(self_0, Show);
    s = tmp as *mut Show;
    if !s.is_null() {
        if ((*s).show).is_some() {
            tmp___0 = (Some(((*s).show).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, out, pos);
            return tmp___0;
        }
    }
    tmp___1 = type_of(self_0);
    __constr_expr_814[0 as libc::c_int as usize] = tmp___1;
    __constr_expr_814[1 as libc::c_int as usize] = self_0;
    __constr_expr_814[2 as libc::c_int as usize] = Terminal;
    __constr_expr_813.items = __constr_expr_814.as_mut_ptr();
    __constr_expr_815[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_815[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(
        __constr_expr_815.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___4 = memcpy(
        tmp___3 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_813 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___5 = print_to_with(
        out,
        pos,
        b"<'%s' At 0x%p>\0" as *const u8 as *const libc::c_char,
        tmp___4 as *mut Tuple as var,
    );
    return tmp___5;
}
pub unsafe extern "C" fn print_with(
    mut fmt: *const libc::c_char,
    mut args: var,
) -> libc::c_int {
    let mut __constr_expr_816: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_817: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_816.file = stdout;
    __constr_expr_817[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_817[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_817.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_816 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    tmp___2 = print_to_with(tmp___1 as *mut File as var, 0 as libc::c_int, fmt, args);
    return tmp___2;
}
pub unsafe extern "C" fn println_with(
    mut fmt: *const libc::c_char,
    mut args: var,
) -> libc::c_int {
    let mut pos: libc::c_int = 0;
    let mut __constr_expr_818: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_819: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_820: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_821: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_822: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_823: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_824: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    pos = 0 as libc::c_int;
    __constr_expr_818.file = stdout;
    __constr_expr_819[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_819[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_819.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_818 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    pos = print_to_with(tmp___1 as *mut File as var, pos, fmt, args);
    __constr_expr_821[0 as libc::c_int as usize] = Terminal;
    __constr_expr_820.items = __constr_expr_821.as_mut_ptr();
    __constr_expr_822[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_822[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(
        __constr_expr_822.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___4 = memcpy(
        tmp___3 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_820 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_823.file = stdout;
    __constr_expr_824[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___5 = 1 as libc::c_uint;
    while !(tmp___5 >= 32 as libc::c_uint) {
        __constr_expr_824[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = tmp___5.wrapping_add(1);
    }
    tmp___6 = header_init(__constr_expr_824.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___7 = memcpy(
        tmp___6 as *mut File as *mut libc::c_void,
        &mut __constr_expr_823 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    pos = print_to_with(
        tmp___7 as *mut File as var,
        pos,
        b"\n\0" as *const u8 as *const libc::c_char,
        tmp___4 as *mut Tuple as var,
    );
    return pos;
}
pub unsafe extern "C" fn print_to_with(
    mut out: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: var,
) -> libc::c_int {
    let mut fmt_buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut index___0: size_t = 0;
    let mut start___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut off: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut __constr_expr_825: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_826: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_827: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut off___0: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut __constr_expr_828: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_829: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_830: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __constr_expr_831: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_832: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_833: [libc::c_char; 32] = [0; 32];
    let mut tmp___10: libc::c_uint = 0;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: size_t = 0;
    let mut a: var = 0 as *mut libc::c_void;
    let mut __constr_expr_834: Int = Int { val: 0 };
    let mut __constr_expr_835: [libc::c_char; 32] = [0; 32];
    let mut tmp___14: libc::c_uint = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut off___1: libc::c_int = 0;
    let mut tmp___18: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___19: libc::c_int = 0;
    let mut __constr_expr_836: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_837: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_838: [libc::c_char; 32] = [0; 32];
    let mut tmp___20: libc::c_uint = 0;
    let mut tmp___21: var = 0 as *mut libc::c_void;
    let mut tmp___22: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut off___2: libc::c_int = 0;
    let mut tmp___23: int64_t = 0;
    let mut tmp___24: libc::c_int = 0;
    let mut __constr_expr_839: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_840: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_841: [libc::c_char; 32] = [0; 32];
    let mut tmp___25: libc::c_uint = 0;
    let mut tmp___26: var = 0 as *mut libc::c_void;
    let mut tmp___27: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut off___3: libc::c_int = 0;
    let mut tmp___29: libc::c_double = 0.;
    let mut tmp___30: libc::c_int = 0;
    let mut __constr_expr_842: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_843: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_844: [libc::c_char; 32] = [0; 32];
    let mut tmp___31: libc::c_uint = 0;
    let mut tmp___32: var = 0 as *mut libc::c_void;
    let mut tmp___33: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___34: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut off___4: libc::c_int = 0;
    let mut tmp___35: int64_t = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut __constr_expr_845: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_846: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_847: [libc::c_char; 32] = [0; 32];
    let mut tmp___37: libc::c_uint = 0;
    let mut tmp___38: var = 0 as *mut libc::c_void;
    let mut tmp___39: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut off___5: libc::c_int = 0;
    let mut tmp___40: libc::c_int = 0;
    let mut __constr_expr_848: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_849: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_850: [libc::c_char; 32] = [0; 32];
    let mut tmp___41: libc::c_uint = 0;
    let mut tmp___42: var = 0 as *mut libc::c_void;
    let mut tmp___43: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_851: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_852: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_853: [libc::c_char; 32] = [0; 32];
    let mut tmp___44: libc::c_uint = 0;
    let mut tmp___45: var = 0 as *mut libc::c_void;
    let mut tmp___46: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strlen(fmt);
    tmp___0 = malloc(tmp.wrapping_add(1 as libc::c_ulong));
    fmt_buf = tmp___0 as *mut libc::c_char;
    index___0 = 0 as libc::c_int as size_t;
    while !(*fmt as libc::c_int == 0 as libc::c_int) {
        start___0 = fmt;
        while *fmt as libc::c_int != 0 as libc::c_int {
            if !(*fmt as libc::c_int != 37 as libc::c_int) {
                break;
            }
            fmt = fmt.offset(1);
        }
        if start___0 as libc::c_ulong != fmt as libc::c_ulong {
            memcpy(
                fmt_buf as *mut libc::c_void,
                start___0 as *const libc::c_void,
                fmt.offset_from(start___0) as libc::c_long as size_t,
            );
            *fmt_buf
                .offset(
                    fmt.offset_from(start___0) as libc::c_long as isize,
                ) = '\u{0}' as i32 as libc::c_char;
            tmp___1 = format_to(out, pos, fmt_buf as *const libc::c_char);
            off = tmp___1;
            if off < 0 as libc::c_int {
                __constr_expr_826[0 as libc::c_int as usize] = Terminal;
                __constr_expr_825.items = __constr_expr_826.as_mut_ptr();
                __constr_expr_827[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___2 = 1 as libc::c_uint;
                while !(tmp___2 >= 32 as libc::c_uint) {
                    __constr_expr_827[tmp___2
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___2 = tmp___2.wrapping_add(1);
                }
                tmp___3 = header_init(
                    __constr_expr_827.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___4 = memcpy(
                    tmp___3 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_825 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    FormatError,
                    b"Unable to output format!\0" as *const u8 as *const libc::c_char,
                    tmp___4 as *mut Tuple as var,
                );
            }
            pos += off;
        } else {
            if *fmt as libc::c_int == 37 as libc::c_int {
                if *fmt.offset(1 as libc::c_int as isize) as libc::c_int
                    == 37 as libc::c_int
                {
                    tmp___5 = format_to(
                        out,
                        pos,
                        b"%%\0" as *const u8 as *const libc::c_char,
                    );
                    off___0 = tmp___5;
                    if off___0 < 0 as libc::c_int {
                        __constr_expr_829[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_828.items = __constr_expr_829.as_mut_ptr();
                        __constr_expr_830[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___6 = 1 as libc::c_uint;
                        while !(tmp___6 >= 32 as libc::c_uint) {
                            __constr_expr_830[tmp___6
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___6 = tmp___6.wrapping_add(1);
                        }
                        tmp___7 = header_init(
                            __constr_expr_830.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___8 = memcpy(
                            tmp___7 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_828 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to output '%%%%'!\0" as *const u8
                                as *const libc::c_char,
                            tmp___8 as *mut Tuple as var,
                        );
                    }
                    pos += off___0;
                    fmt = fmt.offset(2 as libc::c_int as isize);
                    continue;
                }
            }
            loop {
                tmp___9 = strchr(
                    b"diuoxXfFeEgGaAxcsp$\0" as *const u8 as *const libc::c_char,
                    *fmt as libc::c_int,
                );
                if !tmp___9.is_null() {
                    break;
                }
                fmt = fmt.offset(1);
            }
            if start___0 as libc::c_ulong != fmt as libc::c_ulong {
                memcpy(
                    fmt_buf as *mut libc::c_void,
                    start___0 as *const libc::c_void,
                    (fmt.offset_from(start___0) as libc::c_long + 1 as libc::c_long)
                        as size_t,
                );
                *fmt_buf
                    .offset(
                        (fmt.offset_from(start___0) as libc::c_long + 1 as libc::c_long)
                            as isize,
                    ) = '\u{0}' as i32 as libc::c_char;
                tmp___13 = len(args);
                if index___0 >= tmp___13 {
                    __constr_expr_832[0 as libc::c_int as usize] = Terminal;
                    __constr_expr_831.items = __constr_expr_832.as_mut_ptr();
                    __constr_expr_833[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___10 = 1 as libc::c_uint;
                    while !(tmp___10 >= 32 as libc::c_uint) {
                        __constr_expr_833[tmp___10
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___10 = tmp___10.wrapping_add(1);
                    }
                    tmp___11 = header_init(
                        __constr_expr_833.as_mut_ptr() as var,
                        Tuple,
                        2 as libc::c_int,
                    );
                    tmp___12 = memcpy(
                        tmp___11 as *mut Tuple as *mut libc::c_void,
                        &mut __constr_expr_831 as *mut Tuple as *const libc::c_void,
                        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                    );
                    exception_throw(
                        FormatError,
                        b"Not enough arguments to Format String!\0" as *const u8
                            as *const libc::c_char,
                        tmp___12 as *mut Tuple as var,
                    );
                }
                __constr_expr_834.val = index___0 as int64_t;
                __constr_expr_835[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___14 = 1 as libc::c_uint;
                while !(tmp___14 >= 32 as libc::c_uint) {
                    __constr_expr_835[tmp___14
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___14 = tmp___14.wrapping_add(1);
                }
                tmp___15 = header_init(
                    __constr_expr_835.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___16 = memcpy(
                    tmp___15 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_834 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                tmp___17 = get(args, tmp___16 as *mut Int as var);
                a = tmp___17;
                index___0 = index___0.wrapping_add(1);
                if *fmt as libc::c_int == 36 as libc::c_int {
                    pos = show_to(a, out, pos);
                }
                if *fmt as libc::c_int == 115 as libc::c_int {
                    tmp___18 = c_str(a);
                    tmp___19 = format_to(
                        out,
                        pos,
                        fmt_buf as *const libc::c_char,
                        tmp___18,
                    );
                    off___1 = tmp___19;
                    if off___1 < 0 as libc::c_int {
                        __constr_expr_837[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_836.items = __constr_expr_837.as_mut_ptr();
                        __constr_expr_838[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___20 = 1 as libc::c_uint;
                        while !(tmp___20 >= 32 as libc::c_uint) {
                            __constr_expr_838[tmp___20
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___20 = tmp___20.wrapping_add(1);
                        }
                        tmp___21 = header_init(
                            __constr_expr_838.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___22 = memcpy(
                            tmp___21 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_836 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to output String!\0" as *const u8
                                as *const libc::c_char,
                            tmp___22 as *mut Tuple as var,
                        );
                    }
                    pos += off___1;
                }
                tmp___28 = strchr(
                    b"diouxX\0" as *const u8 as *const libc::c_char,
                    *fmt as libc::c_int,
                );
                if !tmp___28.is_null() {
                    tmp___23 = c_int(a);
                    tmp___24 = format_to(
                        out,
                        pos,
                        fmt_buf as *const libc::c_char,
                        tmp___23,
                    );
                    off___2 = tmp___24;
                    if off___2 < 0 as libc::c_int {
                        __constr_expr_840[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_839.items = __constr_expr_840.as_mut_ptr();
                        __constr_expr_841[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___25 = 1 as libc::c_uint;
                        while !(tmp___25 >= 32 as libc::c_uint) {
                            __constr_expr_841[tmp___25
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___25 = tmp___25.wrapping_add(1);
                        }
                        tmp___26 = header_init(
                            __constr_expr_841.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___27 = memcpy(
                            tmp___26 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_839 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to output Int!\0" as *const u8
                                as *const libc::c_char,
                            tmp___27 as *mut Tuple as var,
                        );
                    }
                    pos += off___2;
                }
                tmp___34 = strchr(
                    b"fFeEgGaA\0" as *const u8 as *const libc::c_char,
                    *fmt as libc::c_int,
                );
                if !tmp___34.is_null() {
                    tmp___29 = c_float(a);
                    tmp___30 = format_to(
                        out,
                        pos,
                        fmt_buf as *const libc::c_char,
                        tmp___29,
                    );
                    off___3 = tmp___30;
                    if off___3 < 0 as libc::c_int {
                        __constr_expr_843[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_842.items = __constr_expr_843.as_mut_ptr();
                        __constr_expr_844[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___31 = 1 as libc::c_uint;
                        while !(tmp___31 >= 32 as libc::c_uint) {
                            __constr_expr_844[tmp___31
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___31 = tmp___31.wrapping_add(1);
                        }
                        tmp___32 = header_init(
                            __constr_expr_844.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___33 = memcpy(
                            tmp___32 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_842 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to output Real!\0" as *const u8
                                as *const libc::c_char,
                            tmp___33 as *mut Tuple as var,
                        );
                    }
                    pos += off___3;
                }
                if *fmt as libc::c_int == 99 as libc::c_int {
                    tmp___35 = c_int(a);
                    tmp___36 = format_to(
                        out,
                        pos,
                        fmt_buf as *const libc::c_char,
                        tmp___35,
                    );
                    off___4 = tmp___36;
                    if off___4 < 0 as libc::c_int {
                        __constr_expr_846[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_845.items = __constr_expr_846.as_mut_ptr();
                        __constr_expr_847[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___37 = 1 as libc::c_uint;
                        while !(tmp___37 >= 32 as libc::c_uint) {
                            __constr_expr_847[tmp___37
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___37 = tmp___37.wrapping_add(1);
                        }
                        tmp___38 = header_init(
                            __constr_expr_847.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___39 = memcpy(
                            tmp___38 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_845 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to output Char!\0" as *const u8
                                as *const libc::c_char,
                            tmp___39 as *mut Tuple as var,
                        );
                    }
                    pos += off___4;
                }
                if *fmt as libc::c_int == 112 as libc::c_int {
                    tmp___40 = format_to(out, pos, fmt_buf as *const libc::c_char, a);
                    off___5 = tmp___40;
                    if off___5 < 0 as libc::c_int {
                        __constr_expr_849[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_848.items = __constr_expr_849.as_mut_ptr();
                        __constr_expr_850[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___41 = 1 as libc::c_uint;
                        while !(tmp___41 >= 32 as libc::c_uint) {
                            __constr_expr_850[tmp___41
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___41 = tmp___41.wrapping_add(1);
                        }
                        tmp___42 = header_init(
                            __constr_expr_850.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___43 = memcpy(
                            tmp___42 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_848 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to output Object!\0" as *const u8
                                as *const libc::c_char,
                            tmp___43 as *mut Tuple as var,
                        );
                    }
                    pos += off___5;
                }
                fmt = fmt.offset(1);
            } else {
                __constr_expr_852[0 as libc::c_int as usize] = Terminal;
                __constr_expr_851.items = __constr_expr_852.as_mut_ptr();
                __constr_expr_853[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___44 = 1 as libc::c_uint;
                while !(tmp___44 >= 32 as libc::c_uint) {
                    __constr_expr_853[tmp___44
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___44 = tmp___44.wrapping_add(1);
                }
                tmp___45 = header_init(
                    __constr_expr_853.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___46 = memcpy(
                    tmp___45 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_851 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    FormatError,
                    b"Invalid Format String!\0" as *const u8 as *const libc::c_char,
                    tmp___46 as *mut Tuple as var,
                );
            }
        }
    }
    free(fmt_buf as *mut libc::c_void);
    return pos;
}
pub unsafe extern "C" fn look(mut self_0: var) -> libc::c_int {
    let mut __constr_expr_854: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_855: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_854.file = stdin;
    __constr_expr_855[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_855[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_855.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_854 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    tmp___2 = look_from(self_0, tmp___1 as *mut File as var, 0 as libc::c_int);
    return tmp___2;
}
pub unsafe extern "C" fn look_from(
    mut self_0: var,
    mut input: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    tmp = method_at_offset(
        self_0,
        Show,
        &mut (*(0 as *mut Show)).look
            as *mut Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>
            as libc::c_ulong,
        b"look\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Show)).look).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, input, pos);
    return tmp___0;
}
pub unsafe extern "C" fn scan_with(
    mut fmt: *const libc::c_char,
    mut args: var,
) -> libc::c_int {
    let mut __constr_expr_856: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_857: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_856.file = stdin;
    __constr_expr_857[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_857[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_857.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_856 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    tmp___2 = scan_from_with(tmp___1 as *mut File as var, 0 as libc::c_int, fmt, args);
    return tmp___2;
}
pub unsafe extern "C" fn scanln_with(
    mut fmt: *const libc::c_char,
    mut args: var,
) -> libc::c_int {
    let mut pos: libc::c_int = 0;
    let mut __constr_expr_858: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_859: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_860: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_861: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_862: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_863: File = File { file: 0 as *mut FILE };
    let mut __constr_expr_864: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    pos = 0 as libc::c_int;
    __constr_expr_858.file = stdin;
    __constr_expr_859[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_859[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_859.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut File as *mut libc::c_void,
        &mut __constr_expr_858 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    pos = scan_from_with(tmp___1 as *mut File as var, pos, fmt, args);
    __constr_expr_861[0 as libc::c_int as usize] = Terminal;
    __constr_expr_860.items = __constr_expr_861.as_mut_ptr();
    __constr_expr_862[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_862[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(
        __constr_expr_862.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___4 = memcpy(
        tmp___3 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_860 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    __constr_expr_863.file = stdin;
    __constr_expr_864[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___5 = 1 as libc::c_uint;
    while !(tmp___5 >= 32 as libc::c_uint) {
        __constr_expr_864[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = tmp___5.wrapping_add(1);
    }
    tmp___6 = header_init(__constr_expr_864.as_mut_ptr() as var, File, 2 as libc::c_int);
    tmp___7 = memcpy(
        tmp___6 as *mut File as *mut libc::c_void,
        &mut __constr_expr_863 as *mut File as *const libc::c_void,
        ::std::mem::size_of::<File>() as libc::c_ulong,
    );
    pos = scan_from_with(
        tmp___7 as *mut File as var,
        pos,
        b"\n\0" as *const u8 as *const libc::c_char,
        tmp___4 as *mut Tuple as var,
    );
    return pos;
}
pub unsafe extern "C" fn scan_from_with(
    mut input: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: var,
) -> libc::c_int {
    let mut fmt_buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut index___0: size_t = 0;
    let mut start___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut err: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut __constr_expr_865: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_866: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_867: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut off: libc::c_int = 0;
    let mut __constr_expr_868: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_869: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_870: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: size_t = 0;
    let mut a: var = 0 as *mut libc::c_void;
    let mut __constr_expr_871: Int = Int { val: 0 };
    let mut __constr_expr_872: [libc::c_char; 32] = [0; 32];
    let mut tmp___10: libc::c_uint = 0;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut err___0: libc::c_int = 0;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: libc::c_int = 0;
    let mut __constr_expr_873: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_874: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_875: [libc::c_char; 32] = [0; 32];
    let mut tmp___16: libc::c_uint = 0;
    let mut tmp___17: var = 0 as *mut libc::c_void;
    let mut tmp___18: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut err___1: libc::c_int = 0;
    let mut tmp___19: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___20: libc::c_int = 0;
    let mut __constr_expr_876: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_877: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_878: [libc::c_char; 32] = [0; 32];
    let mut tmp___21: libc::c_uint = 0;
    let mut tmp___22: var = 0 as *mut libc::c_void;
    let mut tmp___23: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___24: libc::c_long = 0;
    let mut err___2: libc::c_int = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut __constr_expr_879: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_880: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_881: [libc::c_char; 32] = [0; 32];
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: var = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_882: Int = Int { val: 0 };
    let mut __constr_expr_883: [libc::c_char; 32] = [0; 32];
    let mut tmp___29: libc::c_uint = 0;
    let mut tmp___30: var = 0 as *mut libc::c_void;
    let mut tmp___31: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___32: libc::c_double = 0.;
    let mut err___3: libc::c_int = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut __constr_expr_884: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_885: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_886: [libc::c_char; 32] = [0; 32];
    let mut tmp___34: libc::c_uint = 0;
    let mut tmp___35: var = 0 as *mut libc::c_void;
    let mut tmp___36: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_887: Float = Float { val: 0. };
    let mut __constr_expr_888: [libc::c_char; 32] = [0; 32];
    let mut tmp___37: libc::c_uint = 0;
    let mut tmp___38: var = 0 as *mut libc::c_void;
    let mut tmp___39: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___40: libc::c_float = 0.;
    let mut err___4: libc::c_int = 0;
    let mut tmp___41: libc::c_int = 0;
    let mut __constr_expr_889: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_890: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_891: [libc::c_char; 32] = [0; 32];
    let mut tmp___42: libc::c_uint = 0;
    let mut tmp___43: var = 0 as *mut libc::c_void;
    let mut tmp___44: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_892: Float = Float { val: 0. };
    let mut __constr_expr_893: [libc::c_char; 32] = [0; 32];
    let mut tmp___45: libc::c_uint = 0;
    let mut tmp___46: var = 0 as *mut libc::c_void;
    let mut tmp___47: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___48: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___49: libc::c_char = 0;
    let mut err___5: libc::c_int = 0;
    let mut tmp___50: libc::c_int = 0;
    let mut __constr_expr_894: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_895: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_896: [libc::c_char; 32] = [0; 32];
    let mut tmp___51: libc::c_uint = 0;
    let mut tmp___52: var = 0 as *mut libc::c_void;
    let mut tmp___53: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_897: Int = Int { val: 0 };
    let mut __constr_expr_898: [libc::c_char; 32] = [0; 32];
    let mut tmp___54: libc::c_uint = 0;
    let mut tmp___55: var = 0 as *mut libc::c_void;
    let mut tmp___56: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___57: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut err___6: libc::c_int = 0;
    let mut tmp___58: libc::c_int = 0;
    let mut __constr_expr_899: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_900: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_901: [libc::c_char; 32] = [0; 32];
    let mut tmp___59: libc::c_uint = 0;
    let mut tmp___60: var = 0 as *mut libc::c_void;
    let mut tmp___61: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_902: Ref = Ref { val: 0 as *mut libc::c_void };
    let mut __constr_expr_903: [libc::c_char; 32] = [0; 32];
    let mut tmp___62: libc::c_uint = 0;
    let mut tmp___63: var = 0 as *mut libc::c_void;
    let mut tmp___64: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_904: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_905: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_906: [libc::c_char; 32] = [0; 32];
    let mut tmp___65: libc::c_uint = 0;
    let mut tmp___66: var = 0 as *mut libc::c_void;
    let mut tmp___67: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___68: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___69: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = strlen(fmt);
    tmp___0 = malloc(tmp.wrapping_add(4 as libc::c_ulong));
    fmt_buf = tmp___0 as *mut libc::c_char;
    index___0 = 0 as libc::c_int as size_t;
    while !(*fmt as libc::c_int == 0 as libc::c_int) {
        start___0 = fmt;
        while *fmt as libc::c_int != 0 as libc::c_int {
            if !(*fmt as libc::c_int != 37 as libc::c_int) {
                break;
            }
            fmt = fmt.offset(1);
        }
        if start___0 as libc::c_ulong != fmt as libc::c_ulong {
            memcpy(
                fmt_buf as *mut libc::c_void,
                start___0 as *const libc::c_void,
                fmt.offset_from(start___0) as libc::c_long as size_t,
            );
            *fmt_buf
                .offset(
                    fmt.offset_from(start___0) as libc::c_long as isize,
                ) = '\u{0}' as i32 as libc::c_char;
            format_from(input, pos, fmt_buf as *const libc::c_char);
            pos += fmt.offset_from(start___0) as libc::c_long as libc::c_int;
        } else {
            if *fmt as libc::c_int == 37 as libc::c_int {
                if *fmt.offset(1 as libc::c_int as isize) as libc::c_int
                    == 37 as libc::c_int
                {
                    tmp___1 = format_from(
                        input,
                        pos,
                        b"%%\0" as *const u8 as *const libc::c_char,
                    );
                    err = tmp___1;
                    if err < 0 as libc::c_int {
                        __constr_expr_866[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_865.items = __constr_expr_866.as_mut_ptr();
                        __constr_expr_867[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___2 = 1 as libc::c_uint;
                        while !(tmp___2 >= 32 as libc::c_uint) {
                            __constr_expr_867[tmp___2
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___2 = tmp___2.wrapping_add(1);
                        }
                        tmp___3 = header_init(
                            __constr_expr_867.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___4 = memcpy(
                            tmp___3 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_865 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to input '%%%%'!\0" as *const u8
                                as *const libc::c_char,
                            tmp___4 as *mut Tuple as var,
                        );
                    }
                    pos += 2 as libc::c_int;
                    fmt = fmt.offset(2 as libc::c_int as isize);
                    continue;
                }
            }
            loop {
                tmp___5 = strchr(
                    b"diuoxXfFeEgGaAxcsp$[^]\0" as *const u8 as *const libc::c_char,
                    *fmt as libc::c_int,
                );
                if !tmp___5.is_null() {
                    break;
                }
                fmt = fmt.offset(1);
            }
            if !(start___0 as libc::c_ulong != fmt as libc::c_ulong) {
                continue;
            }
            off = 0 as libc::c_int;
            memcpy(
                fmt_buf as *mut libc::c_void,
                start___0 as *const libc::c_void,
                (fmt.offset_from(start___0) as libc::c_long + 1 as libc::c_long)
                    as size_t,
            );
            *fmt_buf
                .offset(
                    (fmt.offset_from(start___0) as libc::c_long + 1 as libc::c_long)
                        as isize,
                ) = '\u{0}' as i32 as libc::c_char;
            strcat(fmt_buf, b"%n\0" as *const u8 as *const libc::c_char);
            tmp___9 = len(args);
            if index___0 >= tmp___9 {
                __constr_expr_869[0 as libc::c_int as usize] = Terminal;
                __constr_expr_868.items = __constr_expr_869.as_mut_ptr();
                __constr_expr_870[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = 1 as libc::c_uint;
                while !(tmp___6 >= 32 as libc::c_uint) {
                    __constr_expr_870[tmp___6
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___6 = tmp___6.wrapping_add(1);
                }
                tmp___7 = header_init(
                    __constr_expr_870.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___8 = memcpy(
                    tmp___7 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_868 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    FormatError,
                    b"Not enough arguments to Format String!\0" as *const u8
                        as *const libc::c_char,
                    tmp___8 as *mut Tuple as var,
                );
            }
            __constr_expr_871.val = index___0 as int64_t;
            __constr_expr_872[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___10 = 1 as libc::c_uint;
            while !(tmp___10 >= 32 as libc::c_uint) {
                __constr_expr_872[tmp___10 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___10 = tmp___10.wrapping_add(1);
            }
            tmp___11 = header_init(
                __constr_expr_872.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___12 = memcpy(
                tmp___11 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_871 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___13 = get(args, tmp___12 as *mut Int as var);
            a = tmp___13;
            index___0 = index___0.wrapping_add(1);
            if *fmt as libc::c_int == 36 as libc::c_int {
                pos = look_from(a, input, pos);
            } else if *fmt as libc::c_int == 115 as libc::c_int {
                tmp___14 = c_str(a);
                tmp___15 = format_from(
                    input,
                    pos,
                    fmt_buf as *const libc::c_char,
                    tmp___14,
                    &mut off as *mut libc::c_int,
                );
                err___0 = tmp___15;
                if err___0 < 1 as libc::c_int {
                    __constr_expr_874[0 as libc::c_int as usize] = Terminal;
                    __constr_expr_873.items = __constr_expr_874.as_mut_ptr();
                    __constr_expr_875[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___16 = 1 as libc::c_uint;
                    while !(tmp___16 >= 32 as libc::c_uint) {
                        __constr_expr_875[tmp___16
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___16 = tmp___16.wrapping_add(1);
                    }
                    tmp___17 = header_init(
                        __constr_expr_875.as_mut_ptr() as var,
                        Tuple,
                        2 as libc::c_int,
                    );
                    tmp___18 = memcpy(
                        tmp___17 as *mut Tuple as *mut libc::c_void,
                        &mut __constr_expr_873 as *mut Tuple as *const libc::c_void,
                        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                    );
                    exception_throw(
                        FormatError,
                        b"Unable to input String!\0" as *const u8 as *const libc::c_char,
                        tmp___18 as *mut Tuple as var,
                    );
                }
                pos += off;
            } else if *fmt as libc::c_int == 93 as libc::c_int {
                tmp___19 = c_str(a);
                tmp___20 = format_from(
                    input,
                    pos,
                    fmt_buf as *const libc::c_char,
                    tmp___19,
                    &mut off as *mut libc::c_int,
                );
                err___1 = tmp___20;
                if err___1 < 1 as libc::c_int {
                    __constr_expr_877[0 as libc::c_int as usize] = Terminal;
                    __constr_expr_876.items = __constr_expr_877.as_mut_ptr();
                    __constr_expr_878[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___21 = 1 as libc::c_uint;
                    while !(tmp___21 >= 32 as libc::c_uint) {
                        __constr_expr_878[tmp___21
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___21 = tmp___21.wrapping_add(1);
                    }
                    tmp___22 = header_init(
                        __constr_expr_878.as_mut_ptr() as var,
                        Tuple,
                        2 as libc::c_int,
                    );
                    tmp___23 = memcpy(
                        tmp___22 as *mut Tuple as *mut libc::c_void,
                        &mut __constr_expr_876 as *mut Tuple as *const libc::c_void,
                        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                    );
                    exception_throw(
                        FormatError,
                        b"Unable to input Scanset!\0" as *const u8
                            as *const libc::c_char,
                        tmp___23 as *mut Tuple as var,
                    );
                }
                pos += off;
            } else {
                tmp___69 = strchr(
                    b"diouxX\0" as *const u8 as *const libc::c_char,
                    *fmt as libc::c_int,
                );
                if !tmp___69.is_null() {
                    tmp___24 = 0 as libc::c_long;
                    tmp___25 = format_from(
                        input,
                        pos,
                        fmt_buf as *const libc::c_char,
                        &mut tmp___24 as *mut libc::c_long,
                        &mut off as *mut libc::c_int,
                    );
                    err___2 = tmp___25;
                    if err___2 < 1 as libc::c_int {
                        __constr_expr_880[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_879.items = __constr_expr_880.as_mut_ptr();
                        __constr_expr_881[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___26 = 1 as libc::c_uint;
                        while !(tmp___26 >= 32 as libc::c_uint) {
                            __constr_expr_881[tmp___26
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___26 = tmp___26.wrapping_add(1);
                        }
                        tmp___27 = header_init(
                            __constr_expr_881.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___28 = memcpy(
                            tmp___27 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_879 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Unable to input Int!\0" as *const u8
                                as *const libc::c_char,
                            tmp___28 as *mut Tuple as var,
                        );
                    }
                    pos += off;
                    __constr_expr_882.val = tmp___24;
                    __constr_expr_883[0 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___29 = 1 as libc::c_uint;
                    while !(tmp___29 >= 32 as libc::c_uint) {
                        __constr_expr_883[tmp___29
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___29 = tmp___29.wrapping_add(1);
                    }
                    tmp___30 = header_init(
                        __constr_expr_883.as_mut_ptr() as var,
                        Int,
                        2 as libc::c_int,
                    );
                    tmp___31 = memcpy(
                        tmp___30 as *mut Int as *mut libc::c_void,
                        &mut __constr_expr_882 as *mut Int as *const libc::c_void,
                        ::std::mem::size_of::<Int>() as libc::c_ulong,
                    );
                    assign(a, tmp___31 as *mut Int as var);
                } else {
                    tmp___68 = strchr(
                        b"fFeEgGaA\0" as *const u8 as *const libc::c_char,
                        *fmt as libc::c_int,
                    );
                    if !tmp___68.is_null() {
                        tmp___48 = strchr(fmt_buf as *const libc::c_char, 'l' as i32);
                        if !tmp___48.is_null() {
                            tmp___32 = 0 as libc::c_int as libc::c_double;
                            tmp___33 = format_from(
                                input,
                                pos,
                                fmt_buf as *const libc::c_char,
                                &mut tmp___32 as *mut libc::c_double,
                                &mut off as *mut libc::c_int,
                            );
                            err___3 = tmp___33;
                            if err___3 < 1 as libc::c_int {
                                __constr_expr_885[0 as libc::c_int as usize] = Terminal;
                                __constr_expr_884.items = __constr_expr_885.as_mut_ptr();
                                __constr_expr_886[0 as libc::c_int
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                tmp___34 = 1 as libc::c_uint;
                                while !(tmp___34 >= 32 as libc::c_uint) {
                                    __constr_expr_886[tmp___34
                                        as usize] = 0 as libc::c_int as libc::c_char;
                                    tmp___34 = tmp___34.wrapping_add(1);
                                }
                                tmp___35 = header_init(
                                    __constr_expr_886.as_mut_ptr() as var,
                                    Tuple,
                                    2 as libc::c_int,
                                );
                                tmp___36 = memcpy(
                                    tmp___35 as *mut Tuple as *mut libc::c_void,
                                    &mut __constr_expr_884 as *mut Tuple as *const libc::c_void,
                                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                                );
                                exception_throw(
                                    FormatError,
                                    b"Unable to input Float!\0" as *const u8
                                        as *const libc::c_char,
                                    tmp___36 as *mut Tuple as var,
                                );
                            }
                            pos += off;
                            __constr_expr_887.val = tmp___32;
                            __constr_expr_888[0 as libc::c_int
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___37 = 1 as libc::c_uint;
                            while !(tmp___37 >= 32 as libc::c_uint) {
                                __constr_expr_888[tmp___37
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                tmp___37 = tmp___37.wrapping_add(1);
                            }
                            tmp___38 = header_init(
                                __constr_expr_888.as_mut_ptr() as var,
                                Float,
                                2 as libc::c_int,
                            );
                            tmp___39 = memcpy(
                                tmp___38 as *mut Float as *mut libc::c_void,
                                &mut __constr_expr_887 as *mut Float as *const libc::c_void,
                                ::std::mem::size_of::<Float>() as libc::c_ulong,
                            );
                            assign(a, tmp___39 as *mut Float as var);
                        } else {
                            tmp___40 = 0 as libc::c_int as libc::c_float;
                            tmp___41 = format_from(
                                input,
                                pos,
                                fmt_buf as *const libc::c_char,
                                &mut tmp___40 as *mut libc::c_float,
                                &mut off as *mut libc::c_int,
                            );
                            err___4 = tmp___41;
                            if err___4 < 1 as libc::c_int {
                                __constr_expr_890[0 as libc::c_int as usize] = Terminal;
                                __constr_expr_889.items = __constr_expr_890.as_mut_ptr();
                                __constr_expr_891[0 as libc::c_int
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                tmp___42 = 1 as libc::c_uint;
                                while !(tmp___42 >= 32 as libc::c_uint) {
                                    __constr_expr_891[tmp___42
                                        as usize] = 0 as libc::c_int as libc::c_char;
                                    tmp___42 = tmp___42.wrapping_add(1);
                                }
                                tmp___43 = header_init(
                                    __constr_expr_891.as_mut_ptr() as var,
                                    Tuple,
                                    2 as libc::c_int,
                                );
                                tmp___44 = memcpy(
                                    tmp___43 as *mut Tuple as *mut libc::c_void,
                                    &mut __constr_expr_889 as *mut Tuple as *const libc::c_void,
                                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                                );
                                exception_throw(
                                    FormatError,
                                    b"Unable to input Float!\0" as *const u8
                                        as *const libc::c_char,
                                    tmp___44 as *mut Tuple as var,
                                );
                            }
                            pos += off;
                            __constr_expr_892.val = tmp___40 as libc::c_double;
                            __constr_expr_893[0 as libc::c_int
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___45 = 1 as libc::c_uint;
                            while !(tmp___45 >= 32 as libc::c_uint) {
                                __constr_expr_893[tmp___45
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                tmp___45 = tmp___45.wrapping_add(1);
                            }
                            tmp___46 = header_init(
                                __constr_expr_893.as_mut_ptr() as var,
                                Float,
                                2 as libc::c_int,
                            );
                            tmp___47 = memcpy(
                                tmp___46 as *mut Float as *mut libc::c_void,
                                &mut __constr_expr_892 as *mut Float as *const libc::c_void,
                                ::std::mem::size_of::<Float>() as libc::c_ulong,
                            );
                            assign(a, tmp___47 as *mut Float as var);
                        }
                    } else if *fmt as libc::c_int == 99 as libc::c_int {
                        tmp___49 = '\u{0}' as i32 as libc::c_char;
                        tmp___50 = format_from(
                            input,
                            pos,
                            fmt_buf as *const libc::c_char,
                            &mut tmp___49 as *mut libc::c_char,
                            &mut off as *mut libc::c_int,
                        );
                        err___5 = tmp___50;
                        if err___5 < 1 as libc::c_int {
                            __constr_expr_895[0 as libc::c_int as usize] = Terminal;
                            __constr_expr_894.items = __constr_expr_895.as_mut_ptr();
                            __constr_expr_896[0 as libc::c_int
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___51 = 1 as libc::c_uint;
                            while !(tmp___51 >= 32 as libc::c_uint) {
                                __constr_expr_896[tmp___51
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                tmp___51 = tmp___51.wrapping_add(1);
                            }
                            tmp___52 = header_init(
                                __constr_expr_896.as_mut_ptr() as var,
                                Tuple,
                                2 as libc::c_int,
                            );
                            tmp___53 = memcpy(
                                tmp___52 as *mut Tuple as *mut libc::c_void,
                                &mut __constr_expr_894 as *mut Tuple as *const libc::c_void,
                                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                            );
                            exception_throw(
                                FormatError,
                                b"Unable to input Char!\0" as *const u8
                                    as *const libc::c_char,
                                tmp___53 as *mut Tuple as var,
                            );
                        }
                        pos += off;
                        __constr_expr_897.val = tmp___49 as int64_t;
                        __constr_expr_898[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___54 = 1 as libc::c_uint;
                        while !(tmp___54 >= 32 as libc::c_uint) {
                            __constr_expr_898[tmp___54
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___54 = tmp___54.wrapping_add(1);
                        }
                        tmp___55 = header_init(
                            __constr_expr_898.as_mut_ptr() as var,
                            Int,
                            2 as libc::c_int,
                        );
                        tmp___56 = memcpy(
                            tmp___55 as *mut Int as *mut libc::c_void,
                            &mut __constr_expr_897 as *mut Int as *const libc::c_void,
                            ::std::mem::size_of::<Int>() as libc::c_ulong,
                        );
                        assign(a, tmp___56 as *mut Int as var);
                    } else if *fmt as libc::c_int == 112 as libc::c_int {
                        tmp___57 = 0 as *mut libc::c_void;
                        tmp___58 = format_from(
                            input,
                            pos,
                            fmt_buf as *const libc::c_char,
                            &mut tmp___57 as *mut *mut libc::c_void,
                            &mut off as *mut libc::c_int,
                        );
                        err___6 = tmp___58;
                        if err___6 < 1 as libc::c_int {
                            __constr_expr_900[0 as libc::c_int as usize] = Terminal;
                            __constr_expr_899.items = __constr_expr_900.as_mut_ptr();
                            __constr_expr_901[0 as libc::c_int
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___59 = 1 as libc::c_uint;
                            while !(tmp___59 >= 32 as libc::c_uint) {
                                __constr_expr_901[tmp___59
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                tmp___59 = tmp___59.wrapping_add(1);
                            }
                            tmp___60 = header_init(
                                __constr_expr_901.as_mut_ptr() as var,
                                Tuple,
                                2 as libc::c_int,
                            );
                            tmp___61 = memcpy(
                                tmp___60 as *mut Tuple as *mut libc::c_void,
                                &mut __constr_expr_899 as *mut Tuple as *const libc::c_void,
                                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                            );
                            exception_throw(
                                FormatError,
                                b"Unable to input Ref!\0" as *const u8
                                    as *const libc::c_char,
                                tmp___61 as *mut Tuple as var,
                            );
                        }
                        pos += off;
                        __constr_expr_902.val = tmp___57;
                        __constr_expr_903[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___62 = 1 as libc::c_uint;
                        while !(tmp___62 >= 32 as libc::c_uint) {
                            __constr_expr_903[tmp___62
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___62 = tmp___62.wrapping_add(1);
                        }
                        tmp___63 = header_init(
                            __constr_expr_903.as_mut_ptr() as var,
                            Ref,
                            2 as libc::c_int,
                        );
                        tmp___64 = memcpy(
                            tmp___63 as *mut Ref as *mut libc::c_void,
                            &mut __constr_expr_902 as *mut Ref as *const libc::c_void,
                            ::std::mem::size_of::<Ref>() as libc::c_ulong,
                        );
                        assign(a, tmp___64 as *mut Ref as var);
                    } else {
                        __constr_expr_905[0 as libc::c_int as usize] = Terminal;
                        __constr_expr_904.items = __constr_expr_905.as_mut_ptr();
                        __constr_expr_906[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                        tmp___65 = 1 as libc::c_uint;
                        while !(tmp___65 >= 32 as libc::c_uint) {
                            __constr_expr_906[tmp___65
                                as usize] = 0 as libc::c_int as libc::c_char;
                            tmp___65 = tmp___65.wrapping_add(1);
                        }
                        tmp___66 = header_init(
                            __constr_expr_906.as_mut_ptr() as var,
                            Tuple,
                            2 as libc::c_int,
                        );
                        tmp___67 = memcpy(
                            tmp___66 as *mut Tuple as *mut libc::c_void,
                            &mut __constr_expr_904 as *mut Tuple as *const libc::c_void,
                            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                        );
                        exception_throw(
                            FormatError,
                            b"Invalid Format Specifier!\0" as *const u8
                                as *const libc::c_char,
                            tmp___67 as *mut Tuple as var,
                        );
                    }
                }
            }
            fmt = fmt.offset(1);
        }
    }
    free(fmt_buf as *mut libc::c_void);
    return pos;
}
unsafe extern "C" fn Call_Name() -> *const libc::c_char {
    return b"Call\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Call_Brief() -> *const libc::c_char {
    return b"Callable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Call_Description() -> *const libc::c_char {
    return b"The `Call` class is used by types which can be called as functions.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Call_Definition() -> *const libc::c_char {
    return b"struct Call {\n  var (*call_with)(var, var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___30: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var increment(var args) {\n  struct Int* i = get(args, $I(0));\n  i->val++;\n  return NULL;\n}\n\nvar x = $I(0);\nshow(x); /* 0 */\ncall($(Function, increment), x);\nshow(x); /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Call_Examples() -> *mut Example {
    return examples___30.as_mut_ptr();
}
static mut methods___24: [Method; 2] = [
    {
        let mut init = Method {
            name: b"call\0" as *const u8 as *const libc::c_char,
            definition: b"#define call(self, ...)\nvar call_with(var self, var args);\0"
                as *const u8 as *const libc::c_char,
            description: b"Call the object `self` with arguments `args`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Call_Methods() -> *mut Method {
    return methods___24.as_mut_ptr();
}
static mut __constr_expr_908: Doc = {
    let mut init = Doc {
        name: Some(Call_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Call_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Call_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Call_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Call_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Call_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_907: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Call\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Call>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_908 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Call: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn call_with(mut self_0: var, mut args: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Call,
        &mut (*(0 as *mut Call)).call_with
            as *mut Option::<unsafe extern "C" fn(var, var) -> var> as libc::c_ulong,
        b"call_with\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Call)).call_with).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0, args);
    return tmp___0;
}
unsafe extern "C" fn Function_Name() -> *const libc::c_char {
    return b"Function\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Function_Brief() -> *const libc::c_char {
    return b"Function Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Function_Description() -> *const libc::c_char {
    return b"The `Function` type allows C function pointers to be treated as Cello objects. They can be passed around, stored, and manipulated. Only C functions of the type `var(*)(var)` can be stored as a `Function` type and when called the arguments will be wrapped into an iterable and passed as the first argument, typically in the form of a `tuple`.\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___31: [Example; 4] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var increment(var args) {\n  struct Int* i = get(args, $I(0));\n  i->val++;\n  return NULL;\n}\n\nvar x = $I(0);\nshow(x); /* 0 */\ncall($(Function, increment), x);\nshow(x); /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 2\0" as *const u8 as *const libc::c_char,
            body: b"var hello_person(var args) {\n  print(\"Hello %$!\", get(args, $I(0)));\n  return NULL;\n}\n\ncall($(Function, hello_person), $S(\"Dan\"));\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 3\0" as *const u8 as *const libc::c_char,
            body: b"var add_print(var args) {\n  int64_t fst = c_int(get(args, $I(0)));\n  int64_t snd = c_int(get(args, $I(1)));\n  println(\"%i + %i = %i\", $I(fst), $I(snd), $I(fst+snd));\n  return NULL;\n}\n\ncall($(Function, add_print), $I(10), $I(21));\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Function_Examples() -> *mut Example {
    return examples___31.as_mut_ptr();
}
unsafe extern "C" fn Function_Definition() -> *const libc::c_char {
    return b"struct Function {\n  var (*func)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
unsafe extern "C" fn Function_Call(mut self_0: var, mut args: var) -> var {
    let mut f: *mut Function = 0 as *mut Function;
    let mut tmp: var = 0 as *mut libc::c_void;
    f = self_0 as *mut Function;
    tmp = (Some(((*f).func).expect("non-null function pointer")))
        .expect("non-null function pointer")(args);
    return tmp;
}
static mut __constr_expr_910: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Function_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Function_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Function_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Function_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(Function_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_911: Call = {
    let mut init = Call {
        call_with: Some(Function_Call as unsafe extern "C" fn(var, var) -> var),
    };
    init
};
static mut __constr_expr_909: [var; 36] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Function\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Function>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_910 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Call\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_911 as *const Call as *mut Call as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Function: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn header(mut self_0: var) -> *mut Header {
    return (self_0 as *mut libc::c_char)
        .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
        as *mut Header;
}
pub unsafe extern "C" fn header_init(
    mut head: var,
    mut type_0: var,
    mut alloc___0: libc::c_int,
) -> var {
    let mut self_0: *mut Header = 0 as *mut Header;
    self_0 = head as *mut Header;
    (*self_0).type_0 = type_0;
    (*self_0).alloc = alloc___0 as intptr_t as var;
    (*self_0).magic = 844048 as libc::c_int as var;
    return (self_0 as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Alloc_Name() -> *const libc::c_char {
    return b"Alloc\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Alloc_Brief() -> *const libc::c_char {
    return b"Memory Allocation\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Alloc_Description() -> *const libc::c_char {
    return b"The `Alloc` class can be used to override how memory is allocated for a given data type. By default memory is allocated using `calloc` along with the `Size` class to determine the amount of memory to allocate.\n\nA custom allocator should be careful to also initialise the header for the allocated memory using the function `header_init`. Cello objects without a header wont be recognised as such as so will throw errors when used with Cello functions.\n\nAllocated memory is automatically registered with the garbage collector unless the functions `alloc_raw` and `dealloc_raw` are used.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Alloc_Definition() -> *const libc::c_char {
    return b"struct Alloc {\n  var (*alloc)(void);\n  void (*dealloc)(var);\n};\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___32: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"/* Allocation deallocated by Garbage Collector */\nvar x = alloc(Int);\nconstruct(x, $I(10));\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Avoid Garbage Collection\0" as *const u8 as *const libc::c_char,
            body: b"/* Allocation must be manually deallocated */\nvar x = alloc_raw(Int);\nconstruct(x, $I(10));\ndestruct(x);\ndealloc_raw(x);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Alloc_Examples() -> *mut Example {
    return examples___32.as_mut_ptr();
}
static mut methods___25: [Method; 4] = [
    {
        let mut init = Method {
            name: b"$\0" as *const u8 as *const libc::c_char,
            definition: b"#define $(T, ...)\n#define $I(X)\n#define $F(X)\n#define $S(X)\n#define $R(X)\n#define $B(X)\0"
                as *const u8 as *const libc::c_char,
            description: b"Allocate memory for the given type `T` on the stack and copy in the given arguments `...` as struct members. Shorthand constructors exist for native types:\n\n* `$I -> Int` `$F -> Float` `$S -> String`\n* `$R -> Ref` `$B -> Box`\n\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"alloc\0" as *const u8 as *const libc::c_char,
            definition: b"#define alloc_stack(T)\nvar alloc(var type);\nvar alloc_raw(var type);\nvar alloc_root(var type);\0"
                as *const u8 as *const libc::c_char,
            description: b"Allocate memory for a given `type`. To avoid the Garbage Collector completely use `alloc_raw`, to register the allocation as a root use `alloc_root`. In the case of raw or root allocations the corresponding `dealloc` function should be used when done. Memory allocated with `alloc_stack` is not managed by the Garbage Collector.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"dealloc\0" as *const u8 as *const libc::c_char,
            definition: b"void dealloc(var self);\nvoid dealloc_raw(var self);\nvoid dealloc_root(var self);\0"
                as *const u8 as *const libc::c_char,
            description: b"Deallocate memory for object `self` manually. If registered with the Garbage Collector then entry will be removed. If the `raw` variation is used memory will be deallocated without going via the Garbage Collector.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Alloc_Methods() -> *mut Method {
    return methods___25.as_mut_ptr();
}
static mut __constr_expr_913: Doc = {
    let mut init = Doc {
        name: Some(Alloc_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Alloc_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Alloc_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Alloc_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Alloc_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Alloc_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_912: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Alloc\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Alloc>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_913 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Alloc: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn alloc_by(mut type_0: var, mut method: libc::c_int) -> var {
    let mut a: *mut Alloc = 0 as *mut Alloc;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut self_0: var = 0 as *mut libc::c_void;
    let mut head: *mut Header = 0 as *mut Header;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_914: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_915: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_916: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_917: Int = Int { val: 0 };
    let mut __constr_expr_918: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut __constr_expr_919: Int = Int { val: 0 };
    let mut __constr_expr_920: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    tmp = type_instance(type_0, Alloc);
    a = tmp as *mut Alloc;
    let mut current_block_21: u64;
    if !a.is_null() {
        if ((*a).alloc).is_some() {
            self_0 = (Some(((*a).alloc).expect("non-null function pointer")))
                .expect("non-null function pointer")();
            current_block_21 = 3437258052017859086;
        } else {
            current_block_21 = 5350462347608521337;
        }
    } else {
        current_block_21 = 5350462347608521337;
    }
    match current_block_21 {
        5350462347608521337 => {
            tmp___0 = size(type_0);
            tmp___1 = calloc(
                1 as libc::c_int as size_t,
                (::std::mem::size_of::<Header>() as libc::c_ulong).wrapping_add(tmp___0),
            );
            head = tmp___1 as *mut Header;
            if head as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                __constr_expr_915[0 as libc::c_int as usize] = type_0;
                __constr_expr_915[1 as libc::c_int as usize] = Terminal;
                __constr_expr_914.items = __constr_expr_915.as_mut_ptr();
                __constr_expr_916[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___2 = 1 as libc::c_uint;
                while !(tmp___2 >= 32 as libc::c_uint) {
                    __constr_expr_916[tmp___2
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___2 = tmp___2.wrapping_add(1);
                }
                tmp___3 = header_init(
                    __constr_expr_916.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___4 = memcpy(
                    tmp___3 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_914 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    OutOfMemoryError,
                    b"Cannot create new '%s', out of memory!\0" as *const u8
                        as *const libc::c_char,
                    tmp___4 as *mut Tuple as var,
                );
            }
            self_0 = header_init(head as var, type_0, 3 as libc::c_int);
        }
        _ => {}
    }
    match method {
        0 => {
            __constr_expr_917.val = 0 as libc::c_int as int64_t;
            __constr_expr_918[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = 1 as libc::c_uint;
            while !(tmp___5 >= 32 as libc::c_uint) {
                __constr_expr_918[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___5 = tmp___5.wrapping_add(1);
            }
            tmp___6 = header_init(
                __constr_expr_918.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___7 = memcpy(
                tmp___6 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_917 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___8 = current(GC);
            set(tmp___8, self_0, tmp___7 as *mut Int as var);
        }
        2 => {
            __constr_expr_919.val = 1 as libc::c_int as int64_t;
            __constr_expr_920[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___9 = 1 as libc::c_uint;
            while !(tmp___9 >= 32 as libc::c_uint) {
                __constr_expr_920[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___9 = tmp___9.wrapping_add(1);
            }
            tmp___10 = header_init(
                __constr_expr_920.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___11 = memcpy(
                tmp___10 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_919 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___12 = current(GC);
            set(tmp___12, self_0, tmp___11 as *mut Int as var);
        }
        1 | _ => {}
    }
    return self_0;
}
pub unsafe extern "C" fn alloc(mut type_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = alloc_by(type_0, 0 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn alloc_raw(mut type_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = alloc_by(type_0, 1 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn alloc_root(mut type_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = alloc_by(type_0, 2 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn dealloc(mut self_0: var) {
    let mut a: *mut Alloc = 0 as *mut Alloc;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut __constr_expr_921: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_922: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_923: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_924: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_925: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_926: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: *mut Header = 0 as *mut Header;
    let mut __constr_expr_927: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_928: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_929: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: *mut Header = 0 as *mut Header;
    let mut __constr_expr_930: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_931: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_932: [libc::c_char; 32] = [0; 32];
    let mut tmp___11: libc::c_uint = 0;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: *mut Header = 0 as *mut Header;
    let mut s: size_t = 0;
    let mut tmp___15: var = 0 as *mut libc::c_void;
    let mut tmp___16: size_t = 0;
    let mut i: size_t = 0;
    let mut tmp___17: *mut Header = 0 as *mut Header;
    tmp = instance(self_0, Alloc);
    a = tmp as *mut Alloc;
    if !a.is_null() {
        if ((*a).dealloc).is_some() {
            (Some(((*a).dealloc).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0);
            return;
        }
    }
    if self_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_922[0 as libc::c_int as usize] = Terminal;
        __constr_expr_921.items = __constr_expr_922.as_mut_ptr();
        __constr_expr_923[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_923[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_923.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_921 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ResourceError,
            b"Attempt to deallocate NULL!\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    tmp___6 = header(self_0);
    if (*tmp___6).alloc as libc::c_ulong == 1 as libc::c_int as var as libc::c_ulong {
        __constr_expr_925[0 as libc::c_int as usize] = self_0;
        __constr_expr_925[1 as libc::c_int as usize] = Terminal;
        __constr_expr_924.items = __constr_expr_925.as_mut_ptr();
        __constr_expr_926[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_926[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_926.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_924 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ResourceError,
            b"Attempt to deallocate %$ which was allocated statically!\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
    tmp___10 = header(self_0);
    if (*tmp___10).alloc as libc::c_ulong == 2 as libc::c_int as var as libc::c_ulong {
        __constr_expr_928[0 as libc::c_int as usize] = self_0;
        __constr_expr_928[1 as libc::c_int as usize] = Terminal;
        __constr_expr_927.items = __constr_expr_928.as_mut_ptr();
        __constr_expr_929[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___7 = 1 as libc::c_uint;
        while !(tmp___7 >= 32 as libc::c_uint) {
            __constr_expr_929[tmp___7 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___7 = tmp___7.wrapping_add(1);
        }
        tmp___8 = header_init(
            __constr_expr_929.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___9 = memcpy(
            tmp___8 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_927 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ResourceError,
            b"Attempt to deallocate %$ which was allocated on the stack!\0" as *const u8
                as *const libc::c_char,
            tmp___9 as *mut Tuple as var,
        );
    }
    tmp___14 = header(self_0);
    if (*tmp___14).alloc as libc::c_ulong == 4 as libc::c_int as var as libc::c_ulong {
        __constr_expr_931[0 as libc::c_int as usize] = self_0;
        __constr_expr_931[1 as libc::c_int as usize] = Terminal;
        __constr_expr_930.items = __constr_expr_931.as_mut_ptr();
        __constr_expr_932[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___11 = 1 as libc::c_uint;
        while !(tmp___11 >= 32 as libc::c_uint) {
            __constr_expr_932[tmp___11 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___11 = tmp___11.wrapping_add(1);
        }
        tmp___12 = header_init(
            __constr_expr_932.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___13 = memcpy(
            tmp___12 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_930 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ResourceError,
            b"Attempt to deallocate %$ which was allocated inside a data structure!\0"
                as *const u8 as *const libc::c_char,
            tmp___13 as *mut Tuple as var,
        );
    }
    tmp___15 = type_of(self_0);
    tmp___16 = size(tmp___15);
    s = tmp___16;
    i = 0 as libc::c_int as size_t;
    while i
        < (::std::mem::size_of::<Header>() as libc::c_ulong)
            .wrapping_add(s)
            .wrapping_div(::std::mem::size_of::<var>() as libc::c_ulong)
    {
        tmp___17 = header(self_0);
        let ref mut fresh43 = *(tmp___17 as *mut var).offset(i as isize);
        *fresh43 = 59774918928 as libc::c_long as var;
        i = i.wrapping_add(1);
    }
    free(
        (self_0 as *mut libc::c_char)
            .offset(-(::std::mem::size_of::<Header>() as libc::c_ulong as isize))
            as *mut libc::c_void,
    );
}
pub unsafe extern "C" fn dealloc_raw(mut self_0: var) {
    dealloc(self_0);
}
pub unsafe extern "C" fn dealloc_root(mut self_0: var) {
    dealloc(self_0);
}
unsafe extern "C" fn New_Name() -> *const libc::c_char {
    return b"New\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn New_Brief() -> *const libc::c_char {
    return b"Construction and Destruction\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn New_Description() -> *const libc::c_char {
    return b"The `New` class allows the user to define constructors and destructors for a type, accessible via `new` and `del`. Objects allocated with `new` are allocated on the heap and also registered with the Garbage Collector this means technically it isn't required to call `del` on them as they will be cleaned up at a later date.\n\nThe `new_root` function can be called to register a variable with the Garbage Collector but to indicate that it will be manually destructed with `del_root` by the user. This should be used for variables that wont be reachable by the Garbage Collector such as those in the data segment or only accessible via vanilla C structures.\n\nThe `new_raw` and `del_raw` functions can be called to construct and destruct objects without going via the Garbage Collector.\n\nIt is also possible to simply call the `construct` and `destruct` functions if you wish to construct an already allocated object.\n\nConstructors should assume that memory is zero'd for an object but nothing else.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn New_Definition() -> *const libc::c_char {
    return b"struct New {\n  void (*construct_with)(var, var);\n  void (*destruct)(var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___33: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Int, $I(1));\nshow(x); /* 1 */\nshow(type_of(x)); /* Int */\n\nvar y = alloc(Float);\nconstruct(y, $F(1.0));\nshow(y); /* 1.0 */\ndestruct(y);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn New_Examples() -> *mut Example {
    return examples___33.as_mut_ptr();
}
static mut methods___26: [Method; 5] = [
    {
        let mut init = Method {
            name: b"new\0" as *const u8 as *const libc::c_char,
            definition: b"#define new(T, ...)\n#define new_raw(T, ...)\n#define new_root(T, ...)\nvar new_with(var type, var args);\nvar new_raw_with(var type, var args);\nvar new_root_with(var type, var args);\0"
                as *const u8 as *const libc::c_char,
            description: b"Construct a new object of a given `type`. Use `new_raw` to avoid the Garbage Collector completely, and `new_root` to register the allocation as a Garbage Collection root. In the case of raw and root allocations they must be destructed with the corresponding deletion functions.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"del\0" as *const u8 as *const libc::c_char,
            definition: b"void del(var self);\nvoid del_raw(var self);\nvoid del_root(var self);\0"
                as *const u8 as *const libc::c_char,
            description: b"Destruct the object `self` manually. If registered with the Garbage Collector then entry will be removed. If `del_raw` is used thenthe destruction will be done without going via the Garbage Collector.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"construct\0" as *const u8 as *const libc::c_char,
            definition: b"#define construct(self, ...)\nvar construct_with(var self, var args);\0"
                as *const u8 as *const libc::c_char,
            description: b"Call the constructor on object `self` which has already been allocated.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"destruct\0" as *const u8 as *const libc::c_char,
            definition: b"var destruct(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Call the destructor on object `self` without deallocating the memory for it.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn New_Methods() -> *mut Method {
    return methods___26.as_mut_ptr();
}
static mut __constr_expr_934: Doc = {
    let mut init = Doc {
        name: Some(New_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(New_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            New_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            New_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(New_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(New_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_933: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"New\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<New>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_934 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut New: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn construct_with(mut self_0: var, mut args: var) -> var {
    let mut n: *mut New = 0 as *mut New;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut __constr_expr_935: Int = Int { val: 0 };
    let mut __constr_expr_936: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: size_t = 0;
    tmp = instance(self_0, New);
    n = tmp as *mut New;
    let mut current_block_17: u64;
    if !n.is_null() {
        if ((*n).construct_with).is_some() {
            (Some(((*n).construct_with).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, args);
            current_block_17 = 13797916685926291137;
        } else {
            current_block_17 = 4150394652598716801;
        }
    } else {
        current_block_17 = 4150394652598716801;
    }
    match current_block_17 {
        4150394652598716801 => {
            tmp___4 = len(args);
            if tmp___4 == 1 as libc::c_ulong {
                __constr_expr_935.val = 0 as libc::c_int as int64_t;
                __constr_expr_936[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___0 = 1 as libc::c_uint;
                while !(tmp___0 >= 32 as libc::c_uint) {
                    __constr_expr_936[tmp___0
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___0 = tmp___0.wrapping_add(1);
                }
                tmp___1 = header_init(
                    __constr_expr_936.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___2 = memcpy(
                    tmp___1 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_935 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                tmp___3 = get(args, tmp___2 as *mut Int as var);
                assign(self_0, tmp___3);
            }
        }
        _ => {}
    }
    return self_0;
}
pub unsafe extern "C" fn destruct(mut self_0: var) -> var {
    let mut n: *mut New = 0 as *mut New;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = instance(self_0, New);
    n = tmp as *mut New;
    if !n.is_null() {
        if ((*n).destruct).is_some() {
            (Some(((*n).destruct).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0);
        }
    }
    return self_0;
}
pub unsafe extern "C" fn new_with(mut type_0: var, mut args: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = alloc(type_0);
    tmp___0 = construct_with(tmp, args);
    return tmp___0;
}
pub unsafe extern "C" fn new_raw_with(mut type_0: var, mut args: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = alloc_raw(type_0);
    tmp___0 = construct_with(tmp, args);
    return tmp___0;
}
pub unsafe extern "C" fn new_root_with(mut type_0: var, mut args: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = alloc_root(type_0);
    tmp___0 = construct_with(tmp, args);
    return tmp___0;
}
unsafe extern "C" fn del_by(mut self_0: var, mut method: libc::c_int) {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    match method {
        2 | 0 => {
            tmp = current(GC);
            rem(tmp, self_0);
            return;
        }
        1 | _ => {}
    }
    tmp___0 = destruct(self_0);
    dealloc(tmp___0);
}
pub unsafe extern "C" fn del(mut self_0: var) {
    del_by(self_0, 0 as libc::c_int);
}
pub unsafe extern "C" fn del_raw(mut self_0: var) {
    del_by(self_0, 1 as libc::c_int);
}
pub unsafe extern "C" fn del_root(mut self_0: var) {
    del_by(self_0, 2 as libc::c_int);
}
unsafe extern "C" fn Copy_Name() -> *const libc::c_char {
    return b"Copy\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Copy_Brief() -> *const libc::c_char {
    return b"Copyable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Copy_Description() -> *const libc::c_char {
    return b"The `Copy` class can be used to override the behaviour of an object when a copy is made of it. By default the `Copy` class allocates a new empty object of the same type and uses the `Assign` class to set the contents. The copy is then registered with the Garbage Collector as if it had been constructed with `new`. This means when using manual memory management a copy must be deleted manually.\n\nIf the `copy` class is overridden then the implementer may manually have to register the object with the Garbage Collector if they wish for it to be tracked.\n\nBy convention `copy` follows the semantics of `Assign`, which typically means a _deep copy_ should be made, and that an object will create a copy of all of the sub-objects it references or contains - although this could vary depending on the type's overridden behaviours.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Copy_Definition() -> *const libc::c_char {
    return b"struct Copy {\n  var (*copy)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___34: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(String, $S(\"Hello\"));\nvar y = copy(x);\nshow(x); /* Hello */\nshow(y); /* Hello */\nshow($I(eq(x, y))); /* 1 */\nshow($I(x is y)); /* 0 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Copy_Examples() -> *mut Example {
    return examples___34.as_mut_ptr();
}
static mut methods___27: [Method; 2] = [
    {
        let mut init = Method {
            name: b"copy\0" as *const u8 as *const libc::c_char,
            definition: b"var copy(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Make a copy of the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Copy_Methods() -> *mut Method {
    return methods___27.as_mut_ptr();
}
static mut __constr_expr_938: Doc = {
    let mut init = Doc {
        name: Some(Copy_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Copy_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Copy_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Copy_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Copy_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Copy_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_937: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Copy\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Copy_0>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_938 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Copy: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn copy(mut self_0: var) -> var {
    let mut c: *mut Copy_0 = 0 as *mut Copy_0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    tmp = instance(self_0, Copy);
    c = tmp as *mut Copy_0;
    if !c.is_null() {
        if ((*c).copy).is_some() {
            tmp___0 = (Some(((*c).copy).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0);
            return tmp___0;
        }
    }
    tmp___1 = type_of(self_0);
    tmp___2 = alloc(tmp___1);
    tmp___3 = assign(tmp___2, self_0);
    return tmp___3;
}
unsafe extern "C" fn Concat_Name() -> *const libc::c_char {
    return b"Concat\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Concat_Brief() -> *const libc::c_char {
    return b"Concatenate Objects\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Concat_Description() -> *const libc::c_char {
    return b"The `Concat` class is implemented by objects that can have other objects either _appended_ to their, on _concatenated_ to them. For example collections or strings.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Concat_Definition() -> *const libc::c_char {
    return b"struct Concat {\n  void (*concat)(var, var);\n  void (*append)(var, var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___35: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Float, $F(9.9), $F(2.8));\nvar y = new(Array, Float, $F(1.1), $F(6.5));\n\nshow(x); /* <'Array' At 0x00414603 [9.9, 2.8]> */\nshow(y); /* <'Array' At 0x00414603 [1.1, 6.5]> */\nappend(x, $F(2.5));\nshow(x); /* <'Array' At 0x00414603 [9.9, 2.8, 2.5]> */\nconcat(x, y);\nshow(x); /* <'Array' At 0x00414603 [9.9, 2.8, 2.5, 1.1, 6.5]> */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Concat_Examples() -> *mut Example {
    return examples___35.as_mut_ptr();
}
static mut methods___28: [Method; 3] = [
    {
        let mut init = Method {
            name: b"append\0" as *const u8 as *const libc::c_char,
            definition: b"void append(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Append the object `obj` to the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"concat\0" as *const u8 as *const libc::c_char,
            definition: b"void concat(var self, var obj);\0" as *const u8
                as *const libc::c_char,
            description: b"Concatenate the object `obj` to the object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Concat_Methods() -> *mut Method {
    return methods___28.as_mut_ptr();
}
static mut __constr_expr_940: Doc = {
    let mut init = Doc {
        name: Some(Concat_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Concat_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Concat_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Concat_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Concat_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Concat_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_939: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Concat\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Concat>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_940 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Concat: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn append(mut self_0: var, mut obj: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Concat,
        &mut (*(0 as *mut Concat)).append
            as *mut Option::<unsafe extern "C" fn(var, var) -> ()> as libc::c_ulong,
        b"append\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Concat)).append).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, obj);
}
pub unsafe extern "C" fn concat(mut self_0: var, mut obj: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Concat,
        &mut (*(0 as *mut Concat)).concat
            as *mut Option::<unsafe extern "C" fn(var, var) -> ()> as libc::c_ulong,
        b"concat\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Concat)).concat).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, obj);
}
unsafe extern "C" fn C_Int_Name() -> *const libc::c_char {
    return b"C_Int\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Int_Brief() -> *const libc::c_char {
    return b"Interpret as C Integer\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Int_Description() -> *const libc::c_char {
    return b"The `C_Int` class should be overridden by types which are representable as a C style Integer of the type `int64_t`.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Int_Definition() -> *const libc::c_char {
    return b"struct C_Int {\n  int64_t (*c_int)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___36: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"printf(\"%li\", c_int($I(5))); /* 5 */\nprintf(\"%li\", c_int($I(6))); /* 6 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn C_Int_Examples() -> *mut Example {
    return examples___36.as_mut_ptr();
}
static mut methods___29: [Method; 2] = [
    {
        let mut init = Method {
            name: b"c_int\0" as *const u8 as *const libc::c_char,
            definition: b"int64_t c_int(var self);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns the object `self` represented as a `int64_t`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn C_Int_Methods() -> *mut Method {
    return methods___29.as_mut_ptr();
}
static mut __constr_expr_942: Doc = {
    let mut init = Doc {
        name: Some(C_Int_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(C_Int_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            C_Int_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            C_Int_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(C_Int_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(C_Int_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_941: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"C_Int\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<C_Int>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_942 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut C_Int: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn C_Float_Name() -> *const libc::c_char {
    return b"C_Float\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Float_Brief() -> *const libc::c_char {
    return b"Interpret as C Float\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Float_Description() -> *const libc::c_char {
    return b"The `C_Float` class should be overridden by types which are representable as a C style Float of the type `double`.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn C_Float_Definition() -> *const libc::c_char {
    return b"struct C_Float {\n  double (*c_float)(var);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___37: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"printf(\"%f\", c_float($F(5.1))); /* 5.1 */\nprintf(\"%f\", c_float($F(6.2))); /* 6.2 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn C_Float_Examples() -> *mut Example {
    return examples___37.as_mut_ptr();
}
static mut methods___30: [Method; 2] = [
    {
        let mut init = Method {
            name: b"c_float\0" as *const u8 as *const libc::c_char,
            definition: b"double c_float(var self);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns the object `self` represented as a `double`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn C_Float_Methods() -> *mut Method {
    return methods___30.as_mut_ptr();
}
static mut __constr_expr_944: Doc = {
    let mut init = Doc {
        name: Some(C_Float_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(C_Float_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            C_Float_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            C_Float_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(C_Float_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(C_Float_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_943: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"C_Float\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<C_Float>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_944 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut C_Float: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn c_int(mut self_0: var) -> int64_t {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: int64_t = 0;
    tmp = type_of(self_0);
    if tmp as libc::c_ulong == Int as libc::c_ulong {
        return (*(self_0 as *mut Int)).val;
    }
    tmp___0 = method_at_offset(
        self_0,
        C_Int,
        &mut (*(0 as *mut C_Int)).c_int
            as *mut Option::<unsafe extern "C" fn(var) -> int64_t> as libc::c_ulong,
        b"c_int\0" as *const u8 as *const libc::c_char,
    );
    tmp___1 = (Some(
        ((*(tmp___0 as *mut C_Int)).c_int).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___1;
}
pub unsafe extern "C" fn c_float(mut self_0: var) -> libc::c_double {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_double = 0.;
    tmp = type_of(self_0);
    if tmp as libc::c_ulong == Float as libc::c_ulong {
        return (*(self_0 as *mut Float)).val;
    }
    tmp___0 = method_at_offset(
        self_0,
        C_Float,
        &mut (*(0 as *mut C_Float)).c_float
            as *mut Option::<unsafe extern "C" fn(var) -> libc::c_double>
            as libc::c_ulong,
        b"c_float\0" as *const u8 as *const libc::c_char,
    );
    tmp___1 = (Some(
        ((*(tmp___0 as *mut C_Float)).c_float).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___1;
}
unsafe extern "C" fn Int_Name() -> *const libc::c_char {
    return b"Int\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Int_Brief() -> *const libc::c_char {
    return b"Integer Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Int_Description() -> *const libc::c_char {
    return b"64-bit signed integer Object.\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Int_Definition() -> *const libc::c_char {
    return b"struct Int {\n  int64_t val;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___38: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var i0 = $(Int, 1);\nvar i1 = new(Int, $I(24313));\nvar i2 = copy(i0);\n\nshow(i0); /*     1 */\nshow(i1); /* 24313 */\nshow(i2); /*     1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Int_Examples() -> *mut Example {
    return examples___38.as_mut_ptr();
}
unsafe extern "C" fn Int_Assign(mut self_0: var, mut obj: var) {
    let mut i: *mut Int = 0 as *mut Int;
    i = self_0 as *mut Int;
    (*i).val = c_int(obj);
}
unsafe extern "C" fn Int_C_Int(mut self_0: var) -> int64_t {
    let mut i: *mut Int = 0 as *mut Int;
    i = self_0 as *mut Int;
    return (*i).val;
}
unsafe extern "C" fn Int_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut tmp: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    tmp = Int_C_Int(self_0);
    tmp___0 = c_int(obj);
    return (tmp - tmp___0) as libc::c_int;
}
unsafe extern "C" fn Int_Hash(mut self_0: var) -> uint64_t {
    let mut tmp: int64_t = 0;
    tmp = c_int(self_0);
    return tmp as uint64_t;
}
unsafe extern "C" fn Int_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut __constr_expr_945: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_946: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_947: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_946[0 as libc::c_int as usize] = self_0;
    __constr_expr_946[1 as libc::c_int as usize] = Terminal;
    __constr_expr_945.items = __constr_expr_946.as_mut_ptr();
    __constr_expr_947[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_947[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_947.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_945 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = print_to_with(
        output,
        pos,
        b"%li\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    return tmp___2;
}
unsafe extern "C" fn Int_Look(
    mut self_0: var,
    mut input: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut __constr_expr_948: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_949: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_950: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_949[0 as libc::c_int as usize] = self_0;
    __constr_expr_949[1 as libc::c_int as usize] = Terminal;
    __constr_expr_948.items = __constr_expr_949.as_mut_ptr();
    __constr_expr_950[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_950[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_950.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_948 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = scan_from_with(
        input,
        pos,
        b"%li\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    return tmp___2;
}
static mut __constr_expr_952: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Int_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Int_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Int_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Int_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(Int_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_953: Assign = {
    let mut init = Assign {
        assign: Some(Int_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_954: Cmp = {
    let mut init = Cmp {
        cmp: Some(Int_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_955: Hash = {
    let mut init = Hash {
        hash: Some(Int_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_956: C_Int = {
    let mut init = C_Int {
        c_int: Some(Int_C_Int as unsafe extern "C" fn(var) -> int64_t),
    };
    init
};
static mut __constr_expr_957: Show = {
    let mut init = Show {
        show: Some(
            Int_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
        look: Some(
            Int_Look as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_951: [var; 48] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Int\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Int>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_952 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_953 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_954 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_955 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"C_Int\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_956 as *const C_Int as *mut C_Int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_957 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Int: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Float_Name() -> *const libc::c_char {
    return b"Float\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Float_Brief() -> *const libc::c_char {
    return b"Floating Point Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Float_Description() -> *const libc::c_char {
    return b"64-bit double precision float point Object.\0" as *const u8
        as *const libc::c_char;
}
unsafe extern "C" fn Float_Definition() -> *const libc::c_char {
    return b"struct Float {\n  double val;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___39: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var f0 = $(Float, 1.0);\nvar f1 = new(Float, $F(24.313));\nvar f2 = copy(f0);\n\nshow(f0); /*  1.000 */\nshow(f1); /* 24.313 */\nshow(f2); /*  1.000 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Float_Examples() -> *mut Example {
    return examples___39.as_mut_ptr();
}
unsafe extern "C" fn Float_Assign(mut self_0: var, mut obj: var) {
    let mut f: *mut Float = 0 as *mut Float;
    f = self_0 as *mut Float;
    (*f).val = c_float(obj);
}
unsafe extern "C" fn Float_C_Float(mut self_0: var) -> libc::c_double {
    let mut f: *mut Float = 0 as *mut Float;
    f = self_0 as *mut Float;
    return (*f).val;
}
unsafe extern "C" fn Float_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut c: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = Float_C_Float(self_0);
    tmp___0 = c_float(obj);
    c = tmp - tmp___0;
    if c > 0 as libc::c_int as libc::c_double {
        tmp___2 = 1 as libc::c_int;
    } else {
        if c < 0 as libc::c_int as libc::c_double {
            tmp___1 = -(1 as libc::c_int);
        } else {
            tmp___1 = 0 as libc::c_int;
        }
        tmp___2 = tmp___1;
    }
    return tmp___2;
}
unsafe extern "C" fn Float_Hash(mut self_0: var) -> uint64_t {
    let mut ic: interp_cast = interp_cast { as_flt: 0. };
    ic.as_flt = c_float(self_0);
    return ic.as_int;
}
pub unsafe extern "C" fn Float_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut __constr_expr_958: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_959: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_960: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_959[0 as libc::c_int as usize] = self_0;
    __constr_expr_959[1 as libc::c_int as usize] = Terminal;
    __constr_expr_958.items = __constr_expr_959.as_mut_ptr();
    __constr_expr_960[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_960[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_960.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_958 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = print_to_with(
        output,
        pos,
        b"%f\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    return tmp___2;
}
pub unsafe extern "C" fn Float_Look(
    mut self_0: var,
    mut input: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut __constr_expr_961: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_962: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_963: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    __constr_expr_962[0 as libc::c_int as usize] = self_0;
    __constr_expr_962[1 as libc::c_int as usize] = Terminal;
    __constr_expr_961.items = __constr_expr_962.as_mut_ptr();
    __constr_expr_963[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_963[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_963.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_961 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___2 = scan_from_with(
        input,
        pos,
        b"%f\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    return tmp___2;
}
static mut __constr_expr_965: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Float_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Float_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Float_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Float_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(Float_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_966: Assign = {
    let mut init = Assign {
        assign: Some(Float_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_967: Cmp = {
    let mut init = Cmp {
        cmp: Some(Float_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_968: Hash = {
    let mut init = Hash {
        hash: Some(Float_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_969: C_Float = {
    let mut init = C_Float {
        c_float: Some(Float_C_Float as unsafe extern "C" fn(var) -> libc::c_double),
    };
    init
};
static mut __constr_expr_970: Show = {
    let mut init = Show {
        show: Some(
            Float_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
        look: Some(
            Float_Look as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_964: [var; 48] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Float\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Float>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_965 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_966 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_967 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_968 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"C_Float\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_969 as *const C_Float as *mut C_Float as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_970 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Float: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Start_Name() -> *const libc::c_char {
    return b"Start\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Start_Brief() -> *const libc::c_char {
    return b"Can be started or stopped\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Start_Description() -> *const libc::c_char {
    return b"The `Start` class can be implemented by types which provide an abstract notion of a started and stopped state. This can be real processes such as `Thread`, or something like `File` where the on/off correspond to if the file is open or not.\n\nThe main nicety of the `Start` class is that it allows use of the `with` macro which performs the `start` function at the opening of a scope block and the `stop` function at the end.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Start_Definition() -> *const libc::c_char {
    return b"struct Start {\n  void (*start)(var);\n  void (*stop)(var);\n  void (*join)(var);\n  bool (*running)(var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___40: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Mutex);\nstart(x); /* Lock Mutex */ \nprint(\"Inside Mutex!\\n\");\nstop(x); /* unlock Mutex */\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Scoped\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Mutex);\nwith (mut in x) { /* Lock Mutex */ \n  print(\"Inside Mutex!\\n\");\n} /* unlock Mutex */\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Start_Examples() -> *mut Example {
    return examples___40.as_mut_ptr();
}
static mut methods___31: [Method; 6] = [
    {
        let mut init = Method {
            name: b"with\0" as *const u8 as *const libc::c_char,
            definition: b"#define with(...)\0" as *const u8 as *const libc::c_char,
            description: b"Perform operations in between `start` and `stop`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"start\0" as *const u8 as *const libc::c_char,
            definition: b"void start(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Start the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"stop\0" as *const u8 as *const libc::c_char,
            definition: b"void stop(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Stop the object `self`.\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"join\0" as *const u8 as *const libc::c_char,
            definition: b"void join(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Block and wait for the object `self` to stop.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"running\0" as *const u8 as *const libc::c_char,
            definition: b"bool running(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Check if the object `self` is running.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Start_Methods() -> *mut Method {
    return methods___31.as_mut_ptr();
}
static mut __constr_expr_972: Doc = {
    let mut init = Doc {
        name: Some(Start_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Start_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Start_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Start_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Start_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Start_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_971: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Start>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_972 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Start: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn start(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Start,
        &mut (*(0 as *mut Start)).start as *mut Option::<unsafe extern "C" fn(var) -> ()>
            as libc::c_ulong,
        b"start\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Start)).start).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn stop(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Start,
        &mut (*(0 as *mut Start)).stop as *mut Option::<unsafe extern "C" fn(var) -> ()>
            as libc::c_ulong,
        b"stop\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Start)).stop).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn join(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Start,
        &mut (*(0 as *mut Start)).join as *mut Option::<unsafe extern "C" fn(var) -> ()>
            as libc::c_ulong,
        b"join\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Start)).join).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn running(mut self_0: var) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = method_at_offset(
        self_0,
        Start,
        &mut (*(0 as *mut Start)).running
            as *mut Option::<unsafe extern "C" fn(var) -> bool> as libc::c_ulong,
        b"running\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Start)).running).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn start_in(mut self_0: var) -> var {
    let mut s: *mut Start = 0 as *mut Start;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = instance(self_0, Start);
    s = tmp as *mut Start;
    if !s.is_null() {
        if ((*s).start).is_some() {
            (Some(((*s).start).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0);
        }
    }
    return self_0;
}
pub unsafe extern "C" fn stop_in(mut self_0: var) -> var {
    let mut s: *mut Start = 0 as *mut Start;
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = instance(self_0, Start);
    s = tmp as *mut Start;
    if !s.is_null() {
        if ((*s).stop).is_some() {
            (Some(((*s).stop).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0);
        }
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn Current_Name() -> *const libc::c_char {
    return b"Current\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Current_Brief() -> *const libc::c_char {
    return b"Implicit Object\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Current_Description() -> *const libc::c_char {
    return b"The `Current` class can be implemented by types which have implicit instances associated with them. For example it can be used to retrieve the _current_ `Thread`, or it could be used to get the _current_ Garbage Collector.\n\nThis class may be implemented by types which express the [Singleton Design Pattern](http://en.wikipedia.org/wiki/Singleton_pattern)\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Current_Definition() -> *const libc::c_char {
    return b"struct Current {\n  var (*current)(void);\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___41: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var gc = current(GC);\nshow(gc);\nvar thread = current(Thread);\nshow(thread);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Current_Examples() -> *mut Example {
    return examples___41.as_mut_ptr();
}
static mut methods___32: [Method; 2] = [
    {
        let mut init = Method {
            name: b"current\0" as *const u8 as *const libc::c_char,
            definition: b"var current(var type);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the current active object of the given `type`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Current_Methods() -> *mut Method {
    return methods___32.as_mut_ptr();
}
static mut __constr_expr_974: Doc = {
    let mut init = Doc {
        name: Some(Current_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Current_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Current_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Current_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Current_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Current_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_973: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Current\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Current>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_974 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Current: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn current(mut type_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = type_method_at_offset(
        type_0,
        Current,
        &mut (*(0 as *mut Current)).current
            as *mut Option::<unsafe extern "C" fn() -> var> as libc::c_ulong,
        b"current\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Current)).current).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")();
    return tmp___0;
}
unsafe extern "C" fn Thread_Name() -> *const libc::c_char {
    return b"Thread\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Thread_Brief() -> *const libc::c_char {
    return b"Concurrent Execution\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Thread_Description() -> *const libc::c_char {
    return b"The `Thread` type provides a basic primitive for concurrent execution. It acts as a basic wrapper around operating system threads, using WinThreads on Windows and pthreads otherwise.\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___42: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var set_value(var args) {\n  assign(get(args, $I(0)), $I(1));\n  return NULL;\n}\n\nvar i = $I(0);\n\nvar x = new(Thread, $(Function, set_value));\ncall(x, i);\njoin(x);\n\nshow(i); /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Exclusive Resource\0" as *const u8 as *const libc::c_char,
            body: b"var increment(var args) {\n  var mut = get(args, $I(0));\n  var tot = get(args, $I(1));\n  lock(mut);\n  assign(tot, $I(c_int(tot)+1));\n  unlock(mut);\n  return NULL;\n}\n\nvar mutex = new(Mutex);\nvar total = $I(0);\n\nvar threads = new(Array, Box,\n  new(Thread, $(Function, increment)),\n  new(Thread, $(Function, increment)),\n  new(Thread, $(Function, increment)));\n\nshow(total); /* 0 */\n\nforeach (t in threads) {\n  call(deref(t), mutex, total);\n}\n\nforeach (t in threads) {\n  join(deref(t));\n}\n\nshow(total); /* 3 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Thread_Examples() -> *mut Example {
    return examples___42.as_mut_ptr();
}
unsafe extern "C" fn Thread_New(mut self_0: var, mut args: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut __constr_expr_975: Int = Int { val: 0 };
    let mut __constr_expr_976: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: bool = false;
    let mut __constr_expr_977: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_978: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_979: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    tmp___4 = empty(args);
    if tmp___4 {
        (*t).func = 0 as *mut libc::c_void;
    } else {
        __constr_expr_975.val = 0 as libc::c_int as int64_t;
        __constr_expr_976[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_976[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_976.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_975 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___3 = get(args, tmp___2 as *mut Int as var);
        (*t).func = tmp___3;
    }
    (*t).args = 0 as *mut libc::c_void;
    (*t).is_main = 0 as libc::c_int != 0;
    (*t).is_running = 0 as libc::c_int != 0;
    __constr_expr_978[0 as libc::c_int as usize] = String;
    __constr_expr_978[1 as libc::c_int as usize] = Ref;
    __constr_expr_978[2 as libc::c_int as usize] = Terminal;
    __constr_expr_977.items = __constr_expr_978.as_mut_ptr();
    __constr_expr_979[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___5 = 1 as libc::c_uint;
    while !(tmp___5 >= 32 as libc::c_uint) {
        __constr_expr_979[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = tmp___5.wrapping_add(1);
    }
    tmp___6 = header_init(
        __constr_expr_979.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___7 = memcpy(
        tmp___6 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_977 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___8 = new_raw_with(Table, tmp___7 as *mut Tuple as var);
    (*t).tls = tmp___8 as *mut Table as var;
}
unsafe extern "C" fn Thread_Del(mut self_0: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    t = self_0 as *mut Thread;
    if (*t).args as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        del_raw((*t).args);
    }
    del_raw((*t).tls);
}
unsafe extern "C" fn Thread_C_Int(mut self_0: var) -> int64_t {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut __constr_expr_980: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_981: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_982: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    if !(*t).is_running {
        __constr_expr_981[0 as libc::c_int as usize] = Terminal;
        __constr_expr_980.items = __constr_expr_981.as_mut_ptr();
        __constr_expr_982[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_982[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_982.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_980 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Cannot get thread ID, thread not running!\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    return (*t).thread as int64_t;
}
unsafe extern "C" fn Thread_Assign(mut self_0: var, mut obj: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut o: *mut Thread = 0 as *mut Thread;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    tmp = cast(obj, Thread);
    o = tmp as *mut Thread;
    (*t).func = (*o).func;
    if !((*t).tls).is_null() {
        (*t).tls = (*t).tls;
    } else {
        tmp___0 = alloc_raw(Table);
        (*t).tls = tmp___0;
    }
    assign((*t).tls, (*o).tls);
}
unsafe extern "C" fn Thread_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut tmp: int64_t = 0;
    let mut tmp___0: int64_t = 0;
    tmp = Thread_C_Int(self_0);
    tmp___0 = c_int(obj);
    return (tmp - tmp___0) as libc::c_int;
}
unsafe extern "C" fn Thread_Hash(mut self_0: var) -> uint64_t {
    let mut tmp: int64_t = 0;
    tmp = Thread_C_Int(self_0);
    return tmp as uint64_t;
}
static mut Thread_TLS_Key_Created: bool = 0 as libc::c_int != 0;
static mut Thread_Key_Wrapper: pthread_key_t = 0;
unsafe extern "C" fn Thread_TLS_Key_Create() {
    pthread_key_create(
        &mut Thread_Key_Wrapper,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        >(0 as *mut libc::c_void),
    );
}
unsafe extern "C" fn Thread_TLS_Key_Delete() {
    pthread_key_delete(Thread_Key_Wrapper);
}
unsafe extern "C" fn Thread_Init_Run(mut self_0: var) -> var {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut bottom: var = 0 as *mut libc::c_void;
    let mut gc: var = 0 as *mut libc::c_void;
    let mut __constr_expr_983: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_984: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_985: Ref = Ref { val: 0 as *mut libc::c_void };
    let mut __constr_expr_986: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_987: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut exc: var = 0 as *mut libc::c_void;
    let mut __constr_expr_988: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_989: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_990: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut x: var = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    pthread_setspecific(Thread_Key_Wrapper, t as *const libc::c_void);
    (*t).is_running = 1 as libc::c_int != 0;
    bottom = 0 as *mut libc::c_void;
    __constr_expr_985.val = &mut bottom as *mut var as var;
    __constr_expr_986[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_986[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_986.as_mut_ptr() as var, Ref, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Ref as *mut libc::c_void,
        &mut __constr_expr_985 as *mut Ref as *const libc::c_void,
        ::std::mem::size_of::<Ref>() as libc::c_ulong,
    );
    __constr_expr_984[0 as libc::c_int as usize] = tmp___1 as *mut Ref as var;
    __constr_expr_984[1 as libc::c_int as usize] = Terminal;
    __constr_expr_983.items = __constr_expr_984.as_mut_ptr();
    __constr_expr_987[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___2 = 1 as libc::c_uint;
    while !(tmp___2 >= 32 as libc::c_uint) {
        __constr_expr_987[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = tmp___2.wrapping_add(1);
    }
    tmp___3 = header_init(
        __constr_expr_987.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___4 = memcpy(
        tmp___3 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_983 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___5 = new_raw_with(GC, tmp___4 as *mut Tuple as var);
    gc = tmp___5 as *mut GC as var;
    __constr_expr_989[0 as libc::c_int as usize] = Terminal;
    __constr_expr_988.items = __constr_expr_989.as_mut_ptr();
    __constr_expr_990[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___6 = 1 as libc::c_uint;
    while !(tmp___6 >= 32 as libc::c_uint) {
        __constr_expr_990[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = tmp___6.wrapping_add(1);
    }
    tmp___7 = header_init(
        __constr_expr_990.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___8 = memcpy(
        tmp___7 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_988 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___9 = new_raw_with(Exception, tmp___8 as *mut Tuple as var);
    exc = tmp___9 as *mut Exception as var;
    tmp___10 = call_with((*t).func, (*t).args);
    x = tmp___10;
    del_raw((*t).args);
    (*t).args = 0 as *mut libc::c_void;
    del_raw(exc);
    del_raw(gc);
    return x;
}
unsafe extern "C" fn Thread_Call(mut self_0: var, mut args: var) -> var {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut err: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut __constr_expr_991: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_992: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_993: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_994: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_995: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_996: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_997: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_998: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_999: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    tmp = type_of(args);
    tmp___0 = alloc_raw(tmp);
    (*t).args = assign(tmp___0, args);
    if !Thread_TLS_Key_Created {
        Thread_TLS_Key_Create();
        Thread_TLS_Key_Created = 1 as libc::c_int != 0;
        atexit(Some(Thread_TLS_Key_Delete as unsafe extern "C" fn() -> ()));
    }
    tmp___1 = pthread_create(
        &mut (*t).thread as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        Some(Thread_Init_Run as unsafe extern "C" fn(var) -> var),
        t as *mut libc::c_void,
    );
    err = tmp___1;
    if err == 22 as libc::c_int {
        __constr_expr_992[0 as libc::c_int as usize] = Terminal;
        __constr_expr_991.items = __constr_expr_992.as_mut_ptr();
        __constr_expr_993[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___2 = 1 as libc::c_uint;
        while !(tmp___2 >= 32 as libc::c_uint) {
            __constr_expr_993[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = tmp___2.wrapping_add(1);
        }
        tmp___3 = header_init(
            __constr_expr_993.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___4 = memcpy(
            tmp___3 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_991 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Argument to Thread Creation\0" as *const u8 as *const libc::c_char,
            tmp___4 as *mut Tuple as var,
        );
    }
    if err == 11 as libc::c_int {
        __constr_expr_995[0 as libc::c_int as usize] = Terminal;
        __constr_expr_994.items = __constr_expr_995.as_mut_ptr();
        __constr_expr_996[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___5 = 1 as libc::c_uint;
        while !(tmp___5 >= 32 as libc::c_uint) {
            __constr_expr_996[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = tmp___5.wrapping_add(1);
        }
        tmp___6 = header_init(
            __constr_expr_996.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___7 = memcpy(
            tmp___6 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_994 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Not enough resources to create another Thread\0" as *const u8
                as *const libc::c_char,
            tmp___7 as *mut Tuple as var,
        );
    }
    if err == 16 as libc::c_int {
        __constr_expr_998[0 as libc::c_int as usize] = Terminal;
        __constr_expr_997.items = __constr_expr_998.as_mut_ptr();
        __constr_expr_999[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___8 = 1 as libc::c_uint;
        while !(tmp___8 >= 32 as libc::c_uint) {
            __constr_expr_999[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = tmp___8.wrapping_add(1);
        }
        tmp___9 = header_init(
            __constr_expr_999.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___10 = memcpy(
            tmp___9 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_997 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            BusyError,
            b"System is too busy to create thread\0" as *const u8 as *const libc::c_char,
            tmp___10 as *mut Tuple as var,
        );
    }
    return self_0;
}
static mut Thread_Main: var = 0 as *const libc::c_void as *mut libc::c_void;
static mut Exception_Main: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Thread_Main_Del() {
    del_raw(Exception_Main);
    del_raw(Thread_Main);
}
unsafe extern "C" fn Thread_Current() -> var {
    let mut wrapper: var = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1000: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1001: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1002: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1003: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1004: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1005: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut t: *mut Thread = 0 as *mut Thread;
    if !Thread_TLS_Key_Created {
        Thread_TLS_Key_Create();
        Thread_TLS_Key_Created = 1 as libc::c_int != 0;
        atexit(Some(Thread_TLS_Key_Delete as unsafe extern "C" fn() -> ()));
    }
    tmp = pthread_getspecific(Thread_Key_Wrapper);
    wrapper = tmp;
    if wrapper as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if Thread_Main as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            __constr_expr_1001[0 as libc::c_int as usize] = Terminal;
            __constr_expr_1000.items = __constr_expr_1001.as_mut_ptr();
            __constr_expr_1002[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = 1 as libc::c_uint;
            while !(tmp___0 >= 32 as libc::c_uint) {
                __constr_expr_1002[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___0 = tmp___0.wrapping_add(1);
            }
            tmp___1 = header_init(
                __constr_expr_1002.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___2 = memcpy(
                tmp___1 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1000 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            tmp___3 = new_raw_with(Thread, tmp___2 as *mut Tuple as var);
            Thread_Main = tmp___3 as *mut Thread as var;
            __constr_expr_1004[0 as libc::c_int as usize] = Terminal;
            __constr_expr_1003.items = __constr_expr_1004.as_mut_ptr();
            __constr_expr_1005[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = 1 as libc::c_uint;
            while !(tmp___4 >= 32 as libc::c_uint) {
                __constr_expr_1005[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___4 = tmp___4.wrapping_add(1);
            }
            tmp___5 = header_init(
                __constr_expr_1005.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___6 = memcpy(
                tmp___5 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1003 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            tmp___7 = new_raw_with(Exception, tmp___6 as *mut Tuple as var);
            Exception_Main = tmp___7 as *mut Exception as var;
            atexit(Some(Thread_Main_Del as unsafe extern "C" fn() -> ()));
        }
        t = Thread_Main as *mut Thread;
        (*t).is_main = 1 as libc::c_int != 0;
        (*t).is_running = 1 as libc::c_int != 0;
        (*t).thread = pthread_self();
        return Thread_Main;
    }
    return wrapper;
}
unsafe extern "C" fn Thread_Start(mut self_0: var) {
    let mut __constr_expr_1006: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1007: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1008: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    __constr_expr_1007[0 as libc::c_int as usize] = Terminal;
    __constr_expr_1006.items = __constr_expr_1007.as_mut_ptr();
    __constr_expr_1008[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1008[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_1008.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_1006 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    call_with(self_0, tmp___1 as *mut Tuple as var);
}
unsafe extern "C" fn Thread_Stop(mut self_0: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_1009: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1010: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1011: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1012: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1013: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1014: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    if (*t).thread == 0 {
        return;
    }
    tmp = pthread_kill((*t).thread, 2 as libc::c_int);
    err = tmp;
    if err == 22 as libc::c_int {
        __constr_expr_1010[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1009.items = __constr_expr_1010.as_mut_ptr();
        __constr_expr_1011[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1011[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1011.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1009 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Argument to Thread Stop\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    if err == 3 as libc::c_int {
        __constr_expr_1013[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1012.items = __constr_expr_1013.as_mut_ptr();
        __constr_expr_1014[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1014[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1014.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1012 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Thread\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn Thread_Join(mut self_0: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_1015: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1016: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1017: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1018: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1019: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1020: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    if (*t).thread == 0 {
        return;
    }
    tmp = pthread_join((*t).thread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
    err = tmp;
    if err == 22 as libc::c_int {
        __constr_expr_1016[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1015.items = __constr_expr_1016.as_mut_ptr();
        __constr_expr_1017[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1017[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1017.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1015 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Argument to Thread Join\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    if err == 3 as libc::c_int {
        __constr_expr_1019[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1018.items = __constr_expr_1019.as_mut_ptr();
        __constr_expr_1020[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1020[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1020.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1018 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Thread\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn Thread_Running(mut self_0: var) -> bool {
    let mut t: *mut Thread = 0 as *mut Thread;
    t = self_0 as *mut Thread;
    return (*t).is_running;
}
unsafe extern "C" fn Thread_Get(mut self_0: var, mut key: var) -> var {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    tmp = get((*t).tls, key);
    tmp___0 = deref(tmp);
    return tmp___0;
}
unsafe extern "C" fn Thread_Set(mut self_0: var, mut key: var, mut val: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut __constr_expr_1021: Ref = Ref { val: 0 as *mut libc::c_void };
    let mut __constr_expr_1022: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    t = self_0 as *mut Thread;
    __constr_expr_1021.val = val;
    __constr_expr_1022[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1022[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_1022.as_mut_ptr() as var, Ref, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Ref as *mut libc::c_void,
        &mut __constr_expr_1021 as *mut Ref as *const libc::c_void,
        ::std::mem::size_of::<Ref>() as libc::c_ulong,
    );
    set((*t).tls, key, tmp___1 as *mut Ref as var);
}
unsafe extern "C" fn Thread_Mem(mut self_0: var, mut key: var) -> bool {
    let mut t: *mut Thread = 0 as *mut Thread;
    let mut tmp: bool = false;
    t = self_0 as *mut Thread;
    tmp = mem((*t).tls, key);
    return tmp;
}
unsafe extern "C" fn Thread_Rem(mut self_0: var, mut key: var) {
    let mut t: *mut Thread = 0 as *mut Thread;
    t = self_0 as *mut Thread;
    rem((*t).tls, key);
}
unsafe extern "C" fn Thread_Mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut t: *mut Thread = 0 as *mut Thread;
    t = self_0 as *mut Thread;
    mark((*t).tls, gc, f);
}
static mut __constr_expr_1024: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Thread_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Thread_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Thread_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Thread_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1025: New = {
    let mut init = New {
        construct_with: Some(Thread_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Thread_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_1026: Assign = {
    let mut init = Assign {
        assign: Some(Thread_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_1027: Cmp = {
    let mut init = Cmp {
        cmp: Some(Thread_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_1028: Hash = {
    let mut init = Hash {
        hash: Some(Thread_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_1029: Call = {
    let mut init = Call {
        call_with: Some(Thread_Call as unsafe extern "C" fn(var, var) -> var),
    };
    init
};
static mut __constr_expr_1030: Current = {
    let mut init = Current {
        current: Some(Thread_Current as unsafe extern "C" fn() -> var),
    };
    init
};
static mut __constr_expr_1031: Mark = {
    let mut init = Mark {
        mark: Some(
            Thread_Mark
                as unsafe extern "C" fn(
                    var,
                    var,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_1032: Start = {
    let mut init = Start {
        start: Some(Thread_Start as unsafe extern "C" fn(var) -> ()),
        stop: Some(Thread_Stop as unsafe extern "C" fn(var) -> ()),
        join: Some(Thread_Join as unsafe extern "C" fn(var) -> ()),
        running: Some(Thread_Running as unsafe extern "C" fn(var) -> bool),
    };
    init
};
static mut __constr_expr_1033: C_Int = {
    let mut init = C_Int {
        c_int: Some(Thread_C_Int as unsafe extern "C" fn(var) -> int64_t),
    };
    init
};
static mut __constr_expr_1034: Get = {
    let mut init = Get {
        get: Some(Thread_Get as unsafe extern "C" fn(var, var) -> var),
        set: Some(Thread_Set as unsafe extern "C" fn(var, var, var) -> ()),
        mem: Some(Thread_Mem as unsafe extern "C" fn(var, var) -> bool),
        rem: Some(Thread_Rem as unsafe extern "C" fn(var, var) -> ()),
        key_type: None,
        val_type: None,
    };
    init
};
static mut __constr_expr_1023: [var; 63] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Thread\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Thread>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1024 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1025 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1026 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1027 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1028 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Call\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1029 as *const Call as *mut Call as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Current\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1030 as *const Current as *mut Current as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1031 as *const Mark as *mut Mark as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1032 as *const Start as *mut Start as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"C_Int\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1033 as *const C_Int as *mut C_Int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1034 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Thread: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Lock_Name() -> *const libc::c_char {
    return b"Lock\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Lock_Brief() -> *const libc::c_char {
    return b"Exclusive Resource\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Lock_Description() -> *const libc::c_char {
    return b"The `Lock` class can be implemented by types to limit the access to them. For example this class is implemented by the `Mutex` type to provide mutual exclusion across Threads.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Lock_Definition() -> *const libc::c_char {
    return b"struct Lock {\n  void (*lock)(var);\n  void (*unlock)(var);\n  bool (*trylock)(var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut methods___33: [Method; 4] = [
    {
        let mut init = Method {
            name: b"lock\0" as *const u8 as *const libc::c_char,
            definition: b"void lock(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Wait until a lock can be aquired on object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"trylock\0" as *const u8 as *const libc::c_char,
            definition: b"bool trylock(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Try to acquire a lock on object `self`. Returns `true` on success and `false` if the resource is busy.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"unlock\0" as *const u8 as *const libc::c_char,
            definition: b"void unlock(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Release lock on object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Lock_Methods() -> *mut Method {
    return methods___33.as_mut_ptr();
}
static mut examples___43: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Mutex);\nlock(x);   /* Lock Mutex */ \nprint(\"Inside Mutex!\\n\");\nunlock(x); /* Unlock Mutex */\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Lock_Examples() -> *mut Example {
    return examples___43.as_mut_ptr();
}
static mut __constr_expr_1036: Doc = {
    let mut init = Doc {
        name: Some(Lock_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Lock_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Lock_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Lock_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Lock_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Lock_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_1035: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Lock\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Lock>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1036 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Lock: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn lock(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Lock,
        &mut (*(0 as *mut Lock)).lock as *mut Option::<unsafe extern "C" fn(var) -> ()>
            as libc::c_ulong,
        b"lock\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Lock)).lock).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn unlock(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Lock,
        &mut (*(0 as *mut Lock)).unlock as *mut Option::<unsafe extern "C" fn(var) -> ()>
            as libc::c_ulong,
        b"unlock\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Lock)).unlock).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn trylock(mut self_0: var) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = method_at_offset(
        self_0,
        Lock,
        &mut (*(0 as *mut Lock)).trylock
            as *mut Option::<unsafe extern "C" fn(var) -> bool> as libc::c_ulong,
        b"trylock\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Lock)).trylock).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
unsafe extern "C" fn Mutex_Name() -> *const libc::c_char {
    return b"Mutex\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Mutex_Brief() -> *const libc::c_char {
    return b"Mutual Exclusion Lock\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Mutex_Description() -> *const libc::c_char {
    return b"The `Mutex` type can be used to gain mutual exclusion across Threads for access to some resource.\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___44: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Mutex);\nwith (mut in x) { /* Lock Mutex */ \n  print(\"Inside Mutex!\\n\");\n} /* Unlock Mutex */\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Mutex_Examples() -> *mut Example {
    return examples___44.as_mut_ptr();
}
unsafe extern "C" fn Mutex_New(mut self_0: var, mut args: var) {
    let mut m: *mut Mutex = 0 as *mut Mutex;
    m = self_0 as *mut Mutex;
    pthread_mutex_init(
        &mut (*m).mutex,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
}
unsafe extern "C" fn Mutex_Del(mut self_0: var) {
    let mut m: *mut Mutex = 0 as *mut Mutex;
    m = self_0 as *mut Mutex;
    pthread_mutex_destroy(&mut (*m).mutex);
}
unsafe extern "C" fn Mutex_Lock(mut self_0: var) {
    let mut m: *mut Mutex = 0 as *mut Mutex;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_1037: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1038: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1039: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1040: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1041: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1042: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    m = self_0 as *mut Mutex;
    tmp = pthread_mutex_lock(&mut (*m).mutex);
    err = tmp;
    if err == 22 as libc::c_int {
        __constr_expr_1038[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1037.items = __constr_expr_1038.as_mut_ptr();
        __constr_expr_1039[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1039[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1039.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1037 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Argument to Mutex Lock\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    if err == 35 as libc::c_int {
        __constr_expr_1041[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1040.items = __constr_expr_1041.as_mut_ptr();
        __constr_expr_1042[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1042[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1042.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1040 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ResourceError,
            b"Attempt to relock already held mutex\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn Mutex_Trylock(mut self_0: var) -> bool {
    let mut m: *mut Mutex = 0 as *mut Mutex;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_1043: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1044: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1045: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    m = self_0 as *mut Mutex;
    tmp = pthread_mutex_trylock(&mut (*m).mutex);
    err = tmp;
    if err == 16 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    if err == 22 as libc::c_int {
        __constr_expr_1044[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1043.items = __constr_expr_1044.as_mut_ptr();
        __constr_expr_1045[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1045[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1045.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1043 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Argument to Mutex Lock Try\0" as *const u8 as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn Mutex_Unlock(mut self_0: var) {
    let mut m: *mut Mutex = 0 as *mut Mutex;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut err: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut __constr_expr_1046: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1047: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1048: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1049: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1050: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1051: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = cast(self_0, Mutex);
    m = tmp as *mut Mutex;
    tmp___0 = pthread_mutex_unlock(&mut (*m).mutex);
    err = tmp___0;
    if err == 22 as libc::c_int {
        __constr_expr_1047[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1046.items = __constr_expr_1047.as_mut_ptr();
        __constr_expr_1048[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = 1 as libc::c_uint;
        while !(tmp___1 >= 32 as libc::c_uint) {
            __constr_expr_1048[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = tmp___1.wrapping_add(1);
        }
        tmp___2 = header_init(
            __constr_expr_1048.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___3 = memcpy(
            tmp___2 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1046 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ValueError,
            b"Invalid Argument to Mutex Unlock\0" as *const u8 as *const libc::c_char,
            tmp___3 as *mut Tuple as var,
        );
    }
    if err == 1 as libc::c_int {
        __constr_expr_1050[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1049.items = __constr_expr_1050.as_mut_ptr();
        __constr_expr_1051[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = 1 as libc::c_uint;
        while !(tmp___4 >= 32 as libc::c_uint) {
            __constr_expr_1051[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = tmp___4.wrapping_add(1);
        }
        tmp___5 = header_init(
            __constr_expr_1051.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___6 = memcpy(
            tmp___5 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1049 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            ResourceError,
            b"Mutex cannot be held by caller\0" as *const u8 as *const libc::c_char,
            tmp___6 as *mut Tuple as var,
        );
    }
}
static mut __constr_expr_1053: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Mutex_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Mutex_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Mutex_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Mutex_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1054: New = {
    let mut init = New {
        construct_with: Some(Mutex_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Mutex_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_1055: Lock = {
    let mut init = Lock {
        lock: Some(Mutex_Lock as unsafe extern "C" fn(var) -> ()),
        unlock: Some(Mutex_Unlock as unsafe extern "C" fn(var) -> ()),
        trylock: Some(Mutex_Trylock as unsafe extern "C" fn(var) -> bool),
    };
    init
};
static mut __constr_expr_1056: Start = unsafe {
    {
        let mut init = Start {
            start: Some(Mutex_Lock as unsafe extern "C" fn(var) -> ()),
            stop: Some(Mutex_Unlock as unsafe extern "C" fn(var) -> ()),
            join: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            running: None,
        };
        init
    }
};
static mut __constr_expr_1052: [var; 42] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Mutex\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Mutex>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1053 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1054 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Lock\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1055 as *const Lock as *mut Lock as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1056 as *const Start as *mut Start as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Mutex: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Mark_Name() -> *const libc::c_char {
    return b"Mark\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Mark_Brief() -> *const libc::c_char {
    return b"Markable by GC\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Mark_Description() -> *const libc::c_char {
    return b"The `Mark` class can be overridden to customize the behaviour of the Cello Garbage Collector on encountering a given type. By default the allocated memory for a structure is scanned for pointers to other Cello objects, but if a type does its own memory allocation it may store pointers to Cello objects in other locations.\n\nIf this is the case the `Mark` class can be overridden and the callback function `f` must be called on all pointers which might be Cello objects which are managed by the class. Alternately the `mark` function can be called on any sub object to start a chain of recursive marking.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Mark_Definition() -> *const libc::c_char {
    return b"struct Mark {\n  void (*mark)(var, var, void(*)(var,void*));\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut methods___34: [Method; 2] = [
    {
        let mut init = Method {
            name: b"mark\0" as *const u8 as *const libc::c_char,
            definition: b"void mark(var self, var gc, void(*f)(var,void*));\0"
                as *const u8 as *const libc::c_char,
            description: b"Mark the object `self` with the Garbage Collector `gc` and the callback function `f`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Mark_Methods() -> *mut Method {
    return methods___34.as_mut_ptr();
}
static mut __constr_expr_1058: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Mark_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Mark_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Mark_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Mark_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Example>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            methods: Some(Mark_Methods as unsafe extern "C" fn() -> *mut Method),
        };
        init
    }
};
static mut __constr_expr_1057: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Mark>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1058 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Mark: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut m: *mut Mark = 0 as *mut Mark;
    let mut tmp: var = 0 as *mut libc::c_void;
    if self_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    tmp = instance(self_0, Mark);
    m = tmp as *mut Mark;
    if !m.is_null() {
        if ((*m).mark).is_some() {
            (Some(((*m).mark).expect("non-null function pointer")))
                .expect("non-null function pointer")(self_0, gc, f);
        }
    }
}
static mut GC_Primes: [size_t; 24] = [
    0 as libc::c_int as size_t,
    1 as libc::c_int as size_t,
    5 as libc::c_int as size_t,
    11 as libc::c_int as size_t,
    23 as libc::c_int as size_t,
    53 as libc::c_int as size_t,
    101 as libc::c_int as size_t,
    197 as libc::c_int as size_t,
    389 as libc::c_int as size_t,
    683 as libc::c_int as size_t,
    1259 as libc::c_int as size_t,
    2417 as libc::c_int as size_t,
    4733 as libc::c_int as size_t,
    9371 as libc::c_int as size_t,
    18617 as libc::c_int as size_t,
    37097 as libc::c_int as size_t,
    74093 as libc::c_int as size_t,
    148073 as libc::c_int as size_t,
    296099 as libc::c_int as size_t,
    592019 as libc::c_int as size_t,
    1100009 as libc::c_int as size_t,
    2200013 as libc::c_int as size_t,
    4400021 as libc::c_int as size_t,
    8800019 as libc::c_int as size_t,
];
unsafe extern "C" fn GC_Name() -> *const libc::c_char {
    return b"GC\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn GC_Brief() -> *const libc::c_char {
    return b"Garbage Collector\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn GC_Description() -> *const libc::c_char {
    return b"The `GC` type provides an interface to the Cello Garbage Collector. One instance of this type is created for each thread and can be retrieved using the `current` function. The Garbage Collector can be stopped and started using `start` and `stop` and objects can be added or removed from the Garbage Collector using `set` and `rem`.\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___45: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Starting & Stopping\0" as *const u8 as *const libc::c_char,
            body: b"var gc = current(GC);\nstop(gc);\nvar x = new(Int, $I(10)); /* Not added to GC */\nshow($I(running(gc))); /* 0 */\ndel(x); /* Must be deleted when done */\nstart(gc);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn GC_Examples() -> *mut Example {
    return examples___45.as_mut_ptr();
}
unsafe extern "C" fn GC_Probe(
    mut gc: *mut GC,
    mut i: uint64_t,
    mut h: uint64_t,
) -> uint64_t {
    let mut v: int64_t = 0;
    v = i.wrapping_sub(h.wrapping_sub(1 as libc::c_ulong)) as int64_t;
    if v < 0 as libc::c_long {
        v = ((*gc).nslots).wrapping_add(v as size_t) as int64_t;
    }
    return v as uint64_t;
}
static mut GC_Load_Factor: libc::c_double = 0.9f64;
unsafe extern "C" fn GC_Ideal_Size(mut size___0: size_t) -> size_t {
    let mut i: size_t = 0;
    let mut last: size_t = 0;
    let mut i___0: size_t = 0;
    size___0 = (size___0.wrapping_add(1 as libc::c_ulong) as libc::c_double
        / GC_Load_Factor) as size_t;
    i = 0 as libc::c_int as size_t;
    while i < 24 as libc::c_ulong {
        if GC_Primes[i as usize] >= size___0 {
            return GC_Primes[i as usize];
        }
        i = i.wrapping_add(1);
    }
    last = GC_Primes[23 as libc::c_int as usize];
    i___0 = 0 as libc::c_int as size_t;
    loop {
        if last.wrapping_mul(i___0) >= size___0 {
            return last.wrapping_mul(i___0);
        }
        i___0 = i___0.wrapping_add(1);
    };
}
unsafe extern "C" fn GC_Rehash(mut gc: *mut GC, mut new_size: size_t) {
    let mut old_entries: *mut GCEntry = 0 as *mut GCEntry;
    let mut old_size: size_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1059: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1060: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1061: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    old_entries = (*gc).entries;
    old_size = (*gc).nslots;
    (*gc).nslots = new_size;
    tmp = calloc((*gc).nslots, ::std::mem::size_of::<GCEntry>() as libc::c_ulong);
    (*gc).entries = tmp as *mut GCEntry;
    if (*gc).entries as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1060[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1059.items = __constr_expr_1060.as_mut_ptr();
        __constr_expr_1061[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1061[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1061.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1059 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate GC Pointer Table, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___2 as *mut Tuple as var,
        );
        return;
    }
    i = 0 as libc::c_int as size_t;
    while i < old_size {
        if (*old_entries.offset(i as isize)).hash != 0 as libc::c_ulong {
            GC_Set_Ptr(
                gc,
                (*old_entries.offset(i as isize)).ptr,
                (*old_entries.offset(i as isize)).root,
            );
        }
        i = i.wrapping_add(1);
    }
    free(old_entries as *mut libc::c_void);
}
unsafe extern "C" fn GC_Resize_More(mut gc: *mut GC) {
    let mut new_size: size_t = 0;
    let mut tmp: size_t = 0;
    let mut old_size: size_t = 0;
    tmp = GC_Ideal_Size((*gc).nitems);
    new_size = tmp;
    old_size = (*gc).nslots;
    if new_size > old_size {
        GC_Rehash(gc, new_size);
    }
}
unsafe extern "C" fn GC_Resize_Less(mut gc: *mut GC) {
    let mut new_size: size_t = 0;
    let mut tmp: size_t = 0;
    let mut old_size: size_t = 0;
    tmp = GC_Ideal_Size((*gc).nitems);
    new_size = tmp;
    old_size = (*gc).nslots;
    if new_size < old_size {
        GC_Rehash(gc, new_size);
    }
}
unsafe extern "C" fn GC_Hash(mut ptr: var) -> uint64_t {
    return ptr as uintptr_t >> 3 as libc::c_int;
}
unsafe extern "C" fn GC_Set_Ptr(mut gc: *mut GC, mut ptr: var, mut root: bool) {
    let mut i: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut ihash: uint64_t = 0;
    let mut entry: GCEntry = GCEntry {
        ptr: 0 as *mut libc::c_void,
        hash: 0,
        root: false,
        marked: false,
    };
    let mut h: uint64_t = 0;
    let mut p: uint64_t = 0;
    let mut tmp___0: uint64_t = 0;
    let mut tmp___1: GCEntry = GCEntry {
        ptr: 0 as *mut libc::c_void,
        hash: 0,
        root: false,
        marked: false,
    };
    tmp = GC_Hash(ptr);
    i = tmp.wrapping_rem((*gc).nslots);
    j = 0 as libc::c_int as uint64_t;
    ihash = i.wrapping_add(1 as libc::c_ulong);
    entry.ptr = ptr;
    entry.hash = ihash;
    entry.root = root;
    entry.marked = 0 as libc::c_int != 0;
    loop {
        h = (*((*gc).entries).offset(i as isize)).hash;
        if h == 0 as libc::c_ulong {
            *((*gc).entries).offset(i as isize) = entry;
            return;
        }
        if (*((*gc).entries).offset(i as isize)).ptr as libc::c_ulong
            == entry.ptr as libc::c_ulong
        {
            return;
        }
        tmp___0 = GC_Probe(gc, i, h);
        p = tmp___0;
        if j >= p {
            tmp___1 = *((*gc).entries).offset(i as isize);
            *((*gc).entries).offset(i as isize) = entry;
            entry = tmp___1;
            j = p;
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*gc).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn GC_Mem_Ptr(mut gc: *mut GC, mut ptr: var) -> bool {
    let mut i: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___0: uint64_t = 0;
    if (*gc).nslots == 0 as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    tmp = GC_Hash(ptr);
    i = tmp.wrapping_rem((*gc).nslots);
    j = 0 as libc::c_int as uint64_t;
    loop {
        h = (*((*gc).entries).offset(i as isize)).hash;
        if h == 0 as libc::c_ulong {
            return 0 as libc::c_int != 0
        } else {
            tmp___0 = GC_Probe(gc, i, h);
            if j > tmp___0 {
                return 0 as libc::c_int != 0;
            }
        }
        if (*((*gc).entries).offset(i as isize)).ptr as libc::c_ulong
            == ptr as libc::c_ulong
        {
            return 1 as libc::c_int != 0;
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*gc).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn GC_Rem_Ptr(mut gc: *mut GC, mut ptr: var) {
    let mut i: size_t = 0;
    let mut i___0: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___0: uint64_t = 0;
    let mut freeitem: var = 0 as *mut libc::c_void;
    let mut nj: uint64_t = 0;
    let mut nh: uint64_t = 0;
    let mut tmp___1: uint64_t = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    if (*gc).nslots == 0 as libc::c_ulong {
        return;
    }
    i = 0 as libc::c_int as size_t;
    while i < (*gc).freenum {
        if *((*gc).freelist).offset(i as isize) as libc::c_ulong == ptr as libc::c_ulong
        {
            let ref mut fresh44 = *((*gc).freelist).offset(i as isize);
            *fresh44 = 0 as *mut libc::c_void;
        }
        i = i.wrapping_add(1);
    }
    tmp = GC_Hash(ptr);
    i___0 = tmp.wrapping_rem((*gc).nslots);
    j = 0 as libc::c_int as uint64_t;
    loop {
        h = (*((*gc).entries).offset(i___0 as isize)).hash;
        if h == 0 as libc::c_ulong {
            return
        } else {
            tmp___0 = GC_Probe(gc, i___0, h);
            if j > tmp___0 {
                return;
            }
        }
        if (*((*gc).entries).offset(i___0 as isize)).ptr as libc::c_ulong
            == ptr as libc::c_ulong
        {
            freeitem = (*((*gc).entries).offset(i___0 as isize)).ptr;
            memset(
                ((*gc).entries).offset(i___0 as isize) as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<GCEntry>() as libc::c_ulong,
            );
            j = i___0;
            loop {
                nj = j.wrapping_add(1 as libc::c_ulong).wrapping_rem((*gc).nslots);
                nh = (*((*gc).entries).offset(nj as isize)).hash;
                if !(nh != 0 as libc::c_ulong) {
                    break;
                }
                tmp___1 = GC_Probe(gc, nj, nh);
                if !(tmp___1 > 0 as libc::c_ulong) {
                    break;
                }
                memcpy(
                    ((*gc).entries).offset(j as isize) as *mut libc::c_void,
                    ((*gc).entries).offset(nj as isize) as *const libc::c_void,
                    ::std::mem::size_of::<GCEntry>() as libc::c_ulong,
                );
                memset(
                    ((*gc).entries).offset(nj as isize) as *mut libc::c_void,
                    0 as libc::c_int,
                    ::std::mem::size_of::<GCEntry>() as libc::c_ulong,
                );
                j = nj;
            }
            (*gc).nitems = ((*gc).nitems).wrapping_sub(1);
            tmp___2 = destruct(freeitem);
            dealloc(tmp___2);
            return;
        }
        i___0 = i___0.wrapping_add(1 as libc::c_ulong).wrapping_rem((*gc).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn GC_Mark_And_Recurse(mut gc: *mut GC, mut ptr: *mut libc::c_void) {
    GC_Mark_Item(gc, ptr);
    GC_Recurse(gc, ptr);
}
unsafe extern "C" fn GC_Recurse(mut gc: *mut GC, mut ptr: var) {
    let mut type_0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut m: *mut Mark = 0 as *mut Mark;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut p: var = 0 as *mut libc::c_void;
    let mut tmp___1: size_t = 0;
    tmp = type_of(ptr);
    type_0 = tmp;
    if type_0 as libc::c_ulong == Int as libc::c_ulong {
        return
    } else {
        if type_0 as libc::c_ulong == Float as libc::c_ulong {
            return
        } else {
            if type_0 as libc::c_ulong == String as libc::c_ulong {
                return
            } else {
                if type_0 as libc::c_ulong == Type as libc::c_ulong {
                    return
                } else {
                    if type_0 as libc::c_ulong == File as libc::c_ulong {
                        return
                    } else {
                        if type_0 as libc::c_ulong == Process as libc::c_ulong {
                            return
                        } else {
                            if type_0 as libc::c_ulong == Function as libc::c_ulong {
                                return;
                            }
                        }
                    }
                }
            }
        }
    }
    tmp___0 = type_instance(type_0, Mark);
    m = tmp___0 as *mut Mark;
    if !m.is_null() {
        if ((*m).mark).is_some() {
            (Some(((*m).mark).expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )(
                ptr,
                gc as var,
                ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(*mut GC, *mut libc::c_void) -> ()>,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                >(
                    Some(
                        GC_Mark_And_Recurse
                            as unsafe extern "C" fn(*mut GC, *mut libc::c_void) -> (),
                    ),
                ),
            );
            return;
        }
    }
    i = 0 as libc::c_int as size_t;
    loop {
        tmp___1 = size(type_0);
        if !(i.wrapping_add(::std::mem::size_of::<var>() as libc::c_ulong) <= tmp___1) {
            break;
        }
        p = (ptr as *mut libc::c_char).offset(i as isize) as var;
        GC_Mark_Item(gc, *(p as *mut var));
        i = (i as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<var>() as libc::c_ulong) as size_t
            as size_t;
    };
}
unsafe extern "C" fn GC_Mark_Item(mut gc: *mut GC, mut ptr: *mut libc::c_void) {
    let mut pval: uintptr_t = 0;
    let mut i: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut j: uint64_t = 0;
    let mut h: uint64_t = 0;
    let mut tmp___0: uint64_t = 0;
    pval = ptr as uintptr_t;
    if pval.wrapping_rem(::std::mem::size_of::<var>() as libc::c_ulong)
        != 0 as libc::c_ulong
    {
        return
    } else {
        if pval < (*gc).minptr {
            return
        } else {
            if pval > (*gc).maxptr {
                return;
            }
        }
    }
    tmp = GC_Hash(ptr);
    i = tmp.wrapping_rem((*gc).nslots);
    j = 0 as libc::c_int as uint64_t;
    loop {
        h = (*((*gc).entries).offset(i as isize)).hash;
        if h == 0 as libc::c_ulong {
            return
        } else {
            tmp___0 = GC_Probe(gc, i, h);
            if j > tmp___0 {
                return;
            }
        }
        if (*((*gc).entries).offset(i as isize)).ptr as libc::c_ulong
            == ptr as libc::c_ulong
        {
            if !(*((*gc).entries).offset(i as isize)).marked {
                (*((*gc).entries).offset(i as isize)).marked = 1 as libc::c_int != 0;
                GC_Recurse(gc, (*((*gc).entries).offset(i as isize)).ptr);
                return;
            }
        }
        i = i.wrapping_add(1 as libc::c_ulong).wrapping_rem((*gc).nslots);
        j = j.wrapping_add(1);
    };
}
unsafe extern "C" fn GC_Mark_Stack(mut gc: *mut GC) {
    let mut stk: var = 0 as *mut libc::c_void;
    let mut bot: var = 0 as *mut libc::c_void;
    let mut top: var = 0 as *mut libc::c_void;
    let mut p: var = 0 as *mut libc::c_void;
    let mut p___0: var = 0 as *mut libc::c_void;
    stk = 0 as *mut libc::c_void;
    bot = (*gc).bottom;
    top = &mut stk as *mut var as var;
    if bot as libc::c_ulong == top as libc::c_ulong {
        return;
    }
    if (bot as libc::c_ulong) < top as libc::c_ulong {
        p = top;
        while p as libc::c_ulong >= bot as libc::c_ulong {
            GC_Mark_Item(gc, *(p as *mut var));
            p = (p as *mut libc::c_char)
                .offset(-(::std::mem::size_of::<var>() as libc::c_ulong as isize))
                as var;
        }
    }
    if bot as libc::c_ulong > top as libc::c_ulong {
        p___0 = top;
        while p___0 as libc::c_ulong <= bot as libc::c_ulong {
            GC_Mark_Item(gc, *(p___0 as *mut var));
            p___0 = (p___0 as *mut libc::c_char)
                .offset(::std::mem::size_of::<var>() as libc::c_ulong as isize) as var;
        }
    }
}
pub unsafe extern "C" fn GC_Mark(mut gc: *mut GC) {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut noinline: libc::c_int = 0;
    let mut env: jmp_buf = [__jmp_buf_tag {
        __jmpbuf: [0; 8],
        __mask_was_saved: 0,
        __saved_mask: __sigset_t { __val: [0; 16] },
    }; 1];
    let mut mark_stack: Option::<unsafe extern "C" fn(*mut GC) -> ()> = None;
    let mut tmp___0: Option::<unsafe extern "C" fn(*mut GC) -> ()> = None;
    if gc as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return
    } else {
        if (*gc).nitems == 0 as libc::c_ulong {
            return;
        }
    }
    tmp = current(Thread);
    mark(
        tmp,
        gc as var,
        ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut GC, *mut libc::c_void) -> ()>,
            Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
        >(Some(GC_Mark_Item as unsafe extern "C" fn(*mut GC, *mut libc::c_void) -> ())),
    );
    i = 0 as libc::c_int as size_t;
    while i < (*gc).nslots {
        if !((*((*gc).entries).offset(i as isize)).hash == 0 as libc::c_ulong) {
            if !(*((*gc).entries).offset(i as isize)).marked {
                if (*((*gc).entries).offset(i as isize)).root {
                    (*((*gc).entries).offset(i as isize)).marked = 1 as libc::c_int != 0;
                    GC_Recurse(gc, (*((*gc).entries).offset(i as isize)).ptr);
                }
            }
        }
        i = i.wrapping_add(1);
    }
    noinline = 1 as libc::c_int;
    if noinline != 0 {
        memset(
            &mut env as *mut jmp_buf as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<jmp_buf>() as libc::c_ulong,
        );
        _setjmp(env.as_mut_ptr());
    }
    if noinline != 0 {
        tmp___0 = Some(GC_Mark_Stack as unsafe extern "C" fn(*mut GC) -> ());
    } else {
        tmp___0 = ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut GC) -> ()>,
        >(0 as *mut libc::c_void);
    }
    mark_stack = tmp___0;
    (Some(mark_stack.expect("non-null function pointer")))
        .expect("non-null function pointer")(gc);
}
unsafe extern "C" fn GC_Show(
    mut self_0: var,
    mut out: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut gc: *mut GC = 0 as *mut GC;
    let mut __constr_expr_1062: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1063: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1064: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_1065: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1066: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1067: Int = Int { val: 0 };
    let mut __constr_expr_1068: [libc::c_char; 32] = [0; 32];
    let mut tmp___2: libc::c_uint = 0;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut tmp___4: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1069: [libc::c_char; 32] = [0; 32];
    let mut tmp___5: libc::c_uint = 0;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1070: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1071: [var; 6] = [0 as *mut libc::c_void; 6];
    let mut __constr_expr_1072: Int = Int { val: 0 };
    let mut __constr_expr_1073: [libc::c_char; 32] = [0; 32];
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1074: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1075: [libc::c_char; 32] = [0; 32];
    let mut tmp___12: libc::c_uint = 0;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1076: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1077: [libc::c_char; 32] = [0; 32];
    let mut tmp___15: libc::c_uint = 0;
    let mut tmp___16: var = 0 as *mut libc::c_void;
    let mut tmp___17: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___18: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_1078: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1079: [libc::c_char; 32] = [0; 32];
    let mut tmp___19: libc::c_uint = 0;
    let mut tmp___20: var = 0 as *mut libc::c_void;
    let mut tmp___21: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1080: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1081: [libc::c_char; 32] = [0; 32];
    let mut tmp___22: libc::c_uint = 0;
    let mut tmp___23: var = 0 as *mut libc::c_void;
    let mut tmp___24: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___25: *mut String_0 = 0 as *mut String_0;
    let mut __constr_expr_1082: [libc::c_char; 32] = [0; 32];
    let mut tmp___26: libc::c_uint = 0;
    let mut tmp___27: var = 0 as *mut libc::c_void;
    let mut tmp___28: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1083: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1084: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1085: [libc::c_char; 32] = [0; 32];
    let mut tmp___29: libc::c_uint = 0;
    let mut tmp___30: var = 0 as *mut libc::c_void;
    let mut tmp___31: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___32: libc::c_int = 0;
    gc = self_0 as *mut GC;
    __constr_expr_1063[0 as libc::c_int as usize] = self_0;
    __constr_expr_1063[1 as libc::c_int as usize] = Terminal;
    __constr_expr_1062.items = __constr_expr_1063.as_mut_ptr();
    __constr_expr_1064[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1064[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_1064.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_1062 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        out,
        pos,
        b"<'GC' At 0x%p\n\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    i = 0 as libc::c_int as size_t;
    while i < (*gc).nslots {
        if (*((*gc).entries).offset(i as isize)).hash == 0 as libc::c_ulong {
            __constr_expr_1067.val = i as int64_t;
            __constr_expr_1068[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___2 = 1 as libc::c_uint;
            while !(tmp___2 >= 32 as libc::c_uint) {
                __constr_expr_1068[tmp___2 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___2 = tmp___2.wrapping_add(1);
            }
            tmp___3 = header_init(
                __constr_expr_1068.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___4 = memcpy(
                tmp___3 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_1067 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            __constr_expr_1066[0 as libc::c_int as usize] = tmp___4 as *mut Int as var;
            __constr_expr_1066[1 as libc::c_int as usize] = Terminal;
            __constr_expr_1065.items = __constr_expr_1066.as_mut_ptr();
            __constr_expr_1069[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___5 = 1 as libc::c_uint;
            while !(tmp___5 >= 32 as libc::c_uint) {
                __constr_expr_1069[tmp___5 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___5 = tmp___5.wrapping_add(1);
            }
            tmp___6 = header_init(
                __constr_expr_1069.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___7 = memcpy(
                tmp___6 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1065 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"| %i : \n\0" as *const u8 as *const libc::c_char,
                tmp___7 as *mut Tuple as var,
            );
        } else {
            __constr_expr_1072.val = i as int64_t;
            __constr_expr_1073[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___8 = 1 as libc::c_uint;
            while !(tmp___8 >= 32 as libc::c_uint) {
                __constr_expr_1073[tmp___8 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___8 = tmp___8.wrapping_add(1);
            }
            tmp___9 = header_init(
                __constr_expr_1073.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___10 = memcpy(
                tmp___9 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_1072 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            tmp___11 = type_of((*((*gc).entries).offset(i as isize)).ptr);
            if (*((*gc).entries).offset(i as isize)).root {
                __constr_expr_1074
                    .val = b"root\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                __constr_expr_1075[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___12 = 1 as libc::c_uint;
                while !(tmp___12 >= 32 as libc::c_uint) {
                    __constr_expr_1075[tmp___12
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___12 = tmp___12.wrapping_add(1);
                }
                tmp___13 = header_init(
                    __constr_expr_1075.as_mut_ptr() as var,
                    String,
                    2 as libc::c_int,
                );
                tmp___14 = memcpy(
                    tmp___13 as *mut String_0 as *mut libc::c_void,
                    &mut __constr_expr_1074 as *mut String_0 as *const libc::c_void,
                    ::std::mem::size_of::<String_0>() as libc::c_ulong,
                );
                tmp___18 = tmp___14 as *mut String_0;
            } else {
                __constr_expr_1076
                    .val = b"auto\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                __constr_expr_1077[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___15 = 1 as libc::c_uint;
                while !(tmp___15 >= 32 as libc::c_uint) {
                    __constr_expr_1077[tmp___15
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___15 = tmp___15.wrapping_add(1);
                }
                tmp___16 = header_init(
                    __constr_expr_1077.as_mut_ptr() as var,
                    String,
                    2 as libc::c_int,
                );
                tmp___17 = memcpy(
                    tmp___16 as *mut String_0 as *mut libc::c_void,
                    &mut __constr_expr_1076 as *mut String_0 as *const libc::c_void,
                    ::std::mem::size_of::<String_0>() as libc::c_ulong,
                );
                tmp___18 = tmp___17 as *mut String_0;
            }
            if (*((*gc).entries).offset(i as isize)).marked {
                __constr_expr_1078
                    .val = b"*\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                __constr_expr_1079[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___19 = 1 as libc::c_uint;
                while !(tmp___19 >= 32 as libc::c_uint) {
                    __constr_expr_1079[tmp___19
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___19 = tmp___19.wrapping_add(1);
                }
                tmp___20 = header_init(
                    __constr_expr_1079.as_mut_ptr() as var,
                    String,
                    2 as libc::c_int,
                );
                tmp___21 = memcpy(
                    tmp___20 as *mut String_0 as *mut libc::c_void,
                    &mut __constr_expr_1078 as *mut String_0 as *const libc::c_void,
                    ::std::mem::size_of::<String_0>() as libc::c_ulong,
                );
                tmp___25 = tmp___21 as *mut String_0;
            } else {
                __constr_expr_1080
                    .val = b" \0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                __constr_expr_1081[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___22 = 1 as libc::c_uint;
                while !(tmp___22 >= 32 as libc::c_uint) {
                    __constr_expr_1081[tmp___22
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___22 = tmp___22.wrapping_add(1);
                }
                tmp___23 = header_init(
                    __constr_expr_1081.as_mut_ptr() as var,
                    String,
                    2 as libc::c_int,
                );
                tmp___24 = memcpy(
                    tmp___23 as *mut String_0 as *mut libc::c_void,
                    &mut __constr_expr_1080 as *mut String_0 as *const libc::c_void,
                    ::std::mem::size_of::<String_0>() as libc::c_ulong,
                );
                tmp___25 = tmp___24 as *mut String_0;
            }
            __constr_expr_1071[0 as libc::c_int as usize] = tmp___10 as *mut Int as var;
            __constr_expr_1071[1 as libc::c_int as usize] = tmp___11;
            __constr_expr_1071[2 as libc::c_int
                as usize] = (*((*gc).entries).offset(i as isize)).ptr;
            __constr_expr_1071[3 as libc::c_int as usize] = tmp___18 as var;
            __constr_expr_1071[4 as libc::c_int as usize] = tmp___25 as var;
            __constr_expr_1071[5 as libc::c_int as usize] = Terminal;
            __constr_expr_1070.items = __constr_expr_1071.as_mut_ptr();
            __constr_expr_1082[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___26 = 1 as libc::c_uint;
            while !(tmp___26 >= 32 as libc::c_uint) {
                __constr_expr_1082[tmp___26 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___26 = tmp___26.wrapping_add(1);
            }
            tmp___27 = header_init(
                __constr_expr_1082.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___28 = memcpy(
                tmp___27 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1070 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                out,
                pos,
                b"| %i : %15s %p %s %s\n\0" as *const u8 as *const libc::c_char,
                tmp___28 as *mut Tuple as var,
            );
        }
        i = i.wrapping_add(1);
    }
    __constr_expr_1084[0 as libc::c_int as usize] = Terminal;
    __constr_expr_1083.items = __constr_expr_1084.as_mut_ptr();
    __constr_expr_1085[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___29 = 1 as libc::c_uint;
    while !(tmp___29 >= 32 as libc::c_uint) {
        __constr_expr_1085[tmp___29 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___29 = tmp___29.wrapping_add(1);
    }
    tmp___30 = header_init(
        __constr_expr_1085.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___31 = memcpy(
        tmp___30 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_1083 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___32 = print_to_with(
        out,
        pos,
        b"+------------------->\n\0" as *const u8 as *const libc::c_char,
        tmp___31 as *mut Tuple as var,
    );
    return tmp___32;
}
pub unsafe extern "C" fn GC_Sweep(mut gc: *mut GC) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut j: uint64_t = 0;
    let mut nj: uint64_t = 0;
    let mut nh: uint64_t = 0;
    let mut tmp___0: uint64_t = 0;
    let mut i___0: size_t = 0;
    let mut i___1: size_t = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    tmp = realloc(
        (*gc).freelist as *mut libc::c_void,
        (::std::mem::size_of::<var>() as libc::c_ulong).wrapping_mul((*gc).nitems),
    );
    (*gc).freelist = tmp as *mut var;
    (*gc).freenum = 0 as libc::c_int as uintptr_t;
    i = 0 as libc::c_int as size_t;
    while i < (*gc).nslots {
        if (*((*gc).entries).offset(i as isize)).hash == 0 as libc::c_ulong {
            i = i.wrapping_add(1);
        } else if (*((*gc).entries).offset(i as isize)).marked {
            i = i.wrapping_add(1);
        } else {
            if !(*((*gc).entries).offset(i as isize)).root {
                if !(*((*gc).entries).offset(i as isize)).marked {
                    let ref mut fresh45 = *((*gc).freelist)
                        .offset((*gc).freenum as isize);
                    *fresh45 = (*((*gc).entries).offset(i as isize)).ptr;
                    (*gc).freenum = ((*gc).freenum).wrapping_add(1);
                    memset(
                        ((*gc).entries).offset(i as isize) as *mut libc::c_void,
                        0 as libc::c_int,
                        ::std::mem::size_of::<GCEntry>() as libc::c_ulong,
                    );
                    j = i;
                    loop {
                        nj = j
                            .wrapping_add(1 as libc::c_ulong)
                            .wrapping_rem((*gc).nslots);
                        nh = (*((*gc).entries).offset(nj as isize)).hash;
                        if !(nh != 0 as libc::c_ulong) {
                            break;
                        }
                        tmp___0 = GC_Probe(gc, nj, nh);
                        if !(tmp___0 > 0 as libc::c_ulong) {
                            break;
                        }
                        memcpy(
                            ((*gc).entries).offset(j as isize) as *mut libc::c_void,
                            ((*gc).entries).offset(nj as isize) as *const libc::c_void,
                            ::std::mem::size_of::<GCEntry>() as libc::c_ulong,
                        );
                        memset(
                            ((*gc).entries).offset(nj as isize) as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<GCEntry>() as libc::c_ulong,
                        );
                        j = nj;
                    }
                    (*gc).nitems = ((*gc).nitems).wrapping_sub(1);
                    continue;
                }
            }
            i = i.wrapping_add(1);
        }
    }
    i___0 = 0 as libc::c_int as size_t;
    while i___0 < (*gc).nslots {
        if !((*((*gc).entries).offset(i___0 as isize)).hash == 0 as libc::c_ulong) {
            if (*((*gc).entries).offset(i___0 as isize)).marked {
                (*((*gc).entries).offset(i___0 as isize)).marked = 0 as libc::c_int != 0;
            }
        }
        i___0 = i___0.wrapping_add(1);
    }
    GC_Resize_Less(gc);
    (*gc)
        .mitems = ((*gc).nitems)
        .wrapping_add(((*gc).nitems).wrapping_div(2 as libc::c_ulong))
        .wrapping_add(1 as libc::c_ulong);
    i___1 = 0 as libc::c_int as size_t;
    while i___1 < (*gc).freenum {
        if !(*((*gc).freelist).offset(i___1 as isize)).is_null() {
            tmp___1 = destruct(*((*gc).freelist).offset(i___1 as isize));
            dealloc(tmp___1);
        }
        i___1 = i___1.wrapping_add(1);
    }
    free((*gc).freelist as *mut libc::c_void);
    (*gc).freelist = 0 as *mut libc::c_void as *mut var;
    (*gc).freenum = 0 as libc::c_int as uintptr_t;
}
unsafe extern "C" fn GC_Current() -> var {
    let mut __constr_expr_1086: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1087: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    __constr_expr_1086
        .val = b"__GC\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    __constr_expr_1087[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1087[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_1087.as_mut_ptr() as var,
        String,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut String_0 as *mut libc::c_void,
        &mut __constr_expr_1086 as *mut String_0 as *const libc::c_void,
        ::std::mem::size_of::<String_0>() as libc::c_ulong,
    );
    tmp___2 = current(Thread);
    tmp___3 = get(tmp___2, tmp___1 as *mut String_0 as var);
    return tmp___3;
}
unsafe extern "C" fn GC_New(mut self_0: var, mut args: var) {
    let mut gc: *mut GC = 0 as *mut GC;
    let mut bt: *mut Ref = 0 as *mut Ref;
    let mut __constr_expr_1088: Int = Int { val: 0 };
    let mut __constr_expr_1089: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1090: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1091: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    gc = self_0 as *mut GC;
    __constr_expr_1088.val = 0 as libc::c_int as int64_t;
    __constr_expr_1089[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1089[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_1089.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_1088 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    tmp___3 = cast(tmp___2, Ref);
    bt = tmp___3 as *mut Ref;
    (*gc).bottom = (*bt).val;
    (*gc).maxptr = 0 as libc::c_int as uintptr_t;
    (*gc).minptr = 18446744073709551615 as libc::c_ulonglong as uintptr_t;
    (*gc).running = 1 as libc::c_int != 0;
    (*gc).freelist = 0 as *mut libc::c_void as *mut var;
    (*gc).freenum = 0 as libc::c_int as uintptr_t;
    __constr_expr_1090
        .val = b"__GC\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    __constr_expr_1091[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___4 = 1 as libc::c_uint;
    while !(tmp___4 >= 32 as libc::c_uint) {
        __constr_expr_1091[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = tmp___4.wrapping_add(1);
    }
    tmp___5 = header_init(
        __constr_expr_1091.as_mut_ptr() as var,
        String,
        2 as libc::c_int,
    );
    tmp___6 = memcpy(
        tmp___5 as *mut String_0 as *mut libc::c_void,
        &mut __constr_expr_1090 as *mut String_0 as *const libc::c_void,
        ::std::mem::size_of::<String_0>() as libc::c_ulong,
    );
    tmp___7 = current(Thread);
    set(tmp___7, tmp___6 as *mut String_0 as var, gc as var);
}
unsafe extern "C" fn GC_Del(mut self_0: var) {
    let mut gc: *mut GC = 0 as *mut GC;
    let mut __constr_expr_1092: String_0 = String_0 {
        val: 0 as *mut libc::c_char,
    };
    let mut __constr_expr_1093: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    gc = self_0 as *mut GC;
    GC_Sweep(gc);
    free((*gc).entries as *mut libc::c_void);
    free((*gc).freelist as *mut libc::c_void);
    __constr_expr_1092
        .val = b"__GC\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    __constr_expr_1093[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1093[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_1093.as_mut_ptr() as var,
        String,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut String_0 as *mut libc::c_void,
        &mut __constr_expr_1092 as *mut String_0 as *const libc::c_void,
        ::std::mem::size_of::<String_0>() as libc::c_ulong,
    );
    tmp___2 = current(Thread);
    rem(tmp___2, tmp___1 as *mut String_0 as var);
}
unsafe extern "C" fn GC_Set(mut self_0: var, mut key: var, mut val: var) {
    let mut gc: *mut GC = 0 as *mut GC;
    let mut tmp: int64_t = 0;
    gc = self_0 as *mut GC;
    if !(*gc).running {
        return;
    }
    (*gc).nitems = ((*gc).nitems).wrapping_add(1);
    if key as uintptr_t > (*gc).maxptr {
        (*gc).maxptr = key as uintptr_t;
    } else {
        (*gc).maxptr = (*gc).maxptr;
    }
    if (key as uintptr_t) < (*gc).minptr {
        (*gc).minptr = key as uintptr_t;
    } else {
        (*gc).minptr = (*gc).minptr;
    }
    GC_Resize_More(gc);
    tmp = c_int(val);
    GC_Set_Ptr(gc, key, tmp != 0);
    if (*gc).nitems > (*gc).mitems {
        GC_Mark(gc);
        GC_Sweep(gc);
    }
}
unsafe extern "C" fn GC_Rem(mut self_0: var, mut key: var) {
    let mut gc: *mut GC = 0 as *mut GC;
    gc = self_0 as *mut GC;
    if !(*gc).running {
        return;
    }
    GC_Rem_Ptr(gc, key);
    GC_Resize_Less(gc);
    (*gc)
        .mitems = ((*gc).nitems)
        .wrapping_add(((*gc).nitems).wrapping_div(2 as libc::c_ulong))
        .wrapping_add(1 as libc::c_ulong);
}
unsafe extern "C" fn GC_Mem(mut self_0: var, mut key: var) -> bool {
    let mut tmp: bool = false;
    tmp = GC_Mem_Ptr(self_0 as *mut GC, key);
    return tmp;
}
unsafe extern "C" fn GC_Start(mut self_0: var) {
    let mut gc: *mut GC = 0 as *mut GC;
    gc = self_0 as *mut GC;
    (*gc).running = 1 as libc::c_int != 0;
}
unsafe extern "C" fn GC_Stop(mut self_0: var) {
    let mut gc: *mut GC = 0 as *mut GC;
    gc = self_0 as *mut GC;
    (*gc).running = 0 as libc::c_int != 0;
}
unsafe extern "C" fn GC_Running(mut self_0: var) -> bool {
    let mut gc: *mut GC = 0 as *mut GC;
    gc = self_0 as *mut GC;
    return (*gc).running;
}
static mut __constr_expr_1095: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(GC_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(GC_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                GC_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(GC_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1096: New = {
    let mut init = New {
        construct_with: Some(GC_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(GC_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_1097: Get = unsafe {
    {
        let mut init = Get {
            get: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var) -> var>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            set: Some(GC_Set as unsafe extern "C" fn(var, var, var) -> ()),
            mem: Some(GC_Mem as unsafe extern "C" fn(var, var) -> bool),
            rem: Some(GC_Rem as unsafe extern "C" fn(var, var) -> ()),
            key_type: None,
            val_type: None,
        };
        init
    }
};
static mut __constr_expr_1098: Start = unsafe {
    {
        let mut init = Start {
            start: Some(GC_Start as unsafe extern "C" fn(var) -> ()),
            stop: Some(GC_Stop as unsafe extern "C" fn(var) -> ()),
            join: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            running: Some(GC_Running as unsafe extern "C" fn(var) -> bool),
        };
        init
    }
};
static mut __constr_expr_1099: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                GC_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1100: Current = {
    let mut init = Current {
        current: Some(GC_Current as unsafe extern "C" fn() -> var),
    };
    init
};
static mut __constr_expr_1094: [var; 48] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"GC\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<GC>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1095 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1096 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1097 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1098 as *const Start as *mut Start as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1099 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Current\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1100 as *const Current as *mut Current as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut GC: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn Cello_Exit() {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = current(GC);
    del_raw(tmp);
}
unsafe extern "C" fn Array_Name() -> *const libc::c_char {
    return b"Array\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Array_Brief() -> *const libc::c_char {
    return b"Sequential Container\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Array_Description() -> *const libc::c_char {
    return b"The `Array` type is data structure containing a sequence of a single type of object. It can dynamically grow and shrink in size depending on how many elements it contains. It allocates storage for the type specified. It also deallocates and destroys the objects inside upon destruction.\n\nElements are copied into an Array using `assign` and will initially have zero'd memory.\n\nElements are ordered linearly. Elements are accessed by their position in this sequence directly. Addition and removal of elements at the end of the sequence is fast, with memory movement required for elements in the middle of the sequence.\n\nThis is largely equivalent to the C++ construct [std::vector](http://www.cplusplus.com/reference/vector/vector/)\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___46: [Example; 5] = [
    {
        let mut init = Example {
            name: b"Construction & Deletion\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int);\npush(x, $I(32));\npush(x, $I(6));\n\n/* <'Array' At 0x0000000000414603 [32, 6]> */\nshow(x);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Element Access\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Float, $F(0.01), $F(5.12));\n\nshow(get(x, $I(0))); /* 0.01 */\nshow(get(x, $I(1))); /* 5.12 */\n\nset(x, $I(0), $F(500.1));\nshow(get(x, $I(0))); /* 500.1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Membership\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, Int, $I(1), $I(2), $I(3), $I(4));\n\nshow($I(mem(x, $I(1)))); /* 1 */\nshow($I(len(x)));        /* 4 */\n\nrem(x, $I(3));\n\nshow($I(mem(x, $I(3)))); /* 0 */\nshow($I(len(x)));        /* 3 */\nshow($I(empty(x)));      /* 0 */\n\nresize(x, 0);\n\nshow($I(empty(x)));      /* 1 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Iteration\0" as *const u8 as *const libc::c_char,
            body: b"var greetings = new(Array, String, \n  $S(\"Hello\"), $S(\"Bonjour\"), $S(\"Hej\"));\n\nforeach(greet in greetings) {\n  show(greet);\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Array_Examples() -> *mut Example {
    return examples___46.as_mut_ptr();
}
unsafe extern "C" fn Array_Step(mut a: *mut Array) -> size_t {
    return ((*a).tsize).wrapping_add(::std::mem::size_of::<Header>() as libc::c_ulong);
}
unsafe extern "C" fn Array_Item(mut a: *mut Array, mut i: size_t) -> var {
    let mut tmp: size_t = 0;
    tmp = Array_Step(a);
    return ((*a).data as *mut libc::c_char)
        .offset(tmp.wrapping_mul(i) as isize)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
unsafe extern "C" fn Array_Alloc(mut a: *mut Array, mut i: size_t) {
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut head: *mut Header = 0 as *mut Header;
    let mut tmp___1: size_t = 0;
    tmp = Array_Step(a);
    tmp___0 = Array_Step(a);
    memset(
        ((*a).data as *mut libc::c_char).offset(tmp___0.wrapping_mul(i) as isize)
            as *mut libc::c_void,
        0 as libc::c_int,
        tmp,
    );
    tmp___1 = Array_Step(a);
    head = ((*a).data as *mut libc::c_char).offset(tmp___1.wrapping_mul(i) as isize)
        as *mut Header;
    header_init(head as var, (*a).type_0, 4 as libc::c_int);
}
unsafe extern "C" fn Array_Size_Round(mut s: size_t) -> size_t {
    return s
        .wrapping_add(::std::mem::size_of::<var>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<var>() as libc::c_ulong)
        .wrapping_mul(::std::mem::size_of::<var>() as libc::c_ulong);
}
unsafe extern "C" fn Array_New(mut self_0: var, mut args: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut __constr_expr_1101: Int = Int { val: 0 };
    let mut __constr_expr_1102: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: size_t = 0;
    let mut tmp___5: size_t = 0;
    let mut __constr_expr_1103: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1104: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1105: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_1106: Int = Int { val: 0 };
    let mut __constr_expr_1107: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    __constr_expr_1101.val = 0 as libc::c_int as int64_t;
    __constr_expr_1102[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1102[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_1102.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_1101 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    (*a).type_0 = cast(tmp___2, Type);
    tmp___3 = size((*a).type_0);
    (*a).tsize = Array_Size_Round(tmp___3);
    tmp___4 = len(args);
    (*a).nitems = tmp___4.wrapping_sub(1 as libc::c_ulong);
    (*a).nslots = (*a).nitems;
    if (*a).nslots == 0 as libc::c_ulong {
        (*a).data = 0 as *mut libc::c_void;
        return;
    }
    tmp___5 = Array_Step(a);
    (*a).data = malloc(((*a).nslots).wrapping_mul(tmp___5));
    if (*a).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1104[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1103.items = __constr_expr_1104.as_mut_ptr();
        __constr_expr_1105[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1105[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1105.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1103 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot allocate Array, out of memory!\0" as *const u8
                as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        Array_Alloc(a, i);
        __constr_expr_1106.val = i.wrapping_add(1 as libc::c_ulong) as int64_t;
        __constr_expr_1107[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = 1 as libc::c_uint;
        while !(tmp___9 >= 32 as libc::c_uint) {
            __constr_expr_1107[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___9 = tmp___9.wrapping_add(1);
        }
        tmp___10 = header_init(
            __constr_expr_1107.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___11 = memcpy(
            tmp___10 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1106 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___12 = get(args, tmp___11 as *mut Int as var);
        tmp___13 = Array_Item(a, i);
        assign(tmp___13, tmp___12);
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn Array_Del(mut self_0: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp = Array_Item(a, i);
        destruct(tmp);
        i = i.wrapping_add(1);
    }
    free((*a).data);
}
unsafe extern "C" fn Array_Clear(mut self_0: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp = Array_Item(a, i);
        destruct(tmp);
        i = i.wrapping_add(1);
    }
    free((*a).data);
    (*a).data = 0 as *mut libc::c_void;
    (*a).nitems = 0 as libc::c_int as size_t;
    (*a).nslots = 0 as libc::c_int as size_t;
}
unsafe extern "C" fn Array_Assign(mut self_0: var, mut obj: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: bool = false;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: size_t = 0;
    let mut __constr_expr_1108: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1109: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1110: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_1111: Int = Int { val: 0 };
    let mut __constr_expr_1112: [libc::c_char; 32] = [0; 32];
    let mut tmp___7: libc::c_uint = 0;
    let mut tmp___8: var = 0 as *mut libc::c_void;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: var = 0 as *mut libc::c_void;
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp___12: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___13: var = 0 as *mut libc::c_void;
    let mut tmp___14: bool = false;
    let mut tmp___15: bool = false;
    a = self_0 as *mut Array;
    Array_Clear(self_0);
    tmp___1 = implements_method_at_offset(
        obj,
        Iter,
        &mut (*(0 as *mut Iter)).iter_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
    );
    if tmp___1 {
        tmp___0 = iter_type(obj);
        (*a).type_0 = tmp___0;
    } else {
        (*a).type_0 = Ref;
    }
    tmp___2 = size((*a).type_0);
    (*a).tsize = Array_Size_Round(tmp___2);
    (*a).nitems = 0 as libc::c_int as size_t;
    (*a).nslots = 0 as libc::c_int as size_t;
    tmp___14 = implements_method_at_offset(
        obj,
        Len,
        &mut (*(0 as *mut Len)).len as *mut Option::<unsafe extern "C" fn(var) -> size_t>
            as libc::c_ulong,
    );
    let mut current_block_62: u64;
    if tmp___14 {
        tmp___15 = implements_method_at_offset(
            obj,
            Get,
            &mut (*(0 as *mut Get)).get
                as *mut Option::<unsafe extern "C" fn(var, var) -> var> as libc::c_ulong,
        );
        if tmp___15 {
            (*a).nitems = len(obj);
            (*a).nslots = (*a).nitems;
            if (*a).nslots == 0 as libc::c_ulong {
                (*a).data = 0 as *mut libc::c_void;
                return;
            }
            tmp___3 = Array_Step(a);
            (*a).data = malloc(((*a).nslots).wrapping_mul(tmp___3));
            if (*a).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                __constr_expr_1109[0 as libc::c_int as usize] = Terminal;
                __constr_expr_1108.items = __constr_expr_1109.as_mut_ptr();
                __constr_expr_1110[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___4 = 1 as libc::c_uint;
                while !(tmp___4 >= 32 as libc::c_uint) {
                    __constr_expr_1110[tmp___4
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___4 = tmp___4.wrapping_add(1);
                }
                tmp___5 = header_init(
                    __constr_expr_1110.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___6 = memcpy(
                    tmp___5 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_1108 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    OutOfMemoryError,
                    b"Cannot allocate Array, out of memory!\0" as *const u8
                        as *const libc::c_char,
                    tmp___6 as *mut Tuple as var,
                );
            }
            i = 0 as libc::c_int as size_t;
            while i < (*a).nitems {
                Array_Alloc(a, i);
                __constr_expr_1111.val = i as int64_t;
                __constr_expr_1112[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___7 = 1 as libc::c_uint;
                while !(tmp___7 >= 32 as libc::c_uint) {
                    __constr_expr_1112[tmp___7
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___7 = tmp___7.wrapping_add(1);
                }
                tmp___8 = header_init(
                    __constr_expr_1112.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___9 = memcpy(
                    tmp___8 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_1111 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                tmp___10 = get(obj, tmp___9 as *mut Int as var);
                tmp___11 = Array_Item(a, i);
                assign(tmp___11, tmp___10);
                i = i.wrapping_add(1);
            }
            current_block_62 = 5235537862154438448;
        } else {
            current_block_62 = 12983974698409014103;
        }
    } else {
        current_block_62 = 12983974698409014103;
    }
    match current_block_62 {
        12983974698409014103 => {
            __item = obj;
            tmp___12 = instance(__item, Iter);
            __Iteritem = tmp___12;
            tmp___13 = (Some(
                ((*(__Iteritem as *mut Iter)).iter_init)
                    .expect("non-null function pointer"),
            ))
                .expect("non-null function pointer")(__item);
            item = tmp___13;
            while item as libc::c_ulong != Terminal as libc::c_ulong {
                Array_Push(self_0, item);
                item = (Some(
                    ((*(__Iteritem as *mut Iter)).iter_next)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(__item, item);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn Array_Reserve_More(mut a: *mut Array) {
    let mut tmp: size_t = 0;
    let mut __constr_expr_1113: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1114: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1115: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    if (*a).nitems > (*a).nslots {
        (*a)
            .nslots = ((*a).nitems)
            .wrapping_add(((*a).nitems).wrapping_div(2 as libc::c_ulong));
        tmp = Array_Step(a);
        (*a).data = realloc((*a).data, tmp.wrapping_mul((*a).nslots));
        if (*a).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            __constr_expr_1114[0 as libc::c_int as usize] = Terminal;
            __constr_expr_1113.items = __constr_expr_1114.as_mut_ptr();
            __constr_expr_1115[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = 1 as libc::c_uint;
            while !(tmp___0 >= 32 as libc::c_uint) {
                __constr_expr_1115[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___0 = tmp___0.wrapping_add(1);
            }
            tmp___1 = header_init(
                __constr_expr_1115.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___2 = memcpy(
                tmp___1 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1113 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                OutOfMemoryError,
                b"Cannot grow Array, out of memory!\0" as *const u8
                    as *const libc::c_char,
                tmp___2 as *mut Tuple as var,
            );
        }
    }
}
unsafe extern "C" fn Array_Concat(mut self_0: var, mut obj: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: size_t = 0;
    let mut olen: size_t = 0;
    let mut tmp: size_t = 0;
    let mut __item: var = 0 as *mut libc::c_void;
    let mut __Iteritem: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut item: var = 0 as *mut libc::c_void;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    i = 0 as libc::c_int as size_t;
    tmp = len(obj);
    olen = tmp;
    (*a).nitems = ((*a).nitems as libc::c_ulong).wrapping_add(olen) as size_t as size_t;
    Array_Reserve_More(a);
    __item = obj;
    tmp___0 = instance(__item, Iter);
    __Iteritem = tmp___0;
    tmp___1 = (Some(
        ((*(__Iteritem as *mut Iter)).iter_init).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(__item);
    item = tmp___1;
    while item as libc::c_ulong != Terminal as libc::c_ulong {
        Array_Alloc(a, ((*a).nitems).wrapping_sub(olen).wrapping_add(i));
        tmp___2 = Array_Item(a, ((*a).nitems).wrapping_sub(olen).wrapping_add(i));
        assign(tmp___2, item);
        i = i.wrapping_add(1);
        item = (Some(
            ((*(__Iteritem as *mut Iter)).iter_next).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(__item, item);
    }
}
unsafe extern "C" fn Array_Cmp(mut self_0: var, mut obj: var) -> libc::c_int {
    let mut item0: var = 0 as *mut libc::c_void;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut item1: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = Array_Iter_Init(self_0);
    item0 = tmp;
    tmp___0 = iter_init(obj);
    item1 = tmp___0;
    loop {
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            if item1 as libc::c_ulong == Terminal as libc::c_ulong {
                return 0 as libc::c_int;
            }
        }
        if item0 as libc::c_ulong == Terminal as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if item1 as libc::c_ulong == Terminal as libc::c_ulong {
            return 1 as libc::c_int;
        }
        tmp___1 = cmp(item0, item1);
        c = tmp___1;
        if c < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if c > 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        item0 = Array_Iter_Next(self_0, item0);
        item1 = iter_next(obj, item1);
    };
}
unsafe extern "C" fn Array_Hash(mut self_0: var) -> uint64_t {
    let mut a: *mut Array = 0 as *mut Array;
    let mut h: uint64_t = 0;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: uint64_t = 0;
    a = self_0 as *mut Array;
    h = 0 as libc::c_int as uint64_t;
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp = Array_Item(a, i);
        tmp___0 = hash(tmp);
        h ^= tmp___0;
        i = i.wrapping_add(1);
    }
    return h;
}
unsafe extern "C" fn Array_Len(mut self_0: var) -> size_t {
    let mut a: *mut Array = 0 as *mut Array;
    a = self_0 as *mut Array;
    return (*a).nitems;
}
unsafe extern "C" fn Array_Mem(mut self_0: var, mut obj: var) -> bool {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    a = self_0 as *mut Array;
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp = Array_Item(a, i);
        tmp___0 = eq(tmp, obj);
        if tmp___0 {
            return 1 as libc::c_int != 0;
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn Array_Reserve_Less(mut a: *mut Array) {
    let mut tmp: size_t = 0;
    if (*a).nslots
        > ((*a).nitems).wrapping_add(((*a).nitems).wrapping_div(2 as libc::c_ulong))
    {
        (*a).nslots = (*a).nitems;
        tmp = Array_Step(a);
        (*a).data = realloc((*a).data, tmp.wrapping_mul((*a).nslots));
    }
}
unsafe extern "C" fn Array_Pop_At(mut self_0: var, mut key: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut __constr_expr_1116: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1117: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_1118: Int = Int { val: 0 };
    let mut __constr_expr_1119: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1120: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: size_t = 0;
    a = self_0 as *mut Array;
    tmp = c_int(key);
    i = tmp;
    if i < 0 as libc::c_long {
        i = ((*a).nitems).wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_158: {
        if !(i < 0 as libc::c_long) {
            if !(i >= (*a).nitems as int64_t) {
                break 's_158;
            }
        }
        __constr_expr_1118.val = (*a).nitems as int64_t;
        __constr_expr_1119[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1119[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1119.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1118 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1117[0 as libc::c_int as usize] = key;
        __constr_expr_1117[1 as libc::c_int as usize] = tmp___2 as *mut Int as var;
        __constr_expr_1117[2 as libc::c_int as usize] = Terminal;
        __constr_expr_1116.items = __constr_expr_1117.as_mut_ptr();
        __constr_expr_1120[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1120[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1120.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1116 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for Array of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        return;
    }
    tmp___6 = Array_Item(a, i as size_t);
    destruct(tmp___6);
    tmp___7 = Array_Step(a);
    tmp___8 = Array_Step(a);
    tmp___9 = Array_Step(a);
    memmove(
        ((*a).data as *mut libc::c_char)
            .offset(tmp___9.wrapping_mul(i as size_t) as isize) as *mut libc::c_void,
        ((*a).data as *mut libc::c_char)
            .offset(tmp___8.wrapping_mul((i + 1 as libc::c_long) as size_t) as isize)
            as *const libc::c_void,
        tmp___7
            .wrapping_mul(
                ((*a).nitems).wrapping_sub(1 as libc::c_ulong).wrapping_sub(i as size_t),
            ),
    );
    (*a).nitems = ((*a).nitems).wrapping_sub(1);
    Array_Reserve_Less(a);
}
unsafe extern "C" fn Array_Rem(mut self_0: var, mut obj: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: size_t = 0;
    let mut __constr_expr_1121: Int = Int { val: 0 };
    let mut __constr_expr_1122: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: bool = false;
    let mut __constr_expr_1123: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1124: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1125: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp___2 = Array_Item(a, i);
        tmp___3 = eq(tmp___2, obj);
        if tmp___3 {
            __constr_expr_1121.val = i as int64_t;
            __constr_expr_1122[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp = 1 as libc::c_uint;
            while !(tmp >= 32 as libc::c_uint) {
                __constr_expr_1122[tmp as usize] = 0 as libc::c_int as libc::c_char;
                tmp = tmp.wrapping_add(1);
            }
            tmp___0 = header_init(
                __constr_expr_1122.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___1 = memcpy(
                tmp___0 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_1121 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            Array_Pop_At(a as var, tmp___1 as *mut Int as var);
            return;
        }
        i = i.wrapping_add(1);
    }
    __constr_expr_1124[0 as libc::c_int as usize] = obj;
    __constr_expr_1124[1 as libc::c_int as usize] = Terminal;
    __constr_expr_1123.items = __constr_expr_1124.as_mut_ptr();
    __constr_expr_1125[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___4 = 1 as libc::c_uint;
    while !(tmp___4 >= 32 as libc::c_uint) {
        __constr_expr_1125[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = tmp___4.wrapping_add(1);
    }
    tmp___5 = header_init(
        __constr_expr_1125.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___6 = memcpy(
        tmp___5 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_1123 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    exception_throw(
        ValueError,
        b"Object %$ not in Array!\0" as *const u8 as *const libc::c_char,
        tmp___6 as *mut Tuple as var,
    );
}
unsafe extern "C" fn Array_Push(mut self_0: var, mut obj: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    (*a).nitems = ((*a).nitems).wrapping_add(1);
    Array_Reserve_More(a);
    Array_Alloc(a, ((*a).nitems).wrapping_sub(1 as libc::c_ulong));
    tmp = Array_Item(a, ((*a).nitems).wrapping_sub(1 as libc::c_ulong));
    assign(tmp, obj);
}
unsafe extern "C" fn Array_Push_At(mut self_0: var, mut obj: var, mut key: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut __constr_expr_1126: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1127: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_1128: Int = Int { val: 0 };
    let mut __constr_expr_1129: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1130: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: size_t = 0;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: size_t = 0;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    (*a).nitems = ((*a).nitems).wrapping_add(1);
    Array_Reserve_More(a);
    tmp = c_int(key);
    i = tmp;
    if i < 0 as libc::c_long {
        i = ((*a).nitems).wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_164: {
        if !(i < 0 as libc::c_long) {
            if !(i >= (*a).nitems as int64_t) {
                break 's_164;
            }
        }
        __constr_expr_1128.val = (*a).nitems as int64_t;
        __constr_expr_1129[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1129[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1129.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1128 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1127[0 as libc::c_int as usize] = key;
        __constr_expr_1127[1 as libc::c_int as usize] = tmp___2 as *mut Int as var;
        __constr_expr_1127[2 as libc::c_int as usize] = Terminal;
        __constr_expr_1126.items = __constr_expr_1127.as_mut_ptr();
        __constr_expr_1130[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1130[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1130.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1126 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for Array of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        return;
    }
    tmp___6 = Array_Step(a);
    tmp___7 = Array_Step(a);
    tmp___8 = Array_Step(a);
    memmove(
        ((*a).data as *mut libc::c_char)
            .offset(tmp___8.wrapping_mul((i + 1 as libc::c_long) as size_t) as isize)
            as *mut libc::c_void,
        ((*a).data as *mut libc::c_char)
            .offset(tmp___7.wrapping_mul(i as size_t) as isize) as *const libc::c_void,
        tmp___6
            .wrapping_mul(
                ((*a).nitems).wrapping_sub(1 as libc::c_ulong).wrapping_sub(i as size_t),
            ),
    );
    Array_Alloc(self_0 as *mut Array, i as size_t);
    tmp___9 = Array_Item(a, i as size_t);
    assign(tmp___9, obj);
}
unsafe extern "C" fn Array_Pop(mut self_0: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut __constr_expr_1131: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1132: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1133: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    if (*a).nitems == 0 as libc::c_ulong {
        __constr_expr_1132[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1131.items = __constr_expr_1132.as_mut_ptr();
        __constr_expr_1133[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1133[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1133.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1131 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Cannot pop. Array is empty!\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
        return;
    }
    tmp___2 = Array_Item(a, ((*a).nitems).wrapping_sub(1 as libc::c_ulong));
    destruct(tmp___2);
    (*a).nitems = ((*a).nitems).wrapping_sub(1);
    Array_Reserve_Less(a);
}
unsafe extern "C" fn Array_Get(mut self_0: var, mut key: var) -> var {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut __constr_expr_1134: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1135: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_1136: Int = Int { val: 0 };
    let mut __constr_expr_1137: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1138: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    tmp = c_int(key);
    i = tmp;
    if i < 0 as libc::c_long {
        i = ((*a).nitems).wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_154: {
        if !(i < 0 as libc::c_long) {
            if !(i >= (*a).nitems as int64_t) {
                break 's_154;
            }
        }
        __constr_expr_1136.val = (*a).nitems as int64_t;
        __constr_expr_1137[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1137[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1137.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1136 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1135[0 as libc::c_int as usize] = key;
        __constr_expr_1135[1 as libc::c_int as usize] = tmp___2 as *mut Int as var;
        __constr_expr_1135[2 as libc::c_int as usize] = Terminal;
        __constr_expr_1134.items = __constr_expr_1135.as_mut_ptr();
        __constr_expr_1138[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1138[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1138.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1134 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        tmp___6 = exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for Array of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        return tmp___6;
    }
    tmp___7 = Array_Item(a, i as size_t);
    return tmp___7;
}
unsafe extern "C" fn Array_Set(mut self_0: var, mut key: var, mut val: var) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: int64_t = 0;
    let mut tmp: int64_t = 0;
    let mut __constr_expr_1139: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1140: [var; 3] = [0 as *mut libc::c_void; 3];
    let mut __constr_expr_1141: Int = Int { val: 0 };
    let mut __constr_expr_1142: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1143: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    tmp = c_int(key);
    i = tmp;
    if i < 0 as libc::c_long {
        i = ((*a).nitems).wrapping_add(i as size_t) as int64_t;
    } else {
        i = i;
    }
    's_152: {
        if !(i < 0 as libc::c_long) {
            if !(i >= (*a).nitems as int64_t) {
                break 's_152;
            }
        }
        __constr_expr_1141.val = (*a).nitems as int64_t;
        __constr_expr_1142[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1142[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1142.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1141 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1140[0 as libc::c_int as usize] = key;
        __constr_expr_1140[1 as libc::c_int as usize] = tmp___2 as *mut Int as var;
        __constr_expr_1140[2 as libc::c_int as usize] = Terminal;
        __constr_expr_1139.items = __constr_expr_1140.as_mut_ptr();
        __constr_expr_1143[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1143[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1143.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1139 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IndexOutOfBoundsError,
            b"Index '%i' out of bounds for Array of size %i.\0" as *const u8
                as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        return;
    }
    tmp___6 = Array_Item(a, i as size_t);
    assign(tmp___6, val);
}
unsafe extern "C" fn Array_Iter_Init(mut self_0: var) -> var {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    if (*a).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    tmp = Array_Item(a, 0 as libc::c_int as size_t);
    return tmp;
}
unsafe extern "C" fn Array_Iter_Next(mut self_0: var, mut curr: var) -> var {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    tmp___0 = Array_Item(a, ((*a).nitems).wrapping_sub(1 as libc::c_ulong));
    if curr as libc::c_ulong >= tmp___0 as libc::c_ulong {
        return Terminal
    } else {
        tmp = Array_Step(a);
        return (curr as *mut libc::c_char).offset(tmp as isize) as var;
    };
}
unsafe extern "C" fn Array_Iter_Last(mut self_0: var) -> var {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    if (*a).nitems == 0 as libc::c_ulong {
        return Terminal;
    }
    tmp = Array_Item(a, ((*a).nitems).wrapping_sub(1 as libc::c_ulong));
    return tmp;
}
unsafe extern "C" fn Array_Iter_Prev(mut self_0: var, mut curr: var) -> var {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp: size_t = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    tmp___0 = Array_Item(a, 0 as libc::c_int as size_t);
    if (curr as libc::c_ulong) < tmp___0 as libc::c_ulong {
        return Terminal
    } else {
        tmp = Array_Step(a);
        return (curr as *mut libc::c_char).offset(-(tmp as isize)) as var;
    };
}
unsafe extern "C" fn Array_Iter_Type(mut self_0: var) -> var {
    let mut a: *mut Array = 0 as *mut Array;
    a = self_0 as *mut Array;
    return (*a).type_0;
}
unsafe extern "C" fn Array_Sort_Partition(
    mut a: *mut Array,
    mut l: int64_t,
    mut r: int64_t,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) -> size_t {
    let mut p: int64_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut s: int64_t = 0;
    let mut i: int64_t = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1144: Int = Int { val: 0 };
    let mut __constr_expr_1145: [libc::c_char; 32] = [0; 32];
    let mut tmp___4: libc::c_uint = 0;
    let mut tmp___5: var = 0 as *mut libc::c_void;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: bool = false;
    let mut tmp___9: var = 0 as *mut libc::c_void;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    p = l + (r - l) / 2 as libc::c_long;
    tmp = Array_Item(a, r as size_t);
    tmp___0 = Array_Item(a, p as size_t);
    swap(tmp___0, tmp);
    s = l;
    i = l;
    while i < r {
        tmp___3 = Array_Item(a, r as size_t);
        __constr_expr_1144.val = i;
        __constr_expr_1145[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___4 = 1 as libc::c_uint;
        while !(tmp___4 >= 32 as libc::c_uint) {
            __constr_expr_1145[tmp___4 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___4 = tmp___4.wrapping_add(1);
        }
        tmp___5 = header_init(
            __constr_expr_1145.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___6 = memcpy(
            tmp___5 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1144 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___7 = Array_Get(a as var, tmp___6 as *mut Int as var);
        tmp___8 = (Some(f.expect("non-null function pointer")))
            .expect("non-null function pointer")(tmp___7, tmp___3);
        if tmp___8 {
            tmp___1 = Array_Item(a, s as size_t);
            tmp___2 = Array_Item(a, i as size_t);
            swap(tmp___2, tmp___1);
            s += 1;
        }
        i += 1;
    }
    tmp___9 = Array_Item(a, r as size_t);
    tmp___10 = Array_Item(a, s as size_t);
    swap(tmp___10, tmp___9);
    return s as size_t;
}
unsafe extern "C" fn Array_Sort_Part(
    mut a: *mut Array,
    mut l: int64_t,
    mut r: int64_t,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) {
    let mut s: int64_t = 0;
    let mut tmp: size_t = 0;
    if l < r {
        tmp = Array_Sort_Partition(a, l, r, f);
        s = tmp as int64_t;
        Array_Sort_Part(a, l, s - 1 as libc::c_long, f);
        Array_Sort_Part(a, s + 1 as libc::c_long, r, f);
    }
}
unsafe extern "C" fn Array_Sort_By(
    mut self_0: var,
    mut f: Option::<unsafe extern "C" fn(var, var) -> bool>,
) {
    let mut tmp: size_t = 0;
    tmp = Array_Len(self_0);
    Array_Sort_Part(
        self_0 as *mut Array,
        0 as libc::c_int as int64_t,
        tmp.wrapping_sub(1 as libc::c_ulong) as int64_t,
        f,
    );
}
unsafe extern "C" fn Array_Show(
    mut self_0: var,
    mut output: var,
    mut pos: libc::c_int,
) -> libc::c_int {
    let mut a: *mut Array = 0 as *mut Array;
    let mut __constr_expr_1146: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1147: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1148: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut __constr_expr_1149: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1150: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1151: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1152: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1153: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1154: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1155: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1156: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1157: [libc::c_char; 32] = [0; 32];
    let mut tmp___9: libc::c_uint = 0;
    let mut tmp___10: var = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: libc::c_int = 0;
    a = self_0 as *mut Array;
    __constr_expr_1147[0 as libc::c_int as usize] = self_0;
    __constr_expr_1147[1 as libc::c_int as usize] = Terminal;
    __constr_expr_1146.items = __constr_expr_1147.as_mut_ptr();
    __constr_expr_1148[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1148[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(
        __constr_expr_1148.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___1 = memcpy(
        tmp___0 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_1146 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    pos = print_to_with(
        output,
        pos,
        b"<'Array' At 0x%p [\0" as *const u8 as *const libc::c_char,
        tmp___1 as *mut Tuple as var,
    );
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp___2 = Array_Item(a, i);
        __constr_expr_1150[0 as libc::c_int as usize] = tmp___2;
        __constr_expr_1150[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1149.items = __constr_expr_1150.as_mut_ptr();
        __constr_expr_1151[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1151[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1151.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1149 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        pos = print_to_with(
            output,
            pos,
            b"%$\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
        if i < ((*a).nitems).wrapping_sub(1 as libc::c_ulong) {
            __constr_expr_1153[0 as libc::c_int as usize] = Terminal;
            __constr_expr_1152.items = __constr_expr_1153.as_mut_ptr();
            __constr_expr_1154[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = 1 as libc::c_uint;
            while !(tmp___6 >= 32 as libc::c_uint) {
                __constr_expr_1154[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = tmp___6.wrapping_add(1);
            }
            tmp___7 = header_init(
                __constr_expr_1154.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___8 = memcpy(
                tmp___7 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1152 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            pos = print_to_with(
                output,
                pos,
                b", \0" as *const u8 as *const libc::c_char,
                tmp___8 as *mut Tuple as var,
            );
        }
        i = i.wrapping_add(1);
    }
    __constr_expr_1156[0 as libc::c_int as usize] = Terminal;
    __constr_expr_1155.items = __constr_expr_1156.as_mut_ptr();
    __constr_expr_1157[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___9 = 1 as libc::c_uint;
    while !(tmp___9 >= 32 as libc::c_uint) {
        __constr_expr_1157[tmp___9 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___9 = tmp___9.wrapping_add(1);
    }
    tmp___10 = header_init(
        __constr_expr_1157.as_mut_ptr() as var,
        Tuple,
        2 as libc::c_int,
    );
    tmp___11 = memcpy(
        tmp___10 as *mut Tuple as *mut libc::c_void,
        &mut __constr_expr_1155 as *mut Tuple as *const libc::c_void,
        ::std::mem::size_of::<Tuple>() as libc::c_ulong,
    );
    tmp___12 = print_to_with(
        output,
        pos,
        b"]>\0" as *const u8 as *const libc::c_char,
        tmp___11 as *mut Tuple as var,
    );
    return tmp___12;
}
unsafe extern "C" fn Array_Resize(mut self_0: var, mut n: size_t) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    let mut __constr_expr_1158: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1159: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1160: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    if n == 0 as libc::c_ulong {
        Array_Clear(self_0);
        return;
    }
    while n < (*a).nitems {
        tmp = Array_Item(a, ((*a).nitems).wrapping_sub(1 as libc::c_ulong));
        destruct(tmp);
        (*a).nitems = ((*a).nitems).wrapping_sub(1);
    }
    (*a).nslots = n;
    tmp___0 = Array_Step(a);
    (*a).data = realloc((*a).data, tmp___0.wrapping_mul((*a).nslots));
    if (*a).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1159[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1158.items = __constr_expr_1159.as_mut_ptr();
        __constr_expr_1160[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = 1 as libc::c_uint;
        while !(tmp___1 >= 32 as libc::c_uint) {
            __constr_expr_1160[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = tmp___1.wrapping_add(1);
        }
        tmp___2 = header_init(
            __constr_expr_1160.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___3 = memcpy(
            tmp___2 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1158 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            OutOfMemoryError,
            b"Cannot grow Array, out of memory!\0" as *const u8 as *const libc::c_char,
            tmp___3 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn Array_Mark(
    mut self_0: var,
    mut gc: var,
    mut f: Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
) {
    let mut a: *mut Array = 0 as *mut Array;
    let mut i: size_t = 0;
    let mut tmp: var = 0 as *mut libc::c_void;
    a = self_0 as *mut Array;
    i = 0 as libc::c_int as size_t;
    while i < (*a).nitems {
        tmp = Array_Item(a, i);
        (Some(f.expect("non-null function pointer")))
            .expect("non-null function pointer")(gc, tmp);
        i = i.wrapping_add(1);
    }
}
static mut __constr_expr_1162: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Array_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Array_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Array_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *const libc::c_char>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            examples: Some(Array_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1163: New = {
    let mut init = New {
        construct_with: Some(Array_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Array_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_1164: Assign = {
    let mut init = Assign {
        assign: Some(Array_Assign as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_1165: Mark = {
    let mut init = Mark {
        mark: Some(
            Array_Mark
                as unsafe extern "C" fn(
                    var,
                    var,
                    Option::<unsafe extern "C" fn(var, *mut libc::c_void) -> ()>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_1166: Cmp = {
    let mut init = Cmp {
        cmp: Some(Array_Cmp as unsafe extern "C" fn(var, var) -> libc::c_int),
    };
    init
};
static mut __constr_expr_1167: Hash = {
    let mut init = Hash {
        hash: Some(Array_Hash as unsafe extern "C" fn(var) -> uint64_t),
    };
    init
};
static mut __constr_expr_1168: Push = {
    let mut init = Push {
        push: Some(Array_Push as unsafe extern "C" fn(var, var) -> ()),
        pop: Some(Array_Pop as unsafe extern "C" fn(var) -> ()),
        push_at: Some(Array_Push_At as unsafe extern "C" fn(var, var, var) -> ()),
        pop_at: Some(Array_Pop_At as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_1169: Concat = {
    let mut init = Concat {
        concat: Some(Array_Concat as unsafe extern "C" fn(var, var) -> ()),
        append: Some(Array_Push as unsafe extern "C" fn(var, var) -> ()),
    };
    init
};
static mut __constr_expr_1170: Len = {
    let mut init = Len {
        len: Some(Array_Len as unsafe extern "C" fn(var) -> size_t),
    };
    init
};
static mut __constr_expr_1171: Get = {
    let mut init = Get {
        get: Some(Array_Get as unsafe extern "C" fn(var, var) -> var),
        set: Some(Array_Set as unsafe extern "C" fn(var, var, var) -> ()),
        mem: Some(Array_Mem as unsafe extern "C" fn(var, var) -> bool),
        rem: Some(Array_Rem as unsafe extern "C" fn(var, var) -> ()),
        key_type: None,
        val_type: None,
    };
    init
};
static mut __constr_expr_1172: Iter = {
    let mut init = Iter {
        iter_init: Some(Array_Iter_Init as unsafe extern "C" fn(var) -> var),
        iter_next: Some(Array_Iter_Next as unsafe extern "C" fn(var, var) -> var),
        iter_last: Some(Array_Iter_Last as unsafe extern "C" fn(var) -> var),
        iter_prev: Some(Array_Iter_Prev as unsafe extern "C" fn(var, var) -> var),
        iter_type: Some(Array_Iter_Type as unsafe extern "C" fn(var) -> var),
    };
    init
};
static mut __constr_expr_1173: Sort = {
    let mut init = Sort {
        sort_by: Some(
            Array_Sort_By
                as unsafe extern "C" fn(
                    var,
                    Option::<unsafe extern "C" fn(var, var) -> bool>,
                ) -> (),
        ),
    };
    init
};
static mut __constr_expr_1174: Show = unsafe {
    {
        let mut init = Show {
            show: Some(
                Array_Show as unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int,
            ),
            look: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var, var, libc::c_int) -> libc::c_int>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1175: Resize = {
    let mut init = Resize {
        resize: Some(Array_Resize as unsafe extern "C" fn(var, size_t) -> ()),
    };
    init
};
static mut __constr_expr_1161: [var; 72] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Array\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Array>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1162 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1163 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Assign\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1164 as *const Assign as *mut Assign as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Mark\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1165 as *const Mark as *mut Mark as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Cmp\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1166 as *const Cmp as *mut Cmp as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Hash\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1167 as *const Hash as *mut Hash as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Push\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1168 as *const Push as *mut Push as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Concat\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1169 as *const Concat as *mut Concat as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Len\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1170 as *const Len as *mut Len as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1171 as *const Get as *mut Get as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Iter\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1172 as *const Iter as *mut Iter as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Sort\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1173 as *const Sort as *mut Sort as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Show\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1174 as *const Show as *mut Show as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Resize\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1175 as *const Resize as *mut Resize as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Array: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Get_Name() -> *const libc::c_char {
    return b"Get\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Get_Brief() -> *const libc::c_char {
    return b"Gettable or Settable\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Get_Description() -> *const libc::c_char {
    return b"The `Get` class provides a method to _get_ or _set_ certain properties of an object using keys and value. Typically it is implemented by data lookup structures such as `Table` or `Map` but it is also used more generally such as using indices to look up items in `Array`, or as thread local storage for the `Thread` object.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Get_Definition() -> *const libc::c_char {
    return b"struct Get {\n  var  (*get)(var, var);\n  void (*set)(var, var, var);\n  bool (*mem)(var, var);\n  void (*rem)(var, var);\n  var (*key_type)(var);\n  var (*val_type)(var);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___47: [Example; 3] = [
    {
        let mut init = Example {
            name: b"Usage 1\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Array, String, \n  $S(\"Hello\"), $S(\"There\"));\n\nshow(get(x, $I(0))); /* Hello */\nshow(get(x, $I(1))); /* There */\nset(x, $I(1), $S(\"Blah\"));\nshow(get(x, $I(1))); /* Blah */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Usage 2\0" as *const u8 as *const libc::c_char,
            body: b"var prices = new(Table, String, Int, \n  $S(\"Apple\"),  $I(12),\n  $S(\"Banana\"), $I( 6),\n  $S(\"Pear\"),   $I(55));\n\nvar pear_price   = get(prices, $S(\"Pear\"));\nvar banana_price = get(prices, $S(\"Banana\"));\nvar apple_price  = get(prices, $S(\"Apple\"));\n\nshow(pear_price);   /* 55 */\nshow(banana_price); /*  6 */\nshow(apple_price);  /* 12 */\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Get_Examples() -> *mut Example {
    return examples___47.as_mut_ptr();
}
static mut methods___35: [Method; 7] = [
    {
        let mut init = Method {
            name: b"get\0" as *const u8 as *const libc::c_char,
            definition: b"var get(var self, var key);\0" as *const u8
                as *const libc::c_char,
            description: b"Get the value at a given `key` for object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"set\0" as *const u8 as *const libc::c_char,
            definition: b"void set(var self, var key, var val);\0" as *const u8
                as *const libc::c_char,
            description: b"Set the value at a given `key` for object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"mem\0" as *const u8 as *const libc::c_char,
            definition: b"bool mem(var self, var key);\0" as *const u8
                as *const libc::c_char,
            description: b"Returns true if `key` is a member of the object `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"rem\0" as *const u8 as *const libc::c_char,
            definition: b"void rem(var self, var key);\0" as *const u8
                as *const libc::c_char,
            description: b"Removes the `key` from object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"key_type\0" as *const u8 as *const libc::c_char,
            definition: b"var key_type(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the key type for the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"val_type\0" as *const u8 as *const libc::c_char,
            definition: b"var val_type(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Returns the value type for the object `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Get_Methods() -> *mut Method {
    return methods___35.as_mut_ptr();
}
static mut __constr_expr_1177: Doc = {
    let mut init = Doc {
        name: Some(Get_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Get_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Get_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Get_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Get_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Get_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_1176: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Get\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Get>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1177 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Get: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn get(mut self_0: var, mut key: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Get,
        &mut (*(0 as *mut Get)).get
            as *mut Option::<unsafe extern "C" fn(var, var) -> var> as libc::c_ulong,
        b"get\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Get)).get).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, key);
    return tmp___0;
}
pub unsafe extern "C" fn set(mut self_0: var, mut key: var, mut val: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Get,
        &mut (*(0 as *mut Get)).set
            as *mut Option::<unsafe extern "C" fn(var, var, var) -> ()> as libc::c_ulong,
        b"set\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Get)).set).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, key, val);
}
pub unsafe extern "C" fn mem(mut self_0: var, mut key: var) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = method_at_offset(
        self_0,
        Get,
        &mut (*(0 as *mut Get)).mem
            as *mut Option::<unsafe extern "C" fn(var, var) -> bool> as libc::c_ulong,
        b"mem\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Get)).mem).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, key);
    return tmp___0;
}
pub unsafe extern "C" fn rem(mut self_0: var, mut key: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Get,
        &mut (*(0 as *mut Get)).rem
            as *mut Option::<unsafe extern "C" fn(var, var) -> ()> as libc::c_ulong,
        b"rem\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Get)).rem).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, key);
}
pub unsafe extern "C" fn key_type(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Get,
        &mut (*(0 as *mut Get)).key_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
        b"key_type\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Get)).key_type).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn val_type(mut self_0: var) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Get,
        &mut (*(0 as *mut Get)).val_type
            as *mut Option::<unsafe extern "C" fn(var) -> var> as libc::c_ulong,
        b"val_type\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Get)).val_type).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
unsafe extern "C" fn Stream_Name() -> *const libc::c_char {
    return b"Stream\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Stream_Brief() -> *const libc::c_char {
    return b"File-like\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Stream_Description() -> *const libc::c_char {
    return b"The `Stream` class represents an abstract set of operations that can be performed on File-like objects.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Stream_Definition() -> *const libc::c_char {
    return b"struct Stream {\n  var  (*sopen)(var,var,var);\n  void (*sclose)(var);\n  void (*sseek)(var,int64_t,int);\n  int64_t (*stell)(var);\n  void (*sflush)(var);\n  bool (*seof)(var);\n  size_t (*sread)(var,void*,size_t);\n  size_t (*swrite)(var,void*,size_t);\n};\n\0"
        as *const u8 as *const libc::c_char;
}
static mut examples___48: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var f = sopen($(File, NULL), $S(\"test.bin\"), $S(\"r\"));\n\nchar c;\nwhile (!seof(f)) {\n  sread(f, &c, 1);\n  putc(c, stdout);\n}\n\nsclose(f);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Stream_Examples() -> *mut Example {
    return examples___48.as_mut_ptr();
}
static mut methods___36: [Method; 9] = [
    {
        let mut init = Method {
            name: b"sopen\0" as *const u8 as *const libc::c_char,
            definition: b"var sopen(var self, var resource, var options);\0" as *const u8
                as *const libc::c_char,
            description: b"Open the stream `self` with a given `resource` and `options`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"sclose\0" as *const u8 as *const libc::c_char,
            definition: b"void sclose(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Close the stream `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"sseek\0" as *const u8 as *const libc::c_char,
            definition: b"void sseek(var self, int64_t pos, int origin);\0" as *const u8
                as *const libc::c_char,
            description: b"Seek to the position `pos` from some `origin` in the stream `self`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"stell\0" as *const u8 as *const libc::c_char,
            definition: b"int64_t stell(var self);\0" as *const u8
                as *const libc::c_char,
            description: b"Return the current position of the stream `stell`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"sflush\0" as *const u8 as *const libc::c_char,
            definition: b"void sflush(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Flush the buffered contents of stream `self`.\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"seof\0" as *const u8 as *const libc::c_char,
            definition: b"bool seof(var self);\0" as *const u8 as *const libc::c_char,
            description: b"Returns true if there is no more information in the stream.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"sread\0" as *const u8 as *const libc::c_char,
            definition: b"size_t sread(var self, void* output, size_t size);\0"
                as *const u8 as *const libc::c_char,
            description: b"Read `size` bytes from the stream `self` and write them to `output`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: b"swrite\0" as *const u8 as *const libc::c_char,
            definition: b"size_t swrite(var self, void* input, size_t size);\0"
                as *const u8 as *const libc::c_char,
            description: b"Write `size` bytes to the stream `self` and read them from `input`.\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Method {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            definition: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            description: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Stream_Methods() -> *mut Method {
    return methods___36.as_mut_ptr();
}
static mut __constr_expr_1179: Doc = {
    let mut init = Doc {
        name: Some(Stream_Name as unsafe extern "C" fn() -> *const libc::c_char),
        brief: Some(Stream_Brief as unsafe extern "C" fn() -> *const libc::c_char),
        description: Some(
            Stream_Description as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        definition: Some(
            Stream_Definition as unsafe extern "C" fn() -> *const libc::c_char,
        ),
        examples: Some(Stream_Examples as unsafe extern "C" fn() -> *mut Example),
        methods: Some(Stream_Methods as unsafe extern "C" fn() -> *mut Method),
    };
    init
};
static mut __constr_expr_1178: [var; 33] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Stream\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Stream>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1179 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Stream: var = 0 as *const libc::c_void as *mut libc::c_void;
pub unsafe extern "C" fn sopen(
    mut self_0: var,
    mut resource: var,
    mut options: var,
) -> var {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).sopen
            as *mut Option::<unsafe extern "C" fn(var, var, var) -> var>
            as libc::c_ulong,
        b"sopen\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Stream)).sopen).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, resource, options);
    return tmp___0;
}
pub unsafe extern "C" fn sclose(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).sclose
            as *mut Option::<unsafe extern "C" fn(var) -> ()> as libc::c_ulong,
        b"sclose\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Stream)).sclose).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn sseek(
    mut self_0: var,
    mut pos: int64_t,
    mut origin: libc::c_int,
) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).sseek
            as *mut Option::<unsafe extern "C" fn(var, int64_t, libc::c_int) -> ()>
            as libc::c_ulong,
        b"sseek\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Stream)).sseek).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, pos, origin);
}
pub unsafe extern "C" fn stell(mut self_0: var) -> int64_t {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: int64_t = 0;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).stell
            as *mut Option::<unsafe extern "C" fn(var) -> int64_t> as libc::c_ulong,
        b"stell\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Stream)).stell).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn sflush(mut self_0: var) {
    let mut tmp: var = 0 as *mut libc::c_void;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).sflush
            as *mut Option::<unsafe extern "C" fn(var) -> ()> as libc::c_ulong,
        b"sflush\0" as *const u8 as *const libc::c_char,
    );
    (Some(((*(tmp as *mut Stream)).sflush).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
}
pub unsafe extern "C" fn seof(mut self_0: var) -> bool {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: bool = false;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).seof
            as *mut Option::<unsafe extern "C" fn(var) -> bool> as libc::c_ulong,
        b"seof\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Stream)).seof).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0);
    return tmp___0;
}
pub unsafe extern "C" fn sread(
    mut self_0: var,
    mut output: *mut libc::c_void,
    mut size___0: size_t,
) -> size_t {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).sread
            as *mut Option::<
                unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t,
            > as libc::c_ulong,
        b"sread\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(((*(tmp as *mut Stream)).sread).expect("non-null function pointer")))
        .expect("non-null function pointer")(self_0, output, size___0);
    return tmp___0;
}
pub unsafe extern "C" fn swrite(
    mut self_0: var,
    mut input: *mut libc::c_void,
    mut size___0: size_t,
) -> size_t {
    let mut tmp: var = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    tmp = method_at_offset(
        self_0,
        Stream,
        &mut (*(0 as *mut Stream)).swrite
            as *mut Option::<
                unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t,
            > as libc::c_ulong,
        b"swrite\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = (Some(
        ((*(tmp as *mut Stream)).swrite).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(self_0, input, size___0);
    return tmp___0;
}
unsafe extern "C" fn File_Name() -> *const libc::c_char {
    return b"File\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn File_Brief() -> *const libc::c_char {
    return b"Operating System File\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn File_Description() -> *const libc::c_char {
    return b"The `File` type is a wrapper of the native C `FILE` type representing a file in the operating system.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn File_Definition() -> *const libc::c_char {
    return b"struct File {\n  FILE* file;\n};\n\0" as *const u8 as *const libc::c_char;
}
static mut examples___49: [Example; 4] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(File, $S(\"test.bin\"), $S(\"wb\"));\nchar* data = \"hello\";\nswrite(x, data, strlen(data));\nsclose(x);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Formatted Printing\0" as *const u8 as *const libc::c_char,
            body: b"var x = $(File, NULL);\nsopen(x, $S(\"test.txt\"), $S(\"w\"));\nprint_to(x, 0, \"%$ is %$ \", $S(\"Dan\"), $I(23));\nprint_to(x, 0, \"%$ is %$ \", $S(\"Chess\"), $I(24));\nsclose(x);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: b"Automatic Closing\0" as *const u8 as *const libc::c_char,
            body: b"with(f in new(File, $S(\"test.txt\"), $S(\"r\"))) {\n  var k = new(String); resize(k, 100);\n  var v = new(Int, $I(0));\n  foreach (i in range($I(2))) {\n    scan_from(f, 0, \"%$ is %$ \", k, v);\n    show(k); show(v);\n  }\n}\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn File_Examples() -> *mut Example {
    return examples___49.as_mut_ptr();
}
unsafe extern "C" fn File_New(mut self_0: var, mut args: var) {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1180: Int = Int { val: 0 };
    let mut __constr_expr_1181: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1182: Int = Int { val: 0 };
    let mut __constr_expr_1183: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    let mut tmp___7: size_t = 0;
    f = self_0 as *mut File;
    tmp___7 = len(args);
    if tmp___7 > 0 as libc::c_ulong {
        __constr_expr_1180.val = 1 as libc::c_int as int64_t;
        __constr_expr_1181[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1181[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1181.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1180 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___2 = get(args, tmp___1 as *mut Int as var);
        __constr_expr_1182.val = 0 as libc::c_int as int64_t;
        __constr_expr_1183[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1183[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1183.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1182 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        tmp___6 = get(args, tmp___5 as *mut Int as var);
        File_Open(self_0, tmp___6, tmp___2);
    }
}
unsafe extern "C" fn File_Del(mut self_0: var) {
    let mut f: *mut File = 0 as *mut File;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        File_Close(self_0);
    }
}
unsafe extern "C" fn File_Open(
    mut self_0: var,
    mut filename: var,
    mut access: var,
) -> var {
    let mut f: *mut File = 0 as *mut File;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __constr_expr_1184: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1185: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1186: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        File_Close(self_0);
    }
    tmp = c_str(access);
    tmp___0 = c_str(filename);
    (*f).file = fopen(tmp___0 as *const libc::c_char, tmp as *const libc::c_char);
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1185[0 as libc::c_int as usize] = filename;
        __constr_expr_1185[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1184.items = __constr_expr_1185.as_mut_ptr();
        __constr_expr_1186[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = 1 as libc::c_uint;
        while !(tmp___1 >= 32 as libc::c_uint) {
            __constr_expr_1186[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = tmp___1.wrapping_add(1);
        }
        tmp___2 = header_init(
            __constr_expr_1186.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___3 = memcpy(
            tmp___2 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1184 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Could not open file: %s\0" as *const u8 as *const libc::c_char,
            tmp___3 as *mut Tuple as var,
        );
    }
    return self_0;
}
unsafe extern "C" fn File_Close(mut self_0: var) {
    let mut f: *mut File = 0 as *mut File;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_1187: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1188: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1189: Int = Int { val: 0 };
    let mut __constr_expr_1190: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1191: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut File;
    tmp = fclose((*f).file);
    err = tmp;
    if err != 0 as libc::c_int {
        __constr_expr_1189.val = err as int64_t;
        __constr_expr_1190[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1190[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1190.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1189 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1188[0 as libc::c_int as usize] = tmp___2 as *mut Int as var;
        __constr_expr_1188[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1187.items = __constr_expr_1188.as_mut_ptr();
        __constr_expr_1191[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1191[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1191.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1187 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to close file: %i\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
    (*f).file = 0 as *mut libc::c_void as *mut FILE;
}
unsafe extern "C" fn File_Seek(
    mut self_0: var,
    mut pos: int64_t,
    mut origin: libc::c_int,
) {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1192: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1193: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1194: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut err: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut __constr_expr_1195: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1196: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1197: Int = Int { val: 0 };
    let mut __constr_expr_1198: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1199: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1193[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1192.items = __constr_expr_1193.as_mut_ptr();
        __constr_expr_1194[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1194[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1194.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1192 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot seek file - no file open.\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fseek((*f).file, pos, origin);
    err = tmp___2;
    if err != 0 as libc::c_int {
        __constr_expr_1197.val = err as int64_t;
        __constr_expr_1198[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1198[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1198.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1197 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1196[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
        __constr_expr_1196[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1195.items = __constr_expr_1196.as_mut_ptr();
        __constr_expr_1199[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1199[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1199.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1195 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to seek in file: %i\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn File_Tell(mut self_0: var) -> int64_t {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1200: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1201: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1202: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: int64_t = 0;
    let mut tmp___2: libc::c_long = 0;
    let mut __constr_expr_1203: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1204: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1205: Int = Int { val: 0 };
    let mut __constr_expr_1206: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1207: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1201[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1200.items = __constr_expr_1201.as_mut_ptr();
        __constr_expr_1202[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1202[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1202.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1200 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot tell file - no file open.\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = ftell((*f).file);
    i = tmp___2;
    if i == -(1 as libc::c_long) {
        __constr_expr_1205.val = i;
        __constr_expr_1206[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1206[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1206.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1205 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1204[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
        __constr_expr_1204[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1203.items = __constr_expr_1204.as_mut_ptr();
        __constr_expr_1207[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1207[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1207.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1203 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to tell file: %i\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    return i;
}
unsafe extern "C" fn File_Flush(mut self_0: var) {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1208: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1209: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1210: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut err: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut __constr_expr_1211: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1212: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1213: Int = Int { val: 0 };
    let mut __constr_expr_1214: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1215: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1209[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1208.items = __constr_expr_1209.as_mut_ptr();
        __constr_expr_1210[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1210[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1210.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1208 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot flush file - no file open.\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fflush((*f).file);
    err = tmp___2;
    if err != 0 as libc::c_int {
        __constr_expr_1213.val = err as int64_t;
        __constr_expr_1214[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1214[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1214.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1213 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1212[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
        __constr_expr_1212[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1211.items = __constr_expr_1212.as_mut_ptr();
        __constr_expr_1215[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1215[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1215.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1211 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to flush file: %i\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn File_EOF(mut self_0: var) -> bool {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1216: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1217: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1218: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1217[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1216.items = __constr_expr_1217.as_mut_ptr();
        __constr_expr_1218[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1218[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1218.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1216 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot eof file - no file open.\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = feof((*f).file);
    return tmp___2 != 0;
}
unsafe extern "C" fn File_Read(
    mut self_0: var,
    mut output: *mut libc::c_void,
    mut size___0: size_t,
) -> size_t {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1219: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1220: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1221: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut num: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut __constr_expr_1222: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1223: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1224: Int = Int { val: 0 };
    let mut __constr_expr_1225: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1226: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: libc::c_int = 0;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1220[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1219.items = __constr_expr_1220.as_mut_ptr();
        __constr_expr_1221[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1221[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1221.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1219 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot read file - no file open.\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fread(output, size___0, 1 as libc::c_int as size_t, (*f).file);
    num = tmp___2;
    if num != 1 as libc::c_ulong {
        if size___0 != 0 as libc::c_ulong {
            tmp___9 = feof((*f).file);
            if tmp___9 == 0 {
                __constr_expr_1224.val = num as int64_t;
                __constr_expr_1225[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___3 = 1 as libc::c_uint;
                while !(tmp___3 >= 32 as libc::c_uint) {
                    __constr_expr_1225[tmp___3
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___3 = tmp___3.wrapping_add(1);
                }
                tmp___4 = header_init(
                    __constr_expr_1225.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___5 = memcpy(
                    tmp___4 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_1224 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                __constr_expr_1223[0 as libc::c_int
                    as usize] = tmp___5 as *mut Int as var;
                __constr_expr_1223[1 as libc::c_int as usize] = Terminal;
                __constr_expr_1222.items = __constr_expr_1223.as_mut_ptr();
                __constr_expr_1226[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = 1 as libc::c_uint;
                while !(tmp___6 >= 32 as libc::c_uint) {
                    __constr_expr_1226[tmp___6
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___6 = tmp___6.wrapping_add(1);
                }
                tmp___7 = header_init(
                    __constr_expr_1226.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___8 = memcpy(
                    tmp___7 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_1222 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    IOError,
                    b"Failed to read from file: %i\0" as *const u8
                        as *const libc::c_char,
                    tmp___8 as *mut Tuple as var,
                );
                return num;
            }
        }
    }
    return num;
}
unsafe extern "C" fn File_Write(
    mut self_0: var,
    mut input: *mut libc::c_void,
    mut size___0: size_t,
) -> size_t {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1227: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1228: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1229: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut num: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut __constr_expr_1230: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1231: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1232: Int = Int { val: 0 };
    let mut __constr_expr_1233: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1234: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1228[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1227.items = __constr_expr_1228.as_mut_ptr();
        __constr_expr_1229[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1229[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1229.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1227 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot write file - no file open.\0" as *const u8 as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fwrite(
        input as *const libc::c_void,
        size___0,
        1 as libc::c_int as size_t,
        (*f).file,
    );
    num = tmp___2;
    if num != 1 as libc::c_ulong {
        if size___0 != 0 as libc::c_ulong {
            __constr_expr_1232.val = num as int64_t;
            __constr_expr_1233[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = 1 as libc::c_uint;
            while !(tmp___3 >= 32 as libc::c_uint) {
                __constr_expr_1233[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___3 = tmp___3.wrapping_add(1);
            }
            tmp___4 = header_init(
                __constr_expr_1233.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___5 = memcpy(
                tmp___4 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_1232 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            __constr_expr_1231[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
            __constr_expr_1231[1 as libc::c_int as usize] = Terminal;
            __constr_expr_1230.items = __constr_expr_1231.as_mut_ptr();
            __constr_expr_1234[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = 1 as libc::c_uint;
            while !(tmp___6 >= 32 as libc::c_uint) {
                __constr_expr_1234[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = tmp___6.wrapping_add(1);
            }
            tmp___7 = header_init(
                __constr_expr_1234.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___8 = memcpy(
                tmp___7 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1230 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                IOError,
                b"Failed to write to file: %i\0" as *const u8 as *const libc::c_char,
                tmp___8 as *mut Tuple as var,
            );
        }
    }
    return num;
}
unsafe extern "C" fn File_Format_To(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1235: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1236: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1237: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1236[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1235.items = __constr_expr_1236.as_mut_ptr();
        __constr_expr_1237[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1237[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1237.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1235 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot format to file - no file open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = vfprintf((*f).file, fmt, va.as_va_list());
    return tmp___2;
}
unsafe extern "C" fn File_Format_From(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut f: *mut File = 0 as *mut File;
    let mut __constr_expr_1238: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1239: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1240: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    f = self_0 as *mut File;
    if (*f).file as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1239[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1238.items = __constr_expr_1239.as_mut_ptr();
        __constr_expr_1240[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1240[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1240.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1238 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot format from file - no file open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = vfscanf((*f).file, fmt, va.as_va_list());
    return tmp___2;
}
static mut __constr_expr_1242: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(File_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(File_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                File_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                File_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(File_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1243: New = {
    let mut init = New {
        construct_with: Some(File_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(File_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_1244: Start = unsafe {
    {
        let mut init = Start {
            start: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            stop: Some(File_Close as unsafe extern "C" fn(var) -> ()),
            join: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            running: None,
        };
        init
    }
};
static mut __constr_expr_1245: Stream = {
    let mut init = Stream {
        sopen: Some(File_Open as unsafe extern "C" fn(var, var, var) -> var),
        sclose: Some(File_Close as unsafe extern "C" fn(var) -> ()),
        sseek: Some(File_Seek as unsafe extern "C" fn(var, int64_t, libc::c_int) -> ()),
        stell: Some(File_Tell as unsafe extern "C" fn(var) -> int64_t),
        sflush: Some(File_Flush as unsafe extern "C" fn(var) -> ()),
        seof: Some(File_EOF as unsafe extern "C" fn(var) -> bool),
        sread: Some(
            File_Read as unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t,
        ),
        swrite: Some(
            File_Write as unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t,
        ),
    };
    init
};
static mut __constr_expr_1246: Format = {
    let mut init = Format {
        format_to: Some(
            File_Format_To
                as unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
        ),
        format_from: Some(
            File_Format_From
                as unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_1241: [var; 45] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"File\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<File>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1242 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1243 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1244 as *const Start as *mut Start as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Stream\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1245 as *const Stream as *mut Stream as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Format\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1246 as *const Format as *mut Format as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut File: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn Process_Name() -> *const libc::c_char {
    return b"Process\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Process_Brief() -> *const libc::c_char {
    return b"Operating System Process\0" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Process_Description() -> *const libc::c_char {
    return b"The `Process` type is a wrapper for an operating system process as constructed by the unix-like call `popen`. In this sense it is much like a standard file in the operating system but that instead of writing data to a location you are writing it as input to a process.\0"
        as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn Process_Definition() -> *const libc::c_char {
    return b"struct Process {\n  FILE* proc;\n};\n\0" as *const u8
        as *const libc::c_char;
}
static mut examples___50: [Example; 2] = [
    {
        let mut init = Example {
            name: b"Usage\0" as *const u8 as *const libc::c_char,
            body: b"var x = new(Process, $S(\"ls\"), $S(\"r\"));\nchar c;\nwhile (not seof(x)) {\n  sread(x, &c, 1);\n  print(\"%c\", $I(c));\n}\nsclose(x);\n\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = Example {
            name: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
            body: 0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn Process_Examples() -> *mut Example {
    return examples___50.as_mut_ptr();
}
unsafe extern "C" fn Process_New(mut self_0: var, mut args: var) {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1247: Int = Int { val: 0 };
    let mut __constr_expr_1248: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut __constr_expr_1249: Int = Int { val: 0 };
    let mut __constr_expr_1250: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___6: var = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    (*p).proc_0 = 0 as *mut libc::c_void as *mut FILE;
    __constr_expr_1247.val = 1 as libc::c_int as int64_t;
    __constr_expr_1248[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp = 1 as libc::c_uint;
    while !(tmp >= 32 as libc::c_uint) {
        __constr_expr_1248[tmp as usize] = 0 as libc::c_int as libc::c_char;
        tmp = tmp.wrapping_add(1);
    }
    tmp___0 = header_init(__constr_expr_1248.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___1 = memcpy(
        tmp___0 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_1247 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___2 = get(args, tmp___1 as *mut Int as var);
    __constr_expr_1249.val = 0 as libc::c_int as int64_t;
    __constr_expr_1250[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    tmp___3 = 1 as libc::c_uint;
    while !(tmp___3 >= 32 as libc::c_uint) {
        __constr_expr_1250[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = tmp___3.wrapping_add(1);
    }
    tmp___4 = header_init(__constr_expr_1250.as_mut_ptr() as var, Int, 2 as libc::c_int);
    tmp___5 = memcpy(
        tmp___4 as *mut Int as *mut libc::c_void,
        &mut __constr_expr_1249 as *mut Int as *const libc::c_void,
        ::std::mem::size_of::<Int>() as libc::c_ulong,
    );
    tmp___6 = get(args, tmp___5 as *mut Int as var);
    Process_Open(self_0, tmp___6, tmp___2);
}
unsafe extern "C" fn Process_Del(mut self_0: var) {
    let mut p: *mut Process = 0 as *mut Process;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        Process_Close(self_0);
    }
}
unsafe extern "C" fn Process_Open(
    mut self_0: var,
    mut filename: var,
    mut access: var,
) -> var {
    let mut p: *mut Process = 0 as *mut Process;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut __constr_expr_1251: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1252: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1253: [libc::c_char; 32] = [0; 32];
    let mut tmp___1: libc::c_uint = 0;
    let mut tmp___2: var = 0 as *mut libc::c_void;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        Process_Close(self_0);
    }
    tmp = c_str(access);
    tmp___0 = c_str(filename);
    (*p).proc_0 = popen(tmp___0 as *const libc::c_char, tmp as *const libc::c_char);
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1252[0 as libc::c_int as usize] = filename;
        __constr_expr_1252[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1251.items = __constr_expr_1252.as_mut_ptr();
        __constr_expr_1253[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___1 = 1 as libc::c_uint;
        while !(tmp___1 >= 32 as libc::c_uint) {
            __constr_expr_1253[tmp___1 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___1 = tmp___1.wrapping_add(1);
        }
        tmp___2 = header_init(
            __constr_expr_1253.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___3 = memcpy(
            tmp___2 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1251 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Could not open process: %s\0" as *const u8 as *const libc::c_char,
            tmp___3 as *mut Tuple as var,
        );
    }
    return self_0;
}
unsafe extern "C" fn Process_Close(mut self_0: var) {
    let mut p: *mut Process = 0 as *mut Process;
    let mut err: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut __constr_expr_1254: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1255: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1256: Int = Int { val: 0 };
    let mut __constr_expr_1257: [libc::c_char; 32] = [0; 32];
    let mut tmp___0: libc::c_uint = 0;
    let mut tmp___1: var = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1258: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    tmp = pclose((*p).proc_0);
    err = tmp;
    if err != 0 as libc::c_int {
        __constr_expr_1256.val = err as int64_t;
        __constr_expr_1257[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___0 = 1 as libc::c_uint;
        while !(tmp___0 >= 32 as libc::c_uint) {
            __constr_expr_1257[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___0 = tmp___0.wrapping_add(1);
        }
        tmp___1 = header_init(
            __constr_expr_1257.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___2 = memcpy(
            tmp___1 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1256 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1255[0 as libc::c_int as usize] = tmp___2 as *mut Int as var;
        __constr_expr_1255[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1254.items = __constr_expr_1255.as_mut_ptr();
        __constr_expr_1258[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1258[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1258.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1254 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to close process: %i\0" as *const u8 as *const libc::c_char,
            tmp___5 as *mut Tuple as var,
        );
    }
    (*p).proc_0 = 0 as *mut libc::c_void as *mut FILE;
}
unsafe extern "C" fn Process_Seek(
    mut self_0: var,
    mut pos: int64_t,
    mut origin: libc::c_int,
) {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1259: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1260: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1261: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut err: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut __constr_expr_1262: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1263: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1264: Int = Int { val: 0 };
    let mut __constr_expr_1265: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1266: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1260[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1259.items = __constr_expr_1260.as_mut_ptr();
        __constr_expr_1261[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1261[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1261.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1259 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot seek process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fseek((*p).proc_0, pos, origin);
    err = tmp___2;
    if err != 0 as libc::c_int {
        __constr_expr_1264.val = err as int64_t;
        __constr_expr_1265[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1265[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1265.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1264 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1263[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
        __constr_expr_1263[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1262.items = __constr_expr_1263.as_mut_ptr();
        __constr_expr_1266[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1266[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1266.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1262 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to seek in process: %i\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn Process_Tell(mut self_0: var) -> int64_t {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1267: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1268: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1269: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: int64_t = 0;
    let mut tmp___2: libc::c_long = 0;
    let mut __constr_expr_1270: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1271: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1272: Int = Int { val: 0 };
    let mut __constr_expr_1273: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1274: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1268[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1267.items = __constr_expr_1268.as_mut_ptr();
        __constr_expr_1269[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1269[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1269.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1267 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot tell process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = ftell((*p).proc_0);
    i = tmp___2;
    if i == -(1 as libc::c_long) {
        __constr_expr_1272.val = i;
        __constr_expr_1273[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1273[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1273.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1272 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1271[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
        __constr_expr_1271[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1270.items = __constr_expr_1271.as_mut_ptr();
        __constr_expr_1274[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1274[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1274.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1270 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to tell process: %i\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
    return i;
}
unsafe extern "C" fn Process_Flush(mut self_0: var) {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1275: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1276: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1277: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut err: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut __constr_expr_1278: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1279: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1280: Int = Int { val: 0 };
    let mut __constr_expr_1281: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1282: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1276[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1275.items = __constr_expr_1276.as_mut_ptr();
        __constr_expr_1277[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1277[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1277.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1275 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot flush process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fflush((*p).proc_0);
    err = tmp___2;
    if err != 0 as libc::c_int {
        __constr_expr_1280.val = err as int64_t;
        __constr_expr_1281[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___3 = 1 as libc::c_uint;
        while !(tmp___3 >= 32 as libc::c_uint) {
            __constr_expr_1281[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = tmp___3.wrapping_add(1);
        }
        tmp___4 = header_init(
            __constr_expr_1281.as_mut_ptr() as var,
            Int,
            2 as libc::c_int,
        );
        tmp___5 = memcpy(
            tmp___4 as *mut Int as *mut libc::c_void,
            &mut __constr_expr_1280 as *mut Int as *const libc::c_void,
            ::std::mem::size_of::<Int>() as libc::c_ulong,
        );
        __constr_expr_1279[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
        __constr_expr_1279[1 as libc::c_int as usize] = Terminal;
        __constr_expr_1278.items = __constr_expr_1279.as_mut_ptr();
        __constr_expr_1282[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp___6 = 1 as libc::c_uint;
        while !(tmp___6 >= 32 as libc::c_uint) {
            __constr_expr_1282[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = tmp___6.wrapping_add(1);
        }
        tmp___7 = header_init(
            __constr_expr_1282.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___8 = memcpy(
            tmp___7 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1278 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Failed to flush process: %i\0" as *const u8 as *const libc::c_char,
            tmp___8 as *mut Tuple as var,
        );
    }
}
unsafe extern "C" fn Process_EOF(mut self_0: var) -> bool {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1283: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1284: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1285: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1284[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1283.items = __constr_expr_1284.as_mut_ptr();
        __constr_expr_1285[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1285[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1285.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1283 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot eof process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = feof((*p).proc_0);
    return tmp___2 != 0;
}
unsafe extern "C" fn Process_Read(
    mut self_0: var,
    mut output: *mut libc::c_void,
    mut size___0: size_t,
) -> size_t {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1286: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1287: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1288: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut num: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut __constr_expr_1289: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1290: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1291: Int = Int { val: 0 };
    let mut __constr_expr_1292: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1293: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: libc::c_int = 0;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1287[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1286.items = __constr_expr_1287.as_mut_ptr();
        __constr_expr_1288[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1288[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1288.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1286 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot read process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fread(output, size___0, 1 as libc::c_int as size_t, (*p).proc_0);
    num = tmp___2;
    if num != 1 as libc::c_ulong {
        if size___0 != 0 as libc::c_ulong {
            tmp___9 = feof((*p).proc_0);
            if tmp___9 == 0 {
                __constr_expr_1291.val = num as int64_t;
                __constr_expr_1292[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___3 = 1 as libc::c_uint;
                while !(tmp___3 >= 32 as libc::c_uint) {
                    __constr_expr_1292[tmp___3
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___3 = tmp___3.wrapping_add(1);
                }
                tmp___4 = header_init(
                    __constr_expr_1292.as_mut_ptr() as var,
                    Int,
                    2 as libc::c_int,
                );
                tmp___5 = memcpy(
                    tmp___4 as *mut Int as *mut libc::c_void,
                    &mut __constr_expr_1291 as *mut Int as *const libc::c_void,
                    ::std::mem::size_of::<Int>() as libc::c_ulong,
                );
                __constr_expr_1290[0 as libc::c_int
                    as usize] = tmp___5 as *mut Int as var;
                __constr_expr_1290[1 as libc::c_int as usize] = Terminal;
                __constr_expr_1289.items = __constr_expr_1290.as_mut_ptr();
                __constr_expr_1293[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = 1 as libc::c_uint;
                while !(tmp___6 >= 32 as libc::c_uint) {
                    __constr_expr_1293[tmp___6
                        as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___6 = tmp___6.wrapping_add(1);
                }
                tmp___7 = header_init(
                    __constr_expr_1293.as_mut_ptr() as var,
                    Tuple,
                    2 as libc::c_int,
                );
                tmp___8 = memcpy(
                    tmp___7 as *mut Tuple as *mut libc::c_void,
                    &mut __constr_expr_1289 as *mut Tuple as *const libc::c_void,
                    ::std::mem::size_of::<Tuple>() as libc::c_ulong,
                );
                exception_throw(
                    IOError,
                    b"Failed to read from process: %i\0" as *const u8
                        as *const libc::c_char,
                    tmp___8 as *mut Tuple as var,
                );
                return num;
            }
        }
    }
    return num;
}
unsafe extern "C" fn Process_Write(
    mut self_0: var,
    mut input: *mut libc::c_void,
    mut size___0: size_t,
) -> size_t {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1294: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1295: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1296: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut num: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut __constr_expr_1297: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1298: [var; 2] = [0 as *mut libc::c_void; 2];
    let mut __constr_expr_1299: Int = Int { val: 0 };
    let mut __constr_expr_1300: [libc::c_char; 32] = [0; 32];
    let mut tmp___3: libc::c_uint = 0;
    let mut tmp___4: var = 0 as *mut libc::c_void;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut __constr_expr_1301: [libc::c_char; 32] = [0; 32];
    let mut tmp___6: libc::c_uint = 0;
    let mut tmp___7: var = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1295[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1294.items = __constr_expr_1295.as_mut_ptr();
        __constr_expr_1296[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1296[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1296.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1294 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot write process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = fwrite(
        input as *const libc::c_void,
        size___0,
        1 as libc::c_int as size_t,
        (*p).proc_0,
    );
    num = tmp___2;
    if num != 1 as libc::c_ulong {
        if size___0 != 0 as libc::c_ulong {
            __constr_expr_1299.val = num as int64_t;
            __constr_expr_1300[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___3 = 1 as libc::c_uint;
            while !(tmp___3 >= 32 as libc::c_uint) {
                __constr_expr_1300[tmp___3 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___3 = tmp___3.wrapping_add(1);
            }
            tmp___4 = header_init(
                __constr_expr_1300.as_mut_ptr() as var,
                Int,
                2 as libc::c_int,
            );
            tmp___5 = memcpy(
                tmp___4 as *mut Int as *mut libc::c_void,
                &mut __constr_expr_1299 as *mut Int as *const libc::c_void,
                ::std::mem::size_of::<Int>() as libc::c_ulong,
            );
            __constr_expr_1298[0 as libc::c_int as usize] = tmp___5 as *mut Int as var;
            __constr_expr_1298[1 as libc::c_int as usize] = Terminal;
            __constr_expr_1297.items = __constr_expr_1298.as_mut_ptr();
            __constr_expr_1301[0 as libc::c_int
                as usize] = 0 as libc::c_int as libc::c_char;
            tmp___6 = 1 as libc::c_uint;
            while !(tmp___6 >= 32 as libc::c_uint) {
                __constr_expr_1301[tmp___6 as usize] = 0 as libc::c_int as libc::c_char;
                tmp___6 = tmp___6.wrapping_add(1);
            }
            tmp___7 = header_init(
                __constr_expr_1301.as_mut_ptr() as var,
                Tuple,
                2 as libc::c_int,
            );
            tmp___8 = memcpy(
                tmp___7 as *mut Tuple as *mut libc::c_void,
                &mut __constr_expr_1297 as *mut Tuple as *const libc::c_void,
                ::std::mem::size_of::<Tuple>() as libc::c_ulong,
            );
            exception_throw(
                IOError,
                b"Failed to write to process: %i\0" as *const u8 as *const libc::c_char,
                tmp___8 as *mut Tuple as var,
            );
        }
    }
    return num;
}
unsafe extern "C" fn Process_Format_To(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1302: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1303: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1304: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1303[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1302.items = __constr_expr_1303.as_mut_ptr();
        __constr_expr_1304[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1304[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1304.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1302 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot format to process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = vfprintf((*p).proc_0, fmt, va.as_va_list());
    return tmp___2;
}
unsafe extern "C" fn Process_Format_From(
    mut self_0: var,
    mut pos: libc::c_int,
    mut fmt: *const libc::c_char,
    mut va: ::std::ffi::VaList,
) -> libc::c_int {
    let mut p: *mut Process = 0 as *mut Process;
    let mut __constr_expr_1305: Tuple = Tuple { items: 0 as *mut var };
    let mut __constr_expr_1306: [var; 1] = [0 as *mut libc::c_void; 1];
    let mut __constr_expr_1307: [libc::c_char; 32] = [0; 32];
    let mut tmp: libc::c_uint = 0;
    let mut tmp___0: var = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    p = self_0 as *mut Process;
    if (*p).proc_0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        __constr_expr_1306[0 as libc::c_int as usize] = Terminal;
        __constr_expr_1305.items = __constr_expr_1306.as_mut_ptr();
        __constr_expr_1307[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        tmp = 1 as libc::c_uint;
        while !(tmp >= 32 as libc::c_uint) {
            __constr_expr_1307[tmp as usize] = 0 as libc::c_int as libc::c_char;
            tmp = tmp.wrapping_add(1);
        }
        tmp___0 = header_init(
            __constr_expr_1307.as_mut_ptr() as var,
            Tuple,
            2 as libc::c_int,
        );
        tmp___1 = memcpy(
            tmp___0 as *mut Tuple as *mut libc::c_void,
            &mut __constr_expr_1305 as *mut Tuple as *const libc::c_void,
            ::std::mem::size_of::<Tuple>() as libc::c_ulong,
        );
        exception_throw(
            IOError,
            b"Cannot format from process - no process open.\0" as *const u8
                as *const libc::c_char,
            tmp___1 as *mut Tuple as var,
        );
    }
    tmp___2 = vfscanf((*p).proc_0, fmt, va.as_va_list());
    return tmp___2;
}
static mut __constr_expr_1309: Doc = unsafe {
    {
        let mut init = Doc {
            name: Some(Process_Name as unsafe extern "C" fn() -> *const libc::c_char),
            brief: Some(Process_Brief as unsafe extern "C" fn() -> *const libc::c_char),
            description: Some(
                Process_Description as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            definition: Some(
                Process_Definition as unsafe extern "C" fn() -> *const libc::c_char,
            ),
            examples: Some(Process_Examples as unsafe extern "C" fn() -> *mut Example),
            methods: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn() -> *mut Method>,
            >(0 as *const libc::c_void as *mut libc::c_void),
        };
        init
    }
};
static mut __constr_expr_1310: New = {
    let mut init = New {
        construct_with: Some(Process_New as unsafe extern "C" fn(var, var) -> ()),
        destruct: Some(Process_Del as unsafe extern "C" fn(var) -> ()),
    };
    init
};
static mut __constr_expr_1311: Start = unsafe {
    {
        let mut init = Start {
            start: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            stop: Some(Process_Close as unsafe extern "C" fn(var) -> ()),
            join: ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(var) -> ()>,
            >(0 as *const libc::c_void as *mut libc::c_void),
            running: None,
        };
        init
    }
};
static mut __constr_expr_1312: Stream = {
    let mut init = Stream {
        sopen: Some(Process_Open as unsafe extern "C" fn(var, var, var) -> var),
        sclose: Some(Process_Close as unsafe extern "C" fn(var) -> ()),
        sseek: Some(
            Process_Seek as unsafe extern "C" fn(var, int64_t, libc::c_int) -> (),
        ),
        stell: Some(Process_Tell as unsafe extern "C" fn(var) -> int64_t),
        sflush: Some(Process_Flush as unsafe extern "C" fn(var) -> ()),
        seof: Some(Process_EOF as unsafe extern "C" fn(var) -> bool),
        sread: Some(
            Process_Read
                as unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t,
        ),
        swrite: Some(
            Process_Write
                as unsafe extern "C" fn(var, *mut libc::c_void, size_t) -> size_t,
        ),
    };
    init
};
static mut __constr_expr_1313: Format = {
    let mut init = Format {
        format_to: Some(
            Process_Format_To
                as unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
        ),
        format_from: Some(
            Process_Format_From
                as unsafe extern "C" fn(
                    var,
                    libc::c_int,
                    *const libc::c_char,
                    ::std::ffi::VaList,
                ) -> libc::c_int,
        ),
    };
    init
};
static mut __constr_expr_1308: [var; 45] = unsafe {
    [
        0 as *const libc::c_void as *mut libc::c_void,
        1 as libc::c_int as var,
        844048 as libc::c_int as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Name\0" as *const u8 as *const libc::c_char as var,
        b"Process\0" as *const u8 as *const libc::c_char as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"__Size\0" as *const u8 as *const libc::c_char as var,
        ::std::mem::size_of::<Process>() as libc::c_ulong as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Doc\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1309 as *const Doc as *mut Doc as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"New\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1310 as *const New as *mut New as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Start\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1311 as *const Start as *mut Start as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Stream\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1312 as *const Stream as *mut Stream as var,
        0 as *const libc::c_void as *mut libc::c_void,
        b"Format\0" as *const u8 as *const libc::c_char as var,
        &__constr_expr_1313 as *const Format as *mut Format as var,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
        0 as *const libc::c_void as *mut libc::c_void,
    ]
};
pub static mut Process: var = 0 as *const libc::c_void as *mut libc::c_void;
unsafe extern "C" fn run_static_initializers() {
    Table = (__constr_expr_49.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Resize = (__constr_expr_61.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    _ = (__constr_expr_63.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Terminal = (__constr_expr_64.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Iter = (__constr_expr_65.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Range = (__constr_expr_118.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Slice = (__constr_expr_162.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Zip = (__constr_expr_181.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Filter = (__constr_expr_196.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Map = (__constr_expr_205.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Assign = (__constr_expr_212.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Swap = (__constr_expr_217.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Hash = (__constr_expr_222.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Push = (__constr_expr_224.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Len = (__constr_expr_226.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    TypeError = (__constr_expr_228.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    ValueError = (__constr_expr_229.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    ClassError = (__constr_expr_230.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    IndexOutOfBoundsError = (__constr_expr_231.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    KeyError = (__constr_expr_232.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    OutOfMemoryError = (__constr_expr_233.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    IOError = (__constr_expr_234.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    FormatError = (__constr_expr_235.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    BusyError = (__constr_expr_236.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    ResourceError = (__constr_expr_237.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    ProgramAbortedError = (__constr_expr_238.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    DivisionByZeroError = (__constr_expr_239.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    IllegalInstructionError = (__constr_expr_240.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    ProgramInterruptedError = (__constr_expr_241.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    SegmentationError = (__constr_expr_242.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    ProgramTerminationError = (__constr_expr_243.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Exception = (__constr_expr_304.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Doc = (__constr_expr_312.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Help = (__constr_expr_314.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    C_Str = (__constr_expr_318.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    String = (__constr_expr_443.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Cast = (__constr_expr_456.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Type = (__constr_expr_551.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Size = (__constr_expr_582.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    List = (__constr_expr_618.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Tuple = (__constr_expr_719.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Pointer = (__constr_expr_734.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Ref = (__constr_expr_736.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Box = (__constr_expr_745.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Tree = (__constr_expr_788.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Cmp = (__constr_expr_800.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Sort = (__constr_expr_805.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Format = (__constr_expr_807.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Show = (__constr_expr_809.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Call = (__constr_expr_907.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Function = (__constr_expr_909.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Alloc = (__constr_expr_912.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    New = (__constr_expr_933.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Copy = (__constr_expr_937.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Concat = (__constr_expr_939.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    C_Int = (__constr_expr_941.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    C_Float = (__constr_expr_943.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Int = (__constr_expr_951.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Float = (__constr_expr_964.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Start = (__constr_expr_971.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Current = (__constr_expr_973.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Thread = (__constr_expr_1023.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Lock = (__constr_expr_1035.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Mutex = (__constr_expr_1052.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Mark = (__constr_expr_1057.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    GC = (__constr_expr_1094.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Array = (__constr_expr_1161.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Get = (__constr_expr_1176.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Stream = (__constr_expr_1178.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    File = (__constr_expr_1241.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
    Process = (__constr_expr_1308.as_mut_ptr() as *mut libc::c_char)
        .offset(::std::mem::size_of::<Header>() as libc::c_ulong as isize) as var;
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
