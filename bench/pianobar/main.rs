use ::libc;
use ::c2rust_bitfields;
use ::c2rust_asm_casts;
use c2rust_asm_casts::AsmCastTrait;
use std::arch::asm;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type gcry_cipher_handle;
    pub type ao_device;
    pub type AVBuffer;
    pub type AVDictionary;
    pub type AVCodecInternal;
    pub type AVCodecHWConfigInternal;
    pub type MpegEncContext;
    pub type AVCodecDefault;
    pub type AVFormatInternal;
    pub type AVStreamInternal;
    pub type AVDeviceCapabilitiesQuery;
    pub type AVDeviceInfoList;
    pub type AVCodecTag;
    pub type AVFilterCommand;
    pub type AVFilterInternal;
    pub type AVFilterChannelLayouts;
    pub type AVFilterFormats;
    pub type AVFilterPad;
    pub type AVFilterGraphInternal;
    pub type json_object;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn exit(_: libc::c_int) -> !;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn puts(__s: *const libc::c_char) -> libc::c_int;
    fn fileno(__stream: *mut FILE) -> libc::c_int;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;
    fn execl(
        __path: *const libc::c_char,
        __arg: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn fork() -> __pid_t;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn __fxstat(
        __ver: libc::c_int,
        __fildes: libc::c_int,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option::<
            unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn signal(
        __sig: libc::c_int,
        __handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    ) -> __sighandler_t;
    fn sigemptyset(__set: *mut sigset_t) -> libc::c_int;
    fn sigaction(
        __sig: libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> libc::c_int;
    fn waitpid(
        __pid: __pid_t,
        __stat_loc: *mut libc::c_int,
        __options: libc::c_int,
    ) -> __pid_t;
    fn gcry_check_version(req_version: *const libc::c_char) -> *const libc::c_char;
    fn gcry_control(CMD: gcry_ctl_cmds, _: ...) -> gcry_error_t;
    fn curl_global_init(flags: libc::c_long) -> CURLcode;
    fn curl_global_cleanup();
    fn curl_easy_init() -> *mut libc::c_void;
    fn curl_easy_cleanup(curl: *mut libc::c_void);
    fn __errno_location() -> *mut libc::c_int;
    fn av_strerror(
        errnum: libc::c_int,
        errbuf: *mut libc::c_char,
        errbuf_size: size_t,
    ) -> libc::c_int;
    fn av_log_set_level(level: libc::c_int);
    fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const libc::c_char;
    fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> libc::c_int;
    fn av_get_channel_layout_nb_channels(channel_layout: uint64_t) -> libc::c_int;
    fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
    fn av_frame_alloc() -> *mut AVFrame;
    fn av_frame_free(frame: *mut *mut AVFrame);
    fn av_frame_unref(frame: *mut AVFrame);
    fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
    fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> libc::c_int;
    fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
    fn avcodec_close(avctx: *mut AVCodecContext) -> libc::c_int;
    fn av_packet_alloc() -> *mut AVPacket;
    fn av_packet_free(pkt: *mut *mut AVPacket);
    fn av_packet_unref(pkt: *mut AVPacket);
    fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
    fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> libc::c_int;
    fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> libc::c_int;
    fn avfilter_link(
        src: *mut AVFilterContext,
        srcpad: libc::c_uint,
        dst: *mut AVFilterContext,
        dstpad: libc::c_uint,
    ) -> libc::c_int;
    fn avfilter_get_by_name(name: *const libc::c_char) -> *const AVFilter;
    fn avfilter_graph_alloc() -> *mut AVFilterGraph;
    fn avfilter_graph_create_filter(
        filt_ctx: *mut *mut AVFilterContext,
        filt: *const AVFilter,
        name: *const libc::c_char,
        args: *const libc::c_char,
        opaque: *mut libc::c_void,
        graph_ctx: *mut AVFilterGraph,
    ) -> libc::c_int;
    fn avfilter_graph_config(
        graphctx: *mut AVFilterGraph,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
    fn avfilter_graph_free(graph: *mut *mut AVFilterGraph);
    fn avfilter_graph_send_command(
        graph: *mut AVFilterGraph,
        target: *const libc::c_char,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        res: *mut libc::c_char,
        res_len: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
    fn av_buffersink_get_time_base(ctx: *const AVFilterContext) -> AVRational;
    fn av_buffersink_get_frame(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
    ) -> libc::c_int;
    fn av_buffersrc_write_frame(
        ctx: *mut AVFilterContext,
        frame: *const AVFrame,
    ) -> libc::c_int;
    fn av_buffersrc_add_frame(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
    ) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
    fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> libc::c_int;
    fn ao_initialize();
    fn ao_shutdown();
    fn ao_open_live(
        driver_id: libc::c_int,
        format: *mut ao_sample_format,
        option: *mut ao_option,
    ) -> *mut ao_device;
    fn ao_open_file(
        driver_id: libc::c_int,
        filename: *const libc::c_char,
        overwrite: libc::c_int,
        format: *mut ao_sample_format,
        option: *mut ao_option,
    ) -> *mut ao_device;
    fn ao_play(
        device: *mut ao_device,
        output_samples: *mut libc::c_char,
        num_bytes: uint_32,
    ) -> libc::c_int;
    fn ao_close(device: *mut ao_device) -> libc::c_int;
    fn ao_driver_id(short_name: *const libc::c_char) -> libc::c_int;
    fn ao_default_driver_id() -> libc::c_int;
    fn avformat_alloc_context() -> *mut AVFormatContext;
    fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const libc::c_char,
        fmt: *mut AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
    fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
    fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_0: AVMediaType,
        wanted_stream_nb: libc::c_int,
        related_stream: libc::c_int,
        decoder_ret: *mut *mut AVCodec,
        flags: libc::c_int,
    ) -> libc::c_int;
    fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
    fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        timestamp: int64_t,
        flags: libc::c_int,
    ) -> libc::c_int;
    fn avformat_close_input(s: *mut *mut AVFormatContext);
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn feof(__stream: *mut FILE) -> libc::c_int;
    fn getpwuid(__uid: __uid_t) -> *mut passwd;
    fn getuid() -> __uid_t;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn tcgetattr(__fd: libc::c_int, __termios_p: *mut termios) -> libc::c_int;
    fn tcsetattr(
        __fd: libc::c_int,
        __optional_actions: libc::c_int,
        __termios_p: *const termios,
    ) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: Option::<
            unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
        >,
    );
    fn strcasecmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn curl_slist_append(_: *mut curl_slist, _: *const libc::c_char) -> *mut curl_slist;
    fn curl_slist_free_all(_: *mut curl_slist);
    fn curl_easy_strerror(_: CURLcode) -> *const libc::c_char;
    fn curl_easy_setopt(curl: *mut libc::c_void, option: CURLoption, _: ...) -> CURLcode;
    fn curl_easy_perform(curl: *mut libc::c_void) -> CURLcode;
    fn curl_easy_reset(curl: *mut libc::c_void);
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn gcry_cipher_encrypt(
        h: gcry_cipher_hd_t,
        out: *mut libc::c_void,
        outsize: size_t,
        in_0: *const libc::c_void,
        inlen: size_t,
    ) -> gcry_error_t;
    fn gcry_cipher_decrypt(
        h: gcry_cipher_hd_t,
        out: *mut libc::c_void,
        outsize: size_t,
        in_0: *const libc::c_void,
        inlen: size_t,
    ) -> gcry_error_t;
    fn gcry_cipher_open(
        handle: *mut gcry_cipher_hd_t,
        algo: libc::c_int,
        mode: libc::c_int,
        flags: libc::c_uint,
    ) -> gcry_error_t;
    fn gcry_cipher_close(h: gcry_cipher_hd_t);
    fn gcry_cipher_setkey(
        hd: gcry_cipher_hd_t,
        key: *const libc::c_void,
        keylen: size_t,
    ) -> gcry_error_t;
    fn time(__timer: *mut time_t) -> time_t;
    fn curl_easy_escape(
        handle: *mut libc::c_void,
        string: *const libc::c_char,
        length: libc::c_int,
    ) -> *mut libc::c_char;
    fn curl_free(p: *mut libc::c_void);
    fn json_object_put(obj: *mut json_object) -> libc::c_int;
    fn json_object_to_json_string(obj: *mut json_object) -> *const libc::c_char;
    fn json_object_new_object() -> *mut json_object;
    fn json_object_object_add(
        obj: *mut json_object,
        key: *const libc::c_char,
        val: *mut json_object,
    ) -> libc::c_int;
    fn json_object_new_array() -> *mut json_object;
    fn json_object_array_add(
        obj: *mut json_object,
        val: *mut json_object,
    ) -> libc::c_int;
    fn json_object_new_boolean(b: json_bool) -> *mut json_object;
    fn json_object_new_int(i: int32_t) -> *mut json_object;
    fn json_object_new_string(s: *const libc::c_char) -> *mut json_object;
    fn json_object_object_get_ex(
        obj: *const json_object,
        key: *const libc::c_char,
        value: *mut *mut json_object,
    ) -> json_bool;
    fn json_object_array_length(obj: *const json_object) -> size_t;
    fn json_object_array_get_idx(
        obj: *const json_object,
        idx: size_t,
    ) -> *mut json_object;
    fn json_object_get_boolean(obj: *const json_object) -> json_bool;
    fn json_object_get_int(obj: *const json_object) -> int32_t;
    fn json_object_get_double(obj: *const json_object) -> libc::c_double;
    fn json_object_get_string(obj: *mut json_object) -> *const libc::c_char;
    fn json_tokener_parse(str: *const libc::c_char) -> *mut json_object;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __gnuc_va_list = __builtin_va_list;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __clock_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __sig_atomic_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type ssize_t = __ssize_t;
pub type pid_t = __pid_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___sigset_t_991265788 {
    pub __val: [libc::c_ulong; 16],
}
pub type __sigset_t = __anonstruct___sigset_t_991265788;
pub type sigset_t = __sigset_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_fd_set_356711149 {
    pub __fds_bits: [__fd_mask; 16],
}
pub type fd_set = __anonstruct_fd_set_356711149;
pub type int8_t = __int8_t;
pub type int64_t = __int64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___wseq32_112954846 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_606137648 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __anonstruct___wseq32_112954846,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct___g1_start32_327815073 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion____missing_field_name_327815072 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __anonstruct___g1_start32_327815073,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __annonCompField1: __anonunion____missing_field_name_606137648,
    pub __annonCompField2: __anonunion____missing_field_name_327815072,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_cond_t_951761805 {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type pthread_cond_t = __anonunion_pthread_cond_t_951761805;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type sig_atomic_t = __sig_atomic_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
}
pub type __sigval_t = sigval;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__kill_244518854 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__timer_490064738 {
    pub si_tid: libc::c_int,
    pub si_overrun: libc::c_int,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__rt_619254530 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigchld_284671705 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__addr_bnd_5259977 {
    pub _lower: *mut libc::c_void,
    pub _upper: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion__bounds_663225253 {
    pub _addr_bnd: __anonstruct__addr_bnd_5259977,
    pub _pkey: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigfault_848714866 {
    pub si_addr: *mut libc::c_void,
    pub si_addr_lsb: libc::c_short,
    pub _bounds: __anonunion__bounds_663225253,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigpoll_386613454 {
    pub si_band: libc::c_long,
    pub si_fd: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct__sigsys_44812255 {
    pub _call_addr: *mut libc::c_void,
    pub _syscall: libc::c_int,
    pub _arch: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion__sifields_1071224287 {
    pub _pad: [libc::c_int; 28],
    pub _kill: __anonstruct__kill_244518854,
    pub _timer: __anonstruct__timer_490064738,
    pub _rt: __anonstruct__rt_619254530,
    pub _sigchld: __anonstruct__sigchld_284671705,
    pub _sigfault: __anonstruct__sigfault_848714866,
    pub _sigpoll: __anonstruct__sigpoll_386613454,
    pub _sigsys: __anonstruct__sigsys_44812255,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_siginfo_t_257952342 {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub __pad0: libc::c_int,
    pub _sifields: __anonunion__sifields_1071224287,
}
pub type siginfo_t = __anonstruct_siginfo_t_257952342;
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion___sigaction_handler_363639592 {
    pub sa_handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    pub sa_sigaction: Option::<
        unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigaction {
    pub __sigaction_handler: __anonunion___sigaction_handler_363639592,
    pub sa_mask: __sigset_t,
    pub sa_flags: libc::c_int,
    pub sa_restorer: Option::<unsafe extern "C" fn() -> ()>,
}
pub type gpg_error_t = libc::c_uint;
pub type gcry_error_t = gpg_error_t;
pub type gcry_ctl_cmds = libc::c_uint;
pub const GCRYCTL_REINIT_SYSCALL_CLAMP: gcry_ctl_cmds = 77;
pub const GCRYCTL_GET_TAGLEN: gcry_ctl_cmds = 76;
pub const GCRYCTL_SET_TAGLEN: gcry_ctl_cmds = 75;
pub const GCRYCTL_DRBG_REINIT: gcry_ctl_cmds = 74;
pub const GCRYCTL_SET_SBOX: gcry_ctl_cmds = 73;
pub const GCRYCTL_REACTIVATE_FIPS_FLAG: gcry_ctl_cmds = 72;
pub const GCRYCTL_INACTIVATE_FIPS_FLAG: gcry_ctl_cmds = 71;
pub const GCRYCTL_CLOSE_RANDOM_DEVICE: gcry_ctl_cmds = 70;
pub const GCRYCTL_SET_CCM_LENGTHS: gcry_ctl_cmds = 69;
pub const GCRYCTL_DISABLE_PRIV_DROP: gcry_ctl_cmds = 68;
pub const GCRYCTL_DISABLE_LOCKED_SECMEM: gcry_ctl_cmds = 67;
pub const GCRYCTL_GET_CURRENT_RNG_TYPE: gcry_ctl_cmds = 66;
pub const GCRYCTL_SET_PREFERRED_RNG_TYPE: gcry_ctl_cmds = 65;
pub const GCRYCTL_SET_ENFORCED_FIPS_FLAG: gcry_ctl_cmds = 64;
pub const GCRYCTL_DISABLE_HWF: gcry_ctl_cmds = 63;
pub const GCRYCTL_SELFTEST: gcry_ctl_cmds = 57;
pub const GCRYCTL_FORCE_FIPS_MODE: gcry_ctl_cmds = 56;
pub const GCRYCTL_FIPS_MODE_P: gcry_ctl_cmds = 55;
pub const GCRYCTL_OPERATIONAL_P: gcry_ctl_cmds = 54;
pub const GCRYCTL_PRINT_CONFIG: gcry_ctl_cmds = 53;
pub const GCRYCTL_SET_RNDEGD_SOCKET: gcry_ctl_cmds = 52;
pub const GCRYCTL_FAKED_RANDOM_P: gcry_ctl_cmds = 51;
pub const GCRYCTL_USE_RANDOM_DAEMON: gcry_ctl_cmds = 50;
pub const GCRYCTL_SET_RANDOM_DAEMON_SOCKET: gcry_ctl_cmds = 49;
pub const GCRYCTL_FAST_POLL: gcry_ctl_cmds = 48;
pub const GCRYCTL_SET_THREAD_CBS: gcry_ctl_cmds = 47;
pub const GCRYCTL_UPDATE_RANDOM_SEED_FILE: gcry_ctl_cmds = 46;
pub const GCRYCTL_SET_RANDOM_SEED_FILE: gcry_ctl_cmds = 45;
pub const GCRYCTL_ENABLE_QUICK_RANDOM: gcry_ctl_cmds = 44;
pub const GCRYCTL_SET_CBC_MAC: gcry_ctl_cmds = 42;
pub const GCRYCTL_SET_CBC_CTS: gcry_ctl_cmds = 41;
pub const GCRYCTL_ANY_INITIALIZATION_P: gcry_ctl_cmds = 40;
pub const GCRYCTL_INITIALIZATION_FINISHED_P: gcry_ctl_cmds = 39;
pub const GCRYCTL_INITIALIZATION_FINISHED: gcry_ctl_cmds = 38;
pub const GCRYCTL_DISABLE_SECMEM: gcry_ctl_cmds = 37;
pub const GCRYCTL_DISABLE_INTERNAL_LOCKING: gcry_ctl_cmds = 36;
pub const GCRYCTL_IS_ALGO_ENABLED: gcry_ctl_cmds = 35;
pub const GCRYCTL_GET_ALGO_USAGE: gcry_ctl_cmds = 34;
pub const GCRYCTL_STOP_DUMP: gcry_ctl_cmds = 33;
pub const GCRYCTL_START_DUMP: gcry_ctl_cmds = 32;
pub const GCRYCTL_ENABLE_M_GUARD: gcry_ctl_cmds = 31;
pub const GCRYCTL_DROP_PRIVS: gcry_ctl_cmds = 30;
pub const GCRYCTL_RESUME_SECMEM_WARN: gcry_ctl_cmds = 29;
pub const GCRYCTL_SUSPEND_SECMEM_WARN: gcry_ctl_cmds = 28;
pub const GCRYCTL_DISABLE_SECMEM_WARN: gcry_ctl_cmds = 27;
pub const GCRYCTL_TERM_SECMEM: gcry_ctl_cmds = 25;
pub const GCRYCTL_INIT_SECMEM: gcry_ctl_cmds = 24;
pub const GCRYCTL_DUMP_MEMORY_STATS: gcry_ctl_cmds = 23;
pub const GCRYCTL_USE_SECURE_RNDPOOL: gcry_ctl_cmds = 22;
pub const GCRYCTL_CLEAR_DEBUG_FLAGS: gcry_ctl_cmds = 21;
pub const GCRYCTL_SET_DEBUG_FLAGS: gcry_ctl_cmds = 20;
pub const GCRYCTL_SET_VERBOSITY: gcry_ctl_cmds = 19;
pub const GCRYCTL_GET_ALGO_NENCR: gcry_ctl_cmds = 18;
pub const GCRYCTL_GET_ALGO_NSIGN: gcry_ctl_cmds = 17;
pub const GCRYCTL_GET_ALGO_NSKEY: gcry_ctl_cmds = 16;
pub const GCRYCTL_GET_ALGO_NPKEY: gcry_ctl_cmds = 15;
pub const GCRYCTL_DUMP_SECMEM_STATS: gcry_ctl_cmds = 14;
pub const GCRYCTL_DUMP_RANDOM_STATS: gcry_ctl_cmds = 13;
pub const GCRYCTL_DISABLE_ALGO: gcry_ctl_cmds = 12;
pub const GCRYCTL_ENABLE_ALGO: gcry_ctl_cmds = 11;
pub const GCRYCTL_GET_ASNOID: gcry_ctl_cmds = 10;
pub const GCRYCTL_IS_SECURE: gcry_ctl_cmds = 9;
pub const GCRYCTL_TEST_ALGO: gcry_ctl_cmds = 8;
pub const GCRYCTL_GET_BLKLEN: gcry_ctl_cmds = 7;
pub const GCRYCTL_GET_KEYLEN: gcry_ctl_cmds = 6;
pub const GCRYCTL_FINALIZE: gcry_ctl_cmds = 5;
pub const GCRYCTL_RESET: gcry_ctl_cmds = 4;
pub const GCRYCTL_CFB_SYNC: gcry_ctl_cmds = 3;
pub type gcry_cipher_hd_t = *mut gcry_cipher_handle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoListHead {
    pub next: *mut PianoListHead,
}
pub type PianoListHead_t = PianoListHead;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoUserInfo {
    pub listenerId: *mut libc::c_char,
    pub authToken: *mut libc::c_char,
}
pub type PianoUserInfo_t = PianoUserInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoStation {
    pub head: PianoListHead_t,
    pub isCreator: libc::c_char,
    pub isQuickMix: libc::c_char,
    pub useQuickMix: libc::c_char,
    pub name: *mut libc::c_char,
    pub id: *mut libc::c_char,
    pub seedId: *mut libc::c_char,
}
pub type PianoStation_t = PianoStation;
pub type __anonenum_PianoSongRating_t_787051046 = libc::c_uint;
pub const PIANO_RATE_TIRED: __anonenum_PianoSongRating_t_787051046 = 3;
pub const PIANO_RATE_BAN: __anonenum_PianoSongRating_t_787051046 = 2;
pub const PIANO_RATE_LOVE: __anonenum_PianoSongRating_t_787051046 = 1;
pub const PIANO_RATE_NONE: __anonenum_PianoSongRating_t_787051046 = 0;
pub type PianoSongRating_t = __anonenum_PianoSongRating_t_787051046;
pub type __anonenum_PianoAudioFormat_t_237414795 = libc::c_uint;
pub const PIANO_AF_MP3: __anonenum_PianoAudioFormat_t_237414795 = 2;
pub const PIANO_AF_AACPLUS: __anonenum_PianoAudioFormat_t_237414795 = 1;
pub const PIANO_AF_UNKNOWN: __anonenum_PianoAudioFormat_t_237414795 = 0;
pub type PianoAudioFormat_t = __anonenum_PianoAudioFormat_t_237414795;
pub type __anonenum_PianoAudioQuality_t_590322017 = libc::c_uint;
pub const PIANO_AQ_HIGH: __anonenum_PianoAudioQuality_t_590322017 = 3;
pub const PIANO_AQ_MEDIUM: __anonenum_PianoAudioQuality_t_590322017 = 2;
pub const PIANO_AQ_LOW: __anonenum_PianoAudioQuality_t_590322017 = 1;
pub const PIANO_AQ_UNKNOWN: __anonenum_PianoAudioQuality_t_590322017 = 0;
pub type PianoAudioQuality_t = __anonenum_PianoAudioQuality_t_590322017;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoSong {
    pub head: PianoListHead_t,
    pub artist: *mut libc::c_char,
    pub stationId: *mut libc::c_char,
    pub album: *mut libc::c_char,
    pub audioUrl: *mut libc::c_char,
    pub coverArt: *mut libc::c_char,
    pub musicId: *mut libc::c_char,
    pub title: *mut libc::c_char,
    pub seedId: *mut libc::c_char,
    pub feedbackId: *mut libc::c_char,
    pub detailUrl: *mut libc::c_char,
    pub trackToken: *mut libc::c_char,
    pub fileGain: libc::c_float,
    pub length: libc::c_uint,
    pub rating: PianoSongRating_t,
    pub audioFormat: PianoAudioFormat_t,
}
pub type PianoSong_t = PianoSong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoGenre {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub musicId: *mut libc::c_char,
}
pub type PianoGenre_t = PianoGenre;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoGenreCategory {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub genres: *mut PianoGenre_t,
}
pub type PianoGenreCategory_t = PianoGenreCategory;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoPartner {
    pub in_0: gcry_cipher_hd_t,
    pub out: gcry_cipher_hd_t,
    pub authToken: *mut libc::c_char,
    pub device: *mut libc::c_char,
    pub user: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub id: libc::c_uint,
}
pub type PianoPartner_t = PianoPartner;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoHandle {
    pub user: PianoUserInfo_t,
    pub stations: *mut PianoStation_t,
    pub genreStations: *mut PianoGenreCategory_t,
    pub partner: PianoPartner_t,
    pub timeOffset: libc::c_int,
}
pub type PianoHandle_t = PianoHandle;
pub type __anonenum_PianoRequestType_t_963729421 = libc::c_uint;
pub const PIANO_REQUEST_SET_STATION_MODE: __anonenum_PianoRequestType_t_963729421 = 26;
pub const PIANO_REQUEST_GET_STATION_MODES: __anonenum_PianoRequestType_t_963729421 = 25;
pub const PIANO_REQUEST_CHANGE_SETTINGS: __anonenum_PianoRequestType_t_963729421 = 24;
pub const PIANO_REQUEST_GET_SETTINGS: __anonenum_PianoRequestType_t_963729421 = 23;
pub const PIANO_REQUEST_DELETE_SEED: __anonenum_PianoRequestType_t_963729421 = 22;
pub const PIANO_REQUEST_DELETE_FEEDBACK: __anonenum_PianoRequestType_t_963729421 = 21;
pub const PIANO_REQUEST_GET_STATION_INFO: __anonenum_PianoRequestType_t_963729421 = 20;
pub const PIANO_REQUEST_BOOKMARK_ARTIST: __anonenum_PianoRequestType_t_963729421 = 19;
pub const PIANO_REQUEST_BOOKMARK_SONG: __anonenum_PianoRequestType_t_963729421 = 18;
pub const PIANO_REQUEST_EXPLAIN: __anonenum_PianoRequestType_t_963729421 = 16;
pub const PIANO_REQUEST_TRANSFORM_STATION: __anonenum_PianoRequestType_t_963729421 = 15;
pub const PIANO_REQUEST_GET_GENRE_STATIONS: __anonenum_PianoRequestType_t_963729421 = 14;
pub const PIANO_REQUEST_SET_QUICKMIX: __anonenum_PianoRequestType_t_963729421 = 13;
pub const PIANO_REQUEST_ADD_TIRED_SONG: __anonenum_PianoRequestType_t_963729421 = 12;
pub const PIANO_REQUEST_ADD_SEED: __anonenum_PianoRequestType_t_963729421 = 11;
pub const PIANO_REQUEST_CREATE_STATION: __anonenum_PianoRequestType_t_963729421 = 10;
pub const PIANO_REQUEST_SEARCH: __anonenum_PianoRequestType_t_963729421 = 9;
pub const PIANO_REQUEST_DELETE_STATION: __anonenum_PianoRequestType_t_963729421 = 8;
pub const PIANO_REQUEST_RENAME_STATION: __anonenum_PianoRequestType_t_963729421 = 7;
pub const PIANO_REQUEST_ADD_FEEDBACK: __anonenum_PianoRequestType_t_963729421 = 5;
pub const PIANO_REQUEST_RATE_SONG: __anonenum_PianoRequestType_t_963729421 = 4;
pub const PIANO_REQUEST_GET_PLAYLIST: __anonenum_PianoRequestType_t_963729421 = 3;
pub const PIANO_REQUEST_GET_STATIONS: __anonenum_PianoRequestType_t_963729421 = 2;
pub const PIANO_REQUEST_LOGIN: __anonenum_PianoRequestType_t_963729421 = 1;
pub type PianoRequestType_t = __anonenum_PianoRequestType_t_963729421;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataLogin_t_116150752 {
    pub user: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub step: libc::c_uchar,
}
pub type PianoRequestDataLogin_t = __anonstruct_PianoRequestDataLogin_t_116150752;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataGetPlaylist_t_687121421 {
    pub station: *mut PianoStation_t,
    pub quality: PianoAudioQuality_t,
    pub retPlaylist: *mut PianoSong_t,
}
pub type PianoRequestDataGetPlaylist_t = __anonstruct_PianoRequestDataGetPlaylist_t_687121421;
pub type __anonenum_PianoReturn_t_816789353 = libc::c_uint;
pub const PIANO_RET_P_RATE_LIMIT: __anonenum_PianoReturn_t_816789353 = 2063;
pub const PIANO_RET_P_ZIP_CODE_INVALID: __anonenum_PianoReturn_t_816789353 = 2048;
pub const PIANO_RET_P_USER_NOT_AUTHORIZED: __anonenum_PianoReturn_t_816789353 = 2028;
pub const PIANO_RET_P_LISTENER_NOT_AUTHORIZED: __anonenum_PianoReturn_t_816789353 = 2027;
pub const PIANO_RET_P_USER_ALREADY_USED_TRIAL: __anonenum_PianoReturn_t_816789353 = 2061;
pub const PIANO_RET_P_USERNAME_ALREADY_EXISTS: __anonenum_PianoReturn_t_816789353 = 2037;
pub const PIANO_RET_P_URL_PARAM_MISSING_USER_ID: __anonenum_PianoReturn_t_816789353 = 1029;
pub const PIANO_RET_P_URL_PARAM_MISSING_PARTNER_ID: __anonenum_PianoReturn_t_816789353 = 1028;
pub const PIANO_RET_P_URL_PARAM_MISSING_METHOD: __anonenum_PianoReturn_t_816789353 = 1026;
pub const PIANO_RET_P_URL_PARAM_MISSING_AUTH_TOKEN: __anonenum_PianoReturn_t_816789353 = 1027;
pub const PIANO_RET_P_UPGRADE_DEVICE_MODEL_INVALID: __anonenum_PianoReturn_t_816789353 = 2039;
pub const PIANO_RET_P_STATION_DOES_NOT_EXIST: __anonenum_PianoReturn_t_816789353 = 2030;
pub const PIANO_RET_P_SECURE_PROTOCOL_REQUIRED: __anonenum_PianoReturn_t_816789353 = 1030;
pub const PIANO_RET_P_READ_ONLY_MODE: __anonenum_PianoReturn_t_816789353 = 2024;
pub const PIANO_RET_P_PARTNER_NOT_AUTHORIZED: __anonenum_PianoReturn_t_816789353 = 2034;
pub const PIANO_RET_P_PARAMETER_VALUE_INVALID: __anonenum_PianoReturn_t_816789353 = 1034;
pub const PIANO_RET_P_PARAMETER_TYPE_MISMATCH: __anonenum_PianoReturn_t_816789353 = 1032;
pub const PIANO_RET_P_PARAMETER_MISSING: __anonenum_PianoReturn_t_816789353 = 1033;
pub const PIANO_RET_P_MAX_STATIONS_REACHED: __anonenum_PianoReturn_t_816789353 = 2029;
pub const PIANO_RET_P_MAINTENANCE_MODE: __anonenum_PianoReturn_t_816789353 = 1025;
pub const PIANO_RET_P_LICENSING_RESTRICTIONS: __anonenum_PianoReturn_t_816789353 = 1036;
pub const PIANO_RET_P_INVALID_USERNAME: __anonenum_PianoReturn_t_816789353 = 2035;
pub const PIANO_RET_P_INVALID_SPONSOR: __anonenum_PianoReturn_t_816789353 = 2060;
pub const PIANO_RET_P_INVALID_PASSWORD: __anonenum_PianoReturn_t_816789353 = 2036;
pub const PIANO_RET_P_INVALID_PARTNER_LOGIN: __anonenum_PianoReturn_t_816789353 = 2026;
pub const PIANO_RET_P_INVALID_GENDER: __anonenum_PianoReturn_t_816789353 = 2051;
pub const PIANO_RET_P_INVALID_COUNTRY_CODE: __anonenum_PianoReturn_t_816789353 = 2051;
pub const PIANO_RET_P_INVALID_AUTH_TOKEN: __anonenum_PianoReturn_t_816789353 = 2025;
pub const PIANO_RET_P_INSUFFICIENT_CONNECTIVITY: __anonenum_PianoReturn_t_816789353 = 1037;
pub const PIANO_RET_P_EXPLICIT_PIN_MALFORMED: __anonenum_PianoReturn_t_816789353 = 2044;
pub const PIANO_RET_P_EXPLICIT_PIN_INCORRECT: __anonenum_PianoReturn_t_816789353 = 2042;
pub const PIANO_RET_P_DEVICE_NOT_FOUND: __anonenum_PianoReturn_t_816789353 = 2033;
pub const PIANO_RET_P_DEVICE_MODEL_INVALID: __anonenum_PianoReturn_t_816789353 = 2047;
pub const PIANO_RET_P_DEVICE_DISABLED: __anonenum_PianoReturn_t_816789353 = 2058;
pub const PIANO_RET_P_DEVICE_ALREADY_ASSOCIATED_TO_ACCOUNT: __anonenum_PianoReturn_t_816789353 = 2038;
pub const PIANO_RET_P_DAILY_TRIAL_LIMIT_REACHED: __anonenum_PianoReturn_t_816789353 = 2059;
pub const PIANO_RET_P_COMPLIMENTARY_PERIOD_ALREADY_IN_USE: __anonenum_PianoReturn_t_816789353 = 2031;
pub const PIANO_RET_P_CERTIFICATE_REQUIRED: __anonenum_PianoReturn_t_816789353 = 1031;
pub const PIANO_RET_P_CALL_NOT_ALLOWED: __anonenum_PianoReturn_t_816789353 = 2032;
pub const PIANO_RET_P_BIRTH_YEAR_TOO_YOUNG: __anonenum_PianoReturn_t_816789353 = 2050;
pub const PIANO_RET_P_BIRTH_YEAR_INVALID: __anonenum_PianoReturn_t_816789353 = 2049;
pub const PIANO_RET_P_API_VERSION_NOT_SUPPORTED: __anonenum_PianoReturn_t_816789353 = 1035;
pub const PIANO_RET_P_INTERNAL: __anonenum_PianoReturn_t_816789353 = 1024;
pub const PIANO_RET_GCRY_ERR: __anonenum_PianoReturn_t_816789353 = 7;
pub const PIANO_RET_QUALITY_UNAVAILABLE: __anonenum_PianoReturn_t_816789353 = 6;
pub const PIANO_RET_INVALID_LOGIN: __anonenum_PianoReturn_t_816789353 = 5;
pub const PIANO_RET_OUT_OF_MEMORY: __anonenum_PianoReturn_t_816789353 = 4;
pub const PIANO_RET_CONTINUE_REQUEST: __anonenum_PianoReturn_t_816789353 = 3;
pub const PIANO_RET_INVALID_RESPONSE: __anonenum_PianoReturn_t_816789353 = 2;
pub const PIANO_RET_OK: __anonenum_PianoReturn_t_816789353 = 1;
pub const PIANO_RET_ERR: __anonenum_PianoReturn_t_816789353 = 0;
pub type PianoReturn_t = __anonenum_PianoReturn_t_816789353;
pub type CURL = ();
pub type __anonenum_CURLcode_1040171027 = libc::c_uint;
pub const CURL_LAST: __anonenum_CURLcode_1040171027 = 96;
pub const CURLE_HTTP3: __anonenum_CURLcode_1040171027 = 95;
pub const CURLE_AUTH_ERROR: __anonenum_CURLcode_1040171027 = 94;
pub const CURLE_RECURSIVE_API_CALL: __anonenum_CURLcode_1040171027 = 93;
pub const CURLE_HTTP2_STREAM: __anonenum_CURLcode_1040171027 = 92;
pub const CURLE_SSL_INVALIDCERTSTATUS: __anonenum_CURLcode_1040171027 = 91;
pub const CURLE_SSL_PINNEDPUBKEYNOTMATCH: __anonenum_CURLcode_1040171027 = 90;
pub const CURLE_NO_CONNECTION_AVAILABLE: __anonenum_CURLcode_1040171027 = 89;
pub const CURLE_CHUNK_FAILED: __anonenum_CURLcode_1040171027 = 88;
pub const CURLE_FTP_BAD_FILE_LIST: __anonenum_CURLcode_1040171027 = 87;
pub const CURLE_RTSP_SESSION_ERROR: __anonenum_CURLcode_1040171027 = 86;
pub const CURLE_RTSP_CSEQ_ERROR: __anonenum_CURLcode_1040171027 = 85;
pub const CURLE_FTP_PRET_FAILED: __anonenum_CURLcode_1040171027 = 84;
pub const CURLE_SSL_ISSUER_ERROR: __anonenum_CURLcode_1040171027 = 83;
pub const CURLE_SSL_CRL_BADFILE: __anonenum_CURLcode_1040171027 = 82;
pub const CURLE_AGAIN: __anonenum_CURLcode_1040171027 = 81;
pub const CURLE_SSL_SHUTDOWN_FAILED: __anonenum_CURLcode_1040171027 = 80;
pub const CURLE_SSH: __anonenum_CURLcode_1040171027 = 79;
pub const CURLE_REMOTE_FILE_NOT_FOUND: __anonenum_CURLcode_1040171027 = 78;
pub const CURLE_SSL_CACERT_BADFILE: __anonenum_CURLcode_1040171027 = 77;
pub const CURLE_CONV_REQD: __anonenum_CURLcode_1040171027 = 76;
pub const CURLE_CONV_FAILED: __anonenum_CURLcode_1040171027 = 75;
pub const CURLE_TFTP_NOSUCHUSER: __anonenum_CURLcode_1040171027 = 74;
pub const CURLE_REMOTE_FILE_EXISTS: __anonenum_CURLcode_1040171027 = 73;
pub const CURLE_TFTP_UNKNOWNID: __anonenum_CURLcode_1040171027 = 72;
pub const CURLE_TFTP_ILLEGAL: __anonenum_CURLcode_1040171027 = 71;
pub const CURLE_REMOTE_DISK_FULL: __anonenum_CURLcode_1040171027 = 70;
pub const CURLE_TFTP_PERM: __anonenum_CURLcode_1040171027 = 69;
pub const CURLE_TFTP_NOTFOUND: __anonenum_CURLcode_1040171027 = 68;
pub const CURLE_LOGIN_DENIED: __anonenum_CURLcode_1040171027 = 67;
pub const CURLE_SSL_ENGINE_INITFAILED: __anonenum_CURLcode_1040171027 = 66;
pub const CURLE_SEND_FAIL_REWIND: __anonenum_CURLcode_1040171027 = 65;
pub const CURLE_USE_SSL_FAILED: __anonenum_CURLcode_1040171027 = 64;
pub const CURLE_FILESIZE_EXCEEDED: __anonenum_CURLcode_1040171027 = 63;
pub const CURLE_LDAP_INVALID_URL: __anonenum_CURLcode_1040171027 = 62;
pub const CURLE_BAD_CONTENT_ENCODING: __anonenum_CURLcode_1040171027 = 61;
pub const CURLE_PEER_FAILED_VERIFICATION: __anonenum_CURLcode_1040171027 = 60;
pub const CURLE_SSL_CIPHER: __anonenum_CURLcode_1040171027 = 59;
pub const CURLE_SSL_CERTPROBLEM: __anonenum_CURLcode_1040171027 = 58;
pub const CURLE_OBSOLETE57: __anonenum_CURLcode_1040171027 = 57;
pub const CURLE_RECV_ERROR: __anonenum_CURLcode_1040171027 = 56;
pub const CURLE_SEND_ERROR: __anonenum_CURLcode_1040171027 = 55;
pub const CURLE_SSL_ENGINE_SETFAILED: __anonenum_CURLcode_1040171027 = 54;
pub const CURLE_SSL_ENGINE_NOTFOUND: __anonenum_CURLcode_1040171027 = 53;
pub const CURLE_GOT_NOTHING: __anonenum_CURLcode_1040171027 = 52;
pub const CURLE_OBSOLETE51: __anonenum_CURLcode_1040171027 = 51;
pub const CURLE_OBSOLETE50: __anonenum_CURLcode_1040171027 = 50;
pub const CURLE_TELNET_OPTION_SYNTAX: __anonenum_CURLcode_1040171027 = 49;
pub const CURLE_UNKNOWN_OPTION: __anonenum_CURLcode_1040171027 = 48;
pub const CURLE_TOO_MANY_REDIRECTS: __anonenum_CURLcode_1040171027 = 47;
pub const CURLE_OBSOLETE46: __anonenum_CURLcode_1040171027 = 46;
pub const CURLE_INTERFACE_FAILED: __anonenum_CURLcode_1040171027 = 45;
pub const CURLE_OBSOLETE44: __anonenum_CURLcode_1040171027 = 44;
pub const CURLE_BAD_FUNCTION_ARGUMENT: __anonenum_CURLcode_1040171027 = 43;
pub const CURLE_ABORTED_BY_CALLBACK: __anonenum_CURLcode_1040171027 = 42;
pub const CURLE_FUNCTION_NOT_FOUND: __anonenum_CURLcode_1040171027 = 41;
pub const CURLE_OBSOLETE40: __anonenum_CURLcode_1040171027 = 40;
pub const CURLE_LDAP_SEARCH_FAILED: __anonenum_CURLcode_1040171027 = 39;
pub const CURLE_LDAP_CANNOT_BIND: __anonenum_CURLcode_1040171027 = 38;
pub const CURLE_FILE_COULDNT_READ_FILE: __anonenum_CURLcode_1040171027 = 37;
pub const CURLE_BAD_DOWNLOAD_RESUME: __anonenum_CURLcode_1040171027 = 36;
pub const CURLE_SSL_CONNECT_ERROR: __anonenum_CURLcode_1040171027 = 35;
pub const CURLE_HTTP_POST_ERROR: __anonenum_CURLcode_1040171027 = 34;
pub const CURLE_RANGE_ERROR: __anonenum_CURLcode_1040171027 = 33;
pub const CURLE_OBSOLETE32: __anonenum_CURLcode_1040171027 = 32;
pub const CURLE_FTP_COULDNT_USE_REST: __anonenum_CURLcode_1040171027 = 31;
pub const CURLE_FTP_PORT_FAILED: __anonenum_CURLcode_1040171027 = 30;
pub const CURLE_OBSOLETE29: __anonenum_CURLcode_1040171027 = 29;
pub const CURLE_OPERATION_TIMEDOUT: __anonenum_CURLcode_1040171027 = 28;
pub const CURLE_OUT_OF_MEMORY: __anonenum_CURLcode_1040171027 = 27;
pub const CURLE_READ_ERROR: __anonenum_CURLcode_1040171027 = 26;
pub const CURLE_UPLOAD_FAILED: __anonenum_CURLcode_1040171027 = 25;
pub const CURLE_OBSOLETE24: __anonenum_CURLcode_1040171027 = 24;
pub const CURLE_WRITE_ERROR: __anonenum_CURLcode_1040171027 = 23;
pub const CURLE_HTTP_RETURNED_ERROR: __anonenum_CURLcode_1040171027 = 22;
pub const CURLE_QUOTE_ERROR: __anonenum_CURLcode_1040171027 = 21;
pub const CURLE_OBSOLETE20: __anonenum_CURLcode_1040171027 = 20;
pub const CURLE_FTP_COULDNT_RETR_FILE: __anonenum_CURLcode_1040171027 = 19;
pub const CURLE_PARTIAL_FILE: __anonenum_CURLcode_1040171027 = 18;
pub const CURLE_FTP_COULDNT_SET_TYPE: __anonenum_CURLcode_1040171027 = 17;
pub const CURLE_HTTP2: __anonenum_CURLcode_1040171027 = 16;
pub const CURLE_FTP_CANT_GET_HOST: __anonenum_CURLcode_1040171027 = 15;
pub const CURLE_FTP_WEIRD_227_FORMAT: __anonenum_CURLcode_1040171027 = 14;
pub const CURLE_FTP_WEIRD_PASV_REPLY: __anonenum_CURLcode_1040171027 = 13;
pub const CURLE_FTP_ACCEPT_TIMEOUT: __anonenum_CURLcode_1040171027 = 12;
pub const CURLE_FTP_WEIRD_PASS_REPLY: __anonenum_CURLcode_1040171027 = 11;
pub const CURLE_FTP_ACCEPT_FAILED: __anonenum_CURLcode_1040171027 = 10;
pub const CURLE_REMOTE_ACCESS_DENIED: __anonenum_CURLcode_1040171027 = 9;
pub const CURLE_WEIRD_SERVER_REPLY: __anonenum_CURLcode_1040171027 = 8;
pub const CURLE_COULDNT_CONNECT: __anonenum_CURLcode_1040171027 = 7;
pub const CURLE_COULDNT_RESOLVE_HOST: __anonenum_CURLcode_1040171027 = 6;
pub const CURLE_COULDNT_RESOLVE_PROXY: __anonenum_CURLcode_1040171027 = 5;
pub const CURLE_NOT_BUILT_IN: __anonenum_CURLcode_1040171027 = 4;
pub const CURLE_URL_MALFORMAT: __anonenum_CURLcode_1040171027 = 3;
pub const CURLE_FAILED_INIT: __anonenum_CURLcode_1040171027 = 2;
pub const CURLE_UNSUPPORTED_PROTOCOL: __anonenum_CURLcode_1040171027 = 1;
pub const CURLE_OK: __anonenum_CURLcode_1040171027 = 0;
pub type CURLcode = __anonenum_CURLcode_1040171027;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type AVMediaType = libc::c_int;
pub const AVMEDIA_TYPE_NB: AVMediaType = 5;
pub const AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
pub const AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
pub const AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub type AVPictureType = libc::c_uint;
pub const AV_PICTURE_TYPE_BI: AVPictureType = 7;
pub const AV_PICTURE_TYPE_SP: AVPictureType = 6;
pub const AV_PICTURE_TYPE_SI: AVPictureType = 5;
pub const AV_PICTURE_TYPE_S: AVPictureType = 4;
pub const AV_PICTURE_TYPE_B: AVPictureType = 3;
pub const AV_PICTURE_TYPE_P: AVPictureType = 2;
pub const AV_PICTURE_TYPE_I: AVPictureType = 1;
pub const AV_PICTURE_TYPE_NONE: AVPictureType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVRational {
    pub num: libc::c_int,
    pub den: libc::c_int,
}
pub type __anonenum_AVClassCategory_328176932 = libc::c_uint;
pub const AV_CLASS_CATEGORY_NB: __anonenum_AVClassCategory_328176932 = 46;
pub const AV_CLASS_CATEGORY_DEVICE_INPUT: __anonenum_AVClassCategory_328176932 = 45;
pub const AV_CLASS_CATEGORY_DEVICE_OUTPUT: __anonenum_AVClassCategory_328176932 = 44;
pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: __anonenum_AVClassCategory_328176932 = 43;
pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: __anonenum_AVClassCategory_328176932 = 42;
pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: __anonenum_AVClassCategory_328176932 = 41;
pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: __anonenum_AVClassCategory_328176932 = 40;
pub const AV_CLASS_CATEGORY_SWRESAMPLER: __anonenum_AVClassCategory_328176932 = 10;
pub const AV_CLASS_CATEGORY_SWSCALER: __anonenum_AVClassCategory_328176932 = 9;
pub const AV_CLASS_CATEGORY_BITSTREAM_FILTER: __anonenum_AVClassCategory_328176932 = 8;
pub const AV_CLASS_CATEGORY_FILTER: __anonenum_AVClassCategory_328176932 = 7;
pub const AV_CLASS_CATEGORY_DECODER: __anonenum_AVClassCategory_328176932 = 6;
pub const AV_CLASS_CATEGORY_ENCODER: __anonenum_AVClassCategory_328176932 = 5;
pub const AV_CLASS_CATEGORY_DEMUXER: __anonenum_AVClassCategory_328176932 = 4;
pub const AV_CLASS_CATEGORY_MUXER: __anonenum_AVClassCategory_328176932 = 3;
pub const AV_CLASS_CATEGORY_OUTPUT: __anonenum_AVClassCategory_328176932 = 2;
pub const AV_CLASS_CATEGORY_INPUT: __anonenum_AVClassCategory_328176932 = 1;
pub const AV_CLASS_CATEGORY_NA: __anonenum_AVClassCategory_328176932 = 0;
pub type AVClassCategory = __anonenum_AVClassCategory_328176932;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVOptionRanges {
    pub range: *mut *mut AVOptionRange,
    pub nb_ranges: libc::c_int,
    pub nb_components: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVOptionRange {
    pub str_0: *const libc::c_char,
    pub value_min: libc::c_double,
    pub value_max: libc::c_double,
    pub component_min: libc::c_double,
    pub component_max: libc::c_double,
    pub is_range: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVOption {
    pub name: *const libc::c_char,
    pub help: *const libc::c_char,
    pub offset: libc::c_int,
    pub type_0: AVOptionType,
    pub default_val: __anonunion_default_val_762784759,
    pub min: libc::c_double,
    pub max: libc::c_double,
    pub flags: libc::c_int,
    pub unit: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_default_val_762784759 {
    pub i64_0: int64_t,
    pub dbl: libc::c_double,
    pub str_0: *const libc::c_char,
    pub q: AVRational,
}
pub type AVOptionType = libc::c_uint;
pub const AV_OPT_TYPE_BOOL: AVOptionType = 18;
pub const AV_OPT_TYPE_CHANNEL_LAYOUT: AVOptionType = 17;
pub const AV_OPT_TYPE_COLOR: AVOptionType = 16;
pub const AV_OPT_TYPE_DURATION: AVOptionType = 15;
pub const AV_OPT_TYPE_VIDEO_RATE: AVOptionType = 14;
pub const AV_OPT_TYPE_SAMPLE_FMT: AVOptionType = 13;
pub const AV_OPT_TYPE_PIXEL_FMT: AVOptionType = 12;
pub const AV_OPT_TYPE_IMAGE_SIZE: AVOptionType = 11;
pub const AV_OPT_TYPE_CONST: AVOptionType = 10;
pub const AV_OPT_TYPE_UINT64: AVOptionType = 9;
pub const AV_OPT_TYPE_DICT: AVOptionType = 8;
pub const AV_OPT_TYPE_BINARY: AVOptionType = 7;
pub const AV_OPT_TYPE_RATIONAL: AVOptionType = 6;
pub const AV_OPT_TYPE_STRING: AVOptionType = 5;
pub const AV_OPT_TYPE_FLOAT: AVOptionType = 4;
pub const AV_OPT_TYPE_DOUBLE: AVOptionType = 3;
pub const AV_OPT_TYPE_INT64: AVOptionType = 2;
pub const AV_OPT_TYPE_INT: AVOptionType = 1;
pub const AV_OPT_TYPE_FLAGS: AVOptionType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVClass {
    pub class_name: *const libc::c_char,
    pub item_name: Option::<
        unsafe extern "C" fn(*mut libc::c_void) -> *const libc::c_char,
    >,
    pub option: *const AVOption,
    pub version: libc::c_int,
    pub log_level_offset_offset: libc::c_int,
    pub parent_log_context_offset: libc::c_int,
    pub child_next: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> *mut libc::c_void,
    >,
    pub child_class_next: Option::<
        unsafe extern "C" fn(*const AVClass) -> *const AVClass,
    >,
    pub category: AVClassCategory,
    pub get_category: Option::<
        unsafe extern "C" fn(*mut libc::c_void) -> AVClassCategory,
    >,
    pub query_ranges: Option::<
        unsafe extern "C" fn(
            *mut *mut AVOptionRanges,
            *mut libc::c_void,
            *const libc::c_char,
            libc::c_int,
        ) -> libc::c_int,
    >,
}
pub type AVPixelFormat = libc::c_int;
pub const AV_PIX_FMT_NB: AVPixelFormat = 193;
pub const AV_PIX_FMT_NV42: AVPixelFormat = 192;
pub const AV_PIX_FMT_NV24: AVPixelFormat = 191;
pub const AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 190;
pub const AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 189;
pub const AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 188;
pub const AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 187;
pub const AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 186;
pub const AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 185;
pub const AV_PIX_FMT_GRAY14LE: AVPixelFormat = 184;
pub const AV_PIX_FMT_GRAY14BE: AVPixelFormat = 183;
pub const AV_PIX_FMT_OPENCL: AVPixelFormat = 182;
pub const AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 181;
pub const AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 180;
pub const AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 179;
pub const AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 178;
pub const AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 177;
pub const AV_PIX_FMT_GRAY9LE: AVPixelFormat = 176;
pub const AV_PIX_FMT_GRAY9BE: AVPixelFormat = 175;
pub const AV_PIX_FMT_D3D11: AVPixelFormat = 174;
pub const AV_PIX_FMT_P016BE: AVPixelFormat = 173;
pub const AV_PIX_FMT_P016LE: AVPixelFormat = 172;
pub const AV_PIX_FMT_GRAY10LE: AVPixelFormat = 171;
pub const AV_PIX_FMT_GRAY10BE: AVPixelFormat = 170;
pub const AV_PIX_FMT_GRAY12LE: AVPixelFormat = 169;
pub const AV_PIX_FMT_GRAY12BE: AVPixelFormat = 168;
pub const AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 167;
pub const AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 166;
pub const AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 165;
pub const AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 164;
pub const AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 163;
pub const AV_PIX_FMT_P010BE: AVPixelFormat = 162;
pub const AV_PIX_FMT_P010LE: AVPixelFormat = 161;
pub const AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 160;
pub const AV_PIX_FMT_AYUV64BE: AVPixelFormat = 159;
pub const AV_PIX_FMT_AYUV64LE: AVPixelFormat = 158;
pub const AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 157;
pub const AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 156;
pub const AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 155;
pub const AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 154;
pub const AV_PIX_FMT_XVMC: AVPixelFormat = 153;
pub const AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 152;
pub const AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 151;
pub const AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 150;
pub const AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 149;
pub const AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 148;
pub const AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 147;
pub const AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 146;
pub const AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 145;
pub const AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 144;
pub const AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 143;
pub const AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 142;
pub const AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 141;
pub const AV_PIX_FMT_YUVJ411P: AVPixelFormat = 140;
pub const AV_PIX_FMT_GBRP14LE: AVPixelFormat = 139;
pub const AV_PIX_FMT_GBRP14BE: AVPixelFormat = 138;
pub const AV_PIX_FMT_GBRP12LE: AVPixelFormat = 137;
pub const AV_PIX_FMT_GBRP12BE: AVPixelFormat = 136;
pub const AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 135;
pub const AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 134;
pub const AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 133;
pub const AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 132;
pub const AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 131;
pub const AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 130;
pub const AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 129;
pub const AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 128;
pub const AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 127;
pub const AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 126;
pub const AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 125;
pub const AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 124;
pub const AV_PIX_FMT_BGR0: AVPixelFormat = 123;
pub const AV_PIX_FMT_0BGR: AVPixelFormat = 122;
pub const AV_PIX_FMT_RGB0: AVPixelFormat = 121;
pub const AV_PIX_FMT_0RGB: AVPixelFormat = 120;
pub const AV_PIX_FMT_CUDA: AVPixelFormat = 119;
pub const AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 118;
pub const AV_PIX_FMT_MMAL: AVPixelFormat = 117;
pub const AV_PIX_FMT_QSV: AVPixelFormat = 116;
pub const AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 115;
pub const AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 114;
pub const AV_PIX_FMT_GBRAP: AVPixelFormat = 113;
pub const AV_PIX_FMT_YA16LE: AVPixelFormat = 112;
pub const AV_PIX_FMT_YA16BE: AVPixelFormat = 111;
pub const AV_PIX_FMT_YVYU422: AVPixelFormat = 110;
pub const AV_PIX_FMT_BGRA64LE: AVPixelFormat = 109;
pub const AV_PIX_FMT_BGRA64BE: AVPixelFormat = 108;
pub const AV_PIX_FMT_RGBA64LE: AVPixelFormat = 107;
pub const AV_PIX_FMT_RGBA64BE: AVPixelFormat = 106;
pub const AV_PIX_FMT_NV20BE: AVPixelFormat = 105;
pub const AV_PIX_FMT_NV20LE: AVPixelFormat = 104;
pub const AV_PIX_FMT_NV16: AVPixelFormat = 103;
pub const AV_PIX_FMT_XYZ12BE: AVPixelFormat = 102;
pub const AV_PIX_FMT_XYZ12LE: AVPixelFormat = 101;
pub const AV_PIX_FMT_VDPAU: AVPixelFormat = 100;
pub const AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 99;
pub const AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 98;
pub const AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 97;
pub const AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 96;
pub const AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 95;
pub const AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 94;
pub const AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 93;
pub const AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 92;
pub const AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 91;
pub const AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 90;
pub const AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 89;
pub const AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 88;
pub const AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 87;
pub const AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 86;
pub const AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 85;
pub const AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 84;
pub const AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 83;
pub const AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 82;
pub const AV_PIX_FMT_YUVA444P: AVPixelFormat = 81;
pub const AV_PIX_FMT_YUVA422P: AVPixelFormat = 80;
pub const AV_PIX_FMT_GBRP16LE: AVPixelFormat = 79;
pub const AV_PIX_FMT_GBRP16BE: AVPixelFormat = 78;
pub const AV_PIX_FMT_GBRP10LE: AVPixelFormat = 77;
pub const AV_PIX_FMT_GBRP10BE: AVPixelFormat = 76;
pub const AV_PIX_FMT_GBRP9LE: AVPixelFormat = 75;
pub const AV_PIX_FMT_GBRP9BE: AVPixelFormat = 74;
pub const AV_PIX_FMT_GBR24P: AVPixelFormat = 73;
pub const AV_PIX_FMT_GBRP: AVPixelFormat = 73;
pub const AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 72;
pub const AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 71;
pub const AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 70;
pub const AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 69;
pub const AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 68;
pub const AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 67;
pub const AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 66;
pub const AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 65;
pub const AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 64;
pub const AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 63;
pub const AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 62;
pub const AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 61;
pub const AV_PIX_FMT_BGR48LE: AVPixelFormat = 60;
pub const AV_PIX_FMT_BGR48BE: AVPixelFormat = 59;
pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = 58;
pub const AV_PIX_FMT_Y400A: AVPixelFormat = 58;
pub const AV_PIX_FMT_YA8: AVPixelFormat = 58;
pub const AV_PIX_FMT_BGR444BE: AVPixelFormat = 57;
pub const AV_PIX_FMT_BGR444LE: AVPixelFormat = 56;
pub const AV_PIX_FMT_RGB444BE: AVPixelFormat = 55;
pub const AV_PIX_FMT_RGB444LE: AVPixelFormat = 54;
pub const AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 53;
pub const AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 52;
pub const AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 51;
pub const AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 50;
pub const AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 49;
pub const AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 48;
pub const AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 47;
pub const AV_PIX_FMT_VAAPI: AVPixelFormat = 46;
pub const AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 46;
pub const AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 45;
pub const AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 44;
pub const AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
pub const AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
pub const AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
pub const AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
pub const AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
pub const AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
pub const AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
pub const AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
pub const AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
pub const AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
pub const AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
pub const AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
pub const AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
pub const AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
pub const AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
pub const AV_PIX_FMT_BGRA: AVPixelFormat = 28;
pub const AV_PIX_FMT_ABGR: AVPixelFormat = 27;
pub const AV_PIX_FMT_RGBA: AVPixelFormat = 26;
pub const AV_PIX_FMT_ARGB: AVPixelFormat = 25;
pub const AV_PIX_FMT_NV21: AVPixelFormat = 24;
pub const AV_PIX_FMT_NV12: AVPixelFormat = 23;
pub const AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
pub const AV_PIX_FMT_RGB4: AVPixelFormat = 21;
pub const AV_PIX_FMT_RGB8: AVPixelFormat = 20;
pub const AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
pub const AV_PIX_FMT_BGR4: AVPixelFormat = 18;
pub const AV_PIX_FMT_BGR8: AVPixelFormat = 17;
pub const AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
pub const AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
pub const AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
pub const AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
pub const AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
pub const AV_PIX_FMT_PAL8: AVPixelFormat = 11;
pub const AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
pub const AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
pub const AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
pub const AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
pub const AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
pub const AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
pub const AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
pub const AV_PIX_FMT_BGR24: AVPixelFormat = 3;
pub const AV_PIX_FMT_RGB24: AVPixelFormat = 2;
pub const AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
pub const AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
pub const AV_PIX_FMT_NONE: AVPixelFormat = -1;
pub type AVColorPrimaries = libc::c_uint;
pub const AVCOL_PRI_NB: AVColorPrimaries = 23;
pub const AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
pub const AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
pub const AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
pub const AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVCOL_PRI_BT2020: AVColorPrimaries = 9;
pub const AVCOL_PRI_FILM: AVColorPrimaries = 8;
pub const AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
pub const AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
pub const AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
pub const AVCOL_PRI_BT470M: AVColorPrimaries = 4;
pub const AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
pub const AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
pub type AVColorTransferCharacteristic = libc::c_uint;
pub const AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
pub const AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
pub const AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
pub const AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
pub const AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
pub const AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
pub const AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
pub const AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
pub const AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
pub const AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
pub const AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
pub const AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
pub const AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
pub const AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
pub const AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
pub const AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
pub type AVColorSpace = libc::c_uint;
pub const AVCOL_SPC_NB: AVColorSpace = 15;
pub const AVCOL_SPC_ICTCP: AVColorSpace = 14;
pub const AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
pub const AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
pub const AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
pub const AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
pub const AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
pub const AVCOL_SPC_YCOCG: AVColorSpace = 8;
pub const AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
pub const AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
pub const AVCOL_SPC_BT470BG: AVColorSpace = 5;
pub const AVCOL_SPC_FCC: AVColorSpace = 4;
pub const AVCOL_SPC_RESERVED: AVColorSpace = 3;
pub const AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVCOL_SPC_RGB: AVColorSpace = 0;
pub type AVColorRange = libc::c_uint;
pub const AVCOL_RANGE_NB: AVColorRange = 3;
pub const AVCOL_RANGE_JPEG: AVColorRange = 2;
pub const AVCOL_RANGE_MPEG: AVColorRange = 1;
pub const AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
pub type AVChromaLocation = libc::c_uint;
pub const AVCHROMA_LOC_NB: AVChromaLocation = 7;
pub const AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
pub const AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
pub const AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
pub const AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
pub type AVSampleFormat = libc::c_int;
pub const AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
pub const AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
pub const AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
pub const AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
pub const AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
pub const AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
pub const AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
pub const AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
pub const AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
pub const AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
pub const AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
pub const AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
pub const AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
pub const AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut uint8_t,
    pub size: libc::c_int,
}
pub type AVFrameSideDataType = libc::c_uint;
pub const AV_FRAME_DATA_REGIONS_OF_INTEREST: AVFrameSideDataType = 20;
pub const AV_FRAME_DATA_DYNAMIC_HDR_PLUS: AVFrameSideDataType = 19;
pub const AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 18;
pub const AV_FRAME_DATA_QP_TABLE_DATA: AVFrameSideDataType = 17;
pub const AV_FRAME_DATA_QP_TABLE_PROPERTIES: AVFrameSideDataType = 16;
pub const AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
pub const AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
pub const AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
pub const AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
pub const AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
pub const AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
pub const AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
pub const AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
pub const AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
pub const AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
pub const AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
pub const AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
pub const AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
pub const AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
pub const AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
pub const AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFrameSideData {
    pub type_0: AVFrameSideDataType,
    pub data: *mut uint8_t,
    pub size: libc::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFrame {
    pub data: [*mut uint8_t; 8],
    pub linesize: [libc::c_int; 8],
    pub extended_data: *mut *mut uint8_t,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub nb_samples: libc::c_int,
    pub format: libc::c_int,
    pub key_frame: libc::c_int,
    pub pict_type: AVPictureType,
    pub sample_aspect_ratio: AVRational,
    pub pts: int64_t,
    pub pkt_pts: int64_t,
    pub pkt_dts: int64_t,
    pub coded_picture_number: libc::c_int,
    pub display_picture_number: libc::c_int,
    pub quality: libc::c_int,
    pub opaque: *mut libc::c_void,
    pub error: [uint64_t; 8],
    pub repeat_pict: libc::c_int,
    pub interlaced_frame: libc::c_int,
    pub top_field_first: libc::c_int,
    pub palette_has_changed: libc::c_int,
    pub reordered_opaque: int64_t,
    pub sample_rate: libc::c_int,
    pub channel_layout: uint64_t,
    pub buf: [*mut AVBufferRef; 8],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: libc::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: libc::c_int,
    pub flags: libc::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub best_effort_timestamp: int64_t,
    pub pkt_pos: int64_t,
    pub pkt_duration: int64_t,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: libc::c_int,
    pub channels: libc::c_int,
    pub pkt_size: libc::c_int,
    pub qscale_table: *mut int8_t,
    pub qstride: libc::c_int,
    pub qscale_type: libc::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub opaque_ref: *mut AVBufferRef,
    pub crop_top: size_t,
    pub crop_bottom: size_t,
    pub crop_left: size_t,
    pub crop_right: size_t,
    pub private_ref: *mut AVBufferRef,
}
pub type AVCodecID = libc::c_uint;
pub const AV_CODEC_ID_WRAPPED_AVFRAME: AVCodecID = 135169;
pub const AV_CODEC_ID_FFMETADATA: AVCodecID = 135168;
pub const AV_CODEC_ID_MPEG4SYSTEMS: AVCodecID = 131073;
pub const AV_CODEC_ID_MPEG2TS: AVCodecID = 131072;
pub const AV_CODEC_ID_PROBE: AVCodecID = 102400;
pub const AV_CODEC_ID_BIN_DATA: AVCodecID = 100359;
pub const AV_CODEC_ID_TIMED_ID3: AVCodecID = 100358;
pub const AV_CODEC_ID_DVD_NAV: AVCodecID = 100357;
pub const AV_CODEC_ID_SMPTE_KLV: AVCodecID = 100356;
pub const AV_CODEC_ID_OTF: AVCodecID = 100355;
pub const AV_CODEC_ID_IDF: AVCodecID = 100354;
pub const AV_CODEC_ID_XBIN: AVCodecID = 100353;
pub const AV_CODEC_ID_BINTEXT: AVCodecID = 100352;
pub const AV_CODEC_ID_SCTE_35: AVCodecID = 98305;
pub const AV_CODEC_ID_TTF: AVCodecID = 98304;
pub const AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = 98304;
pub const AV_CODEC_ID_ARIB_CAPTION: AVCodecID = 96272;
pub const AV_CODEC_ID_TTML: AVCodecID = 96271;
pub const AV_CODEC_ID_HDMV_TEXT_SUBTITLE: AVCodecID = 96270;
pub const AV_CODEC_ID_ASS: AVCodecID = 96269;
pub const AV_CODEC_ID_PJS: AVCodecID = 96268;
pub const AV_CODEC_ID_VPLAYER: AVCodecID = 96267;
pub const AV_CODEC_ID_MPL2: AVCodecID = 96266;
pub const AV_CODEC_ID_WEBVTT: AVCodecID = 96265;
pub const AV_CODEC_ID_SUBRIP: AVCodecID = 96264;
pub const AV_CODEC_ID_SUBVIEWER: AVCodecID = 96263;
pub const AV_CODEC_ID_SUBVIEWER1: AVCodecID = 96262;
pub const AV_CODEC_ID_STL: AVCodecID = 96261;
pub const AV_CODEC_ID_REALTEXT: AVCodecID = 96260;
pub const AV_CODEC_ID_SAMI: AVCodecID = 96259;
pub const AV_CODEC_ID_JACOSUB: AVCodecID = 96258;
pub const AV_CODEC_ID_EIA_608: AVCodecID = 96257;
pub const AV_CODEC_ID_MICRODVD: AVCodecID = 96256;
pub const AV_CODEC_ID_SRT: AVCodecID = 94216;
pub const AV_CODEC_ID_DVB_TELETEXT: AVCodecID = 94215;
pub const AV_CODEC_ID_HDMV_PGS_SUBTITLE: AVCodecID = 94214;
pub const AV_CODEC_ID_MOV_TEXT: AVCodecID = 94213;
pub const AV_CODEC_ID_SSA: AVCodecID = 94212;
pub const AV_CODEC_ID_XSUB: AVCodecID = 94211;
pub const AV_CODEC_ID_TEXT: AVCodecID = 94210;
pub const AV_CODEC_ID_DVB_SUBTITLE: AVCodecID = 94209;
pub const AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = 94208;
pub const AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = 94208;
pub const AV_CODEC_ID_HCOM: AVCodecID = 88085;
pub const AV_CODEC_ID_ATRAC9: AVCodecID = 88084;
pub const AV_CODEC_ID_SBC: AVCodecID = 88083;
pub const AV_CODEC_ID_APTX_HD: AVCodecID = 88082;
pub const AV_CODEC_ID_APTX: AVCodecID = 88081;
pub const AV_CODEC_ID_DOLBY_E: AVCodecID = 88080;
pub const AV_CODEC_ID_ATRAC3PAL: AVCodecID = 88079;
pub const AV_CODEC_ID_ATRAC3AL: AVCodecID = 88078;
pub const AV_CODEC_ID_DST: AVCodecID = 88077;
pub const AV_CODEC_ID_XMA2: AVCodecID = 88076;
pub const AV_CODEC_ID_XMA1: AVCodecID = 88075;
pub const AV_CODEC_ID_INTERPLAY_ACM: AVCodecID = 88074;
pub const AV_CODEC_ID_4GV: AVCodecID = 88073;
pub const AV_CODEC_ID_DSD_MSBF_PLANAR: AVCodecID = 88072;
pub const AV_CODEC_ID_DSD_LSBF_PLANAR: AVCodecID = 88071;
pub const AV_CODEC_ID_DSD_MSBF: AVCodecID = 88070;
pub const AV_CODEC_ID_DSD_LSBF: AVCodecID = 88069;
pub const AV_CODEC_ID_SMV: AVCodecID = 88068;
pub const AV_CODEC_ID_EVRC: AVCodecID = 88067;
pub const AV_CODEC_ID_SONIC_LS: AVCodecID = 88066;
pub const AV_CODEC_ID_SONIC: AVCodecID = 88065;
pub const AV_CODEC_ID_FFWAVESYNTH: AVCodecID = 88064;
pub const AV_CODEC_ID_CODEC2: AVCodecID = 86083;
pub const AV_CODEC_ID_DSS_SP: AVCodecID = 86082;
pub const AV_CODEC_ID_ON2AVC: AVCodecID = 86081;
pub const AV_CODEC_ID_PAF_AUDIO: AVCodecID = 86080;
pub const AV_CODEC_ID_METASOUND: AVCodecID = 86079;
pub const AV_CODEC_ID_TAK: AVCodecID = 86078;
pub const AV_CODEC_ID_COMFORT_NOISE: AVCodecID = 86077;
pub const AV_CODEC_ID_OPUS: AVCodecID = 86076;
pub const AV_CODEC_ID_ILBC: AVCodecID = 86075;
pub const AV_CODEC_ID_IAC: AVCodecID = 86074;
pub const AV_CODEC_ID_RALF: AVCodecID = 86073;
pub const AV_CODEC_ID_BMV_AUDIO: AVCodecID = 86072;
pub const AV_CODEC_ID_8SVX_FIB: AVCodecID = 86071;
pub const AV_CODEC_ID_8SVX_EXP: AVCodecID = 86070;
pub const AV_CODEC_ID_G729: AVCodecID = 86069;
pub const AV_CODEC_ID_G723_1: AVCodecID = 86068;
pub const AV_CODEC_ID_CELT: AVCodecID = 86067;
pub const AV_CODEC_ID_QDMC: AVCodecID = 86066;
pub const AV_CODEC_ID_AAC_LATM: AVCodecID = 86065;
pub const AV_CODEC_ID_BINKAUDIO_DCT: AVCodecID = 86064;
pub const AV_CODEC_ID_BINKAUDIO_RDFT: AVCodecID = 86063;
pub const AV_CODEC_ID_ATRAC1: AVCodecID = 86062;
pub const AV_CODEC_ID_MP4ALS: AVCodecID = 86061;
pub const AV_CODEC_ID_TRUEHD: AVCodecID = 86060;
pub const AV_CODEC_ID_TWINVQ: AVCodecID = 86059;
pub const AV_CODEC_ID_MP1: AVCodecID = 86058;
pub const AV_CODEC_ID_SIPR: AVCodecID = 86057;
pub const AV_CODEC_ID_EAC3: AVCodecID = 86056;
pub const AV_CODEC_ID_ATRAC3P: AVCodecID = 86055;
pub const AV_CODEC_ID_WMALOSSLESS: AVCodecID = 86054;
pub const AV_CODEC_ID_WMAPRO: AVCodecID = 86053;
pub const AV_CODEC_ID_WMAVOICE: AVCodecID = 86052;
pub const AV_CODEC_ID_SPEEX: AVCodecID = 86051;
pub const AV_CODEC_ID_MUSEPACK8: AVCodecID = 86050;
pub const AV_CODEC_ID_NELLYMOSER: AVCodecID = 86049;
pub const AV_CODEC_ID_APE: AVCodecID = 86048;
pub const AV_CODEC_ID_ATRAC3: AVCodecID = 86047;
pub const AV_CODEC_ID_GSM_MS: AVCodecID = 86046;
pub const AV_CODEC_ID_MLP: AVCodecID = 86045;
pub const AV_CODEC_ID_MUSEPACK7: AVCodecID = 86044;
pub const AV_CODEC_ID_IMC: AVCodecID = 86043;
pub const AV_CODEC_ID_DSICINAUDIO: AVCodecID = 86042;
pub const AV_CODEC_ID_WAVPACK: AVCodecID = 86041;
pub const AV_CODEC_ID_QCELP: AVCodecID = 86040;
pub const AV_CODEC_ID_SMACKAUDIO: AVCodecID = 86039;
pub const AV_CODEC_ID_TTA: AVCodecID = 86038;
pub const AV_CODEC_ID_TRUESPEECH: AVCodecID = 86037;
pub const AV_CODEC_ID_COOK: AVCodecID = 86036;
pub const AV_CODEC_ID_QDM2: AVCodecID = 86035;
pub const AV_CODEC_ID_GSM: AVCodecID = 86034;
pub const AV_CODEC_ID_WESTWOOD_SND1: AVCodecID = 86033;
pub const AV_CODEC_ID_ALAC: AVCodecID = 86032;
pub const AV_CODEC_ID_SHORTEN: AVCodecID = 86031;
pub const AV_CODEC_ID_MP3ON4: AVCodecID = 86030;
pub const AV_CODEC_ID_MP3ADU: AVCodecID = 86029;
pub const AV_CODEC_ID_FLAC: AVCodecID = 86028;
pub const AV_CODEC_ID_VMDAUDIO: AVCodecID = 86027;
pub const AV_CODEC_ID_MACE6: AVCodecID = 86026;
pub const AV_CODEC_ID_MACE3: AVCodecID = 86025;
pub const AV_CODEC_ID_WMAV2: AVCodecID = 86024;
pub const AV_CODEC_ID_WMAV1: AVCodecID = 86023;
pub const AV_CODEC_ID_DVAUDIO: AVCodecID = 86022;
pub const AV_CODEC_ID_VORBIS: AVCodecID = 86021;
pub const AV_CODEC_ID_DTS: AVCodecID = 86020;
pub const AV_CODEC_ID_AC3: AVCodecID = 86019;
pub const AV_CODEC_ID_AAC: AVCodecID = 86018;
pub const AV_CODEC_ID_MP3: AVCodecID = 86017;
pub const AV_CODEC_ID_MP2: AVCodecID = 86016;
pub const AV_CODEC_ID_GREMLIN_DPCM: AVCodecID = 83969;
pub const AV_CODEC_ID_SDX2_DPCM: AVCodecID = 83968;
pub const AV_CODEC_ID_SOL_DPCM: AVCodecID = 81923;
pub const AV_CODEC_ID_XAN_DPCM: AVCodecID = 81922;
pub const AV_CODEC_ID_INTERPLAY_DPCM: AVCodecID = 81921;
pub const AV_CODEC_ID_ROQ_DPCM: AVCodecID = 81920;
pub const AV_CODEC_ID_RA_288: AVCodecID = 77825;
pub const AV_CODEC_ID_RA_144: AVCodecID = 77824;
pub const AV_CODEC_ID_AMR_WB: AVCodecID = 73729;
pub const AV_CODEC_ID_AMR_NB: AVCodecID = 73728;
pub const AV_CODEC_ID_ADPCM_AGM: AVCodecID = 71690;
pub const AV_CODEC_ID_ADPCM_MTAF: AVCodecID = 71689;
pub const AV_CODEC_ID_ADPCM_IMA_DAT4: AVCodecID = 71688;
pub const AV_CODEC_ID_ADPCM_AICA: AVCodecID = 71687;
pub const AV_CODEC_ID_ADPCM_PSX: AVCodecID = 71686;
pub const AV_CODEC_ID_ADPCM_THP_LE: AVCodecID = 71685;
pub const AV_CODEC_ID_ADPCM_G726LE: AVCodecID = 71684;
pub const AV_CODEC_ID_ADPCM_IMA_RAD: AVCodecID = 71683;
pub const AV_CODEC_ID_ADPCM_DTK: AVCodecID = 71682;
pub const AV_CODEC_ID_ADPCM_IMA_OKI: AVCodecID = 71681;
pub const AV_CODEC_ID_ADPCM_AFC: AVCodecID = 71680;
pub const AV_CODEC_ID_ADPCM_VIMA: AVCodecID = 69662;
pub const AV_CODEC_ID_ADPCM_IMA_APC: AVCodecID = 69661;
pub const AV_CODEC_ID_ADPCM_G722: AVCodecID = 69660;
pub const AV_CODEC_ID_ADPCM_IMA_ISS: AVCodecID = 69659;
pub const AV_CODEC_ID_ADPCM_EA_MAXIS_XA: AVCodecID = 69658;
pub const AV_CODEC_ID_ADPCM_EA_XAS: AVCodecID = 69657;
pub const AV_CODEC_ID_ADPCM_IMA_EA_EACS: AVCodecID = 69656;
pub const AV_CODEC_ID_ADPCM_IMA_EA_SEAD: AVCodecID = 69655;
pub const AV_CODEC_ID_ADPCM_EA_R2: AVCodecID = 69654;
pub const AV_CODEC_ID_ADPCM_EA_R3: AVCodecID = 69653;
pub const AV_CODEC_ID_ADPCM_EA_R1: AVCodecID = 69652;
pub const AV_CODEC_ID_ADPCM_IMA_AMV: AVCodecID = 69651;
pub const AV_CODEC_ID_ADPCM_THP: AVCodecID = 69650;
pub const AV_CODEC_ID_ADPCM_SBPRO_2: AVCodecID = 69649;
pub const AV_CODEC_ID_ADPCM_SBPRO_3: AVCodecID = 69648;
pub const AV_CODEC_ID_ADPCM_SBPRO_4: AVCodecID = 69647;
pub const AV_CODEC_ID_ADPCM_YAMAHA: AVCodecID = 69646;
pub const AV_CODEC_ID_ADPCM_SWF: AVCodecID = 69645;
pub const AV_CODEC_ID_ADPCM_CT: AVCodecID = 69644;
pub const AV_CODEC_ID_ADPCM_G726: AVCodecID = 69643;
pub const AV_CODEC_ID_ADPCM_EA: AVCodecID = 69642;
pub const AV_CODEC_ID_ADPCM_ADX: AVCodecID = 69641;
pub const AV_CODEC_ID_ADPCM_XA: AVCodecID = 69640;
pub const AV_CODEC_ID_ADPCM_4XM: AVCodecID = 69639;
pub const AV_CODEC_ID_ADPCM_MS: AVCodecID = 69638;
pub const AV_CODEC_ID_ADPCM_IMA_SMJPEG: AVCodecID = 69637;
pub const AV_CODEC_ID_ADPCM_IMA_WS: AVCodecID = 69636;
pub const AV_CODEC_ID_ADPCM_IMA_DK4: AVCodecID = 69635;
pub const AV_CODEC_ID_ADPCM_IMA_DK3: AVCodecID = 69634;
pub const AV_CODEC_ID_ADPCM_IMA_WAV: AVCodecID = 69633;
pub const AV_CODEC_ID_ADPCM_IMA_QT: AVCodecID = 69632;
pub const AV_CODEC_ID_PCM_VIDC: AVCodecID = 67588;
pub const AV_CODEC_ID_PCM_F24LE: AVCodecID = 67587;
pub const AV_CODEC_ID_PCM_F16LE: AVCodecID = 67586;
pub const AV_CODEC_ID_PCM_S64BE: AVCodecID = 67585;
pub const AV_CODEC_ID_PCM_S64LE: AVCodecID = 67584;
pub const AV_CODEC_ID_PCM_S16BE_PLANAR: AVCodecID = 65566;
pub const AV_CODEC_ID_PCM_S32LE_PLANAR: AVCodecID = 65565;
pub const AV_CODEC_ID_PCM_S24LE_PLANAR: AVCodecID = 65564;
pub const AV_CODEC_ID_PCM_S8_PLANAR: AVCodecID = 65563;
pub const AV_CODEC_ID_S302M: AVCodecID = 65562;
pub const AV_CODEC_ID_PCM_LXF: AVCodecID = 65561;
pub const AV_CODEC_ID_PCM_BLURAY: AVCodecID = 65560;
pub const AV_CODEC_ID_PCM_F64LE: AVCodecID = 65559;
pub const AV_CODEC_ID_PCM_F64BE: AVCodecID = 65558;
pub const AV_CODEC_ID_PCM_F32LE: AVCodecID = 65557;
pub const AV_CODEC_ID_PCM_F32BE: AVCodecID = 65556;
pub const AV_CODEC_ID_PCM_DVD: AVCodecID = 65555;
pub const AV_CODEC_ID_PCM_S16LE_PLANAR: AVCodecID = 65554;
pub const AV_CODEC_ID_PCM_ZORK: AVCodecID = 65553;
pub const AV_CODEC_ID_PCM_S24DAUD: AVCodecID = 65552;
pub const AV_CODEC_ID_PCM_U24BE: AVCodecID = 65551;
pub const AV_CODEC_ID_PCM_U24LE: AVCodecID = 65550;
pub const AV_CODEC_ID_PCM_S24BE: AVCodecID = 65549;
pub const AV_CODEC_ID_PCM_S24LE: AVCodecID = 65548;
pub const AV_CODEC_ID_PCM_U32BE: AVCodecID = 65547;
pub const AV_CODEC_ID_PCM_U32LE: AVCodecID = 65546;
pub const AV_CODEC_ID_PCM_S32BE: AVCodecID = 65545;
pub const AV_CODEC_ID_PCM_S32LE: AVCodecID = 65544;
pub const AV_CODEC_ID_PCM_ALAW: AVCodecID = 65543;
pub const AV_CODEC_ID_PCM_MULAW: AVCodecID = 65542;
pub const AV_CODEC_ID_PCM_U8: AVCodecID = 65541;
pub const AV_CODEC_ID_PCM_S8: AVCodecID = 65540;
pub const AV_CODEC_ID_PCM_U16BE: AVCodecID = 65539;
pub const AV_CODEC_ID_PCM_U16LE: AVCodecID = 65538;
pub const AV_CODEC_ID_PCM_S16BE: AVCodecID = 65537;
pub const AV_CODEC_ID_PCM_S16LE: AVCodecID = 65536;
pub const AV_CODEC_ID_FIRST_AUDIO: AVCodecID = 65536;
pub const AV_CODEC_ID_VP4: AVCodecID = 32813;
pub const AV_CODEC_ID_LSCR: AVCodecID = 32812;
pub const AV_CODEC_ID_AGM: AVCodecID = 32811;
pub const AV_CODEC_ID_ARBC: AVCodecID = 32810;
pub const AV_CODEC_ID_HYMT: AVCodecID = 32809;
pub const AV_CODEC_ID_RASC: AVCodecID = 32808;
pub const AV_CODEC_ID_WCMV: AVCodecID = 32807;
pub const AV_CODEC_ID_MWSC: AVCodecID = 32806;
pub const AV_CODEC_ID_PROSUMER: AVCodecID = 32805;
pub const AV_CODEC_ID_IMM4: AVCodecID = 32804;
pub const AV_CODEC_ID_FITS: AVCodecID = 32803;
pub const AV_CODEC_ID_GDV: AVCodecID = 32802;
pub const AV_CODEC_ID_SVG: AVCodecID = 32801;
pub const AV_CODEC_ID_SRGC: AVCodecID = 32800;
pub const AV_CODEC_ID_MSCC: AVCodecID = 32799;
pub const AV_CODEC_ID_BITPACKED: AVCodecID = 32798;
pub const AV_CODEC_ID_AV1: AVCodecID = 32797;
pub const AV_CODEC_ID_XPM: AVCodecID = 32796;
pub const AV_CODEC_ID_CLEARVIDEO: AVCodecID = 32795;
pub const AV_CODEC_ID_SCPR: AVCodecID = 32794;
pub const AV_CODEC_ID_FMVC: AVCodecID = 32793;
pub const AV_CODEC_ID_SPEEDHQ: AVCodecID = 32792;
pub const AV_CODEC_ID_PIXLET: AVCodecID = 32791;
pub const AV_CODEC_ID_PSD: AVCodecID = 32790;
pub const AV_CODEC_ID_YLC: AVCodecID = 32789;
pub const AV_CODEC_ID_SHEERVIDEO: AVCodecID = 32788;
pub const AV_CODEC_ID_MAGICYUV: AVCodecID = 32787;
pub const AV_CODEC_ID_M101: AVCodecID = 32786;
pub const AV_CODEC_ID_TRUEMOTION2RT: AVCodecID = 32785;
pub const AV_CODEC_ID_CFHD: AVCodecID = 32784;
pub const AV_CODEC_ID_DAALA: AVCodecID = 32783;
pub const AV_CODEC_ID_APNG: AVCodecID = 32782;
pub const AV_CODEC_ID_SMVJPEG: AVCodecID = 32781;
pub const AV_CODEC_ID_SNOW: AVCodecID = 32780;
pub const AV_CODEC_ID_XFACE: AVCodecID = 32779;
pub const AV_CODEC_ID_CPIA: AVCodecID = 32778;
pub const AV_CODEC_ID_AVRN: AVCodecID = 32777;
pub const AV_CODEC_ID_YUV4: AVCodecID = 32776;
pub const AV_CODEC_ID_V408: AVCodecID = 32775;
pub const AV_CODEC_ID_V308: AVCodecID = 32774;
pub const AV_CODEC_ID_TARGA_Y216: AVCodecID = 32773;
pub const AV_CODEC_ID_AYUV: AVCodecID = 32772;
pub const AV_CODEC_ID_AVUI: AVCodecID = 32771;
pub const AV_CODEC_ID_012V: AVCodecID = 32770;
pub const AV_CODEC_ID_AVRP: AVCodecID = 32769;
pub const AV_CODEC_ID_Y41P: AVCodecID = 32768;
pub const AV_CODEC_ID_AVS2: AVCodecID = 192;
pub const AV_CODEC_ID_RSCC: AVCodecID = 191;
pub const AV_CODEC_ID_SCREENPRESSO: AVCodecID = 190;
pub const AV_CODEC_ID_DXV: AVCodecID = 189;
pub const AV_CODEC_ID_DDS: AVCodecID = 188;
pub const AV_CODEC_ID_HAP: AVCodecID = 187;
pub const AV_CODEC_ID_HQ_HQA: AVCodecID = 186;
pub const AV_CODEC_ID_TDSC: AVCodecID = 185;
pub const AV_CODEC_ID_HQX: AVCodecID = 184;
pub const AV_CODEC_ID_MVC2: AVCodecID = 183;
pub const AV_CODEC_ID_MVC1: AVCodecID = 182;
pub const AV_CODEC_ID_SGIRLE: AVCodecID = 181;
pub const AV_CODEC_ID_SANM: AVCodecID = 180;
pub const AV_CODEC_ID_VP7: AVCodecID = 179;
pub const AV_CODEC_ID_EXR: AVCodecID = 178;
pub const AV_CODEC_ID_PAF_VIDEO: AVCodecID = 177;
pub const AV_CODEC_ID_BRENDER_PIX: AVCodecID = 176;
pub const AV_CODEC_ID_ALIAS_PIX: AVCodecID = 175;
pub const AV_CODEC_ID_FIC: AVCodecID = 174;
pub const AV_CODEC_ID_HEVC: AVCodecID = 173;
pub const AV_CODEC_ID_HNM4_VIDEO: AVCodecID = 172;
pub const AV_CODEC_ID_WEBP: AVCodecID = 171;
pub const AV_CODEC_ID_G2M: AVCodecID = 170;
pub const AV_CODEC_ID_ESCAPE130: AVCodecID = 169;
pub const AV_CODEC_ID_AIC: AVCodecID = 168;
pub const AV_CODEC_ID_VP9: AVCodecID = 167;
pub const AV_CODEC_ID_MSS2: AVCodecID = 166;
pub const AV_CODEC_ID_CLLC: AVCodecID = 165;
pub const AV_CODEC_ID_MTS2: AVCodecID = 164;
pub const AV_CODEC_ID_TSCC2: AVCodecID = 163;
pub const AV_CODEC_ID_MSA1: AVCodecID = 162;
pub const AV_CODEC_ID_MSS1: AVCodecID = 161;
pub const AV_CODEC_ID_ZEROCODEC: AVCodecID = 160;
pub const AV_CODEC_ID_XBM: AVCodecID = 159;
pub const AV_CODEC_ID_CDXL: AVCodecID = 158;
pub const AV_CODEC_ID_XWD: AVCodecID = 157;
pub const AV_CODEC_ID_V410: AVCodecID = 156;
pub const AV_CODEC_ID_DXTORY: AVCodecID = 155;
pub const AV_CODEC_ID_VBLE: AVCodecID = 154;
pub const AV_CODEC_ID_BMV_VIDEO: AVCodecID = 153;
pub const AV_CODEC_ID_UTVIDEO: AVCodecID = 152;
pub const AV_CODEC_ID_VC1IMAGE: AVCodecID = 151;
pub const AV_CODEC_ID_WMV3IMAGE: AVCodecID = 150;
pub const AV_CODEC_ID_DFA: AVCodecID = 149;
pub const AV_CODEC_ID_JV: AVCodecID = 148;
pub const AV_CODEC_ID_PRORES: AVCodecID = 147;
pub const AV_CODEC_ID_LAGARITH: AVCodecID = 146;
pub const AV_CODEC_ID_MXPEG: AVCodecID = 145;
pub const AV_CODEC_ID_R10K: AVCodecID = 144;
pub const AV_CODEC_ID_A64_MULTI5: AVCodecID = 143;
pub const AV_CODEC_ID_A64_MULTI: AVCodecID = 142;
pub const AV_CODEC_ID_ANSI: AVCodecID = 141;
pub const AV_CODEC_ID_PICTOR: AVCodecID = 140;
pub const AV_CODEC_ID_VP8: AVCodecID = 139;
pub const AV_CODEC_ID_YOP: AVCodecID = 138;
pub const AV_CODEC_ID_KGV1: AVCodecID = 137;
pub const AV_CODEC_ID_IFF_ILBM: AVCodecID = 136;
pub const AV_CODEC_ID_BINKVIDEO: AVCodecID = 135;
pub const AV_CODEC_ID_ANM: AVCodecID = 134;
pub const AV_CODEC_ID_R210: AVCodecID = 133;
pub const AV_CODEC_ID_CDGRAPHICS: AVCodecID = 132;
pub const AV_CODEC_ID_FLASHSV2: AVCodecID = 131;
pub const AV_CODEC_ID_FRWU: AVCodecID = 130;
pub const AV_CODEC_ID_MAD: AVCodecID = 129;
pub const AV_CODEC_ID_DPX: AVCodecID = 128;
pub const AV_CODEC_ID_V210: AVCodecID = 127;
pub const AV_CODEC_ID_TMV: AVCodecID = 126;
pub const AV_CODEC_ID_V210X: AVCodecID = 125;
pub const AV_CODEC_ID_AURA2: AVCodecID = 124;
pub const AV_CODEC_ID_AURA: AVCodecID = 123;
pub const AV_CODEC_ID_TQI: AVCodecID = 122;
pub const AV_CODEC_ID_TGQ: AVCodecID = 121;
pub const AV_CODEC_ID_TGV: AVCodecID = 120;
pub const AV_CODEC_ID_MOTIONPIXELS: AVCodecID = 119;
pub const AV_CODEC_ID_CMV: AVCodecID = 118;
pub const AV_CODEC_ID_BFI: AVCodecID = 117;
pub const AV_CODEC_ID_DIRAC: AVCodecID = 116;
pub const AV_CODEC_ID_ESCAPE124: AVCodecID = 115;
pub const AV_CODEC_ID_RL2: AVCodecID = 114;
pub const AV_CODEC_ID_MIMIC: AVCodecID = 113;
pub const AV_CODEC_ID_INDEO5: AVCodecID = 112;
pub const AV_CODEC_ID_INDEO4: AVCodecID = 111;
pub const AV_CODEC_ID_SUNRAST: AVCodecID = 110;
pub const AV_CODEC_ID_PCX: AVCodecID = 109;
pub const AV_CODEC_ID_VB: AVCodecID = 108;
pub const AV_CODEC_ID_AMV: AVCodecID = 107;
pub const AV_CODEC_ID_VP6A: AVCodecID = 106;
pub const AV_CODEC_ID_TXD: AVCodecID = 105;
pub const AV_CODEC_ID_PTX: AVCodecID = 104;
pub const AV_CODEC_ID_BETHSOFTVID: AVCodecID = 103;
pub const AV_CODEC_ID_C93: AVCodecID = 102;
pub const AV_CODEC_ID_SGI: AVCodecID = 101;
pub const AV_CODEC_ID_THP: AVCodecID = 100;
pub const AV_CODEC_ID_DNXHD: AVCodecID = 99;
pub const AV_CODEC_ID_DXA: AVCodecID = 98;
pub const AV_CODEC_ID_GIF: AVCodecID = 97;
pub const AV_CODEC_ID_TIFF: AVCodecID = 96;
pub const AV_CODEC_ID_TIERTEXSEQVIDEO: AVCodecID = 95;
pub const AV_CODEC_ID_DSICINVIDEO: AVCodecID = 94;
pub const AV_CODEC_ID_TARGA: AVCodecID = 93;
pub const AV_CODEC_ID_VP6F: AVCodecID = 92;
pub const AV_CODEC_ID_VP6: AVCodecID = 91;
pub const AV_CODEC_ID_VP5: AVCodecID = 90;
pub const AV_CODEC_ID_VMNC: AVCodecID = 89;
pub const AV_CODEC_ID_JPEG2000: AVCodecID = 88;
pub const AV_CODEC_ID_CAVS: AVCodecID = 87;
pub const AV_CODEC_ID_FLASHSV: AVCodecID = 86;
pub const AV_CODEC_ID_KMVC: AVCodecID = 85;
pub const AV_CODEC_ID_NUV: AVCodecID = 84;
pub const AV_CODEC_ID_SMACKVIDEO: AVCodecID = 83;
pub const AV_CODEC_ID_AVS: AVCodecID = 82;
pub const AV_CODEC_ID_ZMBV: AVCodecID = 81;
pub const AV_CODEC_ID_MMVIDEO: AVCodecID = 80;
pub const AV_CODEC_ID_CSCD: AVCodecID = 79;
pub const AV_CODEC_ID_BMP: AVCodecID = 78;
pub const AV_CODEC_ID_TRUEMOTION2: AVCodecID = 77;
pub const AV_CODEC_ID_FRAPS: AVCodecID = 76;
pub const AV_CODEC_ID_INDEO2: AVCodecID = 75;
pub const AV_CODEC_ID_AASC: AVCodecID = 74;
pub const AV_CODEC_ID_WNV1: AVCodecID = 73;
pub const AV_CODEC_ID_LOCO: AVCodecID = 72;
pub const AV_CODEC_ID_WMV3: AVCodecID = 71;
pub const AV_CODEC_ID_VC1: AVCodecID = 70;
pub const AV_CODEC_ID_RV40: AVCodecID = 69;
pub const AV_CODEC_ID_RV30: AVCodecID = 68;
pub const AV_CODEC_ID_FFVHUFF: AVCodecID = 67;
pub const AV_CODEC_ID_PAM: AVCodecID = 66;
pub const AV_CODEC_ID_PGMYUV: AVCodecID = 65;
pub const AV_CODEC_ID_PGM: AVCodecID = 64;
pub const AV_CODEC_ID_PBM: AVCodecID = 63;
pub const AV_CODEC_ID_PPM: AVCodecID = 62;
pub const AV_CODEC_ID_PNG: AVCodecID = 61;
pub const AV_CODEC_ID_QPEG: AVCodecID = 60;
pub const AV_CODEC_ID_VIXL: AVCodecID = 59;
pub const AV_CODEC_ID_QDRAW: AVCodecID = 58;
pub const AV_CODEC_ID_ULTI: AVCodecID = 57;
pub const AV_CODEC_ID_TSCC: AVCodecID = 56;
pub const AV_CODEC_ID_QTRLE: AVCodecID = 55;
pub const AV_CODEC_ID_ZLIB: AVCodecID = 54;
pub const AV_CODEC_ID_MSZH: AVCodecID = 53;
pub const AV_CODEC_ID_VMDVIDEO: AVCodecID = 52;
pub const AV_CODEC_ID_TRUEMOTION1: AVCodecID = 51;
pub const AV_CODEC_ID_FLIC: AVCodecID = 50;
pub const AV_CODEC_ID_SMC: AVCodecID = 49;
pub const AV_CODEC_ID_8BPS: AVCodecID = 48;
pub const AV_CODEC_ID_IDCIN: AVCodecID = 47;
pub const AV_CODEC_ID_MSVIDEO1: AVCodecID = 46;
pub const AV_CODEC_ID_MSRLE: AVCodecID = 45;
pub const AV_CODEC_ID_WS_VQA: AVCodecID = 44;
pub const AV_CODEC_ID_CINEPAK: AVCodecID = 43;
pub const AV_CODEC_ID_RPZA: AVCodecID = 42;
pub const AV_CODEC_ID_XAN_WC4: AVCodecID = 41;
pub const AV_CODEC_ID_XAN_WC3: AVCodecID = 40;
pub const AV_CODEC_ID_INTERPLAY_VIDEO: AVCodecID = 39;
pub const AV_CODEC_ID_ROQ: AVCodecID = 38;
pub const AV_CODEC_ID_MDEC: AVCodecID = 37;
pub const AV_CODEC_ID_CLJR: AVCodecID = 36;
pub const AV_CODEC_ID_VCR1: AVCodecID = 35;
pub const AV_CODEC_ID_4XM: AVCodecID = 34;
pub const AV_CODEC_ID_FFV1: AVCodecID = 33;
pub const AV_CODEC_ID_ASV2: AVCodecID = 32;
pub const AV_CODEC_ID_ASV1: AVCodecID = 31;
pub const AV_CODEC_ID_THEORA: AVCodecID = 30;
pub const AV_CODEC_ID_VP3: AVCodecID = 29;
pub const AV_CODEC_ID_INDEO3: AVCodecID = 28;
pub const AV_CODEC_ID_H264: AVCodecID = 27;
pub const AV_CODEC_ID_CYUV: AVCodecID = 26;
pub const AV_CODEC_ID_HUFFYUV: AVCodecID = 25;
pub const AV_CODEC_ID_DVVIDEO: AVCodecID = 24;
pub const AV_CODEC_ID_SVQ3: AVCodecID = 23;
pub const AV_CODEC_ID_SVQ1: AVCodecID = 22;
pub const AV_CODEC_ID_FLV1: AVCodecID = 21;
pub const AV_CODEC_ID_H263I: AVCodecID = 20;
pub const AV_CODEC_ID_H263P: AVCodecID = 19;
pub const AV_CODEC_ID_WMV2: AVCodecID = 18;
pub const AV_CODEC_ID_WMV1: AVCodecID = 17;
pub const AV_CODEC_ID_MSMPEG4V3: AVCodecID = 16;
pub const AV_CODEC_ID_MSMPEG4V2: AVCodecID = 15;
pub const AV_CODEC_ID_MSMPEG4V1: AVCodecID = 14;
pub const AV_CODEC_ID_RAWVIDEO: AVCodecID = 13;
pub const AV_CODEC_ID_MPEG4: AVCodecID = 12;
pub const AV_CODEC_ID_JPEGLS: AVCodecID = 11;
pub const AV_CODEC_ID_SP5X: AVCodecID = 10;
pub const AV_CODEC_ID_LJPEG: AVCodecID = 9;
pub const AV_CODEC_ID_MJPEGB: AVCodecID = 8;
pub const AV_CODEC_ID_MJPEG: AVCodecID = 7;
pub const AV_CODEC_ID_RV20: AVCodecID = 6;
pub const AV_CODEC_ID_RV10: AVCodecID = 5;
pub const AV_CODEC_ID_H263: AVCodecID = 4;
pub const AV_CODEC_ID_H261: AVCodecID = 3;
pub const AV_CODEC_ID_MPEG2VIDEO: AVCodecID = 2;
pub const AV_CODEC_ID_MPEG1VIDEO: AVCodecID = 1;
pub const AV_CODEC_ID_NONE: AVCodecID = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVProfile {
    pub profile: libc::c_int,
    pub name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_0: AVMediaType,
    pub name: *const libc::c_char,
    pub long_name: *const libc::c_char,
    pub props: libc::c_int,
    pub mime_types: *const *const libc::c_char,
    pub profiles: *const AVProfile,
}
pub type AVDiscard = libc::c_int;
pub const AVDISCARD_ALL: AVDiscard = 48;
pub const AVDISCARD_NONKEY: AVDiscard = 32;
pub const AVDISCARD_NONINTRA: AVDiscard = 24;
pub const AVDISCARD_BIDIR: AVDiscard = 16;
pub const AVDISCARD_NONREF: AVDiscard = 8;
pub const AVDISCARD_DEFAULT: AVDiscard = 0;
pub const AVDISCARD_NONE: AVDiscard = -16;
pub type AVAudioServiceType = libc::c_uint;
pub const AV_AUDIO_SERVICE_TYPE_NB: AVAudioServiceType = 9;
pub const AV_AUDIO_SERVICE_TYPE_KARAOKE: AVAudioServiceType = 8;
pub const AV_AUDIO_SERVICE_TYPE_VOICE_OVER: AVAudioServiceType = 7;
pub const AV_AUDIO_SERVICE_TYPE_EMERGENCY: AVAudioServiceType = 6;
pub const AV_AUDIO_SERVICE_TYPE_COMMENTARY: AVAudioServiceType = 5;
pub const AV_AUDIO_SERVICE_TYPE_DIALOGUE: AVAudioServiceType = 4;
pub const AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: AVAudioServiceType = 3;
pub const AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: AVAudioServiceType = 2;
pub const AV_AUDIO_SERVICE_TYPE_EFFECTS: AVAudioServiceType = 1;
pub const AV_AUDIO_SERVICE_TYPE_MAIN: AVAudioServiceType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RcOverride {
    pub start_frame: libc::c_int,
    pub end_frame: libc::c_int,
    pub qscale: libc::c_int,
    pub quality_factor: libc::c_float,
}
pub type AVPacketSideDataType = libc::c_uint;
pub const AV_PKT_DATA_NB: AVPacketSideDataType = 27;
pub const AV_PKT_DATA_AFD: AVPacketSideDataType = 26;
pub const AV_PKT_DATA_ENCRYPTION_INFO: AVPacketSideDataType = 25;
pub const AV_PKT_DATA_ENCRYPTION_INIT_INFO: AVPacketSideDataType = 24;
pub const AV_PKT_DATA_A53_CC: AVPacketSideDataType = 23;
pub const AV_PKT_DATA_CONTENT_LIGHT_LEVEL: AVPacketSideDataType = 22;
pub const AV_PKT_DATA_SPHERICAL: AVPacketSideDataType = 21;
pub const AV_PKT_DATA_MASTERING_DISPLAY_METADATA: AVPacketSideDataType = 20;
pub const AV_PKT_DATA_MPEGTS_STREAM_ID: AVPacketSideDataType = 19;
pub const AV_PKT_DATA_METADATA_UPDATE: AVPacketSideDataType = 18;
pub const AV_PKT_DATA_WEBVTT_SETTINGS: AVPacketSideDataType = 17;
pub const AV_PKT_DATA_WEBVTT_IDENTIFIER: AVPacketSideDataType = 16;
pub const AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: AVPacketSideDataType = 15;
pub const AV_PKT_DATA_SUBTITLE_POSITION: AVPacketSideDataType = 14;
pub const AV_PKT_DATA_STRINGS_METADATA: AVPacketSideDataType = 13;
pub const AV_PKT_DATA_JP_DUALMONO: AVPacketSideDataType = 12;
pub const AV_PKT_DATA_SKIP_SAMPLES: AVPacketSideDataType = 11;
pub const AV_PKT_DATA_CPB_PROPERTIES: AVPacketSideDataType = 10;
pub const AV_PKT_DATA_FALLBACK_TRACK: AVPacketSideDataType = 9;
pub const AV_PKT_DATA_QUALITY_STATS: AVPacketSideDataType = 8;
pub const AV_PKT_DATA_AUDIO_SERVICE_TYPE: AVPacketSideDataType = 7;
pub const AV_PKT_DATA_STEREO3D: AVPacketSideDataType = 6;
pub const AV_PKT_DATA_DISPLAYMATRIX: AVPacketSideDataType = 5;
pub const AV_PKT_DATA_REPLAYGAIN: AVPacketSideDataType = 4;
pub const AV_PKT_DATA_H263_MB_INFO: AVPacketSideDataType = 3;
pub const AV_PKT_DATA_PARAM_CHANGE: AVPacketSideDataType = 2;
pub const AV_PKT_DATA_NEW_EXTRADATA: AVPacketSideDataType = 1;
pub const AV_PKT_DATA_PALETTE: AVPacketSideDataType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVPacketSideData {
    pub data: *mut uint8_t,
    pub size: libc::c_int,
    pub type_0: AVPacketSideDataType,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVPacket {
    pub buf: *mut AVBufferRef,
    pub pts: int64_t,
    pub dts: int64_t,
    pub data: *mut uint8_t,
    pub size: libc::c_int,
    pub stream_index: libc::c_int,
    pub flags: libc::c_int,
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: libc::c_int,
    pub duration: int64_t,
    pub pos: int64_t,
    pub convergence_duration: int64_t,
}
pub type AVFieldOrder = libc::c_uint;
pub const AV_FIELD_BT: AVFieldOrder = 5;
pub const AV_FIELD_TB: AVFieldOrder = 4;
pub const AV_FIELD_BB: AVFieldOrder = 3;
pub const AV_FIELD_TT: AVFieldOrder = 2;
pub const AV_FIELD_PROGRESSIVE: AVFieldOrder = 1;
pub const AV_FIELD_UNKNOWN: AVFieldOrder = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVCodec {
    pub name: *const libc::c_char,
    pub long_name: *const libc::c_char,
    pub type_0: AVMediaType,
    pub id: AVCodecID,
    pub capabilities: libc::c_int,
    pub supported_framerates: *const AVRational,
    pub pix_fmts: *const AVPixelFormat,
    pub supported_samplerates: *const libc::c_int,
    pub sample_fmts: *const AVSampleFormat,
    pub channel_layouts: *const uint64_t,
    pub max_lowres: uint8_t,
    pub priv_class: *const AVClass,
    pub profiles: *const AVProfile,
    pub wrapper_name: *const libc::c_char,
    pub priv_data_size: libc::c_int,
    pub next: *mut AVCodec,
    pub init_thread_copy: Option::<
        unsafe extern "C" fn(*mut AVCodecContext) -> libc::c_int,
    >,
    pub update_thread_context: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *const AVCodecContext) -> libc::c_int,
    >,
    pub defaults: *const AVCodecDefault,
    pub init_static_data: Option::<unsafe extern "C" fn(*mut AVCodec) -> ()>,
    pub init: Option::<unsafe extern "C" fn(*mut AVCodecContext) -> libc::c_int>,
    pub encode_sub: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *mut uint8_t,
            libc::c_int,
            *const AVSubtitle,
        ) -> libc::c_int,
    >,
    pub encode2: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *mut AVPacket,
            *const AVFrame,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub decode: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *mut libc::c_void,
            *mut libc::c_int,
            *mut AVPacket,
        ) -> libc::c_int,
    >,
    pub close: Option::<unsafe extern "C" fn(*mut AVCodecContext) -> libc::c_int>,
    pub send_frame: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *const AVFrame) -> libc::c_int,
    >,
    pub receive_packet: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *mut AVPacket) -> libc::c_int,
    >,
    pub receive_frame: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *mut AVFrame) -> libc::c_int,
    >,
    pub flush: Option::<unsafe extern "C" fn(*mut AVCodecContext) -> ()>,
    pub caps_internal: libc::c_int,
    pub bsfs: *const libc::c_char,
    pub hw_configs: *mut *const AVCodecHWConfigInternal,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVCodecContext {
    pub av_class: *const AVClass,
    pub log_level_offset: libc::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    pub codec_tag: libc::c_uint,
    pub priv_data: *mut libc::c_void,
    pub internal: *mut AVCodecInternal,
    pub opaque: *mut libc::c_void,
    pub bit_rate: int64_t,
    pub bit_rate_tolerance: libc::c_int,
    pub global_quality: libc::c_int,
    pub compression_level: libc::c_int,
    pub flags: libc::c_int,
    pub flags2: libc::c_int,
    pub extradata: *mut uint8_t,
    pub extradata_size: libc::c_int,
    pub time_base: AVRational,
    pub ticks_per_frame: libc::c_int,
    pub delay: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub coded_width: libc::c_int,
    pub coded_height: libc::c_int,
    pub gop_size: libc::c_int,
    pub pix_fmt: AVPixelFormat,
    pub draw_horiz_band: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *const AVFrame,
            *mut libc::c_int,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub get_format: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *const AVPixelFormat) -> AVPixelFormat,
    >,
    pub max_b_frames: libc::c_int,
    pub b_quant_factor: libc::c_float,
    pub b_frame_strategy: libc::c_int,
    pub b_quant_offset: libc::c_float,
    pub has_b_frames: libc::c_int,
    pub mpeg_quant: libc::c_int,
    pub i_quant_factor: libc::c_float,
    pub i_quant_offset: libc::c_float,
    pub lumi_masking: libc::c_float,
    pub temporal_cplx_masking: libc::c_float,
    pub spatial_cplx_masking: libc::c_float,
    pub p_masking: libc::c_float,
    pub dark_masking: libc::c_float,
    pub slice_count: libc::c_int,
    pub prediction_method: libc::c_int,
    pub slice_offset: *mut libc::c_int,
    pub sample_aspect_ratio: AVRational,
    pub me_cmp: libc::c_int,
    pub me_sub_cmp: libc::c_int,
    pub mb_cmp: libc::c_int,
    pub ildct_cmp: libc::c_int,
    pub dia_size: libc::c_int,
    pub last_predictor_count: libc::c_int,
    pub pre_me: libc::c_int,
    pub me_pre_cmp: libc::c_int,
    pub pre_dia_size: libc::c_int,
    pub me_subpel_quality: libc::c_int,
    pub me_range: libc::c_int,
    pub slice_flags: libc::c_int,
    pub mb_decision: libc::c_int,
    pub intra_matrix: *mut uint16_t,
    pub inter_matrix: *mut uint16_t,
    pub scenechange_threshold: libc::c_int,
    pub noise_reduction: libc::c_int,
    pub intra_dc_precision: libc::c_int,
    pub skip_top: libc::c_int,
    pub skip_bottom: libc::c_int,
    pub mb_lmin: libc::c_int,
    pub mb_lmax: libc::c_int,
    pub me_penalty_compensation: libc::c_int,
    pub bidir_refine: libc::c_int,
    pub brd_scale: libc::c_int,
    pub keyint_min: libc::c_int,
    pub refs: libc::c_int,
    pub chromaoffset: libc::c_int,
    pub mv0_threshold: libc::c_int,
    pub b_sensitivity: libc::c_int,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub color_range: AVColorRange,
    pub chroma_sample_location: AVChromaLocation,
    pub slices: libc::c_int,
    pub field_order: AVFieldOrder,
    pub sample_rate: libc::c_int,
    pub channels: libc::c_int,
    pub sample_fmt: AVSampleFormat,
    pub frame_size: libc::c_int,
    pub frame_number: libc::c_int,
    pub block_align: libc::c_int,
    pub cutoff: libc::c_int,
    pub channel_layout: uint64_t,
    pub request_channel_layout: uint64_t,
    pub audio_service_type: AVAudioServiceType,
    pub request_sample_fmt: AVSampleFormat,
    pub get_buffer2: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *mut AVFrame,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub refcounted_frames: libc::c_int,
    pub qcompress: libc::c_float,
    pub qblur: libc::c_float,
    pub qmin: libc::c_int,
    pub qmax: libc::c_int,
    pub max_qdiff: libc::c_int,
    pub rc_buffer_size: libc::c_int,
    pub rc_override_count: libc::c_int,
    pub rc_override: *mut RcOverride,
    pub rc_max_rate: int64_t,
    pub rc_min_rate: int64_t,
    pub rc_max_available_vbv_use: libc::c_float,
    pub rc_min_vbv_overflow_use: libc::c_float,
    pub rc_initial_buffer_occupancy: libc::c_int,
    pub coder_type: libc::c_int,
    pub context_model: libc::c_int,
    pub frame_skip_threshold: libc::c_int,
    pub frame_skip_factor: libc::c_int,
    pub frame_skip_exp: libc::c_int,
    pub frame_skip_cmp: libc::c_int,
    pub trellis: libc::c_int,
    pub min_prediction_order: libc::c_int,
    pub max_prediction_order: libc::c_int,
    pub timecode_frame_start: int64_t,
    pub rtp_callback: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *mut libc::c_void,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub rtp_payload_size: libc::c_int,
    pub mv_bits: libc::c_int,
    pub header_bits: libc::c_int,
    pub i_tex_bits: libc::c_int,
    pub p_tex_bits: libc::c_int,
    pub i_count: libc::c_int,
    pub p_count: libc::c_int,
    pub skip_count: libc::c_int,
    pub misc_bits: libc::c_int,
    pub frame_bits: libc::c_int,
    pub stats_out: *mut libc::c_char,
    pub stats_in: *mut libc::c_char,
    pub workaround_bugs: libc::c_int,
    pub strict_std_compliance: libc::c_int,
    pub error_concealment: libc::c_int,
    pub debug: libc::c_int,
    pub err_recognition: libc::c_int,
    pub reordered_opaque: int64_t,
    pub hwaccel: *const AVHWAccel,
    pub hwaccel_context: *mut libc::c_void,
    pub error: [uint64_t; 8],
    pub dct_algo: libc::c_int,
    pub idct_algo: libc::c_int,
    pub bits_per_coded_sample: libc::c_int,
    pub bits_per_raw_sample: libc::c_int,
    pub lowres: libc::c_int,
    pub coded_frame: *mut AVFrame,
    pub thread_count: libc::c_int,
    pub thread_type: libc::c_int,
    pub active_thread_type: libc::c_int,
    pub thread_safe_callbacks: libc::c_int,
    pub execute: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            Option::<
                unsafe extern "C" fn(
                    *mut AVCodecContext,
                    *mut libc::c_void,
                ) -> libc::c_int,
            >,
            *mut libc::c_void,
            *mut libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub execute2: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            Option::<
                unsafe extern "C" fn(
                    *mut AVCodecContext,
                    *mut libc::c_void,
                    libc::c_int,
                    libc::c_int,
                ) -> libc::c_int,
            >,
            *mut libc::c_void,
            *mut libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub nsse_weight: libc::c_int,
    pub profile: libc::c_int,
    pub level: libc::c_int,
    pub skip_loop_filter: AVDiscard,
    pub skip_idct: AVDiscard,
    pub skip_frame: AVDiscard,
    pub subtitle_header: *mut uint8_t,
    pub subtitle_header_size: libc::c_int,
    pub vbv_delay: uint64_t,
    pub side_data_only_packets: libc::c_int,
    pub initial_padding: libc::c_int,
    pub framerate: AVRational,
    pub sw_pix_fmt: AVPixelFormat,
    pub pkt_timebase: AVRational,
    pub codec_descriptor: *const AVCodecDescriptor,
    pub pts_correction_num_faulty_pts: int64_t,
    pub pts_correction_num_faulty_dts: int64_t,
    pub pts_correction_last_pts: int64_t,
    pub pts_correction_last_dts: int64_t,
    pub sub_charenc: *mut libc::c_char,
    pub sub_charenc_mode: libc::c_int,
    pub skip_alpha: libc::c_int,
    pub seek_preroll: libc::c_int,
    pub debug_mv: libc::c_int,
    pub chroma_intra_matrix: *mut uint16_t,
    pub dump_separator: *mut uint8_t,
    pub codec_whitelist: *mut libc::c_char,
    pub properties: libc::c_uint,
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: libc::c_int,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub sub_text_format: libc::c_int,
    pub trailing_padding: libc::c_int,
    pub max_pixels: int64_t,
    pub hw_device_ctx: *mut AVBufferRef,
    pub hwaccel_flags: libc::c_int,
    pub apply_cropping: libc::c_int,
    pub extra_hw_frames: libc::c_int,
    pub discard_damaged_percentage: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVHWAccel {
    pub name: *const libc::c_char,
    pub type_0: AVMediaType,
    pub id: AVCodecID,
    pub pix_fmt: AVPixelFormat,
    pub capabilities: libc::c_int,
    pub alloc_frame: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *mut AVFrame) -> libc::c_int,
    >,
    pub start_frame: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *const uint8_t,
            uint32_t,
        ) -> libc::c_int,
    >,
    pub decode_params: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            libc::c_int,
            *const uint8_t,
            uint32_t,
        ) -> libc::c_int,
    >,
    pub decode_slice: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *const uint8_t,
            uint32_t,
        ) -> libc::c_int,
    >,
    pub end_frame: Option::<unsafe extern "C" fn(*mut AVCodecContext) -> libc::c_int>,
    pub frame_priv_data_size: libc::c_int,
    pub decode_mb: Option::<unsafe extern "C" fn(*mut MpegEncContext) -> ()>,
    pub init: Option::<unsafe extern "C" fn(*mut AVCodecContext) -> libc::c_int>,
    pub uninit: Option::<unsafe extern "C" fn(*mut AVCodecContext) -> libc::c_int>,
    pub priv_data_size: libc::c_int,
    pub caps_internal: libc::c_int,
    pub frame_params: Option::<
        unsafe extern "C" fn(*mut AVCodecContext, *mut AVBufferRef) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVSubtitle {
    pub format: uint16_t,
    pub start_display_time: uint32_t,
    pub end_display_time: uint32_t,
    pub num_rects: libc::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    pub pts: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVSubtitleRect {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub w: libc::c_int,
    pub h: libc::c_int,
    pub nb_colors: libc::c_int,
    pub pict: AVPicture,
    pub data: [*mut uint8_t; 4],
    pub linesize: [libc::c_int; 4],
    pub type_0: AVSubtitleType,
    pub text: *mut libc::c_char,
    pub ass: *mut libc::c_char,
    pub flags: libc::c_int,
}
pub type AVSubtitleType = libc::c_uint;
pub const SUBTITLE_ASS: AVSubtitleType = 3;
pub const SUBTITLE_TEXT: AVSubtitleType = 2;
pub const SUBTITLE_BITMAP: AVSubtitleType = 1;
pub const SUBTITLE_NONE: AVSubtitleType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVPicture {
    pub data: [*mut uint8_t; 8],
    pub linesize: [libc::c_int; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVCodecParameters {
    pub codec_type: AVMediaType,
    pub codec_id: AVCodecID,
    pub codec_tag: uint32_t,
    pub extradata: *mut uint8_t,
    pub extradata_size: libc::c_int,
    pub format: libc::c_int,
    pub bit_rate: int64_t,
    pub bits_per_coded_sample: libc::c_int,
    pub bits_per_raw_sample: libc::c_int,
    pub profile: libc::c_int,
    pub level: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub sample_aspect_ratio: AVRational,
    pub field_order: AVFieldOrder,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub video_delay: libc::c_int,
    pub channel_layout: uint64_t,
    pub channels: libc::c_int,
    pub sample_rate: libc::c_int,
    pub block_align: libc::c_int,
    pub frame_size: libc::c_int,
    pub initial_padding: libc::c_int,
    pub trailing_padding: libc::c_int,
    pub seek_preroll: libc::c_int,
}
pub type AVPictureStructure = libc::c_uint;
pub const AV_PICTURE_STRUCTURE_FRAME: AVPictureStructure = 3;
pub const AV_PICTURE_STRUCTURE_BOTTOM_FIELD: AVPictureStructure = 2;
pub const AV_PICTURE_STRUCTURE_TOP_FIELD: AVPictureStructure = 1;
pub const AV_PICTURE_STRUCTURE_UNKNOWN: AVPictureStructure = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVCodecParser {
    pub codec_ids: [libc::c_int; 5],
    pub priv_data_size: libc::c_int,
    pub parser_init: Option::<
        unsafe extern "C" fn(*mut AVCodecParserContext) -> libc::c_int,
    >,
    pub parser_parse: Option::<
        unsafe extern "C" fn(
            *mut AVCodecParserContext,
            *mut AVCodecContext,
            *mut *const uint8_t,
            *mut libc::c_int,
            *const uint8_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub parser_close: Option::<unsafe extern "C" fn(*mut AVCodecParserContext) -> ()>,
    pub split: Option::<
        unsafe extern "C" fn(
            *mut AVCodecContext,
            *const uint8_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub next: *mut AVCodecParser,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVCodecParserContext {
    pub priv_data: *mut libc::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: int64_t,
    pub cur_offset: int64_t,
    pub next_frame_offset: int64_t,
    pub pict_type: libc::c_int,
    pub repeat_pict: libc::c_int,
    pub pts: int64_t,
    pub dts: int64_t,
    pub last_pts: int64_t,
    pub last_dts: int64_t,
    pub fetch_timestamp: libc::c_int,
    pub cur_frame_start_index: libc::c_int,
    pub cur_frame_offset: [int64_t; 4],
    pub cur_frame_pts: [int64_t; 4],
    pub cur_frame_dts: [int64_t; 4],
    pub flags: libc::c_int,
    pub offset: int64_t,
    pub cur_frame_end: [int64_t; 4],
    pub key_frame: libc::c_int,
    pub convergence_duration: int64_t,
    pub dts_sync_point: libc::c_int,
    pub dts_ref_dts_delta: libc::c_int,
    pub pts_dts_delta: libc::c_int,
    pub cur_frame_pos: [int64_t; 4],
    pub pos: int64_t,
    pub last_pos: int64_t,
    pub duration: libc::c_int,
    pub field_order: AVFieldOrder,
    pub picture_structure: AVPictureStructure,
    pub output_picture_number: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub coded_width: libc::c_int,
    pub coded_height: libc::c_int,
    pub format: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVIOInterruptCB {
    pub callback: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub opaque: *mut libc::c_void,
}
pub type AVIODataMarkerType = libc::c_uint;
pub const AVIO_DATA_MARKER_FLUSH_POINT: AVIODataMarkerType = 5;
pub const AVIO_DATA_MARKER_TRAILER: AVIODataMarkerType = 4;
pub const AVIO_DATA_MARKER_UNKNOWN: AVIODataMarkerType = 3;
pub const AVIO_DATA_MARKER_BOUNDARY_POINT: AVIODataMarkerType = 2;
pub const AVIO_DATA_MARKER_SYNC_POINT: AVIODataMarkerType = 1;
pub const AVIO_DATA_MARKER_HEADER: AVIODataMarkerType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVIOContext {
    pub av_class: *const AVClass,
    pub buffer: *mut libc::c_uchar,
    pub buffer_size: libc::c_int,
    pub buf_ptr: *mut libc::c_uchar,
    pub buf_end: *mut libc::c_uchar,
    pub opaque: *mut libc::c_void,
    pub read_packet: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut uint8_t, libc::c_int) -> libc::c_int,
    >,
    pub write_packet: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut uint8_t, libc::c_int) -> libc::c_int,
    >,
    pub seek: Option::<
        unsafe extern "C" fn(*mut libc::c_void, int64_t, libc::c_int) -> int64_t,
    >,
    pub pos: int64_t,
    pub eof_reached: libc::c_int,
    pub write_flag: libc::c_int,
    pub max_packet_size: libc::c_int,
    pub checksum: libc::c_ulong,
    pub checksum_ptr: *mut libc::c_uchar,
    pub update_checksum: Option::<
        unsafe extern "C" fn(
            libc::c_ulong,
            *const uint8_t,
            libc::c_uint,
        ) -> libc::c_ulong,
    >,
    pub error: libc::c_int,
    pub read_pause: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> libc::c_int,
    >,
    pub read_seek: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            libc::c_int,
            int64_t,
            libc::c_int,
        ) -> int64_t,
    >,
    pub seekable: libc::c_int,
    pub maxsize: int64_t,
    pub direct: libc::c_int,
    pub bytes_read: int64_t,
    pub seek_count: libc::c_int,
    pub writeout_count: libc::c_int,
    pub orig_buffer_size: libc::c_int,
    pub short_seek_threshold: libc::c_int,
    pub protocol_whitelist: *const libc::c_char,
    pub protocol_blacklist: *const libc::c_char,
    pub write_data_type: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *mut uint8_t,
            libc::c_int,
            AVIODataMarkerType,
            int64_t,
        ) -> libc::c_int,
    >,
    pub ignore_boundary_point: libc::c_int,
    pub current_type: AVIODataMarkerType,
    pub last_time: int64_t,
    pub short_seek_get: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub written: int64_t,
    pub buf_ptr_max: *mut libc::c_uchar,
    pub min_packet_size: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFormatContext {
    pub av_class: *const AVClass,
    pub iformat: *mut AVInputFormat,
    pub oformat: *mut AVOutputFormat,
    pub priv_data: *mut libc::c_void,
    pub pb: *mut AVIOContext,
    pub ctx_flags: libc::c_int,
    pub nb_streams: libc::c_uint,
    pub streams: *mut *mut AVStream,
    pub filename: [libc::c_char; 1024],
    pub url: *mut libc::c_char,
    pub start_time: int64_t,
    pub duration: int64_t,
    pub bit_rate: int64_t,
    pub packet_size: libc::c_uint,
    pub max_delay: libc::c_int,
    pub flags: libc::c_int,
    pub probesize: int64_t,
    pub max_analyze_duration: int64_t,
    pub key: *const uint8_t,
    pub keylen: libc::c_int,
    pub nb_programs: libc::c_uint,
    pub programs: *mut *mut AVProgram,
    pub video_codec_id: AVCodecID,
    pub audio_codec_id: AVCodecID,
    pub subtitle_codec_id: AVCodecID,
    pub max_index_size: libc::c_uint,
    pub max_picture_buffer: libc::c_uint,
    pub nb_chapters: libc::c_uint,
    pub chapters: *mut *mut AVChapter,
    pub metadata: *mut AVDictionary,
    pub start_time_realtime: int64_t,
    pub fps_probe_size: libc::c_int,
    pub error_recognition: libc::c_int,
    pub interrupt_callback: AVIOInterruptCB,
    pub debug: libc::c_int,
    pub max_interleave_delta: int64_t,
    pub strict_std_compliance: libc::c_int,
    pub event_flags: libc::c_int,
    pub max_ts_probe: libc::c_int,
    pub avoid_negative_ts: libc::c_int,
    pub ts_id: libc::c_int,
    pub audio_preload: libc::c_int,
    pub max_chunk_duration: libc::c_int,
    pub max_chunk_size: libc::c_int,
    pub use_wallclock_as_timestamps: libc::c_int,
    pub avio_flags: libc::c_int,
    pub duration_estimation_method: AVDurationEstimationMethod,
    pub skip_initial_bytes: int64_t,
    pub correct_ts_overflow: libc::c_uint,
    pub seek2any: libc::c_int,
    pub flush_packets: libc::c_int,
    pub probe_score: libc::c_int,
    pub format_probesize: libc::c_int,
    pub codec_whitelist: *mut libc::c_char,
    pub format_whitelist: *mut libc::c_char,
    pub internal: *mut AVFormatInternal,
    pub io_repositioned: libc::c_int,
    pub video_codec: *mut AVCodec,
    pub audio_codec: *mut AVCodec,
    pub subtitle_codec: *mut AVCodec,
    pub data_codec: *mut AVCodec,
    pub metadata_header_padding: libc::c_int,
    pub opaque: *mut libc::c_void,
    pub control_message_cb: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            *mut libc::c_void,
            size_t,
        ) -> libc::c_int,
    >,
    pub output_ts_offset: int64_t,
    pub dump_separator: *mut uint8_t,
    pub data_codec_id: AVCodecID,
    pub open_cb: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut *mut AVIOContext,
            *const libc::c_char,
            libc::c_int,
            *const AVIOInterruptCB,
            *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    pub protocol_whitelist: *mut libc::c_char,
    pub io_open: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut *mut AVIOContext,
            *const libc::c_char,
            libc::c_int,
            *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    pub io_close: Option::<
        unsafe extern "C" fn(*mut AVFormatContext, *mut AVIOContext) -> (),
    >,
    pub protocol_blacklist: *mut libc::c_char,
    pub max_streams: libc::c_int,
    pub skip_estimate_duration_from_pts: libc::c_int,
}
pub type AVDurationEstimationMethod = libc::c_uint;
pub const AVFMT_DURATION_FROM_BITRATE: AVDurationEstimationMethod = 2;
pub const AVFMT_DURATION_FROM_STREAM: AVDurationEstimationMethod = 1;
pub const AVFMT_DURATION_FROM_PTS: AVDurationEstimationMethod = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVChapter {
    pub id: libc::c_int,
    pub time_base: AVRational,
    pub start: int64_t,
    pub end: int64_t,
    pub metadata: *mut AVDictionary,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVProgram {
    pub id: libc::c_int,
    pub flags: libc::c_int,
    pub discard: AVDiscard,
    pub stream_index: *mut libc::c_uint,
    pub nb_stream_indexes: libc::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: libc::c_int,
    pub pmt_pid: libc::c_int,
    pub pcr_pid: libc::c_int,
    pub pmt_version: libc::c_int,
    pub start_time: int64_t,
    pub end_time: int64_t,
    pub pts_wrap_reference: int64_t,
    pub pts_wrap_behavior: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVStream {
    pub index: libc::c_int,
    pub id: libc::c_int,
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut libc::c_void,
    pub time_base: AVRational,
    pub start_time: int64_t,
    pub duration: int64_t,
    pub nb_frames: int64_t,
    pub disposition: libc::c_int,
    pub discard: AVDiscard,
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    pub avg_frame_rate: AVRational,
    pub attached_pic: AVPacket,
    pub side_data: *mut AVPacketSideData,
    pub nb_side_data: libc::c_int,
    pub event_flags: libc::c_int,
    pub r_frame_rate: AVRational,
    pub recommended_encoder_configuration: *mut libc::c_char,
    pub codecpar: *mut AVCodecParameters,
    pub info: *mut __anonstruct_info_529918689,
    pub pts_wrap_bits: libc::c_int,
    pub first_dts: int64_t,
    pub cur_dts: int64_t,
    pub last_IP_pts: int64_t,
    pub last_IP_duration: libc::c_int,
    pub probe_packets: libc::c_int,
    pub codec_info_nb_frames: libc::c_int,
    pub need_parsing: AVStreamParseType,
    pub parser: *mut AVCodecParserContext,
    pub last_in_packet_buffer: *mut AVPacketList,
    pub probe_data: AVProbeData,
    pub pts_buffer: [int64_t; 17],
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: libc::c_int,
    pub index_entries_allocated_size: libc::c_uint,
    pub stream_identifier: libc::c_int,
    pub program_num: libc::c_int,
    pub pmt_version: libc::c_int,
    pub pmt_stream_idx: libc::c_int,
    pub interleaver_chunk_size: int64_t,
    pub interleaver_chunk_duration: int64_t,
    pub request_probe: libc::c_int,
    pub skip_to_keyframe: libc::c_int,
    pub skip_samples: libc::c_int,
    pub start_skip_samples: int64_t,
    pub first_discard_sample: int64_t,
    pub last_discard_sample: int64_t,
    pub nb_decoded_frames: libc::c_int,
    pub mux_ts_offset: int64_t,
    pub pts_wrap_reference: int64_t,
    pub pts_wrap_behavior: libc::c_int,
    pub update_initial_durations_done: libc::c_int,
    pub pts_reorder_error: [int64_t; 17],
    pub pts_reorder_error_count: [uint8_t; 17],
    pub last_dts_for_order_check: int64_t,
    pub dts_ordered: uint8_t,
    pub dts_misordered: uint8_t,
    pub inject_global_side_data: libc::c_int,
    pub display_aspect_ratio: AVRational,
    pub internal: *mut AVStreamInternal,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct AVIndexEntry {
    pub pos: int64_t,
    pub timestamp: int64_t,
    #[bitfield(name = "flags", ty = "libc::c_int", bits = "0..=1")]
    #[bitfield(name = "size", ty = "libc::c_int", bits = "2..=31")]
    pub flags_size: [u8; 4],
    pub min_distance: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVProbeData {
    pub filename: *const libc::c_char,
    pub buf: *mut libc::c_uchar,
    pub buf_size: libc::c_int,
    pub mime_type: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
pub type AVStreamParseType = libc::c_uint;
pub const AVSTREAM_PARSE_FULL_RAW: AVStreamParseType = 5;
pub const AVSTREAM_PARSE_FULL_ONCE: AVStreamParseType = 4;
pub const AVSTREAM_PARSE_TIMESTAMPS: AVStreamParseType = 3;
pub const AVSTREAM_PARSE_HEADERS: AVStreamParseType = 2;
pub const AVSTREAM_PARSE_FULL: AVStreamParseType = 1;
pub const AVSTREAM_PARSE_NONE: AVStreamParseType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_info_529918689 {
    pub last_dts: int64_t,
    pub duration_gcd: int64_t,
    pub duration_count: libc::c_int,
    pub rfps_duration_sum: int64_t,
    pub duration_error: *mut [[libc::c_double; 399]; 2],
    pub codec_info_duration: int64_t,
    pub codec_info_duration_fields: int64_t,
    pub frame_delay_evidence: libc::c_int,
    pub found_decoder: libc::c_int,
    pub last_duration: int64_t,
    pub fps_first_dts: int64_t,
    pub fps_first_dts_idx: libc::c_int,
    pub fps_last_dts: int64_t,
    pub fps_last_dts_idx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVOutputFormat {
    pub name: *const libc::c_char,
    pub long_name: *const libc::c_char,
    pub mime_type: *const libc::c_char,
    pub extensions: *const libc::c_char,
    pub audio_codec: AVCodecID,
    pub video_codec: AVCodecID,
    pub subtitle_codec: AVCodecID,
    pub flags: libc::c_int,
    pub codec_tag: *const *const AVCodecTag,
    pub priv_class: *const AVClass,
    pub next: *mut AVOutputFormat,
    pub priv_data_size: libc::c_int,
    pub write_header: Option::<
        unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int,
    >,
    pub write_packet: Option::<
        unsafe extern "C" fn(*mut AVFormatContext, *mut AVPacket) -> libc::c_int,
    >,
    pub write_trailer: Option::<
        unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int,
    >,
    pub interleave_packet: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut AVPacket,
            *mut AVPacket,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub query_codec: Option::<
        unsafe extern "C" fn(AVCodecID, libc::c_int) -> libc::c_int,
    >,
    pub get_output_timestamp: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            *mut int64_t,
            *mut int64_t,
        ) -> (),
    >,
    pub control_message: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            *mut libc::c_void,
            size_t,
        ) -> libc::c_int,
    >,
    pub write_uncoded_frame: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            *mut *mut AVFrame,
            libc::c_uint,
        ) -> libc::c_int,
    >,
    pub get_device_list: Option::<
        unsafe extern "C" fn(*mut AVFormatContext, *mut AVDeviceInfoList) -> libc::c_int,
    >,
    pub create_device_capabilities: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
    pub free_device_capabilities: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
    pub data_codec: AVCodecID,
    pub init: Option::<unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int>,
    pub deinit: Option::<unsafe extern "C" fn(*mut AVFormatContext) -> ()>,
    pub check_bitstream: Option::<
        unsafe extern "C" fn(*mut AVFormatContext, *const AVPacket) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVInputFormat {
    pub name: *const libc::c_char,
    pub long_name: *const libc::c_char,
    pub flags: libc::c_int,
    pub extensions: *const libc::c_char,
    pub codec_tag: *const *const AVCodecTag,
    pub priv_class: *const AVClass,
    pub mime_type: *const libc::c_char,
    pub next: *mut AVInputFormat,
    pub raw_codec_id: libc::c_int,
    pub priv_data_size: libc::c_int,
    pub read_probe: Option::<unsafe extern "C" fn(*const AVProbeData) -> libc::c_int>,
    pub read_header: Option::<unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int>,
    pub read_packet: Option::<
        unsafe extern "C" fn(*mut AVFormatContext, *mut AVPacket) -> libc::c_int,
    >,
    pub read_close: Option::<unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int>,
    pub read_seek: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            int64_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub read_timestamp: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            *mut int64_t,
            int64_t,
        ) -> int64_t,
    >,
    pub read_play: Option::<unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int>,
    pub read_pause: Option::<unsafe extern "C" fn(*mut AVFormatContext) -> libc::c_int>,
    pub read_seek2: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            libc::c_int,
            int64_t,
            int64_t,
            int64_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub get_device_list: Option::<
        unsafe extern "C" fn(*mut AVFormatContext, *mut AVDeviceInfoList) -> libc::c_int,
    >,
    pub create_device_capabilities: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
    pub free_device_capabilities: Option::<
        unsafe extern "C" fn(
            *mut AVFormatContext,
            *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFilterContext {
    pub av_class: *const AVClass,
    pub filter: *const AVFilter,
    pub name: *mut libc::c_char,
    pub input_pads: *mut AVFilterPad,
    pub inputs: *mut *mut AVFilterLink,
    pub nb_inputs: libc::c_uint,
    pub output_pads: *mut AVFilterPad,
    pub outputs: *mut *mut AVFilterLink,
    pub nb_outputs: libc::c_uint,
    pub priv_0: *mut libc::c_void,
    pub graph: *mut AVFilterGraph,
    pub thread_type: libc::c_int,
    pub internal: *mut AVFilterInternal,
    pub command_queue: *mut AVFilterCommand,
    pub enable_str: *mut libc::c_char,
    pub enable: *mut libc::c_void,
    pub var_values: *mut libc::c_double,
    pub is_disabled: libc::c_int,
    pub hw_device_ctx: *mut AVBufferRef,
    pub nb_threads: libc::c_int,
    pub ready: libc::c_uint,
    pub extra_hw_frames: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFilterGraph {
    pub av_class: *const AVClass,
    pub filters: *mut *mut AVFilterContext,
    pub nb_filters: libc::c_uint,
    pub scale_sws_opts: *mut libc::c_char,
    pub resample_lavr_opts: *mut libc::c_char,
    pub thread_type: libc::c_int,
    pub nb_threads: libc::c_int,
    pub internal: *mut AVFilterGraphInternal,
    pub opaque: *mut libc::c_void,
    pub execute: Option::<avfilter_execute_func>,
    pub aresample_swr_opts: *mut libc::c_char,
    pub sink_links: *mut *mut AVFilterLink,
    pub sink_links_count: libc::c_int,
    pub disable_auto_convert: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFilterLink {
    pub src: *mut AVFilterContext,
    pub srcpad: *mut AVFilterPad,
    pub dst: *mut AVFilterContext,
    pub dstpad: *mut AVFilterPad,
    pub type_0: AVMediaType,
    pub w: libc::c_int,
    pub h: libc::c_int,
    pub sample_aspect_ratio: AVRational,
    pub channel_layout: uint64_t,
    pub sample_rate: libc::c_int,
    pub format: libc::c_int,
    pub time_base: AVRational,
    pub in_formats: *mut AVFilterFormats,
    pub out_formats: *mut AVFilterFormats,
    pub in_samplerates: *mut AVFilterFormats,
    pub out_samplerates: *mut AVFilterFormats,
    pub in_channel_layouts: *mut AVFilterChannelLayouts,
    pub out_channel_layouts: *mut AVFilterChannelLayouts,
    pub request_samples: libc::c_int,
    pub init_state: __anonenum_init_state_395822227,
    pub graph: *mut AVFilterGraph,
    pub current_pts: int64_t,
    pub current_pts_us: int64_t,
    pub age_index: libc::c_int,
    pub frame_rate: AVRational,
    pub partial_buf: *mut AVFrame,
    pub partial_buf_size: libc::c_int,
    pub min_samples: libc::c_int,
    pub max_samples: libc::c_int,
    pub channels: libc::c_int,
    pub flags: libc::c_uint,
    pub frame_count_in: int64_t,
    pub frame_count_out: int64_t,
    pub frame_pool: *mut libc::c_void,
    pub frame_wanted_out: libc::c_int,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub reserved: [libc::c_char; 61440],
}
pub type __anonenum_init_state_395822227 = libc::c_uint;
pub const AVLINK_INIT: __anonenum_init_state_395822227 = 2;
pub const AVLINK_STARTINIT: __anonenum_init_state_395822227 = 1;
pub const AVLINK_UNINIT: __anonenum_init_state_395822227 = 0;
pub type avfilter_execute_func = unsafe extern "C" fn(
    *mut AVFilterContext,
    Option::<avfilter_action_func>,
    *mut libc::c_void,
    *mut libc::c_int,
    libc::c_int,
) -> libc::c_int;
pub type avfilter_action_func = unsafe extern "C" fn(
    *mut AVFilterContext,
    *mut libc::c_void,
    libc::c_int,
    libc::c_int,
) -> libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVFilter {
    pub name: *const libc::c_char,
    pub description: *const libc::c_char,
    pub inputs: *const AVFilterPad,
    pub outputs: *const AVFilterPad,
    pub priv_class: *const AVClass,
    pub flags: libc::c_int,
    pub preinit: Option::<unsafe extern "C" fn(*mut AVFilterContext) -> libc::c_int>,
    pub init: Option::<unsafe extern "C" fn(*mut AVFilterContext) -> libc::c_int>,
    pub init_dict: Option::<
        unsafe extern "C" fn(*mut AVFilterContext, *mut *mut AVDictionary) -> libc::c_int,
    >,
    pub uninit: Option::<unsafe extern "C" fn(*mut AVFilterContext) -> ()>,
    pub query_formats: Option::<
        unsafe extern "C" fn(*mut AVFilterContext) -> libc::c_int,
    >,
    pub priv_size: libc::c_int,
    pub flags_internal: libc::c_int,
    pub next: *mut AVFilter,
    pub process_command: Option::<
        unsafe extern "C" fn(
            *mut AVFilterContext,
            *const libc::c_char,
            *const libc::c_char,
            *mut libc::c_char,
            libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub init_opaque: Option::<
        unsafe extern "C" fn(*mut AVFilterContext, *mut libc::c_void) -> libc::c_int,
    >,
    pub activate: Option::<unsafe extern "C" fn(*mut AVFilterContext) -> libc::c_int>,
}
pub type __anonenum_BarKeyShortcutId_t_540388776 = libc::c_uint;
pub const BAR_KS_COUNT: __anonenum_BarKeyShortcutId_t_540388776 = 30;
pub const BAR_KS_SETTINGS: __anonenum_BarKeyShortcutId_t_540388776 = 29;
pub const BAR_KS_VOLRESET: __anonenum_BarKeyShortcutId_t_540388776 = 28;
pub const BAR_KS_PAUSE: __anonenum_BarKeyShortcutId_t_540388776 = 27;
pub const BAR_KS_PLAY: __anonenum_BarKeyShortcutId_t_540388776 = 26;
pub const BAR_KS_CREATESTATIONFROMSONG: __anonenum_BarKeyShortcutId_t_540388776 = 25;
pub const BAR_KS_PLAYPAUSE2: __anonenum_BarKeyShortcutId_t_540388776 = 24;
pub const BAR_KS_MANAGESTATION: __anonenum_BarKeyShortcutId_t_540388776 = 23;
pub const BAR_KS_VOLUP: __anonenum_BarKeyShortcutId_t_540388776 = 22;
pub const BAR_KS_VOLDOWN: __anonenum_BarKeyShortcutId_t_540388776 = 21;
pub const BAR_KS_BOOKMARK: __anonenum_BarKeyShortcutId_t_540388776 = 20;
pub const BAR_KS_DEBUG: __anonenum_BarKeyShortcutId_t_540388776 = 19;
pub const BAR_KS_SELECTQUICKMIX: __anonenum_BarKeyShortcutId_t_540388776 = 18;
pub const BAR_KS_UPCOMING: __anonenum_BarKeyShortcutId_t_540388776 = 17;
pub const BAR_KS_TIRED: __anonenum_BarKeyShortcutId_t_540388776 = 16;
pub const BAR_KS_SELECTSTATION: __anonenum_BarKeyShortcutId_t_540388776 = 15;
pub const BAR_KS_RENAMESTATION: __anonenum_BarKeyShortcutId_t_540388776 = 14;
pub const BAR_KS_QUIT: __anonenum_BarKeyShortcutId_t_540388776 = 13;
pub const BAR_KS_PLAYPAUSE: __anonenum_BarKeyShortcutId_t_540388776 = 12;
pub const BAR_KS_SKIP: __anonenum_BarKeyShortcutId_t_540388776 = 11;
pub const BAR_KS_ADDSHARED: __anonenum_BarKeyShortcutId_t_540388776 = 10;
pub const BAR_KS_INFO: __anonenum_BarKeyShortcutId_t_540388776 = 9;
pub const BAR_KS_HISTORY: __anonenum_BarKeyShortcutId_t_540388776 = 8;
pub const BAR_KS_GENRESTATION: __anonenum_BarKeyShortcutId_t_540388776 = 7;
pub const BAR_KS_EXPLAIN: __anonenum_BarKeyShortcutId_t_540388776 = 6;
pub const BAR_KS_DELETESTATION: __anonenum_BarKeyShortcutId_t_540388776 = 5;
pub const BAR_KS_CREATESTATION: __anonenum_BarKeyShortcutId_t_540388776 = 4;
pub const BAR_KS_ADDMUSIC: __anonenum_BarKeyShortcutId_t_540388776 = 3;
pub const BAR_KS_BAN: __anonenum_BarKeyShortcutId_t_540388776 = 2;
pub const BAR_KS_LOVE: __anonenum_BarKeyShortcutId_t_540388776 = 1;
pub const BAR_KS_HELP: __anonenum_BarKeyShortcutId_t_540388776 = 0;
pub type BarKeyShortcutId_t = __anonenum_BarKeyShortcutId_t_540388776;
pub type __anonenum_BarStationSorting_t_648870747 = libc::c_uint;
pub const BAR_SORT_COUNT: __anonenum_BarStationSorting_t_648870747 = 6;
pub const BAR_SORT_QUICKMIX_10_NAME_ZA: __anonenum_BarStationSorting_t_648870747 = 5;
pub const BAR_SORT_QUICKMIX_10_NAME_AZ: __anonenum_BarStationSorting_t_648870747 = 4;
pub const BAR_SORT_QUICKMIX_01_NAME_ZA: __anonenum_BarStationSorting_t_648870747 = 3;
pub const BAR_SORT_QUICKMIX_01_NAME_AZ: __anonenum_BarStationSorting_t_648870747 = 2;
pub const BAR_SORT_NAME_ZA: __anonenum_BarStationSorting_t_648870747 = 1;
pub const BAR_SORT_NAME_AZ: __anonenum_BarStationSorting_t_648870747 = 0;
pub type BarStationSorting_t = __anonenum_BarStationSorting_t_648870747;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_BarMsgFormatStr_t_476363767 {
    pub prefix: *mut libc::c_char,
    pub postfix: *mut libc::c_char,
}
pub type BarMsgFormatStr_t = __anonstruct_BarMsgFormatStr_t_476363767;
pub type __anonenum_BarUiMsg_t_774981372 = libc::c_uint;
pub const MSG_COUNT: __anonenum_BarUiMsg_t_774981372 = 7;
pub const MSG_LIST: __anonenum_BarUiMsg_t_774981372 = 6;
pub const MSG_QUESTION: __anonenum_BarUiMsg_t_774981372 = 5;
pub const MSG_ERR: __anonenum_BarUiMsg_t_774981372 = 4;
pub const MSG_TIME: __anonenum_BarUiMsg_t_774981372 = 3;
pub const MSG_PLAYING: __anonenum_BarUiMsg_t_774981372 = 2;
pub const MSG_INFO: __anonenum_BarUiMsg_t_774981372 = 1;
pub const MSG_NONE: __anonenum_BarUiMsg_t_774981372 = 0;
pub type BarUiMsg_t = __anonenum_BarUiMsg_t_774981372;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_BarSettings_t_498659073 {
    pub autoselect: bool,
    pub history: libc::c_uint,
    pub maxRetry: libc::c_uint,
    pub timeout: libc::c_uint,
    pub bufferSecs: libc::c_uint,
    pub volume: libc::c_int,
    pub gainMul: libc::c_float,
    pub sortOrder: BarStationSorting_t,
    pub audioQuality: PianoAudioQuality_t,
    pub username: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub passwordCmd: *mut libc::c_char,
    pub controlProxy: *mut libc::c_char,
    pub proxy: *mut libc::c_char,
    pub bindTo: *mut libc::c_char,
    pub autostartStation: *mut libc::c_char,
    pub eventCmd: *mut libc::c_char,
    pub loveIcon: *mut libc::c_char,
    pub banIcon: *mut libc::c_char,
    pub tiredIcon: *mut libc::c_char,
    pub atIcon: *mut libc::c_char,
    pub npSongFormat: *mut libc::c_char,
    pub npStationFormat: *mut libc::c_char,
    pub listSongFormat: *mut libc::c_char,
    pub timeFormat: *mut libc::c_char,
    pub fifo: *mut libc::c_char,
    pub rpcHost: *mut libc::c_char,
    pub rpcTlsPort: *mut libc::c_char,
    pub partnerUser: *mut libc::c_char,
    pub partnerPassword: *mut libc::c_char,
    pub device: *mut libc::c_char,
    pub inkey: *mut libc::c_char,
    pub outkey: *mut libc::c_char,
    pub caBundle: *mut libc::c_char,
    pub audioPipe: *mut libc::c_char,
    pub keys: [libc::c_char; 30],
    pub sampleRate: libc::c_int,
    pub msgFormat: [BarMsgFormatStr_t; 7],
}
pub type BarSettings_t = __anonstruct_BarSettings_t_498659073;
pub type __anonenum_BarPlayerMode_11296495 = libc::c_uint;
pub const PLAYER_FINISHED: __anonenum_BarPlayerMode_11296495 = 3;
pub const PLAYER_PLAYING: __anonenum_BarPlayerMode_11296495 = 2;
pub const PLAYER_WAITING: __anonenum_BarPlayerMode_11296495 = 1;
pub const PLAYER_DEAD: __anonenum_BarPlayerMode_11296495 = 0;
pub type BarPlayerMode = __anonenum_BarPlayerMode_11296495;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_player_t_802006497 {
    pub lock: pthread_mutex_t,
    pub aoplayLock: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub aoplayCond: pthread_cond_t,
    pub doQuit: bool,
    pub doPause: bool,
    pub songDuration: libc::c_uint,
    pub songPlayed: libc::c_uint,
    pub mode: BarPlayerMode,
    pub fvolume: *mut AVFilterContext,
    pub fgraph: *mut AVFilterGraph,
    pub fctx: *mut AVFormatContext,
    pub st: *mut AVStream,
    pub cctx: *mut AVCodecContext,
    pub fbufsink: *mut AVFilterContext,
    pub fabuf: *mut AVFilterContext,
    pub streamIdx: libc::c_int,
    pub lastTimestamp: int64_t,
    pub interrupted: sig_atomic_t,
    pub aoDev: *mut ao_device,
    pub gain: libc::c_double,
    pub url: *mut libc::c_char,
    pub settings: *const BarSettings_t,
}
pub type player_t = __anonstruct_player_t_802006497;
pub type __anonenum_BarReadlineFlags_t_696436146 = libc::c_uint;
pub const BAR_RL_NOINT: __anonenum_BarReadlineFlags_t_696436146 = 4;
pub const BAR_RL_NOECHO: __anonenum_BarReadlineFlags_t_696436146 = 2;
pub const BAR_RL_FULLRETURN: __anonenum_BarReadlineFlags_t_696436146 = 1;
pub const BAR_RL_DEFAULT: __anonenum_BarReadlineFlags_t_696436146 = 0;
pub type BarReadlineFlags_t = __anonenum_BarReadlineFlags_t_696436146;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_BarReadlineFds_t_550597175 {
    pub set: fd_set,
    pub maxfd: libc::c_int,
    pub fds: [libc::c_int; 2],
}
pub type BarReadlineFds_t = __anonstruct_BarReadlineFds_t_550597175;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_BarApp_t_215541748 {
    pub ph: PianoHandle_t,
    pub http: *mut libc::c_void,
    pub player: player_t,
    pub settings: BarSettings_t,
    pub playlist: *mut PianoSong_t,
    pub songHistory: *mut PianoSong_t,
    pub curStation: *mut PianoStation_t,
    pub nextStation: *mut PianoStation_t,
    pub doQuit: sig_atomic_t,
    pub input: BarReadlineFds_t,
    pub playerErrors: libc::c_uint,
}
pub type BarApp_t = __anonstruct_BarApp_t_215541748;
pub type __anonenum_BarUiDispatchContext_t_1004206478 = libc::c_uint;
pub const BAR_DC_SONG: __anonenum_BarUiDispatchContext_t_1004206478 = 4;
pub const BAR_DC_STATION: __anonenum_BarUiDispatchContext_t_1004206478 = 2;
pub const BAR_DC_GLOBAL: __anonenum_BarUiDispatchContext_t_1004206478 = 1;
pub const BAR_DC_UNDEFINED: __anonenum_BarUiDispatchContext_t_1004206478 = 0;
pub type BarUiDispatchContext_t = __anonenum_BarUiDispatchContext_t_1004206478;
pub type uintptr_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_condattr_t_488594145 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_condattr_t = __anonunion_pthread_condattr_t_488594145;
pub type uint_32 = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ao_sample_format {
    pub bits: libc::c_int,
    pub rate: libc::c_int,
    pub channels: libc::c_int,
    pub byte_format: libc::c_int,
    pub matrix: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ao_option {
    pub key: *mut libc::c_char,
    pub value: *mut libc::c_char,
    pub next: *mut ao_option,
}
pub type __anonenum_drainMode_989564894 = libc::c_uint;
pub const DONE: __anonenum_drainMode_989564894 = 2;
pub const DRAIN: __anonenum_drainMode_989564894 = 1;
pub const FILL: __anonenum_drainMode_989564894 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct passwd {
    pub pw_name: *mut libc::c_char,
    pub pw_passwd: *mut libc::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut libc::c_char,
    pub pw_dir: *mut libc::c_char,
    pub pw_shell: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_BarUiDispatchAction_t_315043967 {
    pub defaultKey: libc::c_char,
    pub context: BarUiDispatchContext_t,
    pub function: Option::<
        unsafe extern "C" fn(
            *mut BarApp_t,
            *mut PianoStation_t,
            *mut PianoSong_t,
            BarUiDispatchContext_t,
        ) -> (),
    >,
    pub helpText: *const libc::c_char,
    pub configKey: *const libc::c_char,
}
pub type BarUiDispatchAction_t = __anonstruct_BarUiDispatchAction_t_315043967;
pub type cc_t = libc::c_uchar;
pub type speed_t = libc::c_uint;
pub type tcflag_t = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoArtist {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub musicId: *mut libc::c_char,
    pub seedId: *mut libc::c_char,
    pub score: libc::c_int,
}
pub type PianoArtist_t = PianoArtist;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoStationInfo_t_433712355 {
    pub songSeeds: *mut PianoSong_t,
    pub artistSeeds: *mut PianoArtist_t,
    pub stationSeeds: *mut PianoStation_t,
    pub feedback: *mut PianoSong_t,
}
pub type PianoStationInfo_t = __anonstruct_PianoStationInfo_t_433712355;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoSettings_t_630908213 {
    pub username: *mut libc::c_char,
    pub explicitContentFilter: bool,
}
pub type PianoSettings_t = __anonstruct_PianoSettings_t_630908213;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoStationMode_t_460202994 {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub description: *mut libc::c_char,
    pub isAlgorithmic: bool,
    pub isTakeover: bool,
    pub active: bool,
    pub id: libc::c_int,
}
pub type PianoStationMode_t = __anonstruct_PianoStationMode_t_460202994;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataRateSong_t_734572046 {
    pub song: *mut PianoSong_t,
    pub rating: PianoSongRating_t,
}
pub type PianoRequestDataRateSong_t = __anonstruct_PianoRequestDataRateSong_t_734572046;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataRenameStation_t_302001453 {
    pub station: *mut PianoStation_t,
    pub newName: *mut libc::c_char,
}
pub type PianoRequestDataRenameStation_t = __anonstruct_PianoRequestDataRenameStation_t_302001453;
pub type __anonenum_type_185732391 = libc::c_uint;
pub const PIANO_MUSICTYPE_ARTIST: __anonenum_type_185732391 = 2;
pub const PIANO_MUSICTYPE_SONG: __anonenum_type_185732391 = 1;
pub const PIANO_MUSICTYPE_INVALID: __anonenum_type_185732391 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataCreateStation_t_733199068 {
    pub token: *mut libc::c_char,
    pub type_0: __anonenum_type_185732391,
}
pub type PianoRequestDataCreateStation_t = __anonstruct_PianoRequestDataCreateStation_t_733199068;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataAddSeed_t_846105165 {
    pub station: *mut PianoStation_t,
    pub musicId: *mut libc::c_char,
}
pub type PianoRequestDataAddSeed_t = __anonstruct_PianoRequestDataAddSeed_t_846105165;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataExplain_t_569239397 {
    pub song: *mut PianoSong_t,
    pub retExplain: *mut libc::c_char,
}
pub type PianoRequestDataExplain_t = __anonstruct_PianoRequestDataExplain_t_569239397;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataGetStationInfo_t_492757416 {
    pub station: *mut PianoStation_t,
    pub info: PianoStationInfo_t,
}
pub type PianoRequestDataGetStationInfo_t = __anonstruct_PianoRequestDataGetStationInfo_t_492757416;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataDeleteSeed_t_815195772 {
    pub song: *mut PianoSong_t,
    pub artist: *mut PianoArtist_t,
    pub station: *mut PianoStation_t,
}
pub type PianoRequestDataDeleteSeed_t = __anonstruct_PianoRequestDataDeleteSeed_t_815195772;
pub type __anonenum_PianoTristate_t_148770165 = libc::c_uint;
pub const PIANO_TRUE: __anonenum_PianoTristate_t_148770165 = 2;
pub const PIANO_FALSE: __anonenum_PianoTristate_t_148770165 = 1;
pub const PIANO_UNDEFINED: __anonenum_PianoTristate_t_148770165 = 0;
pub type PianoTristate_t = __anonenum_PianoTristate_t_148770165;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataChangeSettings_t_634463242 {
    pub currentUsername: *mut libc::c_char,
    pub newUsername: *mut libc::c_char,
    pub currentPassword: *mut libc::c_char,
    pub newPassword: *mut libc::c_char,
    pub explicitContentFilter: PianoTristate_t,
}
pub type PianoRequestDataChangeSettings_t = __anonstruct_PianoRequestDataChangeSettings_t_634463242;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataGetStationModes_t_379829503 {
    pub station: *mut PianoStation_t,
    pub retModes: *mut PianoStationMode_t,
}
pub type PianoRequestDataGetStationModes_t = __anonstruct_PianoRequestDataGetStationModes_t_379829503;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataSetStationMode_t_201641957 {
    pub station: *mut PianoStation_t,
    pub id: libc::c_uint,
}
pub type PianoRequestDataSetStationMode_t = __anonstruct_PianoRequestDataSetStationMode_t_201641957;
pub type va_list___0 = __gnuc_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoSearchResult {
    pub songs: *mut PianoSong_t,
    pub artists: *mut PianoArtist_t,
}
pub type PianoSearchResult_t = PianoSearchResult;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequest {
    pub type_0: PianoRequestType_t,
    pub secure: bool,
    pub data: *mut libc::c_void,
    pub urlPath: [libc::c_char; 1024],
    pub postData: *mut libc::c_char,
    pub responseData: *mut libc::c_char,
}
pub type PianoRequest_t = PianoRequest;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataSearch_t_846105164 {
    pub searchStr: *mut libc::c_char,
    pub searchResult: PianoSearchResult_t,
}
pub type PianoRequestDataSearch_t = __anonstruct_PianoRequestDataSearch_t_846105164;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct curl_slist {
    pub data: *mut libc::c_char,
    pub next: *mut curl_slist,
}
pub type __anonenum_CURLoption_714703655 = libc::c_uint;
pub const CURLOPT_LASTENTRY: __anonenum_CURLoption_714703655 = 10290;
pub const CURLOPT_SASL_AUTHZID: __anonenum_CURLoption_714703655 = 10289;
pub const CURLOPT_MAXAGE_CONN: __anonenum_CURLoption_714703655 = 288;
pub const CURLOPT_ALTSVC: __anonenum_CURLoption_714703655 = 10287;
pub const CURLOPT_ALTSVC_CTRL: __anonenum_CURLoption_714703655 = 286;
pub const CURLOPT_HTTP09_ALLOWED: __anonenum_CURLoption_714703655 = 285;
pub const CURLOPT_TRAILERDATA: __anonenum_CURLoption_714703655 = 10284;
pub const CURLOPT_TRAILERFUNCTION: __anonenum_CURLoption_714703655 = 20283;
pub const CURLOPT_CURLU: __anonenum_CURLoption_714703655 = 10282;
pub const CURLOPT_UPKEEP_INTERVAL_MS: __anonenum_CURLoption_714703655 = 281;
pub const CURLOPT_UPLOAD_BUFFERSIZE: __anonenum_CURLoption_714703655 = 280;
pub const CURLOPT_DOH_URL: __anonenum_CURLoption_714703655 = 10279;
pub const CURLOPT_DISALLOW_USERNAME_IN_URL: __anonenum_CURLoption_714703655 = 278;
pub const CURLOPT_PROXY_TLS13_CIPHERS: __anonenum_CURLoption_714703655 = 10277;
pub const CURLOPT_TLS13_CIPHERS: __anonenum_CURLoption_714703655 = 10276;
pub const CURLOPT_DNS_SHUFFLE_ADDRESSES: __anonenum_CURLoption_714703655 = 275;
pub const CURLOPT_HAPROXYPROTOCOL: __anonenum_CURLoption_714703655 = 274;
pub const CURLOPT_RESOLVER_START_DATA: __anonenum_CURLoption_714703655 = 10273;
pub const CURLOPT_RESOLVER_START_FUNCTION: __anonenum_CURLoption_714703655 = 20272;
pub const CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS: __anonenum_CURLoption_714703655 = 271;
pub const CURLOPT_TIMEVALUE_LARGE: __anonenum_CURLoption_714703655 = 30270;
pub const CURLOPT_MIMEPOST: __anonenum_CURLoption_714703655 = 10269;
pub const CURLOPT_SSH_COMPRESSION: __anonenum_CURLoption_714703655 = 268;
pub const CURLOPT_SOCKS5_AUTH: __anonenum_CURLoption_714703655 = 267;
pub const CURLOPT_REQUEST_TARGET: __anonenum_CURLoption_714703655 = 10266;
pub const CURLOPT_SUPPRESS_CONNECT_HEADERS: __anonenum_CURLoption_714703655 = 265;
pub const CURLOPT_ABSTRACT_UNIX_SOCKET: __anonenum_CURLoption_714703655 = 10264;
pub const CURLOPT_PROXY_PINNEDPUBLICKEY: __anonenum_CURLoption_714703655 = 10263;
pub const CURLOPT_PRE_PROXY: __anonenum_CURLoption_714703655 = 10262;
pub const CURLOPT_PROXY_SSL_OPTIONS: __anonenum_CURLoption_714703655 = 261;
pub const CURLOPT_PROXY_CRLFILE: __anonenum_CURLoption_714703655 = 10260;
pub const CURLOPT_PROXY_SSL_CIPHER_LIST: __anonenum_CURLoption_714703655 = 10259;
pub const CURLOPT_PROXY_KEYPASSWD: __anonenum_CURLoption_714703655 = 10258;
pub const CURLOPT_PROXY_SSLKEYTYPE: __anonenum_CURLoption_714703655 = 10257;
pub const CURLOPT_PROXY_SSLKEY: __anonenum_CURLoption_714703655 = 10256;
pub const CURLOPT_PROXY_SSLCERTTYPE: __anonenum_CURLoption_714703655 = 10255;
pub const CURLOPT_PROXY_SSLCERT: __anonenum_CURLoption_714703655 = 10254;
pub const CURLOPT_PROXY_TLSAUTH_TYPE: __anonenum_CURLoption_714703655 = 10253;
pub const CURLOPT_PROXY_TLSAUTH_PASSWORD: __anonenum_CURLoption_714703655 = 10252;
pub const CURLOPT_PROXY_TLSAUTH_USERNAME: __anonenum_CURLoption_714703655 = 10251;
pub const CURLOPT_PROXY_SSLVERSION: __anonenum_CURLoption_714703655 = 250;
pub const CURLOPT_PROXY_SSL_VERIFYHOST: __anonenum_CURLoption_714703655 = 249;
pub const CURLOPT_PROXY_SSL_VERIFYPEER: __anonenum_CURLoption_714703655 = 248;
pub const CURLOPT_PROXY_CAPATH: __anonenum_CURLoption_714703655 = 10247;
pub const CURLOPT_PROXY_CAINFO: __anonenum_CURLoption_714703655 = 10246;
pub const CURLOPT_KEEP_SENDING_ON_ERROR: __anonenum_CURLoption_714703655 = 245;
pub const CURLOPT_TCP_FASTOPEN: __anonenum_CURLoption_714703655 = 244;
pub const CURLOPT_CONNECT_TO: __anonenum_CURLoption_714703655 = 10243;
pub const CURLOPT_TFTP_NO_OPTIONS: __anonenum_CURLoption_714703655 = 242;
pub const CURLOPT_STREAM_DEPENDS_E: __anonenum_CURLoption_714703655 = 10241;
pub const CURLOPT_STREAM_DEPENDS: __anonenum_CURLoption_714703655 = 10240;
pub const CURLOPT_STREAM_WEIGHT: __anonenum_CURLoption_714703655 = 239;
pub const CURLOPT_DEFAULT_PROTOCOL: __anonenum_CURLoption_714703655 = 10238;
pub const CURLOPT_PIPEWAIT: __anonenum_CURLoption_714703655 = 237;
pub const CURLOPT_SERVICE_NAME: __anonenum_CURLoption_714703655 = 10236;
pub const CURLOPT_PROXY_SERVICE_NAME: __anonenum_CURLoption_714703655 = 10235;
pub const CURLOPT_PATH_AS_IS: __anonenum_CURLoption_714703655 = 234;
pub const CURLOPT_SSL_FALSESTART: __anonenum_CURLoption_714703655 = 233;
pub const CURLOPT_SSL_VERIFYSTATUS: __anonenum_CURLoption_714703655 = 232;
pub const CURLOPT_UNIX_SOCKET_PATH: __anonenum_CURLoption_714703655 = 10231;
pub const CURLOPT_PINNEDPUBLICKEY: __anonenum_CURLoption_714703655 = 10230;
pub const CURLOPT_HEADEROPT: __anonenum_CURLoption_714703655 = 229;
pub const CURLOPT_PROXYHEADER: __anonenum_CURLoption_714703655 = 10228;
pub const CURLOPT_EXPECT_100_TIMEOUT_MS: __anonenum_CURLoption_714703655 = 227;
pub const CURLOPT_SSL_ENABLE_ALPN: __anonenum_CURLoption_714703655 = 226;
pub const CURLOPT_SSL_ENABLE_NPN: __anonenum_CURLoption_714703655 = 225;
pub const CURLOPT_LOGIN_OPTIONS: __anonenum_CURLoption_714703655 = 10224;
pub const CURLOPT_DNS_LOCAL_IP6: __anonenum_CURLoption_714703655 = 10223;
pub const CURLOPT_DNS_LOCAL_IP4: __anonenum_CURLoption_714703655 = 10222;
pub const CURLOPT_DNS_INTERFACE: __anonenum_CURLoption_714703655 = 10221;
pub const CURLOPT_XOAUTH2_BEARER: __anonenum_CURLoption_714703655 = 10220;
pub const CURLOPT_XFERINFOFUNCTION: __anonenum_CURLoption_714703655 = 20219;
pub const CURLOPT_SASL_IR: __anonenum_CURLoption_714703655 = 218;
pub const CURLOPT_MAIL_AUTH: __anonenum_CURLoption_714703655 = 10217;
pub const CURLOPT_SSL_OPTIONS: __anonenum_CURLoption_714703655 = 216;
pub const CURLOPT_TCP_KEEPINTVL: __anonenum_CURLoption_714703655 = 215;
pub const CURLOPT_TCP_KEEPIDLE: __anonenum_CURLoption_714703655 = 214;
pub const CURLOPT_TCP_KEEPALIVE: __anonenum_CURLoption_714703655 = 213;
pub const CURLOPT_ACCEPTTIMEOUT_MS: __anonenum_CURLoption_714703655 = 212;
pub const CURLOPT_DNS_SERVERS: __anonenum_CURLoption_714703655 = 10211;
pub const CURLOPT_GSSAPI_DELEGATION: __anonenum_CURLoption_714703655 = 210;
pub const CURLOPT_CLOSESOCKETDATA: __anonenum_CURLoption_714703655 = 10209;
pub const CURLOPT_CLOSESOCKETFUNCTION: __anonenum_CURLoption_714703655 = 20208;
pub const CURLOPT_TRANSFER_ENCODING: __anonenum_CURLoption_714703655 = 207;
pub const CURLOPT_TLSAUTH_TYPE: __anonenum_CURLoption_714703655 = 10206;
pub const CURLOPT_TLSAUTH_PASSWORD: __anonenum_CURLoption_714703655 = 10205;
pub const CURLOPT_TLSAUTH_USERNAME: __anonenum_CURLoption_714703655 = 10204;
pub const CURLOPT_RESOLVE: __anonenum_CURLoption_714703655 = 10203;
pub const CURLOPT_FNMATCH_DATA: __anonenum_CURLoption_714703655 = 10202;
pub const CURLOPT_CHUNK_DATA: __anonenum_CURLoption_714703655 = 10201;
pub const CURLOPT_FNMATCH_FUNCTION: __anonenum_CURLoption_714703655 = 20200;
pub const CURLOPT_CHUNK_END_FUNCTION: __anonenum_CURLoption_714703655 = 20199;
pub const CURLOPT_CHUNK_BGN_FUNCTION: __anonenum_CURLoption_714703655 = 20198;
pub const CURLOPT_WILDCARDMATCH: __anonenum_CURLoption_714703655 = 197;
pub const CURLOPT_INTERLEAVEFUNCTION: __anonenum_CURLoption_714703655 = 20196;
pub const CURLOPT_INTERLEAVEDATA: __anonenum_CURLoption_714703655 = 10195;
pub const CURLOPT_RTSP_SERVER_CSEQ: __anonenum_CURLoption_714703655 = 194;
pub const CURLOPT_RTSP_CLIENT_CSEQ: __anonenum_CURLoption_714703655 = 193;
pub const CURLOPT_RTSP_TRANSPORT: __anonenum_CURLoption_714703655 = 10192;
pub const CURLOPT_RTSP_STREAM_URI: __anonenum_CURLoption_714703655 = 10191;
pub const CURLOPT_RTSP_SESSION_ID: __anonenum_CURLoption_714703655 = 10190;
pub const CURLOPT_RTSP_REQUEST: __anonenum_CURLoption_714703655 = 189;
pub const CURLOPT_FTP_USE_PRET: __anonenum_CURLoption_714703655 = 188;
pub const CURLOPT_MAIL_RCPT: __anonenum_CURLoption_714703655 = 10187;
pub const CURLOPT_MAIL_FROM: __anonenum_CURLoption_714703655 = 10186;
pub const CURLOPT_SSH_KEYDATA: __anonenum_CURLoption_714703655 = 10185;
pub const CURLOPT_SSH_KEYFUNCTION: __anonenum_CURLoption_714703655 = 20184;
pub const CURLOPT_SSH_KNOWNHOSTS: __anonenum_CURLoption_714703655 = 10183;
pub const CURLOPT_REDIR_PROTOCOLS: __anonenum_CURLoption_714703655 = 182;
pub const CURLOPT_PROTOCOLS: __anonenum_CURLoption_714703655 = 181;
pub const CURLOPT_SOCKS5_GSSAPI_NEC: __anonenum_CURLoption_714703655 = 180;
pub const CURLOPT_SOCKS5_GSSAPI_SERVICE: __anonenum_CURLoption_714703655 = 10179;
pub const CURLOPT_TFTP_BLKSIZE: __anonenum_CURLoption_714703655 = 178;
pub const CURLOPT_NOPROXY: __anonenum_CURLoption_714703655 = 10177;
pub const CURLOPT_PROXYPASSWORD: __anonenum_CURLoption_714703655 = 10176;
pub const CURLOPT_PROXYUSERNAME: __anonenum_CURLoption_714703655 = 10175;
pub const CURLOPT_PASSWORD: __anonenum_CURLoption_714703655 = 10174;
pub const CURLOPT_USERNAME: __anonenum_CURLoption_714703655 = 10173;
pub const CURLOPT_CERTINFO: __anonenum_CURLoption_714703655 = 172;
pub const CURLOPT_ADDRESS_SCOPE: __anonenum_CURLoption_714703655 = 171;
pub const CURLOPT_ISSUERCERT: __anonenum_CURLoption_714703655 = 10170;
pub const CURLOPT_CRLFILE: __anonenum_CURLoption_714703655 = 10169;
pub const CURLOPT_SEEKDATA: __anonenum_CURLoption_714703655 = 10168;
pub const CURLOPT_SEEKFUNCTION: __anonenum_CURLoption_714703655 = 20167;
pub const CURLOPT_PROXY_TRANSFER_MODE: __anonenum_CURLoption_714703655 = 166;
pub const CURLOPT_COPYPOSTFIELDS: __anonenum_CURLoption_714703655 = 10165;
pub const CURLOPT_OPENSOCKETDATA: __anonenum_CURLoption_714703655 = 10164;
pub const CURLOPT_OPENSOCKETFUNCTION: __anonenum_CURLoption_714703655 = 20163;
pub const CURLOPT_SSH_HOST_PUBLIC_KEY_MD5: __anonenum_CURLoption_714703655 = 10162;
pub const CURLOPT_POSTREDIR: __anonenum_CURLoption_714703655 = 161;
pub const CURLOPT_NEW_DIRECTORY_PERMS: __anonenum_CURLoption_714703655 = 160;
pub const CURLOPT_NEW_FILE_PERMS: __anonenum_CURLoption_714703655 = 159;
pub const CURLOPT_HTTP_CONTENT_DECODING: __anonenum_CURLoption_714703655 = 158;
pub const CURLOPT_HTTP_TRANSFER_DECODING: __anonenum_CURLoption_714703655 = 157;
pub const CURLOPT_CONNECTTIMEOUT_MS: __anonenum_CURLoption_714703655 = 156;
pub const CURLOPT_TIMEOUT_MS: __anonenum_CURLoption_714703655 = 155;
pub const CURLOPT_FTP_SSL_CCC: __anonenum_CURLoption_714703655 = 154;
pub const CURLOPT_SSH_PRIVATE_KEYFILE: __anonenum_CURLoption_714703655 = 10153;
pub const CURLOPT_SSH_PUBLIC_KEYFILE: __anonenum_CURLoption_714703655 = 10152;
pub const CURLOPT_SSH_AUTH_TYPES: __anonenum_CURLoption_714703655 = 151;
pub const CURLOPT_SSL_SESSIONID_CACHE: __anonenum_CURLoption_714703655 = 150;
pub const CURLOPT_SOCKOPTDATA: __anonenum_CURLoption_714703655 = 10149;
pub const CURLOPT_SOCKOPTFUNCTION: __anonenum_CURLoption_714703655 = 20148;
pub const CURLOPT_FTP_ALTERNATIVE_TO_USER: __anonenum_CURLoption_714703655 = 10147;
pub const CURLOPT_MAX_RECV_SPEED_LARGE: __anonenum_CURLoption_714703655 = 30146;
pub const CURLOPT_MAX_SEND_SPEED_LARGE: __anonenum_CURLoption_714703655 = 30145;
pub const CURLOPT_CONV_FROM_UTF8_FUNCTION: __anonenum_CURLoption_714703655 = 20144;
pub const CURLOPT_CONV_TO_NETWORK_FUNCTION: __anonenum_CURLoption_714703655 = 20143;
pub const CURLOPT_CONV_FROM_NETWORK_FUNCTION: __anonenum_CURLoption_714703655 = 20142;
pub const CURLOPT_CONNECT_ONLY: __anonenum_CURLoption_714703655 = 141;
pub const CURLOPT_LOCALPORTRANGE: __anonenum_CURLoption_714703655 = 140;
pub const CURLOPT_LOCALPORT: __anonenum_CURLoption_714703655 = 139;
pub const CURLOPT_FTP_FILEMETHOD: __anonenum_CURLoption_714703655 = 138;
pub const CURLOPT_FTP_SKIP_PASV_IP: __anonenum_CURLoption_714703655 = 137;
pub const CURLOPT_IGNORE_CONTENT_LENGTH: __anonenum_CURLoption_714703655 = 136;
pub const CURLOPT_COOKIELIST: __anonenum_CURLoption_714703655 = 10135;
pub const CURLOPT_FTP_ACCOUNT: __anonenum_CURLoption_714703655 = 10134;
pub const CURLOPT_IOCTLDATA: __anonenum_CURLoption_714703655 = 10131;
pub const CURLOPT_IOCTLFUNCTION: __anonenum_CURLoption_714703655 = 20130;
pub const CURLOPT_FTPSSLAUTH: __anonenum_CURLoption_714703655 = 129;
pub const CURLOPT_TCP_NODELAY: __anonenum_CURLoption_714703655 = 121;
pub const CURLOPT_POSTFIELDSIZE_LARGE: __anonenum_CURLoption_714703655 = 30120;
pub const CURLOPT_USE_SSL: __anonenum_CURLoption_714703655 = 119;
pub const CURLOPT_NETRC_FILE: __anonenum_CURLoption_714703655 = 10118;
pub const CURLOPT_MAXFILESIZE_LARGE: __anonenum_CURLoption_714703655 = 30117;
pub const CURLOPT_RESUME_FROM_LARGE: __anonenum_CURLoption_714703655 = 30116;
pub const CURLOPT_INFILESIZE_LARGE: __anonenum_CURLoption_714703655 = 30115;
pub const CURLOPT_MAXFILESIZE: __anonenum_CURLoption_714703655 = 114;
pub const CURLOPT_IPRESOLVE: __anonenum_CURLoption_714703655 = 113;
pub const CURLOPT_FTP_RESPONSE_TIMEOUT: __anonenum_CURLoption_714703655 = 112;
pub const CURLOPT_PROXYAUTH: __anonenum_CURLoption_714703655 = 111;
pub const CURLOPT_FTP_CREATE_MISSING_DIRS: __anonenum_CURLoption_714703655 = 110;
pub const CURLOPT_SSL_CTX_DATA: __anonenum_CURLoption_714703655 = 10109;
pub const CURLOPT_SSL_CTX_FUNCTION: __anonenum_CURLoption_714703655 = 20108;
pub const CURLOPT_HTTPAUTH: __anonenum_CURLoption_714703655 = 107;
pub const CURLOPT_FTP_USE_EPRT: __anonenum_CURLoption_714703655 = 106;
pub const CURLOPT_UNRESTRICTED_AUTH: __anonenum_CURLoption_714703655 = 105;
pub const CURLOPT_HTTP200ALIASES: __anonenum_CURLoption_714703655 = 10104;
pub const CURLOPT_PRIVATE: __anonenum_CURLoption_714703655 = 10103;
pub const CURLOPT_ACCEPT_ENCODING: __anonenum_CURLoption_714703655 = 10102;
pub const CURLOPT_PROXYTYPE: __anonenum_CURLoption_714703655 = 101;
pub const CURLOPT_SHARE: __anonenum_CURLoption_714703655 = 10100;
pub const CURLOPT_NOSIGNAL: __anonenum_CURLoption_714703655 = 99;
pub const CURLOPT_BUFFERSIZE: __anonenum_CURLoption_714703655 = 98;
pub const CURLOPT_CAPATH: __anonenum_CURLoption_714703655 = 10097;
pub const CURLOPT_COOKIESESSION: __anonenum_CURLoption_714703655 = 96;
pub const CURLOPT_DEBUGDATA: __anonenum_CURLoption_714703655 = 10095;
pub const CURLOPT_DEBUGFUNCTION: __anonenum_CURLoption_714703655 = 20094;
pub const CURLOPT_PREQUOTE: __anonenum_CURLoption_714703655 = 10093;
pub const CURLOPT_DNS_CACHE_TIMEOUT: __anonenum_CURLoption_714703655 = 92;
pub const CURLOPT_DNS_USE_GLOBAL_CACHE: __anonenum_CURLoption_714703655 = 91;
pub const CURLOPT_SSLENGINE_DEFAULT: __anonenum_CURLoption_714703655 = 90;
pub const CURLOPT_SSLENGINE: __anonenum_CURLoption_714703655 = 10089;
pub const CURLOPT_SSLKEYTYPE: __anonenum_CURLoption_714703655 = 10088;
pub const CURLOPT_SSLKEY: __anonenum_CURLoption_714703655 = 10087;
pub const CURLOPT_SSLCERTTYPE: __anonenum_CURLoption_714703655 = 10086;
pub const CURLOPT_FTP_USE_EPSV: __anonenum_CURLoption_714703655 = 85;
pub const CURLOPT_HTTP_VERSION: __anonenum_CURLoption_714703655 = 84;
pub const CURLOPT_SSL_CIPHER_LIST: __anonenum_CURLoption_714703655 = 10083;
pub const CURLOPT_COOKIEJAR: __anonenum_CURLoption_714703655 = 10082;
pub const CURLOPT_SSL_VERIFYHOST: __anonenum_CURLoption_714703655 = 81;
pub const CURLOPT_HTTPGET: __anonenum_CURLoption_714703655 = 80;
pub const CURLOPT_HEADERFUNCTION: __anonenum_CURLoption_714703655 = 20079;
pub const CURLOPT_CONNECTTIMEOUT: __anonenum_CURLoption_714703655 = 78;
pub const CURLOPT_EGDSOCKET: __anonenum_CURLoption_714703655 = 10077;
pub const CURLOPT_RANDOM_FILE: __anonenum_CURLoption_714703655 = 10076;
pub const CURLOPT_FORBID_REUSE: __anonenum_CURLoption_714703655 = 75;
pub const CURLOPT_FRESH_CONNECT: __anonenum_CURLoption_714703655 = 74;
pub const CURLOPT_OBSOLETE72: __anonenum_CURLoption_714703655 = 72;
pub const CURLOPT_MAXCONNECTS: __anonenum_CURLoption_714703655 = 71;
pub const CURLOPT_TELNETOPTIONS: __anonenum_CURLoption_714703655 = 10070;
pub const CURLOPT_FILETIME: __anonenum_CURLoption_714703655 = 69;
pub const CURLOPT_MAXREDIRS: __anonenum_CURLoption_714703655 = 68;
pub const CURLOPT_CAINFO: __anonenum_CURLoption_714703655 = 10065;
pub const CURLOPT_SSL_VERIFYPEER: __anonenum_CURLoption_714703655 = 64;
pub const CURLOPT_KRBLEVEL: __anonenum_CURLoption_714703655 = 10063;
pub const CURLOPT_INTERFACE: __anonenum_CURLoption_714703655 = 10062;
pub const CURLOPT_HTTPPROXYTUNNEL: __anonenum_CURLoption_714703655 = 61;
pub const CURLOPT_POSTFIELDSIZE: __anonenum_CURLoption_714703655 = 60;
pub const CURLOPT_PROXYPORT: __anonenum_CURLoption_714703655 = 59;
pub const CURLOPT_AUTOREFERER: __anonenum_CURLoption_714703655 = 58;
pub const CURLOPT_PROGRESSDATA: __anonenum_CURLoption_714703655 = 10057;
pub const CURLOPT_PROGRESSFUNCTION: __anonenum_CURLoption_714703655 = 20056;
pub const CURLOPT_PUT: __anonenum_CURLoption_714703655 = 54;
pub const CURLOPT_TRANSFERTEXT: __anonenum_CURLoption_714703655 = 53;
pub const CURLOPT_FOLLOWLOCATION: __anonenum_CURLoption_714703655 = 52;
pub const CURLOPT_NETRC: __anonenum_CURLoption_714703655 = 51;
pub const CURLOPT_APPEND: __anonenum_CURLoption_714703655 = 50;
pub const CURLOPT_DIRLISTONLY: __anonenum_CURLoption_714703655 = 48;
pub const CURLOPT_POST: __anonenum_CURLoption_714703655 = 47;
pub const CURLOPT_UPLOAD: __anonenum_CURLoption_714703655 = 46;
pub const CURLOPT_FAILONERROR: __anonenum_CURLoption_714703655 = 45;
pub const CURLOPT_NOBODY: __anonenum_CURLoption_714703655 = 44;
pub const CURLOPT_NOPROGRESS: __anonenum_CURLoption_714703655 = 43;
pub const CURLOPT_HEADER: __anonenum_CURLoption_714703655 = 42;
pub const CURLOPT_VERBOSE: __anonenum_CURLoption_714703655 = 41;
pub const CURLOPT_OBSOLETE40: __anonenum_CURLoption_714703655 = 10040;
pub const CURLOPT_POSTQUOTE: __anonenum_CURLoption_714703655 = 10039;
pub const CURLOPT_STDERR: __anonenum_CURLoption_714703655 = 10037;
pub const CURLOPT_CUSTOMREQUEST: __anonenum_CURLoption_714703655 = 10036;
pub const CURLOPT_TIMEVALUE: __anonenum_CURLoption_714703655 = 34;
pub const CURLOPT_TIMECONDITION: __anonenum_CURLoption_714703655 = 33;
pub const CURLOPT_SSLVERSION: __anonenum_CURLoption_714703655 = 32;
pub const CURLOPT_COOKIEFILE: __anonenum_CURLoption_714703655 = 10031;
pub const CURLOPT_HEADERDATA: __anonenum_CURLoption_714703655 = 10029;
pub const CURLOPT_QUOTE: __anonenum_CURLoption_714703655 = 10028;
pub const CURLOPT_CRLF: __anonenum_CURLoption_714703655 = 27;
pub const CURLOPT_KEYPASSWD: __anonenum_CURLoption_714703655 = 10026;
pub const CURLOPT_SSLCERT: __anonenum_CURLoption_714703655 = 10025;
pub const CURLOPT_HTTPPOST: __anonenum_CURLoption_714703655 = 10024;
pub const CURLOPT_HTTPHEADER: __anonenum_CURLoption_714703655 = 10023;
pub const CURLOPT_COOKIE: __anonenum_CURLoption_714703655 = 10022;
pub const CURLOPT_RESUME_FROM: __anonenum_CURLoption_714703655 = 21;
pub const CURLOPT_LOW_SPEED_TIME: __anonenum_CURLoption_714703655 = 20;
pub const CURLOPT_LOW_SPEED_LIMIT: __anonenum_CURLoption_714703655 = 19;
pub const CURLOPT_USERAGENT: __anonenum_CURLoption_714703655 = 10018;
pub const CURLOPT_FTPPORT: __anonenum_CURLoption_714703655 = 10017;
pub const CURLOPT_REFERER: __anonenum_CURLoption_714703655 = 10016;
pub const CURLOPT_POSTFIELDS: __anonenum_CURLoption_714703655 = 10015;
pub const CURLOPT_INFILESIZE: __anonenum_CURLoption_714703655 = 14;
pub const CURLOPT_TIMEOUT: __anonenum_CURLoption_714703655 = 13;
pub const CURLOPT_READFUNCTION: __anonenum_CURLoption_714703655 = 20012;
pub const CURLOPT_WRITEFUNCTION: __anonenum_CURLoption_714703655 = 20011;
pub const CURLOPT_ERRORBUFFER: __anonenum_CURLoption_714703655 = 10010;
pub const CURLOPT_READDATA: __anonenum_CURLoption_714703655 = 10009;
pub const CURLOPT_RANGE: __anonenum_CURLoption_714703655 = 10007;
pub const CURLOPT_PROXYUSERPWD: __anonenum_CURLoption_714703655 = 10006;
pub const CURLOPT_USERPWD: __anonenum_CURLoption_714703655 = 10005;
pub const CURLOPT_PROXY: __anonenum_CURLoption_714703655 = 10004;
pub const CURLOPT_PORT: __anonenum_CURLoption_714703655 = 3;
pub const CURLOPT_URL: __anonenum_CURLoption_714703655 = 10002;
pub const CURLOPT_WRITEDATA: __anonenum_CURLoption_714703655 = 10001;
pub type CURLoption = __anonenum_CURLoption_714703655;
pub type BarSortFunc_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_buffer_653462436 {
    pub data: *mut libc::c_char,
    pub pos: size_t,
}
pub type buffer = __anonstruct_buffer_653462436;
pub type __suseconds_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type time_t = __time_t;
pub type int32_t = __int32_t;
pub type json_bool = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_PianoRequestDataAddFeedback_t_546671994 {
    pub stationId: *mut libc::c_char,
    pub trackToken: *mut libc::c_char,
    pub rating: PianoSongRating_t,
}
pub type PianoRequestDataAddFeedback_t = __anonstruct_PianoRequestDataAddFeedback_t_546671994;
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    let mut tmp: libc::c_long = 0;
    tmp = strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
    return tmp as libc::c_int;
}
#[inline]
unsafe extern "C" fn atof(mut __nptr: *const libc::c_char) -> libc::c_double {
    let mut tmp: libc::c_double = 0.;
    tmp = strtod(__nptr, 0 as *mut libc::c_void as *mut *mut libc::c_char);
    return tmp;
}
#[inline]
unsafe extern "C" fn vprintf(
    mut __fmt: *const libc::c_char,
    mut __arg: ::std::ffi::VaList,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = vfprintf(stdout, __fmt, __arg.as_va_list());
    return tmp;
}
#[inline]
unsafe extern "C" fn putchar(mut __c: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = putc(__c, stdout);
    return tmp;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    let mut tmp: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___0: __int32_t = 0;
    if __c >= -(128 as libc::c_int) {
        if __c < 256 as libc::c_int {
            tmp = __ctype_tolower_loc();
            tmp___0 = *(*tmp).offset(__c as isize);
        } else {
            tmp___0 = __c;
        }
    } else {
        tmp___0 = __c;
    }
    return tmp___0;
}
#[inline]
unsafe extern "C" fn stat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __xstat(1 as libc::c_int, __path, __statbuf);
    return tmp;
}
#[inline]
unsafe extern "C" fn fstat(
    mut __fd: libc::c_int,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = __fxstat(1 as libc::c_int, __fd, __statbuf);
    return tmp;
}
#[inline]
unsafe extern "C" fn debugEnable() -> bool {
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn BarMainLoginUser(mut app___0: *mut BarApp_t) -> bool {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataLogin_t = PianoRequestDataLogin_t {
        user: 0 as *mut libc::c_char,
        password: 0 as *mut libc::c_char,
        step: 0,
    };
    let mut ret: bool = false;
    reqData.user = (*app___0).settings.username;
    reqData.password = (*app___0).settings.password;
    reqData.step = 0 as libc::c_int as libc::c_uchar;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Login... \0" as *const u8 as *const libc::c_char,
    );
    ret = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_LOGIN,
        &mut reqData as *mut PianoRequestDataLogin_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"userlogin\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void as *const PianoStation_t,
        0 as *mut libc::c_void as *const PianoSong_t,
        &mut (*app___0).player,
        0 as *mut libc::c_void as *mut PianoStation_t,
        pRet,
        wRet,
    );
    return ret;
}
unsafe extern "C" fn BarMainGetLoginCredentials(
    mut settings: *mut BarSettings_t,
    mut input: *mut BarReadlineFds_t,
) -> bool {
    let mut usernameFromConfig: bool = false;
    let mut nameBuf: [libc::c_char; 100] = [0; 100];
    let mut tmp: size_t = 0;
    let mut passBuf: [libc::c_char; 100] = [0; 100];
    let mut tmp___0: size_t = 0;
    let mut chld: pid_t = 0;
    let mut pipeFd: [libc::c_int; 2] = [0; 2];
    let mut tmp___1: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut status: libc::c_int = 0;
    let mut len: ssize_t = 0;
    let mut tmp___9: size_t = 0;
    usernameFromConfig = 1 as libc::c_int != 0;
    if (*settings).username as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        BarUiMsg(
            settings as *const BarSettings_t,
            MSG_QUESTION,
            b"Email: \0" as *const u8 as *const libc::c_char,
        );
        tmp = BarReadlineStr(
            nameBuf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            input,
            BAR_RL_DEFAULT,
        );
        if tmp == 0 as libc::c_ulong {
            return 0 as libc::c_int != 0;
        }
        (*settings).username = strdup(nameBuf.as_mut_ptr() as *const libc::c_char);
        usernameFromConfig = 0 as libc::c_int != 0;
    }
    if (*settings).password as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        if usernameFromConfig {
            BarUiMsg(
                settings as *const BarSettings_t,
                MSG_QUESTION,
                b"Email: %s\n\0" as *const u8 as *const libc::c_char,
                (*settings).username,
            );
        }
        if (*settings).passwordCmd as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            BarUiMsg(
                settings as *const BarSettings_t,
                MSG_QUESTION,
                b"Password: \0" as *const u8 as *const libc::c_char,
            );
            tmp___0 = BarReadlineStr(
                passBuf.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
                input,
                BAR_RL_NOECHO,
            );
            if tmp___0 == 0 as libc::c_ulong {
                puts(b"\0" as *const u8 as *const libc::c_char);
                return 0 as libc::c_int != 0;
            }
            puts(b"\0" as *const u8 as *const libc::c_char);
            (*settings).password = strdup(passBuf.as_mut_ptr() as *const libc::c_char);
        } else {
            BarUiMsg(
                settings as *const BarSettings_t,
                MSG_INFO,
                b"Requesting password from external helper... \0" as *const u8
                    as *const libc::c_char,
            );
            tmp___3 = pipe(pipeFd.as_mut_ptr());
            if tmp___3 == -(1 as libc::c_int) {
                tmp___1 = __errno_location();
                tmp___2 = strerror(*tmp___1);
                BarUiMsg(
                    settings as *const BarSettings_t,
                    MSG_NONE,
                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                    tmp___2,
                );
                return 0 as libc::c_int != 0;
            }
            chld = fork();
            if chld == 0 as libc::c_int {
                close(pipeFd[0 as libc::c_int as usize]);
                tmp___4 = fileno(stdout);
                dup2(pipeFd[1 as libc::c_int as usize], tmp___4);
                execl(
                    b"/bin/sh\0" as *const u8 as *const libc::c_char,
                    b"/bin/sh\0" as *const u8 as *const libc::c_char,
                    b"-c\0" as *const u8 as *const libc::c_char,
                    (*settings).passwordCmd,
                    0 as *mut libc::c_void as *mut libc::c_char,
                );
                tmp___5 = __errno_location();
                tmp___6 = strerror(*tmp___5);
                BarUiMsg(
                    settings as *const BarSettings_t,
                    MSG_NONE,
                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                    tmp___6,
                );
                close(pipeFd[1 as libc::c_int as usize]);
                exit(1 as libc::c_int);
            } else {
                if chld == -(1 as libc::c_int) {
                    tmp___7 = __errno_location();
                    tmp___8 = strerror(*tmp___7);
                    BarUiMsg(
                        settings as *const BarSettings_t,
                        MSG_NONE,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        tmp___8,
                    );
                    return 0 as libc::c_int != 0;
                } else {
                    close(pipeFd[1 as libc::c_int as usize]);
                    memset(
                        passBuf.as_mut_ptr() as *mut libc::c_void,
                        0 as libc::c_int,
                        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
                    );
                    read(
                        pipeFd[0 as libc::c_int as usize],
                        passBuf.as_mut_ptr() as *mut libc::c_void,
                        (::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_ulong),
                    );
                    close(pipeFd[0 as libc::c_int as usize]);
                    tmp___9 = strlen(passBuf.as_mut_ptr() as *const libc::c_char);
                    len = tmp___9.wrapping_sub(1 as libc::c_ulong) as ssize_t;
                    while len >= 0 as libc::c_long {
                        if !(passBuf[len as usize] as libc::c_int == 10 as libc::c_int) {
                            break;
                        }
                        passBuf[len as usize] = '\u{0}' as i32 as libc::c_char;
                        len -= 1;
                    }
                    waitpid(chld, &mut status, 0 as libc::c_int);
                    if (status & 65280 as libc::c_int) >> 8 as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*settings)
                            .password = strdup(
                            passBuf.as_mut_ptr() as *const libc::c_char,
                        );
                        BarUiMsg(
                            settings as *const BarSettings_t,
                            MSG_NONE,
                            b"Ok.\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        BarUiMsg(
                            settings as *const BarSettings_t,
                            MSG_NONE,
                            b"Error: Exit status %i.\n\0" as *const u8
                                as *const libc::c_char,
                            (status & 65280 as libc::c_int) >> 8 as libc::c_int,
                        );
                        return 0 as libc::c_int != 0;
                    }
                }
            }
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn BarMainGetStations(mut app___0: *mut BarApp_t) -> bool {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut ret: bool = false;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Get stations... \0" as *const u8 as *const libc::c_char,
    );
    ret = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_GET_STATIONS,
        0 as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"usergetstations\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void as *const PianoStation_t,
        0 as *mut libc::c_void as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
    return ret;
}
unsafe extern "C" fn BarMainGetInitialStation(mut app___0: *mut BarApp_t) {
    if (*app___0).settings.autostartStation as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        (*app___0)
            .nextStation = PianoFindStationById(
            (*app___0).ph.stations,
            (*app___0).settings.autostartStation as *const libc::c_char,
        );
        if (*app___0).nextStation as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            BarUiMsg(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_ERR,
                b"Error: Autostart station not found.\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if (*app___0).nextStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
    {
        (*app___0)
            .nextStation = BarUiSelectStation(
            app___0,
            (*app___0).ph.stations,
            b"Select station: \0" as *const u8 as *const libc::c_char,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(*mut BarApp_t, *mut libc::c_char) -> ()>,
            >(0 as *mut libc::c_void),
            (*app___0).settings.autoselect,
        );
    }
}
unsafe extern "C" fn BarMainHandleUserInput(mut app___0: *mut BarApp_t) {
    let mut buf: [libc::c_char; 2] = [0; 2];
    let mut tmp: size_t = 0;
    tmp = BarReadline(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
        0 as *mut libc::c_void as *const libc::c_char,
        &mut (*app___0).input,
        7 as BarReadlineFlags_t,
        1 as libc::c_int,
    );
    if tmp > 0 as libc::c_ulong {
        BarUiDispatch(
            app___0,
            buf[0 as libc::c_int as usize],
            (*app___0).curStation,
            (*app___0).playlist,
            1 as libc::c_int != 0,
            BAR_DC_GLOBAL,
        );
    }
}
unsafe extern "C" fn BarMainGetPlaylist(mut app___0: *mut BarApp_t) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataGetPlaylist_t = PianoRequestDataGetPlaylist_t {
        station: 0 as *mut PianoStation_t,
        quality: PIANO_AQ_UNKNOWN,
        retPlaylist: 0 as *mut PianoSong_t,
    };
    let mut tmp: bool = false;
    reqData.station = (*app___0).nextStation;
    reqData.quality = (*app___0).settings.audioQuality;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Receiving new playlist... \0" as *const u8 as *const libc::c_char,
    );
    tmp = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_GET_PLAYLIST,
        &mut reqData as *mut PianoRequestDataGetPlaylist_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    if tmp {
        (*app___0).playlist = reqData.retPlaylist;
        if (*app___0).playlist as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            BarUiMsg(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_INFO,
                b"No tracks left.\n\0" as *const u8 as *const libc::c_char,
            );
            (*app___0).nextStation = 0 as *mut libc::c_void as *mut PianoStation_t;
        }
    } else {
        (*app___0).nextStation = 0 as *mut libc::c_void as *mut PianoStation_t;
    }
    (*app___0).curStation = (*app___0).nextStation;
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"stationfetchplaylist\0" as *const u8 as *const libc::c_char,
        (*app___0).curStation as *const PianoStation_t,
        (*app___0).playlist as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
}
static mut httpPrefix: [libc::c_char; 8] = [
    'h' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    't' as i32 as libc::c_char,
    'p' as i32 as libc::c_char,
    ':' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '/' as i32 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];
unsafe extern "C" fn BarMainStartPlayback(
    mut app___0: *mut BarApp_t,
    mut playerThread: *mut pthread_t,
) {
    let mut curSong: *const PianoSong_t = 0 as *const PianoSong_t;
    let mut tmp: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___0: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: libc::c_int = 0;
    curSong = (*app___0).playlist as *const PianoSong_t;
    if (*(*app___0).curStation).isQuickMix != 0 {
        tmp = PianoFindStationById(
            (*app___0).ph.stations,
            (*curSong).stationId as *const libc::c_char,
        );
        tmp___0 = tmp;
    } else {
        tmp___0 = 0 as *mut libc::c_void as *mut PianoStation_t;
    }
    BarUiPrintSong(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        curSong,
        tmp___0 as *const PianoStation_t,
    );
    if (*curSong).audioUrl as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_ERR,
            b"Invalid song url.\n\0" as *const u8 as *const libc::c_char,
        );
    } else {
        tmp___1 = strlen(httpPrefix.as_ptr());
        tmp___2 = strncmp(
            (*curSong).audioUrl as *const libc::c_char,
            httpPrefix.as_ptr(),
            tmp___1,
        );
        if tmp___2 != 0 as libc::c_int {
            BarUiMsg(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_ERR,
                b"Invalid song url.\n\0" as *const u8 as *const libc::c_char,
            );
        } else {
            player = &mut (*app___0).player;
            BarPlayerReset(player);
            (*app___0).player.url = (*curSong).audioUrl;
            (*app___0).player.gain = (*curSong).fileGain as libc::c_double;
            (*app___0).player.songDuration = (*curSong).length;
            interrupted = &mut (*app___0).player.interrupted;
            BarUiStartEventCmd(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                b"songstart\0" as *const u8 as *const libc::c_char,
                (*app___0).curStation as *const PianoStation_t,
                curSong,
                &mut (*app___0).player,
                (*app___0).ph.stations,
                PIANO_RET_OK,
                CURLE_OK,
            );
            (*app___0).player.mode = PLAYER_WAITING;
            pthread_create(
                playerThread,
                0 as *mut libc::c_void as *const pthread_attr_t,
                Some(
                    BarPlayerThread
                        as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
                ),
                &mut (*app___0).player as *mut player_t as *mut libc::c_void,
            );
        }
    };
}
unsafe extern "C" fn BarMainPlayerCleanup(
    mut app___0: *mut BarApp_t,
    mut playerThread: *mut pthread_t,
) {
    let mut threadRet: *mut libc::c_void = 0 as *mut libc::c_void;
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"songfinish\0" as *const u8 as *const libc::c_char,
        (*app___0).curStation as *const PianoStation_t,
        (*app___0).playlist as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        PIANO_RET_OK,
        CURLE_OK,
    );
    pthread_join(*playerThread, &mut threadRet);
    if threadRet as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*app___0).playerErrors = 0 as libc::c_uint;
    } else if threadRet as libc::c_ulong
            == 2 as libc::c_int as *mut libc::c_void as libc::c_ulong
        {
        (*app___0).playerErrors = ((*app___0).playerErrors).wrapping_add(1);
        if (*app___0).playerErrors >= (*app___0).settings.maxRetry {
            (*app___0).nextStation = 0 as *mut libc::c_void as *mut PianoStation_t;
        }
    } else {
        (*app___0).nextStation = 0 as *mut libc::c_void as *mut PianoStation_t;
    }
    interrupted = &mut (*app___0).doQuit;
    (*app___0).player.mode = PLAYER_DEAD;
}
unsafe extern "C" fn BarMainPrintTime(mut app___0: *mut BarApp_t) {
    let mut songRemaining: libc::c_uint = 0;
    let mut sign: [libc::c_char; 2] = [0; 2];
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut songDuration: libc::c_uint = 0;
    let mut songPlayed: libc::c_uint = 0;
    let mut outstr: [libc::c_char; 512] = [0; 512];
    let mut totalFormatted: [libc::c_char; 16] = [0; 16];
    let mut remainingFormatted: [libc::c_char; 16] = [0; 16];
    let mut elapsedFormatted: [libc::c_char; 16] = [0; 16];
    let mut vals: [*const libc::c_char; 4] = [0 as *const libc::c_char; 4];
    sign[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    sign[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    player = &mut (*app___0).player;
    pthread_mutex_lock(&mut (*player).lock);
    songDuration = (*player).songDuration;
    songPlayed = (*player).songPlayed;
    pthread_mutex_unlock(&mut (*player).lock);
    if songPlayed <= songDuration {
        songRemaining = songDuration.wrapping_sub(songPlayed);
        sign[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
    } else {
        songRemaining = songPlayed.wrapping_sub(songDuration);
        sign[0 as libc::c_int as usize] = '+' as i32 as libc::c_char;
    }
    vals[0 as libc::c_int as usize] = totalFormatted.as_mut_ptr() as *const libc::c_char;
    vals[1 as libc::c_int
        as usize] = remainingFormatted.as_mut_ptr() as *const libc::c_char;
    vals[2 as libc::c_int
        as usize] = elapsedFormatted.as_mut_ptr() as *const libc::c_char;
    vals[3 as libc::c_int as usize] = sign.as_mut_ptr() as *const libc::c_char;
    snprintf(
        totalFormatted.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%02u:%02u\0" as *const u8 as *const libc::c_char,
        songDuration.wrapping_div(60 as libc::c_uint),
        songDuration.wrapping_rem(60 as libc::c_uint),
    );
    snprintf(
        remainingFormatted.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%02u:%02u\0" as *const u8 as *const libc::c_char,
        songRemaining.wrapping_div(60 as libc::c_uint),
        songRemaining.wrapping_rem(60 as libc::c_uint),
    );
    snprintf(
        elapsedFormatted.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%02u:%02u\0" as *const u8 as *const libc::c_char,
        songPlayed.wrapping_div(60 as libc::c_uint),
        songPlayed.wrapping_rem(60 as libc::c_uint),
    );
    BarUiCustomFormat(
        outstr.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
        (*app___0).settings.timeFormat as *const libc::c_char,
        b"tres\0" as *const u8 as *const libc::c_char,
        vals.as_mut_ptr(),
    );
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_TIME,
        b"%s\r\0" as *const u8 as *const libc::c_char,
        outstr.as_mut_ptr(),
    );
}
unsafe extern "C" fn BarMainLoop(mut app___0: *mut BarApp_t) {
    let mut playerThread: pthread_t = 0;
    let mut tmp: bool = false;
    let mut tmp___0: bool = false;
    let mut tmp___1: bool = false;
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut tmp___2: BarPlayerMode = PLAYER_DEAD;
    let mut histsong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___3: BarPlayerMode = PLAYER_DEAD;
    let mut tmp___4: BarPlayerMode = PLAYER_DEAD;
    let mut tmp___5: BarPlayerMode = PLAYER_DEAD;
    tmp = BarMainGetLoginCredentials(&mut (*app___0).settings, &mut (*app___0).input);
    if !tmp {
        return;
    }
    tmp___0 = BarMainLoginUser(app___0);
    if !tmp___0 {
        return;
    }
    tmp___1 = BarMainGetStations(app___0);
    if !tmp___1 {
        return;
    }
    BarMainGetInitialStation(app___0);
    player = &mut (*app___0).player;
    while (*app___0).doQuit == 0 {
        tmp___2 = BarPlayerGetMode(player);
        if tmp___2 as libc::c_uint == 3 as libc::c_uint {
            if (*player).interrupted != 0 as libc::c_int {
                (*app___0).doQuit = 1 as libc::c_int;
            }
            BarMainPlayerCleanup(app___0, &mut playerThread);
        }
        tmp___3 = BarPlayerGetMode(player);
        if tmp___3 as libc::c_uint == 0 as libc::c_uint {
            if (*app___0).playlist as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                histsong = (*app___0).playlist;
                if (*app___0).playlist as libc::c_ulong
                    == 0 as *mut libc::c_void as libc::c_ulong
                {
                    (*app___0).playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                } else {
                    (*app___0)
                        .playlist = (*(*app___0).playlist).head.next as *mut libc::c_void
                        as *mut PianoSong_t;
                }
                (*histsong).head.next = 0 as *mut libc::c_void as *mut PianoListHead;
                BarUiHistoryPrepend(app___0, histsong);
            }
            if (*app___0).playlist as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                if (*app___0).nextStation as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    if (*app___0).doQuit == 0 {
                        if (*app___0).nextStation as libc::c_ulong
                            != (*app___0).curStation as libc::c_ulong
                        {
                            BarUiPrintStation(
                                &mut (*app___0).settings as *mut BarSettings_t
                                    as *const BarSettings_t,
                                (*app___0).nextStation,
                            );
                        }
                        BarMainGetPlaylist(app___0);
                    }
                }
            }
            if (*app___0).playlist as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                BarMainStartPlayback(app___0, &mut playerThread);
            }
        }
        BarMainHandleUserInput(app___0);
        tmp___4 = BarPlayerGetMode(player);
        if tmp___4 as libc::c_uint == 2 as libc::c_uint {
            BarMainPrintTime(app___0);
        }
    }
    tmp___5 = BarPlayerGetMode(player);
    if tmp___5 as libc::c_uint != 0 as libc::c_uint {
        pthread_join(playerThread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
    }
}
pub static mut interrupted: *mut sig_atomic_t = 0 as *const libc::c_void
    as *mut libc::c_void as *mut sig_atomic_t;
unsafe extern "C" fn intHandler(mut signal___0: libc::c_int) {
    if interrupted as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        *interrupted += 1;
    }
}
unsafe extern "C" fn BarMainSetupSigaction() {
    let mut act: sigaction = sigaction {
        __sigaction_handler: __anonunion___sigaction_handler_363639592 {
            sa_handler: None,
        },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    act
        .__sigaction_handler
        .sa_handler = Some(intHandler as unsafe extern "C" fn(libc::c_int) -> ());
    act.sa_mask.__val[0 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[1 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[2 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[3 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[4 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[5 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[6 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[7 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[8 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[9 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[10 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[11 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[12 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[13 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[14 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_mask.__val[15 as libc::c_int as usize] = 0 as libc::c_ulong;
    act.sa_flags = 0 as libc::c_int;
    act.sa_restorer = None;
    sigemptyset(&mut act.sa_mask);
    sigaction(
        2 as libc::c_int,
        &mut act as *mut sigaction as *const sigaction,
        0 as *mut libc::c_void as *mut sigaction,
    );
}
static mut app: BarApp_t = BarApp_t {
    ph: PianoHandle_t {
        user: PianoUserInfo_t {
            listenerId: 0 as *const libc::c_char as *mut libc::c_char,
            authToken: 0 as *const libc::c_char as *mut libc::c_char,
        },
        stations: 0 as *const PianoStation_t as *mut PianoStation_t,
        genreStations: 0 as *const PianoGenreCategory_t as *mut PianoGenreCategory_t,
        partner: PianoPartner_t {
            in_0: 0 as *const gcry_cipher_handle as *mut gcry_cipher_handle,
            out: 0 as *const gcry_cipher_handle as *mut gcry_cipher_handle,
            authToken: 0 as *const libc::c_char as *mut libc::c_char,
            device: 0 as *const libc::c_char as *mut libc::c_char,
            user: 0 as *const libc::c_char as *mut libc::c_char,
            password: 0 as *const libc::c_char as *mut libc::c_char,
            id: 0,
        },
        timeOffset: 0,
    },
    http: 0 as *const libc::c_void as *mut libc::c_void,
    player: player_t {
        lock: __anonunion_pthread_mutex_t_335460617 {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                },
            },
        },
        aoplayLock: __anonunion_pthread_mutex_t_335460617 {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                },
            },
        },
        cond: __anonunion_pthread_cond_t_951761805 {
            __data: __pthread_cond_s {
                __annonCompField1: __anonunion____missing_field_name_606137648 {
                    __wseq: 0,
                },
                __annonCompField2: __anonunion____missing_field_name_327815072 {
                    __g1_start: 0,
                },
                __g_refs: [0; 2],
                __g_size: [0; 2],
                __g1_orig_size: 0,
                __wrefs: 0,
                __g_signals: [0; 2],
            },
        },
        aoplayCond: __anonunion_pthread_cond_t_951761805 {
            __data: __pthread_cond_s {
                __annonCompField1: __anonunion____missing_field_name_606137648 {
                    __wseq: 0,
                },
                __annonCompField2: __anonunion____missing_field_name_327815072 {
                    __g1_start: 0,
                },
                __g_refs: [0; 2],
                __g_size: [0; 2],
                __g1_orig_size: 0,
                __wrefs: 0,
                __g_signals: [0; 2],
            },
        },
        doQuit: false,
        doPause: false,
        songDuration: 0,
        songPlayed: 0,
        mode: PLAYER_DEAD,
        fvolume: 0 as *const AVFilterContext as *mut AVFilterContext,
        fgraph: 0 as *const AVFilterGraph as *mut AVFilterGraph,
        fctx: 0 as *const AVFormatContext as *mut AVFormatContext,
        st: 0 as *const AVStream as *mut AVStream,
        cctx: 0 as *const AVCodecContext as *mut AVCodecContext,
        fbufsink: 0 as *const AVFilterContext as *mut AVFilterContext,
        fabuf: 0 as *const AVFilterContext as *mut AVFilterContext,
        streamIdx: 0,
        lastTimestamp: 0,
        interrupted: 0,
        aoDev: 0 as *const ao_device as *mut ao_device,
        gain: 0.,
        url: 0 as *const libc::c_char as *mut libc::c_char,
        settings: 0 as *const BarSettings_t,
    },
    settings: BarSettings_t {
        autoselect: false,
        history: 0,
        maxRetry: 0,
        timeout: 0,
        bufferSecs: 0,
        volume: 0,
        gainMul: 0.,
        sortOrder: BAR_SORT_NAME_AZ,
        audioQuality: PIANO_AQ_UNKNOWN,
        username: 0 as *const libc::c_char as *mut libc::c_char,
        password: 0 as *const libc::c_char as *mut libc::c_char,
        passwordCmd: 0 as *const libc::c_char as *mut libc::c_char,
        controlProxy: 0 as *const libc::c_char as *mut libc::c_char,
        proxy: 0 as *const libc::c_char as *mut libc::c_char,
        bindTo: 0 as *const libc::c_char as *mut libc::c_char,
        autostartStation: 0 as *const libc::c_char as *mut libc::c_char,
        eventCmd: 0 as *const libc::c_char as *mut libc::c_char,
        loveIcon: 0 as *const libc::c_char as *mut libc::c_char,
        banIcon: 0 as *const libc::c_char as *mut libc::c_char,
        tiredIcon: 0 as *const libc::c_char as *mut libc::c_char,
        atIcon: 0 as *const libc::c_char as *mut libc::c_char,
        npSongFormat: 0 as *const libc::c_char as *mut libc::c_char,
        npStationFormat: 0 as *const libc::c_char as *mut libc::c_char,
        listSongFormat: 0 as *const libc::c_char as *mut libc::c_char,
        timeFormat: 0 as *const libc::c_char as *mut libc::c_char,
        fifo: 0 as *const libc::c_char as *mut libc::c_char,
        rpcHost: 0 as *const libc::c_char as *mut libc::c_char,
        rpcTlsPort: 0 as *const libc::c_char as *mut libc::c_char,
        partnerUser: 0 as *const libc::c_char as *mut libc::c_char,
        partnerPassword: 0 as *const libc::c_char as *mut libc::c_char,
        device: 0 as *const libc::c_char as *mut libc::c_char,
        inkey: 0 as *const libc::c_char as *mut libc::c_char,
        outkey: 0 as *const libc::c_char as *mut libc::c_char,
        caBundle: 0 as *const libc::c_char as *mut libc::c_char,
        audioPipe: 0 as *const libc::c_char as *mut libc::c_char,
        keys: [0; 30],
        sampleRate: 0,
        msgFormat: [BarMsgFormatStr_t {
            prefix: 0 as *const libc::c_char as *mut libc::c_char,
            postfix: 0 as *const libc::c_char as *mut libc::c_char,
        }; 7],
    },
    playlist: 0 as *const PianoSong_t as *mut PianoSong_t,
    songHistory: 0 as *const PianoSong_t as *mut PianoSong_t,
    curStation: 0 as *const PianoStation_t as *mut PianoStation_t,
    nextStation: 0 as *const PianoStation_t as *mut PianoStation_t,
    doQuit: 0,
    input: BarReadlineFds_t {
        set: fd_set { __fds_bits: [0; 16] },
        maxfd: 0,
        fds: [0; 2],
    },
    playerErrors: 0,
};
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pret: PianoReturn_t = PIANO_RET_ERR;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut __d0: libc::c_int = 0;
    let mut __d1: libc::c_int = 0;
    let mut s: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    debugEnable();
    memset(
        &mut app as *mut BarApp_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<BarApp_t>() as libc::c_ulong,
    );
    BarTermInit();
    signal(
        13 as libc::c_int,
        ::std::mem::transmute::<
            libc::intptr_t,
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        >(1 as libc::c_int as libc::intptr_t),
    );
    BarMainSetupSigaction();
    interrupted = &mut app.doQuit;
    gcry_check_version(0 as *mut libc::c_void as *const libc::c_char);
    gcry_control(GCRYCTL_DISABLE_SECMEM, 0 as libc::c_int);
    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0 as libc::c_int);
    BarPlayerInit(
        &mut app.player as *mut player_t,
        &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
    );
    BarSettingsInit(&mut app.settings);
    BarSettingsRead(&mut app.settings);
    pret = PianoInit(
        &mut app.ph,
        app.settings.partnerUser as *const libc::c_char,
        app.settings.partnerPassword as *const libc::c_char,
        app.settings.device as *const libc::c_char,
        app.settings.inkey as *const libc::c_char,
        app.settings.outkey as *const libc::c_char,
    );
    if pret as libc::c_uint != 1 as libc::c_uint {
        tmp = PianoErrorToStr(pret);
        BarUiMsg(
            &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_ERR,
            b"Initialization failed: %s\n\0" as *const u8 as *const libc::c_char,
            tmp,
        );
        return 0 as libc::c_int;
    }
    BarUiMsg(
        &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_NONE,
        b"Welcome to pianobar (2022.04.01-dev)! \0" as *const u8 as *const libc::c_char,
    );
    if app.settings.keys[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        BarUiMsg(
            &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_NONE,
            b"\n\0" as *const u8 as *const libc::c_char,
        );
    } else {
        BarUiMsg(
            &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_NONE,
            b"Press %c for a list of commands.\n\0" as *const u8 as *const libc::c_char,
            app.settings.keys[0 as libc::c_int as usize] as libc::c_int,
        );
    }
    curl_global_init(
        (1 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int) as libc::c_long,
    );
    app.http = curl_easy_init();
    let fresh0 = &mut __d0;
    let fresh1;
    let fresh2 = (::std::mem::size_of::<fd_set>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<__fd_mask>() as libc::c_ulong);
    let fresh3 = &mut __d1;
    let fresh4;
    let fresh5 = &mut *(app.input.set.__fds_bits)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut __fd_mask;
    asm!(
        "cld; rep; stosq", inlateout("cx") c2rust_asm_casts::AsmCast::cast_in(fresh0,
        fresh2) => fresh1, inlateout("di") c2rust_asm_casts::AsmCast::cast_in(fresh3,
        fresh5) => fresh4, inlateout("ax") 0 as libc::c_int => _,
        options(preserves_flags, att_syntax)
    );
    c2rust_asm_casts::AsmCast::cast_out(fresh0, fresh2, fresh1);
    c2rust_asm_casts::AsmCast::cast_out(fresh3, fresh5, fresh4);
    app.input.fds[0 as libc::c_int as usize] = 0 as libc::c_int;
    app
        .input
        .set
        .__fds_bits[(app.input.fds[0 as libc::c_int as usize]
        / (8 as libc::c_int
            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
        as usize]
        |= ((1 as libc::c_ulong)
            << app.input.fds[0 as libc::c_int as usize]
                % (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as __fd_mask;
    app
        .input
        .fds[1 as libc::c_int
        as usize] = open(app.settings.fifo as *const libc::c_char, 2 as libc::c_int);
    if app.input.fds[1 as libc::c_int as usize] != -(1 as libc::c_int) {
        fstat(app.input.fds[1 as libc::c_int as usize], &mut s);
        if !(s.st_mode & 61440 as libc::c_uint == 4096 as libc::c_uint) {
            BarUiMsg(
                &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_ERR,
                b"File at %s is not a fifo\n\0" as *const u8 as *const libc::c_char,
                app.settings.fifo,
            );
            close(app.input.fds[1 as libc::c_int as usize]);
            app.input.fds[1 as libc::c_int as usize] = -(1 as libc::c_int);
        } else {
            app
                .input
                .set
                .__fds_bits[(app.input.fds[1 as libc::c_int as usize]
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                |= ((1 as libc::c_ulong)
                    << app.input.fds[1 as libc::c_int as usize]
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask;
            BarUiMsg(
                &mut app.settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_INFO,
                b"Control fifo at %s opened\n\0" as *const u8 as *const libc::c_char,
                app.settings.fifo,
            );
        }
    }
    if app.input.fds[0 as libc::c_int as usize]
        > app.input.fds[1 as libc::c_int as usize]
    {
        app.input.maxfd = app.input.fds[0 as libc::c_int as usize];
    } else {
        app.input.maxfd = app.input.fds[1 as libc::c_int as usize];
    }
    app.input.maxfd += 1;
    BarMainLoop(&mut app);
    if app.input.fds[1 as libc::c_int as usize] != -(1 as libc::c_int) {
        close(app.input.fds[1 as libc::c_int as usize]);
    }
    BarSettingsWrite(app.curStation, &mut app.settings);
    PianoDestroy(&mut app.ph);
    PianoDestroyPlaylist(app.songHistory);
    PianoDestroyPlaylist(app.playlist);
    curl_easy_cleanup(app.http);
    curl_global_cleanup();
    BarPlayerDestroy(&mut app.player as *mut player_t);
    BarSettingsDestroy(&mut app.settings);
    BarTermRestore();
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn av_q2d(mut a: AVRational) -> libc::c_double {
    return a.num as libc::c_double / a.den as libc::c_double;
}
pub static mut avformat: AVSampleFormat = AV_SAMPLE_FMT_S16;
unsafe extern "C" fn printError(
    settings: *const BarSettings_t,
    msg: *const libc::c_char,
    mut ret: libc::c_int,
) {
    let mut avmsg: [libc::c_char; 128] = [0; 128];
    av_strerror(
        ret,
        avmsg.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
    );
    BarUiMsg(
        settings,
        MSG_ERR,
        b"%s (%s)\n\0" as *const u8 as *const libc::c_char,
        msg,
        avmsg.as_mut_ptr(),
    );
}
pub unsafe extern "C" fn BarPlayerInit(
    p: *mut player_t,
    settings: *const BarSettings_t,
) {
    ao_initialize();
    av_log_set_level(8 as libc::c_int);
    pthread_mutex_init(
        &mut (*p).lock,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    pthread_cond_init(
        &mut (*p).cond as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    pthread_mutex_init(
        &mut (*p).aoplayLock,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    pthread_cond_init(
        &mut (*p).aoplayCond as *mut pthread_cond_t,
        0 as *mut libc::c_void as *const pthread_condattr_t,
    );
    BarPlayerReset(p);
    (*p).settings = settings;
}
pub unsafe extern "C" fn BarPlayerDestroy(p: *mut player_t) {
    pthread_cond_destroy(&mut (*p).cond);
    pthread_mutex_destroy(&mut (*p).lock);
    pthread_cond_destroy(&mut (*p).aoplayCond);
    pthread_mutex_destroy(&mut (*p).aoplayLock);
    ao_shutdown();
}
pub unsafe extern "C" fn BarPlayerReset(p: *mut player_t) {
    (*p).doQuit = 0 as libc::c_int != 0;
    (*p).doPause = 0 as libc::c_int != 0;
    (*p).songDuration = 0 as libc::c_uint;
    (*p).songPlayed = 0 as libc::c_uint;
    (*p).mode = PLAYER_DEAD;
    (*p).fvolume = 0 as *mut libc::c_void as *mut AVFilterContext;
    (*p).fgraph = 0 as *mut libc::c_void as *mut AVFilterGraph;
    (*p).fctx = 0 as *mut libc::c_void as *mut AVFormatContext;
    (*p).st = 0 as *mut libc::c_void as *mut AVStream;
    (*p).cctx = 0 as *mut libc::c_void as *mut AVCodecContext;
    (*p).fbufsink = 0 as *mut libc::c_void as *mut AVFilterContext;
    (*p).fabuf = 0 as *mut libc::c_void as *mut AVFilterContext;
    (*p).streamIdx = -(1 as libc::c_int);
    (*p).lastTimestamp = 0 as libc::c_int as int64_t;
    (*p).interrupted = 0 as libc::c_int;
    (*p).aoDev = 0 as *mut libc::c_void as *mut ao_device;
}
pub unsafe extern "C" fn BarPlayerSetVolume(player: *mut player_t) {
    let mut ret: libc::c_int = 0;
    let mut strbuf: [libc::c_char; 16] = [0; 16];
    if (*player).mode as libc::c_uint != 2 as libc::c_uint {
        return;
    }
    snprintf(
        strbuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%fdB\0" as *const u8 as *const libc::c_char,
        (*(*player).settings).volume as libc::c_double
            + (*player).gain * (*(*player).settings).gainMul as libc::c_double,
    );
    ret = avfilter_graph_send_command(
        (*player).fgraph,
        b"volume\0" as *const u8 as *const libc::c_char,
        b"volume\0" as *const u8 as *const libc::c_char,
        strbuf.as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void as *mut libc::c_char,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"Cannot set volume\0" as *const u8 as *const libc::c_char,
            ret,
        );
    }
}
unsafe extern "C" fn intCb(data: *mut libc::c_void) -> libc::c_int {
    let mut player: *mut player_t = 0 as *mut player_t;
    player = data as *mut player_t;
    if (*player).interrupted > 1 as libc::c_int {
        pthread_mutex_lock(&mut (*player).lock);
        (*player).doQuit = 1 as libc::c_int != 0;
        pthread_mutex_unlock(&mut (*player).lock);
        return 1 as libc::c_int;
    } else if (*player).interrupted != 0 as libc::c_int {
        (*player).interrupted = 0 as libc::c_int;
        return 1 as libc::c_int;
    } else {
        return 0 as libc::c_int
    };
}
unsafe extern "C" fn openStream(player: *mut player_t) -> bool {
    let mut ret: libc::c_int = 0;
    let mut timeout: libc::c_ulong = 0;
    let mut timeoutStr: [libc::c_char; 16] = [0; 16];
    let mut options: *mut AVDictionary = 0 as *mut AVDictionary;
    let mut i: size_t = 0;
    let mut tmp: *mut AVCodecContext = 0 as *mut AVCodecContext;
    let mut cp: *const AVCodecParameters = 0 as *const AVCodecParameters;
    let mut decoder: *mut AVCodec = 0 as *mut AVCodec;
    let mut tmp___0: *mut AVCodec = 0 as *mut AVCodec;
    let mut songDuration: libc::c_uint = 0;
    let mut tmp___1: libc::c_double = 0.;
    (*player).fctx = avformat_alloc_context();
    (*(*player).fctx)
        .interrupt_callback
        .callback = ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    >(Some(intCb as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int));
    (*(*player).fctx).interrupt_callback.opaque = player as *mut libc::c_void;
    timeout = ((*(*player).settings).timeout).wrapping_mul(1000000 as libc::c_uint)
        as libc::c_ulong;
    ret = snprintf(
        timeoutStr.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%lu\0" as *const u8 as *const libc::c_char,
        timeout,
    );
    options = 0 as *mut libc::c_void as *mut AVDictionary;
    av_dict_set(
        &mut options,
        b"timeout\0" as *const u8 as *const libc::c_char,
        timeoutStr.as_mut_ptr() as *const libc::c_char,
        0 as libc::c_int,
    );
    ret = avformat_open_input(
        &mut (*player).fctx,
        (*player).url as *const libc::c_char,
        0 as *mut libc::c_void as *mut AVInputFormat,
        &mut options,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"Unable to open audio file\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    ret = avformat_find_stream_info(
        (*player).fctx,
        0 as *mut libc::c_void as *mut *mut AVDictionary,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"find_stream_info\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as size_t;
    while i < (*(*player).fctx).nb_streams as size_t {
        (**((*(*player).fctx).streams).offset(i as isize)).discard = AVDISCARD_ALL;
        i = i.wrapping_add(1);
    }
    (*player)
        .streamIdx = av_find_best_stream(
        (*player).fctx,
        AVMEDIA_TYPE_AUDIO,
        -(1 as libc::c_int),
        -(1 as libc::c_int),
        0 as *mut libc::c_void as *mut *mut AVCodec,
        0 as libc::c_int,
    );
    if (*player).streamIdx < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"find_best_stream\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    (*player).st = *((*(*player).fctx).streams).offset((*player).streamIdx as isize);
    (*(*player).st).discard = AVDISCARD_DEFAULT;
    tmp = avcodec_alloc_context3(0 as *mut libc::c_void as *const AVCodec);
    (*player).cctx = tmp;
    if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        printError(
            (*player).settings,
            b"avcodec_alloc_context3\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    cp = (*(*player).st).codecpar as *const AVCodecParameters;
    ret = avcodec_parameters_to_context((*player).cctx, cp);
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"avcodec_parameters_to_context\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    tmp___0 = avcodec_find_decoder((*cp).codec_id);
    decoder = tmp___0;
    if decoder as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        printError(
            (*player).settings,
            b"find_decoder\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    ret = avcodec_open2(
        (*player).cctx,
        decoder as *const AVCodec,
        0 as *mut libc::c_void as *mut *mut AVDictionary,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"codec_open2\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    if (*player).lastTimestamp > 0 as libc::c_long {
        av_seek_frame(
            (*player).fctx,
            (*player).streamIdx,
            (*player).lastTimestamp,
            0 as libc::c_int,
        );
    }
    tmp___1 = av_q2d((*(*player).st).time_base);
    songDuration = (tmp___1 * (*(*player).st).duration as libc::c_double)
        as libc::c_uint;
    pthread_mutex_lock(&mut (*player).lock);
    (*player).songPlayed = 0 as libc::c_uint;
    (*player).songDuration = songDuration;
    pthread_mutex_unlock(&mut (*player).lock);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn getSampleRate(player: *const player_t) -> libc::c_int {
    let mut cp: *const AVCodecParameters = 0 as *const AVCodecParameters;
    let mut tmp: libc::c_int = 0;
    cp = (*(*player).st).codecpar as *const AVCodecParameters;
    if (*(*player).settings).sampleRate == 0 as libc::c_int {
        tmp = (*cp).sample_rate;
    } else {
        tmp = (*(*player).settings).sampleRate;
    }
    return tmp;
}
unsafe extern "C" fn openFilter(player: *mut player_t) -> bool {
    let mut strbuf: [libc::c_char; 256] = [0; 256];
    let mut ret: libc::c_int = 0;
    let mut cp: *mut AVCodecParameters = 0 as *mut AVCodecParameters;
    let mut tmp: *mut AVFilterGraph = 0 as *mut AVFilterGraph;
    let mut time_base: AVRational = AVRational { num: 0, den: 0 };
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const AVFilter = 0 as *const AVFilter;
    let mut tmp___2: *const AVFilter = 0 as *const AVFilter;
    let mut fafmt: *mut AVFilterContext = 0 as *mut AVFilterContext;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: *const AVFilter = 0 as *const AVFilter;
    let mut tmp___6: *const AVFilter = 0 as *const AVFilter;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    ret = 0 as libc::c_int;
    cp = (*(*player).st).codecpar;
    tmp = avfilter_graph_alloc();
    (*player).fgraph = tmp;
    if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        printError(
            (*player).settings,
            b"graph_alloc\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    time_base = (*(*player).st).time_base;
    tmp___0 = av_get_sample_fmt_name((*(*player).cctx).sample_fmt);
    snprintf(
        strbuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=0x%lx\0"
            as *const u8 as *const libc::c_char,
        time_base.num,
        time_base.den,
        (*cp).sample_rate,
        tmp___0,
        (*cp).channel_layout,
    );
    tmp___1 = avfilter_get_by_name(b"abuffer\0" as *const u8 as *const libc::c_char);
    ret = avfilter_graph_create_filter(
        &mut (*player).fabuf,
        tmp___1,
        b"source\0" as *const u8 as *const libc::c_char,
        strbuf.as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void,
        (*player).fgraph,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"create_filter abuffer\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    tmp___2 = avfilter_get_by_name(b"volume\0" as *const u8 as *const libc::c_char);
    ret = avfilter_graph_create_filter(
        &mut (*player).fvolume,
        tmp___2,
        b"volume\0" as *const u8 as *const libc::c_char,
        b"0dB\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void,
        (*player).fgraph,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"create_filter volume\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    fafmt = 0 as *mut libc::c_void as *mut AVFilterContext;
    tmp___3 = getSampleRate(player as *const player_t);
    tmp___4 = av_get_sample_fmt_name(avformat);
    snprintf(
        strbuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"sample_fmts=%s:sample_rates=%d\0" as *const u8 as *const libc::c_char,
        tmp___4,
        tmp___3,
    );
    tmp___5 = avfilter_get_by_name(b"aformat\0" as *const u8 as *const libc::c_char);
    ret = avfilter_graph_create_filter(
        &mut fafmt,
        tmp___5,
        b"format\0" as *const u8 as *const libc::c_char,
        strbuf.as_mut_ptr() as *const libc::c_char,
        0 as *mut libc::c_void,
        (*player).fgraph,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"create_filter aformat\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    tmp___6 = avfilter_get_by_name(b"abuffersink\0" as *const u8 as *const libc::c_char);
    ret = avfilter_graph_create_filter(
        &mut (*player).fbufsink,
        tmp___6,
        b"sink\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void as *const libc::c_char,
        0 as *mut libc::c_void,
        (*player).fgraph,
    );
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"create_filter abuffersink\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    tmp___7 = avfilter_link(
        (*player).fabuf,
        0 as libc::c_uint,
        (*player).fvolume,
        0 as libc::c_uint,
    );
    if tmp___7 != 0 as libc::c_int {
        printError(
            (*player).settings,
            b"filter_link\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    } else {
        tmp___8 = avfilter_link(
            (*player).fvolume,
            0 as libc::c_uint,
            fafmt,
            0 as libc::c_uint,
        );
        if tmp___8 != 0 as libc::c_int {
            printError(
                (*player).settings,
                b"filter_link\0" as *const u8 as *const libc::c_char,
                ret,
            );
            return 0 as libc::c_int != 0;
        } else {
            tmp___9 = avfilter_link(
                fafmt,
                0 as libc::c_uint,
                (*player).fbufsink,
                0 as libc::c_uint,
            );
            if tmp___9 != 0 as libc::c_int {
                printError(
                    (*player).settings,
                    b"filter_link\0" as *const u8 as *const libc::c_char,
                    ret,
                );
                return 0 as libc::c_int != 0;
            }
        }
    }
    ret = avfilter_graph_config((*player).fgraph, 0 as *mut libc::c_void);
    if ret < 0 as libc::c_int {
        printError(
            (*player).settings,
            b"graph_config\0" as *const u8 as *const libc::c_char,
            ret,
        );
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn openDevice(player: *mut player_t) -> bool {
    let mut cp: *const AVCodecParameters = 0 as *const AVCodecParameters;
    let mut aoFmt: ao_sample_format = ao_sample_format {
        bits: 0,
        rate: 0,
        channels: 0,
        byte_format: 0,
        matrix: 0 as *mut libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    let mut driver: libc::c_int = 0;
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut ao_device = 0 as *mut ao_device;
    let mut tmp___2: *mut ao_device = 0 as *mut ao_device;
    cp = (*(*player).st).codecpar as *const AVCodecParameters;
    memset(
        &mut aoFmt as *mut ao_sample_format as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ao_sample_format>() as libc::c_ulong,
    );
    tmp = av_get_bytes_per_sample(avformat);
    aoFmt.bits = tmp * 8 as libc::c_int;
    aoFmt.channels = (*cp).channels;
    aoFmt.rate = getSampleRate(player as *const player_t);
    aoFmt.byte_format = 4 as libc::c_int;
    driver = -(1 as libc::c_int);
    if !((*(*player).settings).audioPipe).is_null() {
        tmp___0 = stat(
            (*(*player).settings).audioPipe as *const libc::c_char,
            &mut st as *mut stat,
        );
        if tmp___0 != 0 {
            BarUiMsg(
                (*player).settings,
                MSG_ERR,
                b"Cannot stat audio pipe file.\n\0" as *const u8 as *const libc::c_char,
            );
            return 0 as libc::c_int != 0;
        }
        if !(st.st_mode & 61440 as libc::c_uint == 4096 as libc::c_uint) {
            BarUiMsg(
                (*player).settings,
                MSG_ERR,
                b"File is not a pipe, error.\n\0" as *const u8 as *const libc::c_char,
            );
            return 0 as libc::c_int != 0;
        }
        driver = ao_driver_id(b"raw\0" as *const u8 as *const libc::c_char);
        tmp___1 = ao_open_file(
            driver,
            (*(*player).settings).audioPipe as *const libc::c_char,
            1 as libc::c_int,
            &mut aoFmt,
            0 as *mut libc::c_void as *mut ao_option,
        );
        (*player).aoDev = tmp___1;
        if tmp___1 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            BarUiMsg(
                (*player).settings,
                MSG_ERR,
                b"Cannot open audio pipe file.\n\0" as *const u8 as *const libc::c_char,
            );
            return 0 as libc::c_int != 0;
        }
    } else {
        driver = ao_default_driver_id();
        tmp___2 = ao_open_live(
            driver,
            &mut aoFmt,
            0 as *mut libc::c_void as *mut ao_option,
        );
        (*player).aoDev = tmp___2;
        if tmp___2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            BarUiMsg(
                (*player).settings,
                MSG_ERR,
                b"Cannot open audio device.\n\0" as *const u8 as *const libc::c_char,
            );
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn shouldQuit(player: *mut player_t) -> bool {
    let mut ret: bool = false;
    pthread_mutex_lock(&mut (*player).lock);
    ret = (*player).doQuit;
    pthread_mutex_unlock(&mut (*player).lock);
    return ret;
}
unsafe extern "C" fn changeMode(player: *mut player_t, mut mode: libc::c_uint) {
    pthread_mutex_lock(&mut (*player).lock);
    (*player).mode = mode as BarPlayerMode;
    pthread_mutex_unlock(&mut (*player).lock);
}
pub unsafe extern "C" fn BarPlayerGetMode(player: *mut player_t) -> BarPlayerMode {
    let mut ret: BarPlayerMode = PLAYER_DEAD;
    pthread_mutex_lock(&mut (*player).lock);
    ret = (*player).mode;
    pthread_mutex_unlock(&mut (*player).lock);
    return ret;
}
unsafe extern "C" fn play(player: *mut player_t) -> libc::c_int {
    let mut minBufferHealth: int64_t = 0;
    let mut cctx: *mut AVCodecContext = 0 as *mut AVCodecContext;
    let mut pkt: *mut AVPacket = 0 as *mut AVPacket;
    let mut tmp: *mut AVPacket = 0 as *mut AVPacket;
    let mut frame: *mut AVFrame = 0 as *mut AVFrame;
    let mut aoplaythread: pthread_t = 0;
    let mut drainMode: __anonenum_drainMode_989564894 = FILL;
    let mut ret: libc::c_int = 0;
    let mut timeBase: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut rt: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut rt___0: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut bufferHealth: int64_t = 0;
    let mut tmp___3: bool = false;
    let mut tmp___4: bool = false;
    minBufferHealth = (*(*player).settings).bufferSecs as int64_t;
    cctx = (*player).cctx;
    tmp = av_packet_alloc();
    pkt = tmp;
    (*pkt).data = 0 as *mut libc::c_void as *mut uint8_t;
    (*pkt).size = 0 as libc::c_int;
    frame = 0 as *mut libc::c_void as *mut AVFrame;
    frame = av_frame_alloc();
    pthread_create(
        &mut aoplaythread as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        Some(
            BarAoPlayThread
                as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        ),
        player as *mut libc::c_void,
    );
    drainMode = FILL;
    ret = 0 as libc::c_int;
    tmp___0 = av_q2d((*(*player).st).time_base);
    timeBase = tmp___0;
    loop {
        tmp___4 = shouldQuit(player);
        if tmp___4 {
            break;
        }
        if !(drainMode as libc::c_uint != 2 as libc::c_uint) {
            break;
        }
        if drainMode as libc::c_uint == 0 as libc::c_uint {
            ret = av_read_frame((*player).fctx, pkt);
            if ret
                == -(((69 as libc::c_int | (79 as libc::c_int) << 8 as libc::c_int
                    | (70 as libc::c_int) << 16 as libc::c_int) as libc::c_uint
                    | (32 as libc::c_uint) << 24 as libc::c_int) as libc::c_int)
            {
                drainMode = DRAIN;
                avcodec_send_packet(cctx, 0 as *mut libc::c_void as *const AVPacket);
            } else if (*pkt).stream_index != (*player).streamIdx {
                av_packet_unref(pkt);
                continue;
            } else if ret < 0 as libc::c_int {
                pthread_mutex_lock(&mut (*player).aoplayLock);
                tmp___1 = av_buffersrc_add_frame(
                    (*player).fabuf,
                    0 as *mut libc::c_void as *mut AVFrame,
                );
                rt = tmp___1;
                pthread_cond_broadcast(&mut (*player).aoplayCond);
                pthread_mutex_unlock(&mut (*player).aoplayLock);
                break;
            } else {
                avcodec_send_packet(cctx, pkt as *const AVPacket);
            }
        }
        loop {
            tmp___3 = shouldQuit(player);
            if tmp___3 {
                break;
            }
            ret = avcodec_receive_frame(cctx, frame);
            if ret
                == -(((69 as libc::c_int | (79 as libc::c_int) << 8 as libc::c_int
                    | (70 as libc::c_int) << 16 as libc::c_int) as libc::c_uint
                    | (32 as libc::c_uint) << 24 as libc::c_int) as libc::c_int)
            {
                drainMode = DONE;
                pthread_mutex_lock(&mut (*player).aoplayLock);
                tmp___2 = av_buffersrc_add_frame(
                    (*player).fabuf,
                    0 as *mut libc::c_void as *mut AVFrame,
                );
                rt___0 = tmp___2;
                pthread_cond_broadcast(&mut (*player).aoplayCond);
                pthread_mutex_unlock(&mut (*player).aoplayLock);
                break;
            } else {
                if ret != 0 as libc::c_int {
                    break;
                }
                if (*frame).pts
                    == -(0x7fffffffffffffff as libc::c_long)
                        - 1 as libc::c_int as libc::c_long
                {
                    (*frame).pts = 0 as libc::c_int as int64_t;
                }
                pthread_mutex_lock(&mut (*player).aoplayLock);
                ret = av_buffersrc_write_frame((*player).fabuf, frame as *const AVFrame);
                pthread_mutex_unlock(&mut (*player).aoplayLock);
                bufferHealth = 0 as libc::c_int as int64_t;
                loop {
                    pthread_mutex_lock(&mut (*player).aoplayLock);
                    bufferHealth = (timeBase
                        * ((*frame).pts - (*player).lastTimestamp) as libc::c_double)
                        as int64_t;
                    if bufferHealth > minBufferHealth {
                        pthread_cond_broadcast(&mut (*player).aoplayCond);
                        pthread_cond_wait(
                            &mut (*player).aoplayCond as *mut pthread_cond_t,
                            &mut (*player).aoplayLock as *mut pthread_mutex_t,
                        );
                    }
                    pthread_mutex_unlock(&mut (*player).aoplayLock);
                    if !(bufferHealth > minBufferHealth) {
                        break;
                    }
                }
            }
        }
        av_packet_unref(pkt);
    }
    av_frame_free(&mut frame);
    av_packet_free(&mut pkt);
    pthread_join(aoplaythread, 0 as *mut libc::c_void as *mut *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn finish(player: *mut player_t) {
    ao_close((*player).aoDev);
    (*player).aoDev = 0 as *mut libc::c_void as *mut ao_device;
    if (*player).fgraph as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        avfilter_graph_free(&mut (*player).fgraph);
        (*player).fgraph = 0 as *mut libc::c_void as *mut AVFilterGraph;
    }
    if (*player).cctx as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        avcodec_close((*player).cctx);
        (*player).cctx = 0 as *mut libc::c_void as *mut AVCodecContext;
    }
    if (*player).fctx as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        avformat_close_input(&mut (*player).fctx);
    }
}
pub unsafe extern "C" fn BarPlayerThread(
    mut data: *mut libc::c_void,
) -> *mut libc::c_void {
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut pret: uintptr_t = 0;
    let mut retry: bool = false;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: bool = false;
    let mut tmp___2: bool = false;
    let mut tmp___3: bool = false;
    player = data as *mut player_t;
    pret = 0 as libc::c_int as uintptr_t;
    loop {
        retry = 0 as libc::c_int != 0;
        tmp___3 = openStream(player);
        if tmp___3 {
            tmp___1 = openFilter(player);
            if tmp___1 {
                tmp___2 = openDevice(player);
                if tmp___2 {
                    changeMode(player, 2 as libc::c_uint);
                    BarPlayerSetVolume(player);
                    tmp = play(player);
                    if tmp
                        == -(((73 as libc::c_int
                            | (78 as libc::c_int) << 8 as libc::c_int
                            | (68 as libc::c_int) << 16 as libc::c_int) as libc::c_uint
                            | (65 as libc::c_uint) << 24 as libc::c_int) as libc::c_int)
                    {
                        if (*player).interrupted == 0 {
                            tmp___0 = 1 as libc::c_int;
                        } else {
                            tmp___0 = 0 as libc::c_int;
                        }
                    } else {
                        tmp___0 = 0 as libc::c_int;
                    }
                    retry = tmp___0 != 0;
                } else {
                    pret = 1 as libc::c_int as uintptr_t;
                }
            } else {
                pret = 1 as libc::c_int as uintptr_t;
            }
        } else {
            pret = 2 as libc::c_int as uintptr_t;
        }
        changeMode(player, 1 as libc::c_uint);
        finish(player);
        if !retry {
            break;
        }
    }
    changeMode(player, 3 as libc::c_uint);
    return pret as *mut libc::c_void;
}
pub unsafe extern "C" fn BarAoPlayThread(
    mut data: *mut libc::c_void,
) -> *mut libc::c_void {
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut filteredFrame: *mut AVFrame = 0 as *mut AVFrame;
    let mut ret: libc::c_int = 0;
    let mut timeBase: libc::c_double = 0.;
    let mut tmp: AVRational = AVRational { num: 0, den: 0 };
    let mut tmp___0: libc::c_double = 0.;
    let mut timeBaseSt: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: bool = false;
    let mut numChannels: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut bps: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut timestamp: libc::c_double = 0.;
    let mut songPlayed: libc::c_uint = 0;
    let mut lastTimestamp: int64_t = 0;
    let mut tmp___5: bool = false;
    player = data as *mut player_t;
    filteredFrame = 0 as *mut libc::c_void as *mut AVFrame;
    filteredFrame = av_frame_alloc();
    tmp = av_buffersink_get_time_base((*player).fbufsink as *const AVFilterContext);
    tmp___0 = av_q2d(tmp);
    timeBase = tmp___0;
    tmp___1 = av_q2d((*(*player).st).time_base);
    timeBaseSt = tmp___1;
    loop {
        tmp___5 = shouldQuit(player);
        if tmp___5 {
            break;
        }
        pthread_mutex_lock(&mut (*player).aoplayLock);
        ret = av_buffersink_get_frame((*player).fbufsink, filteredFrame);
        if ret
            == -(((69 as libc::c_int | (79 as libc::c_int) << 8 as libc::c_int
                | (70 as libc::c_int) << 16 as libc::c_int) as libc::c_uint
                | (32 as libc::c_uint) << 24 as libc::c_int) as libc::c_int)
        {
            pthread_mutex_unlock(&mut (*player).aoplayLock);
            break;
        } else {
            tmp___2 = shouldQuit(player);
            if tmp___2 {
                pthread_mutex_unlock(&mut (*player).aoplayLock);
                break;
            } else if ret < 0 as libc::c_int {
                pthread_cond_broadcast(&mut (*player).aoplayCond);
                pthread_cond_wait(
                    &mut (*player).aoplayCond as *mut pthread_cond_t,
                    &mut (*player).aoplayLock as *mut pthread_mutex_t,
                );
                pthread_mutex_unlock(&mut (*player).aoplayLock);
            } else {
                pthread_mutex_unlock(&mut (*player).aoplayLock);
                tmp___3 = av_get_channel_layout_nb_channels(
                    (*filteredFrame).channel_layout,
                );
                numChannels = tmp___3;
                tmp___4 = av_get_bytes_per_sample(
                    (*filteredFrame).format as AVSampleFormat,
                );
                bps = tmp___4;
                ao_play(
                    (*player).aoDev,
                    (*filteredFrame).data[0 as libc::c_int as usize]
                        as *mut libc::c_char,
                    ((*filteredFrame).nb_samples * numChannels * bps) as uint_32,
                );
                timestamp = (*filteredFrame).pts as libc::c_double * timeBase;
                songPlayed = timestamp as libc::c_uint;
                pthread_mutex_lock(&mut (*player).lock);
                (*player).songPlayed = songPlayed;
                if (*player).doPause {
                    loop {
                        pthread_cond_wait(
                            &mut (*player).cond as *mut pthread_cond_t,
                            &mut (*player).lock as *mut pthread_mutex_t,
                        );
                        if !(*player).doPause {
                            break;
                        }
                    }
                }
                pthread_mutex_unlock(&mut (*player).lock);
                lastTimestamp = (timestamp / timeBaseSt) as int64_t;
                pthread_mutex_lock(&mut (*player).aoplayLock);
                (*player).lastTimestamp = lastTimestamp;
                pthread_cond_broadcast(&mut (*player).aoplayCond);
                pthread_mutex_unlock(&mut (*player).aoplayLock);
                av_frame_unref(filteredFrame);
            }
        }
    }
    av_frame_free(&mut filteredFrame);
    return 0 as *mut libc::c_void;
}
static mut dispatchActions: [BarUiDispatchAction_t; 30] = [
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '?' as i32 as libc::c_char,
            context: BAR_DC_UNDEFINED,
            function: Some(
                BarUiActHelp
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_help\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '+' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActLoveSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"love song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songlove\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '-' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActBanSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"ban song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songban\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'a' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActAddMusic
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add music to station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationaddmusic\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'c' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActCreateStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"create new station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationcreate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'd' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActDeleteStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"delete station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationdelete\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'e' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActExplain
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"explain why this song is played\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songexplain\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'g' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActStationFromGenre
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add genre station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationaddbygenre\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'h' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActHistory
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"song history\0" as *const u8 as *const libc::c_char,
            configKey: b"act_history\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'i' as i32 as libc::c_char,
            context: 7 as BarUiDispatchContext_t,
            function: Some(
                BarUiActSongInfo
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"print information about song/station\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songinfo\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'j' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActAddSharedStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add shared station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_addshared\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'n' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActSkipSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"next song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songnext\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'p' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActTogglePause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"pause/resume playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songpausetoggle\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'q' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActQuit
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"quit\0" as *const u8 as *const libc::c_char,
            configKey: b"act_quit\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'r' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActRenameStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"rename station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationrename\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 's' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActSelectStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"change station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationchange\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 't' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActTempBanSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"tired (ban song for 1 month)\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songtired\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'u' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPrintUpcoming
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"upcoming songs\0" as *const u8 as *const libc::c_char,
            configKey: b"act_upcoming\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'x' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActSelectQuickMix
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"select quickmix stations\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationselectquickmix\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '$' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActDebug
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_debug\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'b' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActBookmark
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"bookmark song/artist\0" as *const u8 as *const libc::c_char,
            configKey: b"act_bookmark\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '(' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolDown
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"decrease volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_voldown\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: ')' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolUp
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"increase volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_volup\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '=' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActManageStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"manage station seeds/feedback/mode\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_managestation\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: ' ' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActTogglePause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_songpausetoggle2\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'v' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActCreateStationFromSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"create new station from song or artist\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_stationcreatefromsong\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'P' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPlay
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"resume playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songplay\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'S' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"pause playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songpause\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '^' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolReset
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"reset volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_volreset\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '!' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActSettings
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"change settings\0" as *const u8 as *const libc::c_char,
            configKey: b"act_settings\0" as *const u8 as *const libc::c_char,
        };
        init
    },
];
unsafe extern "C" fn BarSettingsGetHome() -> *mut libc::c_char {
    let mut home: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut pw: *mut passwd = 0 as *mut passwd;
    let mut tmp___1: __uid_t = 0;
    let mut tmp___2: *mut passwd = 0 as *mut passwd;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: size_t = 0;
    home = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    if home as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = strlen(home as *const libc::c_char);
        if tmp___0 > 0 as libc::c_ulong {
            tmp = strdup(home as *const libc::c_char);
            return tmp;
        }
    }
    tmp___1 = getuid();
    tmp___2 = getpwuid(tmp___1);
    pw = tmp___2;
    if pw as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*pw).pw_dir as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___4 = strlen((*pw).pw_dir as *const libc::c_char);
            if tmp___4 > 0 as libc::c_ulong {
                tmp___3 = strdup((*pw).pw_dir as *const libc::c_char);
                return tmp___3;
            }
        }
    }
    return 0 as *mut libc::c_void as *mut libc::c_char;
}
unsafe extern "C" fn BarGetXdgConfigDir(
    filename: *const libc::c_char,
) -> *mut libc::c_char {
    let mut xdgConfigDir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut concat: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    xdgConfigDir = getenv(b"XDG_CONFIG_HOME\0" as *const u8 as *const libc::c_char);
    if xdgConfigDir as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = strlen(xdgConfigDir as *const libc::c_char);
        if tmp___2 > 0 as libc::c_ulong {
            tmp = strlen(xdgConfigDir as *const libc::c_char);
            tmp___0 = strlen(filename);
            len = tmp
                .wrapping_add(1 as libc::c_ulong)
                .wrapping_add(tmp___0)
                .wrapping_add(1 as libc::c_ulong);
            tmp___1 = malloc(
                len.wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
            );
            concat = tmp___1 as *mut libc::c_char;
            snprintf(
                concat,
                len,
                b"%s/%s\0" as *const u8 as *const libc::c_char,
                xdgConfigDir,
                filename,
            );
            return concat;
        }
    }
    return 0 as *mut libc::c_void as *mut libc::c_char;
}
pub unsafe extern "C" fn BarSettingsExpandTilde(
    path: *const libc::c_char,
    home: *const libc::c_char,
) -> *mut libc::c_char {
    let mut expanded: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp___2 = strncmp(
        path,
        b"~/\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int as size_t,
    );
    if tmp___2 == 0 as libc::c_int {
        tmp = strlen(home);
        tmp___0 = strlen(path);
        tmp___1 = malloc(
            tmp
                .wrapping_add(1 as libc::c_ulong)
                .wrapping_add(tmp___0)
                .wrapping_sub(2 as libc::c_ulong)
                .wrapping_add(1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
        );
        expanded = tmp___1 as *mut libc::c_char;
        sprintf(
            expanded,
            b"%s/%s\0" as *const u8 as *const libc::c_char,
            home,
            path.offset(2 as libc::c_int as isize),
        );
        return expanded;
    }
    tmp___3 = strdup(path);
    return tmp___3;
}
pub unsafe extern "C" fn BarSettingsInit(mut settings: *mut BarSettings_t) {
    memset(
        settings as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<BarSettings_t>() as libc::c_ulong,
    );
}
pub unsafe extern "C" fn BarSettingsDestroy(mut settings: *mut BarSettings_t) {
    let mut i: size_t = 0;
    free((*settings).controlProxy as *mut libc::c_void);
    free((*settings).proxy as *mut libc::c_void);
    free((*settings).bindTo as *mut libc::c_void);
    free((*settings).username as *mut libc::c_void);
    free((*settings).password as *mut libc::c_void);
    free((*settings).passwordCmd as *mut libc::c_void);
    free((*settings).autostartStation as *mut libc::c_void);
    free((*settings).eventCmd as *mut libc::c_void);
    free((*settings).loveIcon as *mut libc::c_void);
    free((*settings).banIcon as *mut libc::c_void);
    free((*settings).tiredIcon as *mut libc::c_void);
    free((*settings).atIcon as *mut libc::c_void);
    free((*settings).npSongFormat as *mut libc::c_void);
    free((*settings).npStationFormat as *mut libc::c_void);
    free((*settings).listSongFormat as *mut libc::c_void);
    free((*settings).timeFormat as *mut libc::c_void);
    free((*settings).fifo as *mut libc::c_void);
    free((*settings).audioPipe as *mut libc::c_void);
    free((*settings).rpcHost as *mut libc::c_void);
    free((*settings).rpcTlsPort as *mut libc::c_void);
    free((*settings).partnerUser as *mut libc::c_void);
    free((*settings).partnerPassword as *mut libc::c_void);
    free((*settings).device as *mut libc::c_void);
    free((*settings).inkey as *mut libc::c_void);
    free((*settings).outkey as *mut libc::c_void);
    i = 0 as libc::c_int as size_t;
    while i < 7 as libc::c_ulong {
        free((*settings).msgFormat[i as usize].prefix as *mut libc::c_void);
        free((*settings).msgFormat[i as usize].postfix as *mut libc::c_void);
        i = i.wrapping_add(1);
    }
    memset(
        settings as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<BarSettings_t>() as libc::c_ulong,
    );
}
static mut formatMsgPrefix: *const libc::c_char = b"format_msg_\0" as *const u8
    as *const libc::c_char;
static mut mapping: [*const libc::c_char; 6] = [
    b"name_az\0" as *const u8 as *const libc::c_char,
    b"name_za\0" as *const u8 as *const libc::c_char,
    b"quickmix_01_name_az\0" as *const u8 as *const libc::c_char,
    b"quickmix_01_name_za\0" as *const u8 as *const libc::c_char,
    b"quickmix_10_name_az\0" as *const u8 as *const libc::c_char,
    b"quickmix_10_name_za\0" as *const u8 as *const libc::c_char,
];
static mut mapping___0: [*const libc::c_char; 7] = [
    b"none\0" as *const u8 as *const libc::c_char,
    b"info\0" as *const u8 as *const libc::c_char,
    b"nowplaying\0" as *const u8 as *const libc::c_char,
    b"time\0" as *const u8 as *const libc::c_char,
    b"err\0" as *const u8 as *const libc::c_char,
    b"question\0" as *const u8 as *const libc::c_char,
    b"list\0" as *const u8 as *const libc::c_char,
];
pub unsafe extern "C" fn BarSettingsRead(mut settings: *mut BarSettings_t) {
    let mut configfiles: [*mut libc::c_char; 2] = [0 as *mut libc::c_char; 2];
    let mut userhome: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut defaultxdg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: size_t = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut configfd: *mut FILE = 0 as *mut FILE;
    let mut line: [libc::c_char; 512] = [0; 512];
    let mut lineNum: size_t = 0;
    let mut path: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: libc::c_int = 0;
    let mut key: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut val: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut keyend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: size_t = 0;
    let mut tmp___10: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___11: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut valend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: size_t = 0;
    let mut i___0: size_t = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: libc::c_int = 0;
    let mut tmp___21: libc::c_int = 0;
    let mut i___1: size_t = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: libc::c_double = 0.;
    let mut tmp___24: libc::c_int = 0;
    let mut typeStart: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___25: size_t = 0;
    let mut i___2: size_t = 0;
    let mut formatPos: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___26: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut format: *mut BarMsgFormatStr_t = 0 as *mut BarMsgFormatStr_t;
    let mut prefixLen: size_t = 0;
    let mut tmp___27: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut postfixLen: size_t = 0;
    let mut tmp___28: size_t = 0;
    let mut tmp___29: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___30: libc::c_int = 0;
    let mut tmp___31: size_t = 0;
    let mut tmp___32: libc::c_int = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: libc::c_int = 0;
    let mut tmp___38: libc::c_int = 0;
    let mut tmp___39: libc::c_int = 0;
    let mut tmp___40: libc::c_int = 0;
    let mut tmp___41: libc::c_int = 0;
    let mut tmp___42: libc::c_int = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: libc::c_int = 0;
    let mut tmp___45: libc::c_int = 0;
    let mut tmp___46: libc::c_int = 0;
    let mut tmp___47: libc::c_int = 0;
    let mut tmp___48: libc::c_int = 0;
    let mut tmp___49: libc::c_int = 0;
    let mut tmp___50: libc::c_int = 0;
    let mut tmp___51: libc::c_int = 0;
    let mut tmp___52: libc::c_int = 0;
    let mut tmp___53: libc::c_int = 0;
    let mut tmp___54: libc::c_int = 0;
    let mut tmp___55: libc::c_int = 0;
    let mut tmp___56: libc::c_int = 0;
    let mut tmp___57: libc::c_int = 0;
    let mut tmp___58: libc::c_int = 0;
    let mut tmp___59: libc::c_int = 0;
    let mut tmp___60: libc::c_int = 0;
    let mut tmp___61: libc::c_int = 0;
    let mut tmp___62: libc::c_int = 0;
    let mut tmp___63: libc::c_int = 0;
    let mut tmp___64: libc::c_int = 0;
    let mut tmp___65: libc::c_int = 0;
    let mut tmp___66: libc::c_int = 0;
    let mut tmp___67: libc::c_int = 0;
    let mut tmp___68: libc::c_int = 0;
    let mut tmp___69: libc::c_int = 0;
    let mut tmpProxy: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___70: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___71: size_t = 0;
    configfiles[0 as libc::c_int
        as usize] = b"pianobar/state\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    configfiles[1 as libc::c_int
        as usize] = b"pianobar/config\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    tmp = BarSettingsGetHome();
    userhome = tmp;
    tmp___0 = strlen(userhome as *const libc::c_char);
    tmp___1 = strlen(b"/.config\0" as *const u8 as *const libc::c_char);
    tmp___2 = malloc(tmp___0.wrapping_add(tmp___1).wrapping_add(1 as libc::c_ulong));
    defaultxdg = tmp___2 as *mut libc::c_char;
    sprintf(defaultxdg, b"%s/.config\0" as *const u8 as *const libc::c_char, userhome);
    setenv(
        b"XDG_CONFIG_HOME\0" as *const u8 as *const libc::c_char,
        defaultxdg as *const libc::c_char,
        0 as libc::c_int,
    );
    free(defaultxdg as *mut libc::c_void);
    (*settings).audioQuality = PIANO_AQ_HIGH;
    (*settings).autoselect = 1 as libc::c_int != 0;
    (*settings).history = 5 as libc::c_uint;
    (*settings).volume = 0 as libc::c_int;
    (*settings).timeout = 30 as libc::c_uint;
    (*settings).gainMul = 1.0f64 as libc::c_float;
    (*settings).maxRetry = 5 as libc::c_uint;
    (*settings).bufferSecs = 5 as libc::c_uint;
    (*settings).sortOrder = BAR_SORT_NAME_AZ;
    (*settings).loveIcon = strdup(b" <3\0" as *const u8 as *const libc::c_char);
    (*settings).banIcon = strdup(b" </3\0" as *const u8 as *const libc::c_char);
    (*settings).tiredIcon = strdup(b" zZ\0" as *const u8 as *const libc::c_char);
    (*settings).atIcon = strdup(b" @ \0" as *const u8 as *const libc::c_char);
    (*settings)
        .npSongFormat = strdup(
        b"\"%t\" by \"%a\" on \"%l\"%r%@%s\0" as *const u8 as *const libc::c_char,
    );
    (*settings)
        .npStationFormat = strdup(
        b"Station \"%n\" (%i)\0" as *const u8 as *const libc::c_char,
    );
    (*settings)
        .listSongFormat = strdup(b"%i) %a - %t%r\0" as *const u8 as *const libc::c_char);
    (*settings).timeFormat = strdup(b"%s%r/%t\0" as *const u8 as *const libc::c_char);
    (*settings)
        .rpcHost = strdup(b"tuner.pandora.com\0" as *const u8 as *const libc::c_char);
    (*settings).rpcTlsPort = strdup(b"443\0" as *const u8 as *const libc::c_char);
    (*settings).partnerUser = strdup(b"android\0" as *const u8 as *const libc::c_char);
    (*settings)
        .partnerPassword = strdup(
        b"AC7IBG09A3DTSYM4R41UJWL07VLN8JI7\0" as *const u8 as *const libc::c_char,
    );
    (*settings)
        .device = strdup(b"android-generic\0" as *const u8 as *const libc::c_char);
    (*settings).inkey = strdup(b"R=U!LH$O2B#\0" as *const u8 as *const libc::c_char);
    (*settings).outkey = strdup(b"6#26FRL$ZWD\0" as *const u8 as *const libc::c_char);
    (*settings)
        .fifo = BarGetXdgConfigDir(
        b"pianobar/ctl\0" as *const u8 as *const libc::c_char,
    );
    (*settings).audioPipe = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings).sampleRate = 0 as libc::c_int;
    (*settings)
        .msgFormat[0 as libc::c_int as usize]
        .prefix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[0 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[1 as libc::c_int as usize]
        .prefix = strdup(b"(i) \0" as *const u8 as *const libc::c_char);
    (*settings)
        .msgFormat[1 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[2 as libc::c_int as usize]
        .prefix = strdup(b"|>  \0" as *const u8 as *const libc::c_char);
    (*settings)
        .msgFormat[2 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[3 as libc::c_int as usize]
        .prefix = strdup(b"#   \0" as *const u8 as *const libc::c_char);
    (*settings)
        .msgFormat[3 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[4 as libc::c_int as usize]
        .prefix = strdup(b"/!\\ \0" as *const u8 as *const libc::c_char);
    (*settings)
        .msgFormat[4 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[5 as libc::c_int as usize]
        .prefix = strdup(b"[?] \0" as *const u8 as *const libc::c_char);
    (*settings)
        .msgFormat[5 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    (*settings)
        .msgFormat[6 as libc::c_int as usize]
        .prefix = strdup(b"\t\0" as *const u8 as *const libc::c_char);
    (*settings)
        .msgFormat[6 as libc::c_int as usize]
        .postfix = 0 as *mut libc::c_void as *mut libc::c_char;
    i = 0 as libc::c_int as size_t;
    while i < 30 as libc::c_ulong {
        (*settings).keys[i as usize] = dispatchActions[i as usize].defaultKey;
        i = i.wrapping_add(1);
    }
    j = 0 as libc::c_int as size_t;
    while j
        < (::std::mem::size_of::<[*mut libc::c_char; 2]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
    {
        lineNum = 0 as libc::c_int as size_t;
        tmp___3 = BarGetXdgConfigDir(configfiles[j as usize] as *const libc::c_char);
        path = tmp___3;
        configfd = fopen(
            path as *const libc::c_char,
            b"r\0" as *const u8 as *const libc::c_char,
        );
        if configfd as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            free(path as *mut libc::c_void);
        } else {
            loop {
                lineNum = lineNum.wrapping_add(1);
                tmp___4 = fgets(
                    line.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong
                        as libc::c_int,
                    configfd,
                );
                ret = tmp___4;
                if ret as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    break;
                }
                tmp___5 = strchr(line.as_mut_ptr() as *const libc::c_char, '\n' as i32);
                if tmp___5 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    tmp___6 = feof(configfd);
                    if tmp___6 == 0 {
                        BarUiMsg(
                            settings as *const BarSettings_t,
                            MSG_INFO,
                            b"Line %s:%zu too long, ignoring\n\0" as *const u8
                                as *const libc::c_char,
                            path,
                            lineNum,
                        );
                        continue;
                    }
                }
                key = line.as_mut_ptr();
                loop {
                    tmp___7 = __ctype_b_loc();
                    if *(*tmp___7)
                        .offset(
                            *key.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int as isize,
                        ) as libc::c_int & 8192 as libc::c_int == 0
                    {
                        break;
                    }
                    key = key.offset(1);
                }
                if *key.offset(0 as libc::c_int as isize) as libc::c_int
                    == 35 as libc::c_int
                {
                    continue;
                }
                tmp___8 = strchr(line.as_mut_ptr() as *const libc::c_char, '=' as i32);
                val = tmp___8;
                if val as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    if *key.offset(0 as libc::c_int as isize) as libc::c_int
                        != 0 as libc::c_int
                    {
                        BarUiMsg(
                            settings as *const BarSettings_t,
                            MSG_INFO,
                            b"Invalid line at %s:%zu\n\0" as *const u8
                                as *const libc::c_char,
                            path,
                            lineNum,
                        );
                    }
                } else {
                    *val = '\u{0}' as i32 as libc::c_char;
                    val = val.offset(1);
                    tmp___9 = strlen(key as *const libc::c_char);
                    keyend = key
                        .offset(tmp___9.wrapping_sub(1 as libc::c_ulong) as isize);
                    while keyend as libc::c_ulong >= key as libc::c_ulong {
                        tmp___10 = __ctype_b_loc();
                        if *(*tmp___10)
                            .offset(*keyend as libc::c_uchar as libc::c_int as isize)
                            as libc::c_int & 8192 as libc::c_int == 0
                        {
                            break;
                        }
                        *keyend = '\u{0}' as i32 as libc::c_char;
                        keyend = keyend.offset(-1);
                    }
                    tmp___11 = __ctype_b_loc();
                    if *(*tmp___11)
                        .offset(
                            *val.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int as isize,
                        ) as libc::c_int & 8192 as libc::c_int != 0
                    {
                        val = val.offset(1);
                    }
                    tmp___12 = strlen(val as *const libc::c_char);
                    valend = val
                        .offset(tmp___12.wrapping_sub(1 as libc::c_ulong) as isize);
                    while valend as libc::c_ulong >= val as libc::c_ulong {
                        if !(*valend as libc::c_int == 13 as libc::c_int) {
                            if !(*valend as libc::c_int == 10 as libc::c_int) {
                                break;
                            }
                        }
                        *valend = '\u{0}' as i32 as libc::c_char;
                        valend = valend.offset(-1);
                    }
                    tmp___69 = strcmp(
                        b"control_proxy\0" as *const u8 as *const libc::c_char,
                        key as *const libc::c_char,
                    );
                    if tmp___69 == 0 as libc::c_int {
                        (*settings).controlProxy = strdup(val as *const libc::c_char);
                    } else {
                        tmp___68 = strcmp(
                            b"proxy\0" as *const u8 as *const libc::c_char,
                            key as *const libc::c_char,
                        );
                        if tmp___68 == 0 as libc::c_int {
                            (*settings).proxy = strdup(val as *const libc::c_char);
                        } else {
                            tmp___67 = strcmp(
                                b"bind_to\0" as *const u8 as *const libc::c_char,
                                key as *const libc::c_char,
                            );
                            if tmp___67 == 0 as libc::c_int {
                                (*settings).bindTo = strdup(val as *const libc::c_char);
                            } else {
                                tmp___66 = strcmp(
                                    b"user\0" as *const u8 as *const libc::c_char,
                                    key as *const libc::c_char,
                                );
                                if tmp___66 == 0 as libc::c_int {
                                    (*settings).username = strdup(val as *const libc::c_char);
                                } else {
                                    tmp___65 = strcmp(
                                        b"password\0" as *const u8 as *const libc::c_char,
                                        key as *const libc::c_char,
                                    );
                                    if tmp___65 == 0 as libc::c_int {
                                        (*settings).password = strdup(val as *const libc::c_char);
                                    } else {
                                        tmp___64 = strcmp(
                                            b"password_command\0" as *const u8 as *const libc::c_char,
                                            key as *const libc::c_char,
                                        );
                                        if tmp___64 == 0 as libc::c_int {
                                            (*settings)
                                                .passwordCmd = strdup(val as *const libc::c_char);
                                        } else {
                                            tmp___63 = strcmp(
                                                b"rpc_host\0" as *const u8 as *const libc::c_char,
                                                key as *const libc::c_char,
                                            );
                                            if tmp___63 == 0 as libc::c_int {
                                                free((*settings).rpcHost as *mut libc::c_void);
                                                (*settings).rpcHost = strdup(val as *const libc::c_char);
                                            } else {
                                                tmp___62 = strcmp(
                                                    b"rpc_tls_port\0" as *const u8 as *const libc::c_char,
                                                    key as *const libc::c_char,
                                                );
                                                if tmp___62 == 0 as libc::c_int {
                                                    free((*settings).rpcTlsPort as *mut libc::c_void);
                                                    (*settings).rpcTlsPort = strdup(val as *const libc::c_char);
                                                } else {
                                                    tmp___61 = strcmp(
                                                        b"partner_user\0" as *const u8 as *const libc::c_char,
                                                        key as *const libc::c_char,
                                                    );
                                                    if tmp___61 == 0 as libc::c_int {
                                                        free((*settings).partnerUser as *mut libc::c_void);
                                                        (*settings)
                                                            .partnerUser = strdup(val as *const libc::c_char);
                                                    } else {
                                                        tmp___60 = strcmp(
                                                            b"partner_password\0" as *const u8 as *const libc::c_char,
                                                            key as *const libc::c_char,
                                                        );
                                                        if tmp___60 == 0 as libc::c_int {
                                                            free((*settings).partnerPassword as *mut libc::c_void);
                                                            (*settings)
                                                                .partnerPassword = strdup(val as *const libc::c_char);
                                                        } else {
                                                            tmp___59 = strcmp(
                                                                b"device\0" as *const u8 as *const libc::c_char,
                                                                key as *const libc::c_char,
                                                            );
                                                            if tmp___59 == 0 as libc::c_int {
                                                                free((*settings).device as *mut libc::c_void);
                                                                (*settings).device = strdup(val as *const libc::c_char);
                                                            } else {
                                                                tmp___58 = strcmp(
                                                                    b"encrypt_password\0" as *const u8 as *const libc::c_char,
                                                                    key as *const libc::c_char,
                                                                );
                                                                if tmp___58 == 0 as libc::c_int {
                                                                    free((*settings).outkey as *mut libc::c_void);
                                                                    (*settings).outkey = strdup(val as *const libc::c_char);
                                                                } else {
                                                                    tmp___57 = strcmp(
                                                                        b"decrypt_password\0" as *const u8 as *const libc::c_char,
                                                                        key as *const libc::c_char,
                                                                    );
                                                                    if tmp___57 == 0 as libc::c_int {
                                                                        free((*settings).inkey as *mut libc::c_void);
                                                                        (*settings).inkey = strdup(val as *const libc::c_char);
                                                                    } else {
                                                                        tmp___56 = strcmp(
                                                                            b"ca_bundle\0" as *const u8 as *const libc::c_char,
                                                                            key as *const libc::c_char,
                                                                        );
                                                                        if tmp___56 == 0 as libc::c_int {
                                                                            free((*settings).caBundle as *mut libc::c_void);
                                                                            (*settings).caBundle = strdup(val as *const libc::c_char);
                                                                        } else {
                                                                            tmp___55 = memcmp(
                                                                                b"act_\0" as *const u8 as *const libc::c_char
                                                                                    as *const libc::c_void,
                                                                                key as *const libc::c_void,
                                                                                4 as libc::c_int as size_t,
                                                                            );
                                                                            if tmp___55 == 0 as libc::c_int {
                                                                                i___0 = 0 as libc::c_int as size_t;
                                                                                while i___0 < 30 as libc::c_ulong {
                                                                                    tmp___14 = strcmp(
                                                                                        dispatchActions[i___0 as usize].configKey,
                                                                                        key as *const libc::c_char,
                                                                                    );
                                                                                    if tmp___14 == 0 as libc::c_int {
                                                                                        tmp___13 = strcmp(
                                                                                            val as *const libc::c_char,
                                                                                            b"disabled\0" as *const u8 as *const libc::c_char,
                                                                                        );
                                                                                        if tmp___13 == 0 as libc::c_int {
                                                                                            (*settings)
                                                                                                .keys[i___0 as usize] = '\u{0}' as i32 as libc::c_char;
                                                                                        } else {
                                                                                            (*settings)
                                                                                                .keys[i___0
                                                                                                as usize] = *val.offset(0 as libc::c_int as isize);
                                                                                        }
                                                                                        break;
                                                                                    } else {
                                                                                        i___0 = i___0.wrapping_add(1);
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                tmp___54 = strcmp(
                                                                                    b"audio_quality\0" as *const u8 as *const libc::c_char,
                                                                                    key as *const libc::c_char,
                                                                                );
                                                                                if tmp___54 == 0 as libc::c_int {
                                                                                    tmp___17 = strcmp(
                                                                                        val as *const libc::c_char,
                                                                                        b"low\0" as *const u8 as *const libc::c_char,
                                                                                    );
                                                                                    if tmp___17 == 0 as libc::c_int {
                                                                                        (*settings).audioQuality = PIANO_AQ_LOW;
                                                                                    } else {
                                                                                        tmp___16 = strcmp(
                                                                                            val as *const libc::c_char,
                                                                                            b"medium\0" as *const u8 as *const libc::c_char,
                                                                                        );
                                                                                        if tmp___16 == 0 as libc::c_int {
                                                                                            (*settings).audioQuality = PIANO_AQ_MEDIUM;
                                                                                        } else {
                                                                                            tmp___15 = strcmp(
                                                                                                val as *const libc::c_char,
                                                                                                b"high\0" as *const u8 as *const libc::c_char,
                                                                                            );
                                                                                            if tmp___15 == 0 as libc::c_int {
                                                                                                (*settings).audioQuality = PIANO_AQ_HIGH;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    tmp___53 = strcmp(
                                                                                        b"autostart_station\0" as *const u8 as *const libc::c_char,
                                                                                        key as *const libc::c_char,
                                                                                    );
                                                                                    if tmp___53 == 0 as libc::c_int {
                                                                                        free((*settings).autostartStation as *mut libc::c_void);
                                                                                        (*settings)
                                                                                            .autostartStation = strdup(val as *const libc::c_char);
                                                                                    } else {
                                                                                        tmp___52 = strcmp(
                                                                                            b"event_command\0" as *const u8 as *const libc::c_char,
                                                                                            key as *const libc::c_char,
                                                                                        );
                                                                                        if tmp___52 == 0 as libc::c_int {
                                                                                            (*settings)
                                                                                                .eventCmd = BarSettingsExpandTilde(
                                                                                                val as *const libc::c_char,
                                                                                                userhome as *const libc::c_char,
                                                                                            );
                                                                                        } else {
                                                                                            tmp___51 = strcmp(
                                                                                                b"history\0" as *const u8 as *const libc::c_char,
                                                                                                key as *const libc::c_char,
                                                                                            );
                                                                                            if tmp___51 == 0 as libc::c_int {
                                                                                                tmp___18 = atoi(val as *const libc::c_char);
                                                                                                (*settings).history = tmp___18 as libc::c_uint;
                                                                                            } else {
                                                                                                tmp___50 = strcmp(
                                                                                                    b"max_retry\0" as *const u8 as *const libc::c_char,
                                                                                                    key as *const libc::c_char,
                                                                                                );
                                                                                                if tmp___50 == 0 as libc::c_int {
                                                                                                    tmp___19 = atoi(val as *const libc::c_char);
                                                                                                    (*settings).maxRetry = tmp___19 as libc::c_uint;
                                                                                                } else {
                                                                                                    tmp___49 = strcmp(
                                                                                                        b"timeout\0" as *const u8 as *const libc::c_char,
                                                                                                        key as *const libc::c_char,
                                                                                                    );
                                                                                                    if tmp___49 == 0 as libc::c_int {
                                                                                                        tmp___20 = atoi(val as *const libc::c_char);
                                                                                                        (*settings).timeout = tmp___20 as libc::c_uint;
                                                                                                    } else {
                                                                                                        tmp___48 = strcmp(
                                                                                                            b"buffer_seconds\0" as *const u8 as *const libc::c_char,
                                                                                                            key as *const libc::c_char,
                                                                                                        );
                                                                                                        if tmp___48 == 0 as libc::c_int {
                                                                                                            tmp___21 = atoi(val as *const libc::c_char);
                                                                                                            (*settings).bufferSecs = tmp___21 as libc::c_uint;
                                                                                                        } else {
                                                                                                            tmp___47 = strcmp(
                                                                                                                b"sort\0" as *const u8 as *const libc::c_char,
                                                                                                                key as *const libc::c_char,
                                                                                                            );
                                                                                                            if tmp___47 == 0 as libc::c_int {
                                                                                                                i___1 = 0 as libc::c_int as size_t;
                                                                                                                while i___1 < 6 as libc::c_ulong {
                                                                                                                    tmp___22 = strcmp(
                                                                                                                        mapping[i___1 as usize],
                                                                                                                        val as *const libc::c_char,
                                                                                                                    );
                                                                                                                    if tmp___22 == 0 as libc::c_int {
                                                                                                                        (*settings).sortOrder = i___1 as BarStationSorting_t;
                                                                                                                        break;
                                                                                                                    } else {
                                                                                                                        i___1 = i___1.wrapping_add(1);
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                tmp___46 = strcmp(
                                                                                                                    b"love_icon\0" as *const u8 as *const libc::c_char,
                                                                                                                    key as *const libc::c_char,
                                                                                                                );
                                                                                                                if tmp___46 == 0 as libc::c_int {
                                                                                                                    free((*settings).loveIcon as *mut libc::c_void);
                                                                                                                    (*settings).loveIcon = strdup(val as *const libc::c_char);
                                                                                                                } else {
                                                                                                                    tmp___45 = strcmp(
                                                                                                                        b"ban_icon\0" as *const u8 as *const libc::c_char,
                                                                                                                        key as *const libc::c_char,
                                                                                                                    );
                                                                                                                    if tmp___45 == 0 as libc::c_int {
                                                                                                                        free((*settings).banIcon as *mut libc::c_void);
                                                                                                                        (*settings).banIcon = strdup(val as *const libc::c_char);
                                                                                                                    } else {
                                                                                                                        tmp___44 = strcmp(
                                                                                                                            b"tired_icon\0" as *const u8 as *const libc::c_char,
                                                                                                                            key as *const libc::c_char,
                                                                                                                        );
                                                                                                                        if tmp___44 == 0 as libc::c_int {
                                                                                                                            free((*settings).tiredIcon as *mut libc::c_void);
                                                                                                                            (*settings).tiredIcon = strdup(val as *const libc::c_char);
                                                                                                                        } else {
                                                                                                                            tmp___43 = strcmp(
                                                                                                                                b"at_icon\0" as *const u8 as *const libc::c_char,
                                                                                                                                key as *const libc::c_char,
                                                                                                                            );
                                                                                                                            if tmp___43 == 0 as libc::c_int {
                                                                                                                                free((*settings).atIcon as *mut libc::c_void);
                                                                                                                                (*settings).atIcon = strdup(val as *const libc::c_char);
                                                                                                                            } else {
                                                                                                                                tmp___42 = strcmp(
                                                                                                                                    b"volume\0" as *const u8 as *const libc::c_char,
                                                                                                                                    key as *const libc::c_char,
                                                                                                                                );
                                                                                                                                if tmp___42 == 0 as libc::c_int {
                                                                                                                                    (*settings).volume = atoi(val as *const libc::c_char);
                                                                                                                                } else {
                                                                                                                                    tmp___41 = strcmp(
                                                                                                                                        b"gain_mul\0" as *const u8 as *const libc::c_char,
                                                                                                                                        key as *const libc::c_char,
                                                                                                                                    );
                                                                                                                                    if tmp___41 == 0 as libc::c_int {
                                                                                                                                        tmp___23 = atof(val as *const libc::c_char);
                                                                                                                                        (*settings).gainMul = tmp___23 as libc::c_float;
                                                                                                                                    } else {
                                                                                                                                        tmp___40 = strcmp(
                                                                                                                                            b"format_nowplaying_song\0" as *const u8
                                                                                                                                                as *const libc::c_char,
                                                                                                                                            key as *const libc::c_char,
                                                                                                                                        );
                                                                                                                                        if tmp___40 == 0 as libc::c_int {
                                                                                                                                            free((*settings).npSongFormat as *mut libc::c_void);
                                                                                                                                            (*settings)
                                                                                                                                                .npSongFormat = strdup(val as *const libc::c_char);
                                                                                                                                        } else {
                                                                                                                                            tmp___39 = strcmp(
                                                                                                                                                b"format_nowplaying_station\0" as *const u8
                                                                                                                                                    as *const libc::c_char,
                                                                                                                                                key as *const libc::c_char,
                                                                                                                                            );
                                                                                                                                            if tmp___39 == 0 as libc::c_int {
                                                                                                                                                free((*settings).npStationFormat as *mut libc::c_void);
                                                                                                                                                (*settings)
                                                                                                                                                    .npStationFormat = strdup(val as *const libc::c_char);
                                                                                                                                            } else {
                                                                                                                                                tmp___38 = strcmp(
                                                                                                                                                    b"format_list_song\0" as *const u8 as *const libc::c_char,
                                                                                                                                                    key as *const libc::c_char,
                                                                                                                                                );
                                                                                                                                                if tmp___38 == 0 as libc::c_int {
                                                                                                                                                    free((*settings).listSongFormat as *mut libc::c_void);
                                                                                                                                                    (*settings)
                                                                                                                                                        .listSongFormat = strdup(val as *const libc::c_char);
                                                                                                                                                } else {
                                                                                                                                                    tmp___37 = strcmp(
                                                                                                                                                        b"format_time\0" as *const u8 as *const libc::c_char,
                                                                                                                                                        key as *const libc::c_char,
                                                                                                                                                    );
                                                                                                                                                    if tmp___37 == 0 as libc::c_int {
                                                                                                                                                        free((*settings).timeFormat as *mut libc::c_void);
                                                                                                                                                        (*settings).timeFormat = strdup(val as *const libc::c_char);
                                                                                                                                                    } else {
                                                                                                                                                        tmp___36 = strcmp(
                                                                                                                                                            b"fifo\0" as *const u8 as *const libc::c_char,
                                                                                                                                                            key as *const libc::c_char,
                                                                                                                                                        );
                                                                                                                                                        if tmp___36 == 0 as libc::c_int {
                                                                                                                                                            free((*settings).fifo as *mut libc::c_void);
                                                                                                                                                            (*settings)
                                                                                                                                                                .fifo = BarSettingsExpandTilde(
                                                                                                                                                                val as *const libc::c_char,
                                                                                                                                                                userhome as *const libc::c_char,
                                                                                                                                                            );
                                                                                                                                                        } else {
                                                                                                                                                            tmp___35 = strcmp(
                                                                                                                                                                b"audio_pipe\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                key as *const libc::c_char,
                                                                                                                                                            );
                                                                                                                                                            if tmp___35 == 0 as libc::c_int {
                                                                                                                                                                free((*settings).audioPipe as *mut libc::c_void);
                                                                                                                                                                (*settings)
                                                                                                                                                                    .audioPipe = BarSettingsExpandTilde(
                                                                                                                                                                    val as *const libc::c_char,
                                                                                                                                                                    userhome as *const libc::c_char,
                                                                                                                                                                );
                                                                                                                                                            } else {
                                                                                                                                                                tmp___34 = strcmp(
                                                                                                                                                                    b"autoselect\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                    key as *const libc::c_char,
                                                                                                                                                                );
                                                                                                                                                                if tmp___34 == 0 as libc::c_int {
                                                                                                                                                                    tmp___24 = atoi(val as *const libc::c_char);
                                                                                                                                                                    (*settings).autoselect = tmp___24 != 0;
                                                                                                                                                                } else {
                                                                                                                                                                    tmp___33 = strcmp(
                                                                                                                                                                        b"sample_rate\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                        key as *const libc::c_char,
                                                                                                                                                                    );
                                                                                                                                                                    if tmp___33 == 0 as libc::c_int {
                                                                                                                                                                        (*settings).sampleRate = atoi(val as *const libc::c_char);
                                                                                                                                                                    } else {
                                                                                                                                                                        tmp___31 = strlen(formatMsgPrefix);
                                                                                                                                                                        tmp___32 = strncmp(
                                                                                                                                                                            formatMsgPrefix,
                                                                                                                                                                            key as *const libc::c_char,
                                                                                                                                                                            tmp___31,
                                                                                                                                                                        );
                                                                                                                                                                        if tmp___32 == 0 as libc::c_int {
                                                                                                                                                                            tmp___25 = strlen(formatMsgPrefix);
                                                                                                                                                                            typeStart = key.offset(tmp___25 as isize)
                                                                                                                                                                                as *const libc::c_char;
                                                                                                                                                                            i___2 = 0 as libc::c_int as size_t;
                                                                                                                                                                            while i___2
                                                                                                                                                                                < (::std::mem::size_of::<[*const libc::c_char; 7]>()
                                                                                                                                                                                    as libc::c_ulong)
                                                                                                                                                                                    .wrapping_div(
                                                                                                                                                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                                                                                                                                                            as libc::c_ulong,
                                                                                                                                                                                    )
                                                                                                                                                                            {
                                                                                                                                                                                tmp___30 = strcmp(typeStart, mapping___0[i___2 as usize]);
                                                                                                                                                                                if tmp___30 == 0 as libc::c_int {
                                                                                                                                                                                    tmp___26 = strstr(
                                                                                                                                                                                        val as *const libc::c_char,
                                                                                                                                                                                        b"%s\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                                    );
                                                                                                                                                                                    formatPos = tmp___26 as *const libc::c_char;
                                                                                                                                                                                    if formatPos as libc::c_ulong
                                                                                                                                                                                        != 0 as *mut libc::c_void as libc::c_ulong
                                                                                                                                                                                    {
                                                                                                                                                                                        format = &mut *((*settings).msgFormat)
                                                                                                                                                                                            .as_mut_ptr()
                                                                                                                                                                                            .offset(i___2 as isize) as *mut BarMsgFormatStr_t;
                                                                                                                                                                                        free((*format).prefix as *mut libc::c_void);
                                                                                                                                                                                        free((*format).postfix as *mut libc::c_void);
                                                                                                                                                                                        prefixLen = formatPos
                                                                                                                                                                                            .offset_from(val as *const libc::c_char) as libc::c_long
                                                                                                                                                                                            as size_t;
                                                                                                                                                                                        tmp___27 = calloc(
                                                                                                                                                                                            prefixLen.wrapping_add(1 as libc::c_ulong),
                                                                                                                                                                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                                                                                                                                                                        );
                                                                                                                                                                                        (*format).prefix = tmp___27 as *mut libc::c_char;
                                                                                                                                                                                        memcpy(
                                                                                                                                                                                            (*format).prefix as *mut libc::c_void,
                                                                                                                                                                                            val as *const libc::c_void,
                                                                                                                                                                                            prefixLen,
                                                                                                                                                                                        );
                                                                                                                                                                                        tmp___28 = strlen(val as *const libc::c_char);
                                                                                                                                                                                        postfixLen = tmp___28
                                                                                                                                                                                            .wrapping_sub(
                                                                                                                                                                                                formatPos.offset_from(val as *const libc::c_char)
                                                                                                                                                                                                    as libc::c_long as size_t,
                                                                                                                                                                                            )
                                                                                                                                                                                            .wrapping_sub(2 as libc::c_ulong);
                                                                                                                                                                                        tmp___29 = calloc(
                                                                                                                                                                                            postfixLen.wrapping_add(1 as libc::c_ulong),
                                                                                                                                                                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                                                                                                                                                                        );
                                                                                                                                                                                        (*format).postfix = tmp___29 as *mut libc::c_char;
                                                                                                                                                                                        memcpy(
                                                                                                                                                                                            (*format).postfix as *mut libc::c_void,
                                                                                                                                                                                            formatPos.offset(2 as libc::c_int as isize)
                                                                                                                                                                                                as *const libc::c_void,
                                                                                                                                                                                            postfixLen,
                                                                                                                                                                                        );
                                                                                                                                                                                    }
                                                                                                                                                                                    break;
                                                                                                                                                                                } else {
                                                                                                                                                                                    i___2 = i___2.wrapping_add(1);
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                            BarUiMsg(
                                                                                                                                                                                settings as *const BarSettings_t,
                                                                                                                                                                                MSG_INFO,
                                                                                                                                                                                b"Unrecognized key %s at %s:%zu\n\0" as *const u8
                                                                                                                                                                                    as *const libc::c_char,
                                                                                                                                                                                key,
                                                                                                                                                                                path,
                                                                                                                                                                                lineNum,
                                                                                                                                                                            );
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            fclose(configfd);
            free(path as *mut libc::c_void);
        }
        j = j.wrapping_add(1);
    }
    if (*settings).proxy as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___70 = getenv(b"http_proxy\0" as *const u8 as *const libc::c_char);
        tmpProxy = tmp___70;
        if tmpProxy as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___71 = strlen(tmpProxy as *const libc::c_char);
            if tmp___71 > 0 as libc::c_ulong {
                (*settings).proxy = strdup(tmpProxy as *const libc::c_char);
            }
        }
    }
    if (*settings).proxy as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        setenv(
            b"http_proxy\0" as *const u8 as *const libc::c_char,
            (*settings).proxy as *const libc::c_char,
            1 as libc::c_int,
        );
    }
    free(userhome as *mut libc::c_void);
}
pub unsafe extern "C" fn BarSettingsWrite(
    mut station: *mut PianoStation_t,
    mut settings: *mut BarSettings_t,
) {
    let mut fd: *mut FILE = 0 as *mut FILE;
    let mut path: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    tmp = BarGetXdgConfigDir(b"pianobar/state\0" as *const u8 as *const libc::c_char);
    path = tmp;
    fd = fopen(path as *const libc::c_char, b"w\0" as *const u8 as *const libc::c_char);
    if fd as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        free(path as *mut libc::c_void);
        return;
    }
    fputs(b"# do not edit this file\n\0" as *const u8 as *const libc::c_char, fd);
    fprintf(
        fd,
        b"volume = %i\n\0" as *const u8 as *const libc::c_char,
        (*settings).volume,
    );
    if station as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        fprintf(
            fd,
            b"autostart_station = %s\n\0" as *const u8 as *const libc::c_char,
            (*station).id,
        );
    }
    fclose(fd);
    free(path as *mut libc::c_void);
}
static mut restore: termios = termios {
    c_iflag: 0,
    c_oflag: 0,
    c_cflag: 0,
    c_lflag: 0,
    c_line: 0,
    c_cc: [0; 32],
    c_ispeed: 0,
    c_ospeed: 0,
};
unsafe extern "C" fn BarTermHandleCont(mut sig: libc::c_int) {
    BarTermInit();
}
pub unsafe extern "C" fn BarTermInit() {
    let mut newopt: termios = termios {
        c_iflag: 0,
        c_oflag: 0,
        c_cflag: 0,
        c_lflag: 0,
        c_line: 0,
        c_cc: [0; 32],
        c_ispeed: 0,
        c_ospeed: 0,
    };
    tcgetattr(0 as libc::c_int, &mut restore);
    memcpy(
        &mut newopt as *mut termios as *mut libc::c_void,
        &mut restore as *mut termios as *const libc::c_void,
        ::std::mem::size_of::<termios>() as libc::c_ulong,
    );
    newopt.c_lflag &= 4294967285 as libc::c_uint;
    tcsetattr(
        0 as libc::c_int,
        0 as libc::c_int,
        &mut newopt as *mut termios as *const termios,
    );
    signal(
        18 as libc::c_int,
        Some(BarTermHandleCont as unsafe extern "C" fn(libc::c_int) -> ()),
    );
}
pub unsafe extern "C" fn BarTermRestore() {
    tcsetattr(
        0 as libc::c_int,
        0 as libc::c_int,
        &mut restore as *mut termios as *const termios,
    );
}
static mut dispatchActions___0: [BarUiDispatchAction_t; 30] = [
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '?' as i32 as libc::c_char,
            context: BAR_DC_UNDEFINED,
            function: Some(
                BarUiActHelp
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_help\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '+' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActLoveSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"love song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songlove\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '-' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActBanSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"ban song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songban\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'a' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActAddMusic
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add music to station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationaddmusic\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'c' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActCreateStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"create new station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationcreate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'd' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActDeleteStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"delete station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationdelete\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'e' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActExplain
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"explain why this song is played\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songexplain\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'g' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActStationFromGenre
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add genre station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationaddbygenre\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'h' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActHistory
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"song history\0" as *const u8 as *const libc::c_char,
            configKey: b"act_history\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'i' as i32 as libc::c_char,
            context: 7 as BarUiDispatchContext_t,
            function: Some(
                BarUiActSongInfo
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"print information about song/station\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songinfo\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'j' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActAddSharedStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add shared station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_addshared\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'n' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActSkipSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"next song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songnext\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'p' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActTogglePause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"pause/resume playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songpausetoggle\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'q' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActQuit
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"quit\0" as *const u8 as *const libc::c_char,
            configKey: b"act_quit\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'r' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActRenameStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"rename station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationrename\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 's' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActSelectStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"change station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationchange\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 't' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActTempBanSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"tired (ban song for 1 month)\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songtired\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'u' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPrintUpcoming
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"upcoming songs\0" as *const u8 as *const libc::c_char,
            configKey: b"act_upcoming\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'x' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActSelectQuickMix
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"select quickmix stations\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationselectquickmix\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '$' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActDebug
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_debug\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'b' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActBookmark
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"bookmark song/artist\0" as *const u8 as *const libc::c_char,
            configKey: b"act_bookmark\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '(' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolDown
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"decrease volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_voldown\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: ')' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolUp
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"increase volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_volup\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '=' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActManageStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"manage station seeds/feedback/mode\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_managestation\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: ' ' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActTogglePause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_songpausetoggle2\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'v' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActCreateStationFromSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"create new station from song or artist\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_stationcreatefromsong\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'P' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPlay
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"resume playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songplay\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'S' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"pause playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songpause\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '^' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolReset
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"reset volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_volreset\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '!' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActSettings
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"change settings\0" as *const u8 as *const libc::c_char,
            configKey: b"act_settings\0" as *const u8 as *const libc::c_char,
        };
        init
    },
];
#[inline]
unsafe extern "C" fn BarUiDoSkipSong(player: *mut player_t) {
    pthread_mutex_lock(&mut (*player).lock);
    (*player).doQuit = 1 as libc::c_int != 0;
    (*player).doPause = 0 as libc::c_int != 0;
    pthread_cond_broadcast(&mut (*player).cond);
    pthread_mutex_unlock(&mut (*player).lock);
    pthread_mutex_lock(&mut (*player).aoplayLock);
    pthread_cond_broadcast(&mut (*player).aoplayCond);
    pthread_mutex_unlock(&mut (*player).aoplayLock);
}
unsafe extern "C" fn BarTransformIfShared(
    mut app___0: *mut BarApp_t,
    mut station: *mut PianoStation_t,
) -> libc::c_int {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut tmp: bool = false;
    if (*station).isCreator == 0 {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Transforming station... \0" as *const u8 as *const libc::c_char,
        );
        tmp = BarUiPianoCall(
            app___0,
            PIANO_REQUEST_TRANSFORM_STATION,
            station as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        if !tmp {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn BarUiActHelp(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut i: size_t = 0;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_NONE,
        b"\r\0" as *const u8 as *const libc::c_char,
    );
    i = 0 as libc::c_int as size_t;
    while i < 30 as libc::c_ulong {
        if dispatchActions___0[i as usize].helpText as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            if context as libc::c_uint
                & dispatchActions___0[i as usize].context as libc::c_uint
                == dispatchActions___0[i as usize].context as libc::c_uint
            {
                if (*app___0).settings.keys[i as usize] as libc::c_int
                    != 0 as libc::c_int
                {
                    BarUiMsg(
                        &mut (*app___0).settings as *mut BarSettings_t
                            as *const BarSettings_t,
                        MSG_LIST,
                        b"%c    %s\n\0" as *const u8 as *const libc::c_char,
                        (*app___0).settings.keys[i as usize] as libc::c_int,
                        dispatchActions___0[i as usize].helpText,
                    );
                }
            }
        }
        i = i.wrapping_add(1);
    }
}
pub unsafe extern "C" fn BarUiActAddMusic(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataAddSeed_t = PianoRequestDataAddSeed_t {
        station: 0 as *mut PianoStation_t,
        musicId: 0 as *mut libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    reqData
        .musicId = BarUiSelectMusicId(
        app___0,
        selStation,
        b"Add artist or title to station: \0" as *const u8 as *const libc::c_char,
    );
    if reqData.musicId as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = BarTransformIfShared(app___0, selStation);
        if tmp == 0 {
            return;
        }
        reqData.station = selStation;
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Adding music to station... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_ADD_SEED,
            &mut reqData as *mut PianoRequestDataAddSeed_t as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        free(reqData.musicId as *mut libc::c_void);
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationaddmusic\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
pub unsafe extern "C" fn BarUiActBanSong(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut realStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp: libc::c_int = 0;
    let mut reqData: PianoRequestDataRateSong_t = PianoRequestDataRateSong_t {
        song: 0 as *mut PianoSong_t,
        rating: PIANO_RATE_NONE,
    };
    let mut tmp___0: bool = false;
    realStation = PianoFindStationById(
        (*app___0).ph.stations,
        (*selSong).stationId as *const libc::c_char,
    );
    if realStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    tmp = BarTransformIfShared(app___0, realStation);
    if tmp == 0 {
        return;
    }
    reqData.song = selSong;
    reqData.rating = PIANO_RATE_BAN;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Banning song... \0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_RATE_SONG,
        &mut reqData as *mut PianoRequestDataRateSong_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    if tmp___0 {
        if selSong as libc::c_ulong == (*app___0).playlist as libc::c_ulong {
            BarUiDoSkipSong(&mut (*app___0).player as *mut player_t);
        }
    }
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"songban\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
}
pub unsafe extern "C" fn BarUiActCreateStation(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataCreateStation_t = PianoRequestDataCreateStation_t {
        token: 0 as *mut libc::c_char,
        type_0: PIANO_MUSICTYPE_INVALID,
    };
    reqData.type_0 = PIANO_MUSICTYPE_INVALID;
    reqData
        .token = BarUiSelectMusicId(
        app___0,
        0 as *mut libc::c_void as *mut PianoStation_t,
        b"Create station from artist or title: \0" as *const u8 as *const libc::c_char,
    );
    if reqData.token as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Creating station... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_CREATE_STATION,
            &mut reqData as *mut PianoRequestDataCreateStation_t as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        free(reqData.token as *mut libc::c_void);
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationcreate\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
pub unsafe extern "C" fn BarUiActCreateStationFromSong(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataCreateStation_t = PianoRequestDataCreateStation_t {
        token: 0 as *mut libc::c_char,
        type_0: PIANO_MUSICTYPE_INVALID,
    };
    let mut selectBuf: [libc::c_char; 2] = [0; 2];
    reqData.token = (*selSong).trackToken;
    reqData.type_0 = PIANO_MUSICTYPE_INVALID;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"Create station from [s]ong or [a]rtist? \0" as *const u8 as *const libc::c_char,
    );
    BarReadline(
        selectBuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
        b"sa\0" as *const u8 as *const libc::c_char,
        &mut (*app___0).input,
        BAR_RL_FULLRETURN,
        -(1 as libc::c_int),
    );
    match selectBuf[0 as libc::c_int as usize] as libc::c_int {
        115 => {
            reqData.type_0 = PIANO_MUSICTYPE_SONG;
        }
        97 => {
            reqData.type_0 = PIANO_MUSICTYPE_ARTIST;
        }
        _ => {}
    }
    if reqData.type_0 as libc::c_uint != 0 as libc::c_uint {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Creating station... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_CREATE_STATION,
            &mut reqData as *mut PianoRequestDataCreateStation_t as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationcreate\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
pub unsafe extern "C" fn BarUiActAddSharedStation(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut stationId: [libc::c_char; 50] = [0; 50];
    let mut reqData: PianoRequestDataCreateStation_t = PianoRequestDataCreateStation_t {
        token: 0 as *mut libc::c_char,
        type_0: PIANO_MUSICTYPE_INVALID,
    };
    let mut tmp: size_t = 0;
    reqData.token = stationId.as_mut_ptr();
    reqData.type_0 = PIANO_MUSICTYPE_INVALID;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"Station id: \0" as *const u8 as *const libc::c_char,
    );
    tmp = BarReadline(
        stationId.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong,
        b"0123456789\0" as *const u8 as *const libc::c_char,
        &mut (*app___0).input,
        BAR_RL_DEFAULT,
        -(1 as libc::c_int),
    );
    if tmp > 0 as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Adding shared station... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_CREATE_STATION,
            &mut reqData as *mut PianoRequestDataCreateStation_t as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationaddshared\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
unsafe extern "C" fn drainPlaylist(app___0: *mut BarApp_t) {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    BarUiDoSkipSong(&mut (*app___0).player as *mut player_t);
    if (*app___0).playlist as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*app___0).playlist as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp = 0 as *mut libc::c_void;
        } else {
            tmp = (*(*app___0).playlist).head.next as *mut libc::c_void;
        }
        PianoDestroyPlaylist(tmp as *mut PianoSong_t);
        (*(*app___0).playlist).head.next = 0 as *mut libc::c_void as *mut PianoListHead;
    }
}
pub unsafe extern "C" fn BarUiActDeleteStation(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut tmp: bool = false;
    let mut tmp___0: bool = false;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"Really delete \"%s\"? [yN] \0" as *const u8 as *const libc::c_char,
        (*selStation).name,
    );
    tmp___0 = BarReadlineYesNo(0 as libc::c_int != 0, &mut (*app___0).input);
    if tmp___0 {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Deleting station... \0" as *const u8 as *const libc::c_char,
        );
        tmp = BarUiPianoCall(
            app___0,
            PIANO_REQUEST_DELETE_STATION,
            selStation as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        if tmp {
            if selStation as libc::c_ulong == (*app___0).curStation as libc::c_ulong {
                drainPlaylist(app___0);
                (*app___0).nextStation = 0 as *mut libc::c_void as *mut PianoStation_t;
                (*app___0).curStation = 0 as *mut libc::c_void as *mut PianoStation_t;
                selStation = 0 as *mut libc::c_void as *mut PianoStation_t;
            }
        }
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationdelete\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
pub unsafe extern "C" fn BarUiActExplain(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataExplain_t = PianoRequestDataExplain_t {
        song: 0 as *mut PianoSong_t,
        retExplain: 0 as *mut libc::c_char,
    };
    let mut tmp: bool = false;
    reqData.song = selSong;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Receiving explanation... \0" as *const u8 as *const libc::c_char,
    );
    tmp = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_EXPLAIN,
        &mut reqData as *mut PianoRequestDataExplain_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    if tmp {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            reqData.retExplain,
        );
        free(reqData.retExplain as *mut libc::c_void);
    }
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"songexplain\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
}
pub unsafe extern "C" fn BarUiActStationFromGenre(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut curCat: *const PianoGenreCategory_t = 0 as *const PianoGenreCategory_t;
    let mut curGenre: *const PianoGenre_t = 0 as *const PianoGenre_t;
    let mut i: libc::c_int = 0;
    let mut ret: bool = false;
    let mut tmp: bool = false;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut reqData: PianoRequestDataCreateStation_t = PianoRequestDataCreateStation_t {
        token: 0 as *mut libc::c_char,
        type_0: PIANO_MUSICTYPE_INVALID,
    };
    if (*app___0).ph.genreStations as libc::c_ulong
        == 0 as *mut libc::c_void as libc::c_ulong
    {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Receiving genre stations... \0" as *const u8 as *const libc::c_char,
        );
        tmp = BarUiPianoCall(
            app___0,
            PIANO_REQUEST_GET_GENRE_STATIONS,
            0 as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        ret = tmp;
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationfetchgenre\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
        if !ret {
            return;
        }
    }
    curCat = (*app___0).ph.genreStations as *const PianoGenreCategory_t;
    i = 0 as libc::c_int;
    while curCat as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_LIST,
            b"%2i) %s\n\0" as *const u8 as *const libc::c_char,
            i,
            (*curCat).name,
        );
        i += 1;
        curCat = (*curCat).head.next as *mut libc::c_void as *const PianoGenreCategory_t;
    }
    loop {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_QUESTION,
            b"Select category: \0" as *const u8 as *const libc::c_char,
        );
        tmp___0 = BarReadlineInt(&mut i, &mut (*app___0).input);
        if tmp___0 == 0 as libc::c_ulong {
            return;
        }
        tmp___1 = PianoListGet(
            &mut (*(*app___0).ph.genreStations).head as *mut PianoListHead_t,
            i as size_t,
        );
        curCat = tmp___1 as *const PianoGenreCategory_t;
        if !(curCat as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
    }
    i = 0 as libc::c_int;
    curGenre = (*curCat).genres as *const PianoGenre_t;
    while curGenre as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_LIST,
            b"%2i) %s\n\0" as *const u8 as *const libc::c_char,
            i,
            (*curGenre).name,
        );
        i += 1;
        curGenre = (*curGenre).head.next as *mut libc::c_void as *const PianoGenre_t;
    }
    loop {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_QUESTION,
            b"Select genre: \0" as *const u8 as *const libc::c_char,
        );
        tmp___2 = BarReadlineInt(&mut i, &mut (*app___0).input);
        if tmp___2 == 0 as libc::c_ulong {
            return;
        }
        tmp___3 = PianoListGet(
            &mut (*(*curCat).genres).head as *mut PianoListHead_t,
            i as size_t,
        );
        curGenre = tmp___3 as *const PianoGenre_t;
        if !(curGenre as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
    }
    reqData.token = (*curGenre).musicId;
    reqData.type_0 = PIANO_MUSICTYPE_INVALID;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Adding genre station \"%s\"... \0" as *const u8 as *const libc::c_char,
        (*curGenre).name,
    );
    BarUiPianoCall(
        app___0,
        PIANO_REQUEST_CREATE_STATION,
        &mut reqData as *mut PianoRequestDataCreateStation_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"stationaddgenre\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
}
pub unsafe extern "C" fn BarUiActSongInfo(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut tmp: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___0: *mut PianoStation_t = 0 as *mut PianoStation_t;
    BarUiPrintStation(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        selStation,
    );
    if (*selStation).isQuickMix != 0 {
        tmp = PianoFindStationById(
            (*app___0).ph.stations,
            (*selSong).stationId as *const libc::c_char,
        );
        tmp___0 = tmp;
    } else {
        tmp___0 = 0 as *mut libc::c_void as *mut PianoStation_t;
    }
    BarUiPrintSong(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        selSong as *const PianoSong_t,
        tmp___0 as *const PianoStation_t,
    );
}
pub unsafe extern "C" fn BarUiActDebug(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_NONE,
        b"album:\t%s\nartist:\t%s\naudioFormat:\t%i\naudioUrl:\t%s\ncoverArt:\t%s\ndetailUrl:\t%s\nfileGain:\t%f\nmusicId:\t%s\nrating:\t%i\nstationId:\t%s\ntitle:\t%s\ntrackToken:\t%s\n\0"
            as *const u8 as *const libc::c_char,
        (*selSong).album,
        (*selSong).artist,
        (*selSong).audioFormat as libc::c_uint,
        (*selSong).audioUrl,
        (*selSong).coverArt,
        (*selSong).detailUrl,
        (*selSong).fileGain as libc::c_double,
        (*selSong).musicId,
        (*selSong).rating as libc::c_uint,
        (*selSong).stationId,
        (*selSong).title,
        (*selSong).trackToken,
    );
}
pub unsafe extern "C" fn BarUiActLoveSong(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut realStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp: libc::c_int = 0;
    let mut reqData: PianoRequestDataRateSong_t = PianoRequestDataRateSong_t {
        song: 0 as *mut PianoSong_t,
        rating: PIANO_RATE_NONE,
    };
    realStation = PianoFindStationById(
        (*app___0).ph.stations,
        (*selSong).stationId as *const libc::c_char,
    );
    if realStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    tmp = BarTransformIfShared(app___0, realStation);
    if tmp == 0 {
        return;
    }
    reqData.song = selSong;
    reqData.rating = PIANO_RATE_LOVE;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Loving song... \0" as *const u8 as *const libc::c_char,
    );
    BarUiPianoCall(
        app___0,
        PIANO_REQUEST_RATE_SONG,
        &mut reqData as *mut PianoRequestDataRateSong_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"songlove\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
}
pub unsafe extern "C" fn BarUiActSkipSong(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    BarUiDoSkipSong(&mut (*app___0).player as *mut player_t);
}
pub unsafe extern "C" fn BarUiActPlay(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    pthread_mutex_lock(&mut (*app___0).player.lock);
    (*app___0).player.doPause = 0 as libc::c_int != 0;
    pthread_cond_broadcast(&mut (*app___0).player.cond);
    pthread_mutex_unlock(&mut (*app___0).player.lock);
}
pub unsafe extern "C" fn BarUiActPause(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    pthread_mutex_lock(&mut (*app___0).player.lock);
    (*app___0).player.doPause = 1 as libc::c_int != 0;
    pthread_cond_broadcast(&mut (*app___0).player.cond);
    pthread_mutex_unlock(&mut (*app___0).player.lock);
}
pub unsafe extern "C" fn BarUiActTogglePause(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    pthread_mutex_lock(&mut (*app___0).player.lock);
    (*app___0).player.doPause = !(*app___0).player.doPause;
    pthread_cond_broadcast(&mut (*app___0).player.cond);
    pthread_mutex_unlock(&mut (*app___0).player.lock);
}
pub unsafe extern "C" fn BarUiActRenameStation(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut lineBuf: [libc::c_char; 100] = [0; 100];
    let mut reqData: PianoRequestDataRenameStation_t = PianoRequestDataRenameStation_t {
        station: 0 as *mut PianoStation_t,
        newName: 0 as *mut libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: size_t = 0;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"New name: \0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = BarReadlineStr(
        lineBuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
        &mut (*app___0).input,
        BAR_RL_DEFAULT,
    );
    if tmp___0 > 0 as libc::c_ulong {
        tmp = BarTransformIfShared(app___0, selStation);
        if tmp == 0 {
            return;
        }
        reqData.station = selStation;
        reqData.newName = lineBuf.as_mut_ptr();
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Renaming station... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_RENAME_STATION,
            &mut reqData as *mut PianoRequestDataRenameStation_t as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationrename\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
pub unsafe extern "C" fn BarUiActSelectStation(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut newStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp: *mut PianoStation_t = 0 as *mut PianoStation_t;
    tmp = BarUiSelectStation(
        app___0,
        (*app___0).ph.stations,
        b"Select station: \0" as *const u8 as *const libc::c_char,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut BarApp_t, *mut libc::c_char) -> ()>,
        >(0 as *mut libc::c_void),
        (*app___0).settings.autoselect,
    );
    newStation = tmp;
    if newStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        (*app___0).nextStation = newStation;
        drainPlaylist(app___0);
    }
}
pub unsafe extern "C" fn BarUiActTempBanSong(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut tmp: bool = false;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Putting song on shelf... \0" as *const u8 as *const libc::c_char,
    );
    tmp = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_ADD_TIRED_SONG,
        selSong as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    if tmp {
        if selSong as libc::c_ulong == (*app___0).playlist as libc::c_ulong {
            BarUiDoSkipSong(&mut (*app___0).player as *mut player_t);
        }
    }
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"songshelf\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
}
pub unsafe extern "C" fn BarUiActPrintUpcoming(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut nextSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if selSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp = 0 as *mut libc::c_void;
    } else {
        tmp = (*selSong).head.next as *mut libc::c_void;
    }
    nextSong = tmp as *mut PianoSong_t;
    if nextSong as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        BarUiListSongs(
            app___0 as *const BarApp_t,
            nextSong as *const PianoSong_t,
            0 as *mut libc::c_void as *const libc::c_char,
        );
    } else {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"No songs in queue.\n\0" as *const u8 as *const libc::c_char,
        );
    };
}
unsafe extern "C" fn BarUiActQuickmixCallback(
    mut app___0: *mut BarApp_t,
    mut buf: *mut libc::c_char,
) {
    let mut curStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    curStation = (*app___0).ph.stations;
    if *buf.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
        return
    } else {
        if *buf.offset(1 as libc::c_int as isize) as libc::c_int != 0 as libc::c_int {
            return;
        }
    }
    match *buf as libc::c_int {
        116 => {
            while curStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                (*curStation)
                    .useQuickMix = ((*curStation).useQuickMix == 0) as libc::c_int
                    as libc::c_char;
                curStation = (*curStation).head.next as *mut libc::c_void
                    as *mut PianoStation_t;
            }
            *buf = '\u{0}' as i32 as libc::c_char;
        }
        97 => {
            while curStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                (*curStation).useQuickMix = 1 as libc::c_int as libc::c_char;
                curStation = (*curStation).head.next as *mut libc::c_void
                    as *mut PianoStation_t;
            }
            *buf = '\u{0}' as i32 as libc::c_char;
        }
        110 => {
            while curStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                (*curStation).useQuickMix = 0 as libc::c_int as libc::c_char;
                curStation = (*curStation).head.next as *mut libc::c_void
                    as *mut PianoStation_t;
            }
            *buf = '\u{0}' as i32 as libc::c_char;
        }
        _ => {}
    };
}
pub unsafe extern "C" fn BarUiActSelectQuickMix(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut toggleStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    if (*selStation).isQuickMix != 0 {
        loop {
            toggleStation = BarUiSelectStation(
                app___0,
                (*app___0).ph.stations,
                b"Toggle QuickMix for station: \0" as *const u8 as *const libc::c_char,
                Some(
                    BarUiActQuickmixCallback
                        as unsafe extern "C" fn(*mut BarApp_t, *mut libc::c_char) -> (),
                ),
                0 as libc::c_int != 0,
            );
            if !(toggleStation as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong)
            {
                break;
            }
            (*toggleStation)
                .useQuickMix = ((*toggleStation).useQuickMix == 0) as libc::c_int
                as libc::c_char;
        }
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Setting QuickMix stations... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_SET_QUICKMIX,
            0 as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"stationquickmixtoggle\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    } else {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_ERR,
            b"Please select a QuickMix station first.\n\0" as *const u8
                as *const libc::c_char,
        );
    };
}
pub unsafe extern "C" fn BarUiActQuit(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    (*app___0).doQuit = 1 as libc::c_int;
    BarUiDoSkipSong(&mut (*app___0).player as *mut player_t);
}
pub unsafe extern "C" fn BarUiActHistory(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut buf: [libc::c_char; 2] = [0; 2];
    let mut histSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut action: BarKeyShortcutId_t = BAR_KS_HELP;
    let mut songStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    if (*app___0).songHistory as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
    {
        histSong = BarUiSelectSong(
            app___0 as *const BarApp_t,
            (*app___0).songHistory,
            &mut (*app___0).input,
        );
        if histSong as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp = PianoFindStationById(
                (*app___0).ph.stations,
                (*histSong).stationId as *const libc::c_char,
            );
            songStation = tmp;
            if songStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_ERR,
                    b"Station does not exist any more.\n\0" as *const u8
                        as *const libc::c_char,
                );
                return;
            }
            loop {
                action = BAR_KS_COUNT;
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_QUESTION,
                    b"What to do with this song? \0" as *const u8 as *const libc::c_char,
                );
                tmp___0 = BarReadline(
                    buf.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
                    0 as *mut libc::c_void as *const libc::c_char,
                    &mut (*app___0).input,
                    BAR_RL_FULLRETURN,
                    -(1 as libc::c_int),
                );
                if tmp___0 > 0 as libc::c_ulong {
                    action = BarUiDispatch(
                        app___0,
                        buf[0 as libc::c_int as usize],
                        songStation,
                        histSong,
                        0 as libc::c_int != 0,
                        BAR_DC_UNDEFINED,
                    );
                }
                if !(action as libc::c_uint == 0 as libc::c_uint) {
                    break;
                }
            }
        }
    } else {
        if (*app___0).settings.history == 0 as libc::c_uint {
            tmp___1 = b"History disabled.\n\0" as *const u8 as *const libc::c_char;
        } else {
            tmp___1 = b"No history yet.\n\0" as *const u8 as *const libc::c_char;
        }
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            tmp___1,
        );
    };
}
pub unsafe extern "C" fn BarUiActBookmark(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut selectBuf: [libc::c_char; 2] = [0; 2];
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"Bookmark [s]ong or [a]rtist? \0" as *const u8 as *const libc::c_char,
    );
    BarReadline(
        selectBuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
        b"sa\0" as *const u8 as *const libc::c_char,
        &mut (*app___0).input,
        BAR_RL_FULLRETURN,
        -(1 as libc::c_int),
    );
    if selectBuf[0 as libc::c_int as usize] as libc::c_int == 115 as libc::c_int {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Bookmarking song... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_BOOKMARK_SONG,
            selSong as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"songbookmark\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    } else if selectBuf[0 as libc::c_int as usize] as libc::c_int == 97 as libc::c_int {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Bookmarking artist... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_BOOKMARK_ARTIST,
            selSong as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"artistbookmark\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
    }
}
pub unsafe extern "C" fn BarUiActVolDown(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    (*app___0).settings.volume -= 1;
    BarPlayerSetVolume(&mut (*app___0).player as *mut player_t);
}
pub unsafe extern "C" fn BarUiActVolUp(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    (*app___0).settings.volume += 1;
    BarPlayerSetVolume(&mut (*app___0).player as *mut player_t);
}
pub unsafe extern "C" fn BarUiActVolReset(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    (*app___0).settings.volume = 0 as libc::c_int;
    BarPlayerSetVolume(&mut (*app___0).player as *mut player_t);
}
unsafe extern "C" fn boolToYesNo(value: bool) -> *const libc::c_char {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if value {
        tmp = b"yes\0" as *const u8 as *const libc::c_char;
    } else {
        tmp = b"no\0" as *const u8 as *const libc::c_char;
    }
    return tmp;
}
pub unsafe extern "C" fn BarUiActSettings(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut settings: PianoSettings_t = PianoSettings_t {
        username: 0 as *mut libc::c_char,
        explicitContentFilter: false,
    };
    let mut reqData: PianoRequestDataChangeSettings_t = PianoRequestDataChangeSettings_t {
        currentUsername: 0 as *mut libc::c_char,
        newUsername: 0 as *mut libc::c_char,
        currentPassword: 0 as *mut libc::c_char,
        newPassword: 0 as *mut libc::c_char,
        explicitContentFilter: PIANO_UNDEFINED,
    };
    let mut modified: bool = false;
    let mut bret: bool = false;
    let mut tmp: bool = false;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut val: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    let mut buf: [libc::c_char; 80] = [0; 80];
    let mut tmp___2: size_t = 0;
    let mut buf___0: [libc::c_char; 80] = [0; 80];
    let mut tmp___3: size_t = 0;
    let mut tmp___5: bool = false;
    modified = 0 as libc::c_int != 0;
    memset(
        &mut settings as *mut PianoSettings_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoSettings_t>() as libc::c_ulong,
    );
    memset(
        &mut reqData as *mut PianoRequestDataChangeSettings_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoRequestDataChangeSettings_t>() as libc::c_ulong,
    );
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Retrieving settings... \0" as *const u8 as *const libc::c_char,
    );
    tmp = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_GET_SETTINGS,
        &mut settings as *mut PianoSettings_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    bret = tmp;
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"settingsget\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
    if !bret {
        return;
    }
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_LIST,
        b" 0) Username (%s)\n\0" as *const u8 as *const libc::c_char,
        settings.username,
    );
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_LIST,
        b" 1) Password (*****)\n\0" as *const u8 as *const libc::c_char,
    );
    tmp___0 = boolToYesNo(settings.explicitContentFilter);
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_LIST,
        b" 2) Explicit content filter (%s)\n\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    loop {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_QUESTION,
            b"Change setting: \0" as *const u8 as *const libc::c_char,
        );
        tmp___1 = BarReadlineInt(&mut val, &mut (*app___0).input);
        if tmp___1 == 0 as libc::c_ulong {
            break;
        }
        match val {
            0 => {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_QUESTION,
                    b"New username: \0" as *const u8 as *const libc::c_char,
                );
                tmp___2 = BarReadlineStr(
                    buf.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
                    &mut (*app___0).input,
                    BAR_RL_DEFAULT,
                );
                if tmp___2 > 0 as libc::c_ulong {
                    reqData
                        .newUsername = strdup(buf.as_mut_ptr() as *const libc::c_char);
                    modified = 1 as libc::c_int != 0;
                }
            }
            1 => {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_QUESTION,
                    b"New password: \0" as *const u8 as *const libc::c_char,
                );
                tmp___3 = BarReadlineStr(
                    buf___0.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
                    &mut (*app___0).input,
                    BAR_RL_NOECHO,
                );
                if tmp___3 > 0 as libc::c_ulong {
                    reqData
                        .newPassword = strdup(
                        buf___0.as_mut_ptr() as *const libc::c_char,
                    );
                    modified = 1 as libc::c_int != 0;
                }
                puts(b"\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_QUESTION,
                    b"Enable explicit content filter? [yn] \0" as *const u8
                        as *const libc::c_char,
                );
                tmp___5 = BarReadlineYesNo(
                    settings.explicitContentFilter,
                    &mut (*app___0).input,
                );
                if tmp___5 {
                    reqData.explicitContentFilter = PIANO_TRUE;
                } else {
                    reqData.explicitContentFilter = PIANO_FALSE;
                }
                modified = 1 as libc::c_int != 0;
            }
            _ => {}
        }
    }
    if modified {
        reqData.currentUsername = (*app___0).settings.username;
        reqData.currentPassword = (*app___0).settings.password;
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Changing settings... \0" as *const u8 as *const libc::c_char,
        );
        BarUiPianoCall(
            app___0,
            PIANO_REQUEST_CHANGE_SETTINGS,
            &mut reqData as *mut PianoRequestDataChangeSettings_t as *mut libc::c_void,
            &mut pRet,
            &mut wRet,
        );
        BarUiStartEventCmd(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            b"settingschange\0" as *const u8 as *const libc::c_char,
            selStation as *const PianoStation_t,
            selSong as *const PianoSong_t,
            &mut (*app___0).player,
            (*app___0).ph.stations,
            pRet,
            wRet,
        );
        if reqData.newUsername as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            free((*app___0).settings.username as *mut libc::c_void);
            (*app___0).settings.username = reqData.newUsername;
        }
        if reqData.newPassword as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
            free((*app___0).settings.password as *mut libc::c_void);
            (*app___0).settings.password = reqData.newPassword;
        }
    }
}
pub unsafe extern "C" fn BarUiActManageStation(
    mut app___0: *mut BarApp_t,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    mut context: BarUiDispatchContext_t,
) {
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataGetStationInfo_t = PianoRequestDataGetStationInfo_t {
        station: 0 as *mut PianoStation_t,
        info: PianoStationInfo_t {
            songSeeds: 0 as *mut PianoSong_t,
            artistSeeds: 0 as *mut PianoArtist_t,
            stationSeeds: 0 as *mut PianoStation_t,
            feedback: 0 as *mut PianoSong_t,
        },
    };
    let mut selectBuf: [libc::c_char; 2] = [0; 2];
    let mut allowedActions: [libc::c_char; 6] = [0; 6];
    let mut allowedPos: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut question: [libc::c_char; 128] = [0; 128];
    let mut bret: bool = false;
    let mut tmp: bool = false;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut artist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut tmp___5: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut subReqData: PianoRequestDataDeleteSeed_t = PianoRequestDataDeleteSeed_t {
        song: 0 as *mut PianoSong_t,
        artist: 0 as *mut PianoArtist_t,
        station: 0 as *mut PianoStation_t,
    };
    let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___6: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut subReqData___0: PianoRequestDataDeleteSeed_t = PianoRequestDataDeleteSeed_t {
        song: 0 as *mut PianoSong_t,
        artist: 0 as *mut PianoArtist_t,
        station: 0 as *mut PianoStation_t,
    };
    let mut station: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___7: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut subReqData___1: PianoRequestDataDeleteSeed_t = PianoRequestDataDeleteSeed_t {
        song: 0 as *mut PianoSong_t,
        artist: 0 as *mut PianoArtist_t,
        station: 0 as *mut PianoStation_t,
    };
    let mut song___0: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___8: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut subReqData___2: PianoRequestDataGetStationModes_t = PianoRequestDataGetStationModes_t {
        station: 0 as *mut PianoStation_t,
        retModes: 0 as *mut PianoStationMode_t,
    };
    let mut curMode: *const PianoStationMode_t = 0 as *const PianoStationMode_t;
    let mut i: libc::c_uint = 0;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut selected: libc::c_int = 0;
    let mut tmp___10: size_t = 0;
    let mut selMode: *const PianoStationMode_t = 0 as *const PianoStationMode_t;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut subReqDataSet: PianoRequestDataSetStationMode_t = PianoRequestDataSetStationMode_t {
        station: 0 as *mut PianoStation_t,
        id: 0,
    };
    let mut tmp___12: bool = false;
    let mut tmp___13: size_t = 0;
    allowedPos = allowedActions.as_mut_ptr();
    memset(
        &mut reqData as *mut PianoRequestDataGetStationInfo_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoRequestDataGetStationInfo_t>() as libc::c_ulong,
    );
    reqData.station = selStation;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_INFO,
        b"Fetching station info... \0" as *const u8 as *const libc::c_char,
    );
    tmp = BarUiPianoCall(
        app___0,
        PIANO_REQUEST_GET_STATION_INFO,
        &mut reqData as *mut PianoRequestDataGetStationInfo_t as *mut libc::c_void,
        &mut pRet,
        &mut wRet,
    );
    bret = tmp;
    BarUiStartEventCmd(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        b"stationfetchinfo\0" as *const u8 as *const libc::c_char,
        selStation as *const PianoStation_t,
        selSong as *const PianoSong_t,
        &mut (*app___0).player,
        (*app___0).ph.stations,
        pRet,
        wRet,
    );
    if !bret {
        return;
    }
    if reqData.info.artistSeeds as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        strcpy(question.as_mut_ptr(), b"Delete \0" as *const u8 as *const libc::c_char);
    } else if reqData.info.songSeeds as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
        strcpy(question.as_mut_ptr(), b"Delete \0" as *const u8 as *const libc::c_char);
    } else if reqData.info.stationSeeds as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
        strcpy(question.as_mut_ptr(), b"Delete \0" as *const u8 as *const libc::c_char);
    } else if reqData.info.feedback as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
        strcpy(question.as_mut_ptr(), b"Delete \0" as *const u8 as *const libc::c_char);
    }
    if reqData.info.artistSeeds as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        strcat(question.as_mut_ptr(), b"[a]rtist\0" as *const u8 as *const libc::c_char);
        tmp___0 = allowedPos;
        allowedPos = allowedPos.offset(1);
        *tmp___0 = 'a' as i32 as libc::c_char;
    }
    if reqData.info.songSeeds as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
    {
        if allowedPos as libc::c_ulong != allowedActions.as_mut_ptr() as libc::c_ulong {
            strcat(question.as_mut_ptr(), b"/\0" as *const u8 as *const libc::c_char);
        }
        strcat(question.as_mut_ptr(), b"[s]ong\0" as *const u8 as *const libc::c_char);
        tmp___1 = allowedPos;
        allowedPos = allowedPos.offset(1);
        *tmp___1 = 's' as i32 as libc::c_char;
    }
    if reqData.info.stationSeeds as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        if allowedPos as libc::c_ulong != allowedActions.as_mut_ptr() as libc::c_ulong {
            strcat(question.as_mut_ptr(), b"/\0" as *const u8 as *const libc::c_char);
        }
        strcat(
            question.as_mut_ptr(),
            b"s[t]ation\0" as *const u8 as *const libc::c_char,
        );
        tmp___2 = allowedPos;
        allowedPos = allowedPos.offset(1);
        *tmp___2 = 't' as i32 as libc::c_char;
    }
    if allowedPos as libc::c_ulong != allowedActions.as_mut_ptr() as libc::c_ulong {
        strcat(question.as_mut_ptr(), b" seeds\0" as *const u8 as *const libc::c_char);
    }
    if reqData.info.feedback as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
    {
        if allowedPos as libc::c_ulong != allowedActions.as_mut_ptr() as libc::c_ulong {
            strcat(question.as_mut_ptr(), b" or \0" as *const u8 as *const libc::c_char);
        }
        strcat(
            question.as_mut_ptr(),
            b"[f]eedback\0" as *const u8 as *const libc::c_char,
        );
        tmp___3 = allowedPos;
        allowedPos = allowedPos.offset(1);
        *tmp___3 = 'f' as i32 as libc::c_char;
    }
    if allowedPos as libc::c_ulong != allowedActions.as_mut_ptr() as libc::c_ulong {
        strcat(question.as_mut_ptr(), b"? \0" as *const u8 as *const libc::c_char);
    }
    if (*selStation).isQuickMix == 0 {
        strcat(
            question.as_mut_ptr(),
            b"Manage [m]ode? \0" as *const u8 as *const libc::c_char,
        );
        tmp___4 = allowedPos;
        allowedPos = allowedPos.offset(1);
        *tmp___4 = 'm' as i32 as libc::c_char;
    }
    *allowedPos = '\u{0}' as i32 as libc::c_char;
    if allowedPos as libc::c_ulong == allowedActions.as_mut_ptr() as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"No actions available.\n\0" as *const u8 as *const libc::c_char,
        );
        return;
    }
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"%s\0" as *const u8 as *const libc::c_char,
        question.as_mut_ptr(),
    );
    tmp___13 = BarReadline(
        selectBuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
        allowedActions.as_mut_ptr() as *const libc::c_char,
        &mut (*app___0).input,
        BAR_RL_FULLRETURN,
        -(1 as libc::c_int),
    );
    if tmp___13 != 0 {
        if selectBuf[0 as libc::c_int as usize] as libc::c_int == 97 as libc::c_int {
            tmp___5 = BarUiSelectArtist(app___0, reqData.info.artistSeeds);
            artist = tmp___5;
            if artist as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                memset(
                    &mut subReqData as *mut PianoRequestDataDeleteSeed_t
                        as *mut libc::c_void,
                    0 as libc::c_int,
                    ::std::mem::size_of::<PianoRequestDataDeleteSeed_t>()
                        as libc::c_ulong,
                );
                subReqData.artist = artist;
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_INFO,
                    b"Deleting artist seed... \0" as *const u8 as *const libc::c_char,
                );
                BarUiPianoCall(
                    app___0,
                    PIANO_REQUEST_DELETE_SEED,
                    &mut subReqData as *mut PianoRequestDataDeleteSeed_t
                        as *mut libc::c_void,
                    &mut pRet,
                    &mut wRet,
                );
                BarUiStartEventCmd(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    b"stationdeleteartistseed\0" as *const u8 as *const libc::c_char,
                    selStation as *const PianoStation_t,
                    selSong as *const PianoSong_t,
                    &mut (*app___0).player,
                    (*app___0).ph.stations,
                    pRet,
                    wRet,
                );
            }
        } else if selectBuf[0 as libc::c_int as usize] as libc::c_int
                == 115 as libc::c_int
            {
            tmp___6 = BarUiSelectSong(
                app___0 as *const BarApp_t,
                reqData.info.songSeeds,
                &mut (*app___0).input,
            );
            song = tmp___6;
            if song as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                memset(
                    &mut subReqData___0 as *mut PianoRequestDataDeleteSeed_t
                        as *mut libc::c_void,
                    0 as libc::c_int,
                    ::std::mem::size_of::<PianoRequestDataDeleteSeed_t>()
                        as libc::c_ulong,
                );
                subReqData___0.song = song;
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_INFO,
                    b"Deleting song seed... \0" as *const u8 as *const libc::c_char,
                );
                BarUiPianoCall(
                    app___0,
                    PIANO_REQUEST_DELETE_SEED,
                    &mut subReqData___0 as *mut PianoRequestDataDeleteSeed_t
                        as *mut libc::c_void,
                    &mut pRet,
                    &mut wRet,
                );
                BarUiStartEventCmd(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    b"stationdeletesongseed\0" as *const u8 as *const libc::c_char,
                    selStation as *const PianoStation_t,
                    selSong as *const PianoSong_t,
                    &mut (*app___0).player,
                    (*app___0).ph.stations,
                    pRet,
                    wRet,
                );
            }
        } else if selectBuf[0 as libc::c_int as usize] as libc::c_int
                == 116 as libc::c_int
            {
            tmp___7 = BarUiSelectStation(
                app___0,
                reqData.info.stationSeeds,
                b"Delete seed station: \0" as *const u8 as *const libc::c_char,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut BarApp_t, *mut libc::c_char) -> (),
                    >,
                >(0 as *mut libc::c_void),
                0 as libc::c_int != 0,
            );
            station = tmp___7;
            if station as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                memset(
                    &mut subReqData___1 as *mut PianoRequestDataDeleteSeed_t
                        as *mut libc::c_void,
                    0 as libc::c_int,
                    ::std::mem::size_of::<PianoRequestDataDeleteSeed_t>()
                        as libc::c_ulong,
                );
                subReqData___1.station = station;
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_INFO,
                    b"Deleting station seed... \0" as *const u8 as *const libc::c_char,
                );
                BarUiPianoCall(
                    app___0,
                    PIANO_REQUEST_DELETE_SEED,
                    &mut subReqData___1 as *mut PianoRequestDataDeleteSeed_t
                        as *mut libc::c_void,
                    &mut pRet,
                    &mut wRet,
                );
                BarUiStartEventCmd(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    b"stationdeletestationseed\0" as *const u8 as *const libc::c_char,
                    selStation as *const PianoStation_t,
                    selSong as *const PianoSong_t,
                    &mut (*app___0).player,
                    (*app___0).ph.stations,
                    pRet,
                    wRet,
                );
            }
        } else if selectBuf[0 as libc::c_int as usize] as libc::c_int
                == 102 as libc::c_int
            {
            tmp___8 = BarUiSelectSong(
                app___0 as *const BarApp_t,
                reqData.info.feedback,
                &mut (*app___0).input,
            );
            song___0 = tmp___8;
            if song___0 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_INFO,
                    b"Deleting feedback... \0" as *const u8 as *const libc::c_char,
                );
                BarUiPianoCall(
                    app___0,
                    PIANO_REQUEST_DELETE_FEEDBACK,
                    song___0 as *mut libc::c_void,
                    &mut pRet,
                    &mut wRet,
                );
                BarUiStartEventCmd(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    b"stationdeletefeedback\0" as *const u8 as *const libc::c_char,
                    selStation as *const PianoStation_t,
                    selSong as *const PianoSong_t,
                    &mut (*app___0).player,
                    (*app___0).ph.stations,
                    pRet,
                    wRet,
                );
            }
        } else if selectBuf[0 as libc::c_int as usize] as libc::c_int
                == 109 as libc::c_int
            {
            subReqData___2.station = selStation;
            subReqData___2.retModes = 0 as *mut PianoStationMode_t;
            BarUiMsg(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_INFO,
                b"Fetching modes... \0" as *const u8 as *const libc::c_char,
            );
            BarUiPianoCall(
                app___0,
                PIANO_REQUEST_GET_STATION_MODES,
                &mut subReqData___2 as *mut PianoRequestDataGetStationModes_t
                    as *mut libc::c_void,
                &mut pRet,
                &mut wRet,
            );
            BarUiStartEventCmd(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                b"stationgetmodes\0" as *const u8 as *const libc::c_char,
                selStation as *const PianoStation_t,
                selSong as *const PianoSong_t,
                &mut (*app___0).player,
                (*app___0).ph.stations,
                pRet,
                wRet,
            );
            curMode = subReqData___2.retModes as *const PianoStationMode_t;
            i = 0 as libc::c_uint;
            while curMode as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*curMode).active {
                    tmp___9 = b" (active)\0" as *const u8 as *const libc::c_char;
                } else {
                    tmp___9 = b"\0" as *const u8 as *const libc::c_char;
                }
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_LIST,
                    b"%2i) %s: %s%s\n\0" as *const u8 as *const libc::c_char,
                    i,
                    (*curMode).name,
                    (*curMode).description,
                    tmp___9,
                );
                i = i.wrapping_add(1);
                curMode = (*curMode).head.next as *mut libc::c_void
                    as *const PianoStationMode_t;
            }
            BarUiMsg(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_QUESTION,
                b"Pick a new mode: \0" as *const u8 as *const libc::c_char,
            );
            loop {
                tmp___10 = BarReadlineInt(&mut selected, &mut (*app___0).input);
                if tmp___10 == 0 as libc::c_ulong {
                    break;
                }
                tmp___11 = PianoListGet(
                    &mut (*subReqData___2.retModes).head as *mut PianoListHead_t,
                    selected as size_t,
                );
                selMode = tmp___11 as *const PianoStationMode_t;
                if !(selMode as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong)
                {
                    continue;
                }
                subReqDataSet.station = selStation;
                subReqDataSet.id = selected as libc::c_uint;
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_INFO,
                    b"Selecting mode \"%s\"... \0" as *const u8 as *const libc::c_char,
                    (*selMode).name,
                );
                tmp___12 = BarUiPianoCall(
                    app___0,
                    PIANO_REQUEST_SET_STATION_MODE,
                    &mut subReqDataSet as *mut PianoRequestDataSetStationMode_t
                        as *mut libc::c_void,
                    &mut pRet,
                    &mut wRet,
                );
                if tmp___12 {
                    drainPlaylist(app___0);
                }
                BarUiStartEventCmd(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    b"stationsetmode\0" as *const u8 as *const libc::c_char,
                    selStation as *const PianoStation_t,
                    selSong as *const PianoSong_t,
                    &mut (*app___0).player,
                    (*app___0).ph.stations,
                    pRet,
                    wRet,
                );
                break;
            }
            PianoDestroyStationMode(subReqData___2.retModes);
        }
    }
    PianoDestroyStationInfo(&mut reqData.info);
}
unsafe extern "C" fn isnumeric(mut s: *const libc::c_char) -> bool {
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    if *s as libc::c_int == 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    while *s as libc::c_int != 0 as libc::c_int {
        tmp = __ctype_b_loc();
        if *(*tmp).offset(*s as libc::c_uchar as libc::c_int as isize) as libc::c_int
            & 2048 as libc::c_int == 0
        {
            return 0 as libc::c_int != 0;
        }
        s = s.offset(1);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn BarStrCaseStr(
    mut haystack: *const libc::c_char,
    mut needle: *const libc::c_char,
) -> *const libc::c_char {
    let mut needlePos: *const libc::c_char = 0 as *const libc::c_char;
    let mut __res: libc::c_int = 0;
    let mut tmp___0: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut __res___0: libc::c_int = 0;
    let mut tmp___2: *mut *const __int32_t = 0 as *mut *const __int32_t;
    let mut tmp___3: size_t = 0;
    needlePos = needle;
    if *needle as libc::c_int == 0 as libc::c_int {
        return haystack;
    }
    while *haystack as libc::c_int != 0 as libc::c_int {
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong > 1 as libc::c_ulong {
            __res = tolower(*haystack as libc::c_uchar as libc::c_int);
        } else {
            tmp___0 = __ctype_tolower_loc();
            __res = *(*tmp___0)
                .offset(*haystack as libc::c_uchar as libc::c_int as isize);
        }
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong > 1 as libc::c_ulong {
            __res___0 = tolower(*needlePos as libc::c_uchar as libc::c_int);
        } else {
            tmp___2 = __ctype_tolower_loc();
            __res___0 = *(*tmp___2)
                .offset(*needlePos as libc::c_uchar as libc::c_int as isize);
        }
        if __res == __res___0 {
            needlePos = needlePos.offset(1);
        } else {
            needlePos = needle;
        }
        haystack = haystack.offset(1);
        if *needlePos as libc::c_int == 0 as libc::c_int {
            tmp___3 = strlen(needle);
            return haystack.offset(-(tmp___3 as isize));
        }
    }
    return 0 as *mut libc::c_void as *const libc::c_char;
}
pub unsafe extern "C" fn BarUiMsg(
    mut settings: *const BarSettings_t,
    type_0: BarUiMsg_t,
    mut format: *const libc::c_char,
    mut args: ...
) {
    let mut fmtargs: ::std::ffi::VaListImpl;
    match type_0 as libc::c_uint {
        6 | 5 | 4 | 3 | 2 | 1 => {
            fputs(b"\x1B[2K\0" as *const u8 as *const libc::c_char, stdout);
        }
        _ => {}
    }
    if (*settings).msgFormat[type_0 as usize].prefix as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        fputs(
            (*settings).msgFormat[type_0 as usize].prefix as *const libc::c_char,
            stdout,
        );
    }
    fmtargs = args.clone();
    vprintf(format, fmtargs.as_va_list());
    if (*settings).msgFormat[type_0 as usize].postfix as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        fputs(
            (*settings).msgFormat[type_0 as usize].postfix as *const libc::c_char,
            stdout,
        );
    }
    fflush(stdout);
}
unsafe extern "C" fn httpFetchCb(
    mut ptr: *mut libc::c_char,
    mut size: size_t,
    mut nmemb: size_t,
    mut userdata: *mut libc::c_void,
) -> size_t {
    let mut buffer___0: *mut buffer = 0 as *mut buffer;
    let mut recvSize: size_t = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut newbuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    buffer___0 = userdata as *mut buffer;
    recvSize = size.wrapping_mul(nmemb);
    if (*buffer___0).data as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = malloc(
            (::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                .wrapping_mul(recvSize.wrapping_add(1 as libc::c_ulong)),
        );
        tmp = tmp___0 as *mut libc::c_char;
        (*buffer___0).data = tmp;
        if tmp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            return 0 as libc::c_int as size_t;
        }
    } else {
        tmp___1 = realloc(
            (*buffer___0).data as *mut libc::c_void,
            (::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                .wrapping_mul(
                    ((*buffer___0).pos)
                        .wrapping_add(recvSize)
                        .wrapping_add(1 as libc::c_ulong),
                ),
        );
        newbuf = tmp___1 as *mut libc::c_char;
        if newbuf as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            free((*buffer___0).data as *mut libc::c_void);
            return 0 as libc::c_int as size_t;
        }
        (*buffer___0).data = newbuf;
    }
    memcpy(
        ((*buffer___0).data).offset((*buffer___0).pos as isize) as *mut libc::c_void,
        ptr as *const libc::c_void,
        recvSize,
    );
    (*buffer___0)
        .pos = ((*buffer___0).pos as libc::c_ulong).wrapping_add(recvSize) as size_t
        as size_t;
    *((*buffer___0).data)
        .offset((*buffer___0).pos as isize) = '\u{0}' as i32 as libc::c_char;
    return recvSize;
}
pub unsafe extern "C" fn progressCb(
    data: *mut libc::c_void,
    mut dltotal: libc::c_double,
    mut dlnow: libc::c_double,
    mut ultotal: libc::c_double,
    mut ulnow: libc::c_double,
) -> libc::c_int {
    let mut lint: sig_atomic_t = 0;
    lint = *(data as *mut sig_atomic_t);
    if lint != 0 { return 1 as libc::c_int } else { return 0 as libc::c_int };
}
unsafe extern "C" fn temporaryCurlError(code: CURLcode) -> bool {
    match code as libc::c_uint {
        56 | 55 | 52 | 35 | 28 | 26 | 8 | 7 | 6 | 5 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn BarPianoHttpRequest(
    http: *mut libc::c_void,
    settings: *const BarSettings_t,
    req: *mut PianoRequest_t,
) -> CURLcode {
    let mut buffer___0: buffer = buffer {
        data: 0 as *mut libc::c_char,
        pos: 0,
    };
    let mut lint: sig_atomic_t = 0;
    let mut prevint: *mut sig_atomic_t = 0 as *mut sig_atomic_t;
    let mut url: [libc::c_char; 2048] = [0; 2048];
    let mut ret: libc::c_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut httpret: CURLcode = CURLE_OK;
    let mut tmp___2: CURLcode = CURLE_OK;
    let mut tmp___3: CURLcode = CURLE_OK;
    let mut tmp___4: CURLcode = CURLE_OK;
    let mut tmp___5: size_t = 0;
    let mut list: *mut curl_slist = 0 as *mut curl_slist;
    let mut retry: libc::c_uint = 0;
    let mut tmp___6: bool = false;
    buffer___0.data = 0 as *mut libc::c_void as *mut libc::c_char;
    buffer___0.pos = 0 as libc::c_int as size_t;
    lint = 0 as libc::c_int;
    if (*req).secure {
        tmp = (*settings).rpcTlsPort as *const libc::c_char;
    } else {
        tmp = b"80\0" as *const u8 as *const libc::c_char;
    }
    if (*req).secure {
        tmp___0 = b"https\0" as *const u8 as *const libc::c_char;
    } else {
        tmp___0 = b"http\0" as *const u8 as *const libc::c_char;
    }
    tmp___1 = snprintf(
        url.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong,
        b"%s://%s:%s%s\0" as *const u8 as *const libc::c_char,
        tmp___0,
        (*settings).rpcHost,
        tmp,
        ((*req).urlPath).as_mut_ptr(),
    );
    ret = tmp___1;
    prevint = interrupted;
    interrupted = &mut lint;
    curl_easy_reset(http);
    httpret = curl_easy_setopt(http, CURLOPT_URL, url.as_mut_ptr());
    httpret = curl_easy_setopt(
        http,
        CURLOPT_USERAGENT,
        b"pianobar-2022.04.01-dev\0" as *const u8 as *const libc::c_char,
    );
    httpret = curl_easy_setopt(http, CURLOPT_POSTFIELDS, (*req).postData);
    httpret = curl_easy_setopt(
        http,
        CURLOPT_WRITEFUNCTION,
        Some(
            httpFetchCb
                as unsafe extern "C" fn(
                    *mut libc::c_char,
                    size_t,
                    size_t,
                    *mut libc::c_void,
                ) -> size_t,
        ),
    );
    httpret = curl_easy_setopt(http, CURLOPT_WRITEDATA, &mut buffer___0 as *mut buffer);
    httpret = curl_easy_setopt(
        http,
        CURLOPT_PROGRESSFUNCTION,
        Some(
            progressCb
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_double,
                    libc::c_double,
                    libc::c_double,
                    libc::c_double,
                ) -> libc::c_int,
        ),
    );
    httpret = curl_easy_setopt(
        http,
        CURLOPT_PROGRESSDATA,
        &mut lint as *mut sig_atomic_t,
    );
    httpret = curl_easy_setopt(http, CURLOPT_NOPROGRESS, 0 as libc::c_int);
    httpret = curl_easy_setopt(http, CURLOPT_POST, 1 as libc::c_int);
    httpret = curl_easy_setopt(http, CURLOPT_TIMEOUT, (*settings).timeout);
    if (*settings).caBundle as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        httpret = curl_easy_setopt(http, CURLOPT_CAINFO, (*settings).caBundle);
    }
    if (*settings).bindTo as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = curl_easy_setopt(http, CURLOPT_INTERFACE, (*settings).bindTo);
        if tmp___2 as libc::c_uint != 0 as libc::c_uint {
            BarUiMsg(
                settings,
                MSG_ERR,
                b"bindTo (%s) is invalid!\n\0" as *const u8 as *const libc::c_char,
                (*settings).bindTo,
            );
        }
    }
    if (*settings).controlProxy as libc::c_ulong
        != 0 as *mut libc::c_void as libc::c_ulong
    {
        tmp___3 = curl_easy_setopt(http, CURLOPT_PROXY, (*settings).controlProxy);
        if tmp___3 as libc::c_uint != 0 as libc::c_uint {
            BarUiMsg(
                settings,
                MSG_ERR,
                b"Control proxy (%s) is invalid!\n\0" as *const u8
                    as *const libc::c_char,
                (*settings).controlProxy,
            );
        }
    } else if (*settings).proxy as libc::c_ulong
            != 0 as *mut libc::c_void as libc::c_ulong
        {
        tmp___5 = strlen((*settings).proxy as *const libc::c_char);
        if tmp___5 > 0 as libc::c_ulong {
            tmp___4 = curl_easy_setopt(http, CURLOPT_PROXY, (*settings).proxy);
            if tmp___4 as libc::c_uint != 0 as libc::c_uint {
                BarUiMsg(
                    settings,
                    MSG_ERR,
                    b"Proxy (%s) is invalid!\n\0" as *const u8 as *const libc::c_char,
                    (*settings).proxy,
                );
            }
        }
    }
    list = 0 as *mut libc::c_void as *mut curl_slist;
    list = curl_slist_append(
        list,
        b"Content-Type: text/plain\0" as *const u8 as *const libc::c_char,
    );
    httpret = curl_easy_setopt(http, CURLOPT_HTTPHEADER, list);
    retry = 0 as libc::c_uint;
    loop {
        httpret = curl_easy_perform(http);
        retry = retry.wrapping_add(1);
        tmp___6 = temporaryCurlError(httpret);
        if !tmp___6 {
            break;
        }
        free(buffer___0.data as *mut libc::c_void);
        buffer___0.data = 0 as *mut libc::c_void as *mut libc::c_char;
        buffer___0.pos = 0 as libc::c_int as size_t;
        if retry >= (*settings).maxRetry {
            break;
        }
    }
    curl_slist_free_all(list);
    (*req).responseData = buffer___0.data;
    interrupted = prevint;
    return httpret;
}
pub unsafe extern "C" fn BarUiPianoCall(
    app___0: *mut BarApp_t,
    type_0: PianoRequestType_t,
    data: *mut libc::c_void,
    pRet: *mut PianoReturn_t,
    wRet: *mut CURLcode,
) -> bool {
    let mut current_block: u64;
    let mut pRetLocal: PianoReturn_t = PIANO_RET_ERR;
    let mut wRetLocal: CURLcode = CURLE_OK;
    let mut ret: bool = false;
    let mut req: PianoRequest_t = PianoRequest_t {
        type_0: 0 as PianoRequestType_t,
        secure: false,
        data: 0 as *mut libc::c_void,
        urlPath: [0; 1024],
        postData: 0 as *mut libc::c_char,
        responseData: 0 as *mut libc::c_char,
    };
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut reqData: PianoRequestDataLogin_t = PianoRequestDataLogin_t {
        user: 0 as *mut libc::c_char,
        password: 0 as *mut libc::c_char,
        step: 0,
    };
    let mut tmp___1: bool = false;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    pRetLocal = PIANO_RET_OK;
    wRetLocal = CURLE_OK;
    ret = 0 as libc::c_int != 0;
    loop {
        req.type_0 = 0 as PianoRequestType_t;
        req.secure = 0 as libc::c_int != 0;
        req.data = data;
        req.urlPath[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[2 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[3 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[4 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[5 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[6 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[7 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[8 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[9 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[10 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[11 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[12 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[13 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[14 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[15 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[16 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[17 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[18 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[19 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[20 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[21 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[22 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[23 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[24 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[25 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[26 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[27 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[28 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[29 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[30 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[31 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[32 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[33 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[34 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[35 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[36 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[37 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[38 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[39 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[40 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[41 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[42 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[43 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[44 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[45 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[46 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[47 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[48 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[49 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[50 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[51 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[52 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[53 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[54 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[55 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[56 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[57 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[58 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[59 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[60 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[61 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[62 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[63 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[64 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[65 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[66 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[67 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[68 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[69 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[70 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[71 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[72 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[73 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[74 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[75 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[76 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[77 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[78 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[79 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[80 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[81 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[82 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[83 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[84 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[85 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[86 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[87 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[88 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[89 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[90 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[91 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[92 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[93 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[94 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[95 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[96 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[97 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[98 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[99 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[100 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[101 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[102 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[103 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[104 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[105 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[106 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[107 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[108 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[109 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[110 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[111 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[112 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[113 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[114 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[115 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[116 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[117 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[118 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[119 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[120 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[121 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[122 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[123 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[124 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[125 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[126 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[127 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[128 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[129 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[130 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[131 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[132 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[133 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[134 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[135 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[136 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[137 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[138 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[139 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[140 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[141 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[142 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[143 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[144 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[145 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[146 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[147 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[148 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[149 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[150 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[151 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[152 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[153 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[154 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[155 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[156 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[157 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[158 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[159 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[160 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[161 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[162 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[163 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[164 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[165 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[166 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[167 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[168 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[169 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[170 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[171 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[172 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[173 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[174 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[175 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[176 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[177 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[178 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[179 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[180 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[181 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[182 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[183 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[184 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[185 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[186 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[187 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[188 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[189 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[190 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[191 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[192 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[193 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[194 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[195 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[196 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[197 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[198 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[199 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[200 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[201 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[202 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[203 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[204 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[205 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[206 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[207 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[208 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[209 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[210 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[211 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[212 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[213 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[214 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[215 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[216 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[217 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[218 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[219 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[220 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[221 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[222 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[223 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[224 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[225 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[226 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[227 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[228 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[229 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[230 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[231 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[232 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[233 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[234 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[235 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[236 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[237 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[238 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[239 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[240 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[241 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[242 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[243 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[244 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[245 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[246 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[247 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[248 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[249 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[250 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[251 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[252 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[253 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[254 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[255 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[256 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[257 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[258 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[259 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[260 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[261 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[262 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[263 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[264 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[265 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[266 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[267 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[268 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[269 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[270 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[271 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[272 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[273 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[274 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[275 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[276 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[277 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[278 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[279 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[280 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[281 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[282 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[283 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[284 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[285 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[286 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[287 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[288 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[289 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[290 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[291 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[292 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[293 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[294 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[295 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[296 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[297 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[298 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[299 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[300 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[301 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[302 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[303 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[304 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[305 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[306 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[307 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[308 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[309 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[310 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[311 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[312 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[313 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[314 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[315 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[316 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[317 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[318 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[319 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[320 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[321 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[322 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[323 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[324 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[325 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[326 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[327 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[328 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[329 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[330 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[331 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[332 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[333 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[334 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[335 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[336 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[337 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[338 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[339 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[340 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[341 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[342 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[343 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[344 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[345 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[346 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[347 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[348 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[349 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[350 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[351 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[352 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[353 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[354 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[355 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[356 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[357 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[358 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[359 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[360 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[361 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[362 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[363 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[364 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[365 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[366 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[367 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[368 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[369 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[370 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[371 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[372 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[373 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[374 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[375 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[376 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[377 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[378 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[379 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[380 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[381 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[382 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[383 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[384 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[385 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[386 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[387 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[388 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[389 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[390 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[391 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[392 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[393 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[394 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[395 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[396 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[397 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[398 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[399 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[400 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[401 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[402 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[403 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[404 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[405 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[406 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[407 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[408 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[409 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[410 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[411 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[412 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[413 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[414 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[415 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[416 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[417 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[418 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[419 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[420 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[421 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[422 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[423 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[424 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[425 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[426 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[427 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[428 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[429 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[430 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[431 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[432 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[433 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[434 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[435 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[436 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[437 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[438 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[439 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[440 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[441 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[442 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[443 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[444 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[445 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[446 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[447 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[448 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[449 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[450 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[451 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[452 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[453 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[454 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[455 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[456 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[457 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[458 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[459 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[460 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[461 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[462 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[463 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[464 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[465 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[466 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[467 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[468 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[469 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[470 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[471 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[472 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[473 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[474 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[475 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[476 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[477 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[478 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[479 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[480 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[481 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[482 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[483 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[484 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[485 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[486 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[487 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[488 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[489 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[490 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[491 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[492 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[493 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[494 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[495 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[496 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[497 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[498 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[499 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[500 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[501 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[502 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[503 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[504 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[505 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[506 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[507 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[508 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[509 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[510 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[511 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[512 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[513 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[514 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[515 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[516 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[517 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[518 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[519 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[520 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[521 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[522 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[523 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[524 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[525 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[526 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[527 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[528 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[529 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[530 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[531 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[532 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[533 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[534 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[535 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[536 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[537 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[538 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[539 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[540 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[541 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[542 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[543 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[544 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[545 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[546 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[547 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[548 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[549 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[550 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[551 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[552 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[553 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[554 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[555 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[556 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[557 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[558 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[559 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[560 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[561 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[562 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[563 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[564 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[565 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[566 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[567 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[568 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[569 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[570 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[571 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[572 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[573 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[574 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[575 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[576 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[577 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[578 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[579 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[580 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[581 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[582 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[583 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[584 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[585 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[586 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[587 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[588 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[589 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[590 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[591 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[592 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[593 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[594 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[595 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[596 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[597 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[598 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[599 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[600 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[601 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[602 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[603 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[604 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[605 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[606 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[607 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[608 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[609 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[610 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[611 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[612 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[613 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[614 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[615 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[616 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[617 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[618 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[619 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[620 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[621 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[622 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[623 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[624 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[625 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[626 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[627 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[628 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[629 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[630 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[631 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[632 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[633 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[634 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[635 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[636 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[637 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[638 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[639 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[640 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[641 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[642 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[643 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[644 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[645 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[646 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[647 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[648 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[649 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[650 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[651 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[652 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[653 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[654 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[655 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[656 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[657 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[658 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[659 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[660 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[661 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[662 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[663 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[664 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[665 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[666 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[667 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[668 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[669 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[670 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[671 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[672 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[673 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[674 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[675 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[676 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[677 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[678 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[679 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[680 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[681 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[682 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[683 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[684 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[685 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[686 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[687 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[688 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[689 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[690 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[691 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[692 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[693 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[694 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[695 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[696 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[697 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[698 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[699 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[700 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[701 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[702 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[703 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[704 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[705 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[706 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[707 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[708 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[709 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[710 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[711 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[712 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[713 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[714 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[715 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[716 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[717 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[718 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[719 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[720 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[721 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[722 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[723 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[724 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[725 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[726 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[727 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[728 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[729 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[730 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[731 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[732 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[733 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[734 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[735 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[736 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[737 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[738 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[739 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[740 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[741 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[742 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[743 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[744 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[745 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[746 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[747 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[748 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[749 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[750 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[751 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[752 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[753 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[754 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[755 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[756 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[757 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[758 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[759 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[760 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[761 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[762 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[763 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[764 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[765 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[766 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[767 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[768 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[769 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[770 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[771 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[772 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[773 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[774 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[775 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[776 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[777 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[778 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[779 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[780 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[781 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[782 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[783 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[784 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[785 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[786 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[787 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[788 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[789 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[790 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[791 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[792 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[793 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[794 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[795 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[796 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[797 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[798 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[799 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[800 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[801 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[802 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[803 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[804 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[805 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[806 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[807 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[808 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[809 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[810 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[811 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[812 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[813 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[814 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[815 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[816 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[817 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[818 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[819 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[820 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[821 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[822 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[823 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[824 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[825 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[826 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[827 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[828 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[829 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[830 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[831 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[832 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[833 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[834 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[835 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[836 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[837 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[838 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[839 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[840 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[841 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[842 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[843 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[844 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[845 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[846 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[847 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[848 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[849 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[850 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[851 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[852 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[853 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[854 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[855 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[856 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[857 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[858 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[859 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[860 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[861 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[862 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[863 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[864 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[865 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[866 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[867 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[868 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[869 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[870 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[871 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[872 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[873 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[874 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[875 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[876 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[877 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[878 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[879 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[880 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[881 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[882 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[883 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[884 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[885 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[886 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[887 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[888 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[889 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[890 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[891 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[892 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[893 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[894 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[895 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[896 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[897 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[898 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[899 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[900 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[901 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[902 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[903 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[904 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[905 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[906 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[907 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[908 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[909 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[910 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[911 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[912 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[913 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[914 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[915 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[916 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[917 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[918 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[919 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[920 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[921 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[922 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[923 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[924 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[925 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[926 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[927 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[928 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[929 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[930 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[931 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[932 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[933 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[934 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[935 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[936 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[937 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[938 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[939 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[940 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[941 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[942 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[943 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[944 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[945 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[946 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[947 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[948 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[949 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[950 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[951 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[952 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[953 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[954 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[955 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[956 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[957 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[958 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[959 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[960 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[961 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[962 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[963 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[964 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[965 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[966 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[967 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[968 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[969 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[970 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[971 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[972 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[973 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[974 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[975 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[976 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[977 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[978 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[979 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[980 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[981 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[982 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[983 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[984 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[985 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[986 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[987 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[988 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[989 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[990 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[991 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[992 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[993 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[994 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[995 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[996 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[997 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[998 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[999 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1000 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1001 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1002 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1003 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1004 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1005 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1006 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1007 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1008 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1009 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1010 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1011 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1012 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1013 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1014 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1015 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1016 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1017 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1018 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1019 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1020 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1021 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1022 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.urlPath[1023 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        req.postData = 0 as *mut libc::c_char;
        req.responseData = 0 as *mut libc::c_void as *mut libc::c_char;
        pRetLocal = PianoRequest(&mut (*app___0).ph, &mut req, type_0);
        if pRetLocal as libc::c_uint != 1 as libc::c_uint {
            tmp = PianoErrorToStr(pRetLocal);
            BarUiMsg(
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                MSG_NONE,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                tmp,
            );
        } else {
            wRetLocal = BarPianoHttpRequest(
                (*app___0).http,
                &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
                &mut req as *mut PianoRequest_t,
            );
            if wRetLocal as libc::c_uint == 42 as libc::c_uint {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_NONE,
                    b"Interrupted.\n\0" as *const u8 as *const libc::c_char,
                );
            } else if wRetLocal as libc::c_uint != 0 as libc::c_uint {
                tmp___0 = curl_easy_strerror(wRetLocal);
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_NONE,
                    b"Network error: %s\n\0" as *const u8 as *const libc::c_char,
                    tmp___0,
                );
            } else {
                pRetLocal = PianoResponse(&mut (*app___0).ph, &mut req);
                if pRetLocal as libc::c_uint != 3 as libc::c_uint {
                    if pRetLocal as libc::c_uint == 2025 as libc::c_uint {
                        if type_0 as libc::c_uint != 1 as libc::c_uint {
                            reqData.user = (*app___0).settings.username;
                            reqData.password = (*app___0).settings.password;
                            reqData.step = 0 as libc::c_int as libc::c_uchar;
                            BarUiMsg(
                                &mut (*app___0).settings as *mut BarSettings_t
                                    as *const BarSettings_t,
                                MSG_NONE,
                                b"Reauthentication required... \0" as *const u8
                                    as *const libc::c_char,
                            );
                            tmp___1 = BarUiPianoCall(
                                app___0,
                                PIANO_REQUEST_LOGIN,
                                &mut reqData as *mut PianoRequestDataLogin_t
                                    as *mut libc::c_void,
                                &mut pRetLocal as *mut PianoReturn_t,
                                &mut wRetLocal as *mut CURLcode,
                            );
                            if tmp___1 {
                                pRetLocal = PIANO_RET_CONTINUE_REQUEST;
                                BarUiMsg(
                                    &mut (*app___0).settings as *mut BarSettings_t
                                        as *const BarSettings_t,
                                    MSG_INFO,
                                    b"Trying again... \0" as *const u8 as *const libc::c_char,
                                );
                                current_block = 3512116851682456468;
                            } else {
                                current_block = 3512116851682456468;
                            }
                        } else {
                            current_block = 16327080829840353395;
                        }
                    } else {
                        current_block = 16327080829840353395;
                    }
                    match current_block {
                        3512116851682456468 => {}
                        _ => {
                            if pRetLocal as libc::c_uint != 1 as libc::c_uint {
                                tmp___2 = PianoErrorToStr(pRetLocal);
                                BarUiMsg(
                                    &mut (*app___0).settings as *mut BarSettings_t
                                        as *const BarSettings_t,
                                    MSG_NONE,
                                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                    tmp___2,
                                );
                            } else {
                                BarUiMsg(
                                    &mut (*app___0).settings as *mut BarSettings_t
                                        as *const BarSettings_t,
                                    MSG_NONE,
                                    b"Ok.\n\0" as *const u8 as *const libc::c_char,
                                );
                                ret = 1 as libc::c_int != 0;
                            }
                        }
                    }
                }
            }
        }
        free(req.responseData as *mut libc::c_void);
        PianoDestroyRequest(&mut req);
        if !(pRetLocal as libc::c_uint == 3 as libc::c_uint) {
            break;
        }
    }
    *pRet = pRetLocal;
    *wRet = wRetLocal;
    return ret;
}
#[inline]
unsafe extern "C" fn BarStationQuickmix01Cmp(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut stationA: *const PianoStation_t = 0 as *const PianoStation_t;
    let mut stationB: *const PianoStation_t = 0 as *const PianoStation_t;
    stationA = *(a as *const *mut PianoStation_t) as *const PianoStation_t;
    stationB = *(b as *const *mut PianoStation_t) as *const PianoStation_t;
    return (*stationA).isQuickMix as libc::c_int - (*stationB).isQuickMix as libc::c_int;
}
#[inline]
unsafe extern "C" fn BarStationNameAZCmp(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut stationA: *const PianoStation_t = 0 as *const PianoStation_t;
    let mut stationB: *const PianoStation_t = 0 as *const PianoStation_t;
    let mut tmp: libc::c_int = 0;
    stationA = *(a as *const *mut PianoStation_t) as *const PianoStation_t;
    stationB = *(b as *const *mut PianoStation_t) as *const PianoStation_t;
    tmp = strcasecmp(
        (*stationA).name as *const libc::c_char,
        (*stationB).name as *const libc::c_char,
    );
    return tmp;
}
unsafe extern "C" fn BarStationNameZACmp(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = BarStationNameAZCmp(b, a);
    return tmp;
}
#[inline]
unsafe extern "C" fn BarStationQuickmixNameCmp(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut c: *const libc::c_void,
    mut d: *const libc::c_void,
) -> libc::c_int {
    let mut qmc: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = BarStationQuickmix01Cmp(a, b);
    qmc = tmp;
    if qmc == 0 as libc::c_int {
        tmp___0 = BarStationNameAZCmp(c, d);
        tmp___1 = tmp___0;
    } else {
        tmp___1 = qmc;
    }
    return tmp___1;
}
unsafe extern "C" fn BarStationCmpQuickmix01NameAZ(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = BarStationQuickmixNameCmp(a, b, a, b);
    return tmp;
}
unsafe extern "C" fn BarStationCmpQuickmix01NameZA(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = BarStationQuickmixNameCmp(a, b, b, a);
    return tmp;
}
unsafe extern "C" fn BarStationCmpQuickmix10NameAZ(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = BarStationQuickmixNameCmp(b, a, a, b);
    return tmp;
}
unsafe extern "C" fn BarStationCmpQuickmix10NameZA(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = BarStationQuickmixNameCmp(b, a, b, a);
    return tmp;
}
static mut orderMapping: [BarSortFunc_t; 6] = unsafe {
    [
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
            BarSortFunc_t,
        >(
            Some(
                BarStationNameAZCmp
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        ),
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
            BarSortFunc_t,
        >(
            Some(
                BarStationNameZACmp
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        ),
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
            BarSortFunc_t,
        >(
            Some(
                BarStationCmpQuickmix01NameAZ
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        ),
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
            BarSortFunc_t,
        >(
            Some(
                BarStationCmpQuickmix01NameZA
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        ),
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
            BarSortFunc_t,
        >(
            Some(
                BarStationCmpQuickmix10NameAZ
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        ),
        ::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
            >,
            BarSortFunc_t,
        >(
            Some(
                BarStationCmpQuickmix10NameZA
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        ),
    ]
};
unsafe extern "C" fn BarSortedStations(
    mut unsortedStations: *mut PianoStation_t,
    mut retStationCount: *mut size_t,
    mut order: BarStationSorting_t,
) -> *mut *mut PianoStation_t {
    let mut stationArray: *mut *mut PianoStation_t = 0 as *mut *mut PianoStation_t;
    let mut currStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut stationCount: size_t = 0;
    let mut i: size_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    stationArray = 0 as *mut libc::c_void as *mut *mut PianoStation_t;
    currStation = 0 as *mut libc::c_void as *mut PianoStation_t;
    stationCount = 0 as libc::c_int as size_t;
    stationCount = PianoListCount(
        &mut (*unsortedStations).head as *mut PianoListHead_t as *const PianoListHead_t,
    );
    tmp = calloc(
        stationCount,
        ::std::mem::size_of::<*mut PianoStation_t>() as libc::c_ulong,
    );
    stationArray = tmp as *mut *mut PianoStation_t;
    i = 0 as libc::c_int as size_t;
    currStation = unsortedStations;
    while currStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        let ref mut fresh6 = *stationArray.offset(i as isize);
        *fresh6 = currStation;
        i = i.wrapping_add(1);
        currStation = (*currStation).head.next as *mut libc::c_void
            as *mut PianoStation_t;
    }
    qsort(
        stationArray as *mut libc::c_void,
        stationCount,
        ::std::mem::size_of::<*mut PianoStation_t>() as libc::c_ulong,
        orderMapping[order as usize],
    );
    *retStationCount = stationCount;
    return stationArray;
}
pub unsafe extern "C" fn BarUiSelectStation(
    mut app___0: *mut BarApp_t,
    mut stations: *mut PianoStation_t,
    mut prompt: *const libc::c_char,
    mut callback: Option::<unsafe extern "C" fn(*mut BarApp_t, *mut libc::c_char) -> ()>,
    mut autoselect: bool,
) -> *mut PianoStation_t {
    let mut current_block: u64;
    let mut sortedStations: *mut *mut PianoStation_t = 0 as *mut *mut PianoStation_t;
    let mut retStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut stationCount: size_t = 0;
    let mut i: size_t = 0;
    let mut lastDisplayed: size_t = 0;
    let mut displayCount: size_t = 0;
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut currStation: *const PianoStation_t = 0 as *const PianoStation_t;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: size_t = 0;
    let mut selected: libc::c_ulong = 0;
    let mut tmp___4: libc::c_ulong = 0;
    let mut tmp___5: bool = false;
    sortedStations = 0 as *mut libc::c_void as *mut *mut PianoStation_t;
    retStation = 0 as *mut libc::c_void as *mut PianoStation_t;
    if stations as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_ERR,
            b"No station available.\n\0" as *const u8 as *const libc::c_char,
        );
        return 0 as *mut libc::c_void as *mut PianoStation_t;
    }
    memset(
        buf.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
    );
    sortedStations = BarSortedStations(
        stations,
        &mut stationCount,
        (*app___0).settings.sortOrder,
    );
    loop {
        displayCount = 0 as libc::c_int as size_t;
        i = 0 as libc::c_int as size_t;
        while i < stationCount {
            currStation = *sortedStations.offset(i as isize) as *const PianoStation_t;
            tmp___2 = BarStrCaseStr(
                (*currStation).name as *const libc::c_char,
                buf.as_mut_ptr() as *const libc::c_char,
            );
            if tmp___2 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if (*currStation).isCreator == 0 {
                    tmp = 'S' as i32;
                } else {
                    tmp = ' ' as i32;
                }
                if (*currStation).isQuickMix != 0 {
                    tmp___0 = 'Q' as i32;
                } else {
                    tmp___0 = ' ' as i32;
                }
                if (*currStation).useQuickMix != 0 {
                    tmp___1 = 'q' as i32;
                } else {
                    tmp___1 = ' ' as i32;
                }
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_LIST,
                    b"%2zi) %c%c%c %s\n\0" as *const u8 as *const libc::c_char,
                    i,
                    tmp___1,
                    tmp___0,
                    tmp,
                    (*currStation).name,
                );
                displayCount = displayCount.wrapping_add(1);
                lastDisplayed = i;
            }
            i = i.wrapping_add(1);
        }
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_QUESTION,
            b"%s\0" as *const u8 as *const libc::c_char,
            prompt,
        );
        if autoselect {
            if displayCount == 1 as libc::c_ulong {
                if stationCount != 1 as libc::c_ulong {
                    BarUiMsg(
                        &mut (*app___0).settings as *mut BarSettings_t
                            as *const BarSettings_t,
                        MSG_NONE,
                        b"%zi\n\0" as *const u8 as *const libc::c_char,
                        lastDisplayed,
                    );
                    retStation = *sortedStations.offset(lastDisplayed as isize);
                    current_block = 13281731871476506071;
                } else {
                    current_block = 12214751728855619512;
                }
            } else {
                current_block = 12214751728855619512;
            }
        } else {
            current_block = 12214751728855619512;
        }
        match current_block {
            12214751728855619512 => {
                tmp___3 = BarReadlineStr(
                    buf.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
                    &mut (*app___0).input,
                    BAR_RL_DEFAULT,
                );
                if tmp___3 == 0 as libc::c_ulong {
                    break;
                }
                tmp___5 = isnumeric(buf.as_mut_ptr() as *const libc::c_char);
                if tmp___5 {
                    tmp___4 = strtoul(
                        buf.as_mut_ptr() as *const libc::c_char,
                        0 as *mut libc::c_void as *mut *mut libc::c_char,
                        0 as libc::c_int,
                    );
                    selected = tmp___4;
                    if selected < stationCount {
                        retStation = *sortedStations.offset(selected as isize);
                    }
                }
                if retStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                {
                    if ::std::mem::transmute::<
                        Option::<
                            unsafe extern "C" fn(*mut BarApp_t, *mut libc::c_char) -> (),
                        >,
                        libc::c_ulong,
                    >(callback) != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        (Some(callback.expect("non-null function pointer")))
                            .expect(
                                "non-null function pointer",
                            )(app___0, buf.as_mut_ptr());
                    }
                }
            }
            _ => {}
        }
        if !(retStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
    }
    free(sortedStations as *mut libc::c_void);
    return retStation;
}
pub unsafe extern "C" fn BarUiSelectSong(
    app___0: *const BarApp_t,
    mut startSong: *mut PianoSong_t,
    mut input: *mut BarReadlineFds_t,
) -> *mut PianoSong_t {
    let mut settings: *const BarSettings_t = 0 as *const BarSettings_t;
    let mut tmpSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut tmp: size_t = 0;
    let mut i: libc::c_ulong = 0;
    let mut tmp___0: libc::c_ulong = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: bool = false;
    settings = &(*app___0).settings;
    tmpSong = 0 as *mut libc::c_void as *mut PianoSong_t;
    memset(
        buf.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
    );
    loop {
        BarUiListSongs(
            app___0,
            startSong as *const PianoSong_t,
            buf.as_mut_ptr() as *const libc::c_char,
        );
        BarUiMsg(
            settings,
            MSG_QUESTION,
            b"Select song: \0" as *const u8 as *const libc::c_char,
        );
        tmp = BarReadlineStr(
            buf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            input,
            BAR_RL_DEFAULT,
        );
        if tmp == 0 as libc::c_ulong {
            return 0 as *mut libc::c_void as *mut PianoSong_t;
        }
        tmp___2 = isnumeric(buf.as_mut_ptr() as *const libc::c_char);
        if tmp___2 {
            tmp___0 = strtoul(
                buf.as_mut_ptr() as *const libc::c_char,
                0 as *mut libc::c_void as *mut *mut libc::c_char,
                0 as libc::c_int,
            );
            i = tmp___0;
            tmp___1 = PianoListGet(&mut (*startSong).head as *mut PianoListHead_t, i);
            tmpSong = tmp___1 as *mut PianoSong_t;
        }
        if !(tmpSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
    }
    return tmpSong;
}
pub unsafe extern "C" fn BarUiSelectArtist(
    mut app___0: *mut BarApp_t,
    mut startArtist: *mut PianoArtist_t,
) -> *mut PianoArtist_t {
    let mut tmpArtist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut i: libc::c_ulong = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: bool = false;
    tmpArtist = 0 as *mut libc::c_void as *mut PianoArtist_t;
    memset(
        buf.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
    );
    loop {
        i = 0 as libc::c_ulong;
        tmpArtist = startArtist;
        while tmpArtist as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp = BarStrCaseStr(
                (*tmpArtist).name as *const libc::c_char,
                buf.as_mut_ptr() as *const libc::c_char,
            );
            if tmp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_LIST,
                    b"%2lu) %s\n\0" as *const u8 as *const libc::c_char,
                    i,
                    (*tmpArtist).name,
                );
            }
            i = i.wrapping_add(1);
            tmpArtist = (*tmpArtist).head.next as *mut libc::c_void
                as *mut PianoArtist_t;
        }
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_QUESTION,
            b"Select artist: \0" as *const u8 as *const libc::c_char,
        );
        tmp___0 = BarReadlineStr(
            buf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            &mut (*app___0).input,
            BAR_RL_DEFAULT,
        );
        if tmp___0 == 0 as libc::c_ulong {
            return 0 as *mut libc::c_void as *mut PianoArtist_t;
        }
        tmp___2 = isnumeric(buf.as_mut_ptr() as *const libc::c_char);
        if tmp___2 {
            i = strtoul(
                buf.as_mut_ptr() as *const libc::c_char,
                0 as *mut libc::c_void as *mut *mut libc::c_char,
                0 as libc::c_int,
            );
            tmp___1 = PianoListGet(&mut (*startArtist).head as *mut PianoListHead_t, i);
            tmpArtist = tmp___1 as *mut PianoArtist_t;
        }
        if !(tmpArtist as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
            break;
        }
    }
    return tmpArtist;
}
pub unsafe extern "C" fn BarUiSelectMusicId(
    mut app___0: *mut BarApp_t,
    mut station: *mut PianoStation_t,
    mut msg: *const libc::c_char,
) -> *mut libc::c_char {
    let mut musicId: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut lineBuf: [libc::c_char; 100] = [0; 100];
    let mut selectBuf: [libc::c_char; 2] = [0; 2];
    let mut searchResult: PianoSearchResult_t = PianoSearchResult_t {
        songs: 0 as *mut PianoSong_t,
        artists: 0 as *mut PianoArtist_t,
    };
    let mut tmpArtist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut tmpSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut pRet: PianoReturn_t = PIANO_RET_ERR;
    let mut wRet: CURLcode = CURLE_OK;
    let mut reqData: PianoRequestDataSearch_t = PianoRequestDataSearch_t {
        searchStr: 0 as *mut libc::c_char,
        searchResult: PianoSearchResult_t {
            songs: 0 as *mut PianoSong_t,
            artists: 0 as *mut PianoArtist_t,
        },
    };
    let mut tmp: bool = false;
    let mut tmp___0: size_t = 0;
    musicId = 0 as *mut libc::c_void as *mut libc::c_char;
    BarUiMsg(
        &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
        MSG_QUESTION,
        b"%s\0" as *const u8 as *const libc::c_char,
        msg,
    );
    tmp___0 = BarReadlineStr(
        lineBuf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
        &mut (*app___0).input,
        BAR_RL_DEFAULT,
    );
    if tmp___0 > 0 as libc::c_ulong {
        reqData.searchStr = lineBuf.as_mut_ptr();
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_INFO,
            b"Searching... \0" as *const u8 as *const libc::c_char,
        );
        tmp = BarUiPianoCall(
            app___0,
            PIANO_REQUEST_SEARCH,
            &mut reqData as *mut PianoRequestDataSearch_t as *mut libc::c_void,
            &mut pRet as *mut PianoReturn_t,
            &mut wRet as *mut CURLcode,
        );
        if !tmp {
            return 0 as *mut libc::c_void as *mut libc::c_char;
        }
        memcpy(
            &mut searchResult as *mut PianoSearchResult_t as *mut libc::c_void,
            &mut reqData.searchResult as *mut PianoSearchResult_t as *const libc::c_void,
            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
        );
        BarUiMsg(
            &mut (*app___0).settings as *mut BarSettings_t as *const BarSettings_t,
            MSG_NONE,
            b"\r\0" as *const u8 as *const libc::c_char,
        );
        let mut current_block_39: u64;
        if searchResult.songs as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
        {
            if searchResult.artists as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                BarUiMsg(
                    &mut (*app___0).settings as *mut BarSettings_t
                        as *const BarSettings_t,
                    MSG_QUESTION,
                    b"Is this an [a]rtist or [t]rack name? \0" as *const u8
                        as *const libc::c_char,
                );
                BarReadline(
                    selectBuf.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
                    b"at\0" as *const u8 as *const libc::c_char,
                    &mut (*app___0).input,
                    BAR_RL_FULLRETURN,
                    -(1 as libc::c_int),
                );
                if selectBuf[0 as libc::c_int as usize] as libc::c_int
                    == 97 as libc::c_int
                {
                    tmpArtist = BarUiSelectArtist(app___0, searchResult.artists);
                    if tmpArtist as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        musicId = strdup((*tmpArtist).musicId as *const libc::c_char);
                    }
                } else if selectBuf[0 as libc::c_int as usize] as libc::c_int
                        == 116 as libc::c_int
                    {
                    tmpSong = BarUiSelectSong(
                        app___0 as *const BarApp_t,
                        searchResult.songs,
                        &mut (*app___0).input,
                    );
                    if tmpSong as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        musicId = strdup((*tmpSong).musicId as *const libc::c_char);
                    }
                }
                current_block_39 = 7659304154607701039;
            } else {
                current_block_39 = 4067331642388638071;
            }
        } else {
            current_block_39 = 4067331642388638071;
        }
        match current_block_39 {
            4067331642388638071 => {
                if searchResult.songs as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                    tmpSong = BarUiSelectSong(
                        app___0 as *const BarApp_t,
                        searchResult.songs,
                        &mut (*app___0).input,
                    );
                    if tmpSong as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        musicId = strdup((*tmpSong).musicId as *const libc::c_char);
                    }
                } else if searchResult.artists as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                    tmpArtist = BarUiSelectArtist(app___0, searchResult.artists);
                    if tmpArtist as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        musicId = strdup((*tmpArtist).musicId as *const libc::c_char);
                    }
                } else {
                    BarUiMsg(
                        &mut (*app___0).settings as *mut BarSettings_t
                            as *const BarSettings_t,
                        MSG_INFO,
                        b"Nothing found...\n\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            _ => {}
        }
        PianoDestroySearchResult(&mut searchResult);
    }
    return musicId;
}
pub unsafe extern "C" fn BarUiCustomFormat(
    mut dest: *mut libc::c_char,
    mut destSize: size_t,
    mut format: *const libc::c_char,
    mut formatChars: *const libc::c_char,
    mut formatVals: *mut *const libc::c_char,
) {
    let mut haveFormatChar: bool = false;
    let mut testChar: *const libc::c_char = 0 as *const libc::c_char;
    let mut val: *const libc::c_char = 0 as *const libc::c_char;
    haveFormatChar = 0 as libc::c_int != 0;
    while *format as libc::c_int != 0 as libc::c_int {
        if !(destSize > 1 as libc::c_ulong) {
            break;
        }
        let mut current_block_30: u64;
        if *format as libc::c_int == 37 as libc::c_int {
            if !haveFormatChar {
                haveFormatChar = 1 as libc::c_int != 0;
                current_block_30 = 14832935472441733737;
            } else {
                current_block_30 = 17970263819832340115;
            }
        } else {
            current_block_30 = 17970263819832340115;
        }
        match current_block_30 {
            17970263819832340115 => {
                if haveFormatChar {
                    testChar = formatChars;
                    val = 0 as *mut libc::c_void as *const libc::c_char;
                    while *testChar as libc::c_int != 0 as libc::c_int {
                        if *testChar as libc::c_int == *format as libc::c_int {
                            val = *formatVals
                                .offset(
                                    (testChar.offset_from(formatChars) as libc::c_long
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ) as isize,
                                );
                            break;
                        } else {
                            testChar = testChar.offset(1);
                        }
                    }
                    if val as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                        while *val as libc::c_int != 0 as libc::c_int {
                            if !(destSize > 1 as libc::c_ulong) {
                                break;
                            }
                            *dest = *val;
                            val = val.offset(1);
                            dest = dest.offset(1);
                            destSize = destSize.wrapping_sub(1);
                        }
                    } else {
                        *dest = '%' as i32 as libc::c_char;
                        dest = dest.offset(1);
                        destSize = destSize.wrapping_sub(1);
                        if destSize > 1 as libc::c_ulong {
                            *dest = *format;
                            dest = dest.offset(1);
                            destSize = destSize.wrapping_sub(1);
                        }
                    }
                    haveFormatChar = 0 as libc::c_int != 0;
                } else {
                    *dest = *format;
                    dest = dest.offset(1);
                    destSize = destSize.wrapping_sub(1);
                }
            }
            _ => {}
        }
        format = format.offset(1);
    }
    *dest = '\u{0}' as i32 as libc::c_char;
}
unsafe extern "C" fn BarUiAppendNewline(mut s: *mut libc::c_char, mut maxlen: size_t) {
    let mut len: size_t = 0;
    len = strlen(s as *const libc::c_char);
    if len == maxlen.wrapping_sub(1 as libc::c_ulong) {
        *s
            .offset(
                maxlen.wrapping_sub(2 as libc::c_ulong) as isize,
            ) = '\n' as i32 as libc::c_char;
    } else {
        *s.offset(len as isize) = '\n' as i32 as libc::c_char;
        *s
            .offset(
                len.wrapping_add(1 as libc::c_ulong) as isize,
            ) = '\u{0}' as i32 as libc::c_char;
    };
}
pub unsafe extern "C" fn BarUiPrintStation(
    mut settings: *const BarSettings_t,
    mut station: *mut PianoStation_t,
) {
    let mut outstr: [libc::c_char; 512] = [0; 512];
    let mut vals: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];
    vals[0 as libc::c_int as usize] = (*station).name as *const libc::c_char;
    vals[1 as libc::c_int as usize] = (*station).id as *const libc::c_char;
    BarUiCustomFormat(
        outstr.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
        (*settings).npStationFormat as *const libc::c_char,
        b"ni\0" as *const u8 as *const libc::c_char,
        vals.as_mut_ptr(),
    );
    BarUiAppendNewline(
        outstr.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
    );
    BarUiMsg(
        settings,
        MSG_PLAYING,
        b"%s\0" as *const u8 as *const libc::c_char,
        outstr.as_mut_ptr(),
    );
}
unsafe extern "C" fn ratingToIcon(
    settings: *const BarSettings_t,
    song: *const PianoSong_t,
) -> *const libc::c_char {
    match (*song).rating as libc::c_uint {
        1 => return (*settings).loveIcon as *const libc::c_char,
        2 => return (*settings).banIcon as *const libc::c_char,
        3 => return (*settings).tiredIcon as *const libc::c_char,
        _ => return b"\0" as *const u8 as *const libc::c_char,
    };
}
pub unsafe extern "C" fn BarUiPrintSong(
    mut settings: *const BarSettings_t,
    mut song: *const PianoSong_t,
    mut station: *const PianoStation_t,
) {
    let mut outstr: [libc::c_char; 512] = [0; 512];
    let mut vals: [*const libc::c_char; 7] = [0 as *const libc::c_char; 7];
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    tmp = ratingToIcon(settings, song);
    if station as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___0 = (*settings).atIcon as *const libc::c_char;
    } else {
        tmp___0 = b"\0" as *const u8 as *const libc::c_char;
    }
    if station as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp___1 = (*station).name as *const libc::c_char;
    } else {
        tmp___1 = b"\0" as *const u8 as *const libc::c_char;
    }
    vals[0 as libc::c_int as usize] = (*song).title as *const libc::c_char;
    vals[1 as libc::c_int as usize] = (*song).artist as *const libc::c_char;
    vals[2 as libc::c_int as usize] = (*song).album as *const libc::c_char;
    vals[3 as libc::c_int as usize] = tmp;
    vals[4 as libc::c_int as usize] = tmp___0;
    vals[5 as libc::c_int as usize] = tmp___1;
    vals[6 as libc::c_int as usize] = (*song).detailUrl as *const libc::c_char;
    BarUiCustomFormat(
        outstr.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
        (*settings).npSongFormat as *const libc::c_char,
        b"talr@su\0" as *const u8 as *const libc::c_char,
        vals.as_mut_ptr(),
    );
    BarUiAppendNewline(
        outstr.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
    );
    BarUiMsg(
        settings,
        MSG_PLAYING,
        b"%s\0" as *const u8 as *const libc::c_char,
        outstr.as_mut_ptr(),
    );
}
pub unsafe extern "C" fn BarUiListSongs(
    app___0: *const BarApp_t,
    mut song: *const PianoSong_t,
    mut filter: *const libc::c_char,
) -> size_t {
    let mut current_block: u64;
    let mut settings: *const BarSettings_t = 0 as *const BarSettings_t;
    let mut i: size_t = 0;
    let mut deleted: *const libc::c_char = 0 as *const libc::c_char;
    let mut empty: *const libc::c_char = 0 as *const libc::c_char;
    let mut stationName: *const libc::c_char = 0 as *const libc::c_char;
    let mut station: *const PianoStation_t = 0 as *const PianoStation_t;
    let mut tmp: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut outstr: [libc::c_char; 512] = [0; 512];
    let mut digits: [libc::c_char; 8] = [0; 8];
    let mut duration: [libc::c_char; 8] = [0; 8];
    let mut tmp___0: libc::c_uint = 0;
    let mut vals: [*const libc::c_char; 7] = [0 as *const libc::c_char; 7];
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut length: libc::c_uint = 0;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    settings = &(*app___0).settings;
    i = 0 as libc::c_int as size_t;
    while song as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if filter as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            current_block = 104164206450431841;
        } else if filter as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            tmp___3 = BarStrCaseStr((*song).artist as *const libc::c_char, filter);
            if tmp___3 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                current_block = 104164206450431841;
            } else {
                tmp___4 = BarStrCaseStr((*song).title as *const libc::c_char, filter);
                if tmp___4 as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    current_block = 104164206450431841;
                } else {
                    current_block = 5141539773904409130;
                }
            }
        } else {
            current_block = 5141539773904409130;
        }
        match current_block {
            104164206450431841 => {
                deleted = b"(deleted)\0" as *const u8 as *const libc::c_char;
                empty = b"\0" as *const u8 as *const libc::c_char;
                stationName = empty;
                tmp = PianoFindStationById(
                    (*app___0).ph.stations,
                    (*song).stationId as *const libc::c_char,
                );
                station = tmp as *const PianoStation_t;
                let mut current_block_15: u64;
                if station as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    if station as libc::c_ulong != (*app___0).curStation as libc::c_ulong
                    {
                        stationName = (*station).name as *const libc::c_char;
                        current_block_15 = 2232869372362427478;
                    } else {
                        current_block_15 = 11520521427490385361;
                    }
                } else {
                    current_block_15 = 11520521427490385361;
                }
                match current_block_15 {
                    11520521427490385361 => {
                        if station as libc::c_ulong
                            == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            if (*song).stationId as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                stationName = deleted;
                            }
                        }
                    }
                    _ => {}
                }
                duration[0 as libc::c_int as usize] = '?' as i32 as libc::c_char;
                duration[1 as libc::c_int as usize] = '?' as i32 as libc::c_char;
                duration[2 as libc::c_int as usize] = ':' as i32 as libc::c_char;
                duration[3 as libc::c_int as usize] = '?' as i32 as libc::c_char;
                duration[4 as libc::c_int as usize] = '?' as i32 as libc::c_char;
                duration[5 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
                tmp___0 = 6 as libc::c_uint;
                while !(tmp___0 >= 8 as libc::c_uint) {
                    duration[tmp___0 as usize] = 0 as libc::c_int as libc::c_char;
                    tmp___0 = tmp___0.wrapping_add(1);
                }
                tmp___1 = ratingToIcon(settings, song);
                if stationName as libc::c_ulong != empty as libc::c_ulong {
                    tmp___2 = (*settings).atIcon as *const libc::c_char;
                } else {
                    tmp___2 = b"\0" as *const u8 as *const libc::c_char;
                }
                vals[0 as libc::c_int
                    as usize] = digits.as_mut_ptr() as *const libc::c_char;
                vals[1 as libc::c_int as usize] = (*song).artist as *const libc::c_char;
                vals[2 as libc::c_int as usize] = (*song).title as *const libc::c_char;
                vals[3 as libc::c_int as usize] = tmp___1;
                vals[4 as libc::c_int
                    as usize] = duration.as_mut_ptr() as *const libc::c_char;
                vals[5 as libc::c_int as usize] = tmp___2;
                vals[6 as libc::c_int as usize] = stationName;
                snprintf(
                    digits.as_mut_ptr(),
                    (::std::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                        ),
                    b"%2zu\0" as *const u8 as *const libc::c_char,
                    i,
                );
                length = (*song).length;
                if length > 0 as libc::c_uint {
                    snprintf(
                        duration.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
                        b"%02u:%02u\0" as *const u8 as *const libc::c_char,
                        length.wrapping_div(60 as libc::c_uint),
                        length.wrapping_rem(60 as libc::c_uint),
                    );
                }
                BarUiCustomFormat(
                    outstr.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                    (*settings).listSongFormat as *const libc::c_char,
                    b"iatrd@s\0" as *const u8 as *const libc::c_char,
                    vals.as_mut_ptr(),
                );
                BarUiAppendNewline(
                    outstr.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                );
                BarUiMsg(
                    settings,
                    MSG_LIST,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    outstr.as_mut_ptr(),
                );
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        song = (*song).head.next as *mut libc::c_void as *const PianoSong_t;
    }
    return i;
}
pub unsafe extern "C" fn BarUiStartEventCmd(
    mut settings: *const BarSettings_t,
    mut type_0: *const libc::c_char,
    mut curStation: *const PianoStation_t,
    mut curSong: *const PianoSong_t,
    player: *mut player_t,
    mut stations: *mut PianoStation_t,
    mut pRet: PianoReturn_t,
    mut wRet: CURLcode,
) {
    let mut chld: pid_t = 0;
    let mut pipeFd: [libc::c_int; 2] = [0; 2];
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut status: libc::c_int = 0;
    let mut songStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut pipeWriteFd: *mut FILE = 0 as *mut FILE;
    let mut songDuration: libc::c_uint = 0;
    let mut songPlayed: libc::c_uint = 0;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: libc::c_uint = 0;
    let mut tmp___9: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___10: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___11: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___12: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___13: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___15: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___16: *const libc::c_char = 0 as *const libc::c_char;
    let mut sortedStations: *mut *mut PianoStation_t = 0 as *mut *mut PianoStation_t;
    let mut stationCount: size_t = 0;
    let mut i: size_t = 0;
    let mut currStation: *const PianoStation_t = 0 as *const PianoStation_t;
    let mut msg: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___17: size_t = 0;
    if (*settings).eventCmd as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    tmp___1 = pipe(pipeFd.as_mut_ptr());
    if tmp___1 == -(1 as libc::c_int) {
        tmp = __errno_location();
        tmp___0 = strerror(*tmp);
        BarUiMsg(
            settings,
            MSG_ERR,
            b"Cannot create eventcmd pipe. (%s)\n\0" as *const u8 as *const libc::c_char,
            tmp___0,
        );
        return;
    }
    chld = fork();
    if chld == 0 as libc::c_int {
        close(pipeFd[1 as libc::c_int as usize]);
        tmp___2 = fileno(stdin);
        dup2(pipeFd[0 as libc::c_int as usize], tmp___2);
        execl(
            (*settings).eventCmd as *const libc::c_char,
            (*settings).eventCmd as *const libc::c_char,
            type_0,
            0 as *mut libc::c_void as *mut libc::c_char,
        );
        tmp___3 = __errno_location();
        tmp___4 = strerror(*tmp___3);
        BarUiMsg(
            settings,
            MSG_ERR,
            b"Cannot start eventcmd. (%s)\n\0" as *const u8 as *const libc::c_char,
            tmp___4,
        );
        close(pipeFd[0 as libc::c_int as usize]);
        exit(1 as libc::c_int);
    } else {
        if chld == -(1 as libc::c_int) {
            tmp___5 = __errno_location();
            tmp___6 = strerror(*tmp___5);
            BarUiMsg(
                settings,
                MSG_ERR,
                b"Cannot fork eventcmd. (%s)\n\0" as *const u8 as *const libc::c_char,
                tmp___6,
            );
        } else {
            songStation = 0 as *mut libc::c_void as *mut PianoStation_t;
            close(pipeFd[0 as libc::c_int as usize]);
            pipeWriteFd = fdopen(
                pipeFd[1 as libc::c_int as usize],
                b"w\0" as *const u8 as *const libc::c_char,
            );
            if curSong as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                if stations as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                    if curStation as libc::c_ulong
                        != 0 as *mut libc::c_void as libc::c_ulong
                    {
                        if (*curStation).isQuickMix != 0 {
                            songStation = PianoFindStationById(
                                stations,
                                (*curSong).stationId as *const libc::c_char,
                            );
                        }
                    }
                }
            }
            pthread_mutex_lock(&mut (*player).lock);
            songDuration = (*player).songDuration;
            songPlayed = (*player).songPlayed;
            pthread_mutex_unlock(&mut (*player).lock);
            if curSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___7 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___7 = (*curSong).detailUrl as *const libc::c_char;
            }
            if curSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___8 = 0 as libc::c_int as libc::c_uint;
            } else {
                tmp___8 = (*curSong).rating as libc::c_uint;
            }
            tmp___9 = curl_easy_strerror(wRet);
            tmp___10 = PianoErrorToStr(pRet);
            if songStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___11 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___11 = (*songStation).name as *const libc::c_char;
            }
            if curStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___12 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___12 = (*curStation).name as *const libc::c_char;
            }
            if curSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___13 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___13 = (*curSong).coverArt as *const libc::c_char;
            }
            if curSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___14 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___14 = (*curSong).album as *const libc::c_char;
            }
            if curSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___15 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___15 = (*curSong).title as *const libc::c_char;
            }
            if curSong as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                tmp___16 = b"\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___16 = (*curSong).artist as *const libc::c_char;
            }
            fprintf(
                pipeWriteFd,
                b"artist=%s\ntitle=%s\nalbum=%s\ncoverArt=%s\nstationName=%s\nsongStationName=%s\npRet=%i\npRetStr=%s\nwRet=%i\nwRetStr=%s\nsongDuration=%u\nsongPlayed=%u\nrating=%i\ndetailUrl=%s\n\0"
                    as *const u8 as *const libc::c_char,
                tmp___16,
                tmp___15,
                tmp___14,
                tmp___13,
                tmp___12,
                tmp___11,
                pRet as libc::c_uint,
                tmp___10,
                wRet as libc::c_uint,
                tmp___9,
                songDuration,
                songPlayed,
                tmp___8,
                tmp___7,
            );
            if stations as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                sortedStations = 0 as *mut libc::c_void as *mut *mut PianoStation_t;
                sortedStations = BarSortedStations(
                    stations,
                    &mut stationCount,
                    (*settings).sortOrder,
                );
                fprintf(
                    pipeWriteFd,
                    b"stationCount=%zd\n\0" as *const u8 as *const libc::c_char,
                    stationCount,
                );
                i = 0 as libc::c_int as size_t;
                while i < stationCount {
                    currStation = *sortedStations.offset(i as isize)
                        as *const PianoStation_t;
                    fprintf(
                        pipeWriteFd,
                        b"station%zd=%s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        (*currStation).name,
                    );
                    i = i.wrapping_add(1);
                }
                free(sortedStations as *mut libc::c_void);
            } else {
                msg = b"stationCount=0\n\0" as *const u8 as *const libc::c_char;
                tmp___17 = strlen(msg);
                fwrite(
                    msg as *const libc::c_void,
                    ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    tmp___17,
                    pipeWriteFd,
                );
            }
            fclose(pipeWriteFd);
            waitpid(chld, &mut status, 0 as libc::c_int);
        }
    };
}
pub unsafe extern "C" fn BarUiHistoryPrepend(
    mut app___0: *mut BarApp_t,
    mut song: *mut PianoSong_t,
) {
    let mut tmp: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut del: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    if (*app___0).settings.history != 0 as libc::c_uint {
        if (*app___0).songHistory as libc::c_ulong
            == 0 as *mut libc::c_void as libc::c_ulong
        {
            tmp = 0 as *mut libc::c_void as *mut PianoListHead_t;
        } else {
            tmp = &mut (*(*app___0).songHistory).head;
        }
        tmp___0 = PianoListPrepend(tmp, &mut (*song).head as *mut PianoListHead_t);
        (*app___0).songHistory = tmp___0 as *mut PianoSong_t;
        loop {
            tmp___1 = PianoListGet(
                &mut (*(*app___0).songHistory).head as *mut PianoListHead_t,
                (*app___0).settings.history as size_t,
            );
            del = tmp___1 as *mut PianoSong_t;
            if !(del as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                break;
            }
            if (*app___0).songHistory as libc::c_ulong
                == 0 as *mut libc::c_void as libc::c_ulong
            {
                tmp___2 = 0 as *mut libc::c_void as *mut PianoListHead_t;
            } else {
                tmp___2 = &mut (*(*app___0).songHistory).head;
            }
            tmp___3 = PianoListDelete(tmp___2, &mut (*del).head as *mut PianoListHead_t);
            (*app___0).songHistory = tmp___3 as *mut PianoSong_t;
            PianoDestroyPlaylist(del);
        }
    } else {
        PianoDestroyPlaylist(song);
    };
}
unsafe extern "C" fn BarReadlinePrevUtf8(mut ptr: *mut libc::c_char) -> size_t {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    loop {
        i = i.wrapping_add(1);
        ptr = ptr.offset(-1);
        if !(*ptr as libc::c_int & (1 as libc::c_int) << 7 as libc::c_int != 0) {
            break;
        }
        if *ptr as libc::c_int & (1 as libc::c_int) << 6 as libc::c_int != 0 {
            break;
        }
    }
    return i;
}
pub unsafe extern "C" fn BarReadline(
    mut buf: *mut libc::c_char,
    bufSize: size_t,
    mut mask: *const libc::c_char,
    mut input: *mut BarReadlineFds_t,
    flags: BarReadlineFlags_t,
    mut timeout: libc::c_int,
) -> size_t {
    let mut bufLen: size_t = 0;
    let mut escapeState: libc::c_uchar = 0;
    let mut set: fd_set = fd_set { __fds_bits: [0; 16] };
    let mut echo: bool = false;
    let mut done: bool = false;
    let mut prevInt: *mut sig_atomic_t = 0 as *mut sig_atomic_t;
    let mut localInt: sig_atomic_t = 0;
    let mut curFd: libc::c_int = 0;
    let mut chr: libc::c_uchar = 0;
    let mut timeoutstruct: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp: *mut timeval = 0 as *mut timeval;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: ssize_t = 0;
    let mut moveSize: size_t = 0;
    let mut tmp___2: size_t = 0;
    let mut moveSize___0: size_t = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    bufLen = 0 as libc::c_int as size_t;
    escapeState = 0 as libc::c_int as libc::c_uchar;
    echo = flags as libc::c_uint & 2 as libc::c_uint == 0;
    done = 0 as libc::c_int != 0;
    prevInt = interrupted;
    localInt = 0 as libc::c_int;
    if flags as libc::c_uint & 4 as libc::c_uint == 0 {
        interrupted = &mut localInt;
    }
    memset(buf as *mut libc::c_void, 0 as libc::c_int, bufSize);
    while !done {
        curFd = -(1 as libc::c_int);
        memcpy(
            &mut set as *mut fd_set as *mut libc::c_void,
            &mut (*input).set as *mut fd_set as *const libc::c_void,
            ::std::mem::size_of::<fd_set>() as libc::c_ulong,
        );
        timeoutstruct.tv_sec = timeout as __time_t;
        timeoutstruct.tv_usec = 0 as libc::c_int as __suseconds_t;
        if timeout == -(1 as libc::c_int) {
            tmp = 0 as *mut libc::c_void as *mut timeval;
        } else {
            tmp = &mut timeoutstruct;
        }
        tmp___0 = select(
            (*input).maxfd,
            &mut set as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            0 as *mut libc::c_void as *mut fd_set,
            tmp,
        );
        if tmp___0 <= 0 as libc::c_int {
            bufLen = 0 as libc::c_int as size_t;
            break;
        } else {
            if set
                .__fds_bits[((*input).fds[0 as libc::c_int as usize]
                / (8 as libc::c_int
                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                        as libc::c_int)) as usize]
                & ((1 as libc::c_ulong)
                    << (*input).fds[0 as libc::c_int as usize]
                        % (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as __fd_mask != 0 as libc::c_long
            {
                curFd = (*input).fds[0 as libc::c_int as usize];
            } else if (*input).fds[1 as libc::c_int as usize] != -(1 as libc::c_int) {
                if set
                    .__fds_bits[((*input).fds[1 as libc::c_int as usize]
                    / (8 as libc::c_int
                        * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                            as libc::c_int)) as usize]
                    & ((1 as libc::c_ulong)
                        << (*input).fds[1 as libc::c_int as usize]
                            % (8 as libc::c_int
                                * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                    as libc::c_int)) as __fd_mask != 0 as libc::c_long
                {
                    curFd = (*input).fds[1 as libc::c_int as usize];
                }
            }
            tmp___1 = read(
                curFd,
                &mut chr as *mut libc::c_uchar as *mut libc::c_void,
                ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
            );
            if tmp___1 <= 0 as libc::c_long {
                if curFd == 0 as libc::c_int {
                    (*input)
                        .set
                        .__fds_bits[(curFd
                        / (8 as libc::c_int
                            * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                as libc::c_int)) as usize]
                        &= !(((1 as libc::c_ulong)
                            << curFd
                                % (8 as libc::c_int
                                    * ::std::mem::size_of::<__fd_mask>() as libc::c_ulong
                                        as libc::c_int)) as __fd_mask);
                }
            } else {
                let mut current_block_70: u64;
                match chr as libc::c_int {
                    10 | 4 => {
                        done = 1 as libc::c_int != 0;
                    }
                    21 => {
                        if echo {
                            while bufLen > 0 as libc::c_ulong {
                                tmp___2 = BarReadlinePrevUtf8(buf.offset(bufLen as isize));
                                moveSize = tmp___2;
                                fputs(
                                    b"\x1B[D\x1B[K\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                                bufLen = (bufLen as libc::c_ulong).wrapping_sub(moveSize)
                                    as size_t as size_t;
                            }
                            fflush(stdout);
                        }
                        bufLen = 0 as libc::c_int as size_t;
                    }
                    27 => {
                        escapeState = 1 as libc::c_int as libc::c_uchar;
                    }
                    126 => {}
                    127 | 8 => {
                        if bufLen > 0 as libc::c_ulong {
                            tmp___3 = BarReadlinePrevUtf8(buf.offset(bufLen as isize));
                            moveSize___0 = tmp___3;
                            memmove(
                                buf.offset(bufLen.wrapping_sub(moveSize___0) as isize)
                                    as *mut libc::c_void,
                                buf.offset(bufLen as isize) as *const libc::c_void,
                                moveSize___0,
                            );
                            bufLen = (bufLen as libc::c_ulong).wrapping_sub(moveSize___0)
                                as size_t as size_t;
                            if echo {
                                fputs(
                                    b"\x1B[D\x1B[K\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                                fflush(stdout);
                            }
                        }
                    }
                    _ => {
                        if !(chr as libc::c_int <= 31 as libc::c_int) {
                            if escapeState as libc::c_int == 2 as libc::c_int {
                                escapeState = 0 as libc::c_int as libc::c_uchar;
                            } else {
                                if escapeState as libc::c_int == 1 as libc::c_int {
                                    if chr as libc::c_int == 91 as libc::c_int {
                                        escapeState = 2 as libc::c_int as libc::c_uchar;
                                        current_block_70 = 5658374378798827547;
                                    } else {
                                        current_block_70 = 15594603006322722090;
                                    }
                                } else {
                                    current_block_70 = 15594603006322722090;
                                }
                                match current_block_70 {
                                    5658374378798827547 => {}
                                    _ => {
                                        if mask as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___4 = strchr(mask, chr as libc::c_int);
                                            if tmp___4.is_null() {
                                                current_block_70 = 5658374378798827547;
                                            } else {
                                                current_block_70 = 8869332144787829186;
                                            }
                                        } else {
                                            current_block_70 = 8869332144787829186;
                                        }
                                        match current_block_70 {
                                            5658374378798827547 => {}
                                            _ => {
                                                if bufLen < bufSize.wrapping_sub(1 as libc::c_ulong) {
                                                    *buf.offset(bufLen as isize) = chr as libc::c_char;
                                                    bufLen = bufLen.wrapping_add(1);
                                                    if echo {
                                                        putchar(chr as libc::c_int);
                                                        fflush(stdout);
                                                    }
                                                    if bufLen >= bufSize.wrapping_sub(1 as libc::c_ulong) {
                                                        if flags as libc::c_uint & 1 as libc::c_uint != 0 {
                                                            done = 1 as libc::c_int != 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if echo {
        fputs(b"\n\0" as *const u8 as *const libc::c_char, stdout);
    }
    interrupted = prevInt;
    *buf.offset(bufLen as isize) = '\u{0}' as i32 as libc::c_char;
    return bufLen;
}
pub unsafe extern "C" fn BarReadlineStr(
    mut buf: *mut libc::c_char,
    bufSize: size_t,
    mut input: *mut BarReadlineFds_t,
    flags: BarReadlineFlags_t,
) -> size_t {
    let mut tmp: size_t = 0;
    tmp = BarReadline(
        buf,
        bufSize,
        0 as *mut libc::c_void as *const libc::c_char,
        input,
        flags,
        -(1 as libc::c_int),
    );
    return tmp;
}
pub unsafe extern "C" fn BarReadlineInt(
    mut ret: *mut libc::c_int,
    mut input: *mut BarReadlineFds_t,
) -> size_t {
    let mut rlRet: libc::c_int = 0;
    let mut buf: [libc::c_char; 16] = [0; 16];
    let mut tmp: size_t = 0;
    rlRet = 0 as libc::c_int;
    tmp = BarReadline(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"0123456789\0" as *const u8 as *const libc::c_char,
        input,
        BAR_RL_DEFAULT,
        -(1 as libc::c_int),
    );
    rlRet = tmp as libc::c_int;
    *ret = atoi(buf.as_mut_ptr() as *const libc::c_char);
    return rlRet as size_t;
}
pub unsafe extern "C" fn BarReadlineYesNo(
    mut def: bool,
    mut input: *mut BarReadlineFds_t,
) -> bool {
    let mut buf: [libc::c_char; 2] = [0; 2];
    BarReadline(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
        b"yYnN\0" as *const u8 as *const libc::c_char,
        input,
        BAR_RL_FULLRETURN,
        -(1 as libc::c_int),
    );
    if buf[0 as libc::c_int as usize] as libc::c_int == 121 as libc::c_int {
        return 1 as libc::c_int != 0
    } else if buf[0 as libc::c_int as usize] as libc::c_int == 89 as libc::c_int {
        return 1 as libc::c_int != 0
    } else if def as libc::c_int == 1 as libc::c_int {
        if buf[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
            return 1 as libc::c_int != 0
        } else {
            return 0 as libc::c_int != 0
        }
    } else {
        return 0 as libc::c_int != 0
    };
}
static mut dispatchActions___1: [BarUiDispatchAction_t; 30] = [
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '?' as i32 as libc::c_char,
            context: BAR_DC_UNDEFINED,
            function: Some(
                BarUiActHelp
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_help\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '+' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActLoveSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"love song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songlove\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '-' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActBanSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"ban song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songban\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'a' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActAddMusic
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add music to station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationaddmusic\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'c' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActCreateStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"create new station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationcreate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'd' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActDeleteStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"delete station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationdelete\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'e' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActExplain
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"explain why this song is played\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songexplain\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'g' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActStationFromGenre
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add genre station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationaddbygenre\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'h' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActHistory
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"song history\0" as *const u8 as *const libc::c_char,
            configKey: b"act_history\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'i' as i32 as libc::c_char,
            context: 7 as BarUiDispatchContext_t,
            function: Some(
                BarUiActSongInfo
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"print information about song/station\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songinfo\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'j' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActAddSharedStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"add shared station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_addshared\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'n' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActSkipSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"next song\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songnext\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'p' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActTogglePause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"pause/resume playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songpausetoggle\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'q' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActQuit
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"quit\0" as *const u8 as *const libc::c_char,
            configKey: b"act_quit\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'r' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActRenameStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"rename station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationrename\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 's' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActSelectStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"change station\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationchange\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 't' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActTempBanSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"tired (ban song for 1 month)\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_songtired\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'u' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPrintUpcoming
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"upcoming songs\0" as *const u8 as *const libc::c_char,
            configKey: b"act_upcoming\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'x' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActSelectQuickMix
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"select quickmix stations\0" as *const u8 as *const libc::c_char,
            configKey: b"act_stationselectquickmix\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '$' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActDebug
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_debug\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'b' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActBookmark
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"bookmark song/artist\0" as *const u8 as *const libc::c_char,
            configKey: b"act_bookmark\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '(' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolDown
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"decrease volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_voldown\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: ')' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolUp
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"increase volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_volup\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '=' as i32 as libc::c_char,
            context: BAR_DC_STATION,
            function: Some(
                BarUiActManageStation
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"manage station seeds/feedback/mode\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_managestation\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: ' ' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActTogglePause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: 0 as *const libc::c_void as *mut libc::c_void
                as *const libc::c_char,
            configKey: b"act_songpausetoggle2\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'v' as i32 as libc::c_char,
            context: BAR_DC_SONG,
            function: Some(
                BarUiActCreateStationFromSong
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"create new station from song or artist\0" as *const u8
                as *const libc::c_char,
            configKey: b"act_stationcreatefromsong\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'P' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPlay
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"resume playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songplay\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: 'S' as i32 as libc::c_char,
            context: 3 as BarUiDispatchContext_t,
            function: Some(
                BarUiActPause
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"pause playback\0" as *const u8 as *const libc::c_char,
            configKey: b"act_songpause\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '^' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActVolReset
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"reset volume\0" as *const u8 as *const libc::c_char,
            configKey: b"act_volreset\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = __anonstruct_BarUiDispatchAction_t_315043967 {
            defaultKey: '!' as i32 as libc::c_char,
            context: BAR_DC_GLOBAL,
            function: Some(
                BarUiActSettings
                    as unsafe extern "C" fn(
                        *mut BarApp_t,
                        *mut PianoStation_t,
                        *mut PianoSong_t,
                        BarUiDispatchContext_t,
                    ) -> (),
            ),
            helpText: b"change settings\0" as *const u8 as *const libc::c_char,
            configKey: b"act_settings\0" as *const u8 as *const libc::c_char,
        };
        init
    },
];
pub unsafe extern "C" fn BarUiDispatch(
    mut app___0: *mut BarApp_t,
    key: libc::c_char,
    mut selStation: *mut PianoStation_t,
    mut selSong: *mut PianoSong_t,
    verbose: bool,
    mut context: BarUiDispatchContext_t,
) -> BarKeyShortcutId_t {
    let mut i: size_t = 0;
    if selStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        context = (context as libc::c_uint | 2 as libc::c_uint)
            as BarUiDispatchContext_t;
    }
    if selSong as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        context = (context as libc::c_uint | 4 as libc::c_uint)
            as BarUiDispatchContext_t;
    }
    i = 0 as libc::c_int as size_t;
    while i < 30 as libc::c_ulong {
        if (*app___0).settings.keys[i as usize] as libc::c_int != 0 as libc::c_int {
            if (*app___0).settings.keys[i as usize] as libc::c_int == key as libc::c_int
            {
                if dispatchActions___1[i as usize].context as libc::c_uint
                    & context as libc::c_uint
                    == dispatchActions___1[i as usize].context as libc::c_uint
                {
                    (Some(
                        ((*dispatchActions___1.as_ptr().offset(i as isize)).function)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(app___0, selStation, selSong, context);
                    return i as BarKeyShortcutId_t;
                } else {
                    if verbose {
                        if dispatchActions___1[i as usize].context as libc::c_uint
                            & 4 as libc::c_uint != 0
                        {
                            BarUiMsg(
                                &mut (*app___0).settings as *mut BarSettings_t
                                    as *const BarSettings_t,
                                MSG_ERR,
                                b"No song playing.\n\0" as *const u8 as *const libc::c_char,
                            );
                        } else if dispatchActions___1[i as usize].context as libc::c_uint
                                & 2 as libc::c_uint != 0
                            {
                            BarUiMsg(
                                &mut (*app___0).settings as *mut BarSettings_t
                                    as *const BarSettings_t,
                                MSG_ERR,
                                b"No station selected.\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        return BAR_KS_COUNT;
                    }
                }
            }
        }
        i = i.wrapping_add(1);
    }
    return BAR_KS_COUNT;
}
pub unsafe extern "C" fn PianoDecryptString(
    mut h: gcry_cipher_hd_t,
    input: *const libc::c_char,
    retSize: *mut size_t,
) -> *mut libc::c_char {
    let mut inputLen: size_t = 0;
    let mut tmp: size_t = 0;
    let mut gret: gcry_error_t = 0;
    let mut output: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut outputLen: size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    let mut hex: [libc::c_char; 3] = [0; 3];
    let mut tmp___1: libc::c_long = 0;
    tmp = strlen(input);
    inputLen = tmp;
    outputLen = inputLen.wrapping_div(2 as libc::c_ulong);
    tmp___0 = calloc(
        outputLen.wrapping_add(1 as libc::c_ulong),
        ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
    );
    output = tmp___0 as *mut libc::c_uchar;
    i = 0 as libc::c_int as size_t;
    while i < outputLen {
        memcpy(
            hex.as_mut_ptr() as *mut libc::c_void,
            input.offset(i.wrapping_mul(2 as libc::c_ulong) as isize)
                as *const libc::c_void,
            2 as libc::c_int as size_t,
        );
        hex[2 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
        tmp___1 = strtol(
            hex.as_mut_ptr() as *const libc::c_char,
            0 as *mut libc::c_void as *mut *mut libc::c_char,
            16 as libc::c_int,
        );
        *output.offset(i as isize) = tmp___1 as libc::c_uchar;
        i = i.wrapping_add(1);
    }
    gret = gcry_cipher_decrypt(
        h,
        output as *mut libc::c_void,
        outputLen,
        0 as *mut libc::c_void as *const libc::c_void,
        0 as libc::c_int as size_t,
    );
    if gret != 0 {
        free(output as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    *retSize = outputLen;
    return output as *mut libc::c_char;
}
pub unsafe extern "C" fn PianoEncryptString(
    mut h: gcry_cipher_hd_t,
    mut s: *const libc::c_char,
) -> *mut libc::c_char {
    let mut paddedInput: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut hexOutput: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut inputLen: size_t = 0;
    let mut tmp: size_t = 0;
    let mut paddedInputLen: size_t = 0;
    let mut tmp___0: size_t = 0;
    let mut gret: gcry_error_t = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: size_t = 0;
    tmp = strlen(s);
    inputLen = tmp;
    if inputLen.wrapping_rem(8 as libc::c_ulong) == 0 as libc::c_ulong {
        tmp___0 = inputLen;
    } else {
        tmp___0 = inputLen
            .wrapping_add(
                (8 as libc::c_ulong)
                    .wrapping_sub(inputLen.wrapping_rem(8 as libc::c_ulong)),
            );
    }
    paddedInputLen = tmp___0;
    tmp___1 = calloc(
        paddedInputLen.wrapping_add(1 as libc::c_ulong),
        ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
    );
    paddedInput = tmp___1 as *mut libc::c_uchar;
    memcpy(paddedInput as *mut libc::c_void, s as *const libc::c_void, inputLen);
    gret = gcry_cipher_encrypt(
        h,
        paddedInput as *mut libc::c_void,
        paddedInputLen,
        0 as *mut libc::c_void as *const libc::c_void,
        0 as libc::c_int as size_t,
    );
    if gret != 0 {
        free(paddedInput as *mut libc::c_void);
        return 0 as *mut libc::c_void as *mut libc::c_char;
    }
    tmp___2 = calloc(
        paddedInputLen.wrapping_mul(2 as libc::c_ulong).wrapping_add(1 as libc::c_ulong),
        ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
    );
    hexOutput = tmp___2 as *mut libc::c_uchar;
    i = 0 as libc::c_int as size_t;
    while i < paddedInputLen {
        snprintf(
            hexOutput.offset(i.wrapping_mul(2 as libc::c_ulong) as isize)
                as *mut libc::c_char,
            3 as libc::c_int as size_t,
            b"%02x\0" as *const u8 as *const libc::c_char,
            *paddedInput.offset(i as isize) as libc::c_int,
        );
        i = i.wrapping_add(1);
    }
    free(paddedInput as *mut libc::c_void);
    return hexOutput as *mut libc::c_char;
}
pub unsafe extern "C" fn PianoInit(
    mut ph: *mut PianoHandle_t,
    mut partnerUser: *const libc::c_char,
    mut partnerPassword: *const libc::c_char,
    mut device: *const libc::c_char,
    mut inkey: *const libc::c_char,
    mut outkey: *const libc::c_char,
) -> PianoReturn_t {
    let mut tmp: gcry_error_t = 0;
    let mut tmp___0: size_t = 0;
    let mut tmp___1: gcry_error_t = 0;
    let mut tmp___2: gcry_error_t = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: gcry_error_t = 0;
    memset(
        ph as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoHandle_t>() as libc::c_ulong,
    );
    (*ph).partner.user = strdup(partnerUser);
    (*ph).partner.password = strdup(partnerPassword);
    (*ph).partner.device = strdup(device);
    tmp = gcry_cipher_open(
        &mut (*ph).partner.in_0,
        4 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_uint,
    );
    if tmp != 0 as libc::c_uint {
        return PIANO_RET_GCRY_ERR;
    }
    tmp___0 = strlen(inkey);
    tmp___1 = gcry_cipher_setkey(
        (*ph).partner.in_0,
        inkey as *const libc::c_uchar as *const libc::c_void,
        tmp___0,
    );
    if tmp___1 != 0 as libc::c_uint {
        return PIANO_RET_GCRY_ERR;
    }
    tmp___2 = gcry_cipher_open(
        &mut (*ph).partner.out,
        4 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_uint,
    );
    if tmp___2 != 0 as libc::c_uint {
        return PIANO_RET_GCRY_ERR;
    }
    tmp___3 = strlen(outkey);
    tmp___4 = gcry_cipher_setkey(
        (*ph).partner.out,
        outkey as *const libc::c_uchar as *const libc::c_void,
        tmp___3,
    );
    if tmp___4 != 0 as libc::c_uint {
        return PIANO_RET_GCRY_ERR;
    }
    return PIANO_RET_OK;
}
unsafe extern "C" fn PianoDestroyArtists(mut artists: *mut PianoArtist_t) {
    let mut curArtist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut lastArtist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    curArtist = artists;
    while curArtist as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free((*curArtist).name as *mut libc::c_void);
        free((*curArtist).musicId as *mut libc::c_void);
        free((*curArtist).seedId as *mut libc::c_void);
        lastArtist = curArtist;
        curArtist = (*curArtist).head.next as *mut PianoArtist_t;
        free(lastArtist as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn PianoDestroySearchResult(
    mut searchResult: *mut PianoSearchResult_t,
) {
    PianoDestroyArtists((*searchResult).artists);
    PianoDestroyPlaylist((*searchResult).songs);
}
pub unsafe extern "C" fn PianoDestroyStation(mut station: *mut PianoStation_t) {
    free((*station).name as *mut libc::c_void);
    free((*station).id as *mut libc::c_void);
    free((*station).seedId as *mut libc::c_void);
    memset(
        station as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
    );
}
unsafe extern "C" fn PianoDestroyStations(mut stations: *mut PianoStation_t) {
    let mut curStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut lastStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    curStation = stations;
    while curStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        lastStation = curStation;
        curStation = (*curStation).head.next as *mut PianoStation_t;
        PianoDestroyStation(lastStation);
        free(lastStation as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn PianoDestroyPlaylist(mut playlist: *mut PianoSong_t) {
    let mut curSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut lastSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    curSong = playlist;
    while curSong as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free((*curSong).audioUrl as *mut libc::c_void);
        free((*curSong).coverArt as *mut libc::c_void);
        free((*curSong).artist as *mut libc::c_void);
        free((*curSong).musicId as *mut libc::c_void);
        free((*curSong).title as *mut libc::c_void);
        free((*curSong).stationId as *mut libc::c_void);
        free((*curSong).album as *mut libc::c_void);
        free((*curSong).feedbackId as *mut libc::c_void);
        free((*curSong).seedId as *mut libc::c_void);
        free((*curSong).detailUrl as *mut libc::c_void);
        free((*curSong).trackToken as *mut libc::c_void);
        lastSong = curSong;
        curSong = (*curSong).head.next as *mut PianoSong_t;
        free(lastSong as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn PianoDestroyStationInfo(mut info: *mut PianoStationInfo_t) {
    PianoDestroyPlaylist((*info).feedback);
    PianoDestroyPlaylist((*info).songSeeds);
    PianoDestroyArtists((*info).artistSeeds);
    PianoDestroyStations((*info).stationSeeds);
}
unsafe extern "C" fn PianoDestroyGenres(mut genres: *mut PianoGenre_t) {
    let mut curGenre: *mut PianoGenre_t = 0 as *mut PianoGenre_t;
    let mut lastGenre: *mut PianoGenre_t = 0 as *mut PianoGenre_t;
    curGenre = genres;
    while curGenre as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free((*curGenre).name as *mut libc::c_void);
        free((*curGenre).musicId as *mut libc::c_void);
        lastGenre = curGenre;
        curGenre = (*curGenre).head.next as *mut PianoGenre_t;
        free(lastGenre as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn PianoDestroyUserInfo(mut user: *mut PianoUserInfo_t) {
    free((*user).authToken as *mut libc::c_void);
    free((*user).listenerId as *mut libc::c_void);
}
unsafe extern "C" fn PianoDestroyPartner(mut partner: *mut PianoPartner_t) {
    free((*partner).user as *mut libc::c_void);
    free((*partner).password as *mut libc::c_void);
    free((*partner).device as *mut libc::c_void);
    free((*partner).authToken as *mut libc::c_void);
    gcry_cipher_close((*partner).in_0);
    gcry_cipher_close((*partner).out);
    memset(
        partner as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoPartner_t>() as libc::c_ulong,
    );
}
pub unsafe extern "C" fn PianoDestroyStationMode(modes: *mut PianoStationMode_t) {
    let mut curMode: *mut PianoStationMode_t = 0 as *mut PianoStationMode_t;
    let mut lastMode: *mut PianoStationMode_t = 0 as *mut PianoStationMode_t;
    curMode = modes;
    while curMode as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        free((*curMode).name as *mut libc::c_void);
        free((*curMode).description as *mut libc::c_void);
        lastMode = curMode;
        curMode = (*curMode).head.next as *mut PianoStationMode_t;
        free(lastMode as *mut libc::c_void);
    }
}
pub unsafe extern "C" fn PianoDestroy(mut ph: *mut PianoHandle_t) {
    let mut curGenreCat: *mut PianoGenreCategory_t = 0 as *mut PianoGenreCategory_t;
    let mut lastGenreCat: *mut PianoGenreCategory_t = 0 as *mut PianoGenreCategory_t;
    PianoDestroyUserInfo(&mut (*ph).user);
    PianoDestroyStations((*ph).stations);
    PianoDestroyPartner(&mut (*ph).partner);
    curGenreCat = (*ph).genreStations;
    while curGenreCat as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        PianoDestroyGenres((*curGenreCat).genres);
        free((*curGenreCat).name as *mut libc::c_void);
        lastGenreCat = curGenreCat;
        curGenreCat = (*curGenreCat).head.next as *mut PianoGenreCategory_t;
        free(lastGenreCat as *mut libc::c_void);
    }
    memset(
        ph as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoHandle_t>() as libc::c_ulong,
    );
}
pub unsafe extern "C" fn PianoDestroyRequest(mut req: *mut PianoRequest_t) {
    free((*req).postData as *mut libc::c_void);
    memset(
        req as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<PianoRequest_t>() as libc::c_ulong,
    );
}
pub unsafe extern "C" fn PianoFindStationById(
    stations: *mut PianoStation_t,
    searchStation: *const libc::c_char,
) -> *mut PianoStation_t {
    let mut currStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp: libc::c_int = 0;
    if searchStation as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut PianoStation_t;
    }
    currStation = stations;
    while currStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        tmp = strcmp((*currStation).id as *const libc::c_char, searchStation);
        if tmp == 0 as libc::c_int {
            return currStation;
        }
        currStation = (*currStation).head.next as *mut libc::c_void
            as *mut PianoStation_t;
    }
    return 0 as *mut libc::c_void as *mut PianoStation_t;
}
pub unsafe extern "C" fn PianoErrorToStr(mut ret: PianoReturn_t) -> *const libc::c_char {
    match ret as libc::c_uint {
        1 => return b"Everything is fine :)\0" as *const u8 as *const libc::c_char,
        0 => return b"Unknown.\0" as *const u8 as *const libc::c_char,
        2 => return b"Invalid response.\0" as *const u8 as *const libc::c_char,
        3 => return b"Fix your program.\0" as *const u8 as *const libc::c_char,
        4 => return b"Out of memory.\0" as *const u8 as *const libc::c_char,
        5 => {
            return b"Wrong email address or password.\0" as *const u8
                as *const libc::c_char;
        }
        6 => {
            return b"Selected audio quality is not available.\0" as *const u8
                as *const libc::c_char;
        }
        7 => {
            return b"libgcrypt initialization failed.\0" as *const u8
                as *const libc::c_char;
        }
        1024 => return b"Internal error.\0" as *const u8 as *const libc::c_char,
        2032 => return b"Call not allowed.\0" as *const u8 as *const libc::c_char,
        2025 => return b"Invalid auth token.\0" as *const u8 as *const libc::c_char,
        1025 => return b"Maintenance mode.\0" as *const u8 as *const libc::c_char,
        2029 => {
            return b"Max number of stations reached.\0" as *const u8
                as *const libc::c_char;
        }
        2024 => {
            return b"Read only mode. Try again later.\0" as *const u8
                as *const libc::c_char;
        }
        2030 => return b"Station does not exist.\0" as *const u8 as *const libc::c_char,
        2026 => return b"Invalid partner login.\0" as *const u8 as *const libc::c_char,
        1036 => {
            return b"Pandora is not available in your country. Set up a control proxy (see manpage).\0"
                as *const u8 as *const libc::c_char;
        }
        2034 => {
            return b"Invalid partner credentials.\0" as *const u8 as *const libc::c_char;
        }
        2027 => return b"Listener not authorized.\0" as *const u8 as *const libc::c_char,
        2063 => {
            return b"Access denied. Try again later.\0" as *const u8
                as *const libc::c_char;
        }
        _ => return b"No error message available.\0" as *const u8 as *const libc::c_char,
    };
}
pub unsafe extern "C" fn PianoRequest(
    mut ph: *mut PianoHandle_t,
    mut req: *mut PianoRequest_t,
    mut type_0: PianoRequestType_t,
) -> PianoReturn_t {
    let mut ret: PianoReturn_t = PIANO_RET_ERR;
    let mut jsonSendBuf: *const libc::c_char = 0 as *const libc::c_char;
    let mut method: *const libc::c_char = 0 as *const libc::c_char;
    let mut j: *mut json_object = 0 as *mut json_object;
    let mut tmp: *mut json_object = 0 as *mut json_object;
    let mut timestamp: time_t = 0;
    let mut tmp___0: time_t = 0;
    let mut encrypted: bool = false;
    let mut logindata: *mut PianoRequestDataLogin_t = 0 as *mut PianoRequestDataLogin_t;
    let mut tmp___1: *mut json_object = 0 as *mut json_object;
    let mut tmp___2: *mut json_object = 0 as *mut json_object;
    let mut tmp___3: *mut json_object = 0 as *mut json_object;
    let mut tmp___4: *mut json_object = 0 as *mut json_object;
    let mut tmp___5: *mut json_object = 0 as *mut json_object;
    let mut urlencAuthToken: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut json_object = 0 as *mut json_object;
    let mut tmp___7: *mut json_object = 0 as *mut json_object;
    let mut tmp___8: *mut json_object = 0 as *mut json_object;
    let mut tmp___9: *mut json_object = 0 as *mut json_object;
    let mut tmp___10: *mut json_object = 0 as *mut json_object;
    let mut curl: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___11: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: *mut json_object = 0 as *mut json_object;
    let mut reqData: *mut PianoRequestDataGetPlaylist_t = 0
        as *mut PianoRequestDataGetPlaylist_t;
    let mut tmp___13: *mut json_object = 0 as *mut json_object;
    let mut tmp___14: *mut json_object = 0 as *mut json_object;
    let mut reqData___0: *mut PianoRequestDataAddFeedback_t = 0
        as *mut PianoRequestDataAddFeedback_t;
    let mut tmp___15: *mut json_object = 0 as *mut json_object;
    let mut tmp___16: *mut json_object = 0 as *mut json_object;
    let mut tmp___17: *mut json_object = 0 as *mut json_object;
    let mut reqData___1: *mut PianoRequestDataRenameStation_t = 0
        as *mut PianoRequestDataRenameStation_t;
    let mut tmp___18: *mut json_object = 0 as *mut json_object;
    let mut tmp___19: *mut json_object = 0 as *mut json_object;
    let mut station: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___20: *mut json_object = 0 as *mut json_object;
    let mut reqData___2: *mut PianoRequestDataSearch_t = 0
        as *mut PianoRequestDataSearch_t;
    let mut tmp___21: *mut json_object = 0 as *mut json_object;
    let mut reqData___3: *mut PianoRequestDataCreateStation_t = 0
        as *mut PianoRequestDataCreateStation_t;
    let mut tmp___22: *mut json_object = 0 as *mut json_object;
    let mut tmp___23: *mut json_object = 0 as *mut json_object;
    let mut tmp___24: *mut json_object = 0 as *mut json_object;
    let mut tmp___25: *mut json_object = 0 as *mut json_object;
    let mut reqData___4: *mut PianoRequestDataAddSeed_t = 0
        as *mut PianoRequestDataAddSeed_t;
    let mut tmp___26: *mut json_object = 0 as *mut json_object;
    let mut tmp___27: *mut json_object = 0 as *mut json_object;
    let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___28: *mut json_object = 0 as *mut json_object;
    let mut curStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut a: *mut json_object = 0 as *mut json_object;
    let mut tmp___29: *mut json_object = 0 as *mut json_object;
    let mut tmp___30: *mut json_object = 0 as *mut json_object;
    let mut station___0: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___31: *mut json_object = 0 as *mut json_object;
    let mut reqData___5: *mut PianoRequestDataExplain_t = 0
        as *mut PianoRequestDataExplain_t;
    let mut tmp___32: *mut json_object = 0 as *mut json_object;
    let mut song___0: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___33: *mut json_object = 0 as *mut json_object;
    let mut song___1: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___34: *mut json_object = 0 as *mut json_object;
    let mut reqData___6: *mut PianoRequestDataGetStationInfo_t = 0
        as *mut PianoRequestDataGetStationInfo_t;
    let mut tmp___35: *mut json_object = 0 as *mut json_object;
    let mut tmp___36: *mut json_object = 0 as *mut json_object;
    let mut tmp___37: *mut json_object = 0 as *mut json_object;
    let mut reqData___7: *mut PianoRequestDataGetStationModes_t = 0
        as *mut PianoRequestDataGetStationModes_t;
    let mut station___1: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___38: *mut json_object = 0 as *mut json_object;
    let mut reqData___8: *mut PianoRequestDataSetStationMode_t = 0
        as *mut PianoRequestDataSetStationMode_t;
    let mut station___2: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___39: *mut json_object = 0 as *mut json_object;
    let mut tmp___40: *mut json_object = 0 as *mut json_object;
    let mut song___2: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___41: *mut json_object = 0 as *mut json_object;
    let mut reqData___9: *mut PianoRequestDataDeleteSeed_t = 0
        as *mut PianoRequestDataDeleteSeed_t;
    let mut seedId: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___42: *mut json_object = 0 as *mut json_object;
    let mut reqData___10: *mut PianoRequestDataChangeSettings_t = 0
        as *mut PianoRequestDataChangeSettings_t;
    let mut tmp___43: *mut json_object = 0 as *mut json_object;
    let mut tmp___44: *mut json_object = 0 as *mut json_object;
    let mut tmp___45: *mut json_object = 0 as *mut json_object;
    let mut tmp___46: *mut json_object = 0 as *mut json_object;
    let mut tmp___47: *mut json_object = 0 as *mut json_object;
    let mut tmp___48: *mut json_object = 0 as *mut json_object;
    let mut reqData___11: *mut PianoRequestDataRateSong_t = 0
        as *mut PianoRequestDataRateSong_t;
    let mut transformedReqData: PianoRequestDataAddFeedback_t = PianoRequestDataAddFeedback_t {
        stationId: 0 as *mut libc::c_char,
        trackToken: 0 as *mut libc::c_char,
        rating: PIANO_RATE_NONE,
    };
    let mut urlencAuthToken___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut curl___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___49: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___50: *mut json_object = 0 as *mut json_object;
    let mut tmp___51: *mut json_object = 0 as *mut json_object;
    let mut tmp___52: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut current_block_222: u64;
    ret = PIANO_RET_OK;
    method = 0 as *mut libc::c_void as *const libc::c_char;
    tmp = json_object_new_object();
    j = tmp;
    tmp___0 = time(0 as *mut libc::c_void as *mut time_t);
    timestamp = tmp___0 - (*ph).timeOffset as time_t;
    encrypted = 1 as libc::c_int != 0;
    (*req).type_0 = type_0;
    (*req).secure = 0 as libc::c_int != 0;
    match (*req).type_0 as libc::c_uint {
        1 => {
            logindata = (*req).data as *mut PianoRequestDataLogin_t;
            match (*logindata).step as libc::c_int {
                0 => {
                    encrypted = 0 as libc::c_int != 0;
                    (*req).secure = 1 as libc::c_int != 0;
                    tmp___1 = json_object_new_string(
                        (*ph).partner.user as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"username\0" as *const u8 as *const libc::c_char,
                        tmp___1,
                    );
                    tmp___2 = json_object_new_string(
                        (*ph).partner.password as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"password\0" as *const u8 as *const libc::c_char,
                        tmp___2,
                    );
                    tmp___3 = json_object_new_string(
                        (*ph).partner.device as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"deviceModel\0" as *const u8 as *const libc::c_char,
                        tmp___3,
                    );
                    tmp___4 = json_object_new_string(
                        b"5\0" as *const u8 as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"version\0" as *const u8 as *const libc::c_char,
                        tmp___4,
                    );
                    tmp___5 = json_object_new_boolean(1 as libc::c_int);
                    json_object_object_add(
                        j,
                        b"includeUrls\0" as *const u8 as *const libc::c_char,
                        tmp___5,
                    );
                    snprintf(
                        ((*req).urlPath).as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                        b"/services/json/?method=auth.partnerLogin\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                1 => {
                    (*req).secure = 1 as libc::c_int != 0;
                    tmp___6 = json_object_new_string(
                        b"user\0" as *const u8 as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"loginType\0" as *const u8 as *const libc::c_char,
                        tmp___6,
                    );
                    tmp___7 = json_object_new_string(
                        (*logindata).user as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"username\0" as *const u8 as *const libc::c_char,
                        tmp___7,
                    );
                    tmp___8 = json_object_new_string(
                        (*logindata).password as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"password\0" as *const u8 as *const libc::c_char,
                        tmp___8,
                    );
                    tmp___9 = json_object_new_string(
                        (*ph).partner.authToken as *const libc::c_char,
                    );
                    json_object_object_add(
                        j,
                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                        tmp___9,
                    );
                    tmp___10 = json_object_new_int(timestamp as int32_t);
                    json_object_object_add(
                        j,
                        b"syncTime\0" as *const u8 as *const libc::c_char,
                        tmp___10,
                    );
                    tmp___11 = curl_easy_init();
                    curl = tmp___11;
                    urlencAuthToken = curl_easy_escape(
                        curl,
                        (*ph).partner.authToken as *const libc::c_char,
                        0 as libc::c_int,
                    );
                    snprintf(
                        ((*req).urlPath).as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                        b"/services/json/?method=auth.userLogin&auth_token=%s&partner_id=%i\0"
                            as *const u8 as *const libc::c_char,
                        urlencAuthToken,
                        (*ph).partner.id,
                    );
                    curl_free(urlencAuthToken as *mut libc::c_void);
                    curl_easy_cleanup(curl);
                }
                _ => {}
            }
            current_block_222 = 17518666747792551745;
        }
        2 => {
            tmp___12 = json_object_new_boolean(1 as libc::c_int);
            json_object_object_add(
                j,
                b"returnAllStations\0" as *const u8 as *const libc::c_char,
                tmp___12,
            );
            method = b"user.getStationList\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        3 => {
            reqData = (*req).data as *mut PianoRequestDataGetPlaylist_t;
            (*req).secure = 1 as libc::c_int != 0;
            tmp___13 = json_object_new_string(
                (*(*reqData).station).id as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___13,
            );
            tmp___14 = json_object_new_boolean(1 as libc::c_int);
            json_object_object_add(
                j,
                b"includeTrackLength\0" as *const u8 as *const libc::c_char,
                tmp___14,
            );
            method = b"station.getPlaylist\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        5 => {
            reqData___0 = (*req).data as *mut PianoRequestDataAddFeedback_t;
            tmp___15 = json_object_new_string(
                (*reqData___0).stationId as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___15,
            );
            tmp___16 = json_object_new_string(
                (*reqData___0).trackToken as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"trackToken\0" as *const u8 as *const libc::c_char,
                tmp___16,
            );
            tmp___17 = json_object_new_boolean(
                ((*reqData___0).rating as libc::c_uint == 1 as libc::c_uint)
                    as libc::c_int,
            );
            json_object_object_add(
                j,
                b"isPositive\0" as *const u8 as *const libc::c_char,
                tmp___17,
            );
            method = b"station.addFeedback\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        7 => {
            reqData___1 = (*req).data as *mut PianoRequestDataRenameStation_t;
            tmp___18 = json_object_new_string(
                (*(*reqData___1).station).id as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___18,
            );
            tmp___19 = json_object_new_string(
                (*reqData___1).newName as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"stationName\0" as *const u8 as *const libc::c_char,
                tmp___19,
            );
            method = b"station.renameStation\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        8 => {
            station = (*req).data as *mut PianoStation_t;
            tmp___20 = json_object_new_string((*station).id as *const libc::c_char);
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___20,
            );
            method = b"station.deleteStation\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        9 => {
            reqData___2 = (*req).data as *mut PianoRequestDataSearch_t;
            tmp___21 = json_object_new_string(
                (*reqData___2).searchStr as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"searchText\0" as *const u8 as *const libc::c_char,
                tmp___21,
            );
            method = b"music.search\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        10 => {
            reqData___3 = (*req).data as *mut PianoRequestDataCreateStation_t;
            if (*reqData___3).type_0 as libc::c_uint == 0 as libc::c_uint {
                tmp___22 = json_object_new_string(
                    (*reqData___3).token as *const libc::c_char,
                );
                json_object_object_add(
                    j,
                    b"musicToken\0" as *const u8 as *const libc::c_char,
                    tmp___22,
                );
            } else {
                tmp___23 = json_object_new_string(
                    (*reqData___3).token as *const libc::c_char,
                );
                json_object_object_add(
                    j,
                    b"trackToken\0" as *const u8 as *const libc::c_char,
                    tmp___23,
                );
                match (*reqData___3).type_0 as libc::c_uint {
                    1 => {
                        tmp___24 = json_object_new_string(
                            b"song\0" as *const u8 as *const libc::c_char,
                        );
                        json_object_object_add(
                            j,
                            b"musicType\0" as *const u8 as *const libc::c_char,
                            tmp___24,
                        );
                    }
                    2 => {
                        tmp___25 = json_object_new_string(
                            b"artist\0" as *const u8 as *const libc::c_char,
                        );
                        json_object_object_add(
                            j,
                            b"musicType\0" as *const u8 as *const libc::c_char,
                            tmp___25,
                        );
                    }
                    _ => {}
                }
            }
            method = b"station.createStation\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        11 => {
            reqData___4 = (*req).data as *mut PianoRequestDataAddSeed_t;
            tmp___26 = json_object_new_string(
                (*reqData___4).musicId as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"musicToken\0" as *const u8 as *const libc::c_char,
                tmp___26,
            );
            tmp___27 = json_object_new_string(
                (*(*reqData___4).station).id as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___27,
            );
            method = b"station.addMusic\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        12 => {
            song = (*req).data as *mut PianoSong_t;
            tmp___28 = json_object_new_string((*song).trackToken as *const libc::c_char);
            json_object_object_add(
                j,
                b"trackToken\0" as *const u8 as *const libc::c_char,
                tmp___28,
            );
            method = b"user.sleepSong\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        13 => {
            curStation = (*ph).stations;
            tmp___29 = json_object_new_array();
            a = tmp___29;
            while curStation as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong
            {
                if (*curStation).useQuickMix != 0 {
                    if (*curStation).isQuickMix == 0 {
                        tmp___30 = json_object_new_string(
                            (*curStation).id as *const libc::c_char,
                        );
                        json_object_array_add(a, tmp___30);
                    }
                }
                curStation = (*curStation).head.next as *mut libc::c_void
                    as *mut PianoStation_t;
            }
            json_object_object_add(
                j,
                b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                a,
            );
            method = b"user.setQuickMix\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        14 => {
            method = b"station.getGenreStations\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        15 => {
            station___0 = (*req).data as *mut PianoStation_t;
            tmp___31 = json_object_new_string((*station___0).id as *const libc::c_char);
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___31,
            );
            method = b"station.transformSharedStation\0" as *const u8
                as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        16 => {
            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
            tmp___32 = json_object_new_string(
                (*(*reqData___5).song).trackToken as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"trackToken\0" as *const u8 as *const libc::c_char,
                tmp___32,
            );
            method = b"track.explainTrack\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        18 => {
            song___0 = (*req).data as *mut PianoSong_t;
            tmp___33 = json_object_new_string(
                (*song___0).trackToken as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"trackToken\0" as *const u8 as *const libc::c_char,
                tmp___33,
            );
            method = b"bookmark.addSongBookmark\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        19 => {
            song___1 = (*req).data as *mut PianoSong_t;
            tmp___34 = json_object_new_string(
                (*song___1).trackToken as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"trackToken\0" as *const u8 as *const libc::c_char,
                tmp___34,
            );
            method = b"bookmark.addArtistBookmark\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        20 => {
            reqData___6 = (*req).data as *mut PianoRequestDataGetStationInfo_t;
            tmp___35 = json_object_new_string(
                (*(*reqData___6).station).id as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"stationToken\0" as *const u8 as *const libc::c_char,
                tmp___35,
            );
            tmp___36 = json_object_new_boolean(1 as libc::c_int);
            json_object_object_add(
                j,
                b"includeExtendedAttributes\0" as *const u8 as *const libc::c_char,
                tmp___36,
            );
            tmp___37 = json_object_new_boolean(1 as libc::c_int);
            json_object_object_add(
                j,
                b"includeExtraParams\0" as *const u8 as *const libc::c_char,
                tmp___37,
            );
            method = b"station.getStation\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        25 => {
            reqData___7 = (*req).data as *mut PianoRequestDataGetStationModes_t;
            station___1 = (*reqData___7).station;
            tmp___38 = json_object_new_string((*station___1).id as *const libc::c_char);
            json_object_object_add(
                j,
                b"stationId\0" as *const u8 as *const libc::c_char,
                tmp___38,
            );
            method = b"interactiveradio.v1.getAvailableModesSimple\0" as *const u8
                as *const libc::c_char;
            (*req).secure = 1 as libc::c_int != 0;
            current_block_222 = 17518666747792551745;
        }
        26 => {
            reqData___8 = (*req).data as *mut PianoRequestDataSetStationMode_t;
            station___2 = (*reqData___8).station;
            tmp___39 = json_object_new_string((*station___2).id as *const libc::c_char);
            json_object_object_add(
                j,
                b"stationId\0" as *const u8 as *const libc::c_char,
                tmp___39,
            );
            tmp___40 = json_object_new_int((*reqData___8).id as int32_t);
            json_object_object_add(
                j,
                b"modeId\0" as *const u8 as *const libc::c_char,
                tmp___40,
            );
            method = b"interactiveradio.v1.setAndGetAvailableModes\0" as *const u8
                as *const libc::c_char;
            (*req).secure = 1 as libc::c_int != 0;
            current_block_222 = 17518666747792551745;
        }
        21 => {
            song___2 = (*req).data as *mut PianoSong_t;
            tmp___41 = json_object_new_string(
                (*song___2).feedbackId as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"feedbackId\0" as *const u8 as *const libc::c_char,
                tmp___41,
            );
            method = b"station.deleteFeedback\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        22 => {
            reqData___9 = (*req).data as *mut PianoRequestDataDeleteSeed_t;
            seedId = 0 as *mut libc::c_void as *mut libc::c_char;
            if (*reqData___9).song as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                seedId = (*(*reqData___9).song).seedId;
            } else if (*reqData___9).artist as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                seedId = (*(*reqData___9).artist).seedId;
            } else if (*reqData___9).station as libc::c_ulong
                    != 0 as *mut libc::c_void as libc::c_ulong
                {
                seedId = (*(*reqData___9).station).seedId;
            }
            tmp___42 = json_object_new_string(seedId as *const libc::c_char);
            json_object_object_add(
                j,
                b"seedId\0" as *const u8 as *const libc::c_char,
                tmp___42,
            );
            method = b"station.deleteMusic\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        23 => {
            method = b"user.getSettings\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        24 => {
            reqData___10 = (*req).data as *mut PianoRequestDataChangeSettings_t;
            tmp___43 = json_object_new_boolean(1 as libc::c_int);
            json_object_object_add(
                j,
                b"userInitiatedChange\0" as *const u8 as *const libc::c_char,
                tmp___43,
            );
            tmp___44 = json_object_new_string(
                (*reqData___10).currentUsername as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"currentUsername\0" as *const u8 as *const libc::c_char,
                tmp___44,
            );
            tmp___45 = json_object_new_string(
                (*reqData___10).currentPassword as *const libc::c_char,
            );
            json_object_object_add(
                j,
                b"currentPassword\0" as *const u8 as *const libc::c_char,
                tmp___45,
            );
            if (*reqData___10).explicitContentFilter as libc::c_uint != 0 as libc::c_uint
            {
                tmp___46 = json_object_new_boolean(
                    ((*reqData___10).explicitContentFilter as libc::c_uint
                        == 2 as libc::c_uint) as libc::c_int,
                );
                json_object_object_add(
                    j,
                    b"isExplicitContentFilterEnabled\0" as *const u8
                        as *const libc::c_char,
                    tmp___46,
                );
            }
            if (*reqData___10).newUsername as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                tmp___47 = json_object_new_string(
                    (*reqData___10).newUsername as *const libc::c_char,
                );
                json_object_object_add(
                    j,
                    b"newUsername\0" as *const u8 as *const libc::c_char,
                    tmp___47,
                );
            }
            if (*reqData___10).newPassword as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                tmp___48 = json_object_new_string(
                    (*reqData___10).newPassword as *const libc::c_char,
                );
                json_object_object_add(
                    j,
                    b"newPassword\0" as *const u8 as *const libc::c_char,
                    tmp___48,
                );
            }
            (*req).secure = 1 as libc::c_int != 0;
            method = b"user.changeSettings\0" as *const u8 as *const libc::c_char;
            current_block_222 = 17518666747792551745;
        }
        4 => {
            reqData___11 = (*req).data as *mut PianoRequestDataRateSong_t;
            transformedReqData.stationId = (*(*reqData___11).song).stationId;
            transformedReqData.trackToken = (*(*reqData___11).song).trackToken;
            transformedReqData.rating = (*reqData___11).rating;
            (*req)
                .data = &mut transformedReqData as *mut PianoRequestDataAddFeedback_t
                as *mut libc::c_void;
            ret = PianoRequest(ph, req, PIANO_REQUEST_ADD_FEEDBACK);
            (*req).type_0 = PIANO_REQUEST_RATE_SONG;
            (*req).data = reqData___11 as *mut libc::c_void;
            current_block_222 = 7785088767753337728;
        }
        _ => {
            current_block_222 = 17518666747792551745;
        }
    }
    match current_block_222 {
        17518666747792551745 => {
            if method as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                tmp___49 = curl_easy_init();
                curl___0 = tmp___49;
                urlencAuthToken___0 = curl_easy_escape(
                    curl___0,
                    (*ph).user.authToken as *const libc::c_char,
                    0 as libc::c_int,
                );
                snprintf(
                    ((*req).urlPath).as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                    b"/services/json/?method=%s&auth_token=%s&partner_id=%i&user_id=%s\0"
                        as *const u8 as *const libc::c_char,
                    method,
                    urlencAuthToken___0,
                    (*ph).partner.id,
                    (*ph).user.listenerId,
                );
                curl_free(urlencAuthToken___0 as *mut libc::c_void);
                curl_easy_cleanup(curl___0);
                tmp___50 = json_object_new_string(
                    (*ph).user.authToken as *const libc::c_char,
                );
                json_object_object_add(
                    j,
                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                    tmp___50,
                );
                tmp___51 = json_object_new_int(timestamp as int32_t);
                json_object_object_add(
                    j,
                    b"syncTime\0" as *const u8 as *const libc::c_char,
                    tmp___51,
                );
            }
            jsonSendBuf = json_object_to_json_string(j);
            if encrypted {
                tmp___52 = PianoEncryptString((*ph).partner.out, jsonSendBuf);
                (*req).postData = tmp___52;
                if tmp___52 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    ret = PIANO_RET_OUT_OF_MEMORY;
                }
            } else {
                (*req).postData = strdup(jsonSendBuf);
            }
        }
        _ => {}
    }
    json_object_put(j);
    return ret;
}
unsafe extern "C" fn PianoJsonStrdup(
    mut j: *mut json_object,
    mut key: *const libc::c_char,
) -> *mut libc::c_char {
    let mut v: *mut json_object = 0 as *mut json_object;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: json_bool = 0;
    tmp___1 = json_object_object_get_ex(j as *const json_object, key, &mut v);
    if tmp___1 != 0 {
        tmp = json_object_get_string(v);
        tmp___0 = strdup(tmp);
        return tmp___0;
    } else {
        return 0 as *mut libc::c_void as *mut libc::c_char
    };
}
unsafe extern "C" fn getBoolDefault(
    j: *mut json_object,
    key: *const libc::c_char,
    def: bool,
) -> bool {
    let mut v: *mut json_object = 0 as *mut json_object;
    let mut tmp: json_bool = 0;
    let mut tmp___0: json_bool = 0;
    tmp___0 = json_object_object_get_ex(j as *const json_object, key, &mut v);
    if tmp___0 != 0 {
        tmp = json_object_get_boolean(v as *const json_object);
        return tmp != 0;
    } else {
        return def
    };
}
unsafe extern "C" fn PianoJsonParseStation(
    mut j: *mut json_object,
    mut s: *mut PianoStation_t,
) {
    let mut tmp: bool = false;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: bool = false;
    (*s).name = PianoJsonStrdup(j, b"stationName\0" as *const u8 as *const libc::c_char);
    (*s).id = PianoJsonStrdup(j, b"stationToken\0" as *const u8 as *const libc::c_char);
    tmp = getBoolDefault(
        j,
        b"isShared\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    if tmp {
        tmp___0 = 0 as libc::c_int;
    } else {
        tmp___0 = 1 as libc::c_int;
    }
    (*s).isCreator = tmp___0 as libc::c_char;
    tmp___1 = getBoolDefault(
        j,
        b"isQuickMix\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int != 0,
    );
    (*s).isQuickMix = tmp___1 as libc::c_char;
}
unsafe extern "C" fn PianoStrpcat(
    mut dest: *mut libc::c_char,
    mut src: *const libc::c_char,
    mut len: size_t,
) {
    while *dest as libc::c_int != 0 as libc::c_int {
        if !(len > 1 as libc::c_ulong) {
            break;
        }
        dest = dest.offset(1);
        len = len.wrapping_sub(1);
    }
    while *src as libc::c_int != 0 as libc::c_int {
        if !(len > 1 as libc::c_ulong) {
            break;
        }
        *dest = *src;
        dest = dest.offset(1);
        src = src.offset(1);
        len = len.wrapping_sub(1);
    }
    *dest = '\u{0}' as i32 as libc::c_char;
}
static mut qualityMap: [*const libc::c_char; 4] = [
    b"\0" as *const u8 as *const libc::c_char,
    b"lowQuality\0" as *const u8 as *const libc::c_char,
    b"mediumQuality\0" as *const u8 as *const libc::c_char,
    b"highQuality\0" as *const u8 as *const libc::c_char,
];
static mut formatMap: [*const libc::c_char; 3] = [
    b"\0" as *const u8 as *const libc::c_char,
    b"aacplus\0" as *const u8 as *const libc::c_char,
    b"mp3\0" as *const u8 as *const libc::c_char,
];
static mut keys: [*const libc::c_char; 2] = [
    b"thumbsUp\0" as *const u8 as *const libc::c_char,
    b"thumbsDown\0" as *const u8 as *const libc::c_char,
];
pub unsafe extern "C" fn PianoResponse(
    mut ph: *mut PianoHandle_t,
    mut req: *mut PianoRequest_t,
) -> PianoReturn_t {
    let mut current_block: u64;
    let mut ret: PianoReturn_t = PIANO_RET_ERR;
    let mut j: *mut json_object = 0 as *mut json_object;
    let mut tmp: *mut json_object = 0 as *mut json_object;
    let mut status: *mut json_object = 0 as *mut json_object;
    let mut tmp___0: json_bool = 0;
    let mut code: *mut json_object = 0 as *mut json_object;
    let mut tmp___1: int32_t = 0;
    let mut reqData: *mut PianoRequestDataLogin_t = 0 as *mut PianoRequestDataLogin_t;
    let mut tmp___2: json_bool = 0;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    let mut result: *mut json_object = 0 as *mut json_object;
    let mut reqData___0: *mut PianoRequestDataLogin_t = 0
        as *mut PianoRequestDataLogin_t;
    let mut jsonTimestamp: *mut json_object = 0 as *mut json_object;
    let mut tmp___5: json_bool = 0;
    let mut cryptedTimestamp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut realTimestamp: time_t = 0;
    let mut tmp___7: time_t = 0;
    let mut decryptedTimestamp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut decryptedSize: size_t = 0;
    let mut timestamp: libc::c_ulong = 0;
    let mut tmp___8: libc::c_ulong = 0;
    let mut partnerId: *mut json_object = 0 as *mut json_object;
    let mut tmp___9: json_bool = 0;
    let mut tmp___10: int32_t = 0;
    let mut stations: *mut json_object = 0 as *mut json_object;
    let mut mix: *mut json_object = 0 as *mut json_object;
    let mut tmp___11: json_bool = 0;
    let mut i: libc::c_int = 0;
    let mut tmpStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut s: *mut json_object = 0 as *mut json_object;
    let mut tmp___12: *mut json_object = 0 as *mut json_object;
    let mut tmp___13: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___14: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___16: size_t = 0;
    let mut curStation: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut i___0: libc::c_int = 0;
    let mut id: *mut json_object = 0 as *mut json_object;
    let mut tmp___17: *mut json_object = 0 as *mut json_object;
    let mut tmp___18: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: size_t = 0;
    let mut reqData___1: *mut PianoRequestDataGetPlaylist_t = 0
        as *mut PianoRequestDataGetPlaylist_t;
    let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut items: *mut json_object = 0 as *mut json_object;
    let mut tmp___21: json_bool = 0;
    let mut i___1: libc::c_int = 0;
    let mut s___0: *mut json_object = 0 as *mut json_object;
    let mut tmp___22: *mut json_object = 0 as *mut json_object;
    let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___23: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___24: json_bool = 0;
    let mut umap: *mut json_object = 0 as *mut json_object;
    let mut jsonEncoding: *mut json_object = 0 as *mut json_object;
    let mut qmap: *mut json_object = 0 as *mut json_object;
    let mut encoding: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___25: *const libc::c_char = 0 as *const libc::c_char;
    let mut k: size_t = 0;
    let mut tmp___26: libc::c_int = 0;
    let mut tmp___27: json_bool = 0;
    let mut tmp___28: json_bool = 0;
    let mut tmp___29: json_bool = 0;
    let mut v: *mut json_object = 0 as *mut json_object;
    let mut tmp___31: libc::c_double = 0.;
    let mut tmp___32: json_bool = 0;
    let mut tmp___34: int32_t = 0;
    let mut tmp___35: json_bool = 0;
    let mut tmp___37: int32_t = 0;
    let mut tmp___38: int32_t = 0;
    let mut tmp___39: json_bool = 0;
    let mut tmp___40: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___41: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___42: size_t = 0;
    let mut reqData___2: *mut PianoRequestDataRateSong_t = 0
        as *mut PianoRequestDataRateSong_t;
    let mut reqData___3: *mut PianoRequestDataRenameStation_t = 0
        as *mut PianoRequestDataRenameStation_t;
    let mut station: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___43: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___44: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut reqData___4: *mut PianoRequestDataSearch_t = 0
        as *mut PianoRequestDataSearch_t;
    let mut searchResult: *mut PianoSearchResult_t = 0 as *mut PianoSearchResult_t;
    let mut artists: *mut json_object = 0 as *mut json_object;
    let mut i___2: libc::c_int = 0;
    let mut a: *mut json_object = 0 as *mut json_object;
    let mut tmp___45: *mut json_object = 0 as *mut json_object;
    let mut artist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut tmp___46: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___47: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___48: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___49: size_t = 0;
    let mut tmp___50: json_bool = 0;
    let mut songs: *mut json_object = 0 as *mut json_object;
    let mut i___3: libc::c_int = 0;
    let mut s___1: *mut json_object = 0 as *mut json_object;
    let mut tmp___51: *mut json_object = 0 as *mut json_object;
    let mut song___0: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___52: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___53: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___54: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___55: size_t = 0;
    let mut tmp___56: json_bool = 0;
    let mut tmpStation___0: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___57: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut search: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___58: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut tmp___59: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___60: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___61: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___62: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut song___1: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut categories: *mut json_object = 0 as *mut json_object;
    let mut i___4: libc::c_int = 0;
    let mut c: *mut json_object = 0 as *mut json_object;
    let mut tmp___63: *mut json_object = 0 as *mut json_object;
    let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0 as *mut PianoGenreCategory_t;
    let mut tmp___64: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut stations___0: *mut json_object = 0 as *mut json_object;
    let mut k___0: libc::c_int = 0;
    let mut s___2: *mut json_object = 0 as *mut json_object;
    let mut tmp___65: *mut json_object = 0 as *mut json_object;
    let mut tmpGenre: *mut PianoGenre_t = 0 as *mut PianoGenre_t;
    let mut tmp___66: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___67: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___68: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___69: size_t = 0;
    let mut tmp___70: json_bool = 0;
    let mut tmp___71: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___72: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___73: size_t = 0;
    let mut tmp___74: json_bool = 0;
    let mut station___0: *mut PianoStation_t = 0 as *mut PianoStation_t;
    let mut reqData___5: *mut PianoRequestDataExplain_t = 0
        as *mut PianoRequestDataExplain_t;
    let mut strSize: size_t = 0;
    let mut explanations: *mut json_object = 0 as *mut json_object;
    let mut tmp___75: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i___5: libc::c_int = 0;
    let mut e: *mut json_object = 0 as *mut json_object;
    let mut tmp___76: *mut json_object = 0 as *mut json_object;
    let mut f: *mut json_object = 0 as *mut json_object;
    let mut tmp___77: json_bool = 0;
    let mut s___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___78: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___79: size_t = 0;
    let mut tmp___80: size_t = 0;
    let mut tmp___81: size_t = 0;
    let mut tmp___82: json_bool = 0;
    let mut settings: *mut PianoSettings_t = 0 as *mut PianoSettings_t;
    let mut reqData___6: *mut PianoRequestDataGetStationInfo_t = 0
        as *mut PianoRequestDataGetStationInfo_t;
    let mut info: *mut PianoStationInfo_t = 0 as *mut PianoStationInfo_t;
    let mut music: *mut json_object = 0 as *mut json_object;
    let mut songs___0: *mut json_object = 0 as *mut json_object;
    let mut i___6: libc::c_int = 0;
    let mut s___4: *mut json_object = 0 as *mut json_object;
    let mut tmp___83: *mut json_object = 0 as *mut json_object;
    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___84: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___85: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___86: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___87: size_t = 0;
    let mut tmp___88: json_bool = 0;
    let mut artists___0: *mut json_object = 0 as *mut json_object;
    let mut i___7: libc::c_int = 0;
    let mut a___0: *mut json_object = 0 as *mut json_object;
    let mut tmp___89: *mut json_object = 0 as *mut json_object;
    let mut seedArtist: *mut PianoArtist_t = 0 as *mut PianoArtist_t;
    let mut tmp___90: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___91: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___92: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___93: size_t = 0;
    let mut tmp___94: json_bool = 0;
    let mut tmp___95: json_bool = 0;
    let mut feedback: *mut json_object = 0 as *mut json_object;
    let mut i___8: size_t = 0;
    let mut val: *mut json_object = 0 as *mut json_object;
    let mut tmp___96: json_bool = 0;
    let mut i___9: libc::c_int = 0;
    let mut s___5: *mut json_object = 0 as *mut json_object;
    let mut tmp___97: *mut json_object = 0 as *mut json_object;
    let mut feedbackSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
    let mut tmp___98: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___100: bool = false;
    let mut v___0: *mut json_object = 0 as *mut json_object;
    let mut tmp___102: int32_t = 0;
    let mut tmp___103: json_bool = 0;
    let mut tmp___104: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___105: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___106: size_t = 0;
    let mut tmp___107: json_bool = 0;
    let mut reqData___7: *mut PianoRequestDataGetStationModes_t = 0
        as *mut PianoRequestDataGetStationModes_t;
    let mut active: libc::c_int = 0;
    let mut activeMode: *mut json_object = 0 as *mut json_object;
    let mut tmp___108: json_bool = 0;
    let mut availableModes: *mut json_object = 0 as *mut json_object;
    let mut i___10: libc::c_int = 0;
    let mut val___0: *mut json_object = 0 as *mut json_object;
    let mut tmp___109: *mut json_object = 0 as *mut json_object;
    let mut mode: *mut PianoStationMode_t = 0 as *mut PianoStationMode_t;
    let mut tmp___110: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut modeId: *mut json_object = 0 as *mut json_object;
    let mut tmp___111: json_bool = 0;
    let mut tmp___112: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut tmp___113: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___114: size_t = 0;
    let mut tmp___115: json_bool = 0;
    let mut reqData___8: *mut PianoRequestDataSetStationMode_t = 0
        as *mut PianoRequestDataSetStationMode_t;
    let mut active___0: libc::c_int = 0;
    let mut activeMode___0: *mut json_object = 0 as *mut json_object;
    let mut tmp___116: json_bool = 0;
    ret = PIANO_RET_OK;
    tmp = json_tokener_parse((*req).responseData as *const libc::c_char);
    j = tmp;
    tmp___0 = json_object_object_get_ex(
        j as *const json_object,
        b"stat\0" as *const u8 as *const libc::c_char,
        &mut status,
    );
    if tmp___0 == 0 {
        ret = PIANO_RET_INVALID_RESPONSE;
    } else {
        tmp___3 = json_object_get_string(status);
        tmp___4 = strcmp(tmp___3, b"ok\0" as *const u8 as *const libc::c_char);
        if tmp___4 != 0 as libc::c_int {
            tmp___2 = json_object_object_get_ex(
                j as *const json_object,
                b"code\0" as *const u8 as *const libc::c_char,
                &mut code,
            );
            if tmp___2 != 0 {
                tmp___1 = json_object_get_int(code as *const json_object);
                ret = (tmp___1 + 1024 as libc::c_int) as PianoReturn_t;
                if ret as libc::c_uint == 2026 as libc::c_uint {
                    if (*req).type_0 as libc::c_uint == 1 as libc::c_uint {
                        reqData = (*req).data as *mut PianoRequestDataLogin_t;
                        if (*reqData).step as libc::c_int == 1 as libc::c_int {
                            ret = PIANO_RET_INVALID_LOGIN;
                        }
                    }
                }
            } else {
                ret = PIANO_RET_INVALID_RESPONSE;
            }
        } else {
            result = 0 as *mut libc::c_void as *mut json_object;
            json_object_object_get_ex(
                j as *const json_object,
                b"result\0" as *const u8 as *const libc::c_char,
                &mut result,
            );
            match (*req).type_0 as libc::c_uint {
                1 => {
                    current_block = 9258396240496221466;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                2 => {
                    current_block = 12416622598045156835;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                3 => {
                    current_block = 9102304816714734837;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                4 => {
                    current_block = 3088805359668119436;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                7 => {
                    current_block = 17889527928410410311;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                8 => {
                    current_block = 3706235558033962171;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                9 => {
                    current_block = 18251872013612097558;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                10 => {
                    current_block = 7996750302764191971;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                12 => {
                    current_block = 5788185166277156883;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                14 => {
                    current_block = 14429815417003997109;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                15 => {
                    current_block = 5539689802144708648;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                16 => {
                    current_block = 5790515546987520453;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                23 => {
                    current_block = 8857393537059434631;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                20 => {
                    current_block = 12838518962235657452;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                25 => {
                    current_block = 17392656807572532655;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                26 => {
                    current_block = 11047456882538071530;
                    match current_block {
                        11047456882538071530 => {
                            reqData___8 = (*req).data
                                as *mut PianoRequestDataSetStationMode_t;
                            active___0 = -(1 as libc::c_int);
                            tmp___116 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode___0,
                            );
                            if tmp___116 != 0 {
                                active___0 = json_object_get_int(
                                    activeMode___0 as *const json_object,
                                );
                            }
                            if active___0 as libc::c_uint != (*reqData___8).id {
                                return PIANO_RET_ERR;
                            }
                        }
                        12416622598045156835 => {
                            mix = 0 as *mut libc::c_void as *mut json_object;
                            tmp___11 = json_object_object_get_ex(
                                result as *const json_object,
                                b"stations\0" as *const u8 as *const libc::c_char,
                                &mut stations,
                            );
                            if !(tmp___11 == 0) {
                                i = 0 as libc::c_int;
                                loop {
                                    tmp___16 = json_object_array_length(
                                        stations as *const json_object,
                                    );
                                    if !((i as size_t) < tmp___16) {
                                        break;
                                    }
                                    tmp___12 = json_object_array_get_idx(
                                        stations as *const json_object,
                                        i as size_t,
                                    );
                                    s = tmp___12;
                                    tmp___13 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                    );
                                    tmpStation = tmp___13 as *mut PianoStation_t;
                                    if tmpStation as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    PianoJsonParseStation(s, tmpStation);
                                    if (*tmpStation).isQuickMix != 0 {
                                        json_object_object_get_ex(
                                            s as *const json_object,
                                            b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                            &mut mix,
                                        );
                                    }
                                    if (*ph).stations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___14 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___14 = &mut (*(*ph).stations).head;
                                    }
                                    tmp___15 = PianoListAppend(
                                        tmp___14,
                                        &mut (*tmpStation).head as *mut PianoListHead_t,
                                    );
                                    (*ph).stations = tmp___15 as *mut PianoStation_t;
                                    i += 1;
                                }
                                if mix as libc::c_ulong
                                    != 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    curStation = (*ph).stations;
                                    while curStation as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        i___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___20 = json_object_array_length(
                                                mix as *const json_object,
                                            );
                                            if !((i___0 as size_t) < tmp___20) {
                                                break;
                                            }
                                            tmp___17 = json_object_array_get_idx(
                                                mix as *const json_object,
                                                i___0 as size_t,
                                            );
                                            id = tmp___17;
                                            tmp___18 = json_object_get_string(id);
                                            tmp___19 = strcmp(
                                                tmp___18,
                                                (*curStation).id as *const libc::c_char,
                                            );
                                            if tmp___19 == 0 as libc::c_int {
                                                (*curStation)
                                                    .useQuickMix = 1 as libc::c_int as libc::c_char;
                                            }
                                            i___0 += 1;
                                        }
                                        curStation = (*curStation).head.next as *mut libc::c_void
                                            as *mut PianoStation_t;
                                    }
                                }
                            }
                        }
                        9102304816714734837 => {
                            reqData___1 = (*req).data
                                as *mut PianoRequestDataGetPlaylist_t;
                            playlist = 0 as *mut libc::c_void as *mut PianoSong_t;
                            items = 0 as *mut libc::c_void as *mut json_object;
                            tmp___21 = json_object_object_get_ex(
                                result as *const json_object,
                                b"items\0" as *const u8 as *const libc::c_char,
                                &mut items,
                            );
                            if !(tmp___21 == 0) {
                                i___1 = 0 as libc::c_int;
                                loop {
                                    tmp___42 = json_object_array_length(
                                        items as *const json_object,
                                    );
                                    if !((i___1 as size_t) < tmp___42) {
                                        current_block = 14666402909811248417;
                                        break;
                                    }
                                    tmp___22 = json_object_array_get_idx(
                                        items as *const json_object,
                                        i___1 as size_t,
                                    );
                                    s___0 = tmp___22;
                                    tmp___23 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song = tmp___23 as *mut PianoSong_t;
                                    if song as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___24 = json_object_object_get_ex(
                                        s___0 as *const json_object,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                        0 as *mut libc::c_void as *mut *mut json_object,
                                    );
                                    if tmp___24 == 0 {
                                        free(song as *mut libc::c_void);
                                    } else {
                                        tmp___29 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                            &mut umap,
                                        );
                                        if tmp___29 != 0 {
                                            tmp___27 = json_object_object_get_ex(
                                                umap as *const json_object,
                                                qualityMap[(*reqData___1).quality as usize],
                                                &mut qmap,
                                            );
                                            if tmp___27 != 0 {
                                                tmp___28 = json_object_object_get_ex(
                                                    qmap as *const json_object,
                                                    b"encoding\0" as *const u8 as *const libc::c_char,
                                                    &mut jsonEncoding,
                                                );
                                                if tmp___28 != 0 {
                                                    tmp___25 = json_object_get_string(jsonEncoding);
                                                    encoding = tmp___25;
                                                    k = 0 as libc::c_int as size_t;
                                                    while k
                                                        < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                            as libc::c_ulong)
                                                            .wrapping_div(
                                                                ::std::mem::size_of::<*const libc::c_char>()
                                                                    as libc::c_ulong,
                                                            )
                                                    {
                                                        tmp___26 = strcmp(formatMap[k as usize], encoding);
                                                        if tmp___26 == 0 as libc::c_int {
                                                            (*song).audioFormat = k as PianoAudioFormat_t;
                                                            break;
                                                        } else {
                                                            k = k.wrapping_add(1);
                                                        }
                                                    }
                                                    (*song)
                                                        .audioUrl = PianoJsonStrdup(
                                                        qmap,
                                                        b"audioUrl\0" as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                    free(song as *mut libc::c_void);
                                                    PianoDestroyPlaylist(playlist);
                                                    current_block = 18105026257541969950;
                                                    break;
                                                }
                                            } else {
                                                ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                                free(song as *mut libc::c_void);
                                                PianoDestroyPlaylist(playlist);
                                                current_block = 18105026257541969950;
                                                break;
                                            }
                                        }
                                        (*song)
                                            .artist = PianoJsonStrdup(
                                            s___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .album = PianoJsonStrdup(
                                            s___0,
                                            b"albumName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .title = PianoJsonStrdup(
                                            s___0,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .trackToken = PianoJsonStrdup(
                                            s___0,
                                            b"trackToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .stationId = PianoJsonStrdup(
                                            s___0,
                                            b"stationId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .coverArt = PianoJsonStrdup(
                                            s___0,
                                            b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*song)
                                            .detailUrl = PianoJsonStrdup(
                                            s___0,
                                            b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___32 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackGain\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___32 != 0 {
                                            tmp___31 = json_object_get_double(v as *const json_object);
                                            (*song).fileGain = tmp___31 as libc::c_float;
                                        } else {
                                            (*song).fileGain = 0.0f64 as libc::c_float;
                                        }
                                        tmp___35 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___35 != 0 {
                                            tmp___34 = json_object_get_int(v as *const json_object);
                                            (*song).length = tmp___34 as libc::c_uint;
                                        } else {
                                            (*song).length = 0 as libc::c_uint;
                                        }
                                        tmp___39 = json_object_object_get_ex(
                                            s___0 as *const json_object,
                                            b"songRating\0" as *const u8 as *const libc::c_char,
                                            &mut v,
                                        );
                                        if tmp___39 != 0 {
                                            tmp___37 = json_object_get_int(v as *const json_object);
                                            tmp___38 = tmp___37;
                                        } else {
                                            tmp___38 = 0 as libc::c_int;
                                        }
                                        match tmp___38 {
                                            1 => {
                                                (*song).rating = PIANO_RATE_LOVE;
                                            }
                                            _ => {}
                                        }
                                        if playlist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___40 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___40 = &mut (*playlist).head;
                                        }
                                        tmp___41 = PianoListAppend(
                                            tmp___40,
                                            &mut (*song).head as *mut PianoListHead_t,
                                        );
                                        playlist = tmp___41 as *mut PianoSong_t;
                                    }
                                    i___1 += 1;
                                }
                                match current_block {
                                    18105026257541969950 => {}
                                    _ => {
                                        (*reqData___1).retPlaylist = playlist;
                                    }
                                }
                            }
                        }
                        3088805359668119436 => {
                            reqData___2 = (*req).data as *mut PianoRequestDataRateSong_t;
                            (*(*reqData___2).song).rating = (*reqData___2).rating;
                        }
                        17889527928410410311 => {
                            reqData___3 = (*req).data
                                as *mut PianoRequestDataRenameStation_t;
                            free((*(*reqData___3).station).name as *mut libc::c_void);
                            (*(*reqData___3).station)
                                .name = strdup(
                                (*reqData___3).newName as *const libc::c_char,
                            );
                        }
                        3706235558033962171 => {
                            station = (*req).data as *mut PianoStation_t;
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___43 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___43 = &mut (*(*ph).stations).head;
                            }
                            tmp___44 = PianoListDelete(
                                tmp___43,
                                &mut (*station).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___44 as *mut PianoStation_t;
                            PianoDestroyStation(station);
                            free(station as *mut libc::c_void);
                        }
                        18251872013612097558 => {
                            reqData___4 = (*req).data as *mut PianoRequestDataSearch_t;
                            searchResult = &mut (*reqData___4).searchResult;
                            memset(
                                searchResult as *mut libc::c_void,
                                0 as libc::c_int,
                                ::std::mem::size_of::<PianoSearchResult_t>()
                                    as libc::c_ulong,
                            );
                            tmp___50 = json_object_object_get_ex(
                                result as *const json_object,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists,
                            );
                            if tmp___50 != 0 {
                                i___2 = 0 as libc::c_int;
                                loop {
                                    tmp___49 = json_object_array_length(
                                        artists as *const json_object,
                                    );
                                    if !((i___2 as size_t) < tmp___49) {
                                        break;
                                    }
                                    tmp___45 = json_object_array_get_idx(
                                        artists as *const json_object,
                                        i___2 as size_t,
                                    );
                                    a = tmp___45;
                                    tmp___46 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    );
                                    artist = tmp___46 as *mut PianoArtist_t;
                                    if artist as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*artist)
                                        .name = PianoJsonStrdup(
                                        a,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*artist)
                                        .musicId = PianoJsonStrdup(
                                        a,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).artists as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___47 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___47 = &mut (*(*searchResult).artists).head;
                                    }
                                    tmp___48 = PianoListAppend(
                                        tmp___47,
                                        &mut (*artist).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).artists = tmp___48 as *mut PianoArtist_t;
                                    i___2 += 1;
                                }
                            }
                            tmp___56 = json_object_object_get_ex(
                                result as *const json_object,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs,
                            );
                            if tmp___56 != 0 {
                                i___3 = 0 as libc::c_int;
                                loop {
                                    tmp___55 = json_object_array_length(
                                        songs as *const json_object,
                                    );
                                    if !((i___3 as size_t) < tmp___55) {
                                        break;
                                    }
                                    tmp___51 = json_object_array_get_idx(
                                        songs as *const json_object,
                                        i___3 as size_t,
                                    );
                                    s___1 = tmp___51;
                                    tmp___52 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    );
                                    song___0 = tmp___52 as *mut PianoSong_t;
                                    if song___0 as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*song___0)
                                        .title = PianoJsonStrdup(
                                        s___1,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .artist = PianoJsonStrdup(
                                        s___1,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song___0)
                                        .musicId = PianoJsonStrdup(
                                        s___1,
                                        b"musicToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    if (*searchResult).songs as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___53 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___53 = &mut (*(*searchResult).songs).head;
                                    }
                                    tmp___54 = PianoListAppend(
                                        tmp___53,
                                        &mut (*song___0).head as *mut PianoListHead_t,
                                    );
                                    (*searchResult).songs = tmp___54 as *mut PianoSong_t;
                                    i___3 += 1;
                                }
                            }
                        }
                        7996750302764191971 => {
                            tmp___57 = calloc(
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                            );
                            tmpStation___0 = tmp___57 as *mut PianoStation_t;
                            if tmpStation___0 as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                return PIANO_RET_OUT_OF_MEMORY;
                            }
                            PianoJsonParseStation(result, tmpStation___0);
                            tmp___58 = PianoFindStationById(
                                (*ph).stations,
                                (*tmpStation___0).id as *const libc::c_char,
                            );
                            search = tmp___58;
                            if search as libc::c_ulong
                                != 0 as *mut libc::c_void as libc::c_ulong
                            {
                                if (*ph).stations as libc::c_ulong
                                    == 0 as *mut libc::c_void as libc::c_ulong
                                {
                                    tmp___59 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                } else {
                                    tmp___59 = &mut (*(*ph).stations).head;
                                }
                                tmp___60 = PianoListDelete(
                                    tmp___59,
                                    &mut (*search).head as *mut PianoListHead_t,
                                );
                                (*ph).stations = tmp___60 as *mut PianoStation_t;
                                PianoDestroyStation(search);
                                free(search as *mut libc::c_void);
                            }
                            if (*ph).stations as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                tmp___61 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                            } else {
                                tmp___61 = &mut (*(*ph).stations).head;
                            }
                            tmp___62 = PianoListAppend(
                                tmp___61,
                                &mut (*tmpStation___0).head as *mut PianoListHead_t,
                            );
                            (*ph).stations = tmp___62 as *mut PianoStation_t;
                        }
                        5788185166277156883 => {
                            song___1 = (*req).data as *mut PianoSong_t;
                            (*song___1).rating = PIANO_RATE_TIRED;
                        }
                        14429815417003997109 => {
                            tmp___74 = json_object_object_get_ex(
                                result as *const json_object,
                                b"categories\0" as *const u8 as *const libc::c_char,
                                &mut categories,
                            );
                            if tmp___74 != 0 {
                                i___4 = 0 as libc::c_int;
                                loop {
                                    tmp___73 = json_object_array_length(
                                        categories as *const json_object,
                                    );
                                    if !((i___4 as size_t) < tmp___73) {
                                        break;
                                    }
                                    tmp___63 = json_object_array_get_idx(
                                        categories as *const json_object,
                                        i___4 as size_t,
                                    );
                                    c = tmp___63;
                                    tmp___64 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoGenreCategory_t>()
                                            as libc::c_ulong,
                                    );
                                    tmpGenreCategory = tmp___64 as *mut PianoGenreCategory_t;
                                    if tmpGenreCategory as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*tmpGenreCategory)
                                        .name = PianoJsonStrdup(
                                        c,
                                        b"categoryName\0" as *const u8 as *const libc::c_char,
                                    );
                                    tmp___70 = json_object_object_get_ex(
                                        c as *const json_object,
                                        b"stations\0" as *const u8 as *const libc::c_char,
                                        &mut stations___0,
                                    );
                                    if tmp___70 != 0 {
                                        k___0 = 0 as libc::c_int;
                                        loop {
                                            tmp___69 = json_object_array_length(
                                                stations___0 as *const json_object,
                                            );
                                            if !((k___0 as size_t) < tmp___69) {
                                                break;
                                            }
                                            tmp___65 = json_object_array_get_idx(
                                                stations___0 as *const json_object,
                                                k___0 as size_t,
                                            );
                                            s___2 = tmp___65;
                                            tmp___66 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                            );
                                            tmpGenre = tmp___66 as *mut PianoGenre_t;
                                            if tmpGenre as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*tmpGenre)
                                                .name = PianoJsonStrdup(
                                                s___2,
                                                b"stationName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*tmpGenre)
                                                .musicId = PianoJsonStrdup(
                                                s___2,
                                                b"stationToken\0" as *const u8 as *const libc::c_char,
                                            );
                                            if (*tmpGenreCategory).genres as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___67 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___67 = &mut (*(*tmpGenreCategory).genres).head;
                                            }
                                            tmp___68 = PianoListAppend(
                                                tmp___67,
                                                &mut (*tmpGenre).head as *mut PianoListHead_t,
                                            );
                                            (*tmpGenreCategory).genres = tmp___68 as *mut PianoGenre_t;
                                            k___0 += 1;
                                        }
                                    }
                                    if (*ph).genreStations as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___71 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___71 = &mut (*(*ph).genreStations).head;
                                    }
                                    tmp___72 = PianoListAppend(
                                        tmp___71,
                                        &mut (*tmpGenreCategory).head as *mut PianoListHead_t,
                                    );
                                    (*ph).genreStations = tmp___72 as *mut PianoGenreCategory_t;
                                    i___4 += 1;
                                }
                            }
                        }
                        5539689802144708648 => {
                            station___0 = (*req).data as *mut PianoStation_t;
                            (*station___0).isCreator = 1 as libc::c_int as libc::c_char;
                        }
                        5790515546987520453 => {
                            reqData___5 = (*req).data as *mut PianoRequestDataExplain_t;
                            strSize = 768 as libc::c_int as size_t;
                            tmp___82 = json_object_object_get_ex(
                                result as *const json_object,
                                b"explanations\0" as *const u8 as *const libc::c_char,
                                &mut explanations,
                            );
                            if tmp___82 != 0 {
                                tmp___75 = malloc(
                                    strSize
                                        .wrapping_mul(
                                            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                );
                                (*reqData___5).retExplain = tmp___75 as *mut libc::c_char;
                                strncpy(
                                    (*reqData___5).retExplain,
                                    b"We're playing this track because it features \0"
                                        as *const u8 as *const libc::c_char,
                                    strSize,
                                );
                                i___5 = 0 as libc::c_int;
                                loop {
                                    tmp___81 = json_object_array_length(
                                        explanations as *const json_object,
                                    );
                                    if !((i___5 as size_t) < tmp___81) {
                                        break;
                                    }
                                    tmp___76 = json_object_array_get_idx(
                                        explanations as *const json_object,
                                        i___5 as size_t,
                                    );
                                    e = tmp___76;
                                    tmp___77 = json_object_object_get_ex(
                                        e as *const json_object,
                                        b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                        &mut f,
                                    );
                                    if !(tmp___77 == 0) {
                                        tmp___78 = json_object_get_string(f);
                                        s___3 = tmp___78;
                                        PianoStrpcat((*reqData___5).retExplain, s___3, strSize);
                                        tmp___80 = json_object_array_length(
                                            explanations as *const json_object,
                                        );
                                        if (i___5 as size_t)
                                            < tmp___80.wrapping_sub(2 as libc::c_ulong)
                                        {
                                            PianoStrpcat(
                                                (*reqData___5).retExplain,
                                                b", \0" as *const u8 as *const libc::c_char,
                                                strSize,
                                            );
                                        } else {
                                            tmp___79 = json_object_array_length(
                                                explanations as *const json_object,
                                            );
                                            if i___5 as size_t
                                                == tmp___79.wrapping_sub(2 as libc::c_ulong)
                                            {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b" and \0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            } else {
                                                PianoStrpcat(
                                                    (*reqData___5).retExplain,
                                                    b".\0" as *const u8 as *const libc::c_char,
                                                    strSize,
                                                );
                                            }
                                        }
                                    }
                                    i___5 += 1;
                                }
                            }
                        }
                        8857393537059434631 => {
                            settings = (*req).data as *mut PianoSettings_t;
                            (*settings)
                                .explicitContentFilter = getBoolDefault(
                                result,
                                b"isExplicitContentFilterEnabled\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int != 0,
                            );
                            (*settings)
                                .username = PianoJsonStrdup(
                                result,
                                b"username\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        12838518962235657452 => {
                            reqData___6 = (*req).data
                                as *mut PianoRequestDataGetStationInfo_t;
                            info = &mut (*reqData___6).info;
                            tmp___95 = json_object_object_get_ex(
                                result as *const json_object,
                                b"music\0" as *const u8 as *const libc::c_char,
                                &mut music,
                            );
                            if tmp___95 != 0 {
                                tmp___88 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"songs\0" as *const u8 as *const libc::c_char,
                                    &mut songs___0,
                                );
                                if tmp___88 != 0 {
                                    i___6 = 0 as libc::c_int;
                                    loop {
                                        tmp___87 = json_object_array_length(
                                            songs___0 as *const json_object,
                                        );
                                        if !((i___6 as size_t) < tmp___87) {
                                            break;
                                        }
                                        tmp___83 = json_object_array_get_idx(
                                            songs___0 as *const json_object,
                                            i___6 as size_t,
                                        );
                                        s___4 = tmp___83;
                                        tmp___84 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        );
                                        seedSong = tmp___84 as *mut PianoSong_t;
                                        if seedSong as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedSong)
                                            .title = PianoJsonStrdup(
                                            s___4,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .artist = PianoJsonStrdup(
                                            s___4,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedSong)
                                            .seedId = PianoJsonStrdup(
                                            s___4,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).songSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___85 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___85 = &mut (*(*info).songSeeds).head;
                                        }
                                        tmp___86 = PianoListAppend(
                                            tmp___85,
                                            &mut (*seedSong).head as *mut PianoListHead_t,
                                        );
                                        (*info).songSeeds = tmp___86 as *mut PianoSong_t;
                                        i___6 += 1;
                                    }
                                }
                                tmp___94 = json_object_object_get_ex(
                                    music as *const json_object,
                                    b"artists\0" as *const u8 as *const libc::c_char,
                                    &mut artists___0,
                                );
                                if tmp___94 != 0 {
                                    i___7 = 0 as libc::c_int;
                                    loop {
                                        tmp___93 = json_object_array_length(
                                            artists___0 as *const json_object,
                                        );
                                        if !((i___7 as size_t) < tmp___93) {
                                            break;
                                        }
                                        tmp___89 = json_object_array_get_idx(
                                            artists___0 as *const json_object,
                                            i___7 as size_t,
                                        );
                                        a___0 = tmp___89;
                                        tmp___90 = calloc(
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                        );
                                        seedArtist = tmp___90 as *mut PianoArtist_t;
                                        if seedArtist as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*seedArtist)
                                            .name = PianoJsonStrdup(
                                            a___0,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*seedArtist)
                                            .seedId = PianoJsonStrdup(
                                            a___0,
                                            b"seedId\0" as *const u8 as *const libc::c_char,
                                        );
                                        if (*info).artistSeeds as libc::c_ulong
                                            == 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            tmp___91 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                        } else {
                                            tmp___91 = &mut (*(*info).artistSeeds).head;
                                        }
                                        tmp___92 = PianoListAppend(
                                            tmp___91,
                                            &mut (*seedArtist).head as *mut PianoListHead_t,
                                        );
                                        (*info).artistSeeds = tmp___92 as *mut PianoArtist_t;
                                        i___7 += 1;
                                    }
                                }
                            }
                            tmp___107 = json_object_object_get_ex(
                                result as *const json_object,
                                b"feedback\0" as *const u8 as *const libc::c_char,
                                &mut feedback,
                            );
                            if tmp___107 != 0 {
                                i___8 = 0 as libc::c_int as size_t;
                                while i___8
                                    < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                        as libc::c_ulong)
                                        .wrapping_div(
                                            ::std::mem::size_of::<*const libc::c_char>()
                                                as libc::c_ulong,
                                        )
                                {
                                    tmp___96 = json_object_object_get_ex(
                                        feedback as *const json_object,
                                        keys[i___8 as usize],
                                        &mut val,
                                    );
                                    if !(tmp___96 == 0) {
                                        i___9 = 0 as libc::c_int;
                                        loop {
                                            tmp___106 = json_object_array_length(
                                                val as *const json_object,
                                            );
                                            if !((i___9 as size_t) < tmp___106) {
                                                break;
                                            }
                                            tmp___97 = json_object_array_get_idx(
                                                val as *const json_object,
                                                i___9 as size_t,
                                            );
                                            s___5 = tmp___97;
                                            tmp___98 = calloc(
                                                1 as libc::c_int as size_t,
                                                ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                            );
                                            feedbackSong = tmp___98 as *mut PianoSong_t;
                                            if feedbackSong as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                return PIANO_RET_OUT_OF_MEMORY;
                                            }
                                            (*feedbackSong)
                                                .title = PianoJsonStrdup(
                                                s___5,
                                                b"songName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .artist = PianoJsonStrdup(
                                                s___5,
                                                b"artistName\0" as *const u8 as *const libc::c_char,
                                            );
                                            (*feedbackSong)
                                                .feedbackId = PianoJsonStrdup(
                                                s___5,
                                                b"feedbackId\0" as *const u8 as *const libc::c_char,
                                            );
                                            tmp___100 = getBoolDefault(
                                                s___5,
                                                b"isPositive\0" as *const u8 as *const libc::c_char,
                                                0 as libc::c_int != 0,
                                            );
                                            if tmp___100 {
                                                (*feedbackSong).rating = PIANO_RATE_LOVE;
                                            } else {
                                                (*feedbackSong).rating = PIANO_RATE_BAN;
                                            }
                                            tmp___103 = json_object_object_get_ex(
                                                s___5 as *const json_object,
                                                b"trackLength\0" as *const u8 as *const libc::c_char,
                                                &mut v___0,
                                            );
                                            if tmp___103 != 0 {
                                                tmp___102 = json_object_get_int(
                                                    v___0 as *const json_object,
                                                );
                                                (*feedbackSong).length = tmp___102 as libc::c_uint;
                                            } else {
                                                (*feedbackSong).length = 0 as libc::c_uint;
                                            }
                                            if (*info).feedback as libc::c_ulong
                                                == 0 as *mut libc::c_void as libc::c_ulong
                                            {
                                                tmp___104 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                            } else {
                                                tmp___104 = &mut (*(*info).feedback).head;
                                            }
                                            tmp___105 = PianoListAppend(
                                                tmp___104,
                                                &mut (*feedbackSong).head as *mut PianoListHead_t,
                                            );
                                            (*info).feedback = tmp___105 as *mut PianoSong_t;
                                            i___9 += 1;
                                        }
                                    }
                                    i___8 = i___8.wrapping_add(1);
                                }
                            }
                        }
                        17392656807572532655 => {
                            reqData___7 = (*req).data
                                as *mut PianoRequestDataGetStationModes_t;
                            active = -(1 as libc::c_int);
                            tmp___108 = json_object_object_get_ex(
                                result as *const json_object,
                                b"currentModeId\0" as *const u8 as *const libc::c_char,
                                &mut activeMode,
                            );
                            if tmp___108 != 0 {
                                active = json_object_get_int(
                                    activeMode as *const json_object,
                                );
                            }
                            tmp___115 = json_object_object_get_ex(
                                result as *const json_object,
                                b"availableModes\0" as *const u8 as *const libc::c_char,
                                &mut availableModes,
                            );
                            if tmp___115 != 0 {
                                i___10 = 0 as libc::c_int;
                                loop {
                                    tmp___114 = json_object_array_length(
                                        availableModes as *const json_object,
                                    );
                                    if !((i___10 as size_t) < tmp___114) {
                                        break;
                                    }
                                    tmp___109 = json_object_array_get_idx(
                                        availableModes as *const json_object,
                                        i___10 as size_t,
                                    );
                                    val___0 = tmp___109;
                                    tmp___110 = calloc(
                                        1 as libc::c_int as size_t,
                                        ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                    );
                                    mode = tmp___110 as *mut PianoStationMode_t;
                                    if mode as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    tmp___111 = json_object_object_get_ex(
                                        val___0 as *const json_object,
                                        b"modeId\0" as *const u8 as *const libc::c_char,
                                        &mut modeId,
                                    );
                                    if tmp___111 != 0 {
                                        (*mode)
                                            .id = json_object_get_int(modeId as *const json_object);
                                        (*mode)
                                            .name = PianoJsonStrdup(
                                            val___0,
                                            b"modeName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .description = PianoJsonStrdup(
                                            val___0,
                                            b"modeDescription\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*mode)
                                            .isAlgorithmic = getBoolDefault(
                                            val___0,
                                            b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode)
                                            .isTakeover = getBoolDefault(
                                            val___0,
                                            b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        );
                                        (*mode).active = active == (*mode).id;
                                    }
                                    if (*reqData___7).retModes as libc::c_ulong
                                        == 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        tmp___112 = 0 as *mut libc::c_void as *mut PianoListHead_t;
                                    } else {
                                        tmp___112 = &mut (*(*reqData___7).retModes).head;
                                    }
                                    tmp___113 = PianoListAppend(
                                        tmp___112,
                                        &mut (*mode).head as *mut PianoListHead_t,
                                    );
                                    (*reqData___7)
                                        .retModes = tmp___113 as *mut PianoStationMode_t;
                                    i___10 += 1;
                                }
                            }
                        }
                        _ => {
                            reqData___0 = (*req).data as *mut PianoRequestDataLogin_t;
                            match (*reqData___0).step as libc::c_int {
                                0 => {
                                    tmp___5 = json_object_object_get_ex(
                                        result as *const json_object,
                                        b"syncTime\0" as *const u8 as *const libc::c_char,
                                        &mut jsonTimestamp,
                                    );
                                    if tmp___5 == 0 {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        tmp___6 = json_object_get_string(jsonTimestamp);
                                        cryptedTimestamp = tmp___6;
                                        tmp___7 = time(0 as *mut libc::c_void as *mut time_t);
                                        realTimestamp = tmp___7;
                                        decryptedTimestamp = 0 as *mut libc::c_void
                                            as *mut libc::c_char;
                                        ret = PIANO_RET_ERR;
                                        decryptedTimestamp = PianoDecryptString(
                                            (*ph).partner.in_0,
                                            cryptedTimestamp,
                                            &mut decryptedSize as *mut size_t,
                                        );
                                        if decryptedTimestamp as libc::c_ulong
                                            != 0 as *mut libc::c_void as libc::c_ulong
                                        {
                                            if decryptedSize > 4 as libc::c_ulong {
                                                tmp___8 = strtoul(
                                                    decryptedTimestamp.offset(4 as libc::c_int as isize)
                                                        as *const libc::c_char,
                                                    0 as *mut libc::c_void as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                );
                                                timestamp = tmp___8;
                                                (*ph)
                                                    .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                                    as libc::c_int;
                                                ret = PIANO_RET_CONTINUE_REQUEST;
                                            }
                                        }
                                        free(decryptedTimestamp as *mut libc::c_void);
                                        (*ph)
                                            .partner
                                            .authToken = PianoJsonStrdup(
                                            result,
                                            b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        tmp___9 = json_object_object_get_ex(
                                            result as *const json_object,
                                            b"partnerId\0" as *const u8 as *const libc::c_char,
                                            &mut partnerId,
                                        );
                                        if tmp___9 == 0 {
                                            ret = PIANO_RET_INVALID_RESPONSE;
                                        } else {
                                            tmp___10 = json_object_get_int(
                                                partnerId as *const json_object,
                                            );
                                            (*ph).partner.id = tmp___10 as libc::c_uint;
                                            (*reqData___0)
                                                .step = ((*reqData___0).step as libc::c_int
                                                + 1 as libc::c_int) as libc::c_uchar;
                                        }
                                    }
                                }
                                1 => {
                                    if (*ph).user.listenerId as libc::c_ulong
                                        != 0 as *mut libc::c_void as libc::c_ulong
                                    {
                                        PianoDestroyUserInfo(&mut (*ph).user);
                                    }
                                    (*ph)
                                        .user
                                        .listenerId = PianoJsonStrdup(
                                        result,
                                        b"userId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*ph)
                                        .user
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                _ => {}
                            }
                        }
                    }
                }
                5 | 24 | 22 | 21 | 19 | 18 | 13 | 11 | _ => {}
            }
        }
    }
    json_object_put(j);
    return ret;
}
pub unsafe extern "C" fn PianoListAppend(
    l: *mut PianoListHead_t,
    e: *mut PianoListHead_t,
) -> *mut libc::c_void {
    let mut curr: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    if l as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return e as *mut libc::c_void
    } else {
        curr = l;
        while (*curr).next as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
            curr = (*curr).next;
        }
        (*curr).next = e as *mut PianoListHead;
        return l as *mut libc::c_void;
    };
}
pub unsafe extern "C" fn PianoListPrepend(
    l: *mut PianoListHead_t,
    e: *mut PianoListHead_t,
) -> *mut libc::c_void {
    (*e).next = l as *mut PianoListHead;
    return e as *mut libc::c_void;
}
pub unsafe extern "C" fn PianoListDelete(
    l: *mut PianoListHead_t,
    e: *mut PianoListHead_t,
) -> *mut libc::c_void {
    let mut first: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut curr: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut prev: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    first = l;
    curr = l;
    prev = 0 as *mut libc::c_void as *mut PianoListHead_t;
    while curr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if curr as libc::c_ulong == e as libc::c_ulong {
            if prev as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                (*prev).next = (*curr).next;
            } else {
                first = (*curr).next;
            }
            break;
        } else {
            prev = curr;
            curr = (*curr).next as *mut libc::c_void as *mut PianoListHead_t;
        }
    }
    return first as *mut libc::c_void;
}
pub unsafe extern "C" fn PianoListGet(
    l: *mut PianoListHead_t,
    n: size_t,
) -> *mut libc::c_void {
    let mut curr: *mut PianoListHead_t = 0 as *mut PianoListHead_t;
    let mut i: size_t = 0;
    curr = l;
    i = n;
    while curr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if i == 0 as libc::c_ulong {
            return curr as *mut libc::c_void;
        }
        i = i.wrapping_sub(1);
        curr = (*curr).next as *mut libc::c_void as *mut PianoListHead_t;
    }
    return 0 as *mut libc::c_void;
}
pub unsafe extern "C" fn PianoListCount(l: *const PianoListHead_t) -> size_t {
    let mut count: size_t = 0;
    let mut curr: *const PianoListHead_t = 0 as *const PianoListHead_t;
    count = 0 as libc::c_int as size_t;
    curr = l;
    while curr as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        count = count.wrapping_add(1);
        curr = (*curr).next as *mut libc::c_void as *const PianoListHead_t;
    }
    return count;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
