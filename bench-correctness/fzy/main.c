/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef int __int32_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __clock_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef long __jmp_buf[8];
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag jmp_buf[1];
typedef __clock_t clock_t;
struct greatest_suite_info {
   unsigned int tests_run ;
   unsigned int passed ;
   unsigned int failed ;
   unsigned int skipped ;
   clock_t pre_suite ;
   clock_t post_suite ;
   clock_t pre_test ;
   clock_t post_test ;
};
typedef struct greatest_suite_info greatest_suite_info;
typedef void greatest_suite_cb(void);
typedef void greatest_setup_cb(void *udata );
typedef void greatest_teardown_cb(void *udata );
typedef int greatest_equal_cb(void const   *exp , void const   *got , void *udata );
typedef int greatest_printf_cb(void const   *t , void *udata );
struct greatest_type_info {
   greatest_equal_cb *equal ;
   greatest_printf_cb *print ;
};
typedef struct greatest_type_info greatest_type_info;
struct greatest_memory_cmp_env {
   unsigned char const   *exp ;
   unsigned char const   *got ;
   size_t size ;
};
typedef struct greatest_memory_cmp_env greatest_memory_cmp_env;
enum __anonenum_greatest_flag_t_126737729 {
    GREATEST_FLAG_FIRST_FAIL = 1,
    GREATEST_FLAG_LIST_ONLY = 2
} ;
typedef enum __anonenum_greatest_flag_t_126737729 greatest_flag_t;
struct greatest_prng {
   unsigned char random_order ;
   unsigned char initialized ;
   unsigned char pad_0[2] ;
   unsigned long state ;
   unsigned long count ;
   unsigned long count_ceil ;
   unsigned long count_run ;
   unsigned long mod ;
   unsigned long a ;
   unsigned long c ;
};
struct greatest_run_info {
   unsigned char flags ;
   unsigned char verbosity ;
   unsigned char pad_0[2] ;
   unsigned int tests_run ;
   greatest_suite_info suite ;
   unsigned int passed ;
   unsigned int failed ;
   unsigned int skipped ;
   unsigned int assertions ;
   unsigned int fail_line ;
   unsigned int pad_1 ;
   char const   *fail_file ;
   char const   *msg ;
   greatest_setup_cb *setup ;
   void *setup_udata ;
   greatest_teardown_cb *teardown ;
   void *teardown_udata ;
   unsigned int col ;
   unsigned int width ;
   char const   *suite_filter ;
   char const   *test_filter ;
   char const   *test_exclude ;
   struct greatest_prng prng[2] ;
   clock_t begin ;
   clock_t end ;
   int pad_jmp_buf ;
   jmp_buf jump_dest ;
};
typedef struct greatest_run_info greatest_run_info;
struct greatest_report_t {
   unsigned int passed ;
   unsigned int failed ;
   unsigned int skipped ;
   unsigned int assertions ;
};
typedef unsigned char __uint8_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
enum greatest_test_res {
    GREATEST_TEST_RES_PASS = 0,
    GREATEST_TEST_RES_FAIL = -1,
    GREATEST_TEST_RES_SKIP = 1
} ;
typedef __uint8_t uint8_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef uint64_t theft_seed;
typedef uint64_t theft_hash;
struct theft_bloom ;
struct theft_mt ;
struct theft {
   FILE *out ;
   theft_seed seed ;
   uint8_t requested_bloom_bits ;
   struct theft_bloom *bloom ;
   struct theft_mt *mt ;
};
typedef void *theft_alloc_cb(struct theft *t , theft_seed seed , void *env );
typedef void theft_free_cb(void *instance , void *env );
typedef theft_hash theft_hash_cb(void *instance , void *env );
typedef void *theft_shrink_cb(void *instance , uint32_t tactic , void *env );
typedef void theft_print_cb(FILE *f , void *instance , void *env );
enum __anonenum_theft_trial_res_808224241 {
    THEFT_TRIAL_PASS = 0,
    THEFT_TRIAL_FAIL = 1,
    THEFT_TRIAL_SKIP = 2,
    THEFT_TRIAL_DUP = 3,
    THEFT_TRIAL_ERROR = 4
} ;
typedef enum __anonenum_theft_trial_res_808224241 theft_trial_res;
typedef theft_trial_res theft_propfun();
struct theft_type_info {
   theft_alloc_cb *alloc ;
   theft_free_cb *free ;
   theft_hash_cb *hash ;
   theft_shrink_cb *shrink ;
   theft_print_cb *print ;
};
struct theft_trial_info {
   char const   *name ;
   int trial ;
   theft_seed seed ;
   theft_trial_res status ;
   uint8_t arity ;
   void **args ;
};
enum __anonenum_theft_progress_callback_res_308568895 {
    THEFT_PROGRESS_CONTINUE = 0,
    THEFT_PROGRESS_HALT = 1
} ;
typedef enum __anonenum_theft_progress_callback_res_308568895 theft_progress_callback_res;
typedef theft_progress_callback_res theft_progress_cb(struct theft_trial_info *info ,
                                                      void *env );
enum __anonenum_theft_run_res_746447195 {
    THEFT_RUN_PASS = 0,
    THEFT_RUN_FAIL = 1,
    THEFT_RUN_ERROR = 2,
    THEFT_RUN_ERROR_BAD_ARGS = -1,
    THEFT_RUN_ERROR_MISSING_CALLBACK = -2
} ;
typedef enum __anonenum_theft_run_res_746447195 theft_run_res;
struct theft_trial_report {
   size_t pass ;
   size_t fail ;
   size_t skip ;
   size_t dup ;
};
struct theft_cfg {
   theft_propfun *fun ;
   struct theft_type_info *type_info[10] ;
   char const   *name ;
   int always_seed_count ;
   theft_seed *always_seeds ;
   int trials ;
   theft_progress_cb *progress_cb ;
   void *env ;
   struct theft_trial_report *report ;
   theft_seed seed ;
};
typedef double score_t;
typedef long __ssize_t;
struct __anonstruct_options_t_734899051 {
   int benchmark ;
   char const   *filter ;
   char const   *init_search ;
   char const   *tty_filename ;
   int show_scores ;
   unsigned int num_lines ;
   unsigned int scrolloff ;
   char const   *prompt ;
   unsigned int workers ;
   char input_delimiter ;
   int show_info ;
};
typedef struct __anonstruct_options_t_734899051 options_t;
struct scored_result {
   score_t score ;
   char const   *str ;
};
struct __anonstruct_choices_t_109572495 {
   char *buffer ;
   size_t buffer_size ;
   size_t capacity ;
   size_t size ;
   char const   **strings ;
   struct scored_result *results ;
   size_t available ;
   size_t selection ;
   unsigned int worker_count ;
};
typedef struct __anonstruct_choices_t_109572495 choices_t;
struct match_struct {
   int needle_len ;
   int haystack_len ;
   char lower_needle[1024] ;
   char lower_haystack[1024] ;
   score_t match_bonus[1024] ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct result_list {
   struct scored_result *list ;
   size_t size ;
};
struct worker ;
struct search_job {
   pthread_mutex_t lock ;
   choices_t *choices ;
   char const   *search ;
   size_t processed ;
   struct worker *workers ;
};
struct worker {
   pthread_t thread_id ;
   struct search_job *job ;
   unsigned int worker_num ;
   struct result_list result ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef short __int16_t;
typedef __int16_t int16_t;
typedef struct theft theft;
enum __anonenum_all_gen_res_t_575372223 {
    ALL_GEN_OK = 0,
    ALL_GEN_SKIP = 1,
    ALL_GEN_DUP = 2,
    ALL_GEN_ERROR = 3
} ;
typedef enum __anonenum_all_gen_res_t_575372223 all_gen_res_t;
enum __anonenum_shrink_res_238061164 {
    SHRINK_OK = 0,
    SHRINK_DEAD_END = 1,
    SHRINK_ERROR = 2
} ;
typedef enum __anonenum_shrink_res_238061164 shrink_res;
struct theft_propfun_info {
   char const   *name ;
   theft_propfun *fun ;
   uint8_t arity ;
   struct theft_type_info *type_info[10] ;
   int always_seed_count ;
   theft_seed *always_seeds ;
};
struct theft_bloom {
   uint8_t bit_count ;
   size_t size ;
   uint8_t bits[] ;
};
struct theft_mt {
   uint64_t mt[312] ;
   int16_t mti ;
};
typedef unsigned short __uint16_t;
typedef __int32_t int32_t;
typedef __uint16_t uint16_t;
struct theft_hasher {
   theft_hash accum ;
};
#pragma merger("0","/tmp/cil-yyO1Do9n.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
greatest_type_info greatest_type_info_string ;
greatest_type_info greatest_type_info_memory ;
greatest_run_info greatest_info  ;
void greatest_do_pass(char const   *name ) ;
void greatest_do_fail(char const   *name ) ;
void greatest_do_skip(char const   *name ) ;
int greatest_suite_pre(char const   *suite_name ) ;
void greatest_suite_post(void) ;
int greatest_test_pre(char const   *name ) ;
void greatest_test_post(char const   *name , int res ) ;
void greatest_usage(char const   *name ) ;
int greatest_do_assert_equal_t(void const   *exp , void const   *got , greatest_type_info *type_info ,
                               void *udata ) ;
void greatest_prng_init_first_pass(int id ) ;
int greatest_prng_init_second_pass(int id , unsigned long seed ) ;
void greatest_prng_step(int id ) ;
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb , void *udata ) ;
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb , void *udata ) ;
int greatest_all_passed(void) ;
void greatest_set_suite_filter(char const   *filter ) ;
void greatest_set_test_filter(char const   *filter ) ;
void greatest_set_test_exclude(char const   *filter ) ;
void greatest_stop_at_first_fail(void) ;
void greatest_get_report(struct greatest_report_t *report ) ;
unsigned int greatest_get_verbosity(void) ;
void greatest_set_verbosity(unsigned int verbosity ) ;
void greatest_set_flag(greatest_flag_t flag ) ;
void match_suite(void) ;
void choices_suite(void) ;
void properties_suite(void) ;
static int greatest_name_match(char const   *name , char const   *filter , int res_if_none ) 
{ 
  size_t offset ;
  size_t filter_len ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  offset = (size_t )0;
  if (filter) {
    tmp = strlen(filter);
    tmp___0 = tmp;
  } else {
    tmp___0 = (size_t )0;
  }
  filter_len = tmp___0;
  if (filter_len == 0UL) {
    return (res_if_none);
  }
  while ((int const   )*(name + offset) != 0) {
    if ((int const   )*(name + offset) == (int const   )*(filter + 0)) {
      tmp___1 = strncmp(name + offset, filter, filter_len);
      if (0 == tmp___1) {
        return (1);
      }
    }
    offset ++;
  }
  return (0);
}
}
int greatest_test_pre(char const   *name ) 
{ 
  struct greatest_run_info *g ;
  int match___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct greatest_prng *p ;

  {
  g = & greatest_info;
  tmp = greatest_name_match(name, g->test_filter, 1);
  if (tmp) {
    tmp___0 = greatest_name_match(name, g->test_exclude, 0);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  match___0 = tmp___1;
  if ((int )greatest_info.flags & 2) {
    if (match___0) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"  %s\n",
              name);
    }
    return (0);
  }
  if (match___0) {
    if (! ((int )greatest_info.flags & 1)) {
      goto _L;
    } else
    if (g->suite.failed == 0U) {
      _L: /* CIL Label */ 
      p = & g->prng[1];
      if (p->random_order) {
        (p->count) ++;
        if (! p->initialized) {
          return (0);
        } else
        if (p->count - 1UL != p->state) {
          return (0);
        }
      }
      g->suite.pre_test = clock();
      if (g->suite.pre_test == -1L) {
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"clock error: %s\n",
                "g->suite.pre_test");
        exit(1);
      }
      if (g->setup) {
        (*(g->setup))(g->setup_udata);
      }
      (p->count_run) ++;
      return (1);
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
void greatest_test_post(char const   *name , int res ) 
{ 
  void *udata ;

  {
  greatest_info.suite.post_test = clock();
  if (greatest_info.suite.post_test == -1L) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"clock error: %s\n",
            "greatest_info.suite.post_test");
    exit(1);
  }
  if (greatest_info.teardown) {
    udata = greatest_info.teardown_udata;
    (*(greatest_info.teardown))(udata);
  }
  if (res <= -1) {
    greatest_do_fail(name);
  } else
  if (res >= 1) {
    greatest_do_skip(name);
  } else
  if (res == 0) {
    greatest_do_pass(name);
  }
  (greatest_info.suite.tests_run) ++;
  (greatest_info.col) ++;
  if ((int )greatest_info.verbosity > 0) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" (%lu ticks, %.3f sec)",
            (unsigned long )greatest_info.suite.post_test - (unsigned long )greatest_info.suite.pre_test,
            (double )(greatest_info.suite.post_test - greatest_info.suite.pre_test) / (1.0 * (double )1000000L));
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  } else
  if (greatest_info.col % greatest_info.width == 0U) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    greatest_info.col = 0U;
  }
  fflush(stdout);
  return;
}
}
static void report_suite(void) 
{ 
  char const   *tmp ;

  {
  if (greatest_info.suite.tests_run > 0U) {
    if (greatest_info.suite.tests_run == 1U) {
      tmp = "";
    } else {
      tmp = "s";
    }
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n%u test%s - %u passed, %u failed, %u skipped",
            greatest_info.suite.tests_run, tmp, greatest_info.suite.passed, greatest_info.suite.failed,
            greatest_info.suite.skipped);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" (%lu ticks, %.3f sec)",
            (unsigned long )greatest_info.suite.post_suite - (unsigned long )greatest_info.suite.pre_suite,
            (double )(greatest_info.suite.post_suite - greatest_info.suite.pre_suite) / (1.0 * (double )1000000L));
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  return;
}
}
static void update_counts_and_reset_suite(void) 
{ 


  {
  greatest_info.setup = (greatest_setup_cb *)((void *)0);
  greatest_info.setup_udata = (void *)0;
  greatest_info.teardown = (greatest_teardown_cb *)((void *)0);
  greatest_info.teardown_udata = (void *)0;
  greatest_info.passed += greatest_info.suite.passed;
  greatest_info.failed += greatest_info.suite.failed;
  greatest_info.skipped += greatest_info.suite.skipped;
  greatest_info.tests_run += greatest_info.suite.tests_run;
  memset((void *)(& greatest_info.suite), 0, sizeof(greatest_info.suite));
  greatest_info.col = 0U;
  return;
}
}
int greatest_suite_pre(char const   *suite_name ) 
{ 
  struct greatest_prng *p ;
  int tmp ;

  {
  p = & greatest_info.prng[0];
  tmp = greatest_name_match(suite_name, greatest_info.suite_filter, 1);
  if (tmp) {
    if ((int )greatest_info.flags & 1) {
      if (greatest_info.failed > 0U) {
        return (0);
      }
    }
  } else {
    return (0);
  }
  if (p->random_order) {
    (p->count) ++;
    if (! p->initialized) {
      return (0);
    } else
    if (p->count - 1UL != p->state) {
      return (0);
    }
  }
  (p->count_run) ++;
  update_counts_and_reset_suite();
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n* Suite %s:\n",
          suite_name);
  greatest_info.suite.pre_suite = clock();
  if (greatest_info.suite.pre_suite == -1L) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"clock error: %s\n",
            "greatest_info.suite.pre_suite");
    exit(1);
  }
  return (1);
}
}
void greatest_suite_post(void) 
{ 


  {
  greatest_info.suite.post_suite = clock();
  if (greatest_info.suite.post_suite == -1L) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"clock error: %s\n",
            "greatest_info.suite.post_suite");
    exit(1);
  }
  report_suite();
  return;
}
}
static void greatest_run_suite(greatest_suite_cb *suite_cb , char const   *suite_name ) 
{ 
  int tmp ;

  {
  tmp = greatest_suite_pre(suite_name);
  if (tmp) {
    (*suite_cb)();
    greatest_suite_post();
  }
  return;
}
}
void greatest_do_pass(char const   *name ) 
{ 
  char const   *tmp ;

  {
  if ((int )greatest_info.verbosity > 0) {
    if (greatest_info.msg) {
      tmp = greatest_info.msg;
    } else {
      tmp = "";
    }
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"PASS %s: %s",
            name, tmp);
  } else {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )".");
  }
  (greatest_info.suite.passed) ++;
  return;
}
}
void greatest_do_fail(char const   *name ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((int )greatest_info.verbosity > 0) {
    if (greatest_info.msg) {
      tmp = greatest_info.msg;
    } else {
      tmp = "";
    }
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"FAIL %s: %s (%s:%u)",
            name, tmp, greatest_info.fail_file, greatest_info.fail_line);
  } else {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"F");
    (greatest_info.col) ++;
    if (greatest_info.col != 0U) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      greatest_info.col = 0U;
    }
    if (greatest_info.msg) {
      tmp___0 = greatest_info.msg;
    } else {
      tmp___0 = "";
    }
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"FAIL %s: %s (%s:%u)\n",
            name, tmp___0, greatest_info.fail_file, greatest_info.fail_line);
  }
  (greatest_info.suite.failed) ++;
  return;
}
}
void greatest_do_skip(char const   *name ) 
{ 
  char const   *tmp ;

  {
  if ((int )greatest_info.verbosity > 0) {
    if (greatest_info.msg) {
      tmp = greatest_info.msg;
    } else {
      tmp = "";
    }
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"SKIP %s: %s",
            name, tmp);
  } else {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"s");
  }
  (greatest_info.suite.skipped) ++;
  return;
}
}
int greatest_do_assert_equal_t(void const   *exp , void const   *got , greatest_type_info *type_info ,
                               void *udata ) 
{ 
  int eq ;

  {
  eq = 0;
  if ((unsigned long )type_info == (unsigned long )((void *)0)) {
    return (0);
  } else
  if ((unsigned long )type_info->equal == (unsigned long )((void *)0)) {
    return (0);
  }
  eq = (*(type_info->equal))(exp, got, udata);
  if (! eq) {
    if ((unsigned long )type_info->print != (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      (*(type_info->print))(exp, udata);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      (*(type_info->print))(got, udata);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    } else {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"GREATEST_ASSERT_EQUAL_T failure at %s:%u\n",
              greatest_info.fail_file, greatest_info.fail_line);
    }
  }
  return (eq);
}
}
void greatest_usage(char const   *name ) 
{ 


  {
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Usage: %s [--help] [-hlfv] [-s SUITE] [-t TEST]\n  -h, --help  print this Help\n  -l          List suites and tests, then exit (dry run)\n  -f          Stop runner after first failure\n  -v          Verbose output\n  -s SUITE    only run suites containing string SUITE\n  -t TEST     only run tests containing string TEST\n  -x EXCLUDE  exclude tests containing string EXCLUDE\n",
          name);
  return;
}
}
static void greatest_parse_options(int argc , char **argv ) 
{ 
  int i ;
  char f ;
  int tmp ;
  int tmp___0 ;

  {
  i = 0;
  i = 1;
  while (i < argc) {
    if ((int )*(*(argv + i) + 0) == 45) {
      f = *(*(argv + i) + 1);
      if ((int )f == 115) {
        goto _L;
      } else
      if ((int )f == 116) {
        goto _L;
      } else
      if ((int )f == 120) {
        _L: /* CIL Label */ 
        if (argc <= i + 1) {
          greatest_usage((char const   *)*(argv + 0));
          exit(1);
        }
      }
      switch ((int )f) {
      case 115: 
      greatest_set_suite_filter((char const   *)*(argv + (i + 1)));
      i ++;
      break;
      case 116: 
      greatest_set_test_filter((char const   *)*(argv + (i + 1)));
      i ++;
      break;
      case 120: 
      greatest_set_test_exclude((char const   *)*(argv + (i + 1)));
      i ++;
      break;
      case 102: 
      greatest_stop_at_first_fail();
      break;
      case 108: 
      greatest_info.flags = (unsigned char )((int )greatest_info.flags | 2);
      break;
      case 118: 
      greatest_info.verbosity = (unsigned char )((int )greatest_info.verbosity + 1);
      break;
      case 104: 
      greatest_usage((char const   *)*(argv + 0));
      exit(0);
      case 45: 
      tmp___0 = strncmp("--help", (char const   *)*(argv + i), (size_t )6);
      if (0 == tmp___0) {
        greatest_usage((char const   *)*(argv + 0));
        exit(0);
      } else {
        tmp = strncmp("--", (char const   *)*(argv + i), (size_t )2);
        if (0 == tmp) {
          return;
        }
      }
      default: 
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Unknown argument \'%s\'\n",
              *(argv + i));
      greatest_usage((char const   *)*(argv + 0));
      exit(1);
      }
    }
    i ++;
  }
  return;
}
}
int greatest_all_passed(void) 
{ 


  {
  return (greatest_info.failed == 0U);
}
}
void greatest_set_test_filter(char const   *filter ) 
{ 


  {
  greatest_info.test_filter = filter;
  return;
}
}
void greatest_set_test_exclude(char const   *filter ) 
{ 


  {
  greatest_info.test_exclude = filter;
  return;
}
}
void greatest_set_suite_filter(char const   *filter ) 
{ 


  {
  greatest_info.suite_filter = filter;
  return;
}
}
void greatest_stop_at_first_fail(void) 
{ 


  {
  greatest_info.flags = (unsigned char )((int )greatest_info.flags | 1);
  return;
}
}
void greatest_get_report(struct greatest_report_t *report ) 
{ 


  {
  if (report) {
    report->passed = greatest_info.passed;
    report->failed = greatest_info.failed;
    report->skipped = greatest_info.skipped;
    report->assertions = greatest_info.assertions;
  }
  return;
}
}
unsigned int greatest_get_verbosity(void) 
{ 


  {
  return ((unsigned int )greatest_info.verbosity);
}
}
void greatest_set_verbosity(unsigned int verbosity ) 
{ 


  {
  greatest_info.verbosity = (unsigned char )verbosity;
  return;
}
}
void greatest_set_flag(greatest_flag_t flag ) 
{ 


  {
  greatest_info.flags = (unsigned char )((unsigned int )greatest_info.flags | (unsigned int )flag);
  return;
}
}
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb , void *udata ) 
{ 


  {
  greatest_info.setup = cb;
  greatest_info.setup_udata = udata;
  return;
}
}
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb , void *udata ) 
{ 


  {
  greatest_info.teardown = cb;
  greatest_info.teardown_udata = udata;
  return;
}
}
static int greatest_string_equal_cb(void const   *exp , void const   *got , void *udata ) 
{ 
  size_t *size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  size = (size_t *)udata;
  if ((unsigned long )size != (unsigned long )((void *)0)) {
    tmp = strncmp((char const   *)exp, (char const   *)got, *size);
    tmp___1 = 0 == tmp;
  } else {
    tmp___0 = strcmp((char const   *)exp, (char const   *)got);
    tmp___1 = 0 == tmp___0;
  }
  return (tmp___1);
}
}
static int greatest_string_printf_cb(void const   *t , void *udata ) 
{ 
  int tmp ;

  {
  tmp = fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s", (char const   *)t);
  return (tmp);
}
}
greatest_type_info greatest_type_info_string  =    {& greatest_string_equal_cb, & greatest_string_printf_cb};
static int greatest_memory_equal_cb(void const   *exp , void const   *got , void *udata ) 
{ 
  greatest_memory_cmp_env *env ;
  int tmp ;

  {
  env = (greatest_memory_cmp_env *)udata;
  tmp = memcmp(exp, got, env->size);
  return (0 == tmp);
}
}
static int greatest_memory_printf_cb(void const   *t , void *udata ) 
{ 
  greatest_memory_cmp_env *env ;
  unsigned char const   *buf ;
  unsigned char diff_mark ;
  FILE *out ;
  size_t i ;
  size_t line_i ;
  size_t line_len ;
  int len ;
  int tmp ;
  int m ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char c ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  env = (greatest_memory_cmp_env *)udata;
  buf = (unsigned char const   *)t;
  diff_mark = (unsigned char )' ';
  out = stdout;
  line_len = (size_t )0;
  len = 0;
  i = (size_t )0;
  while (i < env->size) {
    diff_mark = (unsigned char )' ';
    line_len = env->size - i;
    if (line_len > 16UL) {
      line_len = (size_t )16;
    }
    line_i = i;
    while (line_i < i + line_len) {
      if ((int const   )*(env->exp + line_i) != (int const   )*(env->got + line_i)) {
        diff_mark = (unsigned char )'X';
      }
      line_i ++;
    }
    tmp = fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n%04x %c ",
                  (unsigned int )i, (int )diff_mark);
    len += tmp;
    line_i = i;
    while (line_i < i + line_len) {
      m = (int const   )*(env->exp + line_i) == (int const   )*(env->got + line_i);
      if (m) {
        tmp___0 = ' ';
      } else {
        tmp___0 = '<';
      }
      tmp___1 = fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%02x%c",
                        (int const   )*(buf + line_i), tmp___0);
      len += tmp___1;
      line_i ++;
    }
    line_i = (size_t )0;
    while (line_i < 16UL - line_len) {
      tmp___2 = fprintf((FILE * __restrict  )out, (char const   * __restrict  )"   ");
      len += tmp___2;
      line_i ++;
    }
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )" ");
    line_i = i;
    while (line_i < i + line_len) {
      c = (unsigned char )*(buf + line_i);
      tmp___5 = __ctype_b_loc();
      if ((int const   )*(*tmp___5 + (int )c) & 16384) {
        tmp___4 = (int )c;
      } else {
        tmp___4 = '.';
      }
      tmp___6 = fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%c",
                        tmp___4);
      len += tmp___6;
      line_i ++;
    }
    i += line_len;
  }
  tmp___7 = fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  len += tmp___7;
  return (len);
}
}
void greatest_prng_init_first_pass(int id ) 
{ 


  {
  greatest_info.prng[id].random_order = (unsigned char)1;
  greatest_info.prng[id].count_run = 0UL;
  return;
}
}
static unsigned long primes[13]  = 
  {      11UL,      101UL,      1009UL,      10007UL, 
        100003UL,      1000003UL,      10000019UL,      100000007UL, 
        1000000007UL,      1538461UL,      1865471UL,      17471UL, 
        2147483647UL};
int greatest_prng_init_second_pass(int id , unsigned long seed ) 
{ 
  struct greatest_prng *prng ;

  {
  prng = & greatest_info.prng[id];
  if (prng->count == 0UL) {
    return (0);
  }
  prng->mod = 1UL;
  prng->count_ceil = prng->count;
  while (prng->mod < prng->count) {
    prng->mod <<= 1;
  }
  prng->state = seed & 536870911UL;
  prng->a = 4UL * prng->state + 1UL;
  prng->c = primes[((seed * 16451UL) % sizeof(primes)) / sizeof(primes[0])];
  prng->initialized = (unsigned char)1;
  return (1);
}
}
void greatest_prng_step(int id ) 
{ 
  struct greatest_prng *p ;

  {
  p = & greatest_info.prng[id];
  while (1) {
    p->state = (p->a * p->state + p->c) & (p->mod - 1UL);
    if (! (p->state >= p->count_ceil)) {
      break;
    }
  }
  return;
}
}
greatest_type_info greatest_type_info_memory  =    {& greatest_memory_equal_cb, & greatest_memory_printf_cb};
int main(int argc , char **argv ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  while (1) {
    while (1) {
      memset((void *)(& greatest_info), 0, sizeof(greatest_info));
      greatest_info.width = 72U;
      greatest_info.begin = clock();
      if (greatest_info.begin == -1L) {
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"clock error: %s\n",
                "greatest_info.begin");
        exit(1);
      }
      break;
    }
    greatest_parse_options(argc, argv);
    break;
  }
  greatest_run_suite(& match_suite, "match_suite");
  greatest_run_suite(& choices_suite, "choices_suite");
  greatest_run_suite(& properties_suite, "properties_suite");
  while (1) {
    while (1) {
      if (! ((int )greatest_info.flags & 2)) {
        update_counts_and_reset_suite();
        greatest_info.end = clock();
        if (greatest_info.end == -1L) {
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"clock error: %s\n",
                  "greatest_info.end");
          exit(1);
        }
        if (greatest_info.tests_run == 1U) {
          tmp = "";
        } else {
          tmp = "s";
        }
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nTotal: %u test%s",
                greatest_info.tests_run, tmp);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" (%lu ticks, %.3f sec)",
                (unsigned long )greatest_info.end - (unsigned long )greatest_info.begin,
                (double )(greatest_info.end - greatest_info.begin) / (1.0 * (double )1000000L));
        if (greatest_info.assertions == 1U) {
          tmp___0 = "";
        } else {
          tmp___0 = "s";
        }
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )", %u assertion%s\n",
                greatest_info.assertions, tmp___0);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Pass: %u, fail: %u, skip: %u.\n",
                greatest_info.passed, greatest_info.failed, greatest_info.skipped);
      }
      break;
    }
    tmp___3 = greatest_all_passed();
    if (tmp___3) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    return (tmp___2);
    break;
  }
  return (0);
}
}
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-MLN9zpIp.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
struct theft *theft_init(uint8_t bloom_bits ) ;
void theft_free(struct theft *t ) ;
unsigned long theft_random(struct theft *t ) ;
theft_run_res theft_run(struct theft *t , struct theft_cfg *cfg ) ;
theft_hash theft_hash_onepass(uint8_t *data , size_t bytes ) ;
int has_match(char const   *needle , char const   *haystack ) ;
score_t match_positions(char const   *needle , char const   *haystack , size_t *positions ) ;
score_t match(char const   *needle , char const   *haystack ) ;
static void *string_alloc_cb(struct theft *t , theft_hash seed , void *env ) 
{ 
  int limit ;
  size_t sz ;
  char *str ;
  void *tmp ;
  size_t i ;
  theft_hash s ;
  theft_hash tmp___0 ;
  uint8_t b ;

  {
  limit = 128;
  sz = seed % (unsigned long )limit + 1UL;
  tmp = malloc(sz + 1UL);
  str = (char *)tmp;
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((void *)-2);
  }
  i = (size_t )0;
  while (i < sz) {
    tmp___0 = theft_random(t);
    s = tmp___0;
    b = (uint8_t )0;
    while ((unsigned long )b < sizeof(theft_hash )) {
      if (i + (size_t )b >= sz) {
        break;
      }
      *(str + (i + (size_t )b)) = (char )((int )((uint8_t )(s >> 8 * (int )b)) & 255);
      b = (uint8_t )((int )b + 1);
    }
    i += sizeof(theft_hash );
  }
  *(str + sz) = (char)0;
  return ((void *)str);
}
}
static void string_free_cb(void *instance , void *env ) 
{ 


  {
  free(instance);
  return;
}
}
static void string_print_cb(FILE *f , void *instance , void *env ) 
{ 
  char *str ;
  size_t size ;
  size_t tmp ;
  uint8_t bytes ;
  size_t i ;

  {
  str = (char *)instance;
  tmp = strlen((char const   *)str);
  size = tmp;
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"str[%zd]:\n    ",
          size);
  bytes = (uint8_t )0;
  i = (size_t )0;
  while (i < size) {
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02x", (int )*(str + i));
    bytes = (uint8_t )((int )bytes + 1);
    if ((int )bytes == 16) {
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n    ");
      bytes = (uint8_t )0;
    }
    i ++;
  }
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
  return;
}
}
static uint64_t string_hash_cb(void *instance , void *env ) 
{ 
  char *str ;
  int size ;
  size_t tmp ;
  theft_hash tmp___0 ;

  {
  str = (char *)instance;
  tmp = strlen((char const   *)str);
  size = (int )tmp;
  tmp___0 = theft_hash_onepass((uint8_t *)str, (size_t )size);
  return (tmp___0);
}
}
static void *string_shrink_cb(void *instance , uint32_t tactic , void *env ) 
{ 
  char *str ;
  int n ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  str = (char *)instance;
  tmp = strlen((char const   *)str);
  n = (int )tmp;
  if (tactic == 0U) {
    tmp___0 = strndup((char const   *)str, (size_t )(n / 2));
    return ((void *)tmp___0);
  } else
  if (tactic == 1U) {
    tmp___1 = strndup((char const   *)(str + n / 2), (size_t )(n / 2));
    return ((void *)tmp___1);
  } else {
    return ((void *)-3);
  }
}
}
static struct theft_type_info string_info  =    {& string_alloc_cb, & string_free_cb, & string_hash_cb, & string_shrink_cb, & string_print_cb};
static theft_trial_res prop_should_return_results_if_there_is_a_match(char *needle ,
                                                                      char *haystack ) 
{ 
  int match_exists ;
  int tmp ;
  score_t score ;
  score_t tmp___0 ;
  float tmp___1 ;

  {
  tmp = has_match((char const   *)needle, (char const   *)haystack);
  match_exists = tmp;
  if (! match_exists) {
    return ((theft_trial_res )2);
  }
  tmp___0 = match((char const   *)needle, (char const   *)haystack);
  score = tmp___0;
  if ((int )*(needle + 0) == 0) {
    return ((theft_trial_res )2);
  }
  tmp___1 = __builtin_inff();
  if (score == (score_t )(- tmp___1)) {
    return ((theft_trial_res )1);
  }
  return ((theft_trial_res )0);
}
}
static enum greatest_test_res should_return_results_if_there_is_a_match(void) 
{ 
  struct theft *t ;
  struct theft *tmp ;
  struct theft_cfg cfg ;
  unsigned int tmp___0 ;
  theft_run_res res ;
  theft_run_res tmp___1 ;

  {
  tmp = theft_init((uint8_t )0);
  t = tmp;
  cfg.fun = (theft_propfun *)(& prop_should_return_results_if_there_is_a_match);
  cfg.type_info[0] = & string_info;
  cfg.type_info[1] = & string_info;
  tmp___0 = 2U;
  while (! (tmp___0 >= 10U)) {
    cfg.type_info[tmp___0] = (struct theft_type_info *)0;
    tmp___0 ++;
  }
  cfg.name = "should_return_results_if_there_is_a_match";
  cfg.always_seed_count = 0;
  cfg.always_seeds = (theft_seed *)0;
  cfg.trials = 100000;
  cfg.progress_cb = (theft_progress_cb *)0;
  cfg.env = (void *)0;
  cfg.report = (struct theft_trial_report *)0;
  cfg.seed = 0UL;
  tmp___1 = theft_run(t, & cfg);
  res = tmp___1;
  theft_free(t);
  while (1) {
    (greatest_info.assertions) ++;
    if (0 != (int )res) {
      while (1) {
        greatest_info.fail_file = "test/test_properties.c";
        greatest_info.fail_line = 112U;
        greatest_info.msg = "should_return_results_if_there_is_a_match";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static theft_trial_res prop_positions_should_match_characters_in_string(char *needle ,
                                                                        char *haystack ) 
{ 
  int match_exists ;
  int tmp ;
  int n ;
  size_t tmp___0 ;
  size_t *positions ;
  void *tmp___1 ;
  int i ;
  int i___0 ;
  int __res ;
  __int32_t const   **tmp___3 ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;

  {
  tmp = has_match((char const   *)needle, (char const   *)haystack);
  match_exists = tmp;
  if (! match_exists) {
    return ((theft_trial_res )2);
  }
  tmp___0 = strlen((char const   *)needle);
  n = (int )tmp___0;
  tmp___1 = calloc((size_t )n, sizeof(size_t ));
  positions = (size_t *)tmp___1;
  if (! positions) {
    return ((theft_trial_res )4);
  }
  match_positions((char const   *)needle, (char const   *)haystack, positions);
  i = 1;
  while (i < n) {
    if (*(positions + i) <= *(positions + (i - 1))) {
      return ((theft_trial_res )1);
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < n) {
    if (sizeof(*(needle + i___0)) > 1UL) {
      __res = toupper((int )*(needle + i___0));
    } else {
      tmp___3 = __ctype_toupper_loc();
      __res = (int )*(*tmp___3 + (int )*(needle + i___0));
    }
    if (sizeof(*(haystack + *(positions + i___0))) > 1UL) {
      __res___0 = toupper((int )*(haystack + *(positions + i___0)));
    } else {
      tmp___5 = __ctype_toupper_loc();
      __res___0 = (int )*(*tmp___5 + (int )*(haystack + *(positions + i___0)));
    }
    if (__res != __res___0) {
      return ((theft_trial_res )1);
    }
    i___0 ++;
  }
  free((void *)positions);
  return ((theft_trial_res )0);
}
}
static enum greatest_test_res positions_should_match_characters_in_string(void) 
{ 
  struct theft *t ;
  struct theft *tmp ;
  struct theft_cfg cfg ;
  unsigned int tmp___0 ;
  theft_run_res res ;
  theft_run_res tmp___1 ;

  {
  tmp = theft_init((uint8_t )0);
  t = tmp;
  cfg.fun = (theft_propfun *)(& prop_positions_should_match_characters_in_string);
  cfg.type_info[0] = & string_info;
  cfg.type_info[1] = & string_info;
  tmp___0 = 2U;
  while (! (tmp___0 >= 10U)) {
    cfg.type_info[tmp___0] = (struct theft_type_info *)0;
    tmp___0 ++;
  }
  cfg.name = "positions_should_match_characters_in_string";
  cfg.always_seed_count = 0;
  cfg.always_seeds = (theft_seed *)0;
  cfg.trials = 100000;
  cfg.progress_cb = (theft_progress_cb *)0;
  cfg.env = (void *)0;
  cfg.report = (struct theft_trial_report *)0;
  cfg.seed = 0UL;
  tmp___1 = theft_run(t, & cfg);
  res = tmp___1;
  theft_free(t);
  while (1) {
    (greatest_info.assertions) ++;
    if (0 != (int )res) {
      while (1) {
        greatest_info.fail_file = "test/test_properties.c";
        greatest_info.fail_line = 158U;
        greatest_info.msg = "should_return_results_if_there_is_a_match";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
void properties_suite(void) 
{ 
  enum greatest_test_res res ;
  int tmp ;
  int tmp___0 ;
  enum greatest_test_res res___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  while (1) {
    tmp___0 = greatest_test_pre("should_return_results_if_there_is_a_match");
    if (tmp___0 == 1) {
      tmp = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res = (enum greatest_test_res )tmp;
      if ((int )res == 0) {
        res = should_return_results_if_there_is_a_match();
      }
      greatest_test_post("should_return_results_if_there_is_a_match", (int )res);
    }
    break;
  }
  while (1) {
    tmp___2 = greatest_test_pre("positions_should_match_characters_in_string");
    if (tmp___2 == 1) {
      tmp___1 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___0 = (enum greatest_test_res )tmp___1;
      if ((int )res___0 == 0) {
        res___0 = positions_should_match_characters_in_string();
      }
      greatest_test_post("positions_should_match_characters_in_string", (int )res___0);
    }
    break;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-TO_tY0h2.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
void options_init(options_t *options ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
void choices_init(choices_t *c , options_t *options ) ;
void choices_destroy(choices_t *c ) ;
void choices_add(choices_t *c , char const   *choice ) ;
void choices_search(choices_t *c , char const   *search ) ;
char const   *choices_get(choices_t *c , size_t n ) ;
void choices_prev(choices_t *c ) ;
void choices_next(choices_t *c ) ;
static options_t default_options  ;
static choices_t choices  ;
static void setup(void *udata ) 
{ 


  {
  options_init(& default_options);
  choices_init(& choices, & default_options);
  return;
}
}
static void teardown(void *udata ) 
{ 


  {
  choices_destroy(& choices);
  return;
}
}
static enum greatest_test_res test_choices_empty(void) 
{ 


  {
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.size) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.size);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 29U;
        greatest_info.msg = "(size_t)(0) != (choices.size)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 30U;
        greatest_info.msg = "(size_t)(0) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 31U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_prev(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 34U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_next(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 37U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res test_choices_1(void) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  choices_add(& choices, "tags");
  choices_search(& choices, "");
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 46U;
        greatest_info.msg = "(size_t)(1) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 47U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_search(& choices, "t");
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 50U;
        greatest_info.msg = "(size_t)(1) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 51U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_prev(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 54U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_next(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 57U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp = choices_get(& choices, (size_t )0);
    tmp___0 = strcmp(tmp, "tags");
    if (tmp___0) {
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 59U;
        greatest_info.msg = "!strcmp(choices_get(&choices, 0), \"tags\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___1 = choices_get(& choices, (size_t )1);
    if ((unsigned long )((void *)0) != (unsigned long )tmp___1) {
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 60U;
        greatest_info.msg = "NULL != choices_get(&choices, 1)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res test_choices_2(void) 
{ 
  greatest_type_info *type_info ;
  char const   *tmp ;
  int tmp___0 ;
  greatest_type_info *type_info___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  greatest_type_info *type_info___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  choices_add(& choices, "tags");
  choices_add(& choices, "test");
  choices_search(& choices, "");
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 71U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (2UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )2);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 72U;
        greatest_info.msg = "(size_t)(2) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_next(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 75U;
        greatest_info.msg = "(size_t)(1) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_next(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 77U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_prev(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 80U;
        greatest_info.msg = "(size_t)(1) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_prev(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 82U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_search(& choices, "te");
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 86U;
        greatest_info.msg = "(size_t)(1) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 87U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    while (1) {
      type_info = & greatest_type_info_string;
      (greatest_info.assertions) ++;
      tmp = choices_get(& choices, (size_t )0);
      tmp___0 = greatest_do_assert_equal_t((void const   *)"test", (void const   *)tmp,
                                           type_info, (void *)0);
      if (! tmp___0) {
        if ((unsigned long )type_info == (unsigned long )((void *)0)) {
          goto _L;
        } else
        if ((unsigned long )type_info->equal == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 88U;
            greatest_info.msg = "type_info->equal callback missing!";
            return ((enum greatest_test_res )-1);
            break;
          }
        } else {
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 88U;
            greatest_info.msg = "\"test\" != choices_get(&choices, 0)";
            return ((enum greatest_test_res )-1);
            break;
          }
        }
      }
      break;
    }
    break;
  }
  choices_next(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 91U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_prev(& choices);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 94U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_search(& choices, "foobar");
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 98U;
        greatest_info.msg = "(size_t)(0) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 99U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_search(& choices, "ts");
  while (1) {
    (greatest_info.assertions) ++;
    if (2UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )2);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 103U;
        greatest_info.msg = "(size_t)(2) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 104U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    while (1) {
      type_info___0 = & greatest_type_info_string;
      (greatest_info.assertions) ++;
      tmp___1 = choices_get(& choices, (size_t )0);
      tmp___2 = greatest_do_assert_equal_t((void const   *)"test", (void const   *)tmp___1,
                                           type_info___0, (void *)0);
      if (! tmp___2) {
        if ((unsigned long )type_info___0 == (unsigned long )((void *)0)) {
          goto _L___0;
        } else
        if ((unsigned long )type_info___0->equal == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 105U;
            greatest_info.msg = "type_info->equal callback missing!";
            return ((enum greatest_test_res )-1);
            break;
          }
        } else {
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 105U;
            greatest_info.msg = "\"test\" != choices_get(&choices, 0)";
            return ((enum greatest_test_res )-1);
            break;
          }
        }
      }
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      type_info___1 = & greatest_type_info_string;
      (greatest_info.assertions) ++;
      tmp___3 = choices_get(& choices, (size_t )1);
      tmp___4 = greatest_do_assert_equal_t((void const   *)"tags", (void const   *)tmp___3,
                                           type_info___1, (void *)0);
      if (! tmp___4) {
        if ((unsigned long )type_info___1 == (unsigned long )((void *)0)) {
          goto _L___1;
        } else
        if ((unsigned long )type_info___1->equal == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 106U;
            greatest_info.msg = "type_info->equal callback missing!";
            return ((enum greatest_test_res )-1);
            break;
          }
        } else {
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 106U;
            greatest_info.msg = "\"tags\" != choices_get(&choices, 1)";
            return ((enum greatest_test_res )-1);
            break;
          }
        }
      }
      break;
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res test_choices_without_search(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 114U;
        greatest_info.msg = "(size_t)(0) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 115U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.size) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.size);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 116U;
        greatest_info.msg = "(size_t)(0) != (choices.size)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp = choices_get(& choices, (size_t )0);
    if ((unsigned long )((void *)0) != (unsigned long )tmp) {
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 117U;
        greatest_info.msg = "NULL != choices_get(&choices, 0)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  choices_add(& choices, "test");
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 121U;
        greatest_info.msg = "(size_t)(0) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != choices.selection) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.selection);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 122U;
        greatest_info.msg = "(size_t)(0) != (choices.selection)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != choices.size) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.size);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 123U;
        greatest_info.msg = "(size_t)(1) != (choices.size)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___0 = choices_get(& choices, (size_t )0);
    if ((unsigned long )((void *)0) != (unsigned long )tmp___0) {
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 124U;
        greatest_info.msg = "NULL != choices_get(&choices, 0)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res test_choices_unicode(void) 
{ 


  {
  choices_add(& choices, "Edmund Husserl - M\303\251ditations cart\303\251siennes - Introduction a la ph\303\251nom\303\251nologie.pdf");
  choices_search(& choices, "e");
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res test_choices_large_input(void) 
{ 
  int N ;
  char *strings[100000] ;
  int i ;
  greatest_type_info *type_info ;
  char const   *tmp ;
  int tmp___0 ;
  int i___0 ;

  {
  N = 100000;
  i = 0;
  while (i < N) {
    asprintf((char ** __restrict  )(& strings[i]), (char const   * __restrict  )"%i",
             i);
    choices_add(& choices, (char const   *)strings[i]);
    i ++;
  }
  choices_search(& choices, "12");
  while (1) {
    (greatest_info.assertions) ++;
    if (8146UL != choices.available) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )8146);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", choices.available);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_choices.c";
        greatest_info.fail_line = 149U;
        greatest_info.msg = "(size_t)(8146) != (choices.available)";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    while (1) {
      type_info = & greatest_type_info_string;
      (greatest_info.assertions) ++;
      tmp = choices_get(& choices, (size_t )0);
      tmp___0 = greatest_do_assert_equal_t((void const   *)"12", (void const   *)tmp,
                                           type_info, (void *)0);
      if (! tmp___0) {
        if ((unsigned long )type_info == (unsigned long )((void *)0)) {
          goto _L;
        } else
        if ((unsigned long )type_info->equal == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 151U;
            greatest_info.msg = "type_info->equal callback missing!";
            return ((enum greatest_test_res )-1);
            break;
          }
        } else {
          while (1) {
            greatest_info.fail_file = "test/test_choices.c";
            greatest_info.fail_line = 151U;
            greatest_info.msg = "\"12\" != choices_get(&choices, 0)";
            return ((enum greatest_test_res )-1);
            break;
          }
        }
      }
      break;
    }
    break;
  }
  i___0 = 0;
  while (i___0 < N) {
    free((void *)strings[i___0]);
    i___0 ++;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
void choices_suite(void) 
{ 
  enum greatest_test_res res ;
  int tmp ;
  int tmp___0 ;
  enum greatest_test_res res___0 ;
  int tmp___1 ;
  int tmp___2 ;
  enum greatest_test_res res___1 ;
  int tmp___3 ;
  int tmp___4 ;
  enum greatest_test_res res___2 ;
  int tmp___5 ;
  int tmp___6 ;
  enum greatest_test_res res___3 ;
  int tmp___7 ;
  int tmp___8 ;
  enum greatest_test_res res___4 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  GREATEST_SET_SETUP_CB(& setup, (void *)0);
  GREATEST_SET_TEARDOWN_CB(& teardown, (void *)0);
  while (1) {
    tmp___0 = greatest_test_pre("test_choices_empty");
    if (tmp___0 == 1) {
      tmp = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res = (enum greatest_test_res )tmp;
      if ((int )res == 0) {
        res = test_choices_empty();
      }
      greatest_test_post("test_choices_empty", (int )res);
    }
    break;
  }
  while (1) {
    tmp___2 = greatest_test_pre("test_choices_1");
    if (tmp___2 == 1) {
      tmp___1 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___0 = (enum greatest_test_res )tmp___1;
      if ((int )res___0 == 0) {
        res___0 = test_choices_1();
      }
      greatest_test_post("test_choices_1", (int )res___0);
    }
    break;
  }
  while (1) {
    tmp___4 = greatest_test_pre("test_choices_2");
    if (tmp___4 == 1) {
      tmp___3 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___1 = (enum greatest_test_res )tmp___3;
      if ((int )res___1 == 0) {
        res___1 = test_choices_2();
      }
      greatest_test_post("test_choices_2", (int )res___1);
    }
    break;
  }
  while (1) {
    tmp___6 = greatest_test_pre("test_choices_without_search");
    if (tmp___6 == 1) {
      tmp___5 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___2 = (enum greatest_test_res )tmp___5;
      if ((int )res___2 == 0) {
        res___2 = test_choices_without_search();
      }
      greatest_test_post("test_choices_without_search", (int )res___2);
    }
    break;
  }
  while (1) {
    tmp___8 = greatest_test_pre("test_choices_unicode");
    if (tmp___8 == 1) {
      tmp___7 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___3 = (enum greatest_test_res )tmp___7;
      if ((int )res___3 == 0) {
        res___3 = test_choices_unicode();
      }
      greatest_test_post("test_choices_unicode", (int )res___3);
    }
    break;
  }
  while (1) {
    tmp___10 = greatest_test_pre("test_choices_large_input");
    if (tmp___10 == 1) {
      tmp___9 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___4 = (enum greatest_test_res )tmp___9;
      if ((int )res___4 == 0) {
        res___4 = test_choices_large_input();
      }
      greatest_test_post("test_choices_large_input", (int )res___4);
    }
    break;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-bnf4MuRL.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
static enum greatest_test_res exact_match_should_return_true(void) 
{ 
  int tmp ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = has_match("a", "a");
    if (! tmp) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 14U;
        greatest_info.msg = "has_match(\"a\", \"a\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res partial_match_should_return_true(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = has_match("a", "ab");
    if (! tmp) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 19U;
        greatest_info.msg = "has_match(\"a\", \"ab\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___0 = has_match("a", "ba");
    if (! tmp___0) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 20U;
        greatest_info.msg = "has_match(\"a\", \"ba\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res match_with_delimiters_in_between(void) 
{ 
  int tmp ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = has_match("abc", "a|b|c");
    if (! tmp) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 25U;
        greatest_info.msg = "has_match(\"abc\", \"a|b|c\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res non_match_should_return_false(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = has_match("a", "");
    if (tmp) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 30U;
        greatest_info.msg = "!has_match(\"a\", \"\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___0 = has_match("a", "b");
    if (tmp___0) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 31U;
        greatest_info.msg = "!has_match(\"a\", \"b\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___1 = has_match("ass", "tags");
    if (tmp___1) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 32U;
        greatest_info.msg = "!has_match(\"ass\", \"tags\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res empty_query_should_always_match(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = has_match("", "");
    if (! tmp) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 38U;
        greatest_info.msg = "has_match(\"\", \"\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___0 = has_match("", "a");
    if (! tmp___0) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 39U;
        greatest_info.msg = "has_match(\"\", \"a\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res should_prefer_starts_of_words(void) 
{ 
  score_t tmp ;
  score_t tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = match("amor", "app/models/order");
    tmp___0 = match("amor", "app/models/zrder");
    if (! (tmp > tmp___0)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 47U;
        greatest_info.msg = "match(\"amor\", \"app/models/order\") > match(\"amor\", \"app/models/zrder\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res should_prefer_consecutive_letters(void) 
{ 
  score_t tmp ;
  score_t tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = match("amo", "app/m/foo");
    tmp___0 = match("amo", "app/models/foo");
    if (! (tmp < tmp___0)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 53U;
        greatest_info.msg = "match(\"amo\", \"app/m/foo\") < match(\"amo\", \"app/models/foo\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res should_prefer_contiguous_over_letter_following_period(void) 
{ 
  score_t tmp ;
  score_t tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = match("gemfil", "Gemfile.lock");
    tmp___0 = match("gemfil", "Gemfile");
    if (! (tmp < tmp___0)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 59U;
        greatest_info.msg = "match(\"gemfil\", \"Gemfile.lock\") < match(\"gemfil\", \"Gemfile\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res should_prefer_shorter_matches(void) 
{ 
  score_t tmp ;
  score_t tmp___0 ;
  score_t tmp___1 ;
  score_t tmp___2 ;
  score_t tmp___3 ;
  score_t tmp___4 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = match("abce", "abcdef");
    tmp___0 = match("abce", "abc de");
    if (! (tmp > tmp___0)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 64U;
        greatest_info.msg = "match(\"abce\", \"abcdef\") > match(\"abce\", \"abc de\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___1 = match("abc", "    a b c ");
    tmp___2 = match("abc", " a  b  c ");
    if (! (tmp___1 > tmp___2)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 65U;
        greatest_info.msg = "match(\"abc\", \"    a b c \") > match(\"abc\", \" a  b  c \")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    tmp___3 = match("abc", " a b c    ");
    tmp___4 = match("abc", " a  b  c ");
    if (! (tmp___3 > tmp___4)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 66U;
        greatest_info.msg = "match(\"abc\", \" a b c    \") > match(\"abc\", \" a  b  c \")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res should_prefer_shorter_candidates(void) 
{ 
  score_t tmp ;
  score_t tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = match("test", "tests");
    tmp___0 = match("test", "testing");
    if (! (tmp > tmp___0)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 71U;
        greatest_info.msg = "match(\"test\", \"tests\") > match(\"test\", \"testing\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res should_prefer_start_of_candidate(void) 
{ 
  score_t tmp ;
  score_t tmp___0 ;

  {
  while (1) {
    (greatest_info.assertions) ++;
    tmp = match("test", "testing");
    tmp___0 = match("test", "/testing");
    if (! (tmp > tmp___0)) {
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 77U;
        greatest_info.msg = "match(\"test\", \"testing\") > match(\"test\", \"/testing\")";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_exact_match(void) 
{ 
  double greatest_EXP ;
  float tmp ;
  double greatest_GOT ;
  score_t tmp___0 ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  float tmp___1 ;
  double greatest_GOT___0 ;
  score_t tmp___2 ;
  double greatest_TOL___0 ;

  {
  while (1) {
    tmp = __builtin_inff();
    greatest_EXP = (double )tmp;
    tmp___0 = match("abc", "abc");
    greatest_GOT = tmp___0;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 83U;
          greatest_info.msg = "((__builtin_inff ())) != (match(\"abc\", \"abc\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    tmp___1 = __builtin_inff();
    greatest_EXP___0 = (double )tmp___1;
    tmp___2 = match("aBc", "abC");
    greatest_GOT___0 = tmp___2;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 84U;
          greatest_info.msg = "((__builtin_inff ())) != (match(\"aBc\", \"abC\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_empty_query(void) 
{ 
  double greatest_EXP ;
  float tmp ;
  double greatest_GOT ;
  score_t tmp___0 ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  float tmp___1 ;
  double greatest_GOT___0 ;
  score_t tmp___2 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  float tmp___3 ;
  double greatest_GOT___1 ;
  score_t tmp___4 ;
  double greatest_TOL___1 ;

  {
  while (1) {
    tmp = __builtin_inff();
    greatest_EXP = (double )(- tmp);
    tmp___0 = match("", "");
    greatest_GOT = tmp___0;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 90U;
          greatest_info.msg = "(-(__builtin_inff ())) != (match(\"\", \"\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    tmp___1 = __builtin_inff();
    greatest_EXP___0 = (double )(- tmp___1);
    tmp___2 = match("", "a");
    greatest_GOT___0 = tmp___2;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 91U;
          greatest_info.msg = "(-(__builtin_inff ())) != (match(\"\", \"a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    tmp___3 = __builtin_inff();
    greatest_EXP___1 = (double )(- tmp___3);
    tmp___4 = match("", "bb");
    greatest_GOT___1 = tmp___4;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 92U;
          greatest_info.msg = "(-(__builtin_inff ())) != (match(\"\", \"bb\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_gaps(void) 
{ 
  double greatest_EXP ;
  double greatest_GOT ;
  score_t tmp ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  double greatest_GOT___0 ;
  score_t tmp___0 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  double greatest_GOT___1 ;
  score_t tmp___1 ;
  double greatest_TOL___1 ;
  double greatest_EXP___2 ;
  double greatest_GOT___2 ;
  score_t tmp___2 ;
  double greatest_TOL___2 ;
  double greatest_EXP___3 ;
  double greatest_GOT___3 ;
  score_t tmp___3 ;
  double greatest_TOL___3 ;
  double greatest_EXP___4 ;
  double greatest_GOT___4 ;
  score_t tmp___4 ;
  double greatest_TOL___4 ;

  {
  while (1) {
    greatest_EXP = - 0.005;
    tmp = match("a", "*a");
    greatest_GOT = tmp;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 97U;
          greatest_info.msg = "(-0.005) != (match(\"a\", \"*a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___0 = - 0.005 * (double )2;
    tmp___0 = match("a", "*ba");
    greatest_GOT___0 = tmp___0;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 98U;
          greatest_info.msg = "(-0.005*2) != (match(\"a\", \"*ba\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___1 = - 0.005 * (double )2 + - 0.005;
    tmp___1 = match("a", "**a*");
    greatest_GOT___1 = tmp___1;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 99U;
          greatest_info.msg = "(-0.005*2 + -0.005) != (match(\"a\", \"**a*\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___2 = - 0.005 * (double )2 + - 0.005 * (double )2;
    tmp___2 = match("a", "**a**");
    greatest_GOT___2 = tmp___2;
    greatest_TOL___2 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___2 > greatest_GOT___2) {
      if (greatest_EXP___2 - greatest_GOT___2 > greatest_TOL___2) {
        goto _L___5;
      } else {
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
    if (greatest_EXP___2 < greatest_GOT___2) {
      if (greatest_GOT___2 - greatest_EXP___2 > greatest_TOL___2) {
        _L___5: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___2, greatest_TOL___2, greatest_GOT___2);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 100U;
          greatest_info.msg = "(-0.005*2 + -0.005*2) != (match(\"a\", \"**a**\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___3 = (- 0.005 * (double )2 + 1.0) + - 0.005 * (double )2;
    tmp___3 = match("aa", "**aa**");
    greatest_GOT___3 = tmp___3;
    greatest_TOL___3 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___3 > greatest_GOT___3) {
      if (greatest_EXP___3 - greatest_GOT___3 > greatest_TOL___3) {
        goto _L___7;
      } else {
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
    if (greatest_EXP___3 < greatest_GOT___3) {
      if (greatest_GOT___3 - greatest_EXP___3 > greatest_TOL___3) {
        _L___7: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___3, greatest_TOL___3, greatest_GOT___3);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 101U;
          greatest_info.msg = "(-0.005*2 + 1.0 + -0.005*2) != (match(\"aa\", \"**aa**\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___4 = (((- 0.005 + - 0.005) + - 0.01) + - 0.005) + - 0.005;
    tmp___4 = match("aa", "**a*a**");
    greatest_GOT___4 = tmp___4;
    greatest_TOL___4 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___4 > greatest_GOT___4) {
      if (greatest_EXP___4 - greatest_GOT___4 > greatest_TOL___4) {
        goto _L___9;
      } else {
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
    if (greatest_EXP___4 < greatest_GOT___4) {
      if (greatest_GOT___4 - greatest_EXP___4 > greatest_TOL___4) {
        _L___9: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___4, greatest_TOL___4, greatest_GOT___4);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 102U;
          greatest_info.msg = "(-0.005 + -0.005 + -0.01 + -0.005 + -0.005) != (match(\"aa\", \"**a*a**\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_consecutive(void) 
{ 
  double greatest_EXP ;
  double greatest_GOT ;
  score_t tmp ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  double greatest_GOT___0 ;
  score_t tmp___0 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  double greatest_GOT___1 ;
  score_t tmp___1 ;
  double greatest_TOL___1 ;

  {
  while (1) {
    greatest_EXP = - 0.005 + 1.0;
    tmp = match("aa", "*aa");
    greatest_GOT = tmp;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 107U;
          greatest_info.msg = "(-0.005 + 1.0) != (match(\"aa\", \"*aa\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___0 = - 0.005 + 1.0 * (double )2;
    tmp___0 = match("aaa", "*aaa");
    greatest_GOT___0 = tmp___0;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 108U;
          greatest_info.msg = "(-0.005 + 1.0*2) != (match(\"aaa\", \"*aaa\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___1 = (- 0.005 + - 0.01) + 1.0;
    tmp___1 = match("aaa", "*a*aa");
    greatest_GOT___1 = tmp___1;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 109U;
          greatest_info.msg = "(-0.005 + -0.01 + 1.0) != (match(\"aaa\", \"*a*aa\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_slash(void) 
{ 
  double greatest_EXP ;
  double greatest_GOT ;
  score_t tmp ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  double greatest_GOT___0 ;
  score_t tmp___0 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  double greatest_GOT___1 ;
  score_t tmp___1 ;
  double greatest_TOL___1 ;

  {
  while (1) {
    greatest_EXP = - 0.005 + 0.9;
    tmp = match("a", "/a");
    greatest_GOT = tmp;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 114U;
          greatest_info.msg = "(-0.005 + 0.9) != (match(\"a\", \"/a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___0 = - 0.005 * (double )2 + 0.9;
    tmp___0 = match("a", "*/a");
    greatest_GOT___0 = tmp___0;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 115U;
          greatest_info.msg = "(-0.005*2 + 0.9) != (match(\"a\", \"*/a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___1 = (- 0.005 * (double )2 + 0.9) + 1.0;
    tmp___1 = match("aa", "a/aa");
    greatest_GOT___1 = tmp___1;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 116U;
          greatest_info.msg = "(-0.005*2 + 0.9 + 1.0) != (match(\"aa\", \"a/aa\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_capital(void) 
{ 
  double greatest_EXP ;
  double greatest_GOT ;
  score_t tmp ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  double greatest_GOT___0 ;
  score_t tmp___0 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  double greatest_GOT___1 ;
  score_t tmp___1 ;
  double greatest_TOL___1 ;

  {
  while (1) {
    greatest_EXP = - 0.005 + 0.7;
    tmp = match("a", "bA");
    greatest_GOT = tmp;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 121U;
          greatest_info.msg = "(-0.005 + 0.7) != (match(\"a\", \"bA\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___0 = - 0.005 * (double )2 + 0.7;
    tmp___0 = match("a", "baA");
    greatest_GOT___0 = tmp___0;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 122U;
          greatest_info.msg = "(-0.005*2 + 0.7) != (match(\"a\", \"baA\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___1 = (- 0.005 * (double )2 + 0.7) + 1.0;
    tmp___1 = match("aa", "baAa");
    greatest_GOT___1 = tmp___1;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 123U;
          greatest_info.msg = "(-0.005*2 + 0.7 + 1.0) != (match(\"aa\", \"baAa\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_dot(void) 
{ 
  double greatest_EXP ;
  double greatest_GOT ;
  score_t tmp ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  double greatest_GOT___0 ;
  score_t tmp___0 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  double greatest_GOT___1 ;
  score_t tmp___1 ;
  double greatest_TOL___1 ;

  {
  while (1) {
    greatest_EXP = - 0.005 + 0.6;
    tmp = match("a", ".a");
    greatest_GOT = tmp;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 128U;
          greatest_info.msg = "(-0.005 + 0.6) != (match(\"a\", \".a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___0 = - 0.005 * (double )3 + 0.6;
    tmp___0 = match("a", "*a.a");
    greatest_GOT___0 = tmp___0;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 129U;
          greatest_info.msg = "(-0.005*3 + 0.6) != (match(\"a\", \"*a.a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_EXP___1 = (- 0.005 + - 0.01) + 0.6;
    tmp___1 = match("a", "*a.a");
    greatest_GOT___1 = tmp___1;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 130U;
          greatest_info.msg = "(-0.005 + -0.01 + 0.6) != (match(\"a\", \"*a.a\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res score_long_string(void) 
{ 
  char string[4096] ;
  double greatest_EXP ;
  float tmp ;
  double greatest_GOT ;
  score_t tmp___0 ;
  double greatest_TOL ;
  double greatest_EXP___0 ;
  float tmp___1 ;
  double greatest_GOT___0 ;
  score_t tmp___2 ;
  double greatest_TOL___0 ;
  double greatest_EXP___1 ;
  float tmp___3 ;
  double greatest_GOT___1 ;
  score_t tmp___4 ;
  double greatest_TOL___1 ;

  {
  memset((void *)(string), 'a', sizeof(string) - 1UL);
  string[sizeof(string) - 1UL] = (char )'\000';
  while (1) {
    tmp = __builtin_inff();
    greatest_EXP = (double )(- tmp);
    tmp___0 = match("aa", (char const   *)(string));
    greatest_GOT = tmp___0;
    greatest_TOL = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP > greatest_GOT) {
      if (greatest_EXP - greatest_GOT > greatest_TOL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (greatest_EXP < greatest_GOT) {
      if (greatest_GOT - greatest_EXP > greatest_TOL) {
        _L: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP, greatest_TOL, greatest_GOT);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 139U;
          greatest_info.msg = "(-(__builtin_inff ())) != (match(\"aa\", string)) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    tmp___1 = __builtin_inff();
    greatest_EXP___0 = (double )(- tmp___1);
    tmp___2 = match((char const   *)(string), "aa");
    greatest_GOT___0 = tmp___2;
    greatest_TOL___0 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___0 > greatest_GOT___0) {
      if (greatest_EXP___0 - greatest_GOT___0 > greatest_TOL___0) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (greatest_EXP___0 < greatest_GOT___0) {
      if (greatest_GOT___0 - greatest_EXP___0 > greatest_TOL___0) {
        _L___1: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___0, greatest_TOL___0, greatest_GOT___0);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 140U;
          greatest_info.msg = "(-(__builtin_inff ())) != (match(string, \"aa\")) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    tmp___3 = __builtin_inff();
    greatest_EXP___1 = (double )(- tmp___3);
    tmp___4 = match((char const   *)(string), (char const   *)(string));
    greatest_GOT___1 = tmp___4;
    greatest_TOL___1 = 0.000001;
    (greatest_info.assertions) ++;
    if (greatest_EXP___1 > greatest_GOT___1) {
      if (greatest_EXP___1 - greatest_GOT___1 > greatest_TOL___1) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (greatest_EXP___1 < greatest_GOT___1) {
      if (greatest_GOT___1 - greatest_EXP___1 > greatest_TOL___1) {
        _L___3: /* CIL Label */ 
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: %g +/- %g\n     Got: %g\n",
                greatest_EXP___1, greatest_TOL___1, greatest_GOT___1);
        while (1) {
          greatest_info.fail_file = "test/test_match.c";
          greatest_info.fail_line = 141U;
          greatest_info.msg = "(-(__builtin_inff ())) != (match(string, string)) +/- SCORE_TOLERANCE";
          return ((enum greatest_test_res )-1);
          break;
        }
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res positions_consecutive(void) 
{ 
  size_t positions[3] ;

  {
  match_positions("amo", "app/models/foo", positions);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != positions[0]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[0]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 149U;
        greatest_info.msg = "(size_t)(0) != (positions[0])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (4UL != positions[1]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )4);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[1]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 150U;
        greatest_info.msg = "(size_t)(4) != (positions[1])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (5UL != positions[2]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )5);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[2]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 151U;
        greatest_info.msg = "(size_t)(5) != (positions[2])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res positions_start_of_word(void) 
{ 
  size_t positions[4] ;

  {
  match_positions("amor", "app/models/order", positions);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != positions[0]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[0]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 163U;
        greatest_info.msg = "(size_t)(0) != (positions[0])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (4UL != positions[1]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )4);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[1]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 164U;
        greatest_info.msg = "(size_t)(4) != (positions[1])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (11UL != positions[2]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )11);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[2]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 165U;
        greatest_info.msg = "(size_t)(11) != (positions[2])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (12UL != positions[3]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )12);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[3]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 166U;
        greatest_info.msg = "(size_t)(12) != (positions[3])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res positions_no_bonuses(void) 
{ 
  size_t positions[2] ;

  {
  match_positions("as", "tags", positions);
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != positions[0]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[0]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 174U;
        greatest_info.msg = "(size_t)(1) != (positions[0])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (3UL != positions[1]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )3);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[1]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 175U;
        greatest_info.msg = "(size_t)(3) != (positions[1])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  match_positions("as", "examples.txt", positions);
  while (1) {
    (greatest_info.assertions) ++;
    if (2UL != positions[0]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )2);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[0]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 178U;
        greatest_info.msg = "(size_t)(2) != (positions[0])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (7UL != positions[1]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )7);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[1]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 179U;
        greatest_info.msg = "(size_t)(7) != (positions[1])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res positions_multiple_candidates_start_of_words(void) 
{ 
  size_t positions[3] ;

  {
  match_positions("abc", "a/a/b/c/c", positions);
  while (1) {
    (greatest_info.assertions) ++;
    if (2UL != positions[0]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )2);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[0]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 187U;
        greatest_info.msg = "(size_t)(2) != (positions[0])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (4UL != positions[1]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )4);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[1]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 188U;
        greatest_info.msg = "(size_t)(4) != (positions[1])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (6UL != positions[2]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )6);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[2]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 189U;
        greatest_info.msg = "(size_t)(6) != (positions[2])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
static enum greatest_test_res positions_exact_match(void) 
{ 
  size_t positions[3] ;

  {
  match_positions("foo", "foo", positions);
  while (1) {
    (greatest_info.assertions) ++;
    if (0UL != positions[0]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )0);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[0]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 197U;
        greatest_info.msg = "(size_t)(0) != (positions[0])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (1UL != positions[1]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )1);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[1]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 198U;
        greatest_info.msg = "(size_t)(1) != (positions[1])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    (greatest_info.assertions) ++;
    if (2UL != positions[2]) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\nExpected: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", (size_t )2);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n     Got: ");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%zu", positions[2]);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      while (1) {
        greatest_info.fail_file = "test/test_match.c";
        greatest_info.fail_line = 199U;
        greatest_info.msg = "(size_t)(2) != (positions[2])";
        return ((enum greatest_test_res )-1);
        break;
      }
    }
    break;
  }
  while (1) {
    greatest_info.msg = (char const   *)((void *)0);
    return ((enum greatest_test_res )0);
    break;
  }
  return ((enum greatest_test_res )0);
}
}
void match_suite(void) 
{ 
  enum greatest_test_res res ;
  int tmp ;
  int tmp___0 ;
  enum greatest_test_res res___0 ;
  int tmp___1 ;
  int tmp___2 ;
  enum greatest_test_res res___1 ;
  int tmp___3 ;
  int tmp___4 ;
  enum greatest_test_res res___2 ;
  int tmp___5 ;
  int tmp___6 ;
  enum greatest_test_res res___3 ;
  int tmp___7 ;
  int tmp___8 ;
  enum greatest_test_res res___4 ;
  int tmp___9 ;
  int tmp___10 ;
  enum greatest_test_res res___5 ;
  int tmp___11 ;
  int tmp___12 ;
  enum greatest_test_res res___6 ;
  int tmp___13 ;
  int tmp___14 ;
  enum greatest_test_res res___7 ;
  int tmp___15 ;
  int tmp___16 ;
  enum greatest_test_res res___8 ;
  int tmp___17 ;
  int tmp___18 ;
  enum greatest_test_res res___9 ;
  int tmp___19 ;
  int tmp___20 ;
  enum greatest_test_res res___10 ;
  int tmp___21 ;
  int tmp___22 ;
  enum greatest_test_res res___11 ;
  int tmp___23 ;
  int tmp___24 ;
  enum greatest_test_res res___12 ;
  int tmp___25 ;
  int tmp___26 ;
  enum greatest_test_res res___13 ;
  int tmp___27 ;
  int tmp___28 ;
  enum greatest_test_res res___14 ;
  int tmp___29 ;
  int tmp___30 ;
  enum greatest_test_res res___15 ;
  int tmp___31 ;
  int tmp___32 ;
  enum greatest_test_res res___16 ;
  int tmp___33 ;
  int tmp___34 ;
  enum greatest_test_res res___17 ;
  int tmp___35 ;
  int tmp___36 ;
  enum greatest_test_res res___18 ;
  int tmp___37 ;
  int tmp___38 ;
  enum greatest_test_res res___19 ;
  int tmp___39 ;
  int tmp___40 ;
  enum greatest_test_res res___20 ;
  int tmp___41 ;
  int tmp___42 ;
  enum greatest_test_res res___21 ;
  int tmp___43 ;
  int tmp___44 ;
  enum greatest_test_res res___22 ;
  int tmp___45 ;
  int tmp___46 ;

  {
  while (1) {
    tmp___0 = greatest_test_pre("exact_match_should_return_true");
    if (tmp___0 == 1) {
      tmp = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res = (enum greatest_test_res )tmp;
      if ((int )res == 0) {
        res = exact_match_should_return_true();
      }
      greatest_test_post("exact_match_should_return_true", (int )res);
    }
    break;
  }
  while (1) {
    tmp___2 = greatest_test_pre("partial_match_should_return_true");
    if (tmp___2 == 1) {
      tmp___1 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___0 = (enum greatest_test_res )tmp___1;
      if ((int )res___0 == 0) {
        res___0 = partial_match_should_return_true();
      }
      greatest_test_post("partial_match_should_return_true", (int )res___0);
    }
    break;
  }
  while (1) {
    tmp___4 = greatest_test_pre("empty_query_should_always_match");
    if (tmp___4 == 1) {
      tmp___3 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___1 = (enum greatest_test_res )tmp___3;
      if ((int )res___1 == 0) {
        res___1 = empty_query_should_always_match();
      }
      greatest_test_post("empty_query_should_always_match", (int )res___1);
    }
    break;
  }
  while (1) {
    tmp___6 = greatest_test_pre("non_match_should_return_false");
    if (tmp___6 == 1) {
      tmp___5 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___2 = (enum greatest_test_res )tmp___5;
      if ((int )res___2 == 0) {
        res___2 = non_match_should_return_false();
      }
      greatest_test_post("non_match_should_return_false", (int )res___2);
    }
    break;
  }
  while (1) {
    tmp___8 = greatest_test_pre("match_with_delimiters_in_between");
    if (tmp___8 == 1) {
      tmp___7 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___3 = (enum greatest_test_res )tmp___7;
      if ((int )res___3 == 0) {
        res___3 = match_with_delimiters_in_between();
      }
      greatest_test_post("match_with_delimiters_in_between", (int )res___3);
    }
    break;
  }
  while (1) {
    tmp___10 = greatest_test_pre("should_prefer_starts_of_words");
    if (tmp___10 == 1) {
      tmp___9 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___4 = (enum greatest_test_res )tmp___9;
      if ((int )res___4 == 0) {
        res___4 = should_prefer_starts_of_words();
      }
      greatest_test_post("should_prefer_starts_of_words", (int )res___4);
    }
    break;
  }
  while (1) {
    tmp___12 = greatest_test_pre("should_prefer_consecutive_letters");
    if (tmp___12 == 1) {
      tmp___11 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___5 = (enum greatest_test_res )tmp___11;
      if ((int )res___5 == 0) {
        res___5 = should_prefer_consecutive_letters();
      }
      greatest_test_post("should_prefer_consecutive_letters", (int )res___5);
    }
    break;
  }
  while (1) {
    tmp___14 = greatest_test_pre("should_prefer_contiguous_over_letter_following_period");
    if (tmp___14 == 1) {
      tmp___13 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___6 = (enum greatest_test_res )tmp___13;
      if ((int )res___6 == 0) {
        res___6 = should_prefer_contiguous_over_letter_following_period();
      }
      greatest_test_post("should_prefer_contiguous_over_letter_following_period",
                         (int )res___6);
    }
    break;
  }
  while (1) {
    tmp___16 = greatest_test_pre("should_prefer_shorter_matches");
    if (tmp___16 == 1) {
      tmp___15 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___7 = (enum greatest_test_res )tmp___15;
      if ((int )res___7 == 0) {
        res___7 = should_prefer_shorter_matches();
      }
      greatest_test_post("should_prefer_shorter_matches", (int )res___7);
    }
    break;
  }
  while (1) {
    tmp___18 = greatest_test_pre("should_prefer_shorter_candidates");
    if (tmp___18 == 1) {
      tmp___17 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___8 = (enum greatest_test_res )tmp___17;
      if ((int )res___8 == 0) {
        res___8 = should_prefer_shorter_candidates();
      }
      greatest_test_post("should_prefer_shorter_candidates", (int )res___8);
    }
    break;
  }
  while (1) {
    tmp___20 = greatest_test_pre("should_prefer_start_of_candidate");
    if (tmp___20 == 1) {
      tmp___19 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___9 = (enum greatest_test_res )tmp___19;
      if ((int )res___9 == 0) {
        res___9 = should_prefer_start_of_candidate();
      }
      greatest_test_post("should_prefer_start_of_candidate", (int )res___9);
    }
    break;
  }
  while (1) {
    tmp___22 = greatest_test_pre("score_exact_match");
    if (tmp___22 == 1) {
      tmp___21 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___10 = (enum greatest_test_res )tmp___21;
      if ((int )res___10 == 0) {
        res___10 = score_exact_match();
      }
      greatest_test_post("score_exact_match", (int )res___10);
    }
    break;
  }
  while (1) {
    tmp___24 = greatest_test_pre("score_empty_query");
    if (tmp___24 == 1) {
      tmp___23 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___11 = (enum greatest_test_res )tmp___23;
      if ((int )res___11 == 0) {
        res___11 = score_empty_query();
      }
      greatest_test_post("score_empty_query", (int )res___11);
    }
    break;
  }
  while (1) {
    tmp___26 = greatest_test_pre("score_gaps");
    if (tmp___26 == 1) {
      tmp___25 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___12 = (enum greatest_test_res )tmp___25;
      if ((int )res___12 == 0) {
        res___12 = score_gaps();
      }
      greatest_test_post("score_gaps", (int )res___12);
    }
    break;
  }
  while (1) {
    tmp___28 = greatest_test_pre("score_consecutive");
    if (tmp___28 == 1) {
      tmp___27 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___13 = (enum greatest_test_res )tmp___27;
      if ((int )res___13 == 0) {
        res___13 = score_consecutive();
      }
      greatest_test_post("score_consecutive", (int )res___13);
    }
    break;
  }
  while (1) {
    tmp___30 = greatest_test_pre("score_slash");
    if (tmp___30 == 1) {
      tmp___29 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___14 = (enum greatest_test_res )tmp___29;
      if ((int )res___14 == 0) {
        res___14 = score_slash();
      }
      greatest_test_post("score_slash", (int )res___14);
    }
    break;
  }
  while (1) {
    tmp___32 = greatest_test_pre("score_capital");
    if (tmp___32 == 1) {
      tmp___31 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___15 = (enum greatest_test_res )tmp___31;
      if ((int )res___15 == 0) {
        res___15 = score_capital();
      }
      greatest_test_post("score_capital", (int )res___15);
    }
    break;
  }
  while (1) {
    tmp___34 = greatest_test_pre("score_dot");
    if (tmp___34 == 1) {
      tmp___33 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___16 = (enum greatest_test_res )tmp___33;
      if ((int )res___16 == 0) {
        res___16 = score_dot();
      }
      greatest_test_post("score_dot", (int )res___16);
    }
    break;
  }
  while (1) {
    tmp___36 = greatest_test_pre("score_long_string");
    if (tmp___36 == 1) {
      tmp___35 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___17 = (enum greatest_test_res )tmp___35;
      if ((int )res___17 == 0) {
        res___17 = score_long_string();
      }
      greatest_test_post("score_long_string", (int )res___17);
    }
    break;
  }
  while (1) {
    tmp___38 = greatest_test_pre("positions_consecutive");
    if (tmp___38 == 1) {
      tmp___37 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___18 = (enum greatest_test_res )tmp___37;
      if ((int )res___18 == 0) {
        res___18 = positions_consecutive();
      }
      greatest_test_post("positions_consecutive", (int )res___18);
    }
    break;
  }
  while (1) {
    tmp___40 = greatest_test_pre("positions_start_of_word");
    if (tmp___40 == 1) {
      tmp___39 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___19 = (enum greatest_test_res )tmp___39;
      if ((int )res___19 == 0) {
        res___19 = positions_start_of_word();
      }
      greatest_test_post("positions_start_of_word", (int )res___19);
    }
    break;
  }
  while (1) {
    tmp___42 = greatest_test_pre("positions_no_bonuses");
    if (tmp___42 == 1) {
      tmp___41 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___20 = (enum greatest_test_res )tmp___41;
      if ((int )res___20 == 0) {
        res___20 = positions_no_bonuses();
      }
      greatest_test_post("positions_no_bonuses", (int )res___20);
    }
    break;
  }
  while (1) {
    tmp___44 = greatest_test_pre("positions_multiple_candidates_start_of_words");
    if (tmp___44 == 1) {
      tmp___43 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___21 = (enum greatest_test_res )tmp___43;
      if ((int )res___21 == 0) {
        res___21 = positions_multiple_candidates_start_of_words();
      }
      greatest_test_post("positions_multiple_candidates_start_of_words", (int )res___21);
    }
    break;
  }
  while (1) {
    tmp___46 = greatest_test_pre("positions_exact_match");
    if (tmp___46 == 1) {
      tmp___45 = _setjmp((struct __jmp_buf_tag *)(greatest_info.jump_dest));
      res___22 = (enum greatest_test_res )tmp___45;
      if ((int )res___22 == 0) {
        res___22 = positions_exact_match();
      }
      greatest_test_post("positions_exact_match", (int )res___22);
    }
    break;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-DsaHKYUd.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
score_t const   bonus_states[3][256]  = { {        (score_t const   )0}, 
   {        0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            (score_t const   )0.8,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        (score_t const   )0.8,        (score_t const   )0.6,        (score_t const   )0.9, 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        (score_t const   )0.8}, 
   {        0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            (score_t const   )0.8,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        (score_t const   )0.8,        (score_t const   )0.6,        (score_t const   )0.9, 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        (score_t const   )0.8, 
            0.,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7}};
size_t const   bonus_index[256]  = 
  {      0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1};
char *strcasechr(char const   *s , char c ) 
{ 
  char accept[3] ;
  int __res ;
  __int32_t const   **tmp___0 ;
  char *tmp___1 ;

  {
  if (sizeof(c) > 1UL) {
    __res = toupper((int )c);
  } else {
    tmp___0 = __ctype_toupper_loc();
    __res = (int )*(*tmp___0 + (int )c);
  }
  accept[0] = c;
  accept[1] = (char )__res;
  accept[2] = (char)0;
  tmp___1 = strpbrk(s, (char const   *)(accept));
  return (tmp___1);
}
}
int has_match(char const   *needle , char const   *haystack ) 
{ 
  char nch ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  while (*needle) {
    tmp = needle;
    needle ++;
    nch = (char )*tmp;
    tmp___0 = strcasechr(haystack, nch);
    haystack = (char const   *)tmp___0;
    if (! haystack) {
      return (0);
    }
    haystack ++;
  }
  return (1);
}
}
static void precompute_bonus(char const   *haystack , score_t *match_bonus ) 
{ 
  char last_ch ;
  int i ;
  char ch ;

  {
  last_ch = (char )'/';
  i = 0;
  while (*(haystack + i)) {
    ch = (char )*(haystack + i);
    *(match_bonus + i) = (score_t )bonus_states[bonus_index[(unsigned char )ch]][(unsigned char )last_ch];
    last_ch = ch;
    i ++;
  }
  return;
}
}
static void setup_match_struct(struct match_struct *match___0 , char const   *needle ,
                               char const   *haystack ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int i ;
  int __res ;
  __int32_t const   **tmp___2 ;
  int i___0 ;
  int __res___0 ;
  __int32_t const   **tmp___4 ;

  {
  tmp = strlen(needle);
  match___0->needle_len = (int )tmp;
  tmp___0 = strlen(haystack);
  match___0->haystack_len = (int )tmp___0;
  if (match___0->haystack_len > 1024) {
    return;
  } else
  if (match___0->needle_len > match___0->haystack_len) {
    return;
  }
  i = 0;
  while (i < match___0->needle_len) {
    if (sizeof(*(needle + i)) > 1UL) {
      __res = tolower((int )*(needle + i));
    } else {
      tmp___2 = __ctype_tolower_loc();
      __res = (int )*(*tmp___2 + (int )*(needle + i));
    }
    match___0->lower_needle[i] = (char )__res;
    i ++;
  }
  i___0 = 0;
  while (i___0 < match___0->haystack_len) {
    if (sizeof(*(haystack + i___0)) > 1UL) {
      __res___0 = tolower((int )*(haystack + i___0));
    } else {
      tmp___4 = __ctype_tolower_loc();
      __res___0 = (int )*(*tmp___4 + (int )*(haystack + i___0));
    }
    match___0->lower_haystack[i___0] = (char )__res___0;
    i___0 ++;
  }
  precompute_bonus(haystack, match___0->match_bonus);
  return;
}
}
__inline static void match_row(struct match_struct  const  *match___0 , int row ,
                               score_t *curr_D , score_t *curr_M , score_t const   *last_D ,
                               score_t const   *last_M ) 
{ 
  int n ;
  int m ;
  int i ;
  char const   *lower_needle ;
  char const   *lower_haystack ;
  score_t const   *match_bonus ;
  score_t prev_score ;
  float tmp ;
  score_t gap_score ;
  double tmp___0 ;
  int j ;
  score_t score ;
  float tmp___1 ;
  float tmp___2 ;

  {
  n = (int )match___0->needle_len;
  m = (int )match___0->haystack_len;
  i = row;
  lower_needle = (char const   *)(match___0->lower_needle);
  lower_haystack = (char const   *)(match___0->lower_haystack);
  match_bonus = (score_t const   *)(match___0->match_bonus);
  tmp = __builtin_inff();
  prev_score = (score_t )(- tmp);
  if (i == n - 1) {
    tmp___0 = - 0.005;
  } else {
    tmp___0 = - 0.01;
  }
  gap_score = tmp___0;
  j = 0;
  while (j < m) {
    if ((int const   )*(lower_needle + i) == (int const   )*(lower_haystack + j)) {
      tmp___1 = __builtin_inff();
      score = (score_t )(- tmp___1);
      if (! i) {
        score = (double )j * - 0.005 + (double )*(match_bonus + j);
      } else
      if (j) {
        if (*(last_M + (j - 1)) + *(match_bonus + j) > *(last_D + (j - 1)) + (score_t const   )1.0) {
          score = (score_t )(*(last_M + (j - 1)) + *(match_bonus + j));
        } else {
          score = (score_t )(*(last_D + (j - 1)) + (score_t const   )1.0);
        }
      }
      *(curr_D + j) = score;
      if (score > prev_score + gap_score) {
        prev_score = score;
      } else {
        prev_score += gap_score;
      }
      *(curr_M + j) = prev_score;
    } else {
      tmp___2 = __builtin_inff();
      *(curr_D + j) = (score_t )(- tmp___2);
      prev_score += gap_score;
      *(curr_M + j) = prev_score;
    }
    j ++;
  }
  return;
}
}
score_t match(char const   *needle , char const   *haystack ) 
{ 
  float tmp ;
  struct match_struct match___0 ;
  int n ;
  int m ;
  float tmp___0 ;
  float tmp___1 ;
  score_t D[2][1024] ;
  score_t M[2][1024] ;
  score_t *last_D ;
  score_t *last_M ;
  score_t *curr_D ;
  score_t *curr_M ;
  int i ;
  score_t *SWAP ;
  score_t *SWAP___0 ;

  {
  if (! *needle) {
    tmp = __builtin_inff();
    return ((score_t )(- tmp));
  }
  setup_match_struct(& match___0, needle, haystack);
  n = match___0.needle_len;
  m = match___0.haystack_len;
  if (m > 1024) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n > m) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n == m) {
    tmp___1 = __builtin_inff();
    return ((score_t )tmp___1);
  }
  last_D = D[0];
  last_M = M[0];
  curr_D = D[1];
  curr_M = M[1];
  i = 0;
  while (i < n) {
    match_row((struct match_struct  const  *)(& match___0), i, curr_D, curr_M, (score_t const   *)last_D,
              (score_t const   *)last_M);
    while (1) {
      SWAP = curr_D;
      curr_D = last_D;
      last_D = SWAP;
      break;
    }
    while (1) {
      SWAP___0 = curr_M;
      curr_M = last_M;
      last_M = SWAP___0;
      break;
    }
    i ++;
  }
  return (*(last_M + (m - 1)));
}
}
score_t match_positions(char const   *needle , char const   *haystack , size_t *positions ) 
{ 
  float tmp ;
  struct match_struct match___0 ;
  int n ;
  int m ;
  float tmp___0 ;
  int i ;
  float tmp___1 ;
  score_t (*D)[1024] ;
  score_t (*M)[1024] ;
  void *tmp___2 ;
  void *tmp___3 ;
  score_t *last_D ;
  score_t *last_M ;
  score_t *curr_D ;
  score_t *curr_M ;
  int i___0 ;
  int match_required ;
  int i___1 ;
  int j ;
  int tmp___4 ;
  int tmp___5 ;
  float tmp___6 ;
  score_t result ;

  {
  if (! *needle) {
    tmp = __builtin_inff();
    return ((score_t )(- tmp));
  }
  setup_match_struct(& match___0, needle, haystack);
  n = match___0.needle_len;
  m = match___0.haystack_len;
  if (m > 1024) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n > m) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n == m) {
    if (positions) {
      i = 0;
      while (i < n) {
        *(positions + i) = (size_t )i;
        i ++;
      }
    }
    tmp___1 = __builtin_inff();
    return ((score_t )tmp___1);
  }
  tmp___2 = malloc((sizeof(score_t ) * 1024UL) * (unsigned long )n);
  M = (score_t (*)[1024])tmp___2;
  tmp___3 = malloc((sizeof(score_t ) * 1024UL) * (unsigned long )n);
  D = (score_t (*)[1024])tmp___3;
  i___0 = 0;
  while (i___0 < n) {
    curr_D = & (*(D + i___0))[0];
    curr_M = & (*(M + i___0))[0];
    match_row((struct match_struct  const  *)(& match___0), i___0, curr_D, curr_M,
              (score_t const   *)last_D, (score_t const   *)last_M);
    last_D = curr_D;
    last_M = curr_M;
    i___0 ++;
  }
  if (positions) {
    match_required = 0;
    i___1 = n - 1;
    j = m - 1;
    while (i___1 >= 0) {
      while (j >= 0) {
        tmp___6 = __builtin_inff();
        if ((*(D + i___1))[j] != (score_t )(- tmp___6)) {
          if (match_required) {
            goto _L;
          } else
          if ((*(D + i___1))[j] == (*(M + i___1))[j]) {
            _L: /* CIL Label */ 
            if (i___1) {
              if (j) {
                if ((*(M + i___1))[j] == (*(D + (i___1 - 1)))[j - 1] + 1.0) {
                  tmp___4 = 1;
                } else {
                  tmp___4 = 0;
                }
              } else {
                tmp___4 = 0;
              }
            } else {
              tmp___4 = 0;
            }
            match_required = tmp___4;
            tmp___5 = j;
            j --;
            *(positions + i___1) = (size_t )tmp___5;
            break;
          }
        }
        j --;
      }
      i___1 --;
    }
  }
  result = (*(M + (n - 1)))[m - 1];
  free((void *)M);
  free((void *)D);
  return (result);
}
}
#pragma merger("0","/tmp/cil-L1hIoriA.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern FILE *stderr ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
void choices_fread(choices_t *c , FILE *file , char input_delimiter ) ;
size_t choices_available(choices_t *c ) ;
score_t choices_getscore(choices_t *c , size_t n ) ;
static int cmpchoice(void const   *_idx1 , void const   *_idx2 ) 
{ 
  struct scored_result  const  *a ;
  struct scored_result  const  *b ;

  {
  a = (struct scored_result  const  *)_idx1;
  b = (struct scored_result  const  *)_idx2;
  if (a->score == b->score) {
    if ((unsigned long )a->str < (unsigned long )b->str) {
      return (-1);
    } else {
      return (1);
    }
  } else
  if (a->score < b->score) {
    return (1);
  } else {
    return (-1);
  }
}
}
static void *safe_realloc(void *buffer , size_t size ) 
{ 


  {
  buffer = realloc(buffer, size);
  if (! buffer) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Can\'t allocate memory (%zu bytes)\n",
            size);
    abort();
  }
  return (buffer);
}
}
void choices_fread(choices_t *c , FILE *file , char input_delimiter ) 
{ 
  size_t buffer_start ;
  size_t capacity ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char const   *line_end ;
  char *line ;
  char *nl ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  buffer_start = c->buffer_size;
  capacity = (size_t )4096;
  while (capacity <= c->buffer_size) {
    capacity *= 2UL;
  }
  tmp = safe_realloc((void *)c->buffer, capacity);
  c->buffer = (char *)tmp;
  while (1) {
    tmp___1 = fread((void * __restrict  )(c->buffer + c->buffer_size), (size_t )1,
                    capacity - c->buffer_size, (FILE * __restrict  )file);
    tmp___2 = c->buffer_size + tmp___1;
    c->buffer_size = tmp___2;
    if (! (tmp___2 == capacity)) {
      break;
    }
    capacity *= 2UL;
    tmp___0 = safe_realloc((void *)c->buffer, capacity);
    c->buffer = (char *)tmp___0;
  }
  tmp___3 = safe_realloc((void *)c->buffer, c->buffer_size + 1UL);
  c->buffer = (char *)tmp___3;
  tmp___4 = c->buffer_size;
  (c->buffer_size) ++;
  *(c->buffer + tmp___4) = (char )'\000';
  line_end = (char const   *)(c->buffer + c->buffer_size);
  line = c->buffer + buffer_start;
  while (1) {
    tmp___5 = strchr((char const   *)line, (int )input_delimiter);
    nl = tmp___5;
    if (nl) {
      tmp___6 = nl;
      nl ++;
      *tmp___6 = (char )'\000';
    }
    if (*line) {
      choices_add(c, (char const   *)line);
    }
    line = nl;
    if (line) {
      if (! ((unsigned long )line < (unsigned long )line_end)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static void choices_resize(choices_t *c , size_t new_capacity ) 
{ 
  void *tmp ;

  {
  tmp = safe_realloc((void *)c->strings, new_capacity * sizeof(char const   *));
  c->strings = (char const   **)tmp;
  c->capacity = new_capacity;
  return;
}
}
static void choices_reset_search(choices_t *c ) 
{ 
  size_t tmp ;

  {
  free((void *)c->results);
  tmp = (size_t )0;
  c->available = tmp;
  c->selection = tmp;
  c->results = (struct scored_result *)((void *)0);
  return;
}
}
void choices_init(choices_t *c , options_t *options ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  c->strings = (char const   **)((void *)0);
  c->results = (struct scored_result *)((void *)0);
  c->buffer_size = (size_t )0;
  c->buffer = (char *)((void *)0);
  tmp = (size_t )0;
  c->size = tmp;
  c->capacity = tmp;
  choices_resize(c, (size_t )128);
  if (options->workers) {
    c->worker_count = options->workers;
  } else {
    tmp___0 = sysconf(84);
    c->worker_count = (unsigned int )((int )tmp___0);
  }
  choices_reset_search(c);
  return;
}
}
void choices_destroy(choices_t *c ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  free((void *)c->buffer);
  c->buffer = (char *)((void *)0);
  c->buffer_size = (size_t )0;
  free((void *)c->strings);
  c->strings = (char const   **)((void *)0);
  tmp = (size_t )0;
  c->size = tmp;
  c->capacity = tmp;
  free((void *)c->results);
  c->results = (struct scored_result *)((void *)0);
  tmp___0 = (size_t )0;
  c->selection = tmp___0;
  c->available = tmp___0;
  return;
}
}
void choices_add(choices_t *c , char const   *choice ) 
{ 
  size_t tmp ;

  {
  choices_reset_search(c);
  if (c->size == c->capacity) {
    choices_resize(c, c->capacity * 2UL);
  }
  tmp = c->size;
  (c->size) ++;
  *(c->strings + tmp) = choice;
  return;
}
}
size_t choices_available(choices_t *c ) 
{ 


  {
  return (c->available);
}
}
static void worker_get_next_batch(struct search_job *job , size_t *start , size_t *end ) 
{ 


  {
  pthread_mutex_lock(& job->lock);
  *start = job->processed;
  job->processed += 512UL;
  if (job->processed > (job->choices)->size) {
    job->processed = (job->choices)->size;
  }
  *end = job->processed;
  pthread_mutex_unlock(& job->lock);
  return;
}
}
static struct result_list merge2(struct result_list list1 , struct result_list list2 ) 
{ 
  size_t result_index ;
  size_t index1 ;
  size_t index2 ;
  struct result_list result ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  result_index = (size_t )0;
  index1 = (size_t )0;
  index2 = (size_t )0;
  result.size = list1.size + list2.size;
  tmp = malloc(result.size * sizeof(struct scored_result ));
  result.list = (struct scored_result *)tmp;
  if (! result.list) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Can\'t allocate memory\n");
    abort();
  }
  while (1) {
    if (index1 < list1.size) {
      if (! (index2 < list2.size)) {
        break;
      }
    } else {
      break;
    }
    tmp___4 = cmpchoice((void const   *)(list1.list + index1), (void const   *)(list2.list + index2));
    if (tmp___4 < 0) {
      tmp___0 = result_index;
      result_index ++;
      tmp___1 = index1;
      index1 ++;
      *(result.list + tmp___0) = *(list1.list + tmp___1);
    } else {
      tmp___2 = result_index;
      result_index ++;
      tmp___3 = index2;
      index2 ++;
      *(result.list + tmp___2) = *(list2.list + tmp___3);
    }
  }
  while (index1 < list1.size) {
    tmp___5 = result_index;
    result_index ++;
    tmp___6 = index1;
    index1 ++;
    *(result.list + tmp___5) = *(list1.list + tmp___6);
  }
  while (index2 < list2.size) {
    tmp___7 = result_index;
    result_index ++;
    tmp___8 = index2;
    index2 ++;
    *(result.list + tmp___7) = *(list2.list + tmp___8);
  }
  free((void *)list1.list);
  free((void *)list2.list);
  return (result);
}
}
static void *choices_search_worker(void *data ) 
{ 
  struct worker *w ;
  struct search_job *job ;
  choices_t const   *c ;
  struct result_list *result ;
  size_t start ;
  size_t end ;
  size_t i ;
  int tmp ;
  unsigned int step ;
  unsigned int next_worker ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  w = (struct worker *)data;
  job = w->job;
  c = (choices_t const   *)job->choices;
  result = & w->result;
  while (1) {
    worker_get_next_batch(job, & start, & end);
    if (start == end) {
      break;
    }
    i = start;
    while (i < end) {
      tmp = has_match(job->search, *(c->strings + i));
      if (tmp) {
        (result->list + result->size)->str = *(c->strings + i);
        (result->list + result->size)->score = match(job->search, *(c->strings + i));
        (result->size) ++;
      }
      i ++;
    }
  }
  qsort((void *)result->list, result->size, sizeof(struct scored_result ), & cmpchoice);
  step = 0U;
  while (! (w->worker_num % (unsigned int )(2 << step))) {
    next_worker = w->worker_num | (unsigned int )(1 << step);
    if (next_worker >= (unsigned int )c->worker_count) {
      break;
    }
    tmp___0 = __errno_location();
    tmp___1 = pthread_join((job->workers + next_worker)->thread_id, (void **)((void *)0));
    *tmp___0 = tmp___1;
    if (tmp___1) {
      perror("pthread_join");
      exit(1);
    }
    w->result = merge2(w->result, (job->workers + next_worker)->result);
    step ++;
  }
  return ((void *)0);
}
}
void choices_search(choices_t *c , char const   *search ) 
{ 
  struct search_job *job ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct worker *workers ;
  int i ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  choices_reset_search(c);
  tmp = calloc((size_t )1, sizeof(struct search_job ));
  job = (struct search_job *)tmp;
  job->search = search;
  job->choices = c;
  tmp___0 = pthread_mutex_init(& job->lock, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___0 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: pthread_mutex_init failed\n");
    abort();
  }
  tmp___1 = calloc((size_t )c->worker_count, sizeof(struct worker ));
  job->workers = (struct worker *)tmp___1;
  workers = job->workers;
  i = (int )(c->worker_count - 1U);
  while (i >= 0) {
    (workers + i)->job = job;
    (workers + i)->worker_num = (unsigned int )i;
    (workers + i)->result.size = (size_t )0;
    tmp___2 = malloc(c->size * sizeof(struct scored_result ));
    (workers + i)->result.list = (struct scored_result *)tmp___2;
    tmp___3 = __errno_location();
    tmp___4 = pthread_create((pthread_t * __restrict  )(& (workers + i)->thread_id),
                             (pthread_attr_t const   * __restrict  )((void *)0), & choices_search_worker,
                             (void * __restrict  )(workers + i));
    *tmp___3 = tmp___4;
    if (tmp___4) {
      perror("pthread_create");
      exit(1);
    }
    i --;
  }
  tmp___5 = pthread_join((workers + 0)->thread_id, (void **)((void *)0));
  if (tmp___5) {
    perror("pthread_join");
    exit(1);
  }
  c->results = (workers + 0)->result.list;
  c->available = (workers + 0)->result.size;
  free((void *)workers);
  pthread_mutex_destroy(& job->lock);
  free((void *)job);
  return;
}
}
char const   *choices_get(choices_t *c , size_t n ) 
{ 


  {
  if (n < c->available) {
    return ((c->results + n)->str);
  } else {
    return ((char const   *)((void *)0));
  }
}
}
score_t choices_getscore(choices_t *c , size_t n ) 
{ 


  {
  return ((c->results + n)->score);
}
}
void choices_prev(choices_t *c ) 
{ 


  {
  if (c->available) {
    c->selection = ((c->selection + c->available) - 1UL) % c->available;
  }
  return;
}
}
void choices_next(choices_t *c ) 
{ 


  {
  if (c->available) {
    c->selection = (c->selection + 1UL) % c->available;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-2PWWSCmH.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
void options_parse(options_t *options , int argc , char **argv ) ;
static char const   *usage_str  =    "Usage: fzy [OPTION]...\n -l, --lines=LINES        Specify how many lines of results to show (default 10)\n -p, --prompt=PROMPT      Input prompt (default \'> \')\n -q, --query=QUERY        Use QUERY as the initial search string\n -e, --show-matches=QUERY Output the sorted matches of QUERY\n -t, --tty=TTY            Specify file to use as TTY device (default /dev/tty)\n -s, --show-scores        Show the scores of each match\n -0, --read-null          Read input delimited by ASCII NUL characters\n -j, --workers NUM        Use NUM workers for searching. (default is # of CPUs)\n -i, --show-info          Show selection info line\n -h, --help     Display this help and exit\n -v, --version  Output version information and exit\n";
static void usage(char const   *argv0 ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )usage_str, argv0);
  return;
}
}
static struct option longopts[13]  = 
  {      {"show-matches", 1, (int *)((void *)0), 'e'}, 
        {"query", 1, (int *)((void *)0), 'q'}, 
        {"lines", 1, (int *)((void *)0), 'l'}, 
        {"tty", 1, (int *)((void *)0), 't'}, 
        {"prompt", 1, (int *)((void *)0), 'p'}, 
        {"show-scores", 0, (int *)((void *)0), 's'}, 
        {"read-null", 0, (int *)((void *)0), '0'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"benchmark", 2, (int *)((void *)0), 'b'}, 
        {"workers", 1, (int *)((void *)0), 'j'}, 
        {"show-info", 0, (int *)((void *)0), 'i'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
void options_init(options_t *options ) 
{ 


  {
  options->benchmark = 0;
  options->filter = (char const   *)((void *)0);
  options->init_search = (char const   *)((void *)0);
  options->show_scores = 0;
  options->scrolloff = 1U;
  options->tty_filename = "/dev/tty";
  options->num_lines = 10U;
  options->prompt = "> ";
  options->workers = 0U;
  options->input_delimiter = (char )'\n';
  options->show_info = 0;
  return;
}
}
void options_parse(options_t *options , int argc , char **argv ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  int l ;
  int tmp___1 ;
  int tmp___2 ;

  {
  options_init(options);
  while (1) {
    c = getopt_long(argc, (char * const  *)argv, "vhs0e:q:l:t:p:j:i", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    if (! (c != -1)) {
      break;
    }
    switch (c) {
    case 118: 
    printf((char const   * __restrict  )"%s 1.0 \302\251 2014-2018 John Hawthorn\n",
           *(argv + 0));
    exit(0);
    case 115: 
    options->show_scores = 1;
    break;
    case 48: 
    options->input_delimiter = (char )'\000';
    break;
    case 113: 
    options->init_search = (char const   *)optarg;
    break;
    case 101: 
    options->filter = (char const   *)optarg;
    break;
    case 98: 
    if (optarg) {
      tmp = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%d",
                   & options->benchmark);
      if (tmp != 1) {
        usage((char const   *)*(argv + 0));
        exit(1);
      }
    } else {
      options->benchmark = 100;
    }
    break;
    case 116: 
    options->tty_filename = (char const   *)optarg;
    break;
    case 112: 
    options->prompt = (char const   *)optarg;
    break;
    case 106: 
    tmp___0 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%u",
                     & options->workers);
    if (tmp___0 != 1) {
      usage((char const   *)*(argv + 0));
      exit(1);
    }
    break;
    case 108: 
    tmp___2 = strcmp((char const   *)optarg, "max");
    if (tmp___2) {
      tmp___1 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%d",
                       & l);
      if (tmp___1 != 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid format for --lines: %s\n",
                optarg);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Must be integer in range 3..\n");
        usage((char const   *)*(argv + 0));
        exit(1);
      } else
      if (l < 3) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid format for --lines: %s\n",
                optarg);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Must be integer in range 3..\n");
        usage((char const   *)*(argv + 0));
        exit(1);
      }
    } else {
      l = 2147483647;
    }
    options->num_lines = (unsigned int )l;
    break;
    case 105: 
    options->show_info = 1;
    break;
    default: 
    usage((char const   *)*(argv + 0));
    exit(0);
    }
  }
  if (optind != argc) {
    usage((char const   *)*(argv + 0));
    exit(1);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-bD2OAjx0.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
void theft_set_seed(struct theft *t , uint64_t seed ) ;
double theft_random_double(struct theft *t ) ;
void theft_set_output_stream(struct theft *t , FILE *out ) ;
static theft_trial_res call_fun(struct theft_propfun_info *info , void **args ) ;
static _Bool run_trial(struct theft *t , struct theft_propfun_info *info , void **args ,
                       theft_progress_cb *cb , void *env , struct theft_trial_report *r ,
                       struct theft_trial_info *ti , theft_progress_callback_res *cres___0 ) ;
static void mark_called(theft *t , struct theft_propfun_info *info , void **args ,
                        void *env ) ;
static _Bool check_called(theft *t , struct theft_propfun_info *info , void **args ,
                          void *env ) ;
static theft_progress_callback_res report_on_failure(theft *t , struct theft_propfun_info *info ,
                                                     struct theft_trial_info *ti ,
                                                     theft_progress_cb *cb , void *env ) ;
static all_gen_res_t gen_all_args(theft *t , struct theft_propfun_info *info , theft_seed seed ,
                                  void **args , void *env ) ;
static void free_args(struct theft_propfun_info *info , void **args , void *env ) ;
static theft_run_res theft_run_internal(struct theft *t , struct theft_propfun_info *info ,
                                        int trials , theft_progress_cb *cb , void *env ,
                                        struct theft_trial_report *r ) ;
static _Bool attempt_to_shrink(theft *t , struct theft_propfun_info *info , void **args ,
                               void *env ) ;
static shrink_res attempt_to_shrink_arg(theft *t , struct theft_propfun_info *info ,
                                        void **args , void *env , int ai ) ;
struct theft_bloom *theft_bloom_init(uint8_t bit_size2 ) ;
void theft_bloom_mark(struct theft_bloom *b , uint8_t *data , size_t data_size ) ;
_Bool theft_bloom_check(struct theft_bloom *b , uint8_t *data , size_t data_size ) ;
void theft_bloom_free(struct theft_bloom *b ) ;
void theft_bloom_dump(struct theft_bloom *b ) ;
uint8_t theft_bloom_recommendation(int trials ) ;
struct theft_mt *theft_mt_init(uint64_t seed ) ;
void theft_mt_free(struct theft_mt *mt ) ;
void theft_mt_reset(struct theft_mt *mt , uint64_t seed ) ;
uint64_t theft_mt_random(struct theft_mt *mt ) ;
double theft_mt_random_double(struct theft_mt *mt ) ;
struct theft *theft_init(uint8_t bloom_bits ) 
{ 
  theft *t ;
  void *tmp ;

  {
  if ((int )bloom_bits != 0) {
    if ((int )bloom_bits < 13) {
      return ((struct theft *)((void *)0));
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )bloom_bits > 33) {
    if ((int )bloom_bits != 255) {
      return ((struct theft *)((void *)0));
    }
  }
  tmp = malloc(sizeof(*t));
  t = (theft *)tmp;
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    return ((struct theft *)((void *)0));
  }
  memset((void *)t, 0, sizeof(*t));
  t->mt = theft_mt_init((uint64_t )46725745578827501L);
  if ((unsigned long )t->mt == (unsigned long )((void *)0)) {
    free((void *)t);
    return ((struct theft *)((void *)0));
  } else {
    t->out = stdout;
    t->requested_bloom_bits = bloom_bits;
    return (t);
  }
}
}
void theft_set_seed(struct theft *t , uint64_t seed ) 
{ 


  {
  t->seed = seed;
  theft_mt_reset(t->mt, seed);
  return;
}
}
unsigned long theft_random(struct theft *t ) 
{ 
  theft_seed ns ;
  uint64_t tmp ;

  {
  tmp = theft_mt_random(t->mt);
  ns = tmp;
  return (ns);
}
}
double theft_random_double(struct theft *t ) 
{ 
  double tmp ;

  {
  tmp = theft_mt_random_double(t->mt);
  return (tmp);
}
}
void theft_set_output_stream(struct theft *t , FILE *out ) 
{ 


  {
  t->out = out;
  return;
}
}
static _Bool check_all_args(struct theft_propfun_info *info , _Bool *all_hashable ) 
{ 
  _Bool ah ;
  int i ;
  struct theft_type_info *ti ;

  {
  ah = (_Bool)1;
  i = 0;
  while (i < (int )info->arity) {
    ti = info->type_info[i];
    if ((unsigned long )ti->alloc == (unsigned long )((void *)0)) {
      return ((_Bool)0);
    }
    if ((unsigned long )ti->hash == (unsigned long )((void *)0)) {
      ah = (_Bool)0;
    }
    i ++;
  }
  *all_hashable = ah;
  return ((_Bool)1);
}
}
static theft_progress_callback_res default_progress_cb(struct theft_trial_info *info ,
                                                       void *env ) 
{ 


  {
  return ((theft_progress_callback_res )0);
}
}
static void infer_arity(struct theft_propfun_info *info ) 
{ 
  int i ;

  {
  i = 0;
  while (i < 10) {
    if ((unsigned long )info->type_info[i] == (unsigned long )((void *)0)) {
      info->arity = (uint8_t )i;
      break;
    }
    i ++;
  }
  return;
}
}
theft_run_res theft_run(struct theft *t , struct theft_cfg *cfg ) 
{ 
  struct theft_propfun_info info ;
  theft_run_res tmp ;

  {
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    return ((theft_run_res )-1);
  } else
  if ((unsigned long )cfg == (unsigned long )((void *)0)) {
    return ((theft_run_res )-1);
  }
  memset((void *)(& info), 0, sizeof(info));
  info.name = cfg->name;
  info.fun = cfg->fun;
  memcpy((void * __restrict  )(info.type_info), (void const   * __restrict  )(cfg->type_info),
         sizeof(info.type_info));
  info.always_seed_count = cfg->always_seed_count;
  info.always_seeds = cfg->always_seeds;
  if (cfg->seed) {
    theft_set_seed(t, cfg->seed);
  } else {
    theft_set_seed(t, (uint64_t )46725745578827501L);
  }
  if (cfg->trials == 0) {
    cfg->trials = 100;
  }
  tmp = theft_run_internal(t, & info, cfg->trials, cfg->progress_cb, cfg->env, cfg->report);
  return (tmp);
}
}
static theft_run_res theft_run_internal(struct theft *t , struct theft_propfun_info *info ,
                                        int trials , theft_progress_cb *cb , void *env ,
                                        struct theft_trial_report *r ) 
{ 
  struct theft_trial_report fake_report ;
  _Bool all_hashable ;
  _Bool tmp ;
  theft_seed seed ;
  theft_seed initial_seed ;
  int always_seeds ;
  void *args[10] ;
  theft_progress_callback_res cres___0 ;
  int trial ;
  struct theft_trial_info ti ;
  all_gen_res_t gres ;
  all_gen_res_t tmp___0 ;
  _Bool tmp___1 ;

  {
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    r = & fake_report;
  }
  memset((void *)r, 0, sizeof(*r));
  infer_arity(info);
  if ((int )info->arity == 0) {
    return ((theft_run_res )-1);
  }
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    return ((theft_run_res )-1);
  } else
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    return ((theft_run_res )-1);
  } else
  if ((unsigned long )info->fun == (unsigned long )((void *)0)) {
    return ((theft_run_res )-1);
  } else
  if ((int )info->arity == 0) {
    return ((theft_run_res )-1);
  }
  all_hashable = (_Bool)0;
  tmp = check_all_args(info, & all_hashable);
  if (! tmp) {
    return ((theft_run_res )-2);
  }
  if ((unsigned long )cb == (unsigned long )((void *)0)) {
    cb = & default_progress_cb;
  }
  if (all_hashable) {
    if ((int )t->requested_bloom_bits == 0) {
      t->requested_bloom_bits = theft_bloom_recommendation(trials);
    }
    if ((int )t->requested_bloom_bits != 255) {
      t->bloom = theft_bloom_init(t->requested_bloom_bits);
    }
  }
  seed = t->seed;
  initial_seed = t->seed;
  always_seeds = info->always_seed_count;
  if ((unsigned long )info->always_seeds == (unsigned long )((void *)0)) {
    always_seeds = 0;
  }
  cres___0 = (theft_progress_callback_res )0;
  trial = 0;
  while (trial < trials) {
    memset((void *)(args), 255, sizeof(args));
    if ((unsigned int )cres___0 == 1U) {
      break;
    }
    if (trial < always_seeds) {
      seed = *(info->always_seeds + trial);
    } else
    if (always_seeds > 0) {
      if (trial == always_seeds) {
        seed = initial_seed;
      }
    }
    ti.name = info->name;
    ti.trial = trial;
    ti.seed = seed;
    ti.status = 0U;
    ti.arity = info->arity;
    ti.args = args;
    theft_set_seed(t, seed);
    tmp___0 = gen_all_args(t, info, seed, (void **)(args), env);
    gres = tmp___0;
    switch ((unsigned int )gres) {
    case 1U: 
    ti.status = (theft_trial_res )2;
    (r->skip) ++;
    cres___0 = (*cb)(& ti, env);
    break;
    case 2U: 
    ti.status = (theft_trial_res )3;
    (r->dup) ++;
    cres___0 = (*cb)(& ti, env);
    break;
    default: 
    ti.status = (theft_trial_res )4;
    cres___0 = (*cb)(& ti, env);
    return ((theft_run_res )2);
    case 0U: 
    tmp___1 = run_trial(t, info, args, cb, env, r, & ti, & cres___0);
    if (! tmp___1) {
      return ((theft_run_res )2);
    }
    }
    free_args(info, args, env);
    theft_set_seed(t, seed);
    seed = theft_random(t);
    trial ++;
  }
  if (r->fail > 0UL) {
    return ((theft_run_res )1);
  } else {
    return ((theft_run_res )0);
  }
}
}
static _Bool run_trial(struct theft *t , struct theft_propfun_info *info , void **args ,
                       theft_progress_cb *cb , void *env , struct theft_trial_report *r ,
                       struct theft_trial_info *ti , theft_progress_callback_res *cres___0 ) 
{ 
  theft_trial_res tres ;
  theft_trial_res tmp ;
  _Bool tmp___0 ;

  {
  if (t->bloom) {
    mark_called(t, info, args, env);
  }
  tmp = call_fun(info, args);
  tres = tmp;
  ti->status = tres;
  switch ((unsigned int )tres) {
  case 0U: 
  (r->pass) ++;
  *cres___0 = (*cb)(ti, env);
  break;
  case 1U: 
  tmp___0 = attempt_to_shrink(t, info, args, env);
  if (! tmp___0) {
    ti->status = (theft_trial_res )4;
    *cres___0 = (*cb)(ti, env);
    return ((_Bool)0);
  }
  (r->fail) ++;
  *cres___0 = report_on_failure(t, info, ti, cb, env);
  break;
  case 2U: 
  *cres___0 = (*cb)(ti, env);
  (r->skip) ++;
  break;
  case 4U: 
  case 3U: 
  *cres___0 = (*cb)(ti, env);
  free_args(info, args, env);
  return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static void free_args(struct theft_propfun_info *info , void **args , void *env ) 
{ 
  int i ;
  theft_free_cb *fcb ;

  {
  i = 0;
  while (i < (int )info->arity) {
    fcb = (info->type_info[i])->free;
    if (fcb) {
      if ((unsigned long )*(args + i) != (unsigned long )((void *)-1)) {
        (*fcb)(*(args + i), env);
      }
    }
    i ++;
  }
  return;
}
}
void theft_free(struct theft *t ) 
{ 


  {
  if (t->bloom) {
    theft_bloom_dump(t->bloom);
    theft_bloom_free(t->bloom);
    t->bloom = (struct theft_bloom *)((void *)0);
  }
  theft_mt_free(t->mt);
  free((void *)t);
  return;
}
}
static theft_trial_res call_fun(struct theft_propfun_info *info , void **args ) 
{ 
  theft_trial_res res ;

  {
  res = (theft_trial_res )4;
  switch ((int )info->arity) {
  case 1: 
  res = (*(info->fun))(*(args + 0));
  break;
  case 2: 
  res = (*(info->fun))(*(args + 0), *(args + 1));
  break;
  case 3: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2));
  break;
  case 4: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3));
  break;
  case 5: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3), *(args + 4));
  break;
  case 6: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3), *(args + 4),
                       *(args + 5));
  break;
  case 7: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3), *(args + 4),
                       *(args + 5), *(args + 6));
  break;
  case 8: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3), *(args + 4),
                       *(args + 5), *(args + 6), *(args + 7));
  break;
  case 9: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3), *(args + 4),
                       *(args + 5), *(args + 6), *(args + 7), *(args + 8));
  break;
  case 10: 
  res = (*(info->fun))(*(args + 0), *(args + 1), *(args + 2), *(args + 3), *(args + 4),
                       *(args + 5), *(args + 6), *(args + 7), *(args + 8), *(args + 9));
  break;
  default: 
  return ((theft_trial_res )4);
  }
  return (res);
}
}
static all_gen_res_t gen_all_args(theft *t , struct theft_propfun_info *info , theft_seed seed ,
                                  void **args , void *env ) 
{ 
  int i ;
  struct theft_type_info *ti ;
  void *p ;
  void *tmp ;
  int j ;
  _Bool tmp___0 ;

  {
  i = 0;
  while (i < (int )info->arity) {
    ti = info->type_info[i];
    tmp = (*(ti->alloc))(t, seed, env);
    p = tmp;
    if ((unsigned long )p == (unsigned long )((void *)-1)) {
      goto _L;
    } else
    if ((unsigned long )p == (unsigned long )((void *)-2)) {
      _L: /* CIL Label */ 
      j = 0;
      while (j < i) {
        (*(ti->free))(*(args + j), env);
        j ++;
      }
      if ((unsigned long )p == (unsigned long )((void *)-1)) {
        return ((all_gen_res_t )1);
      } else {
        return ((all_gen_res_t )3);
      }
    } else {
      *(args + i) = p;
    }
    seed = theft_random(t);
    i ++;
  }
  if (t->bloom) {
    tmp___0 = check_called(t, info, (void **)args, env);
    if (tmp___0) {
      return ((all_gen_res_t )2);
    }
  }
  return ((all_gen_res_t )0);
}
}
static _Bool attempt_to_shrink(theft *t , struct theft_propfun_info *info , void **args ,
                               void *env ) 
{ 
  _Bool progress ;
  int ai ;
  struct theft_type_info *ti ;
  shrink_res rres ;
  shrink_res tmp ;

  {
  progress = (_Bool)0;
  while (1) {
    progress = (_Bool)0;
    ai = 0;
    while (ai < (int )info->arity) {
      ti = info->type_info[ai];
      if (ti->shrink) {
        tmp = attempt_to_shrink_arg(t, info, args, env, ai);
        rres = tmp;
        switch ((unsigned int )rres) {
        case 0U: 
        progress = (_Bool)1;
        break;
        case 1U: 
        break;
        default: 
        return ((_Bool)0);
        }
      }
      ai ++;
    }
    if (! progress) {
      break;
    }
  }
  return ((_Bool)1);
}
}
static shrink_res attempt_to_shrink_arg(theft *t , struct theft_propfun_info *info ,
                                        void **args , void *env , int ai ) 
{ 
  struct theft_type_info *ti ;
  uint32_t tactic ;
  void *cur ;
  void *nv ;
  void *tmp ;
  _Bool tmp___0 ;
  theft_trial_res res ;
  theft_trial_res tmp___1 ;

  {
  ti = info->type_info[ai];
  tactic = (uint32_t )0;
  while (tactic < 4294967295U) {
    cur = *(args + ai);
    tmp = (*(ti->shrink))(cur, tactic, env);
    nv = tmp;
    if ((unsigned long )nv == (unsigned long )((void *)-3)) {
      return ((shrink_res )1);
    } else
    if ((unsigned long )nv == (unsigned long )((void *)-2)) {
      return ((shrink_res )2);
    } else
    if ((unsigned long )nv == (unsigned long )((void *)-1)) {
      goto __Cont;
    }
    *(args + ai) = nv;
    if (t->bloom) {
      tmp___0 = check_called(t, info, args, env);
      if (tmp___0) {
        if (ti->free) {
          (*(ti->free))(nv, env);
        }
        *(args + ai) = cur;
        goto __Cont;
      } else {
        mark_called(t, info, args, env);
      }
    }
    tmp___1 = call_fun(info, args);
    res = tmp___1;
    switch ((unsigned int )res) {
    case 2U: 
    case 0U: 
    *(args + ai) = cur;
    if (ti->free) {
      (*(ti->free))(nv, env);
    }
    break;
    case 1U: 
    if (ti->free) {
      (*(ti->free))(cur, env);
    }
    return ((shrink_res )0);
    case 4U: 
    case 3U: 
    return ((shrink_res )2);
    }
    __Cont: /* CIL Label */ 
    tactic ++;
  }
  return ((shrink_res )1);
}
}
static void get_arg_hash_buffer(theft_hash *buffer , struct theft_propfun_info *info ,
                                void **args , void *env ) 
{ 
  int i ;

  {
  i = 0;
  while (i < (int )info->arity) {
    *(buffer + i) = (*((info->type_info[i])->hash))(*(args + i), env);
    i ++;
  }
  return;
}
}
static void mark_called(theft *t , struct theft_propfun_info *info , void **args ,
                        void *env ) 
{ 
  theft_hash buffer[10] ;

  {
  get_arg_hash_buffer(buffer, info, args, env);
  theft_bloom_mark(t->bloom, (uint8_t *)(buffer), (unsigned long )info->arity * sizeof(theft_hash ));
  return;
}
}
static _Bool check_called(theft *t , struct theft_propfun_info *info , void **args ,
                          void *env ) 
{ 
  theft_hash buffer[10] ;
  _Bool tmp ;

  {
  get_arg_hash_buffer(buffer, info, args, env);
  tmp = theft_bloom_check(t->bloom, (uint8_t *)(buffer), (unsigned long )info->arity * sizeof(theft_hash ));
  return (tmp);
}
}
static theft_progress_callback_res cres  ;
static theft_progress_callback_res report_on_failure(theft *t , struct theft_propfun_info *info ,
                                                     struct theft_trial_info *ti ,
                                                     theft_progress_cb *cb , void *env ) 
{ 
  int arity ;
  char const   *tmp ;
  int i ;
  theft_print_cb *print ;

  {
  arity = (int )info->arity;
  if (info->name) {
    tmp = info->name;
  } else {
    tmp = "";
  }
  fprintf((FILE * __restrict  )t->out, (char const   * __restrict  )"\n\n -- Counter-Example: %s\n",
          tmp);
  fprintf((FILE * __restrict  )t->out, (char const   * __restrict  )"    Trial %u, Seed 0x%016llx\n",
          ti->trial, ti->seed);
  i = 0;
  while (i < arity) {
    print = (info->type_info[i])->print;
    if (print) {
      fprintf((FILE * __restrict  )t->out, (char const   * __restrict  )"    Argument %d:\n",
              i);
      (*print)(t->out, *(ti->args + i), env);
      fprintf((FILE * __restrict  )t->out, (char const   * __restrict  )"\n");
    }
    i ++;
  }
  cres = (*cb)(ti, env);
  return (cres);
}
}
#pragma merger("0","/tmp/cil-hzJDqFbr.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
static uint8_t get_bits_set_count(uint8_t *counts , uint8_t byte ) ;
struct theft_bloom *theft_bloom_init(uint8_t bit_size2 ) 
{ 
  size_t sz ;
  struct theft_bloom *b ;
  void *tmp ;

  {
  sz = (size_t )(1 << ((int )bit_size2 - 3));
  tmp = malloc(sizeof(struct theft_bloom ) + sz);
  b = (struct theft_bloom *)tmp;
  if (b) {
    b->size = sz;
    b->bit_count = bit_size2;
    memset((void *)(b->bits), 0, sz);
  }
  return (b);
}
}
void theft_bloom_mark(struct theft_bloom *b , uint8_t *data , size_t data_size ) 
{ 
  uint64_t hash ;
  theft_hash tmp ;
  uint8_t bc ;
  uint64_t mask ;
  int bit_inc ;
  int i ;
  uint64_t v ;
  size_t offset ;
  uint8_t bit ;

  {
  tmp = theft_hash_onepass(data, data_size);
  hash = tmp;
  bc = b->bit_count;
  mask = (uint64_t )((1 << (int )bc) - 1);
  bit_inc = (64 - (int )bc) / 4;
  i = 0;
  while (i < 64 - (int )bc) {
    v = (hash & (mask << i)) >> i;
    offset = v / 8UL;
    bit = (uint8_t )(1 << (v & 7UL));
    b->bits[offset] = (uint8_t )((int )b->bits[offset] | (int )bit);
    i += bit_inc;
  }
  return;
}
}
_Bool theft_bloom_check(struct theft_bloom *b , uint8_t *data , size_t data_size ) 
{ 
  uint64_t hash ;
  theft_hash tmp ;
  uint8_t bc ;
  uint64_t mask ;
  int bit_inc ;
  int i ;
  uint64_t v ;
  size_t offset ;
  uint8_t bit ;

  {
  tmp = theft_hash_onepass(data, data_size);
  hash = tmp;
  bc = b->bit_count;
  mask = (uint64_t )((1 << (int )bc) - 1);
  bit_inc = (64 - (int )bc) / 4;
  i = 0;
  while (i < 64 - (int )bc) {
    v = (hash & (mask << i)) >> i;
    offset = v / 8UL;
    bit = (uint8_t )(1 << (v & 7UL));
    if (0 == ((int )b->bits[offset] & (int )bit)) {
      return ((_Bool)0);
    }
    i += bit_inc;
  }
  return ((_Bool)1);
}
}
void theft_bloom_free(struct theft_bloom *b ) 
{ 


  {
  free((void *)b);
  return;
}
}
void theft_bloom_dump(struct theft_bloom *b ) 
{ 
  uint8_t counts[256] ;
  size_t total ;
  uint16_t row_total ;
  size_t i ;
  uint8_t count ;
  uint8_t tmp ;

  {
  memset((void *)(counts), 255, sizeof(counts));
  total = (size_t )0;
  row_total = (uint16_t )0;
  i = (size_t )0;
  while (i < b->size) {
    tmp = get_bits_set_count((uint8_t *)(counts), b->bits[i]);
    count = tmp;
    total += (size_t )count;
    row_total = (uint16_t )((int )row_total + (int )count);
    i ++;
  }
  if (total > b->size) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nWARNING: bloom filter is %zd%% full, larger bloom_bits value recommended.\n",
            (100UL * total) / (8UL * b->size));
  }
  return;
}
}
uint8_t theft_bloom_recommendation(int trials ) 
{ 
  uint8_t res ;
  uint8_t min ;
  uint8_t max ;
  uint8_t i ;
  int32_t v ;

  {
  res = (uint8_t )17;
  min = (uint8_t )10;
  max = (uint8_t )30;
  i = min;
  while ((int )i < (int )max) {
    v = 1 << (int )i;
    if (v > 14 * trials) {
      res = (uint8_t )((int )i + 3);
      break;
    }
    i = (uint8_t )((int )i + 1);
  }
  return (res);
}
}
static uint8_t get_bits_set_count(uint8_t *counts , uint8_t byte ) 
{ 
  uint8_t v ;
  uint8_t t ;
  uint8_t i ;

  {
  v = *(counts + byte);
  if ((int )v != 255) {
    return (v);
  }
  t = (uint8_t )0;
  i = (uint8_t )0;
  while ((int )i < 8) {
    if ((int )byte & (1 << (int )i)) {
      t = (uint8_t )((int )t + 1);
    }
    i = (uint8_t )((int )i + 1);
  }
  *(counts + byte) = t;
  return (t);
}
}
#pragma merger("0","/tmp/cil-DdKpAaEZ.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
static uint64_t genrand64_int64(struct theft_mt *r ) ;
struct theft_mt *theft_mt_init(uint64_t seed ) 
{ 
  struct theft_mt *mt ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct theft_mt ));
  mt = (struct theft_mt *)tmp;
  if ((unsigned long )mt == (unsigned long )((void *)0)) {
    return ((struct theft_mt *)((void *)0));
  }
  theft_mt_reset(mt, seed);
  return (mt);
}
}
void theft_mt_free(struct theft_mt *mt ) 
{ 


  {
  free((void *)mt);
  return;
}
}
void theft_mt_reset(struct theft_mt *mt , uint64_t seed ) 
{ 
  uint16_t mti ;

  {
  mt->mt[0] = seed;
  mti = (uint16_t )0;
  mti = (uint16_t )1;
  while ((int )mti < 312) {
    mt->mt[mti] = (uint64_t )(6364136223846793005ULL * (unsigned long long )(mt->mt[(int )mti - 1] ^ (mt->mt[(int )mti - 1] >> 62)) + (unsigned long long )mti);
    mti = (uint16_t )((int )mti + 1);
  }
  mt->mti = (int16_t )mti;
  return;
}
}
uint64_t theft_mt_random(struct theft_mt *mt ) 
{ 
  uint64_t tmp ;

  {
  tmp = genrand64_int64(mt);
  return (tmp);
}
}
double theft_mt_random_double(struct theft_mt *mt ) 
{ 
  uint64_t tmp ;

  {
  tmp = genrand64_int64(mt);
  return ((double )(tmp >> 11) * (1.0 / 9007199254740991.0));
}
}
static uint64_t mag01[2]  = {      (uint64_t )0ULL,      (uint64_t )13043109905998158313};
static uint64_t genrand64_int64(struct theft_mt *r ) 
{ 
  int i ;
  uint64_t x ;
  int16_t tmp ;

  {
  if ((int )r->mti >= 312) {
    if ((int )r->mti == 313) {
      theft_mt_reset(r, (uint64_t )5489ULL);
    }
    i = 0;
    while (i < 156) {
      x = (uint64_t )(((unsigned long long )r->mt[i] & 18446744071562067968) | ((unsigned long long )r->mt[i + 1] & 2147483647ULL));
      r->mt[i] = (r->mt[i + 156] ^ (x >> 1)) ^ mag01[(int )((unsigned long long )x & 1ULL)];
      i ++;
    }
    while (i < 311) {
      x = (uint64_t )(((unsigned long long )r->mt[i] & 18446744071562067968) | ((unsigned long long )r->mt[i + 1] & 2147483647ULL));
      r->mt[i] = (r->mt[i + -156] ^ (x >> 1)) ^ mag01[(int )((unsigned long long )x & 1ULL)];
      i ++;
    }
    x = (uint64_t )(((unsigned long long )r->mt[311] & 18446744071562067968) | ((unsigned long long )r->mt[0] & 2147483647ULL));
    r->mt[311] = (r->mt[155] ^ (x >> 1)) ^ mag01[(int )((unsigned long long )x & 1ULL)];
    r->mti = (int16_t )0;
  }
  tmp = r->mti;
  r->mti = (int16_t )((int )r->mti + 1);
  x = r->mt[tmp];
  x = (uint64_t )((unsigned long long )x ^ ((unsigned long long )(x >> 29) & 6148914691236517205ULL));
  x = (uint64_t )((unsigned long long )x ^ ((unsigned long long )(x << 17) & 8202884508482404352ULL));
  x = (uint64_t )((unsigned long long )x ^ ((unsigned long long )(x << 37) & 18444473444759240704));
  x ^= x >> 43;
  return (x);
}
}
#pragma merger("0","/tmp/cil-kbt1UdiR.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
void theft_hash_init(struct theft_hasher *h ) ;
void theft_hash_sink(struct theft_hasher *h , uint8_t *data , size_t bytes ) ;
theft_hash theft_hash_done(struct theft_hasher *h ) ;
static unsigned long const   fnv64_prime  =    (uint64_t const   )1099511628211L;
static unsigned long const   fnv64_offset_basis  =    (uint64_t const   )14695981039346656037;
void theft_hash_init(struct theft_hasher *h ) 
{ 


  {
  h->accum = (theft_hash )fnv64_offset_basis;
  return;
}
}
void theft_hash_sink(struct theft_hasher *h , uint8_t *data , size_t bytes ) 
{ 
  uint64_t a ;
  size_t i ;

  {
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    return;
  } else
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return;
  }
  a = h->accum;
  i = (size_t )0;
  while (i < bytes) {
    a = (a ^ (unsigned long )*(data + i)) * (unsigned long )fnv64_prime;
    i ++;
  }
  h->accum = a;
  return;
}
}
theft_hash theft_hash_done(struct theft_hasher *h ) 
{ 
  theft_hash res ;

  {
  res = h->accum;
  theft_hash_init(h);
  return (res);
}
}
theft_hash theft_hash_onepass(uint8_t *data , size_t bytes ) 
{ 
  struct theft_hasher h ;
  theft_hash tmp ;

  {
  theft_hash_init(& h);
  theft_hash_sink(& h, data, bytes);
  tmp = theft_hash_done(& h);
  return (tmp);
}
}
