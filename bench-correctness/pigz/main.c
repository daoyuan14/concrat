/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef __uint16_t __uint_least16_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __off64_t off_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef unsigned long pthread_t;
typedef unsigned int pthread_key_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef void (*__sighandler_t)(int  );
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
typedef __uint32_t uint32_t;
typedef __uint_least16_t uint_least16_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
typedef uintmax_t length_t;
typedef uint32_t crc_t;
typedef uint_least16_t index_t;
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
typedef unsigned int z_crc_t;
struct internal_state ;
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
typedef z_stream *z_streamp;
struct thread_s ;
typedef struct thread_s thread;
struct lock_s ;
typedef struct lock_s lock;
enum twist_op {
    TO = 0,
    BY = 1
} ;
enum wait_op {
    TO_BE = 0,
    NOT_TO_BE = 1,
    TO_BE_MORE_THAN = 2,
    TO_BE_LESS_THAN = 3
} ;
struct ZopfliOptions {
   int verbose ;
   int verbose_more ;
   int numiterations ;
   int blocksplitting ;
   int blocksplittinglast ;
   int blocksplittingmax ;
};
typedef struct ZopfliOptions ZopfliOptions;
typedef long __jmp_buf[8];
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag jmp_buf[1];
struct __anonstruct_try_ball_t__852378850 {
   int ret ;
   int code ;
   int free ;
   char *why ;
};
typedef struct __anonstruct_try_ball_t__852378850 try_ball_t_;
struct try_s_ ;
typedef struct try_s_ try_t_;
struct try_s_ {
   jmp_buf env ;
   try_ball_t_ ball ;
   try_t_ *next ;
};
struct __anonstruct_g_4656454 {
   int ret ;
   char *prog ;
   int ind ;
   int outd ;
   char *inf ;
   size_t inz ;
   char *outf ;
   int verbosity ;
   int headis ;
   int pipeout ;
   int keep ;
   int force ;
   int sync ;
   int form ;
   int magic1 ;
   int recurse ;
   char *sufx ;
   char *name ;
   char *alias ;
   char *comment ;
   time_t mtime ;
   int list ;
   int first ;
   int decode ;
   int level ;
   int strategy ;
   ZopfliOptions zopts ;
   int rsync ;
   int procs ;
   int setdict ;
   size_t block ;
   crc_t shift ;
   time_t stamp ;
   char *hname ;
   char *hcomm ;
   unsigned long zip_crc ;
   length_t zip_clen ;
   length_t zip_ulen ;
   int zip64 ;
   unsigned char in_buf[32810] ;
   unsigned char *in_next ;
   size_t in_left ;
   int in_eof ;
   int in_short ;
   length_t in_tot ;
   length_t out_tot ;
   unsigned long out_check ;
   unsigned char in_buf2[32810] ;
   size_t in_len ;
   int in_which ;
   lock *load_state ;
   thread *load_thread ;
};
typedef length_t val_t;
struct pool ;
struct space {
   lock *use ;
   unsigned char *buf ;
   size_t size ;
   size_t len ;
   struct pool *pool ;
   struct space *next ;
};
struct pool {
   lock *have ;
   struct space *head ;
   size_t size ;
   int limit ;
   int made ;
};
struct job {
   long seq ;
   int more ;
   struct space *in ;
   struct space *out ;
   struct space *lens ;
   unsigned long check ;
   lock *calc ;
   struct job *next ;
};
typedef unsigned long bits_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_663920920 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_424895811 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_424895810 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_424895811 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_663920920 __annonCompField1 ;
   union __anonunion____missing_field_name_424895810 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct __anonstruct___cancel_jmp_buf_572769531 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
struct __anonstruct___pthread_unwind_buf_t_1025859739 {
   struct __anonstruct___cancel_jmp_buf_572769531 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
typedef struct __anonstruct___pthread_unwind_buf_t_1025859739  __attribute__((__aligned__)) __pthread_unwind_buf_t;
struct lock_s {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   long value ;
};
struct thread_s {
   pthread_t id ;
   int done ;
   thread *next ;
};
struct capsule {
   void (*probe)(void * ) ;
   void *payload ;
   char const   *file ;
   long line ;
};
typedef int pthread_once_t;
struct ZopfliLongestMatchCache {
   unsigned short *length ;
   unsigned short *dist ;
   unsigned char *sublen ;
};
typedef struct ZopfliLongestMatchCache ZopfliLongestMatchCache;
struct ZopfliLZ77Store {
   unsigned short *litlens ;
   unsigned short *dists ;
   size_t size ;
   unsigned char const   *data ;
   size_t *pos ;
   unsigned short *ll_symbol ;
   unsigned short *d_symbol ;
   size_t *ll_counts ;
   size_t *d_counts ;
};
typedef struct ZopfliLZ77Store ZopfliLZ77Store;
struct ZopfliBlockState {
   ZopfliOptions const   *options ;
   ZopfliLongestMatchCache *lmc ;
   size_t blockstart ;
   size_t blockend ;
};
typedef struct ZopfliBlockState ZopfliBlockState;
struct ZopfliHash {
   int *head ;
   unsigned short *prev ;
   int *hashval ;
   int val ;
   int *head2 ;
   unsigned short *prev2 ;
   int *hashval2 ;
   int val2 ;
   unsigned short *same ;
};
typedef struct ZopfliHash ZopfliHash;
typedef double FindMinimumFun(size_t i , void *context );
struct SplitCostContext {
   ZopfliLZ77Store const   *lz77 ;
   size_t start ;
   size_t end ;
};
typedef struct SplitCostContext SplitCostContext;
struct SymbolStats {
   size_t litlens[288] ;
   size_t dists[32] ;
   double ll_symbols[288] ;
   double d_symbols[32] ;
};
typedef struct SymbolStats SymbolStats;
struct RanState {
   unsigned int m_w ;
   unsigned int m_z ;
};
typedef struct RanState RanState;
typedef double CostModelFun(unsigned int litlen , unsigned int dist , void *context );
struct Node ;
typedef struct Node Node;
struct Node {
   size_t weight ;
   Node *tail ;
   int count ;
};
struct NodePool {
   Node *next ;
};
typedef struct NodePool NodePool;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-gO9F4Wj5.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern int puts(char const   *__s ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf )  __asm__("__fxstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf )  __asm__("__xstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf )  __asm__("__lxstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag )  __asm__("__fxstatat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern int fsync(int __fd ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern char const   *zlibVersion(void) ;
extern int deflate(z_streamp strm , int flush ) ;
extern int deflateEnd(z_streamp strm ) ;
extern int deflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
extern int deflateReset(z_streamp strm ) ;
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
extern int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) ;
extern int deflatePrime(z_streamp strm , int bits , int value ) ;
extern int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                       void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                       void *out_desc ) ;
extern int inflateBackEnd(z_streamp strm ) ;
extern uLong adler32(uLong adler , Bytef const   *buf , uInt len ) ;
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
extern int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window ,
                            char const   *version , int stream_size ) ;
extern z_crc_t const   *get_crc_table(void) ;
char *yarn_prefix ;
void (*yarn_abort)(int  ) ;
thread *launch_(void (*probe)(void * ) , void *payload , char const   *file , long line ) ;
void join_(thread *ally , char const   *file , long line ) ;
int join_all_(char const   *file , long line ) ;
lock *new_lock_(long initial , char const   *file , long line ) ;
void possess_(lock *bolt , char const   *file , long line ) ;
void release_(lock *bolt , char const   *file , long line ) ;
void twist_(lock *bolt , enum twist_op op , long val , char const   *file , long line ) ;
void wait_for_(lock *bolt , enum wait_op op , long val , char const   *file , long line ) ;
long peek_lock(lock *bolt ) ;
void free_lock_(lock *bolt , char const   *file , long line ) ;
void ZopfliInitOptions(ZopfliOptions *options ) ;
void ZopfliDeflatePart(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in___0 ,
                       size_t instart , size_t inend , unsigned char *bp , unsigned char **out___0 ,
                       size_t *outsize ) ;
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
pthread_key_t try_key_ ;
void try_setup_(void) ;
 __attribute__((__noreturn__)) void try_throw_(int code , char *fmt  , ...) ;
static struct __anonstruct_g_4656454 g  ;
static void message(char *fmt , va_list___0 ap ) 
{ 


  {
  if (g.verbosity > 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", g.prog);
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, ap);
    putc('\n', stderr);
    fflush(stderr);
  }
  return;
}
}
static int complain(char *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  g.ret = 1;
  __builtin_va_start(ap, fmt);
  message(fmt, ap);
  __builtin_va_end(ap);
  return (0);
}
}
static int grumble(char *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  __builtin_va_start(ap, fmt);
  message(fmt, ap);
  __builtin_va_end(ap);
  return (0);
}
}
static void *alloc(void *ptr , size_t size ) 
{ 


  {
  ptr = realloc(ptr, size);
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    try_throw_(12, (char *)"not enough memory", (void *)0);
  }
  return (ptr);
}
}
static void cut_short(int sig ) 
{ 
  int tmp ;

  {
  if (g.outd != -1) {
    if (g.outd != 1) {
      unlink((char const   *)g.outf);
      while (1) {
        if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
          free((void *)g.outf);
          g.outf = (char *)((void *)0);
        }
        break;
      }
      g.outd = -1;
    }
  }
  if (sig < 0) {
    tmp = - sig;
  } else {
    tmp = 4;
  }
  _exit(tmp);
}
}
__inline static size_t grow(size_t size ) 
{ 
  size_t was ;
  size_t top ;
  int shift ;

  {
  was = size;
  size += size >> 2;
  top = size;
  shift = 0;
  while (top > 7UL) {
    top >>= 1;
    shift ++;
  }
  if (top == 7UL) {
    size = 1UL << (shift + 3);
  }
  if (size < 16UL) {
    size = (size_t )16;
  }
  if (size <= was) {
    size = 18446744073709551615;
  }
  return (size);
}
}
__inline static size_t vmemcpy(char **mem , size_t *size , size_t off , void *cpy ,
                               size_t len ) 
{ 
  size_t need ;
  void *tmp ;

  {
  need = off + len;
  if (need < off) {
    try_throw_(34, (char *)"overflow", (void *)0);
  }
  if (need > *size) {
    need = grow(need);
    if (off == 0UL) {
      while (1) {
        if ((unsigned long )*mem != (unsigned long )((void *)0)) {
          free((void *)*mem);
          *mem = (char *)((void *)0);
        }
        break;
      }
      *size = (size_t )0;
    }
    tmp = alloc((void *)*mem, need);
    *mem = (char *)tmp;
    *size = need;
  }
  memcpy((void * __restrict  )(*mem + off), (void const   * __restrict  )cpy, len);
  return (off + len);
}
}
__inline static size_t vstrcpy(char **str , size_t *size , size_t off , void *cpy ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen((char const   *)cpy);
  tmp___0 = vmemcpy(str, size, off, cpy, tmp + 1UL);
  return (tmp___0);
}
}
static size_t readn(int desc , unsigned char *buf , size_t len ) 
{ 
  ssize_t ret ;
  size_t got ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  got = (size_t )0;
  while (len) {
    ret = read(desc, (void *)buf, len);
    if (ret < 0L) {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      tmp___1 = __errno_location();
      try_throw_(*tmp___1, (char *)"read error on %s (%s)", g.inf, tmp___0, (void *)0);
    }
    if (ret == 0L) {
      break;
    }
    buf += ret;
    len -= (size_t )ret;
    got += (size_t )ret;
  }
  return (got);
}
}
static size_t writen(int desc , void const   *buf , size_t len ) 
{ 
  char const   *next___0 ;
  size_t left ;
  size_t max ;
  ssize_t ret ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  next___0 = (char const   *)buf;
  left = len;
  while (left) {
    max = (size_t )9223372036854775807L;
    if (left > max) {
      tmp = max;
    } else {
      tmp = left;
    }
    tmp___0 = write(desc, (void const   *)next___0, tmp);
    ret = tmp___0;
    if (ret < 1L) {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      tmp___3 = __errno_location();
      try_throw_(*tmp___3, (char *)"write error on %s (%s)", g.outf, tmp___2, (void *)0);
    }
    next___0 += ret;
    left -= (size_t )ret;
  }
  return (len);
}
}
static unsigned long time2dos(time_t t ) 
{ 
  struct tm *tm ;
  unsigned long dos ;

  {
  if (t == 0L) {
    t = time((time_t *)((void *)0));
  }
  tm = localtime((time_t const   *)(& t));
  if (tm->tm_year < 80) {
    return (0UL);
  } else
  if (tm->tm_year > 207) {
    return (0UL);
  }
  dos = (unsigned long )(tm->tm_year - 80) << 25;
  dos += (unsigned long )(tm->tm_mon + 1) << 21;
  dos += (unsigned long )tm->tm_mday << 16;
  dos += (unsigned long )tm->tm_hour << 11;
  dos += (unsigned long )tm->tm_min << 5;
  dos += (unsigned long )(tm->tm_sec + 1) >> 1;
  return (dos);
}
}
static unsigned int put(int out___0  , ...) 
{ 
  unsigned int count ;
  int n ;
  va_list___0 ap ;
  val_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *wrap ;
  void *tmp___3 ;
  unsigned char *next___0 ;
  val_t val ;
  val_t tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;

  {
  count = 0U;
  __builtin_va_start(ap, out___0);
  while (1) {
    tmp___2 = __builtin_va_arg(ap, int );
    n = tmp___2;
    if (! (n != 0)) {
      break;
    }
    tmp___0 = __builtin_va_arg(ap, val_t );
    tmp___1 = abs(n);
    count += (unsigned int )tmp___1;
  }
  __builtin_va_end(ap);
  tmp___3 = alloc((void *)0, (size_t )count);
  wrap = (unsigned char *)tmp___3;
  next___0 = wrap;
  __builtin_va_start(ap, out___0);
  while (1) {
    tmp___8 = __builtin_va_arg(ap, int );
    n = tmp___8;
    if (! (n != 0)) {
      break;
    }
    tmp___5 = __builtin_va_arg(ap, val_t );
    val = tmp___5;
    if (n < 0) {
      n = - n << 3;
      while (1) {
        n -= 8;
        tmp___6 = next___0;
        next___0 ++;
        *tmp___6 = (unsigned char )(val >> n);
        if (! n) {
          break;
        }
      }
    } else {
      while (1) {
        tmp___7 = next___0;
        next___0 ++;
        *tmp___7 = (unsigned char )val;
        val >>= 8;
        n --;
        if (! n) {
          break;
        }
      }
    }
  }
  __builtin_va_end(ap);
  writen(out___0, (void const   *)wrap, (size_t )count);
  free((void *)wrap);
  return (count);
}
}
static length_t put_header(void) 
{ 
  length_t len ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int head ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;

  {
  if (g.form > 1) {
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp = g.alias;
    } else {
      tmp = g.name;
    }
    tmp___0 = strlen((char const   *)tmp);
    tmp___1 = time2dos(g.mtime);
    tmp___2 = put(g.outd, 4, (val_t )67324752, 2, (val_t )45, 2, (val_t )8, 2, (val_t )8,
                  4, tmp___1, 4, (val_t )0, 4, (val_t )4294967295U, 4, (val_t )4294967295U,
                  2, tmp___0, 2, (val_t )29, 0);
    len = (length_t )tmp___2;
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___3 = g.alias;
    } else {
      tmp___3 = g.name;
    }
    tmp___4 = strlen((char const   *)tmp___3);
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___5 = g.alias;
    } else {
      tmp___5 = g.name;
    }
    tmp___6 = writen(g.outd, (void const   *)tmp___5, tmp___4);
    len += tmp___6;
    tmp___7 = put(g.outd, 2, (val_t )1, 2, (val_t )16, 8, (val_t )0, 8, (val_t )0,
                  2, (val_t )21589, 2, (val_t )5, 1, (val_t )1, 4, (val_t )g.mtime,
                  0);
    len += (length_t )tmp___7;
  } else
  if (g.form) {
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      complain((char *)"can\'t store comment in zlib format -- ignoring");
    }
    if (g.level >= 9) {
      tmp___10 = 3 << 6;
    } else {
      if (g.level == 1) {
        tmp___9 = 0;
      } else {
        if (g.level >= 6) {
          tmp___8 = 1 << 6;
        } else
        if (g.level == -1) {
          tmp___8 = 1 << 6;
        } else {
          tmp___8 = 2 << 6;
        }
        tmp___9 = tmp___8;
      }
      tmp___10 = tmp___9;
    }
    head = (unsigned int )((120 << 8) + tmp___10);
    head += 31U - head % 31U;
    tmp___11 = put(g.outd, -2, (val_t )head, 0);
    len = (length_t )tmp___11;
  } else {
    if (g.level >= 9) {
      tmp___13 = 2;
    } else {
      if (g.level == 1) {
        tmp___12 = 4;
      } else {
        tmp___12 = 0;
      }
      tmp___13 = tmp___12;
    }
    if ((unsigned long )g.name != (unsigned long )((void *)0)) {
      tmp___14 = 8;
    } else {
      tmp___14 = 0;
    }
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      tmp___15 = 16;
    } else {
      tmp___15 = 0;
    }
    tmp___16 = put(g.outd, 1, (val_t )31, 1, (val_t )139, 1, (val_t )8, 1, (val_t )(tmp___14 + tmp___15),
                   4, (val_t )g.mtime, 1, (val_t )tmp___13, 1, (val_t )3, 0);
    len = (length_t )tmp___16;
    if ((unsigned long )g.name != (unsigned long )((void *)0)) {
      tmp___17 = strlen((char const   *)g.name);
      tmp___18 = writen(g.outd, (void const   *)g.name, tmp___17 + 1UL);
      len += tmp___18;
    }
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      tmp___19 = strlen((char const   *)g.comment);
      tmp___20 = writen(g.outd, (void const   *)g.comment, tmp___19 + 1UL);
      len += tmp___20;
    }
  }
  return (len);
}
}
static void put_trailer(length_t ulen , length_t clen , unsigned long check , length_t head ) 
{ 
  length_t desc ;
  unsigned int tmp ;
  int zip64 ;
  int tmp___0 ;
  length_t cent ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  length_t tmp___6 ;
  length_t tmp___7 ;
  unsigned long tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  length_t tmp___18 ;
  length_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  if (g.form > 1) {
    tmp = put(g.outd, 4, (val_t )134695760, 4, check, 8, clen, 8, ulen, 0);
    desc = (length_t )tmp;
    if (ulen >= 4294967295UL) {
      tmp___0 = 1;
    } else
    if (clen >= 4294967295UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    zip64 = tmp___0;
    if ((unsigned long )g.comment == (unsigned long )((void *)0)) {
      tmp___2 = (size_t )0;
    } else {
      tmp___1 = strlen((char const   *)g.comment);
      tmp___2 = tmp___1;
    }
    if (zip64) {
      tmp___3 = 29;
    } else {
      tmp___3 = 9;
    }
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___4 = g.alias;
    } else {
      tmp___4 = g.name;
    }
    tmp___5 = strlen((char const   *)tmp___4);
    if (zip64) {
      tmp___6 = (length_t )4294967295U;
    } else {
      tmp___6 = ulen;
    }
    if (zip64) {
      tmp___7 = (length_t )4294967295U;
    } else {
      tmp___7 = clen;
    }
    tmp___8 = time2dos(g.mtime);
    tmp___9 = put(g.outd, 4, (val_t )33639248, 1, (val_t )45, 1, (val_t )255, 2, (val_t )45,
                  2, (val_t )8, 2, (val_t )8, 4, tmp___8, 4, check, 4, tmp___7, 4,
                  tmp___6, 2, tmp___5, 2, (val_t )tmp___3, 2, tmp___2, 2, (val_t )0,
                  2, (val_t )0, 4, (val_t )0, 4, (val_t )0, 0);
    cent = (length_t )tmp___9;
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___10 = g.alias;
    } else {
      tmp___10 = g.name;
    }
    tmp___11 = strlen((char const   *)tmp___10);
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___12 = g.alias;
    } else {
      tmp___12 = g.name;
    }
    tmp___13 = writen(g.outd, (void const   *)tmp___12, tmp___11);
    cent += tmp___13;
    if (zip64) {
      tmp___14 = put(g.outd, 2, (val_t )1, 2, (val_t )16, 8, ulen, 8, clen, 0);
      cent += (length_t )tmp___14;
    }
    tmp___15 = put(g.outd, 2, (val_t )21589, 2, (val_t )5, 1, (val_t )1, 4, (val_t )g.mtime,
                   0);
    cent += (length_t )tmp___15;
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      tmp___16 = strlen((char const   *)g.comment);
      tmp___17 = writen(g.outd, (void const   *)g.comment, tmp___16);
      cent += tmp___17;
    }
    zip64 = (head + clen) + desc >= 4294967295UL;
    if (zip64) {
      put(g.outd, 4, (val_t )101075792, 8, (val_t )44, 2, (val_t )45, 2, (val_t )45,
          4, (val_t )0, 4, (val_t )0, 8, (val_t )1, 8, (val_t )1, 8, cent, 8, (head + clen) + desc,
          4, (val_t )117853008, 4, (val_t )0, 8, ((head + clen) + desc) + cent, 4,
          (val_t )1, 0);
    }
    if (zip64) {
      tmp___18 = (length_t )4294967295U;
    } else {
      tmp___18 = (head + clen) + desc;
    }
    if (zip64) {
      tmp___19 = (length_t )4294967295U;
    } else {
      tmp___19 = cent;
    }
    if (zip64) {
      tmp___20 = 65535;
    } else {
      tmp___20 = 1;
    }
    if (zip64) {
      tmp___21 = 65535;
    } else {
      tmp___21 = 1;
    }
    put(g.outd, 4, (val_t )101010256, 2, (val_t )0, 2, (val_t )0, 2, (val_t )tmp___21,
        2, (val_t )tmp___20, 4, tmp___19, 4, tmp___18, 2, (val_t )0, 0);
  } else
  if (g.form) {
    put(g.outd, -4, check, 0);
  } else {
    put(g.outd, 4, check, 4, ulen, 0);
  }
  return;
}
}
static unsigned long adler32z(unsigned long adler , unsigned char const   *buf , size_t len ) 
{ 
  uLong tmp ;

  {
  while (1) {
    if (len > 4294967295UL) {
      if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    adler = adler32(adler, buf, 4294967295U);
    buf += 4294967295U;
    len -= 4294967295UL;
  }
  tmp = adler32(adler, buf, (unsigned int )len);
  return (tmp);
}
}
static unsigned long crc32z(unsigned long crc , unsigned char const   *buf , size_t len ) 
{ 
  uLong tmp ;

  {
  while (1) {
    if (len > 4294967295UL) {
      if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    crc = crc32(crc, buf, 4294967295U);
    buf += 4294967295U;
    len -= 4294967295UL;
  }
  tmp = crc32(crc, buf, (unsigned int )len);
  return (tmp);
}
}
static long zlib_vernum(void) 
{ 
  char const   *ver ;
  char const   *tmp ;
  long num___0 ;
  int left ;
  int comp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = zlibVersion();
  ver = tmp;
  num___0 = 0L;
  left = 4;
  comp = 0;
  while (1) {
    if ((int const   )*ver >= 48) {
      if ((int const   )*ver <= 57) {
        comp = (10 * comp + (int )*ver) - 48;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (comp > 15) {
        tmp___0 = 15;
      } else {
        tmp___0 = comp;
      }
      num___0 = (num___0 << 4) + (long )tmp___0;
      left --;
      if ((int const   )*ver != 46) {
        break;
      }
      comp = 0;
    }
    ver ++;
    if (! left) {
      break;
    }
  }
  if (left < 2) {
    tmp___1 = num___0 << (left << 2);
  } else {
    tmp___1 = -1L;
  }
  return (tmp___1);
}
}
static crc_t multmodp(crc_t a , crc_t b ) 
{ 
  crc_t m ;
  crc_t p ;

  {
  m = 1U << 31;
  p = (crc_t )0;
  while (1) {
    if (a & m) {
      p ^= b;
      if ((a & (m - 1U)) == 0U) {
        break;
      }
    }
    m >>= 1;
    if (b & 1U) {
      b = (b >> 1) ^ 3988292384U;
    } else {
      b >>= 1;
    }
  }
  return (p);
}
}
static crc_t const   x2n_table[32]  = 
  {      (crc_t const   )1073741824,      (crc_t const   )536870912,      (crc_t const   )134217728,      (crc_t const   )8388608, 
        (crc_t const   )32768,      (crc_t const   )3988292384U,      (crc_t const   )2984685714U,      (crc_t const   )2691310871U, 
        (crc_t const   )3982654894U,      (crc_t const   )2295415911U,      (crc_t const   )3619421802U,      (crc_t const   )3963911953U, 
        (crc_t const   )2390663536U,      (crc_t const   )1680310286,      (crc_t const   )1296546528,      (crc_t const   )167662735, 
        (crc_t const   )2206543119U,      (crc_t const   )808857370,      (crc_t const   )2069535939,      (crc_t const   )838779241, 
        (crc_t const   )2683044394U,      (crc_t const   )1821240772,      (crc_t const   )366380877,      (crc_t const   )1608415822, 
        (crc_t const   )3134787127U,      (crc_t const   )776888047,      (crc_t const   )1319870996,      (crc_t const   )2829349568U, 
        (crc_t const   )1117427358,      (crc_t const   )344797226,      (crc_t const   )3289097936U,      (crc_t const   )3303156796U};
static crc_t x2nmodp(size_t n , unsigned int k ) 
{ 
  crc_t p ;

  {
  p = 1U << 31;
  while (n) {
    if (n & 1UL) {
      p = multmodp((crc_t )x2n_table[k & 31U], p);
    }
    n >>= 1;
    k ++;
  }
  return (p);
}
}
static unsigned long crc32_comb(unsigned long crc1 , unsigned long crc2 , size_t len2 ) 
{ 
  crc_t tmp ;
  crc_t tmp___0 ;
  crc_t tmp___1 ;

  {
  if (len2 == g.block) {
    tmp___0 = g.shift;
  } else {
    tmp = x2nmodp(len2, 3U);
    tmp___0 = tmp;
  }
  tmp___1 = multmodp(tmp___0, (crc_t )crc1);
  return ((unsigned long )tmp___1 ^ crc2);
}
}
static unsigned long adler32_comb(unsigned long adler1 , unsigned long adler2 , size_t len2 ) 
{ 
  unsigned long sum1 ;
  unsigned long sum2 ;
  unsigned int rem ;

  {
  rem = (unsigned int )(len2 % 65521UL);
  sum1 = adler1 & 65535UL;
  sum2 = ((unsigned long )rem * sum1) % 65521UL;
  sum1 += ((adler2 & 65535UL) + 65521UL) - 1UL;
  sum2 += ((((adler1 >> 16) & 65535UL) + ((adler2 >> 16) & 65535UL)) + 65521UL) - (unsigned long )rem;
  if (sum1 >= 65521UL) {
    sum1 -= 65521UL;
  }
  if (sum1 >= 65521UL) {
    sum1 -= 65521UL;
  }
  if (sum2 >= (unsigned long )(65521U << 1)) {
    sum2 -= (unsigned long )(65521U << 1);
  }
  if (sum2 >= 65521UL) {
    sum2 -= 65521UL;
  }
  return (sum1 | (sum2 << 16));
}
}
static void new_pool(struct pool *pool , size_t size , int limit ) 
{ 


  {
  pool->have = new_lock_(0L, "pigz.c", 1457L);
  pool->head = (struct space *)((void *)0);
  pool->size = size;
  pool->limit = limit;
  pool->made = 0;
  return;
}
}
static struct space *get_space(struct pool *pool ) 
{ 
  struct space *space ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  possess_(pool->have, "pigz.c", 1470L);
  if (pool->limit == 0) {
    wait_for_(pool->have, (enum wait_op )1, 0L, "pigz.c", 1472L);
  }
  if ((unsigned long )pool->head != (unsigned long )((void *)0)) {
    space = pool->head;
    pool->head = space->next;
    twist_(pool->have, (enum twist_op )1, -1L, "pigz.c", 1478L);
    possess_(space->use, "pigz.c", 1479L);
    twist_(space->use, (enum twist_op )0, 1L, "pigz.c", 1480L);
    space->len = (size_t )0;
    return (space);
  }
  if (! (pool->limit != 0)) {
    __assert_fail("pool->limit != 0", "pigz.c", 1486U, "get_space");
  }
  if (pool->limit > 0) {
    (pool->limit) --;
  }
  (pool->made) ++;
  release_(pool->have, "pigz.c", 1490L);
  tmp___0 = alloc((void *)0, sizeof(struct space ));
  space = (struct space *)tmp___0;
  space->use = new_lock_(1L, "pigz.c", 1492L);
  tmp___1 = alloc((void *)0, pool->size);
  space->buf = (unsigned char *)tmp___1;
  space->size = pool->size;
  space->len = (size_t )0;
  space->pool = pool;
  return (space);
}
}
static void grow_space(struct space *space ) 
{ 
  size_t more ;
  void *tmp ;

  {
  more = grow(space->size);
  if (more == space->size) {
    try_throw_(34, (char *)"overflow", (void *)0);
  }
  tmp = alloc((void *)space->buf, more);
  space->buf = (unsigned char *)tmp;
  space->size = more;
  return;
}
}
static void use_space(struct space *space ) 
{ 
  long use ;

  {
  possess_(space->use, "pigz.c", 1519L);
  use = peek_lock(space->use);
  if (! (use != 0L)) {
    __assert_fail("use != 0", "pigz.c", 1521U, "use_space");
  }
  twist_(space->use, (enum twist_op )1, 1L, "pigz.c", 1522L);
  return;
}
}
static void drop_space(struct space *space ) 
{ 
  long use ;
  struct pool *pool ;

  {
  if ((unsigned long )space == (unsigned long )((void *)0)) {
    return;
  }
  possess_(space->use, "pigz.c", 1532L);
  use = peek_lock(space->use);
  if (! (use != 0L)) {
    __assert_fail("use != 0", "pigz.c", 1534U, "drop_space");
  }
  twist_(space->use, (enum twist_op )1, -1L, "pigz.c", 1535L);
  if (use == 1L) {
    pool = space->pool;
    possess_(pool->have, "pigz.c", 1538L);
    space->next = pool->head;
    pool->head = space;
    twist_(pool->have, (enum twist_op )1, 1L, "pigz.c", 1541L);
  }
  return;
}
}
static int free_pool(struct pool *pool ) 
{ 
  int count ;
  struct space *space ;

  {
  possess_(pool->have, "pigz.c", 1551L);
  count = 0;
  while (1) {
    space = pool->head;
    if (! ((unsigned long )space != (unsigned long )((void *)0))) {
      break;
    }
    pool->head = space->next;
    free((void *)space->buf);
    free_lock_(space->use, "pigz.c", 1556L);
    free((void *)space);
    count ++;
  }
  if (! (count == pool->made)) {
    __assert_fail("count == pool->made", "pigz.c", 1560U, "free_pool");
  }
  release_(pool->have, "pigz.c", 1561L);
  free_lock_(pool->have, "pigz.c", 1562L);
  return (count);
}
}
static struct pool in_pool  ;
static struct pool out_pool  ;
static struct pool dict_pool  ;
static struct pool lens_pool  ;
static lock *compress_have  =    (lock *)((void *)0);
static struct job *compress_head  ;
static struct job **compress_tail  ;
static lock *write_first  ;
static struct job *write_head  ;
static int cthreads  =    0;
static thread *writeth  =    (thread *)((void *)0);
static void setup_jobs(void) 
{ 


  {
  if ((unsigned long )compress_have != (unsigned long )((void *)0)) {
    return;
  }
  compress_have = new_lock_(0L, "pigz.c", 1609L);
  compress_head = (struct job *)((void *)0);
  compress_tail = & compress_head;
  write_first = new_lock_(-1L, "pigz.c", 1612L);
  write_head = (struct job *)((void *)0);
  new_pool(& in_pool, g.block, (g.procs << 1) + 3);
  new_pool(& out_pool, (g.block + (g.block >> 4)) + 32768UL, -1);
  new_pool(& dict_pool, (size_t )32768U, -1);
  new_pool(& lens_pool, g.block >> 11, -1);
  return;
}
}
static void finish_jobs(void) 
{ 
  struct job job ;
  int caught ;

  {
  if ((unsigned long )compress_have == (unsigned long )((void *)0)) {
    return;
  }
  possess_(compress_have, "pigz.c", 1635L);
  job.seq = -1L;
  job.next = (struct job *)((void *)0);
  compress_head = & job;
  compress_tail = & job.next;
  twist_(compress_have, (enum twist_op )1, 1L, "pigz.c", 1640L);
  caught = join_all_("pigz.c", 1643L);
  if (! (caught == cthreads)) {
    __assert_fail("caught == cthreads", "pigz.c", 1645U, "finish_jobs");
  }
  cthreads = 0;
  caught = free_pool(& lens_pool);
  caught = free_pool(& dict_pool);
  caught = free_pool(& out_pool);
  caught = free_pool(& in_pool);
  free_lock_(write_first, "pigz.c", 1657L);
  free_lock_(compress_have, "pigz.c", 1658L);
  compress_have = (lock *)((void *)0);
  return;
}
}
static void deflate_engine(z_stream *strm___0 , struct space *out___0 , int flush ) 
{ 
  size_t room ;

  {
  while (1) {
    room = out___0->size - out___0->len;
    if (room == 0UL) {
      grow_space(out___0);
      room = out___0->size - out___0->len;
    }
    strm___0->next_out = out___0->buf + out___0->len;
    if (room < 4294967295UL) {
      strm___0->avail_out = (unsigned int )room;
    } else {
      strm___0->avail_out = 4294967295U;
    }
    deflate(strm___0, flush);
    out___0->len = (size_t )(strm___0->next_out - out___0->buf);
    if (! (strm___0->avail_out == 0U)) {
      break;
    }
  }
  if (! (strm___0->avail_in == 0U)) {
    __assert_fail("strm->avail_in == 0", "pigz.c", 1680U, "deflate_engine");
  }
  return;
}
}
static void compress_thread(void *dummy ) 
{ 
  struct job *job ;
  struct job *here ;
  struct job **prior ;
  unsigned long check ;
  unsigned char *next___0 ;
  size_t left ;
  size_t len ;
  int bits ;
  int ret ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  z_stream strm___0 ;
  struct space *temp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  long tmp___13 ;
  unsigned char bits___0 ;
  unsigned char *out___0 ;
  size_t outsize ;
  int tmp___14 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  unsigned long tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  unsigned long tmp___32 ;
  int tmp___33 ;
  int tmp___37 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 1703U, "compress_thread");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 1703U, "compress_thread");
      }
      break;
    }
    tmp___33 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___33 == 0) {
      while (1) {
        temp = (struct space *)((void *)0);
        if (g.level > 9) {
          temp = get_space(& out_pool);
        } else {
          strm___0.zfree = (void (*)(voidpf opaque , voidpf address ))0;
          strm___0.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
          strm___0.opaque = (voidpf )0;
          ret = deflateInit2_(& strm___0, 6, 8, -15, 8, g.strategy, "1.2.11", (int )sizeof(z_stream ));
          if (ret == -4) {
            try_throw_(12, (char *)"not enough memory", (void *)0);
          }
          if (ret != 0) {
            try_throw_(22, (char *)"internal error", (void *)0);
          }
        }
        while (1) {
          possess_(compress_have, "pigz.c", 1727L);
          wait_for_(compress_have, (enum wait_op )1, 0L, "pigz.c", 1728L);
          job = compress_head;
          if (! ((unsigned long )job != (unsigned long )((void *)0))) {
            __assert_fail("job != NULL", "pigz.c", 1730U, "compress_thread");
          }
          if (job->seq == -1L) {
            break;
          }
          compress_head = job->next;
          if ((unsigned long )job->next == (unsigned long )((void *)0)) {
            compress_tail = & compress_head;
          }
          twist_(compress_have, (enum twist_op )1, -1L, "pigz.c", 1736L);
          if (g.level <= 9) {
            deflateReset(& strm___0);
            deflateParams(& strm___0, g.level, g.strategy);
          } else {
            temp->len = (size_t )0;
          }
          if ((unsigned long )job->out != (unsigned long )((void *)0)) {
            len = (job->out)->len;
            if (len < 32768UL) {
              left = len;
            } else {
              left = (size_t )32768U;
            }
            if (g.level <= 9) {
              deflateSetDictionary(& strm___0, (Bytef const   *)((job->out)->buf + (len - left)),
                                   (unsigned int )left);
            } else {
              memcpy((void * __restrict  )temp->buf, (void const   * __restrict  )((job->out)->buf + (len - left)),
                     left);
              temp->len = left;
            }
            drop_space(job->out);
          }
          job->out = get_space(& out_pool);
          if (g.level <= 9) {
            strm___0.next_in = (job->in)->buf;
            strm___0.next_out = (job->out)->buf;
          } else {
            memcpy((void * __restrict  )(temp->buf + temp->len), (void const   * __restrict  )(job->in)->buf,
                   (job->in)->len);
          }
          if ((unsigned long )job->lens == (unsigned long )((void *)0)) {
            next___0 = (unsigned char *)((void *)0);
          } else {
            next___0 = (job->lens)->buf;
          }
          left = (job->in)->len;
          (job->out)->len = (size_t )0;
          while (1) {
            if ((unsigned long )next___0 == (unsigned long )((void *)0)) {
              len = (size_t )128;
            } else {
              tmp___5 = next___0;
              next___0 ++;
              len = (size_t )*tmp___5;
            }
            if (len < 128UL) {
              tmp___6 = next___0;
              next___0 ++;
              len = ((len << 8) + (size_t )*tmp___6) + 64UL;
            } else
            if (len == 128UL) {
              len = left;
            } else
            if (len < 192UL) {
              len &= 63UL;
            } else
            if (len < 224UL) {
              tmp___7 = next___0;
              next___0 ++;
              len = ((len & 31UL) << 16) + ((size_t )*tmp___7 << 8);
              tmp___8 = next___0;
              next___0 ++;
              len += (size_t )((unsigned int )*tmp___8 + 32832U);
            } else {
              tmp___9 = next___0;
              next___0 ++;
              len = ((len & 31UL) << 24) + ((size_t )*tmp___9 << 16);
              tmp___10 = next___0;
              next___0 ++;
              len += (size_t )*tmp___10 << 8;
              tmp___11 = next___0;
              next___0 ++;
              len += (size_t )*tmp___11 + 2129984UL;
            }
            left -= len;
            if (g.level <= 9) {
              while (len > (size_t )(4294967295U - (4294967295U >> 1))) {
                strm___0.avail_in = 4294967295U - (4294967295U >> 1);
                deflate_engine(& strm___0, job->out, 0);
                len -= (size_t )(4294967295U - (4294967295U >> 1));
              }
              strm___0.avail_in = (unsigned int )len;
              if (left) {
                goto _L;
              } else
              if (job->more) {
                _L: /* CIL Label */ 
                tmp___13 = zlib_vernum();
                if (tmp___13 >= 4704L) {
                  deflate_engine(& strm___0, job->out, 5);
                  deflatePending(& strm___0, (unsigned int *)0, & bits);
                  if (bits & 1) {
                    deflate_engine(& strm___0, job->out, 2);
                  } else
                  if (! g.setdict) {
                    deflate_engine(& strm___0, job->out, 2);
                  } else
                  if (bits & 7) {
                    while (1) {
                      bits = deflatePrime(& strm___0, 10, 2);
                      if (! (bits == 0)) {
                        __assert_fail("bits == Z_OK", "pigz.c", 1840U, "compress_thread");
                      }
                      deflatePending(& strm___0, (unsigned int *)0, & bits);
                      if (! (bits & 7)) {
                        break;
                      }
                    }
                    deflate_engine(& strm___0, job->out, 5);
                  }
                } else {
                  deflate_engine(& strm___0, job->out, 2);
                }
                if (! g.setdict) {
                  deflate_engine(& strm___0, job->out, 3);
                }
              } else {
                deflate_engine(& strm___0, job->out, 4);
              }
            } else {
              out___0 = (unsigned char *)((void *)0);
              outsize = (size_t )0;
              bits___0 = (unsigned char)0;
              if (left) {
                tmp___14 = 0;
              } else
              if (job->more) {
                tmp___14 = 0;
              } else {
                tmp___14 = 1;
              }
              ZopfliDeflatePart((ZopfliOptions const   *)(& g.zopts), 2, tmp___14,
                                (unsigned char const   *)temp->buf, temp->len, temp->len + len,
                                & bits___0, & out___0, & outsize);
              if (! (((job->out)->len + outsize) + 5UL <= (job->out)->size)) {
                __assert_fail("job->out->len + outsize + 5 <= job->out->size", "pigz.c",
                              1869U, "compress_thread");
              }
              memcpy((void * __restrict  )((job->out)->buf + (job->out)->len), (void const   * __restrict  )out___0,
                     outsize);
              free((void *)out___0);
              (job->out)->len += outsize;
              if (left) {
                goto _L___1;
              } else
              if (job->more) {
                _L___1: /* CIL Label */ 
                bits___0 = (unsigned char )((int )bits___0 & 7);
                if ((int )bits___0 & 1) {
                  goto _L___0;
                } else
                if (! g.setdict) {
                  _L___0: /* CIL Label */ 
                  if ((int )bits___0 == 0) {
                    tmp___16 = (job->out)->len;
                    ((job->out)->len) ++;
                    *((job->out)->buf + tmp___16) = (unsigned char)0;
                  } else
                  if ((int )bits___0 > 5) {
                    tmp___16 = (job->out)->len;
                    ((job->out)->len) ++;
                    *((job->out)->buf + tmp___16) = (unsigned char)0;
                  }
                  tmp___17 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___17) = (unsigned char)0;
                  tmp___18 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___18) = (unsigned char)0;
                  tmp___19 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___19) = (unsigned char)255;
                  tmp___20 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___20) = (unsigned char)255;
                } else
                if (bits___0) {
                  while (1) {
                    *((job->out)->buf + ((job->out)->len - 1UL)) = (unsigned char )((int )*((job->out)->buf + ((job->out)->len - 1UL)) + (2 << (int )bits___0));
                    tmp___21 = (job->out)->len;
                    ((job->out)->len) ++;
                    *((job->out)->buf + tmp___21) = (unsigned char)0;
                    bits___0 = (unsigned char )((int )bits___0 + 2);
                    if (! ((int )bits___0 < 8)) {
                      break;
                    }
                  }
                }
                if (! g.setdict) {
                  tmp___22 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___22) = (unsigned char)0;
                  tmp___23 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___23) = (unsigned char)0;
                  tmp___24 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___24) = (unsigned char)0;
                  tmp___25 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___25) = (unsigned char)255;
                  tmp___26 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___26) = (unsigned char)255;
                }
              }
              temp->len += len;
            }
            if (! left) {
              break;
            }
          }
          drop_space(job->lens);
          job->lens = (struct space *)((void *)0);
          use_space(job->in);
          possess_(write_first, "pigz.c", 1911L);
          prior = & write_head;
          while (1) {
            here = *prior;
            if (! ((unsigned long )here != (unsigned long )((void *)0))) {
              break;
            }
            if (here->seq > job->seq) {
              break;
            }
            prior = & here->next;
          }
          job->next = here;
          *prior = job;
          twist_(write_first, (enum twist_op )0, write_head->seq, "pigz.c", 1920L);
          len = (job->in)->len;
          next___0 = (job->in)->buf;
          if (g.form == 1) {
            tmp___27 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
            check = tmp___27;
          } else {
            tmp___28 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
            check = tmp___28;
          }
          while (len > (size_t )(4294967295U - (4294967295U >> 1))) {
            if (g.form == 1) {
              tmp___29 = adler32z(check, (unsigned char const   *)next___0, (size_t )(4294967295U - (4294967295U >> 1)));
              check = tmp___29;
            } else {
              tmp___30 = crc32z(check, (unsigned char const   *)next___0, (size_t )(4294967295U - (4294967295U >> 1)));
              check = tmp___30;
            }
            len -= (size_t )(4294967295U - (4294967295U >> 1));
            next___0 += 4294967295U - (4294967295U >> 1);
          }
          if (g.form == 1) {
            tmp___31 = adler32z(check, (unsigned char const   *)next___0, (size_t )((unsigned int )len));
            check = tmp___31;
          } else {
            tmp___32 = crc32z(check, (unsigned char const   *)next___0, (size_t )((unsigned int )len));
            check = tmp___32;
          }
          drop_space(job->in);
          job->check = check;
          possess_(job->calc, "pigz.c", 1937L);
          twist_(job->calc, (enum twist_op )0, 1L, "pigz.c", 1938L);
        }
        release_(compress_have, "pigz.c", 1944L);
        if (g.level > 9) {
          drop_space(temp);
        } else {
          deflateEnd(& strm___0);
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___37 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___37 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 1954U, "compress_thread");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 1954U, "compress_thread");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void write_thread(void *dummy ) 
{ 
  long seq ;
  struct job *job ;
  size_t len ;
  int more ;
  length_t head ;
  length_t ulen ;
  length_t clen ;
  unsigned long check ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  long tmp___12 ;
  int tmp___14 ;
  int tmp___18 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 1975U, "write_thread");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 1975U, "write_thread");
      }
      break;
    }
    tmp___14 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___14 == 0) {
      while (1) {
        head = put_header();
        clen = (length_t )0;
        ulen = clen;
        if (g.form == 1) {
          tmp___4 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
          check = tmp___4;
        } else {
          tmp___5 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
          check = tmp___5;
        }
        seq = 0L;
        while (1) {
          possess_(write_first, "pigz.c", 1986L);
          wait_for_(write_first, (enum wait_op )0, seq, "pigz.c", 1987L);
          job = write_head;
          write_head = job->next;
          if ((unsigned long )write_head == (unsigned long )((void *)0)) {
            tmp___6 = -1L;
          } else {
            tmp___6 = write_head->seq;
          }
          twist_(write_first, (enum twist_op )0, tmp___6, "pigz.c", 1990L);
          more = job->more;
          len = (job->in)->len;
          drop_space(job->in);
          ulen += len;
          clen += (job->out)->len;
          writen(g.outd, (void const   *)(job->out)->buf, (job->out)->len);
          drop_space(job->out);
          possess_(job->calc, "pigz.c", 2007L);
          wait_for_(job->calc, (enum wait_op )0, 1L, "pigz.c", 2008L);
          release_(job->calc, "pigz.c", 2009L);
          if (g.form == 1) {
            tmp___7 = adler32_comb(check, job->check, len);
            check = tmp___7;
          } else {
            tmp___8 = crc32_comb(check, job->check, len);
            check = tmp___8;
          }
          free_lock_(job->calc, "pigz.c", 2014L);
          free((void *)job);
          seq ++;
          if (! more) {
            break;
          }
        }
        put_trailer(ulen, clen, check, head);
        possess_(compress_have, "pigz.c", 2025L);
        if ((unsigned long )compress_head == (unsigned long )((void *)0)) {
          tmp___12 = peek_lock(compress_have);
          if (! (tmp___12 == 0L)) {
            __assert_fail("compress_head == NULL && peek_lock(compress_have) == 0",
                          "pigz.c", 2026U, "write_thread");
          }
        } else {
          __assert_fail("compress_head == NULL && peek_lock(compress_have) == 0",
                        "pigz.c", 2026U, "write_thread");
        }
        release_(compress_have, "pigz.c", 2027L);
        possess_(write_first, "pigz.c", 2028L);
        if (! ((unsigned long )write_head == (unsigned long )((void *)0))) {
          __assert_fail("write_head == NULL", "pigz.c", 2029U, "write_thread");
        }
        twist_(write_first, (enum twist_op )0, -1L, "pigz.c", 2030L);
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___18 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___18 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 2032U, "write_thread");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 2032U, "write_thread");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void append_len(struct job *job , size_t len ) 
{ 
  struct space *lens ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  if (! (len < 539000896UL)) {
    __assert_fail("len < 539000896UL", "pigz.c", 2041U, "append_len");
  }
  if ((unsigned long )job->lens == (unsigned long )((void *)0)) {
    job->lens = get_space(& lens_pool);
  }
  lens = job->lens;
  if (lens->size < lens->len + 3UL) {
    grow_space(lens);
  }
  if (len < 64UL) {
    tmp___0 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___0) = (unsigned char )(len + 128UL);
  } else
  if (len < 32832UL) {
    len -= 64UL;
    tmp___1 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___1) = (unsigned char )(len >> 8);
    tmp___2 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___2) = (unsigned char )len;
  } else
  if (len < 2129984UL) {
    len -= 32832UL;
    tmp___3 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___3) = (unsigned char )((len >> 16) + 192UL);
    tmp___4 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___4) = (unsigned char )(len >> 8);
    tmp___5 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___5) = (unsigned char )len;
  } else {
    len -= 2129984UL;
    tmp___6 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___6) = (unsigned char )((len >> 24) + 224UL);
    tmp___7 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___7) = (unsigned char )(len >> 16);
    tmp___8 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___8) = (unsigned char )(len >> 8);
    tmp___9 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___9) = (unsigned char )len;
  }
  return;
}
}
static void parallel_compress(void) 
{ 
  long seq ;
  struct space *curr ;
  struct space *next___0 ;
  struct space *hold ;
  struct space *dict ;
  struct job *job ;
  int more ;
  unsigned int hash ;
  unsigned char *scan ;
  unsigned char *end ;
  unsigned char *last ;
  size_t left ;
  size_t len ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  setup_jobs();
  writeth = launch_(& write_thread, (void *)0, "pigz.c", 2092L);
  seq = 0L;
  next___0 = get_space(& in_pool);
  next___0->len = readn(g.ind, next___0->buf, next___0->size);
  hold = (struct space *)((void *)0);
  dict = (struct space *)((void *)0);
  scan = next___0->buf;
  hash = ((1U << 12) - 1U) >> 1;
  left = (size_t )0;
  while (1) {
    tmp = alloc((void *)0, sizeof(struct job ));
    job = (struct job *)tmp;
    job->calc = new_lock_(0L, "pigz.c", 2107L);
    curr = next___0;
    next___0 = hold;
    hold = (struct space *)((void *)0);
    if ((unsigned long )next___0 == (unsigned long )((void *)0)) {
      next___0 = get_space(& in_pool);
      next___0->len = readn(g.ind, next___0->buf, next___0->size);
    }
    job->lens = (struct space *)((void *)0);
    if (g.rsync) {
      if (curr->len) {
        if (left == 0UL) {
          last = curr->buf;
          end = curr->buf + curr->len;
          while ((unsigned long )scan < (unsigned long )end) {
            tmp___0 = scan;
            scan ++;
            hash = ((hash << 1) ^ (unsigned int )*tmp___0) & ((1U << 12) - 1U);
            if (hash == ((1U << 12) - 1U) >> 1) {
              len = (size_t )(scan - last);
              append_len(job, len);
              last = scan;
            }
          }
          left = (size_t )(scan - last);
          scan = next___0->buf;
        }
        last = next___0->buf;
        len = curr->size - curr->len;
        if (len > next___0->len) {
          len = next___0->len;
        }
        end = next___0->buf + len;
        while ((unsigned long )scan < (unsigned long )end) {
          tmp___1 = scan;
          scan ++;
          hash = ((hash << 1) ^ (unsigned int )*tmp___1) & ((1U << 12) - 1U);
          if (hash == ((1U << 12) - 1U) >> 1) {
            len = (size_t )(scan - last) + left;
            left = (size_t )0;
            append_len(job, len);
            last = scan;
          }
        }
        append_len(job, (size_t )0);
        if ((job->lens)->len == 1UL) {
          tmp___2 = scan;
        } else {
          tmp___2 = last;
        }
        len = (size_t )(tmp___2 - next___0->buf);
        if (len) {
          memcpy((void * __restrict  )(curr->buf + curr->len), (void const   * __restrict  )next___0->buf,
                 len);
          curr->len += len;
          memmove((void *)next___0->buf, (void const   *)(next___0->buf + len), next___0->len - len);
          next___0->len -= len;
          scan -= len;
          left = (size_t )0;
        } else
        if ((job->lens)->len != 1UL) {
          if (left) {
            if (next___0->len) {
              hold = next___0;
              next___0 = get_space(& in_pool);
              memcpy((void * __restrict  )next___0->buf, (void const   * __restrict  )(curr->buf + (curr->len - left)),
                     left);
              next___0->len = left;
              curr->len -= left;
            } else {
              left = (size_t )0;
            }
          } else {
            left = (size_t )0;
          }
        } else {
          left = (size_t )0;
        }
      }
    }
    job->in = curr;
    more = next___0->len != 0UL;
    job->more = more;
    job->out = dict;
    if (more) {
      if (g.setdict) {
        if (curr->len >= 32768UL) {
          dict = curr;
          use_space(dict);
        } else
        if ((unsigned long )job->out == (unsigned long )((void *)0)) {
          dict = curr;
          use_space(dict);
        } else {
          dict = get_space(& dict_pool);
          len = 32768UL - curr->len;
          memcpy((void * __restrict  )dict->buf, (void const   * __restrict  )((job->out)->buf + ((job->out)->len - len)),
                 len);
          memcpy((void * __restrict  )(dict->buf + len), (void const   * __restrict  )curr->buf,
                 curr->len);
          dict->len = (size_t )32768U;
        }
      }
    }
    job->seq = seq;
    seq ++;
    if (seq < 1L) {
      try_throw_(34, (char *)"overflow", (void *)0);
    }
    if ((long )cthreads < seq) {
      if (cthreads < g.procs) {
        launch_(& compress_thread, (void *)0, "pigz.c", 2228L);
        cthreads ++;
      }
    }
    possess_(compress_have, "pigz.c", 2233L);
    job->next = (struct job *)((void *)0);
    *compress_tail = job;
    compress_tail = & job->next;
    twist_(compress_have, (enum twist_op )1, 1L, "pigz.c", 2237L);
    if (! more) {
      break;
    }
  }
  drop_space(next___0);
  join_(writeth, "pigz.c", 2243L);
  writeth = (thread *)((void *)0);
  return;
}
}
static unsigned int out_size  ;
static unsigned char *in  ;
static unsigned char *next  ;
static unsigned char *out  ;
static void single_compress(int reset ) ;
static z_stream *strm  =    (z_stream *)((void *)0);
static void single_compress(int reset ) 
{ 
  size_t got ;
  size_t more ;
  size_t start ;
  size_t have ;
  size_t hist ;
  int fresh ;
  unsigned int hash ;
  unsigned char *scan ;
  size_t left ;
  unsigned long head ;
  length_t ulen ;
  length_t clen ;
  unsigned long check ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  size_t tmp___8 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int bits ;
  size_t tmp___12 ;
  size_t tmp___14 ;
  size_t tmp___17 ;
  size_t tmp___19 ;
  long tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___24 ;
  unsigned char bits___0 ;
  unsigned char *def ;
  size_t size ;
  size_t off ;
  int tmp___26 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;

  {
  if (reset) {
    if ((unsigned long )strm != (unsigned long )((void *)0)) {
      deflateEnd(strm);
      free((void *)strm);
      free((void *)out);
      free((void *)next);
      free((void *)in);
      strm = (z_stream *)((void *)0);
    }
    return;
  }
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    if (g.block > (size_t )(4294967295U - (4294967295U >> 1))) {
      out_size = 4294967295U - (4294967295U >> 1);
    } else {
      out_size = (unsigned int )g.block;
    }
    tmp = alloc((void *)0, g.block + 32768UL);
    in = (unsigned char *)tmp;
    tmp___0 = alloc((void *)0, g.block + 32768UL);
    next = (unsigned char *)tmp___0;
    tmp___1 = alloc((void *)0, (size_t )out_size);
    out = (unsigned char *)tmp___1;
    tmp___2 = alloc((void *)0, sizeof(z_stream ));
    strm = (z_stream *)tmp___2;
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))0;
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
    strm->opaque = (voidpf )0;
    ret = deflateInit2_(strm, 6, 8, -15, 8, g.strategy, "1.2.11", (int )sizeof(z_stream ));
    if (ret == -4) {
      try_throw_(12, (char *)"not enough memory", (void *)0);
    }
    if (ret != 0) {
      try_throw_(22, (char *)"internal error", (void *)0);
    }
  }
  head = put_header();
  if (g.level <= 9) {
    deflateReset(strm);
    deflateParams(strm, g.level, g.strategy);
  }
  got = (size_t )0;
  more = readn(g.ind, next, g.block);
  ulen = more;
  start = (size_t )0;
  hist = (size_t )0;
  clen = (length_t )0;
  have = (size_t )0;
  if (g.form == 1) {
    tmp___3 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
    check = tmp___3;
  } else {
    tmp___4 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
    check = tmp___4;
  }
  hash = ((1U << 12) - 1U) >> 1;
  while (1) {
    if (got == 0UL) {
      scan = in;
      in = next;
      next = scan;
      strm->next_in = in + start;
      got = more;
      if (g.level > 9) {
        left = (start + more) - hist;
        if (left > 32768UL) {
          left = (size_t )32768U;
        }
        memcpy((void * __restrict  )next, (void const   * __restrict  )(in + ((start + more) - left)),
               left);
        start = left;
        hist = (size_t )0;
      } else {
        start = (size_t )0;
      }
      more = readn(g.ind, next + start, g.block);
      ulen += more;
    }
    left = (size_t )0;
    if (g.rsync) {
      if (got) {
        scan = strm->next_in;
        left = got;
        while (1) {
          if (left == 0UL) {
            if (more == 0UL) {
              break;
            } else
            if (got == g.block) {
              break;
            }
            if (g.level > 9) {
              left = (size_t )(strm->next_in - in) - hist;
              if (left > 32768UL) {
                left = (size_t )32768U;
              }
            }
            memmove((void *)in, (void const   *)(strm->next_in - left), left + got);
            hist = (size_t )0;
            strm->next_in = in + left;
            scan = (in + left) + got;
            if (more > g.block - got) {
              left = g.block - got;
            } else {
              left = more;
            }
            memcpy((void * __restrict  )scan, (void const   * __restrict  )(next + start),
                   left);
            got += left;
            more -= left;
            start += left;
            if (more == 0UL) {
              more = readn(g.ind, next, g.block);
              ulen += more;
              start = (size_t )0;
            }
          }
          left --;
          tmp___5 = scan;
          scan ++;
          hash = ((hash << 1) ^ (unsigned int )*tmp___5) & ((1U << 12) - 1U);
          if (! (hash != ((1U << 12) - 1U) >> 1)) {
            break;
          }
        }
        got -= left;
      }
    }
    fresh = 0;
    if (! g.setdict) {
      have += got;
      if (have > g.block) {
        fresh = 1;
        have = got;
      }
    }
    if (g.level <= 9) {
      if (fresh) {
        deflateReset(strm);
      }
      while (got > (size_t )(4294967295U - (4294967295U >> 1))) {
        strm->avail_in = 4294967295U - (4294967295U >> 1);
        if (g.form == 1) {
          tmp___6 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
          check = tmp___6;
        } else {
          tmp___7 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
          check = tmp___7;
        }
        while (1) {
          while (1) {
            strm->avail_out = out_size;
            strm->next_out = out;
            deflate(strm, 0);
            tmp___8 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
            clen += tmp___8;
            if (! (strm->avail_out == 0U)) {
              break;
            }
          }
          if (! (strm->avail_in == 0U)) {
            __assert_fail("strm->avail_in == 0", "pigz.c", 2421U, "single_compress");
          }
          break;
        }
        got -= (size_t )(4294967295U - (4294967295U >> 1));
      }
      strm->avail_in = (unsigned int )got;
      got = left;
      if (g.form == 1) {
        tmp___10 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
        check = tmp___10;
      } else {
        tmp___11 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
        check = tmp___11;
      }
      if (more) {
        goto _L___0;
      } else
      if (got) {
        _L___0: /* CIL Label */ 
        tmp___21 = zlib_vernum();
        if (tmp___21 >= 4704L) {
          while (1) {
            while (1) {
              strm->avail_out = out_size;
              strm->next_out = out;
              deflate(strm, 5);
              tmp___12 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
              clen += tmp___12;
              if (! (strm->avail_out == 0U)) {
                break;
              }
            }
            if (! (strm->avail_in == 0U)) {
              __assert_fail("strm->avail_in == 0", "pigz.c", 2434U, "single_compress");
            }
            break;
          }
          deflatePending(strm, (unsigned int *)0, & bits);
          if (bits & 1) {
            goto _L;
          } else
          if (! g.setdict) {
            _L: /* CIL Label */ 
            while (1) {
              while (1) {
                strm->avail_out = out_size;
                strm->next_out = out;
                deflate(strm, 2);
                tmp___14 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
                clen += tmp___14;
                if (! (strm->avail_out == 0U)) {
                  break;
                }
              }
              if (! (strm->avail_in == 0U)) {
                __assert_fail("strm->avail_in == 0", "pigz.c", 2437U, "single_compress");
              }
              break;
            }
          } else
          if (bits & 7) {
            while (1) {
              bits = deflatePrime(strm, 10, 2);
              if (! (bits == 0)) {
                __assert_fail("bits == Z_OK", "pigz.c", 2441U, "single_compress");
              }
              deflatePending(strm, (unsigned int *)0, & bits);
              if (! (bits & 7)) {
                break;
              }
            }
            while (1) {
              while (1) {
                strm->avail_out = out_size;
                strm->next_out = out;
                deflate(strm, 0);
                tmp___17 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
                clen += tmp___17;
                if (! (strm->avail_out == 0U)) {
                  break;
                }
              }
              if (! (strm->avail_in == 0U)) {
                __assert_fail("strm->avail_in == 0", "pigz.c", 2444U, "single_compress");
              }
              break;
            }
          }
        } else {
          while (1) {
            while (1) {
              strm->avail_out = out_size;
              strm->next_out = out;
              deflate(strm, 2);
              tmp___19 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
              clen += tmp___19;
              if (! (strm->avail_out == 0U)) {
                break;
              }
            }
            if (! (strm->avail_in == 0U)) {
              __assert_fail("strm->avail_in == 0", "pigz.c", 2448U, "single_compress");
            }
            break;
          }
        }
        if (! g.setdict) {
          while (1) {
            while (1) {
              strm->avail_out = out_size;
              strm->next_out = out;
              deflate(strm, 3);
              tmp___22 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
              clen += tmp___22;
              if (! (strm->avail_out == 0U)) {
                break;
              }
            }
            if (! (strm->avail_in == 0U)) {
              __assert_fail("strm->avail_in == 0", "pigz.c", 2453U, "single_compress");
            }
            break;
          }
        }
      } else {
        while (1) {
          while (1) {
            strm->avail_out = out_size;
            strm->next_out = out;
            deflate(strm, 4);
            tmp___24 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
            clen += tmp___24;
            if (! (strm->avail_out == 0U)) {
              break;
            }
          }
          if (! (strm->avail_in == 0U)) {
            __assert_fail("strm->avail_in == 0", "pigz.c", 2456U, "single_compress");
          }
          break;
        }
      }
    } else {
      off = (size_t )(strm->next_in - in);
      if (fresh) {
        hist = off;
      }
      def = (unsigned char *)((void *)0);
      size = (size_t )0;
      bits___0 = (unsigned char)0;
      if (more) {
        tmp___26 = 0;
      } else
      if (left) {
        tmp___26 = 0;
      } else {
        tmp___26 = 1;
      }
      ZopfliDeflatePart((ZopfliOptions const   *)(& g.zopts), 2, tmp___26, (unsigned char const   *)(in + hist),
                        off - hist, (off - hist) + got, & bits___0, & def, & size);
      bits___0 = (unsigned char )((int )bits___0 & 7);
      if (more) {
        goto _L___2;
      } else
      if (left) {
        _L___2: /* CIL Label */ 
        if ((int )bits___0 & 1) {
          goto _L___1;
        } else
        if (! g.setdict) {
          _L___1: /* CIL Label */ 
          writen(g.outd, (void const   *)def, size);
          if ((int )bits___0 == 0) {
            writen(g.outd, (void const   *)((unsigned char *)"\000"), (size_t )1);
          } else
          if ((int )bits___0 > 5) {
            writen(g.outd, (void const   *)((unsigned char *)"\000"), (size_t )1);
          }
          writen(g.outd, (void const   *)((unsigned char *)"\000\000\377\377"), (size_t )4);
        } else {
          if (! (size > 0UL)) {
            __assert_fail("size > 0", "pigz.c", 2484U, "single_compress");
          }
          writen(g.outd, (void const   *)def, size - 1UL);
          if (bits___0) {
            while (1) {
              *(def + (size - 1UL)) = (unsigned char )((int )*(def + (size - 1UL)) + (2 << (int )bits___0));
              writen(g.outd, (void const   *)((def + size) - 1), (size_t )1);
              *(def + (size - 1UL)) = (unsigned char)0;
              bits___0 = (unsigned char )((int )bits___0 + 2);
              if (! ((int )bits___0 < 8)) {
                break;
              }
            }
          }
          writen(g.outd, (void const   *)((def + size) - 1), (size_t )1);
        }
        if (! g.setdict) {
          writen(g.outd, (void const   *)((unsigned char *)"\000\000\000\377\377"),
                 (size_t )5);
        }
      } else {
        writen(g.outd, (void const   *)def, size);
      }
      free((void *)def);
      while (got > (size_t )(4294967295U - (4294967295U >> 1))) {
        if (g.form == 1) {
          tmp___28 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )(4294967295U - (4294967295U >> 1)));
          check = tmp___28;
        } else {
          tmp___29 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )(4294967295U - (4294967295U >> 1)));
          check = tmp___29;
        }
        strm->next_in += 4294967295U - (4294967295U >> 1);
        got -= (size_t )(4294967295U - (4294967295U >> 1));
      }
      if (g.form == 1) {
        tmp___30 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )((unsigned int )got));
        check = tmp___30;
      } else {
        tmp___31 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )((unsigned int )got));
        check = tmp___31;
      }
      strm->next_in += got;
      got = left;
    }
    if (! more) {
      if (! got) {
        break;
      }
    }
  }
  put_trailer(ulen, clen, check, head);
  return;
}
}
static void load_read(void *dummy ) 
{ 
  size_t len ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  int tmp___10 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 2531U, "load_read");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 2531U, "load_read");
      }
      break;
    }
    tmp___6 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___6 == 0) {
      while (1) {
        while (1) {
          possess_(g.load_state, "pigz.c", 2533L);
          wait_for_(g.load_state, (enum wait_op )1, 0L, "pigz.c", 2534L);
          tmp___4 = peek_lock(g.load_state);
          if (tmp___4 > 1L) {
            release_(g.load_state, "pigz.c", 2536L);
            break;
          }
          if (g.in_which) {
            tmp___5 = g.in_buf;
          } else {
            tmp___5 = g.in_buf2;
          }
          len = readn(g.ind, tmp___5, (size_t )32768);
          g.in_len = len;
          twist_(g.load_state, (enum twist_op )0, 0L, "pigz.c", 2542L);
          if (! (len == 32768UL)) {
            break;
          }
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___10 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___10 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 2545U, "load_read");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 2545U, "load_read");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void load_wait(void) 
{ 


  {
  if (g.in_which == -1) {
    return;
  }
  possess_(g.load_state, "pigz.c", 2556L);
  wait_for_(g.load_state, (enum wait_op )0, 0L, "pigz.c", 2557L);
  release_(g.load_state, "pigz.c", 2558L);
  return;
}
}
static size_t load(void) 
{ 


  {
  if (g.in_short) {
    g.in_eof = 1;
    g.in_left = (size_t )0;
    return ((size_t )0);
  }
  if (g.procs > 1) {
    if (g.in_which == -1) {
      g.in_which = 1;
      g.load_state = new_lock_(1L, "pigz.c", 2582L);
      g.load_thread = launch_(& load_read, (void *)0, "pigz.c", 2583L);
    }
    load_wait();
    if (g.in_which) {
      g.in_next = g.in_buf;
    } else {
      g.in_next = g.in_buf2;
    }
    g.in_left = g.in_len;
    if (g.in_len == 32768UL) {
      g.in_which = 1 - g.in_which;
      possess_(g.load_state, "pigz.c", 2597L);
      twist_(g.load_state, (enum twist_op )0, 1L, "pigz.c", 2598L);
    } else {
      join_(g.load_thread, "pigz.c", 2603L);
      free_lock_(g.load_state, "pigz.c", 2604L);
      g.in_which = -1;
    }
  } else {
    g.in_next = g.in_buf;
    g.in_left = readn(g.ind, g.in_next, (size_t )32768);
  }
  if (g.in_left < 32768UL) {
    g.in_short = 1;
    if (g.in_left == 0UL) {
      g.in_eof = 1;
    }
  }
  g.in_tot += g.in_left;
  return (g.in_left);
}
}
static void load_end(void) 
{ 


  {
  if (g.in_which != -1) {
    possess_(g.load_state, "pigz.c", 2637L);
    wait_for_(g.load_state, (enum wait_op )0, 0L, "pigz.c", 2638L);
    twist_(g.load_state, (enum twist_op )0, 2L, "pigz.c", 2639L);
    join_(g.load_thread, "pigz.c", 2642L);
    free_lock_(g.load_state, "pigz.c", 2643L);
    g.in_which = -1;
  }
  g.in_left = (size_t )0;
  g.in_short = 1;
  g.in_eof = 1;
  if (g.ind != 0) {
    close(g.ind);
  }
  while (1) {
    if ((unsigned long )g.hname != (unsigned long )((void *)0)) {
      free((void *)g.hname);
      g.hname = (char *)((void *)0);
    }
    break;
  }
  while (1) {
    if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
      free((void *)g.hcomm);
      g.hcomm = (char *)((void *)0);
    }
    break;
  }
  return;
}
}
static void in_init(void) 
{ 


  {
  g.in_left = (size_t )0;
  g.in_eof = 0;
  g.in_short = 0;
  g.in_tot = (length_t )0;
  g.in_which = -1;
  return;
}
}
static time_t dos2time(unsigned long dos ) 
{ 
  struct tm tm ;
  time_t tmp ;
  time_t tmp___0 ;

  {
  if (dos == 0UL) {
    tmp = time((time_t *)((void *)0));
    return (tmp);
  }
  tm.tm_year = ((int )(dos >> 25) & 127) + 80;
  tm.tm_mon = ((int )(dos >> 21) & 15) - 1;
  tm.tm_mday = (int )(dos >> 16) & 31;
  tm.tm_hour = (int )(dos >> 11) & 31;
  tm.tm_min = (int )(dos >> 5) & 63;
  tm.tm_sec = (int )(dos << 1) & 62;
  tm.tm_isdst = -1;
  tmp___0 = mktime(& tm);
  return (tmp___0);
}
}
static long tolong(unsigned long val ) 
{ 


  {
  return ((long )(val & 2147483647UL) - (long )(val & 2147483648UL));
}
}
static int read_extra(unsigned int len , int save ) 
{ 
  unsigned int id ;
  unsigned int size ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  size_t tmp___8 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  unsigned char *tmp___14 ;
  size_t tmp___15 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  unsigned char *tmp___21 ;
  size_t tmp___22 ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  size_t togo ;
  size_t tmp___27 ;
  unsigned char *tmp___29 ;
  size_t tmp___30 ;
  unsigned char *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  unsigned char *tmp___36 ;
  size_t tmp___37 ;
  unsigned char *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  size_t togo___0 ;
  size_t tmp___42 ;
  size_t togo___1 ;
  size_t tmp___43 ;
  unsigned char *tmp___45 ;
  size_t tmp___46 ;
  unsigned char *tmp___48 ;
  int tmp___49 ;
  size_t tmp___50 ;
  unsigned char *tmp___52 ;
  size_t tmp___53 ;
  unsigned char *tmp___55 ;
  int tmp___56 ;
  size_t tmp___57 ;
  unsigned char *tmp___59 ;
  size_t tmp___60 ;
  unsigned char *tmp___62 ;
  int tmp___63 ;
  size_t tmp___64 ;
  unsigned char *tmp___66 ;
  size_t tmp___67 ;
  unsigned char *tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  unsigned char *tmp___73 ;
  int tmp___74 ;
  size_t tmp___75 ;
  size_t togo___2 ;
  size_t tmp___76 ;
  size_t togo___3 ;
  size_t tmp___77 ;

  {
  while (len >= 4U) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___1 = load();
        if (tmp___1 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___0 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___0;
        }
      }
    } else {
      (g.in_left) --;
      tmp___0 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___0;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___4 = 0;
      } else {
        tmp___5 = load();
        if (tmp___5 == 0UL) {
          tmp___4 = 0;
        } else {
          (g.in_left) --;
          tmp___3 = g.in_next;
          (g.in_next) ++;
          tmp___4 = (int )*tmp___3;
        }
      }
    } else {
      (g.in_left) --;
      tmp___3 = g.in_next;
      (g.in_next) ++;
      tmp___4 = (int )*tmp___3;
    }
    id = tmp2 + ((unsigned int )tmp___4 << 8);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___8 = load();
        if (tmp___8 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___7 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___7;
        }
      }
    } else {
      (g.in_left) --;
      tmp___7 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___7;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___11 = 0;
      } else {
        tmp___12 = load();
        if (tmp___12 == 0UL) {
          tmp___11 = 0;
        } else {
          (g.in_left) --;
          tmp___10 = g.in_next;
          (g.in_next) ++;
          tmp___11 = (int )*tmp___10;
        }
      }
    } else {
      (g.in_left) --;
      tmp___10 = g.in_next;
      (g.in_next) ++;
      tmp___11 = (int )*tmp___10;
    }
    size = tmp2 + ((unsigned int )tmp___11 << 8);
    if (g.in_eof) {
      return (-1);
    }
    len -= 4U;
    if (size > len) {
      break;
    }
    len -= size;
    if (id == 1U) {
      g.zip64 = 1;
      if (g.zip_ulen == 4294967295UL) {
        if (size >= 8U) {
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___15 = load();
              if (tmp___15 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___14 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___14;
              }
            }
          } else {
            (g.in_left) --;
            tmp___14 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___14;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___18 = 0;
            } else {
              tmp___19 = load();
              if (tmp___19 == 0UL) {
                tmp___18 = 0;
              } else {
                (g.in_left) --;
                tmp___17 = g.in_next;
                (g.in_next) ++;
                tmp___18 = (int )*tmp___17;
              }
            }
          } else {
            (g.in_left) --;
            tmp___17 = g.in_next;
            (g.in_next) ++;
            tmp___18 = (int )*tmp___17;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___18 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___22 = load();
              if (tmp___22 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___21 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___21;
              }
            }
          } else {
            (g.in_left) --;
            tmp___21 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___21;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___25 = 0;
            } else {
              tmp___26 = load();
              if (tmp___26 == 0UL) {
                tmp___25 = 0;
              } else {
                (g.in_left) --;
                tmp___24 = g.in_next;
                (g.in_next) ++;
                tmp___25 = (int )*tmp___24;
              }
            }
          } else {
            (g.in_left) --;
            tmp___24 = g.in_next;
            (g.in_next) ++;
            tmp___25 = (int )*tmp___24;
          }
          g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___25 << 8)) << 16);
          while (1) {
            togo = (size_t )4;
            while (togo > g.in_left) {
              togo -= g.in_left;
              tmp___27 = load();
              if (tmp___27 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo;
            g.in_next += togo;
            break;
          }
          size -= 8U;
        }
      }
      if (g.zip_clen == 4294967295UL) {
        if (size >= 8U) {
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___30 = load();
              if (tmp___30 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___29 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___29;
              }
            }
          } else {
            (g.in_left) --;
            tmp___29 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___29;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___33 = 0;
            } else {
              tmp___34 = load();
              if (tmp___34 == 0UL) {
                tmp___33 = 0;
              } else {
                (g.in_left) --;
                tmp___32 = g.in_next;
                (g.in_next) ++;
                tmp___33 = (int )*tmp___32;
              }
            }
          } else {
            (g.in_left) --;
            tmp___32 = g.in_next;
            (g.in_next) ++;
            tmp___33 = (int )*tmp___32;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___33 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___37 = load();
              if (tmp___37 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___36 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___36;
              }
            }
          } else {
            (g.in_left) --;
            tmp___36 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___36;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___40 = 0;
            } else {
              tmp___41 = load();
              if (tmp___41 == 0UL) {
                tmp___40 = 0;
              } else {
                (g.in_left) --;
                tmp___39 = g.in_next;
                (g.in_next) ++;
                tmp___40 = (int )*tmp___39;
              }
            }
          } else {
            (g.in_left) --;
            tmp___39 = g.in_next;
            (g.in_next) ++;
            tmp___40 = (int )*tmp___39;
          }
          g.zip_clen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___40 << 8)) << 16);
          while (1) {
            togo___0 = (size_t )4;
            while (togo___0 > g.in_left) {
              togo___0 -= g.in_left;
              tmp___42 = load();
              if (tmp___42 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo___0;
            g.in_next += togo___0;
            break;
          }
          size -= 8U;
        }
      }
    }
    if (save) {
      if (id == 13U) {
        goto _L;
      } else
      if (id == 22613U) {
        _L: /* CIL Label */ 
        if (size >= 8U) {
          while (1) {
            togo___1 = (size_t )4;
            while (togo___1 > g.in_left) {
              togo___1 -= g.in_left;
              tmp___43 = load();
              if (tmp___43 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo___1;
            g.in_next += togo___1;
            break;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___46 = load();
              if (tmp___46 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___45 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___45;
              }
            }
          } else {
            (g.in_left) --;
            tmp___45 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___45;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___49 = 0;
            } else {
              tmp___50 = load();
              if (tmp___50 == 0UL) {
                tmp___49 = 0;
              } else {
                (g.in_left) --;
                tmp___48 = g.in_next;
                (g.in_next) ++;
                tmp___49 = (int )*tmp___48;
              }
            }
          } else {
            (g.in_left) --;
            tmp___48 = g.in_next;
            (g.in_next) ++;
            tmp___49 = (int )*tmp___48;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___49 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___53 = load();
              if (tmp___53 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___52 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___52;
              }
            }
          } else {
            (g.in_left) --;
            tmp___52 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___52;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___56 = 0;
            } else {
              tmp___57 = load();
              if (tmp___57 == 0UL) {
                tmp___56 = 0;
              } else {
                (g.in_left) --;
                tmp___55 = g.in_next;
                (g.in_next) ++;
                tmp___56 = (int )*tmp___55;
              }
            }
          } else {
            (g.in_left) --;
            tmp___55 = g.in_next;
            (g.in_next) ++;
            tmp___56 = (int )*tmp___55;
          }
          g.stamp = tolong(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___56 << 8)) << 16));
          size -= 8U;
        }
      }
      if (id == 21589U) {
        if (size >= 5U) {
          size --;
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___74 = 0;
            } else {
              tmp___75 = load();
              if (tmp___75 == 0UL) {
                tmp___74 = 0;
              } else {
                (g.in_left) --;
                tmp___73 = g.in_next;
                (g.in_next) ++;
                tmp___74 = (int )*tmp___73;
              }
            }
          } else {
            (g.in_left) --;
            tmp___73 = g.in_next;
            (g.in_next) ++;
            tmp___74 = (int )*tmp___73;
          }
          if (tmp___74 & 1) {
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp2 = 0U;
              } else {
                tmp___60 = load();
                if (tmp___60 == 0UL) {
                  tmp2 = 0U;
                } else {
                  (g.in_left) --;
                  tmp___59 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___59;
                }
              }
            } else {
              (g.in_left) --;
              tmp___59 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___59;
            }
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp___63 = 0;
              } else {
                tmp___64 = load();
                if (tmp___64 == 0UL) {
                  tmp___63 = 0;
                } else {
                  (g.in_left) --;
                  tmp___62 = g.in_next;
                  (g.in_next) ++;
                  tmp___63 = (int )*tmp___62;
                }
              }
            } else {
              (g.in_left) --;
              tmp___62 = g.in_next;
              (g.in_next) ++;
              tmp___63 = (int )*tmp___62;
            }
            tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___63 << 8));
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp2 = 0U;
              } else {
                tmp___67 = load();
                if (tmp___67 == 0UL) {
                  tmp2 = 0U;
                } else {
                  (g.in_left) --;
                  tmp___66 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___66;
                }
              }
            } else {
              (g.in_left) --;
              tmp___66 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___66;
            }
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp___70 = 0;
              } else {
                tmp___71 = load();
                if (tmp___71 == 0UL) {
                  tmp___70 = 0;
                } else {
                  (g.in_left) --;
                  tmp___69 = g.in_next;
                  (g.in_next) ++;
                  tmp___70 = (int )*tmp___69;
                }
              }
            } else {
              (g.in_left) --;
              tmp___69 = g.in_next;
              (g.in_next) ++;
              tmp___70 = (int )*tmp___69;
            }
            g.stamp = tolong(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___70 << 8)) << 16));
            size -= 4U;
          }
        }
      }
    }
    while (1) {
      togo___2 = (size_t )size;
      while (togo___2 > g.in_left) {
        togo___2 -= g.in_left;
        tmp___76 = load();
        if (tmp___76 == 0UL) {
          return (-3);
        }
      }
      g.in_left -= togo___2;
      g.in_next += togo___2;
      break;
    }
  }
  while (1) {
    togo___3 = (size_t )len;
    while (togo___3 > g.in_left) {
      togo___3 -= g.in_left;
      tmp___77 = load();
      if (tmp___77 == 0UL) {
        return (-3);
      }
    }
    g.in_left -= togo___3;
    g.in_next += togo___3;
    break;
  }
  return (0);
}
}
static int get_header(int save ) 
{ 
  unsigned int magic ;
  unsigned int method ;
  unsigned int flags ;
  unsigned int fname ;
  unsigned int extra ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  unsigned long crc ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  size_t tmp___8 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t togo ;
  size_t tmp___13 ;
  unsigned char *tmp___15 ;
  size_t tmp___16 ;
  unsigned char *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  unsigned char *tmp___22 ;
  size_t tmp___23 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  unsigned char *tmp___29 ;
  size_t tmp___30 ;
  unsigned char *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  unsigned char *tmp___36 ;
  size_t tmp___37 ;
  unsigned char *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  size_t togo___0 ;
  size_t tmp___42 ;
  unsigned char *tmp___44 ;
  size_t tmp___45 ;
  unsigned char *tmp___47 ;
  int tmp___48 ;
  size_t tmp___49 ;
  unsigned char *tmp___51 ;
  size_t tmp___52 ;
  unsigned char *tmp___54 ;
  int tmp___55 ;
  size_t tmp___56 ;
  unsigned char *tmp___58 ;
  size_t tmp___59 ;
  unsigned char *tmp___61 ;
  int tmp___62 ;
  size_t tmp___63 ;
  unsigned char *tmp___65 ;
  size_t tmp___66 ;
  unsigned char *tmp___68 ;
  int tmp___69 ;
  size_t tmp___70 ;
  unsigned char *tmp___72 ;
  size_t tmp___73 ;
  unsigned char *tmp___75 ;
  int tmp___76 ;
  size_t tmp___77 ;
  unsigned char *tmp___79 ;
  size_t tmp___80 ;
  unsigned char *tmp___82 ;
  int tmp___83 ;
  size_t tmp___84 ;
  unsigned char *tmp___86 ;
  size_t tmp___87 ;
  unsigned char *tmp___89 ;
  int tmp___90 ;
  size_t tmp___91 ;
  unsigned char *tmp___93 ;
  size_t tmp___94 ;
  unsigned char *tmp___96 ;
  int tmp___97 ;
  size_t tmp___98 ;
  char *next___0 ;
  void *tmp___99 ;
  size_t tmp___100 ;
  size_t togo___1 ;
  size_t tmp___101 ;
  int tmp___102 ;
  unsigned char *tmp___104 ;
  size_t tmp___105 ;
  unsigned char *tmp___107 ;
  size_t tmp___108 ;
  unsigned char *tmp___110 ;
  size_t tmp___111 ;
  unsigned char *tmp___113 ;
  int tmp___114 ;
  size_t tmp___115 ;
  unsigned char *tmp___117 ;
  size_t tmp___118 ;
  unsigned char *tmp___120 ;
  int tmp___121 ;
  size_t tmp___122 ;
  size_t togo___2 ;
  size_t tmp___123 ;
  size_t togo___3 ;
  size_t tmp___124 ;
  size_t togo___4 ;
  unsigned char *tmp___126 ;
  size_t tmp___127 ;
  unsigned char *tmp___129 ;
  int tmp___130 ;
  size_t tmp___131 ;
  size_t tmp___132 ;
  unsigned char *end ;
  size_t copy ;
  size_t have ;
  size_t size ;
  size_t tmp___133 ;
  void *tmp___134 ;
  unsigned char *tmp___136 ;
  int tmp___137 ;
  size_t tmp___138 ;
  unsigned char *end___0 ;
  size_t copy___0 ;
  size_t have___0 ;
  size_t size___0 ;
  size_t tmp___139 ;
  void *tmp___140 ;
  unsigned char *tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  unsigned char *tmp___146 ;
  size_t tmp___147 ;
  unsigned char *tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  int tmp___152 ;

  {
  if (save) {
    g.stamp = (time_t )0;
    while (1) {
      if ((unsigned long )g.hname != (unsigned long )((void *)0)) {
        free((void *)g.hname);
        g.hname = (char *)((void *)0);
      }
      break;
    }
    while (1) {
      if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
        free((void *)g.hcomm);
        g.hcomm = (char *)((void *)0);
      }
      break;
    }
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      g.magic1 = 0;
    } else {
      tmp___1 = load();
      if (tmp___1 == 0UL) {
        g.magic1 = 0;
      } else {
        (g.in_left) --;
        tmp___0 = g.in_next;
        (g.in_next) ++;
        g.magic1 = (int )*tmp___0;
      }
    }
  } else {
    (g.in_left) --;
    tmp___0 = g.in_next;
    (g.in_next) ++;
    g.magic1 = (int )*tmp___0;
  }
  if (g.in_eof) {
    g.magic1 = -1;
    return (-1);
  }
  magic = (unsigned int )g.magic1 << 8;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp___4 = 0;
    } else {
      tmp___5 = load();
      if (tmp___5 == 0UL) {
        tmp___4 = 0;
      } else {
        (g.in_left) --;
        tmp___3 = g.in_next;
        (g.in_next) ++;
        tmp___4 = (int )*tmp___3;
      }
    }
  } else {
    (g.in_left) --;
    tmp___3 = g.in_next;
    (g.in_next) ++;
    tmp___4 = (int )*tmp___3;
  }
  magic += (unsigned int )tmp___4;
  if (g.in_eof) {
    return (-2);
  }
  if (magic % 31U == 0U) {
    if ((magic & 36640U) == 2048U) {
      g.form = 1;
      return (8);
    }
  }
  if (magic == 8093U) {
    g.form = -1;
    return (257);
  }
  if (magic == 20555U) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___8 = load();
        if (tmp___8 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___7 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___7;
        }
      }
    } else {
      (g.in_left) --;
      tmp___7 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___7;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___11 = 0;
      } else {
        tmp___12 = load();
        if (tmp___12 == 0UL) {
          tmp___11 = 0;
        } else {
          (g.in_left) --;
          tmp___10 = g.in_next;
          (g.in_next) ++;
          tmp___11 = (int )*tmp___10;
        }
      }
    } else {
      (g.in_left) --;
      tmp___10 = g.in_next;
      (g.in_next) ++;
      tmp___11 = (int )*tmp___10;
    }
    magic = tmp2 + ((unsigned int )tmp___11 << 8);
    if (g.in_eof) {
      return (-3);
    }
    if (magic == 513U) {
      return (-5);
    } else
    if (magic == 2054U) {
      return (-5);
    }
    if (magic != 1027U) {
      return (-4);
    }
    g.zip64 = 0;
    while (1) {
      togo = (size_t )2;
      while (togo > g.in_left) {
        togo -= g.in_left;
        tmp___13 = load();
        if (tmp___13 == 0UL) {
          return (-3);
        }
      }
      g.in_left -= togo;
      g.in_next += togo;
      break;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___16 = load();
        if (tmp___16 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___15 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___15;
        }
      }
    } else {
      (g.in_left) --;
      tmp___15 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___15;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___19 = 0;
      } else {
        tmp___20 = load();
        if (tmp___20 == 0UL) {
          tmp___19 = 0;
        } else {
          (g.in_left) --;
          tmp___18 = g.in_next;
          (g.in_next) ++;
          tmp___19 = (int )*tmp___18;
        }
      }
    } else {
      (g.in_left) --;
      tmp___18 = g.in_next;
      (g.in_next) ++;
      tmp___19 = (int )*tmp___18;
    }
    flags = tmp2 + ((unsigned int )tmp___19 << 8);
    if (flags & 63472U) {
      return (-4);
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        method = 0U;
      } else {
        tmp___23 = load();
        if (tmp___23 == 0UL) {
          method = 0U;
        } else {
          (g.in_left) --;
          tmp___22 = g.in_next;
          (g.in_next) ++;
          method = (unsigned int )*tmp___22;
        }
      }
    } else {
      (g.in_left) --;
      tmp___22 = g.in_next;
      (g.in_next) ++;
      method = (unsigned int )*tmp___22;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___26 = 0;
      } else {
        tmp___27 = load();
        if (tmp___27 == 0UL) {
          tmp___26 = 0;
        } else {
          (g.in_left) --;
          tmp___25 = g.in_next;
          (g.in_next) ++;
          tmp___26 = (int )*tmp___25;
        }
      }
    } else {
      (g.in_left) --;
      tmp___25 = g.in_next;
      (g.in_next) ++;
      tmp___26 = (int )*tmp___25;
    }
    if (tmp___26 != 0) {
      method = 256U;
    } else
    if (flags & 1U) {
      method = 256U;
    }
    if (save) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___30 = load();
          if (tmp___30 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___29 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___29;
          }
        }
      } else {
        (g.in_left) --;
        tmp___29 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___29;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___33 = 0;
        } else {
          tmp___34 = load();
          if (tmp___34 == 0UL) {
            tmp___33 = 0;
          } else {
            (g.in_left) --;
            tmp___32 = g.in_next;
            (g.in_next) ++;
            tmp___33 = (int )*tmp___32;
          }
        }
      } else {
        (g.in_left) --;
        tmp___32 = g.in_next;
        (g.in_next) ++;
        tmp___33 = (int )*tmp___32;
      }
      tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___33 << 8));
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___37 = load();
          if (tmp___37 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___36 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___36;
          }
        }
      } else {
        (g.in_left) --;
        tmp___36 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___36;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___40 = 0;
        } else {
          tmp___41 = load();
          if (tmp___41 == 0UL) {
            tmp___40 = 0;
          } else {
            (g.in_left) --;
            tmp___39 = g.in_next;
            (g.in_next) ++;
            tmp___40 = (int )*tmp___39;
          }
        }
      } else {
        (g.in_left) --;
        tmp___39 = g.in_next;
        (g.in_next) ++;
        tmp___40 = (int )*tmp___39;
      }
      g.stamp = dos2time(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___40 << 8)) << 16));
    } else {
      while (1) {
        togo___0 = (size_t )4;
        while (togo___0 > g.in_left) {
          togo___0 -= g.in_left;
          tmp___42 = load();
          if (tmp___42 == 0UL) {
            return (-3);
          }
        }
        g.in_left -= togo___0;
        g.in_next += togo___0;
        break;
      }
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___45 = load();
        if (tmp___45 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___44 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___44;
        }
      }
    } else {
      (g.in_left) --;
      tmp___44 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___44;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___48 = 0;
      } else {
        tmp___49 = load();
        if (tmp___49 == 0UL) {
          tmp___48 = 0;
        } else {
          (g.in_left) --;
          tmp___47 = g.in_next;
          (g.in_next) ++;
          tmp___48 = (int )*tmp___47;
        }
      }
    } else {
      (g.in_left) --;
      tmp___47 = g.in_next;
      (g.in_next) ++;
      tmp___48 = (int )*tmp___47;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___48 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___52 = load();
        if (tmp___52 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___51 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___51;
        }
      }
    } else {
      (g.in_left) --;
      tmp___51 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___51;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___55 = 0;
      } else {
        tmp___56 = load();
        if (tmp___56 == 0UL) {
          tmp___55 = 0;
        } else {
          (g.in_left) --;
          tmp___54 = g.in_next;
          (g.in_next) ++;
          tmp___55 = (int )*tmp___54;
        }
      }
    } else {
      (g.in_left) --;
      tmp___54 = g.in_next;
      (g.in_next) ++;
      tmp___55 = (int )*tmp___54;
    }
    g.zip_crc = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___55 << 8)) << 16);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___59 = load();
        if (tmp___59 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___58 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___58;
        }
      }
    } else {
      (g.in_left) --;
      tmp___58 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___58;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___62 = 0;
      } else {
        tmp___63 = load();
        if (tmp___63 == 0UL) {
          tmp___62 = 0;
        } else {
          (g.in_left) --;
          tmp___61 = g.in_next;
          (g.in_next) ++;
          tmp___62 = (int )*tmp___61;
        }
      }
    } else {
      (g.in_left) --;
      tmp___61 = g.in_next;
      (g.in_next) ++;
      tmp___62 = (int )*tmp___61;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___62 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___66 = load();
        if (tmp___66 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___65 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___65;
        }
      }
    } else {
      (g.in_left) --;
      tmp___65 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___65;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___69 = 0;
      } else {
        tmp___70 = load();
        if (tmp___70 == 0UL) {
          tmp___69 = 0;
        } else {
          (g.in_left) --;
          tmp___68 = g.in_next;
          (g.in_next) ++;
          tmp___69 = (int )*tmp___68;
        }
      }
    } else {
      (g.in_left) --;
      tmp___68 = g.in_next;
      (g.in_next) ++;
      tmp___69 = (int )*tmp___68;
    }
    g.zip_clen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___69 << 8)) << 16);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___73 = load();
        if (tmp___73 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___72 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___72;
        }
      }
    } else {
      (g.in_left) --;
      tmp___72 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___72;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___76 = 0;
      } else {
        tmp___77 = load();
        if (tmp___77 == 0UL) {
          tmp___76 = 0;
        } else {
          (g.in_left) --;
          tmp___75 = g.in_next;
          (g.in_next) ++;
          tmp___76 = (int )*tmp___75;
        }
      }
    } else {
      (g.in_left) --;
      tmp___75 = g.in_next;
      (g.in_next) ++;
      tmp___76 = (int )*tmp___75;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___76 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___80 = load();
        if (tmp___80 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___79 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___79;
        }
      }
    } else {
      (g.in_left) --;
      tmp___79 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___79;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___83 = 0;
      } else {
        tmp___84 = load();
        if (tmp___84 == 0UL) {
          tmp___83 = 0;
        } else {
          (g.in_left) --;
          tmp___82 = g.in_next;
          (g.in_next) ++;
          tmp___83 = (int )*tmp___82;
        }
      }
    } else {
      (g.in_left) --;
      tmp___82 = g.in_next;
      (g.in_next) ++;
      tmp___83 = (int )*tmp___82;
    }
    g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___83 << 8)) << 16);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___87 = load();
        if (tmp___87 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___86 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___86;
        }
      }
    } else {
      (g.in_left) --;
      tmp___86 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___86;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___90 = 0;
      } else {
        tmp___91 = load();
        if (tmp___91 == 0UL) {
          tmp___90 = 0;
        } else {
          (g.in_left) --;
          tmp___89 = g.in_next;
          (g.in_next) ++;
          tmp___90 = (int )*tmp___89;
        }
      }
    } else {
      (g.in_left) --;
      tmp___89 = g.in_next;
      (g.in_next) ++;
      tmp___90 = (int )*tmp___89;
    }
    fname = tmp2 + ((unsigned int )tmp___90 << 8);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___94 = load();
        if (tmp___94 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___93 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___93;
        }
      }
    } else {
      (g.in_left) --;
      tmp___93 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___93;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___97 = 0;
      } else {
        tmp___98 = load();
        if (tmp___98 == 0UL) {
          tmp___97 = 0;
        } else {
          (g.in_left) --;
          tmp___96 = g.in_next;
          (g.in_next) ++;
          tmp___97 = (int )*tmp___96;
        }
      }
    } else {
      (g.in_left) --;
      tmp___96 = g.in_next;
      (g.in_next) ++;
      tmp___97 = (int )*tmp___96;
    }
    extra = tmp2 + ((unsigned int )tmp___97 << 8);
    if (save) {
      if (g.in_eof) {
        return (-3);
      }
      tmp___99 = alloc((void *)0, (size_t )(fname + 1U));
      g.hname = (char *)tmp___99;
      next___0 = g.hname;
      while ((size_t )fname > g.in_left) {
        memcpy((void * __restrict  )next___0, (void const   * __restrict  )g.in_next,
               g.in_left);
        fname = (unsigned int )((size_t )fname - g.in_left);
        next___0 += g.in_left;
        tmp___100 = load();
        if (tmp___100 == 0UL) {
          return (-3);
        }
      }
      memcpy((void * __restrict  )next___0, (void const   * __restrict  )g.in_next,
             (size_t )fname);
      g.in_left -= (size_t )fname;
      g.in_next += fname;
      next___0 += fname;
      *next___0 = (char)0;
    } else {
      while (1) {
        togo___1 = (size_t )fname;
        while (togo___1 > g.in_left) {
          togo___1 -= g.in_left;
          tmp___101 = load();
          if (tmp___101 == 0UL) {
            return (-3);
          }
        }
        g.in_left -= togo___1;
        g.in_next += togo___1;
        break;
      }
    }
    read_extra(extra, save);
    g.form = (int )(2U + ((flags & 8U) >> 3));
    if (g.in_eof) {
      tmp___102 = -3;
    } else {
      tmp___102 = (int )method;
    }
    return (tmp___102);
  }
  if (magic != 8075U) {
    (g.in_left) ++;
    (g.in_next) --;
    return (-2);
  }
  crc = 4142483145UL;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      method = 0U;
    } else {
      tmp___105 = load();
      if (tmp___105 == 0UL) {
        method = 0U;
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___104 = g.in_next;
        (g.in_next) ++;
        method = (unsigned int )*tmp___104;
      }
    }
  } else {
    (g.in_left) --;
    crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
    tmp___104 = g.in_next;
    (g.in_next) ++;
    method = (unsigned int )*tmp___104;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      flags = 0U;
    } else {
      tmp___108 = load();
      if (tmp___108 == 0UL) {
        flags = 0U;
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___107 = g.in_next;
        (g.in_next) ++;
        flags = (unsigned int )*tmp___107;
      }
    }
  } else {
    (g.in_left) --;
    crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
    tmp___107 = g.in_next;
    (g.in_next) ++;
    flags = (unsigned int )*tmp___107;
  }
  if (flags & 224U) {
    return (-4);
  }
  if (save) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___111 = load();
        if (tmp___111 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___110 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___110;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___110 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___110;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___114 = 0;
      } else {
        tmp___115 = load();
        if (tmp___115 == 0UL) {
          tmp___114 = 0;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___113 = g.in_next;
          (g.in_next) ++;
          tmp___114 = (int )*tmp___113;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___113 = g.in_next;
      (g.in_next) ++;
      tmp___114 = (int )*tmp___113;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___114 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___118 = load();
        if (tmp___118 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___117 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___117;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___117 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___117;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___121 = 0;
      } else {
        tmp___122 = load();
        if (tmp___122 == 0UL) {
          tmp___121 = 0;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___120 = g.in_next;
          (g.in_next) ++;
          tmp___121 = (int )*tmp___120;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___120 = g.in_next;
      (g.in_next) ++;
      tmp___121 = (int )*tmp___120;
    }
    g.stamp = tolong(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___121 << 8)) << 16));
  } else {
    while (1) {
      togo___2 = (size_t )4;
      while (togo___2 > g.in_left) {
        crc = crc32z(crc, (unsigned char const   *)g.in_next, g.in_left);
        togo___2 -= g.in_left;
        tmp___123 = load();
        if (tmp___123 == 0UL) {
          return (-3);
        }
      }
      crc = crc32z(crc, (unsigned char const   *)g.in_next, togo___2);
      g.in_left -= togo___2;
      g.in_next += togo___2;
      break;
    }
  }
  while (1) {
    togo___3 = (size_t )2;
    while (togo___3 > g.in_left) {
      crc = crc32z(crc, (unsigned char const   *)g.in_next, g.in_left);
      togo___3 -= g.in_left;
      tmp___124 = load();
      if (tmp___124 == 0UL) {
        return (-3);
      }
    }
    crc = crc32z(crc, (unsigned char const   *)g.in_next, togo___3);
    g.in_left -= togo___3;
    g.in_next += togo___3;
    break;
  }
  if (flags & 4U) {
    while (1) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___127 = load();
          if (tmp___127 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
            tmp___126 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___126;
          }
        }
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___126 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___126;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___130 = 0;
        } else {
          tmp___131 = load();
          if (tmp___131 == 0UL) {
            tmp___130 = 0;
          } else {
            (g.in_left) --;
            crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
            tmp___129 = g.in_next;
            (g.in_next) ++;
            tmp___130 = (int )*tmp___129;
          }
        }
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___129 = g.in_next;
        (g.in_next) ++;
        tmp___130 = (int )*tmp___129;
      }
      togo___4 = (size_t )(tmp2 + ((unsigned int )tmp___130 << 8));
      while (togo___4 > g.in_left) {
        crc = crc32z(crc, (unsigned char const   *)g.in_next, g.in_left);
        togo___4 -= g.in_left;
        tmp___132 = load();
        if (tmp___132 == 0UL) {
          return (-3);
        }
      }
      crc = crc32z(crc, (unsigned char const   *)g.in_next, togo___4);
      g.in_left -= togo___4;
      g.in_next += togo___4;
      break;
    }
  }
  if (flags & 8U) {
    if (save) {
      while (1) {
        size = (size_t )0;
        have = (size_t )0;
        while (1) {
          if (g.in_left == 0UL) {
            tmp___133 = load();
            if (tmp___133 == 0UL) {
              return (-3);
            }
          }
          tmp___134 = memchr((void const   *)g.in_next, 0, g.in_left);
          end = (unsigned char *)tmp___134;
          if ((unsigned long )end == (unsigned long )((void *)0)) {
            copy = g.in_left;
          } else {
            copy = (size_t )(end - g.in_next) + 1UL;
          }
          have = vmemcpy(& g.hname, & size, have, (void *)g.in_next, copy);
          g.in_left -= copy;
          g.in_next += copy;
          if (! ((unsigned long )end == (unsigned long )((void *)0))) {
            break;
          }
        }
        crc = crc32z(crc, (unsigned char const   *)((unsigned char *)g.hname), have);
        break;
      }
    } else {
      while (1) {
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___137 = 0;
          } else {
            tmp___138 = load();
            if (tmp___138 == 0UL) {
              tmp___137 = 0;
            } else {
              (g.in_left) --;
              crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
              tmp___136 = g.in_next;
              (g.in_next) ++;
              tmp___137 = (int )*tmp___136;
            }
          }
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___136 = g.in_next;
          (g.in_next) ++;
          tmp___137 = (int )*tmp___136;
        }
        if (! (tmp___137 != 0)) {
          break;
        }
      }
    }
  }
  if (flags & 16U) {
    if (save) {
      while (1) {
        size___0 = (size_t )0;
        have___0 = (size_t )0;
        while (1) {
          if (g.in_left == 0UL) {
            tmp___139 = load();
            if (tmp___139 == 0UL) {
              return (-3);
            }
          }
          tmp___140 = memchr((void const   *)g.in_next, 0, g.in_left);
          end___0 = (unsigned char *)tmp___140;
          if ((unsigned long )end___0 == (unsigned long )((void *)0)) {
            copy___0 = g.in_left;
          } else {
            copy___0 = (size_t )(end___0 - g.in_next) + 1UL;
          }
          have___0 = vmemcpy(& g.hcomm, & size___0, have___0, (void *)g.in_next, copy___0);
          g.in_left -= copy___0;
          g.in_next += copy___0;
          if (! ((unsigned long )end___0 == (unsigned long )((void *)0))) {
            break;
          }
        }
        crc = crc32z(crc, (unsigned char const   *)((unsigned char *)g.hcomm), have___0);
        break;
      }
    } else {
      while (1) {
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___143 = 0;
          } else {
            tmp___144 = load();
            if (tmp___144 == 0UL) {
              tmp___143 = 0;
            } else {
              (g.in_left) --;
              crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
              tmp___142 = g.in_next;
              (g.in_next) ++;
              tmp___143 = (int )*tmp___142;
            }
          }
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___142 = g.in_next;
          (g.in_next) ++;
          tmp___143 = (int )*tmp___142;
        }
        if (! (tmp___143 != 0)) {
          break;
        }
      }
    }
  }
  if (flags & 2U) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___147 = load();
        if (tmp___147 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___146 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___146;
        }
      }
    } else {
      (g.in_left) --;
      tmp___146 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___146;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___150 = 0;
      } else {
        tmp___151 = load();
        if (tmp___151 == 0UL) {
          tmp___150 = 0;
        } else {
          (g.in_left) --;
          tmp___149 = g.in_next;
          (g.in_next) ++;
          tmp___150 = (int )*tmp___149;
        }
      }
    } else {
      (g.in_left) --;
      tmp___149 = g.in_next;
      (g.in_next) ++;
      tmp___150 = (int )*tmp___149;
    }
    if ((unsigned long )(tmp2 + ((unsigned int )tmp___150 << 8)) != (crc & 65535UL)) {
      return (-6);
    }
  }
  g.form = 0;
  if (g.in_eof) {
    tmp___152 = -3;
  } else {
    tmp___152 = (int )method;
  }
  return (tmp___152);
}
}
static int more_zip_entries(void) 
{ 
  unsigned long sig ;
  int ret ;
  int n ;
  unsigned char *first ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  unsigned char central[4] ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  size_t tmp___8 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  unsigned char head[42] ;
  size_t need ;
  size_t part ;
  size_t len ;
  size_t i ;
  size_t tmp___16 ;
  size_t togo ;
  size_t tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;

  {
  central[0] = (unsigned char)80;
  central[1] = (unsigned char)75;
  central[2] = (unsigned char)1;
  central[3] = (unsigned char)2;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp2 = 0U;
    } else {
      tmp___1 = load();
      if (tmp___1 == 0UL) {
        tmp2 = 0U;
      } else {
        (g.in_left) --;
        tmp___0 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___0;
      }
    }
  } else {
    (g.in_left) --;
    tmp___0 = g.in_next;
    (g.in_next) ++;
    tmp2 = (unsigned int )*tmp___0;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp___4 = 0;
    } else {
      tmp___5 = load();
      if (tmp___5 == 0UL) {
        tmp___4 = 0;
      } else {
        (g.in_left) --;
        tmp___3 = g.in_next;
        (g.in_next) ++;
        tmp___4 = (int )*tmp___3;
      }
    }
  } else {
    (g.in_left) --;
    tmp___3 = g.in_next;
    (g.in_next) ++;
    tmp___4 = (int )*tmp___3;
  }
  tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___4 << 8));
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp2 = 0U;
    } else {
      tmp___8 = load();
      if (tmp___8 == 0UL) {
        tmp2 = 0U;
      } else {
        (g.in_left) --;
        tmp___7 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___7;
      }
    }
  } else {
    (g.in_left) --;
    tmp___7 = g.in_next;
    (g.in_next) ++;
    tmp2 = (unsigned int )*tmp___7;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp___11 = 0;
    } else {
      tmp___12 = load();
      if (tmp___12 == 0UL) {
        tmp___11 = 0;
      } else {
        (g.in_left) --;
        tmp___10 = g.in_next;
        (g.in_next) ++;
        tmp___11 = (int )*tmp___10;
      }
    }
  } else {
    (g.in_left) --;
    tmp___10 = g.in_next;
    (g.in_next) ++;
    tmp___11 = (int )*tmp___10;
  }
  sig = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___11 << 8)) << 16);
  if (! g.in_eof) {
    if (sig == 67324752UL) {
      tmp___13 = 1;
    } else {
      tmp___13 = 0;
    }
  } else {
    tmp___13 = 0;
  }
  ret = tmp___13;
  if (! g.list) {
    return (ret);
  } else
  if (g.verbosity < 2) {
    return (ret);
  }
  if (sig == 33639248UL) {
    n = 4;
  } else {
    n = 0;
  }
  while (1) {
    if (g.in_left == 0UL) {
      tmp___14 = load();
      if (tmp___14 == 0UL) {
        return (ret);
      }
    }
    if (n == 0) {
      tmp___15 = memchr((void const   *)g.in_next, (int )central[0], g.in_left);
      first = (unsigned char *)tmp___15;
      if ((unsigned long )first == (unsigned long )((void *)0)) {
        g.in_left = (size_t )0;
      } else {
        n ++;
        g.in_left -= (size_t )((first - g.in_next) + 1L);
        g.in_next = first + 1;
      }
    } else
    if (n < 4) {
      if ((int )*(g.in_next + 0) == (int )central[n]) {
        n ++;
        (g.in_next) ++;
        (g.in_left) --;
      } else {
        n = 0;
      }
    } else {
      need = (size_t )42;
      part = (size_t )0;
      if (need > g.in_left) {
        part = g.in_left;
        memcpy((void * __restrict  )((head + 42) - need), (void const   * __restrict  )g.in_next,
               part);
        need -= part;
        g.in_left = (size_t )0;
        tmp___16 = load();
        if (tmp___16 == 0UL) {
          return (ret);
        }
      }
      memcpy((void * __restrict  )((head + 42) - need), (void const   * __restrict  )g.in_next,
             need);
      if ((unsigned long )((unsigned int )*((head + 12) + 0) + ((unsigned int )*((head + 12) + 1) << 8)) + ((unsigned long )((unsigned int )*(((head + 12) + 2) + 0) + ((unsigned int )*(((head + 12) + 2) + 1) << 8)) << 16) == g.out_check) {
        if ((unsigned long )((unsigned int )*((head + 38) + 0) + ((unsigned int )*((head + 38) + 1) << 8)) + ((unsigned long )((unsigned int )*(((head + 38) + 2) + 0) + ((unsigned int )*(((head + 38) + 2) + 1) << 8)) << 16) == 0UL) {
          g.in_next += need;
          g.in_left -= need;
          len = (size_t )((unsigned int )*((head + 28) + 0) + ((unsigned int )*((head + 28) + 1) << 8));
          if (len == 0UL) {
            return (ret);
          }
          while (1) {
            togo = (unsigned long )((unsigned int )*((head + 24) + 0) + ((unsigned int )*((head + 24) + 1) << 8)) + (unsigned long )((unsigned int )*((head + 26) + 0) + ((unsigned int )*((head + 26) + 1) << 8));
            while (togo > g.in_left) {
              togo -= g.in_left;
              tmp___17 = load();
              if (tmp___17 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo;
            g.in_next += togo;
            break;
          }
          need = len;
          tmp___18 = alloc((void *)0, len + 1UL);
          g.hcomm = (char *)tmp___18;
          while (need > g.in_left) {
            memcpy((void * __restrict  )((g.hcomm + len) - need), (void const   * __restrict  )g.in_next,
                   g.in_left);
            need -= g.in_left;
            g.in_left = (size_t )0;
            tmp___19 = load();
            if (tmp___19 == 0UL) {
              while (1) {
                if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
                  free((void *)g.hcomm);
                  g.hcomm = (char *)((void *)0);
                }
                break;
              }
              return (ret);
            }
          }
          memcpy((void * __restrict  )((g.hcomm + len) - need), (void const   * __restrict  )g.in_next,
                 need);
          g.in_next += need;
          g.in_left -= need;
          i = (size_t )0;
          while (i < len) {
            if ((int )*(g.hcomm + i) == 0) {
              *(g.hcomm + i) = (char )' ';
            }
            i ++;
          }
          *(g.hcomm + len) = (char)0;
          return (ret);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if (part) {
          memmove((void *)(g.in_next + part), (void const   *)g.in_next, g.in_left);
          memcpy((void * __restrict  )g.in_next, (void const   * __restrict  )(head),
                 part);
          g.in_left += part;
        }
        n = 0;
      }
    }
  }
}
}
static size_t compressed_suffix(char *nm ) 
{ 
  size_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  len = strlen((char const   *)nm);
  if (len > 4UL) {
    nm += len - 4UL;
    len = (size_t )4;
    tmp = strcmp((char const   *)nm, ".zip");
    if (tmp == 0) {
      return ((size_t )4);
    } else {
      tmp___0 = strcmp((char const   *)nm, ".ZIP");
      if (tmp___0 == 0) {
        return ((size_t )4);
      } else {
        tmp___1 = strcmp((char const   *)nm, ".tgz");
        if (tmp___1 == 0) {
          return ((size_t )4);
        }
      }
    }
  }
  if (len > 3UL) {
    nm += len - 3UL;
    len = (size_t )3;
    tmp___2 = strcmp((char const   *)nm, ".gz");
    if (tmp___2 == 0) {
      return ((size_t )3);
    } else {
      tmp___3 = strcmp((char const   *)nm, "-gz");
      if (tmp___3 == 0) {
        return ((size_t )3);
      } else {
        tmp___4 = strcmp((char const   *)nm, ".zz");
        if (tmp___4 == 0) {
          return ((size_t )3);
        } else {
          tmp___5 = strcmp((char const   *)nm, "-zz");
          if (tmp___5 == 0) {
            return ((size_t )3);
          }
        }
      }
    }
  }
  if (len > 2UL) {
    nm += len - 2UL;
    tmp___6 = strcmp((char const   *)nm, ".z");
    if (tmp___6 == 0) {
      return ((size_t )2);
    } else {
      tmp___7 = strcmp((char const   *)nm, "-z");
      if (tmp___7 == 0) {
        return ((size_t )2);
      } else {
        tmp___8 = strcmp((char const   *)nm, "_z");
        if (tmp___8 == 0) {
          return ((size_t )2);
        } else {
          tmp___9 = strcmp((char const   *)nm, ".Z");
          if (tmp___9 == 0) {
            return ((size_t )2);
          }
        }
      }
    }
  }
  return ((size_t )0);
}
}
static void show_info(int method , unsigned long check , length_t len , int cont ) 
{ 
  size_t max ;
  size_t n ;
  time_t now ;
  char mod[26] ;
  char tag[49] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  double red ;

  {
  if (g.verbosity > 1) {
    max = (size_t )16;
  } else {
    max = (size_t )48;
  }
  memset((void *)(tag), 0, max + 1UL);
  if (cont) {
    strncpy((char * __restrict  )(tag), (char const   * __restrict  )"<...>", max + 1UL);
  } else
  if ((unsigned long )g.hname == (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)g.inf);
    tmp___0 = compressed_suffix(g.inf);
    n = tmp - tmp___0;
    if (n > max + 1UL) {
      tmp___1 = max + 1UL;
    } else {
      tmp___1 = n;
    }
    memcpy((void * __restrict  )(tag), (void const   * __restrict  )g.inf, tmp___1);
    tmp___2 = strcmp((char const   *)(g.inf + n), ".tgz");
    if (tmp___2 == 0) {
      if (n < max + 1UL) {
        strncpy((char * __restrict  )(tag + n), (char const   * __restrict  )".tar",
                (max + 1UL) - n);
      }
    }
  } else {
    strncpy((char * __restrict  )(tag), (char const   * __restrict  )g.hname, max + 1UL);
  }
  if (tag[max]) {
    strcpy((char * __restrict  )((tag + max) - 3), (char const   * __restrict  )"...");
  }
  if (g.stamp) {
    if (! cont) {
      tmp___3 = ctime((time_t const   *)(& g.stamp));
      strcpy((char * __restrict  )(mod), (char const   * __restrict  )tmp___3);
      now = time((time_t *)((void *)0));
      tmp___4 = ctime((time_t const   *)(& now));
      tmp___5 = strcmp((char const   *)(mod + 20), (char const   *)(tmp___4 + 20));
      if (tmp___5 != 0) {
        strcpy((char * __restrict  )(mod + 11), (char const   * __restrict  )(mod + 19));
      }
    } else {
      strcpy((char * __restrict  )(mod + 4), (char const   * __restrict  )"------ -----");
    }
  } else {
    strcpy((char * __restrict  )(mod + 4), (char const   * __restrict  )"------ -----");
  }
  mod[16] = (char)0;
  if (g.first) {
    if (g.verbosity > 1) {
      fputs((char const   * __restrict  )"method    check    timestamp    ", (FILE * __restrict  )stdout);
    }
    if (g.verbosity > 0) {
      puts("compressed   original reduced  name");
    }
    g.first = 0;
  }
  if (g.verbosity > 1) {
    if (g.form == 3) {
      if (! g.decode) {
        printf((char const   * __restrict  )"zip%3d  --------  %s  ", method, mod + 4);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (g.form > 1) {
      printf((char const   * __restrict  )"zip%3d  %08lx  %s  ", method, check, mod + 4);
    } else
    if (g.form == 1) {
      printf((char const   * __restrict  )"zlib%2d  %08lx  %s  ", method, check, mod + 4);
    } else
    if (method == 257) {
      printf((char const   * __restrict  )"lzw     --------  %s  ", mod + 4);
    } else {
      printf((char const   * __restrict  )"gzip%2d  %08lx  %s  ", method, check, mod + 4);
    }
  }
  if (g.verbosity > 0) {
    red = (100. * ((double )len - (double )g.in_tot)) / (double )len;
    if (g.form == 3) {
      if (! g.decode) {
        printf((char const   * __restrict  )"%10ju %10ju?  unk    %s\n", g.in_tot,
               len, tag);
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (method == 8) {
      if (g.in_tot > (len + (len >> 10)) + 12UL) {
        printf((char const   * __restrict  )"%10ju %10ju?  unk    %s\n", g.in_tot,
               len, tag);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (method == 257) {
      if (g.in_tot > (len + (len >> 1)) + 3UL) {
        printf((char const   * __restrict  )"%10ju %10ju?  unk    %s\n", g.in_tot,
               len, tag);
      } else {
        printf((char const   * __restrict  )"%10ju %10ju %6.1f%%  %s\n", g.in_tot,
               len, red, tag);
      }
    } else {
      printf((char const   * __restrict  )"%10ju %10ju %6.1f%%  %s\n", g.in_tot, len,
             red, tag);
    }
  }
  if (g.verbosity > 1) {
    if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
      puts((char const   *)g.hcomm);
    }
  }
  return;
}
}
static void list_info(void) 
{ 
  int method ;
  size_t n ;
  off_t at ;
  unsigned char tail[8] ;
  unsigned long check ;
  length_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned char *tmp___1 ;
  length_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  in_init();
  method = get_header(1);
  if (method < 0) {
    if (method == -6) {
      tmp___0 = "skipping: %s corrupt: header crc error";
    } else {
      if (method == -1) {
        tmp = "skipping: %s empty";
      } else {
        tmp = "skipping: %s unrecognized format";
      }
      tmp___0 = tmp;
    }
    complain((char *)tmp___0, g.inf);
    return;
  }
  load_wait();
  if (g.form > 1) {
    more_zip_entries();
    g.in_tot = g.zip_clen;
    show_info(method, g.zip_crc, g.zip_ulen, 0);
    return;
  }
  if (g.form == 1) {
    at = lseek(g.ind, (__off64_t )0, 2);
    if (at == -1L) {
      check = 0UL;
      while (1) {
        if (g.in_left < 4UL) {
          len = g.in_left;
        } else {
          len = (length_t )4;
        }
        g.in_next += g.in_left - len;
        while (1) {
          tmp___2 = len;
          len --;
          if (! tmp___2) {
            break;
          }
          tmp___1 = g.in_next;
          (g.in_next) ++;
          check = (check << 8) + (unsigned long )*tmp___1;
        }
        tmp___3 = load();
        if (! (tmp___3 != 0UL)) {
          break;
        }
      }
      check &= 4294967295UL;
    } else {
      g.in_tot = (length_t )at;
      lseek(g.ind, (__off64_t )-4, 2);
      readn(g.ind, tail, (size_t )4);
      check = ((unsigned long )(((unsigned int )tail[0] << 8) + (unsigned int )tail[1]) << 16) + (unsigned long )(((unsigned int )*((tail + 2) + 0) << 8) + (unsigned int )*((tail + 2) + 1));
    }
    g.in_tot -= 6UL;
    show_info(method, check, (length_t )0, 0);
    return;
  }
  if (method == 257) {
    at = lseek(g.ind, (__off64_t )0, 2);
    if (at == -1L) {
      while (1) {
        tmp___4 = load();
        if (! (tmp___4 != 0UL)) {
          break;
        }
      }
    } else {
      g.in_tot = (length_t )at;
    }
    g.in_tot -= 3UL;
    show_info(method, 0UL, (length_t )0, 0);
    return;
  }
  if (g.in_short) {
    if (g.in_left < 8UL) {
      complain((char *)"skipping: %s not a valid gzip file", g.inf);
      return;
    }
    g.in_tot = g.in_left - 8UL;
    memcpy((void * __restrict  )(tail), (void const   * __restrict  )(g.in_next + (g.in_left - 8UL)),
           (size_t )8);
  } else {
    at = lseek(g.ind, (__off64_t )-8, 2);
    if (at != -1L) {
      g.in_tot = ((length_t )at - g.in_tot) + g.in_left;
      readn(g.ind, tail, (size_t )8);
    } else {
      len = g.in_tot - g.in_left;
      while (1) {
        if (g.in_left < 8UL) {
          n = g.in_left;
        } else {
          n = (size_t )8;
        }
        memcpy((void * __restrict  )(tail), (void const   * __restrict  )(g.in_next + (g.in_left - n)),
               n);
        load();
        if (! (g.in_left == 32768UL)) {
          break;
        }
      }
      if (g.in_left < 8UL) {
        if (n + g.in_left < 8UL) {
          complain((char *)"skipping: %s not a valid gzip file", g.inf);
          return;
        }
        if (g.in_left) {
          if (n + g.in_left > 8UL) {
            memcpy((void * __restrict  )(tail), (void const   * __restrict  )((tail + n) - (8UL - g.in_left)),
                   8UL - g.in_left);
          }
          memcpy((void * __restrict  )((tail + 8) - g.in_left), (void const   * __restrict  )g.in_next,
                 g.in_left);
        }
      } else {
        memcpy((void * __restrict  )(tail), (void const   * __restrict  )(g.in_next + (g.in_left - 8UL)),
               (size_t )8);
      }
      g.in_tot -= len + 8UL;
    }
  }
  if (g.in_tot < 2UL) {
    complain((char *)"skipping: %s not a valid gzip file", g.inf);
    return;
  }
  check = (unsigned long )((unsigned int )tail[0] + ((unsigned int )tail[1] << 8)) + ((unsigned long )((unsigned int )*((tail + 2) + 0) + ((unsigned int )*((tail + 2) + 1) << 8)) << 16);
  len = (unsigned long )((unsigned int )*((tail + 4) + 0) + ((unsigned int )*((tail + 4) + 1) << 8)) + ((unsigned long )((unsigned int )*(((tail + 4) + 2) + 0) + ((unsigned int )*(((tail + 4) + 2) + 1) << 8)) << 16);
  show_info(method, check, len, 0);
  return;
}
}
static void cat(void) 
{ 
  unsigned char buf[1] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (g.magic1 != -1) {
    buf[0] = (unsigned char )g.magic1;
    tmp = writen(g.outd, (void const   *)(buf), (size_t )1);
    g.out_tot += tmp;
  }
  while (g.in_left) {
    tmp___0 = writen(g.outd, (void const   *)g.in_next, g.in_left);
    g.out_tot += tmp___0;
    g.in_left = (size_t )0;
    load();
  }
  return;
}
}
static unsigned int inb(void *desc , unsigned char **buf ) 
{ 
  unsigned int len ;
  unsigned int tmp ;

  {
  if (g.in_left == 0UL) {
    load();
  }
  *buf = g.in_next;
  if (g.in_left > 4294967295UL) {
    tmp = 4294967295U;
  } else {
    tmp = (unsigned int )g.in_left;
  }
  len = tmp;
  g.in_next += len;
  g.in_left -= (size_t )len;
  return (len);
}
}
static unsigned char out_buf[32768U]  ;
static unsigned char out_copy[32768U]  ;
static size_t out_len  ;
static lock *outb_write_more  =    (lock *)((void *)0);
static lock *outb_check_more  ;
static void outb_write(void *dummy ) 
{ 
  size_t len ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___8 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3350U, "outb_write");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 3350U, "outb_write");
      }
      break;
    }
    tmp___4 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___4 == 0) {
      while (1) {
        while (1) {
          possess_(outb_write_more, "pigz.c", 3352L);
          wait_for_(outb_write_more, (enum wait_op )0, 1L, "pigz.c", 3353L);
          len = out_len;
          if (len) {
            if (g.decode == 1) {
              writen(g.outd, (void const   *)(out_copy), len);
            }
          }
          twist_(outb_write_more, (enum twist_op )0, 0L, "pigz.c", 3358L);
          if (! len) {
            break;
          }
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___8 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___8 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 3361U, "outb_write");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3361U, "outb_write");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void outb_check(void *dummy ) 
{ 
  size_t len ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___10 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3375U, "outb_check");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 3375U, "outb_check");
      }
      break;
    }
    tmp___6 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___6 == 0) {
      while (1) {
        while (1) {
          possess_(outb_check_more, "pigz.c", 3377L);
          wait_for_(outb_check_more, (enum wait_op )0, 1L, "pigz.c", 3378L);
          len = out_len;
          if (g.form == 1) {
            tmp___4 = adler32z(g.out_check, (unsigned char const   *)(out_copy), len);
            g.out_check = tmp___4;
          } else {
            tmp___5 = crc32z(g.out_check, (unsigned char const   *)(out_copy), len);
            g.out_check = tmp___5;
          }
          twist_(outb_check_more, (enum twist_op )0, 0L, "pigz.c", 3382L);
          if (! len) {
            break;
          }
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___10 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___10 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 3385U, "outb_check");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3385U, "outb_check");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static thread *wr  ;
static thread *ch  ;
static int outb(void *desc , unsigned char *buf , unsigned int len ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (g.procs > 1) {
    if ((unsigned long )outb_write_more == (unsigned long )((void *)0)) {
      outb_write_more = new_lock_(0L, "pigz.c", 3405L);
      outb_check_more = new_lock_(0L, "pigz.c", 3406L);
      wr = launch_(& outb_write, (void *)0, "pigz.c", 3407L);
      ch = launch_(& outb_check, (void *)0, "pigz.c", 3408L);
    }
    possess_(outb_check_more, "pigz.c", 3412L);
    wait_for_(outb_check_more, (enum wait_op )0, 0L, "pigz.c", 3413L);
    possess_(outb_write_more, "pigz.c", 3414L);
    wait_for_(outb_write_more, (enum wait_op )0, 0L, "pigz.c", 3415L);
    out_len = (size_t )len;
    g.out_tot += (length_t )len;
    memcpy((void * __restrict  )(out_copy), (void const   * __restrict  )buf, (size_t )len);
    twist_(outb_write_more, (enum twist_op )0, 1L, "pigz.c", 3421L);
    twist_(outb_check_more, (enum twist_op )0, 1L, "pigz.c", 3422L);
    if (len == 0U) {
      if ((unsigned long )outb_write_more != (unsigned long )((void *)0)) {
        join_(ch, "pigz.c", 3427L);
        join_(wr, "pigz.c", 3428L);
        free_lock_(outb_check_more, "pigz.c", 3429L);
        free_lock_(outb_write_more, "pigz.c", 3430L);
        outb_write_more = (lock *)((void *)0);
      }
    }
    return (0);
  }
  if (len) {
    if (g.decode == 1) {
      writen(g.outd, (void const   *)buf, (size_t )len);
    }
    if (g.form == 1) {
      tmp = adler32z(g.out_check, (unsigned char const   *)buf, (size_t )len);
      g.out_check = tmp;
    } else {
      tmp___0 = crc32z(g.out_check, (unsigned char const   *)buf, (size_t )len);
      g.out_check = tmp___0;
    }
    g.out_tot += (length_t )len;
  }
  return (0);
}
}
static void infchk(void) 
{ 
  int ret ;
  int cont ;
  int more ;
  unsigned long check ;
  unsigned long len ;
  unsigned long ktot ;
  z_stream strm___0 ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  length_t clen ;
  length_t ctot ;
  length_t utot ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned char *tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  unsigned char *tmp___11 ;
  size_t tmp___12 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  unsigned char *tmp___18 ;
  size_t tmp___19 ;
  unsigned char *tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  unsigned char *tmp___25 ;
  size_t tmp___26 ;
  unsigned char *tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  unsigned char *tmp___32 ;
  size_t tmp___33 ;
  unsigned char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  unsigned char *tmp___39 ;
  size_t tmp___40 ;
  unsigned char *tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;
  unsigned char *tmp___46 ;
  size_t tmp___47 ;
  unsigned char *tmp___49 ;
  int tmp___50 ;
  size_t tmp___51 ;
  unsigned char *tmp___53 ;
  size_t tmp___54 ;
  unsigned char *tmp___56 ;
  int tmp___57 ;
  size_t tmp___58 ;
  length_t tmp___59 ;
  unsigned char *tmp___61 ;
  size_t tmp___62 ;
  unsigned char *tmp___64 ;
  int tmp___65 ;
  size_t tmp___66 ;
  unsigned char *tmp___68 ;
  size_t tmp___69 ;
  unsigned char *tmp___71 ;
  int tmp___72 ;
  size_t tmp___73 ;
  unsigned char *tmp___75 ;
  size_t tmp___76 ;
  unsigned char *tmp___78 ;
  int tmp___79 ;
  size_t tmp___80 ;
  unsigned char *tmp___82 ;
  size_t tmp___83 ;
  unsigned char *tmp___85 ;
  int tmp___86 ;
  size_t tmp___87 ;
  unsigned char *tmp___89 ;
  int tmp___90 ;
  size_t tmp___91 ;
  unsigned char *tmp___93 ;
  int tmp___94 ;
  size_t tmp___95 ;
  unsigned char *tmp___97 ;
  int tmp___98 ;
  size_t tmp___99 ;
  unsigned char *tmp___101 ;
  int tmp___102 ;
  size_t tmp___103 ;
  unsigned char *tmp___105 ;
  size_t tmp___106 ;
  unsigned char *tmp___108 ;
  int tmp___109 ;
  size_t tmp___110 ;
  unsigned char *tmp___112 ;
  size_t tmp___113 ;
  unsigned char *tmp___115 ;
  int tmp___116 ;
  size_t tmp___117 ;
  unsigned char *tmp___119 ;
  size_t tmp___120 ;
  unsigned char *tmp___122 ;
  int tmp___123 ;
  size_t tmp___124 ;
  unsigned char *tmp___126 ;
  size_t tmp___127 ;
  unsigned char *tmp___129 ;
  int tmp___130 ;
  size_t tmp___131 ;
  unsigned long tmp___132 ;
  unsigned long tmp___133 ;
  unsigned char *tmp___134 ;
  size_t tmp___135 ;

  {
  utot = (length_t )0;
  ctot = utot;
  if (g.form == 1) {
    tmp = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
    ktot = tmp;
  } else {
    tmp___0 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
    ktot = tmp___0;
  }
  more = 0;
  cont = more;
  while (1) {
    g.in_tot = g.in_left;
    g.out_tot = (length_t )0;
    if (g.form == 1) {
      tmp___1 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
      g.out_check = tmp___1;
    } else {
      tmp___2 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
      g.out_check = tmp___2;
    }
    strm___0.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
    strm___0.zfree = (void (*)(voidpf opaque , voidpf address ))0;
    strm___0.opaque = (voidpf )0;
    ret = inflateBackInit_(& strm___0, 15, out_buf, "1.2.11", (int )sizeof(z_stream ));
    if (ret == -4) {
      try_throw_(12, (char *)"not enough memory", (void *)0);
    }
    if (ret != 0) {
      try_throw_(22, (char *)"internal error", (void *)0);
    }
    strm___0.avail_in = (uInt )0;
    strm___0.next_in = (Bytef *)0;
    ret = inflateBack(& strm___0, & inb, (void *)0, & outb, (void *)0);
    inflateBackEnd(& strm___0);
    if (ret == -3) {
      try_throw_(33, (char *)"%s: corrupted -- invalid deflate data (%s)", g.inf,
                 strm___0.msg, (void *)0);
    }
    if (ret == -5) {
      try_throw_(33, (char *)"%s: corrupted -- incomplete deflate data", g.inf, (void *)0);
    }
    if (ret != 1) {
      try_throw_(22, (char *)"internal error", (void *)0);
    }
    g.in_left += (size_t )strm___0.avail_in;
    g.in_next = strm___0.next_in;
    outb((void *)0, (unsigned char *)((void *)0), 0U);
    clen = g.in_tot - g.in_left;
    if (g.form > 1) {
      if (g.form == 3) {
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___5 = load();
            if (tmp___5 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___4 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___4;
            }
          }
        } else {
          (g.in_left) --;
          tmp___4 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___4;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___8 = 0;
          } else {
            tmp___9 = load();
            if (tmp___9 == 0UL) {
              tmp___8 = 0;
            } else {
              (g.in_left) --;
              tmp___7 = g.in_next;
              (g.in_next) ++;
              tmp___8 = (int )*tmp___7;
            }
          }
        } else {
          (g.in_left) --;
          tmp___7 = g.in_next;
          (g.in_next) ++;
          tmp___8 = (int )*tmp___7;
        }
        tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___8 << 8));
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___12 = load();
            if (tmp___12 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___11 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___11;
            }
          }
        } else {
          (g.in_left) --;
          tmp___11 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___11;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___15 = 0;
          } else {
            tmp___16 = load();
            if (tmp___16 == 0UL) {
              tmp___15 = 0;
            } else {
              (g.in_left) --;
              tmp___14 = g.in_next;
              (g.in_next) ++;
              tmp___15 = (int )*tmp___14;
            }
          }
        } else {
          (g.in_left) --;
          tmp___14 = g.in_next;
          (g.in_next) ++;
          tmp___15 = (int )*tmp___14;
        }
        g.zip_crc = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___15 << 8)) << 16);
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___19 = load();
            if (tmp___19 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___18 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___18;
            }
          }
        } else {
          (g.in_left) --;
          tmp___18 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___18;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___22 = 0;
          } else {
            tmp___23 = load();
            if (tmp___23 == 0UL) {
              tmp___22 = 0;
            } else {
              (g.in_left) --;
              tmp___21 = g.in_next;
              (g.in_next) ++;
              tmp___22 = (int )*tmp___21;
            }
          }
        } else {
          (g.in_left) --;
          tmp___21 = g.in_next;
          (g.in_next) ++;
          tmp___22 = (int )*tmp___21;
        }
        tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___22 << 8));
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___26 = load();
            if (tmp___26 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___25 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___25;
            }
          }
        } else {
          (g.in_left) --;
          tmp___25 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___25;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___29 = 0;
          } else {
            tmp___30 = load();
            if (tmp___30 == 0UL) {
              tmp___29 = 0;
            } else {
              (g.in_left) --;
              tmp___28 = g.in_next;
              (g.in_next) ++;
              tmp___29 = (int )*tmp___28;
            }
          }
        } else {
          (g.in_left) --;
          tmp___28 = g.in_next;
          (g.in_next) ++;
          tmp___29 = (int )*tmp___28;
        }
        g.zip_clen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___29 << 8)) << 16);
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___33 = load();
            if (tmp___33 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___32 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___32;
            }
          }
        } else {
          (g.in_left) --;
          tmp___32 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___32;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___36 = 0;
          } else {
            tmp___37 = load();
            if (tmp___37 == 0UL) {
              tmp___36 = 0;
            } else {
              (g.in_left) --;
              tmp___35 = g.in_next;
              (g.in_next) ++;
              tmp___36 = (int )*tmp___35;
            }
          }
        } else {
          (g.in_left) --;
          tmp___35 = g.in_next;
          (g.in_next) ++;
          tmp___36 = (int )*tmp___35;
        }
        tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___36 << 8));
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___40 = load();
            if (tmp___40 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___39 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___39;
            }
          }
        } else {
          (g.in_left) --;
          tmp___39 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___39;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___43 = 0;
          } else {
            tmp___44 = load();
            if (tmp___44 == 0UL) {
              tmp___43 = 0;
            } else {
              (g.in_left) --;
              tmp___42 = g.in_next;
              (g.in_next) ++;
              tmp___43 = (int )*tmp___42;
            }
          }
        } else {
          (g.in_left) --;
          tmp___42 = g.in_next;
          (g.in_next) ++;
          tmp___43 = (int )*tmp___42;
        }
        g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___43 << 8)) << 16);
        if (g.zip_crc == 134695760UL) {
          if (g.out_check != 134695760UL) {
            goto _L___0;
          } else
          if (g.zip_clen == 134695760UL) {
            if ((clen & 4294967295UL) != 134695760UL) {
              goto _L___0;
            } else
            if (g.zip_ulen == 134695760UL) {
              if (g.zip64) {
                tmp___59 = clen >> 32;
              } else {
                tmp___59 = g.out_tot;
              }
              if (tmp___59 != 134695760UL) {
                _L___0: /* CIL Label */ 
                g.zip_crc = g.zip_clen;
                g.zip_clen = g.zip_ulen;
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp2 = 0U;
                  } else {
                    tmp___47 = load();
                    if (tmp___47 == 0UL) {
                      tmp2 = 0U;
                    } else {
                      (g.in_left) --;
                      tmp___46 = g.in_next;
                      (g.in_next) ++;
                      tmp2 = (unsigned int )*tmp___46;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___46 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___46;
                }
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp___50 = 0;
                  } else {
                    tmp___51 = load();
                    if (tmp___51 == 0UL) {
                      tmp___50 = 0;
                    } else {
                      (g.in_left) --;
                      tmp___49 = g.in_next;
                      (g.in_next) ++;
                      tmp___50 = (int )*tmp___49;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___49 = g.in_next;
                  (g.in_next) ++;
                  tmp___50 = (int )*tmp___49;
                }
                tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___50 << 8));
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp2 = 0U;
                  } else {
                    tmp___54 = load();
                    if (tmp___54 == 0UL) {
                      tmp2 = 0U;
                    } else {
                      (g.in_left) --;
                      tmp___53 = g.in_next;
                      (g.in_next) ++;
                      tmp2 = (unsigned int )*tmp___53;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___53 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___53;
                }
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp___57 = 0;
                  } else {
                    tmp___58 = load();
                    if (tmp___58 == 0UL) {
                      tmp___57 = 0;
                    } else {
                      (g.in_left) --;
                      tmp___56 = g.in_next;
                      (g.in_next) ++;
                      tmp___57 = (int )*tmp___56;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___56 = g.in_next;
                  (g.in_next) ++;
                  tmp___57 = (int )*tmp___56;
                }
                g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___57 << 8)) << 16);
              }
            }
          }
        }
        if (g.zip64) {
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___62 = load();
              if (tmp___62 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___61 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___61;
              }
            }
          } else {
            (g.in_left) --;
            tmp___61 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___61;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___65 = 0;
            } else {
              tmp___66 = load();
              if (tmp___66 == 0UL) {
                tmp___65 = 0;
              } else {
                (g.in_left) --;
                tmp___64 = g.in_next;
                (g.in_next) ++;
                tmp___65 = (int )*tmp___64;
              }
            }
          } else {
            (g.in_left) --;
            tmp___64 = g.in_next;
            (g.in_next) ++;
            tmp___65 = (int )*tmp___64;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___65 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___69 = load();
              if (tmp___69 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___68 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___68;
              }
            }
          } else {
            (g.in_left) --;
            tmp___68 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___68;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___72 = 0;
            } else {
              tmp___73 = load();
              if (tmp___73 == 0UL) {
                tmp___72 = 0;
              } else {
                (g.in_left) --;
                tmp___71 = g.in_next;
                (g.in_next) ++;
                tmp___72 = (int )*tmp___71;
              }
            }
          } else {
            (g.in_left) --;
            tmp___71 = g.in_next;
            (g.in_next) ++;
            tmp___72 = (int )*tmp___71;
          }
          g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___72 << 8)) << 16);
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___76 = load();
              if (tmp___76 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___75 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___75;
              }
            }
          } else {
            (g.in_left) --;
            tmp___75 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___75;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___79 = 0;
            } else {
              tmp___80 = load();
              if (tmp___80 == 0UL) {
                tmp___79 = 0;
              } else {
                (g.in_left) --;
                tmp___78 = g.in_next;
                (g.in_next) ++;
                tmp___79 = (int )*tmp___78;
              }
            }
          } else {
            (g.in_left) --;
            tmp___78 = g.in_next;
            (g.in_next) ++;
            tmp___79 = (int )*tmp___78;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___79 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___83 = load();
              if (tmp___83 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___82 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___82;
              }
            }
          } else {
            (g.in_left) --;
            tmp___82 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___82;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___86 = 0;
            } else {
              tmp___87 = load();
              if (tmp___87 == 0UL) {
                tmp___86 = 0;
              } else {
                (g.in_left) --;
                tmp___85 = g.in_next;
                (g.in_next) ++;
                tmp___86 = (int )*tmp___85;
              }
            }
          } else {
            (g.in_left) --;
            tmp___85 = g.in_next;
            (g.in_next) ++;
            tmp___86 = (int )*tmp___85;
          }
        }
        if (g.in_eof) {
          try_throw_(33, (char *)"%s: corrupted entry -- missing trailer", g.inf,
                     (void *)0);
        }
      }
      check = g.zip_crc;
      if (check != g.out_check) {
        try_throw_(33, (char *)"%s: corrupted entry -- crc32 mismatch", g.inf, (void *)0);
      }
      if (g.zip_clen != (clen & 4294967295UL)) {
        try_throw_(33, (char *)"%s: corrupted entry -- length mismatch", g.inf, (void *)0);
      } else
      if (g.zip_ulen != (g.out_tot & 4294967295UL)) {
        try_throw_(33, (char *)"%s: corrupted entry -- length mismatch", g.inf, (void *)0);
      }
      more = more_zip_entries();
    } else
    if (g.form == 1) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___90 = 0;
        } else {
          tmp___91 = load();
          if (tmp___91 == 0UL) {
            tmp___90 = 0;
          } else {
            (g.in_left) --;
            tmp___89 = g.in_next;
            (g.in_next) ++;
            tmp___90 = (int )*tmp___89;
          }
        }
      } else {
        (g.in_left) --;
        tmp___89 = g.in_next;
        (g.in_next) ++;
        tmp___90 = (int )*tmp___89;
      }
      check = (unsigned long )tmp___90 << 24;
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___94 = 0;
        } else {
          tmp___95 = load();
          if (tmp___95 == 0UL) {
            tmp___94 = 0;
          } else {
            (g.in_left) --;
            tmp___93 = g.in_next;
            (g.in_next) ++;
            tmp___94 = (int )*tmp___93;
          }
        }
      } else {
        (g.in_left) --;
        tmp___93 = g.in_next;
        (g.in_next) ++;
        tmp___94 = (int )*tmp___93;
      }
      check += (unsigned long )tmp___94 << 16;
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___98 = 0;
        } else {
          tmp___99 = load();
          if (tmp___99 == 0UL) {
            tmp___98 = 0;
          } else {
            (g.in_left) --;
            tmp___97 = g.in_next;
            (g.in_next) ++;
            tmp___98 = (int )*tmp___97;
          }
        }
      } else {
        (g.in_left) --;
        tmp___97 = g.in_next;
        (g.in_next) ++;
        tmp___98 = (int )*tmp___97;
      }
      check += (unsigned long )((unsigned int )tmp___98 << 8);
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___102 = 0;
        } else {
          tmp___103 = load();
          if (tmp___103 == 0UL) {
            tmp___102 = 0;
          } else {
            (g.in_left) --;
            tmp___101 = g.in_next;
            (g.in_next) ++;
            tmp___102 = (int )*tmp___101;
          }
        }
      } else {
        (g.in_left) --;
        tmp___101 = g.in_next;
        (g.in_next) ++;
        tmp___102 = (int )*tmp___101;
      }
      check += (unsigned long )tmp___102;
      if (g.in_eof) {
        try_throw_(33, (char *)"%s: corrupted -- missing trailer", g.inf, (void *)0);
      }
      if (check != g.out_check) {
        try_throw_(33, (char *)"%s: corrupted -- adler32 mismatch", g.inf, (void *)0);
      }
    } else {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___106 = load();
          if (tmp___106 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___105 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___105;
          }
        }
      } else {
        (g.in_left) --;
        tmp___105 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___105;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___109 = 0;
        } else {
          tmp___110 = load();
          if (tmp___110 == 0UL) {
            tmp___109 = 0;
          } else {
            (g.in_left) --;
            tmp___108 = g.in_next;
            (g.in_next) ++;
            tmp___109 = (int )*tmp___108;
          }
        }
      } else {
        (g.in_left) --;
        tmp___108 = g.in_next;
        (g.in_next) ++;
        tmp___109 = (int )*tmp___108;
      }
      tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___109 << 8));
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___113 = load();
          if (tmp___113 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___112 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___112;
          }
        }
      } else {
        (g.in_left) --;
        tmp___112 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___112;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___116 = 0;
        } else {
          tmp___117 = load();
          if (tmp___117 == 0UL) {
            tmp___116 = 0;
          } else {
            (g.in_left) --;
            tmp___115 = g.in_next;
            (g.in_next) ++;
            tmp___116 = (int )*tmp___115;
          }
        }
      } else {
        (g.in_left) --;
        tmp___115 = g.in_next;
        (g.in_next) ++;
        tmp___116 = (int )*tmp___115;
      }
      check = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___116 << 8)) << 16);
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___120 = load();
          if (tmp___120 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___119 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___119;
          }
        }
      } else {
        (g.in_left) --;
        tmp___119 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___119;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___123 = 0;
        } else {
          tmp___124 = load();
          if (tmp___124 == 0UL) {
            tmp___123 = 0;
          } else {
            (g.in_left) --;
            tmp___122 = g.in_next;
            (g.in_next) ++;
            tmp___123 = (int )*tmp___122;
          }
        }
      } else {
        (g.in_left) --;
        tmp___122 = g.in_next;
        (g.in_next) ++;
        tmp___123 = (int )*tmp___122;
      }
      tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___123 << 8));
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___127 = load();
          if (tmp___127 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___126 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___126;
          }
        }
      } else {
        (g.in_left) --;
        tmp___126 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___126;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___130 = 0;
        } else {
          tmp___131 = load();
          if (tmp___131 == 0UL) {
            tmp___130 = 0;
          } else {
            (g.in_left) --;
            tmp___129 = g.in_next;
            (g.in_next) ++;
            tmp___130 = (int )*tmp___129;
          }
        }
      } else {
        (g.in_left) --;
        tmp___129 = g.in_next;
        (g.in_next) ++;
        tmp___130 = (int )*tmp___129;
      }
      len = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___130 << 8)) << 16);
      if (g.in_eof) {
        try_throw_(33, (char *)"%s: corrupted -- missing trailer", g.inf, (void *)0);
      }
      if (check != g.out_check) {
        try_throw_(33, (char *)"%s: corrupted -- crc32 mismatch", g.inf, (void *)0);
      }
      if (len != (g.out_tot & 4294967295UL)) {
        try_throw_(33, (char *)"%s: corrupted -- length mismatch", g.inf, (void *)0);
      }
    }
    if (g.list) {
      ctot += clen;
      utot += g.out_tot;
      if (g.form == 1) {
        tmp___132 = adler32_comb(ktot, check, g.out_tot);
        ktot = tmp___132;
      } else {
        tmp___133 = crc32_comb(ktot, check, g.out_tot);
        ktot = tmp___133;
      }
      g.in_tot = clen;
      show_info(8, check, g.out_tot, cont);
      if (cont) {
        cont = 2;
      } else {
        cont = 1;
      }
    }
    if (g.form == 0) {
      ret = get_header(0);
      if (! (ret == 8)) {
        break;
      }
    } else {
      break;
    }
  }
  if (cont > 1) {
    if (g.verbosity > 0) {
      if (g.verbosity > 1) {
        printf((char const   * __restrict  )"        %08lx                ", ktot);
      }
      printf((char const   * __restrict  )"%10ju %10ju %6.1f%%  (total)\n", ctot,
             utot, (100. * ((double )utot - (double )ctot)) / (double )utot);
    }
  }
  if (g.form == 0) {
    if (ret == -2) {
      if (g.force) {
        if (g.pipeout) {
          if (g.decode != 2) {
            if (! g.list) {
              cat();
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
  if (more) {
    complain((char *)"warning: %s: entries after the first were ignored", g.inf);
    g.keep = 1;
  } else
  if (g.verbosity > 1) {
    if (g.form == 0) {
      if (ret != -1) {
        complain((char *)"warning: %s: trailing junk was ignored", g.inf);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (g.form == 1) {
    if (g.in_left == 0UL) {
      if (! g.in_eof) {
        tmp___135 = load();
        if (! (tmp___135 == 0UL)) {
          (g.in_left) --;
          tmp___134 = g.in_next;
          (g.in_next) ++;
        }
      }
    } else {
      (g.in_left) --;
      tmp___134 = g.in_next;
      (g.in_next) ++;
    }
    if (! g.in_eof) {
      complain((char *)"warning: %s: trailing junk was ignored", g.inf);
    }
  }
  return;
}
}
static void unlzw(void) 
{ 
  unsigned int bits ;
  unsigned int mask ;
  bits_t buf ;
  unsigned int left ;
  length_t mark ;
  unsigned int code ;
  unsigned int max ;
  unsigned int flags ;
  unsigned int end ;
  unsigned int prev ;
  unsigned int final ;
  unsigned int stack ;
  unsigned int outcnt ;
  index_t prefix[65536] ;
  unsigned char suffix[65536] ;
  unsigned char match[65282] ;
  size_t tmp ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned int rem ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned char *tmp___8 ;
  size_t tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned int rem___0 ;
  size_t tmp___11 ;
  unsigned int temp ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;

  {
  g.out_tot = (length_t )0;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
    } else {
      tmp = load();
      if (tmp == 0UL) {
        try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
      }
    }
  }
  (g.in_left) --;
  tmp___0 = g.in_next;
  (g.in_next) ++;
  flags = (unsigned int )*tmp___0;
  if (flags & 96U) {
    try_throw_(33, (char *)"%s: unknown lzw flags set", g.inf, (void *)0);
  }
  max = flags & 31U;
  if (max < 9U) {
    try_throw_(33, (char *)"%s: lzw bits out of range", g.inf, (void *)0);
  } else
  if (max > 16U) {
    try_throw_(33, (char *)"%s: lzw bits out of range", g.inf, (void *)0);
  }
  if (max == 9U) {
    max = 10U;
  }
  flags &= 128U;
  mark = g.in_tot - g.in_left;
  bits = 9U;
  mask = 511U;
  if (flags) {
    end = 256U;
  } else {
    end = 255U;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      return;
    } else {
      tmp___1 = load();
      if (tmp___1 == 0UL) {
        return;
      }
    }
  }
  (g.in_left) --;
  tmp___2 = g.in_next;
  (g.in_next) ++;
  buf = (bits_t )((unsigned int )*tmp___2);
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
    } else {
      tmp___3 = load();
      if (tmp___3 == 0UL) {
        try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
      }
    }
  }
  (g.in_left) --;
  tmp___4 = g.in_next;
  (g.in_next) ++;
  buf += (bits_t )((unsigned int )*tmp___4 << 8);
  prev = (unsigned int )(buf & (unsigned long )mask);
  final = prev;
  buf >>= bits;
  left = 16U - bits;
  if (prev > 255U) {
    try_throw_(33, (char *)"%s: invalid lzw code", g.inf, (void *)0);
  }
  out_buf[0] = (unsigned char )final;
  outcnt = 1U;
  stack = 0U;
  while (1) {
    if (end >= mask) {
      if (bits < max) {
        rem = (unsigned int )(((g.in_tot - g.in_left) - mark) % (unsigned long )bits);
        if (rem) {
          rem = bits - rem;
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              break;
            } else {
              tmp___5 = load();
              if (tmp___5 == 0UL) {
                break;
              }
            }
          }
          while ((size_t )rem > g.in_left) {
            rem = (unsigned int )((size_t )rem - g.in_left);
            tmp___6 = load();
            if (tmp___6 == 0UL) {
              try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
            }
          }
          g.in_left -= (size_t )rem;
          g.in_next += rem;
        }
        buf = (bits_t )0;
        left = 0U;
        mark = g.in_tot - g.in_left;
        bits ++;
        mask <<= 1;
        mask ++;
      }
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        break;
      } else {
        tmp___7 = load();
        if (tmp___7 == 0UL) {
          break;
        }
      }
    }
    (g.in_left) --;
    tmp___8 = g.in_next;
    (g.in_next) ++;
    buf += (bits_t )((unsigned int )*tmp___8) << left;
    left += 8U;
    if (left < bits) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
        } else {
          tmp___9 = load();
          if (tmp___9 == 0UL) {
            try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
          }
        }
      }
      (g.in_left) --;
      tmp___10 = g.in_next;
      (g.in_next) ++;
      buf += (bits_t )((unsigned int )*tmp___10) << left;
      left += 8U;
    }
    code = (unsigned int )(buf & (unsigned long )mask);
    buf >>= bits;
    left -= bits;
    if (code == 256U) {
      if (flags) {
        rem___0 = (unsigned int )(((g.in_tot - g.in_left) - mark) % (unsigned long )bits);
        if (rem___0) {
          rem___0 = bits - rem___0;
          while ((size_t )rem___0 > g.in_left) {
            rem___0 = (unsigned int )((size_t )rem___0 - g.in_left);
            tmp___11 = load();
            if (tmp___11 == 0UL) {
              try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
            }
          }
          g.in_left -= (size_t )rem___0;
          g.in_next += rem___0;
        }
        buf = (bits_t )0;
        left = 0U;
        mark = g.in_tot - g.in_left;
        bits = 9U;
        mask = 511U;
        end = 255U;
        goto __Cont;
      }
    }
    temp = code;
    if (code > end) {
      if (code != end + 1U) {
        try_throw_(33, (char *)"%s: invalid lzw code", g.inf, (void *)0);
      } else
      if (prev > end) {
        try_throw_(33, (char *)"%s: invalid lzw code", g.inf, (void *)0);
      }
      tmp___12 = stack;
      stack ++;
      match[tmp___12] = (unsigned char )final;
      code = prev;
    }
    while (code >= 256U) {
      tmp___13 = stack;
      stack ++;
      match[tmp___13] = suffix[code];
      code = (unsigned int )prefix[code];
    }
    tmp___14 = stack;
    stack ++;
    match[tmp___14] = (unsigned char )code;
    final = code;
    if (end < mask) {
      end ++;
      prefix[end] = (index_t )prev;
      suffix[end] = (unsigned char )final;
    }
    prev = temp;
    while (stack > 32768U - outcnt) {
      while (outcnt < 32768U) {
        tmp___15 = outcnt;
        outcnt ++;
        stack --;
        out_buf[tmp___15] = match[stack];
      }
      g.out_tot += (length_t )outcnt;
      if (g.decode == 1) {
        writen(g.outd, (void const   *)(out_buf), (size_t )outcnt);
      }
      outcnt = 0U;
    }
    while (1) {
      tmp___16 = outcnt;
      outcnt ++;
      stack --;
      out_buf[tmp___16] = match[stack];
      if (! stack) {
        break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  g.out_tot += (length_t )outcnt;
  if (outcnt) {
    if (g.decode == 1) {
      writen(g.outd, (void const   *)(out_buf), (size_t )outcnt);
    }
  }
  return;
}
}
static char *justname(char *path ) 
{ 
  char *p ;
  char *tmp ;

  {
  p = strrchr((char const   *)path, '/');
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    tmp = path;
  } else {
    tmp = p + 1;
  }
  return (tmp);
}
}
static int copymeta(char *from , char *to ) 
{ 
  struct stat st ;
  struct timeval times[2] ;
  int tmp ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = stat((char const   * __restrict  )from, (struct stat * __restrict  )(& st));
  if (tmp != 0) {
    return (-4);
  } else
  if ((st.st_mode & 61440U) != 32768U) {
    return (-4);
  }
  tmp___0 = chmod((char const   *)to, st.st_mode & 4095U);
  ret = tmp___0;
  tmp___1 = chown((char const   *)to, st.st_uid, st.st_gid);
  ret += tmp___1;
  times[0].tv_sec = st.st_atim.tv_sec;
  times[0].tv_usec = (__suseconds_t )0;
  times[1].tv_sec = st.st_mtim.tv_sec;
  times[1].tv_usec = (__suseconds_t )0;
  tmp___2 = utimes((char const   *)to, (struct timeval  const  *)(times));
  ret += tmp___2;
  return (ret);
}
}
static void touch(char *path , time_t t ) 
{ 
  struct timeval times[2] ;

  {
  times[0].tv_sec = t;
  times[0].tv_usec = (__suseconds_t )0;
  times[1].tv_sec = t;
  times[1].tv_usec = (__suseconds_t )0;
  utimes((char const   *)path, (struct timeval  const  *)(times));
  return;
}
}
static void out_push(void) 
{ 
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  if (g.outd == -1) {
    return;
  }
  tmp = fsync(g.outd);
  ret = tmp;
  if (ret == -1) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    tmp___2 = __errno_location();
    try_throw_(*tmp___2, (char *)"sync error on %s (%s)", g.outf, tmp___1, (void *)0);
  }
  return;
}
}
static void process(char *path ) ;
static char *sufs[12]  = 
  {      (char *)".z",      (char *)"-z",      (char *)"_z",      (char *)".Z", 
        (char *)".gz",      (char *)"-gz",      (char *)".zz",      (char *)"-zz", 
        (char *)".zip",      (char *)".ZIP",      (char *)".tgz",      (char *)((void *)0)};
static void process(char *path ) 
{ 
  int volatile   method ;
  size_t len ;
  struct stat st ;
  try_ball_t_ err ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  char **sufx ;
  char **tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *roll ;
  size_t size ;
  size_t off ;
  size_t base ;
  DIR *here ;
  struct dirent *next___0 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t suf ;
  size_t tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp___26 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___35 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  int tmp___44 ;
  char *to ;
  char *sufx___0 ;
  size_t pre ;
  char *tmp___45 ;
  int tmp___46 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  int tmp___49 ;
  int overwrite ;
  int ch___0 ;
  int first ;
  int tmp___50 ;
  int *tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  int *tmp___54 ;
  try_t_ try_this____0 ;
  int volatile   try_pushed____0 ;
  void *tmp___55 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___64 ;
  void *tmp___68 ;
  void *tmp___69 ;
  void *tmp___70 ;
  int *tmp___71 ;
  char *tmp___72 ;
  int *tmp___73 ;
  int tmp___74 ;

  {
  method = (int volatile   )-1;
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    vstrcpy(& g.inf, & g.inz, (size_t )0, (void *)"<stdin>");
    g.ind = 0;
    g.name = (char *)((void *)0);
    if (g.headis & 2) {
      tmp___2 = fstat(g.ind, & st);
      if (tmp___2) {
        tmp___0 = time((time_t *)((void *)0));
        tmp___1 = tmp___0;
      } else {
        tmp___1 = st.st_mtim.tv_sec;
      }
      g.mtime = tmp___1;
    } else {
      g.mtime = (time_t )0;
    }
    len = (size_t )0;
  } else {
    if ((unsigned long )path != (unsigned long )g.inf) {
      vstrcpy(& g.inf, & g.inz, (size_t )0, (void *)path);
    }
    len = strlen((char const   *)g.inf);
    tmp___11 = lstat((char const   * __restrict  )g.inf, (struct stat * __restrict  )(& st));
    if (tmp___11) {
      tmp___7 = __errno_location();
      if (*tmp___7 == 2) {
        if (g.list) {
          goto _L;
        } else
        if (g.decode) {
          _L: /* CIL Label */ 
          sufx = sufs;
          while (! ((unsigned long )*sufx == (unsigned long )((void *)0))) {
            tmp___3 = sufx;
            sufx ++;
            vstrcpy(& g.inf, & g.inz, len, (void *)*tmp___3);
            tmp___4 = __errno_location();
            *tmp___4 = 0;
            tmp___5 = lstat((char const   * __restrict  )g.inf, (struct stat * __restrict  )(& st));
            if (tmp___5) {
              tmp___6 = __errno_location();
              if (! (*tmp___6 == 2)) {
                break;
              }
            } else {
              break;
            }
          }
        }
      }
      tmp___8 = __errno_location();
      if (*tmp___8 == 75) {
        try_throw_(33, (char *)"%s too large -- not compiled with large file support",
                   g.inf, (void *)0);
      } else {
        tmp___9 = __errno_location();
        if (*tmp___9 == 27) {
          try_throw_(33, (char *)"%s too large -- not compiled with large file support",
                     g.inf, (void *)0);
        }
      }
      tmp___10 = __errno_location();
      if (*tmp___10) {
        *(g.inf + len) = (char)0;
        complain((char *)"skipping: %s does not exist", g.inf);
        return;
      }
      len = strlen((char const   *)g.inf);
    }
    if ((st.st_mode & 61440U) != 32768U) {
      if ((st.st_mode & 61440U) != 4096U) {
        if ((st.st_mode & 61440U) != 40960U) {
          if ((st.st_mode & 61440U) != 16384U) {
            complain((char *)"skipping: %s is a special file or device", g.inf);
            return;
          }
        }
      }
    }
    if ((st.st_mode & 61440U) == 40960U) {
      if (! g.force) {
        if (! g.pipeout) {
          complain((char *)"skipping: %s is a symbolic link", g.inf);
          return;
        }
      }
    }
    if ((st.st_mode & 61440U) == 16384U) {
      if (! g.recurse) {
        complain((char *)"skipping: %s is a directory", g.inf);
        return;
      }
    }
    if ((st.st_mode & 61440U) == 16384U) {
      roll = (char *)((void *)0);
      size = (size_t )0;
      off = (size_t )0;
      here = opendir((char const   *)g.inf);
      if ((unsigned long )here == (unsigned long )((void *)0)) {
        return;
      }
      while (1) {
        next___0 = readdir(here);
        if (! ((unsigned long )next___0 != (unsigned long )((void *)0))) {
          break;
        }
        if ((int )next___0->d_name[0] == 0) {
          continue;
        } else
        if ((int )next___0->d_name[0] == 46) {
          if ((int )next___0->d_name[1] == 0) {
            continue;
          } else
          if ((int )next___0->d_name[1] == 46) {
            if ((int )next___0->d_name[2] == 0) {
              continue;
            }
          }
        }
        off = vstrcpy(& roll, & size, off, (void *)(next___0->d_name));
      }
      closedir(here);
      vstrcpy(& roll, & size, off, (void *)"");
      if (len) {
        if ((int )*(g.inf + (len - 1UL)) != 47) {
          tmp___12 = vstrcpy(& g.inf, & g.inz, len, (void *)"/");
          base = tmp___12 - 1UL;
        } else {
          base = len;
        }
      } else {
        base = len;
      }
      off = (size_t )0;
      while (*(roll + off)) {
        vstrcpy(& g.inf, & g.inz, base, (void *)(roll + off));
        process(g.inf);
        tmp___13 = strlen((char const   *)(roll + off));
        off += tmp___13 + 1UL;
      }
      *(g.inf + len) = (char)0;
      free((void *)roll);
      return;
    }
    if (! g.force) {
      if (! g.list) {
        if (! g.decode) {
          tmp___14 = strlen((char const   *)g.sufx);
          if (len >= tmp___14) {
            tmp___15 = strlen((char const   *)g.sufx);
            tmp___16 = strcmp((char const   *)((g.inf + len) - tmp___15), (char const   *)g.sufx);
            if (tmp___16 == 0) {
              grumble((char *)"skipping: %s ends with %s", g.inf, g.sufx);
              return;
            }
          }
        }
      }
    }
    if (g.decode == 1) {
      if (! g.pipeout) {
        if (! g.list) {
          tmp___17 = compressed_suffix(g.inf);
          suf = tmp___17;
          if (suf == 0UL) {
            complain((char *)"skipping: %s does not have compressed suffix", g.inf);
            return;
          }
          len -= suf;
        }
      }
    }
    g.ind = open((char const   *)g.inf, 0, 0);
    if (g.ind < 0) {
      tmp___18 = __errno_location();
      tmp___19 = strerror(*tmp___18);
      tmp___20 = __errno_location();
      try_throw_(*tmp___20, (char *)"read error on %s (%s)", g.inf, tmp___19, (void *)0);
    }
    if (g.headis & 1) {
      tmp___21 = justname(g.inf);
      g.name = tmp___21;
    } else {
      g.name = (char *)((void *)0);
    }
    if (g.headis & 2) {
      g.mtime = st.st_mtim.tv_sec;
    } else {
      g.mtime = (time_t )0;
    }
  }
  if (g.list) {
    if (g.decode != 2) {
      list_info();
      load_end();
      return;
    }
  }
  if (g.decode) {
    in_init();
    tmp___22 = get_header(1);
    method = (int volatile   )tmp___22;
    if (method != (int volatile   )8) {
      if (method != (int volatile   )257) {
        if (method == (int volatile   )-1) {
          goto _L___4;
        } else
        if (method == (int volatile   )-2) {
          _L___4: /* CIL Label */ 
          if (g.force) {
            if (g.pipeout) {
              if (g.decode != 2) {
                if (! (! g.list)) {
                  goto _L___3;
                }
              } else {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          load_end();
          if (method == (int volatile   )-6) {
            tmp___25 = "skipping: %s corrupt: header crc error";
          } else {
            if (method == (int volatile   )-1) {
              tmp___24 = "skipping: %s empty";
            } else {
              if (method < (int volatile   )0) {
                tmp___23 = "skipping: %s unrecognized format";
              } else {
                tmp___23 = "skipping: %s unknown compression method";
              }
              tmp___24 = tmp___23;
            }
            tmp___25 = tmp___24;
          }
          complain((char *)tmp___25, g.inf);
          return;
        }
      }
    }
    if (g.decode == 2) {
      while (1) {
        try_pushed_ = (int volatile   )1;
        try_this_.ball.ret = 0;
        try_this_.ball.code = 0;
        try_this_.ball.free = 0;
        try_this_.ball.why = (char *)((void *)0);
        try_setup_();
        tmp___26 = pthread_getspecific(try_key_);
        try_this_.next = (try_t_ *)tmp___26;
        while (1) {
          tmp___30 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
          if (tmp___30 == 0) {
            if (! "try: pthread_setspecific() failed") {
              __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                            "pigz.c", 4068U, "process");
            }
          } else {
            __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4068U, "process");
          }
          break;
        }
        tmp___31 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
        if (tmp___31 == 0) {
          while (1) {
            if (method == (int volatile   )8) {
              infchk();
            } else {
              unlzw();
              if (g.list) {
                g.in_tot -= 3UL;
                show_info((int )method, 0UL, g.out_tot, 0);
              }
            }
            break;
          }
        }
        if (try_pushed_) {
          while (1) {
            tmp___35 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
            if (tmp___35 == 0) {
              if (! "try: pthread_setspecific() failed") {
                __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                              "pigz.c", 4079U, "process");
              }
            } else {
              __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                            "pigz.c", 4079U, "process");
            }
            break;
          }
          try_pushed_ = (int volatile   )0;
        }
        err = try_this_.ball;
        break;
      }
      if (err.code) {
        if (err.code != 33) {
          while (1) {
            try_setup_();
            tmp___39 = pthread_getspecific(try_key_);
            if ((unsigned long )((try_t_ *)tmp___39) != (unsigned long )((void *)0)) {
              if (! "try: naked punt") {
                __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c",
                              4081U, "process");
              }
            } else {
              __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c",
                            4081U, "process");
            }
            tmp___40 = pthread_getspecific(try_key_);
            ((try_t_ *)tmp___40)->ball = err;
            tmp___41 = pthread_getspecific(try_key_);
            longjmp((struct __jmp_buf_tag *)(((try_t_ *)tmp___41)->env), 1);
            break;
          }
        }
        complain((char *)"skipping: %s", err.why);
        while (1) {
          if (err.free) {
            free((void *)err.why);
            err.free = 0;
            err.why = (char *)((void *)0);
          }
          break;
        }
        outb((void *)0, (unsigned char *)((void *)0), 0U);
      }
      load_end();
      return;
    }
  }
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    goto _L___6;
  } else
  if (g.pipeout) {
    _L___6: /* CIL Label */ 
    tmp___42 = strlen("<stdout>");
    tmp___43 = alloc((void *)0, tmp___42 + 1UL);
    g.outf = (char *)tmp___43;
    strcpy((char * __restrict  )g.outf, (char const   * __restrict  )"<stdout>");
    g.outd = 1;
    if (! g.decode) {
      if (! g.force) {
        tmp___44 = isatty(g.outd);
        if (tmp___44) {
          try_throw_(22, (char *)"trying to write compressed data to a terminal (use -f to force)",
                     (void *)0);
        }
      }
    }
  } else {
    to = g.inf;
    sufx___0 = (char *)"";
    pre = (size_t )0;
    if (g.decode) {
      if ((g.headis & 1) != 0) {
        if ((unsigned long )g.hname != (unsigned long )((void *)0)) {
          tmp___45 = justname(g.inf);
          pre = (size_t )(tmp___45 - g.inf);
          to = justname(g.hname);
          len = strlen((char const   *)to);
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        tmp___46 = strcmp((char const   *)(to + len), ".tgz");
        if (tmp___46 == 0) {
          sufx___0 = (char *)".tar";
        }
      }
    } else {
      sufx___0 = g.sufx;
    }
    tmp___47 = strlen((char const   *)sufx___0);
    tmp___48 = alloc((void *)0, ((pre + len) + tmp___47) + 1UL);
    g.outf = (char *)tmp___48;
    memcpy((void * __restrict  )g.outf, (void const   * __restrict  )g.inf, pre);
    memcpy((void * __restrict  )(g.outf + pre), (void const   * __restrict  )to, len);
    strcpy((char * __restrict  )((g.outf + pre) + len), (char const   * __restrict  )sufx___0);
    if (g.force) {
      tmp___49 = 0;
    } else {
      tmp___49 = 128;
    }
    g.outd = open((char const   *)g.outf, 577 | tmp___49, 384);
    if (g.outd < 0) {
      tmp___51 = __errno_location();
      if (*tmp___51 == 17) {
        overwrite = 0;
        tmp___50 = isatty(0);
        if (tmp___50) {
          if (g.verbosity) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s exists -- overwrite (y/n)? ",
                    g.outf);
            fflush(stderr);
            first = 1;
            while (1) {
              ch___0 = getchar();
              if (first == 1) {
                if (ch___0 == 32) {
                  goto __Cont;
                } else
                if (ch___0 == 9) {
                  goto __Cont;
                }
                if (ch___0 == 121) {
                  overwrite = 1;
                } else
                if (ch___0 == 89) {
                  overwrite = 1;
                }
                first = 0;
              }
              __Cont: /* CIL Label */ 
              if (ch___0 != -1) {
                if (ch___0 != 10) {
                  if (! (ch___0 != 13)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            }
          }
        }
        if (! overwrite) {
          complain((char *)"skipping: %s exists", g.outf);
          while (1) {
            if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
              free((void *)g.outf);
              g.outf = (char *)((void *)0);
            }
            break;
          }
          load_end();
          return;
        }
        g.outd = open((char const   *)g.outf, 577, 384);
      }
    }
    if (g.outd < 0) {
      tmp___52 = __errno_location();
      tmp___53 = strerror(*tmp___52);
      tmp___54 = __errno_location();
      try_throw_(*tmp___54, (char *)"write error on %s (%s)", g.outf, tmp___53, (void *)0);
    }
  }
  if (g.verbosity > 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s to %s ",
            g.inf, g.outf);
  }
  if (g.decode) {
    while (1) {
      try_pushed____0 = (int volatile   )1;
      try_this____0.ball.ret = 0;
      try_this____0.ball.code = 0;
      try_this____0.ball.free = 0;
      try_this____0.ball.why = (char *)((void *)0);
      try_setup_();
      tmp___55 = pthread_getspecific(try_key_);
      try_this____0.next = (try_t_ *)tmp___55;
      while (1) {
        tmp___59 = pthread_setspecific(try_key_, (void const   *)(& try_this____0));
        if (tmp___59 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4170U, "process");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4170U, "process");
        }
        break;
      }
      tmp___60 = _setjmp((struct __jmp_buf_tag *)(try_this____0.env));
      if (tmp___60 == 0) {
        while (1) {
          if (method == (int volatile   )8) {
            infchk();
          } else
          if (method == (int volatile   )257) {
            unlzw();
          } else {
            cat();
          }
          break;
        }
      }
      if (try_pushed____0) {
        while (1) {
          tmp___64 = pthread_setspecific(try_key_, (void const   *)try_this____0.next);
          if (tmp___64 == 0) {
            if (! "try: pthread_setspecific() failed") {
              __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                            "pigz.c", 4178U, "process");
            }
          } else {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4178U, "process");
          }
          break;
        }
        try_pushed____0 = (int volatile   )0;
      }
      err = try_this____0.ball;
      break;
    }
    if (err.code) {
      if (err.code != 33) {
        while (1) {
          try_setup_();
          tmp___68 = pthread_getspecific(try_key_);
          if ((unsigned long )((try_t_ *)tmp___68) != (unsigned long )((void *)0)) {
            if (! "try: naked punt") {
              __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c",
                            4180U, "process");
            }
          } else {
            __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c", 4180U,
                          "process");
          }
          tmp___69 = pthread_getspecific(try_key_);
          ((try_t_ *)tmp___69)->ball = err;
          tmp___70 = pthread_getspecific(try_key_);
          longjmp((struct __jmp_buf_tag *)(((try_t_ *)tmp___70)->env), 1);
          break;
        }
      }
      complain((char *)"skipping: %s", err.why);
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      outb((void *)0, (unsigned char *)((void *)0), 0U);
      if (g.outd != -1) {
        if (g.outd != 1) {
          close(g.outd);
          g.outd = -1;
          unlink((char const   *)g.outf);
          while (1) {
            if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
              free((void *)g.outf);
              g.outf = (char *)((void *)0);
            }
            break;
          }
        }
      }
    }
  } else
  if (g.procs > 1) {
    parallel_compress();
  } else {
    single_compress(0);
  }
  if (g.verbosity > 1) {
    putc('\n', stderr);
    fflush(stderr);
  }
  load_end();
  if (g.outd != -1) {
    if (g.outd != 1) {
      if (g.sync) {
        out_push();
      }
      tmp___74 = close(g.outd);
      if (tmp___74) {
        tmp___71 = __errno_location();
        tmp___72 = strerror(*tmp___71);
        tmp___73 = __errno_location();
        try_throw_(*tmp___73, (char *)"write error on %s (%s)", g.outf, tmp___72,
                   (void *)0);
      }
      g.outd = -1;
      if (g.ind != 0) {
        copymeta(g.inf, g.outf);
        if (! g.keep) {
          if (st.st_nlink > 1UL) {
            if (! g.force) {
              complain((char *)"%s has hard links -- not unlinking", g.inf);
            } else {
              unlink((char const   *)g.inf);
            }
          } else {
            unlink((char const   *)g.inf);
          }
        }
      }
      if (g.decode) {
        if ((g.headis & 2) != 0) {
          if (g.stamp) {
            touch(g.outf, g.stamp);
          }
        }
      }
    }
  }
  while (1) {
    if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
      free((void *)g.outf);
      g.outf = (char *)((void *)0);
    }
    break;
  }
  return;
}
}
static char *helptext[42]  = 
  {      (char *)"Usage: pigz [options] [files ...]",      (char *)"  will compress files in place, adding the suffix \'.gz\'. If no files are",      (char *)"  specified, stdin will be compressed to stdout. pigz does what gzip does,",      (char *)"  but spreads the work over multiple processors and cores when compressing.", 
        (char *)"",      (char *)"Options:",      (char *)"  -0 to -9, -11        Compression level (level 11, zopfli, is much slower)",      (char *)"  --fast, --best       Compression levels 1 and 9 respectively", 
        (char *)"  -A, --alias xxx      Use xxx as the name for any --zip entry from stdin",      (char *)"  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)",      (char *)"  -c, --stdout         Write all processed output to stdout (won\'t delete)",      (char *)"  -C, --comment ccc    Put comment ccc in the gzip or zip header", 
        (char *)"  -d, --decompress     Decompress the compressed input",      (char *)"  -f, --force          Force overwrite, compress .gz, links, and to terminal",      (char *)"  -F  --first          Do iterations first, before block split for -11",      (char *)"  -h, --help           Display a help screen and quit", 
        (char *)"  -H, --huffman        Use only Huffman coding for compression",      (char *)"  -i, --independent    Compress blocks independently for damage recovery",      (char *)"  -I, --iterations n   Number of iterations for -11 optimization",      (char *)"  -J, --maxsplits n    Maximum number of split blocks for -11", 
        (char *)"  -k, --keep           Do not delete original file after processing",      (char *)"  -K, --zip            Compress to PKWare zip (.zip) single entry format",      (char *)"  -l, --list           List the contents of the compressed input",      (char *)"  -L, --license        Display the pigz license and quit", 
        (char *)"  -m, --no-time        Do not store or restore mod time",      (char *)"  -M, --time           Store or restore mod time",      (char *)"  -n, --no-name        Do not store or restore file name or mod time",      (char *)"  -N, --name           Store or restore file name and mod time", 
        (char *)"  -O  --oneblock       Do not split into smaller blocks for -11",      (char *)"  -p, --processes n    Allow up to n compression threads (default is the",      (char *)"                       number of online processors, or 8 if unknown)",      (char *)"  -q, --quiet          Print no messages, even on error", 
        (char *)"  -r, --recursive      Process the contents of all subdirectories",      (char *)"  -R, --rsyncable      Input-determined block locations for rsync",      (char *)"  -S, --suffix .sss    Use suffix .sss instead of .gz (for compression)",      (char *)"  -t, --test           Test the integrity of the compressed input", 
        (char *)"  -U, --rle            Use run-length encoding for compression",      (char *)"  -v, --verbose        Provide more verbose output",      (char *)"  -V  --version        Show the version of pigz",      (char *)"  -Y  --synchronous    Force output file write to permanent storage", 
        (char *)"  -z, --zlib           Compress to zlib (.zz) instead of gzip format",      (char *)"  --                   All arguments after \"--\" are treated as files"};
static void help(void) 
{ 
  int n ;

  {
  if (g.verbosity == 0) {
    return;
  }
  n = 0;
  while (n < (int )(sizeof(helptext) / sizeof(char *))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", helptext[n]);
    n ++;
  }
  fflush(stderr);
  exit(0);
}
}
static int nprocs(int n ) 
{ 
  long tmp ;

  {
  tmp = sysconf(84);
  n = (int )tmp;
  return (n);
}
}
static void defaults(void) 
{ 


  {
  g.level = -1;
  g.strategy = 0;
  ZopfliInitOptions(& g.zopts);
  g.block = 131072UL;
  g.procs = nprocs(8);
  g.shift = x2nmodp(g.block, 3U);
  g.rsync = 0;
  g.setdict = 1;
  g.verbosity = 1;
  g.headis = 3;
  g.pipeout = 0;
  g.sufx = (char *)".gz";
  g.comment = (char *)((void *)0);
  g.decode = 0;
  g.list = 0;
  g.keep = 0;
  g.force = 0;
  g.sync = 0;
  g.recurse = 0;
  g.form = 0;
  return;
}
}
static char *longopts[41][2]  = 
  { {        (char *)"LZW",        (char *)"Z"}, 
   {        (char *)"lzw",        (char *)"Z"}, 
   {        (char *)"alias",        (char *)"A"}, 
   {        (char *)"ascii",        (char *)"a"}, 
   {        (char *)"best",        (char *)"9"}, 
   {        (char *)"bits",        (char *)"Z"}, 
   {        (char *)"blocksize",        (char *)"b"}, 
   {        (char *)"decompress",        (char *)"d"}, 
   {        (char *)"fast",        (char *)"1"}, 
   {        (char *)"force",        (char *)"f"}, 
   {        (char *)"comment",        (char *)"C"}, 
   {        (char *)"first",        (char *)"F"}, 
   {        (char *)"iterations",        (char *)"I"}, 
   {        (char *)"maxsplits",        (char *)"J"}, 
   {        (char *)"oneblock",        (char *)"O"}, 
   {        (char *)"help",        (char *)"h"}, 
   {        (char *)"independent",        (char *)"i"}, 
   {        (char *)"keep",        (char *)"k"}, 
   {        (char *)"license",        (char *)"L"}, 
   {        (char *)"list",        (char *)"l"}, 
   {        (char *)"name",        (char *)"N"}, 
   {        (char *)"no-name",        (char *)"n"}, 
   {        (char *)"no-time",        (char *)"m"}, 
   {        (char *)"processes",        (char *)"p"}, 
   {        (char *)"quiet",        (char *)"q"}, 
   {        (char *)"recursive",        (char *)"r"}, 
   {        (char *)"rsyncable",        (char *)"R"}, 
   {        (char *)"silent",        (char *)"q"}, 
   {        (char *)"stdout",        (char *)"c"}, 
   {        (char *)"suffix",        (char *)"S"}, 
   {        (char *)"synchronous",        (char *)"Y"}, 
   {        (char *)"test",        (char *)"t"}, 
   {        (char *)"time",        (char *)"M"}, 
   {        (char *)"to-stdout",        (char *)"c"}, 
   {        (char *)"uncompress",        (char *)"d"}, 
   {        (char *)"verbose",        (char *)"v"}, 
   {        (char *)"version",        (char *)"V"}, 
   {        (char *)"zip",        (char *)"K"}, 
   {        (char *)"zlib",        (char *)"z"}, 
   {        (char *)"huffman",        (char *)"H"}, 
   {        (char *)"rle",        (char *)"U"}};
static void new_opts(void) 
{ 


  {
  single_compress(1);
  finish_jobs();
  return;
}
}
static size_t num(char *arg ) 
{ 
  char *str ;
  size_t val ;

  {
  str = arg;
  val = (size_t )0;
  if ((int )*str == 0) {
    try_throw_(22, (char *)"internal error: empty parameter", (void *)0);
  }
  while (1) {
    if ((int )*str < 48) {
      try_throw_(22, (char *)"invalid numeric parameter: %s", arg, (void *)0);
    } else
    if ((int )*str > 57) {
      try_throw_(22, (char *)"invalid numeric parameter: %s", arg, (void *)0);
    } else
    if (val) {
      if ((18446744073709551615 - (size_t )((int )*str - 48)) / val < 10UL) {
        try_throw_(22, (char *)"invalid numeric parameter: %s", arg, (void *)0);
      }
    }
    val = val * 10UL + (size_t )((int )*str - 48);
    str ++;
    if (! *str) {
      break;
    }
  }
  return (val);
}
}
static int option(char *arg ) ;
static int get  =    0;
static int option(char *arg ) 
{ 
  char bad[3] ;
  int j ;
  int tmp ;
  char const   *tmp___0 ;
  size_t n ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  bad[0] = (char )'-';
  bad[1] = (char )'X';
  bad[2] = (char )'\000';
  if (get) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      bad[1] = (char )*("bpSIJAC" + (get - 1));
      try_throw_(22, (char *)"missing parameter after %s", bad, (void *)0);
    } else
    if ((int )*arg == 45) {
      bad[1] = (char )*("bpSIJAC" + (get - 1));
      try_throw_(22, (char *)"missing parameter after %s", bad, (void *)0);
    }
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (1);
  }
  if ((int )*arg == 45) {
    arg ++;
    if ((int )*arg == 0) {
      return (0);
    }
    if ((int )*arg == 45) {
      arg ++;
      j = (int )(sizeof(longopts) / (sizeof(char *) << 1) - 1UL);
      while (j >= 0) {
        tmp = strcmp((char const   *)arg, (char const   *)longopts[j][0]);
        if (tmp == 0) {
          arg = longopts[j][1];
          break;
        }
        j --;
      }
      if (j < 0) {
        try_throw_(22, (char *)"invalid option: %s", arg - 2, (void *)0);
      }
    }
    while (1) {
      if (get) {
        if (get == 3) {
          try_throw_(22, (char *)"invalid usage: -S must be followed by space", (void *)0);
        }
        if (get == 7) {
          try_throw_(22, (char *)"invalid usage: -C must be followed by space", (void *)0);
        }
        break;
      }
      bad[1] = *arg;
      switch ((int )*arg) {
      case 57: 
      case 56: 
      case 55: 
      case 54: 
      case 53: 
      case 52: 
      case 51: 
      case 50: 
      case 49: 
      case 48: 
      g.level = (int )*arg - 48;
      while (1) {
        if ((int )*(arg + 1) >= 48) {
          if (! ((int )*(arg + 1) <= 57)) {
            break;
          }
        } else {
          break;
        }
        if (g.level) {
          if ((2147483647 - ((int )*(arg + 1) - 48)) / g.level < 10) {
            try_throw_(22, (char *)"only levels 0..9 and 11 are allowed", (void *)0);
          }
        }
        arg ++;
        g.level = (g.level * 10 + (int )*arg) - 48;
      }
      if (g.level == 10) {
        try_throw_(22, (char *)"only levels 0..9 and 11 are allowed", (void *)0);
      } else
      if (g.level > 11) {
        try_throw_(22, (char *)"only levels 0..9 and 11 are allowed", (void *)0);
      }
      break;
      case 65: 
      get = 6;
      break;
      case 67: 
      get = 7;
      break;
      case 70: 
      g.zopts.blocksplittinglast = 1;
      break;
      case 72: 
      g.strategy = 2;
      break;
      case 73: 
      get = 4;
      break;
      case 74: 
      get = 5;
      break;
      case 75: 
      g.form = 2;
      g.sufx = (char *)".zip";
      break;
      case 76: 
      puts("pigz 2.7");
      puts("Copyright (C) 2007-2022 Mark Adler");
      puts("Subject to the terms of the zlib license.");
      puts("No warranty is provided or implied.");
      exit(0);
      break;
      case 77: 
      g.headis |= 10;
      break;
      case 78: 
      g.headis = 15;
      break;
      case 79: 
      g.zopts.blocksplitting = 0;
      break;
      case 82: 
      g.rsync = 1;
      break;
      case 83: 
      get = 3;
      break;
      case 86: 
      puts("pigz 2.7");
      if (g.verbosity > 1) {
        tmp___0 = zlibVersion();
        printf((char const   * __restrict  )"zlib %s\n", tmp___0);
      }
      exit(0);
      break;
      case 89: 
      g.sync = 1;
      break;
      case 90: 
      try_throw_(22, (char *)"invalid option: LZW output not supported: %s", bad,
                 (void *)0);
      break;
      case 97: 
      try_throw_(22, (char *)"invalid option: no ascii conversion: %s", bad, (void *)0);
      break;
      case 98: 
      get = 1;
      break;
      case 99: 
      g.pipeout = 1;
      break;
      case 100: 
      if (! g.decode) {
        g.headis >>= 2;
      }
      g.decode = 1;
      break;
      case 102: 
      g.force = 1;
      break;
      case 104: 
      help();
      break;
      case 105: 
      g.setdict = 0;
      break;
      case 107: 
      g.keep = 1;
      break;
      case 108: 
      g.list = 1;
      break;
      case 110: 
      g.headis = 0;
      break;
      case 109: 
      case 84: 
      g.headis &= -11;
      break;
      case 112: 
      get = 2;
      break;
      case 113: 
      g.verbosity = 0;
      break;
      case 114: 
      g.recurse = 1;
      break;
      case 116: 
      g.decode = 2;
      break;
      case 85: 
      g.strategy = 3;
      break;
      case 118: 
      (g.verbosity) ++;
      break;
      case 122: 
      g.form = 1;
      g.sufx = (char *)".zz";
      break;
      default: 
      try_throw_(22, (char *)"invalid option: %s", bad, (void *)0);
      }
      arg ++;
      if (! *arg) {
        break;
      }
    }
    if ((int )*arg == 0) {
      return (1);
    }
  }
  if (get) {
    if (get == 1) {
      n = num(arg);
      g.block = n << 10;
      g.shift = x2nmodp(g.block, 3U);
      if (g.block < 32768UL) {
        try_throw_(22, (char *)"block size too small (must be >= 32K)", (void *)0);
      }
      if (n != g.block >> 10) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      } else
      if ((g.block + (g.block >> 4)) + 32768UL < g.block) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      } else
      if ((ssize_t )((g.block + (g.block >> 4)) + 32768UL) < 0L) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      } else
      if (g.block > 1UL << 29) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      }
    } else
    if (get == 2) {
      n = num(arg);
      g.procs = (int )n;
      if (g.procs < 1) {
        try_throw_(22, (char *)"invalid number of processes: %s", arg, (void *)0);
      }
      if ((size_t )g.procs != n) {
        try_throw_(22, (char *)"too many processes: %s", arg, (void *)0);
      } else
      if ((g.procs << 1) + 3 < 1) {
        try_throw_(22, (char *)"too many processes: %s", arg, (void *)0);
      }
    } else
    if (get == 3) {
      if ((int )*arg == 0) {
        try_throw_(22, (char *)"suffix cannot be empty", (void *)0);
      }
      g.sufx = arg;
    } else
    if (get == 4) {
      tmp___1 = num(arg);
      g.zopts.numiterations = (int )tmp___1;
    } else
    if (get == 5) {
      tmp___2 = num(arg);
      g.zopts.blocksplittingmax = (int )tmp___2;
    } else
    if (get == 6) {
      g.alias = arg;
    } else
    if (get == 7) {
      g.comment = arg;
    }
    get = 0;
    return (1);
  }
  return (0);
}
}
static void cut_yarn(int err ) 
{ 


  {
  try_throw_(err, (char *)"internal threads error", (void *)0);
}
}
int main(int argc , char **argv ) 
{ 
  int n ;
  int nop ;
  int done ;
  size_t k ;
  char *opts ;
  char *p ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___23 ;
  int tmp___27 ;

  {
  g.ret = 0;
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4605U, "main");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 4605U, "main");
      }
      break;
    }
    tmp___19 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___19 == 0) {
      while (1) {
        g.inf = (char *)((void *)0);
        g.inz = (size_t )0;
        g.in_which = -1;
        g.alias = (char *)"-";
        g.outf = (char *)((void *)0);
        g.first = 1;
        g.hname = (char *)((void *)0);
        g.hcomm = (char *)((void *)0);
        p = strrchr((char const   *)*(argv + 0), '/');
        if ((unsigned long )p == (unsigned long )((void *)0)) {
          p = *(argv + 0);
        } else {
          p ++;
        }
        if (*p) {
          g.prog = p;
        } else {
          g.prog = (char *)"pigz";
        }
        signal(2, & cut_short);
        yarn_prefix = g.prog;
        yarn_abort = & cut_yarn;
        defaults();
        tmp___4 = zlib_vernum();
        if (tmp___4 < 4656L) {
          try_throw_(22, (char *)"zlib version less than 1.2.3", (void *)0);
        }
        get_crc_table();
        opts = getenv("GZIP");
        if ((unsigned long )opts != (unsigned long )((void *)0)) {
          while (*opts) {
            while (1) {
              if (! ((int )*opts == 32)) {
                if (! ((int )*opts == 9)) {
                  break;
                }
              }
              opts ++;
            }
            p = opts;
            while (1) {
              if (*p) {
                if ((int )*p != 32) {
                  if (! ((int )*p != 9)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              p ++;
            }
            n = (int )*p;
            *p = (char)0;
            tmp___5 = option(opts);
            if (! tmp___5) {
              try_throw_(22, (char *)"cannot provide files in GZIP environment variable",
                         (void *)0);
            }
            if (n) {
              tmp___6 = 1;
            } else {
              tmp___6 = 0;
            }
            opts = p + tmp___6;
          }
          option((char *)((void *)0));
        }
        opts = getenv("PIGZ");
        if ((unsigned long )opts != (unsigned long )((void *)0)) {
          while (*opts) {
            while (1) {
              if (! ((int )*opts == 32)) {
                if (! ((int )*opts == 9)) {
                  break;
                }
              }
              opts ++;
            }
            p = opts;
            while (1) {
              if (*p) {
                if ((int )*p != 32) {
                  if (! ((int )*p != 9)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              p ++;
            }
            n = (int )*p;
            *p = (char)0;
            tmp___7 = option(opts);
            if (! tmp___7) {
              try_throw_(22, (char *)"cannot provide files in PIGZ environment variable",
                         (void *)0);
            }
            if (n) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
            opts = p + tmp___8;
          }
          option((char *)((void *)0));
        }
        tmp___9 = strcmp((char const   *)g.prog, "unpigz");
        if (tmp___9 == 0) {
          goto _L;
        } else {
          tmp___10 = strcmp((char const   *)g.prog, "gunzip");
          if (tmp___10 == 0) {
            _L: /* CIL Label */ 
            if (! g.decode) {
              g.headis >>= 2;
            }
            g.decode = 1;
          }
        }
        k = strlen((char const   *)g.prog);
        if (k > 2UL) {
          tmp___11 = strcmp((char const   *)((g.prog + k) - 3), "cat");
          if (tmp___11 == 0) {
            if (! g.decode) {
              g.headis >>= 2;
            }
            g.decode = 1;
            g.pipeout = 1;
          }
        }
        if (argc < 2) {
          if (g.decode) {
            tmp___12 = 0;
          } else {
            tmp___12 = 1;
          }
          tmp___13 = isatty(tmp___12);
          if (tmp___13) {
            help();
          }
        }
        nop = argc;
        n = 1;
        while (n < argc) {
          tmp___15 = strcmp((char const   *)*(argv + n), "--");
          if (tmp___15 == 0) {
            nop = n;
            *(argv + n) = (char *)((void *)0);
            break;
          } else {
            tmp___14 = option(*(argv + n));
            if (tmp___14) {
              *(argv + n) = (char *)((void *)0);
            }
          }
          n ++;
        }
        option((char *)((void *)0));
        done = 0;
        n = 1;
        while (n < argc) {
          if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
            if (done == 1) {
              if (g.pipeout) {
                if (! g.decode) {
                  if (! g.list) {
                    if (g.form > 1) {
                      complain((char *)"warning: output will be concatenated zip files -- %s will not be able to extract",
                               g.prog);
                    }
                  }
                }
              }
            }
            if (n < nop) {
              tmp___18 = strcmp((char const   *)*(argv + n), "-");
              if (tmp___18 == 0) {
                tmp___17 = (char *)((void *)0);
              } else {
                tmp___17 = *(argv + n);
              }
            } else {
              tmp___17 = *(argv + n);
            }
            process(tmp___17);
            done ++;
          }
          n ++;
        }
        if (done == 0) {
          process((char *)((void *)0));
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___23 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___23 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4727U, "main");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4727U, "main");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    while (1) {
      while (1) {
        if ((unsigned long )g.inf != (unsigned long )((void *)0)) {
          free((void *)g.inf);
          g.inf = (char *)((void *)0);
        }
        break;
      }
      g.inz = (size_t )0;
      new_opts();
      break;
    }
    if (try_pushed_) {
      while (1) {
        tmp___27 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___27 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4733U, "main");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4733U, "main");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return (g.ret);
}
}
#pragma merger("0","/tmp/cil-IYg7H9gx.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                        int __detachstate ) ;
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
void yarn_mem(void *(*lease)(size_t  ) , void (*vacate)(void * ) ) ;
char *yarn_prefix  =    (char *)"yarn";
void (*yarn_abort)(int  )  =    (void (*)(int  ))((void *)0);
static void fail(int err , char const   *file , long line , char const   *func ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", yarn_prefix);
  switch (err) {
  case 1: 
  fputs((char const   * __restrict  )"already unlocked", (FILE * __restrict  )stderr);
  break;
  case 3: 
  fputs((char const   * __restrict  )"no such thread", (FILE * __restrict  )stderr);
  break;
  case 35: 
  fputs((char const   * __restrict  )"resource deadlock", (FILE * __restrict  )stderr);
  break;
  case 12: 
  fputs((char const   * __restrict  )"out of memory", (FILE * __restrict  )stderr);
  break;
  case 16: 
  fputs((char const   * __restrict  )"can\'t destroy locked resource", (FILE * __restrict  )stderr);
  break;
  case 22: 
  fputs((char const   * __restrict  )"invalid request", (FILE * __restrict  )stderr);
  break;
  case 11: 
  fputs((char const   * __restrict  )"resource unavailable", (FILE * __restrict  )stderr);
  break;
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"internal error %d",
          err);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" (%s:%ld:%s)\n",
          file, line, func);
  if ((unsigned long )yarn_abort != (unsigned long )((void *)0)) {
    (*yarn_abort)(err);
  }
  exit(err);
}
}
static void *(*my_malloc_f)(size_t  )  =    & malloc;
static void (*my_free)(void * )  =    & free;
void yarn_mem(void *(*lease)(size_t  ) , void (*vacate)(void * ) ) 
{ 


  {
  my_malloc_f = lease;
  my_free = vacate;
  return;
}
}
static void *my_malloc(size_t size , char const   *file , long line ) 
{ 
  void *block ;

  {
  block = (*my_malloc_f)(size);
  if ((unsigned long )block == (unsigned long )((void *)0)) {
    fail(12, file, line, "malloc");
  }
  return (block);
}
}
lock *new_lock_(long initial , char const   *file , long line ) 
{ 
  lock *bolt ;
  void *tmp ;
  int ret ;
  int tmp___0 ;

  {
  tmp = my_malloc(sizeof(struct lock_s ), file, line);
  bolt = (lock *)tmp;
  tmp___0 = pthread_mutex_init(& bolt->mutex, (pthread_mutexattr_t const   *)((void *)0));
  ret = tmp___0;
  if (ret) {
    fail(ret, file, line, "mutex_init");
  }
  ret = pthread_cond_init((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (ret) {
    fail(ret, file, line, "cond_init");
  }
  bolt->value = initial;
  return (bolt);
}
}
void possess_(lock *bolt , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_mutex_lock(& bolt->mutex);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "mutex_lock");
  }
  return;
}
}
void release_(lock *bolt , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_mutex_unlock(& bolt->mutex);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "mutex_unlock");
  }
  return;
}
}
void twist_(lock *bolt , enum twist_op op , long val , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  if ((unsigned int )op == 0U) {
    bolt->value = val;
  } else
  if ((unsigned int )op == 1U) {
    bolt->value += val;
  }
  tmp = pthread_cond_broadcast(& bolt->cond);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "cond_broadcast");
  }
  ret = pthread_mutex_unlock(& bolt->mutex);
  if (ret) {
    fail(ret, file, line, "mutex_unlock");
  }
  return;
}
}
void wait_for_(lock *bolt , enum wait_op op , long val , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;
  int ret___0 ;
  int tmp___0 ;
  int ret___1 ;
  int tmp___1 ;
  int ret___2 ;
  int tmp___2 ;

  {
  switch ((unsigned int )op) {
  case 0U: 
  while (! (bolt->value == val)) {
    tmp = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret = tmp;
    if (ret) {
      fail(ret, file, line, "cond_wait");
    }
  }
  break;
  case 1U: 
  while (! (bolt->value != val)) {
    tmp___0 = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret___0 = tmp___0;
    if (ret___0) {
      fail(ret___0, file, line, "cond_wait");
    }
  }
  break;
  case 2U: 
  while (! (bolt->value > val)) {
    tmp___1 = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret___1 = tmp___1;
    if (ret___1) {
      fail(ret___1, file, line, "cond_wait");
    }
  }
  break;
  case 3U: 
  while (! (bolt->value < val)) {
    tmp___2 = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret___2 = tmp___2;
    if (ret___2) {
      fail(ret___2, file, line, "cond_wait");
    }
  }
  }
  return;
}
}
long peek_lock(lock *bolt ) 
{ 


  {
  return (bolt->value);
}
}
void free_lock_(lock *bolt , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  if ((unsigned long )bolt == (unsigned long )((void *)0)) {
    return;
  }
  tmp = pthread_cond_destroy(& bolt->cond);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "cond_destroy");
  }
  ret = pthread_mutex_destroy(& bolt->mutex);
  if (ret) {
    fail(ret, file, line, "mutex_destroy");
  }
  (*my_free)((void *)bolt);
  return;
}
}
static lock threads_lock  =    {{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}}, 0L};
static thread *threads  =    (thread *)((void *)0);
static void reenter(void *arg ) 
{ 
  struct capsule *capsule ;
  pthread_t me ;
  pthread_t tmp ;
  thread **prior ;
  thread *match ;
  int tmp___0 ;

  {
  capsule = (struct capsule *)arg;
  tmp = pthread_self();
  me = tmp;
  possess_(& threads_lock, capsule->file, capsule->line);
  prior = & threads;
  while (1) {
    match = *prior;
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
      break;
    }
    tmp___0 = pthread_equal(match->id, me);
    if (tmp___0) {
      break;
    }
    prior = & match->next;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    fail(3, capsule->file, capsule->line, "reenter lost");
  }
  match->done = 1;
  if ((unsigned long )threads != (unsigned long )match) {
    *prior = match->next;
    match->next = threads;
    threads = match;
  }
  twist_(& threads_lock, (enum twist_op )1, 1L, capsule->file, capsule->line);
  (*my_free)((void *)capsule);
  return;
}
}
static void *ignition(void *arg ) 
{ 
  struct capsule *capsule ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
  capsule = (struct capsule *)arg;
  while (1) {
    __cancel_routine = & reenter;
    __cancel_arg = arg;
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
    __not_first_call = tmp;
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    if (tmp___0) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      (*(capsule->probe))(capsule->payload);
      while (1) {
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((void *)0);
}
}
thread *launch_(void (*probe)(void * ) , void *payload , char const   *file , long line ) 
{ 
  struct capsule *capsule ;
  void *tmp ;
  thread *th ;
  void *tmp___0 ;
  pthread_attr_t attr ;
  int ret ;
  int tmp___1 ;

  {
  tmp = my_malloc(sizeof(struct capsule ), file, line);
  capsule = (struct capsule *)tmp;
  capsule->probe = probe;
  capsule->payload = payload;
  capsule->file = file;
  capsule->line = line;
  possess_(& threads_lock, file, line);
  tmp___0 = my_malloc(sizeof(struct thread_s ), file, line);
  th = (thread *)tmp___0;
  tmp___1 = pthread_attr_init(& attr);
  ret = tmp___1;
  if (ret) {
    fail(ret, file, line, "attr_init");
  }
  ret = pthread_attr_setdetachstate(& attr, 0);
  if (ret) {
    fail(ret, file, line, "attr_setdetachstate");
  }
  ret = pthread_create((pthread_t * __restrict  )(& th->id), (pthread_attr_t const   * __restrict  )(& attr),
                       & ignition, (void * __restrict  )capsule);
  if (ret) {
    fail(ret, file, line, "create");
  }
  ret = pthread_attr_destroy(& attr);
  if (ret) {
    fail(ret, file, line, "attr_destroy");
  }
  th->done = 0;
  th->next = threads;
  threads = th;
  release_(& threads_lock, file, line);
  return (th);
}
}
void join_(thread *ally , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;
  thread **prior ;
  thread *match ;

  {
  tmp = pthread_join(ally->id, (void **)((void *)0));
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "join");
  }
  possess_(& threads_lock, file, line);
  prior = & threads;
  while (1) {
    match = *prior;
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
      break;
    }
    if ((unsigned long )match == (unsigned long )ally) {
      break;
    }
    prior = & match->next;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    fail(3, file, line, "join lost");
  }
  if (match->done) {
    (threads_lock.value) --;
  }
  *prior = match->next;
  release_(& threads_lock, file, line);
  (*my_free)((void *)ally);
  return;
}
}
int join_all_(char const   *file , long line ) 
{ 
  int count ;
  thread **prior ;
  thread *match ;
  int ret ;
  int tmp ;

  {
  count = 0;
  possess_(& threads_lock, file, line);
  while ((unsigned long )threads != (unsigned long )((void *)0)) {
    wait_for_(& threads_lock, (enum wait_op )1, 0L, file, line);
    prior = & threads;
    while (1) {
      match = *prior;
      if (! ((unsigned long )match != (unsigned long )((void *)0))) {
        break;
      }
      if (match->done) {
        break;
      }
      prior = & match->next;
    }
    if ((unsigned long )match == (unsigned long )((void *)0)) {
      fail(3, file, line, "join_all lost");
    }
    tmp = pthread_join(match->id, (void **)((void *)0));
    ret = tmp;
    if (ret) {
      fail(ret, file, line, "join");
    }
    (threads_lock.value) --;
    *prior = match->next;
    (*my_free)((void *)match);
    count ++;
  }
  release_(& threads_lock, file, line);
  return (count);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-ae3O3rCa.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_key_create)(pthread_key_t *__key ,
                                                                                               void (*__destr_function)(void * ) ) ;
pthread_key_t try_key_  ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
static pthread_once_t try_once_  =    0;
static void try_create_(void) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_key_create(& try_key_, (void (*)(void * ))((void *)0));
  ret = tmp;
  if (ret == 0) {
    if (! "try: pthread_key_create() failed") {
      __assert_fail("ret == 0 && \"try: pthread_key_create() failed\"", "try.c", 22U,
                    "try_create_");
    }
  } else {
    __assert_fail("ret == 0 && \"try: pthread_key_create() failed\"", "try.c", 22U,
                  "try_create_");
  }
  return;
}
}
void try_setup_(void) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_once(& try_once_, & try_create_);
  ret = tmp;
  if (ret == 0) {
    if (! "try: pthread_once() failed") {
      __assert_fail("ret == 0 && \"try: pthread_once() failed\"", "try.c", 27U, "try_setup_");
    }
  } else {
    __assert_fail("ret == 0 && \"try: pthread_once() failed\"", "try.c", 27U, "try_setup_");
  }
  return;
}
}
 __attribute__((__noreturn__)) void try_throw_(int code , char *fmt  , ...) ;
void try_throw_(int code , char *fmt  , ...) 
{ 
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *why ;
  char nul[1] ;
  size_t len ;
  va_list___0 ap1 ;
  va_list___0 ap2 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;

  {
  try_setup_();
  tmp___2 = pthread_getspecific(try_key_);
  if ((unsigned long )((try_t_ *)tmp___2) != (unsigned long )((void *)0)) {
    if (! "try: naked throw") {
      __assert_fail("try_stack_ != NULL && \"try: naked throw\"", "try.c", 40U, "try_throw_");
    }
  } else {
    __assert_fail("try_stack_ != NULL && \"try: naked throw\"", "try.c", 40U, "try_throw_");
  }
  tmp___3 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___3)->ball.ret = 1;
  tmp___4 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___4)->ball.code = code;
  tmp___5 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___5)->ball.free = 0;
  tmp___6 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___6)->ball.why = fmt;
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    tmp___12 = strchr((char const   *)fmt, '%');
    if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
      __builtin_va_start(ap1, fmt);
      __builtin_va_copy(ap2, ap1);
      tmp___7 = vsnprintf((char * __restrict  )(nul), (size_t )1, (char const   * __restrict  )fmt,
                          ap1);
      len = (size_t )tmp___7;
      __builtin_va_end(ap1);
      tmp___8 = malloc(len + 1UL);
      why = (char *)tmp___8;
      if ((unsigned long )why == (unsigned long )((void *)0)) {
        tmp___9 = pthread_getspecific(try_key_);
        ((try_t_ *)tmp___9)->ball.why = (char *)"try: out of memory";
      } else {
        vsnprintf((char * __restrict  )why, len + 1UL, (char const   * __restrict  )fmt,
                  ap2);
        __builtin_va_end(ap2);
        tmp___10 = pthread_getspecific(try_key_);
        ((try_t_ *)tmp___10)->ball.free = 1;
        tmp___11 = pthread_getspecific(try_key_);
        ((try_t_ *)tmp___11)->ball.why = why;
      }
    }
  }
  tmp___13 = pthread_getspecific(try_key_);
  longjmp((struct __jmp_buf_tag *)(((try_t_ *)tmp___13)->env), 1);
}
}
#pragma merger("0","/tmp/cil-6OHkTUbc.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliInitLZ77Store(unsigned char const   *data , ZopfliLZ77Store *store ) ;
void ZopfliCleanLZ77Store(ZopfliLZ77Store *store ) ;
void ZopfliAppendLZ77Store(ZopfliLZ77Store const   *store , ZopfliLZ77Store *target ) ;
size_t ZopfliLZ77GetByteRange(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ) ;
void ZopfliLZ77GetHistogram(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                            size_t *ll_counts , size_t *d_counts ) ;
void ZopfliInitBlockState(ZopfliOptions const   *options , size_t blockstart , size_t blockend ,
                          int add_lmc , ZopfliBlockState *s ) ;
void ZopfliCleanBlockState(ZopfliBlockState *s ) ;
void ZopfliDeflate(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in___0 ,
                   size_t insize , unsigned char *bp , unsigned char **out___0 , size_t *outsize ) ;
double ZopfliCalculateBlockSize(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                                int btype ) ;
double ZopfliCalculateBlockSizeAutoType(ZopfliLZ77Store const   *lz77 , size_t lstart ,
                                        size_t lend ) ;
void ZopfliBlockSplitLZ77(ZopfliOptions const   *options , ZopfliLZ77Store const   *lz77 ,
                          size_t maxblocks , size_t **splitpoints , size_t *npoints ) ;
void ZopfliBlockSplit(ZopfliOptions const   *options , unsigned char const   *in___0 ,
                      size_t instart , size_t inend , size_t maxblocks , size_t **splitpoints ,
                      size_t *npoints ) ;
void ZopfliLZ77Optimal(ZopfliBlockState *s , unsigned char const   *in___0 , size_t instart ,
                       size_t inend , int numiterations , ZopfliLZ77Store *store ) ;
void ZopfliLZ77OptimalFixed(ZopfliBlockState *s , unsigned char const   *in___0 ,
                            size_t instart , size_t inend , ZopfliLZ77Store *store ) ;
int ZopfliGetDistExtraBits(int dist ) ;
int ZopfliGetDistExtraBitsValue(int dist ) ;
int ZopfliGetDistSymbol(int dist ) ;
int ZopfliGetLengthExtraBits(int l ) ;
int ZopfliGetLengthExtraBitsValue(int l ) ;
int ZopfliGetLengthSymbol(int l ) ;
int ZopfliGetLengthSymbolExtraBits(int s ) ;
int ZopfliGetDistSymbolExtraBits(int s ) ;
void ZopfliCalculateBitLengths(size_t const   *count , size_t n , int maxbits , unsigned int *bitlengths ) ;
void ZopfliLengthsToSymbols(unsigned int const   *lengths , size_t n , unsigned int maxbits ,
                            unsigned int *symbols ) ;
static void AddBit(int bit , unsigned char *bp , unsigned char **out___0 , size_t *outsize ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  if ((int )*bp == 0) {
    if (! (*outsize & (*outsize - 1UL))) {
      if (*outsize == 0UL) {
        tmp = malloc(sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp;
      } else {
        tmp___0 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___0;
      }
    }
    *(*out___0 + *outsize) = (unsigned char)0;
    (*outsize) ++;
  }
  *(*out___0 + (*outsize - 1UL)) = (unsigned char )((int )*(*out___0 + (*outsize - 1UL)) | (bit << (int )*bp));
  *bp = (unsigned char )(((int )*bp + 1) & 7);
  return;
}
}
static void AddBits(unsigned int symbol , unsigned int length , unsigned char *bp ,
                    unsigned char **out___0 , size_t *outsize ) 
{ 
  unsigned int i ;
  unsigned int bit ;
  void *tmp ;
  void *tmp___0 ;

  {
  i = 0U;
  while (i < length) {
    bit = (symbol >> i) & 1U;
    if ((int )*bp == 0) {
      if (! (*outsize & (*outsize - 1UL))) {
        if (*outsize == 0UL) {
          tmp = malloc(sizeof(*(*out___0)));
          *out___0 = (unsigned char *)tmp;
        } else {
          tmp___0 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
          *out___0 = (unsigned char *)tmp___0;
        }
      }
      *(*out___0 + *outsize) = (unsigned char)0;
      (*outsize) ++;
    }
    *(*out___0 + (*outsize - 1UL)) = (unsigned char )((unsigned int )*(*out___0 + (*outsize - 1UL)) | (bit << (int )*bp));
    *bp = (unsigned char )(((int )*bp + 1) & 7);
    i ++;
  }
  return;
}
}
static void AddHuffmanBits(unsigned int symbol , unsigned int length , unsigned char *bp ,
                           unsigned char **out___0 , size_t *outsize ) 
{ 
  unsigned int i ;
  unsigned int bit ;
  void *tmp ;
  void *tmp___0 ;

  {
  i = 0U;
  while (i < length) {
    bit = (symbol >> ((length - i) - 1U)) & 1U;
    if ((int )*bp == 0) {
      if (! (*outsize & (*outsize - 1UL))) {
        if (*outsize == 0UL) {
          tmp = malloc(sizeof(*(*out___0)));
          *out___0 = (unsigned char *)tmp;
        } else {
          tmp___0 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
          *out___0 = (unsigned char *)tmp___0;
        }
      }
      *(*out___0 + *outsize) = (unsigned char)0;
      (*outsize) ++;
    }
    *(*out___0 + (*outsize - 1UL)) = (unsigned char )((unsigned int )*(*out___0 + (*outsize - 1UL)) | (bit << (int )*bp));
    *bp = (unsigned char )(((int )*bp + 1) & 7);
    i ++;
  }
  return;
}
}
static void PatchDistanceCodesForBuggyDecoders(unsigned int *d_lengths ) 
{ 
  int num_dist_codes ;
  int i ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  num_dist_codes = 0;
  i = 0;
  while (i < 30) {
    if (*(d_lengths + i)) {
      num_dist_codes ++;
    }
    if (num_dist_codes >= 2) {
      return;
    }
    i ++;
  }
  if (num_dist_codes == 0) {
    tmp = 1U;
    *(d_lengths + 1) = tmp;
    *(d_lengths + 0) = tmp;
  } else
  if (num_dist_codes == 1) {
    if (*(d_lengths + 0)) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    *(d_lengths + tmp___0) = 1U;
  }
  return;
}
}
static size_t EncodeTree(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                         int use_16 , int use_17 , int use_18 , unsigned char *bp ,
                         unsigned char **out___0 , size_t *outsize ) ;
static unsigned int const   order[19]  = 
  {      (unsigned int const   )16,      (unsigned int const   )17,      (unsigned int const   )18,      (unsigned int const   )0, 
        (unsigned int const   )8,      (unsigned int const   )7,      (unsigned int const   )9,      (unsigned int const   )6, 
        (unsigned int const   )10,      (unsigned int const   )5,      (unsigned int const   )11,      (unsigned int const   )4, 
        (unsigned int const   )12,      (unsigned int const   )3,      (unsigned int const   )13,      (unsigned int const   )2, 
        (unsigned int const   )14,      (unsigned int const   )1,      (unsigned int const   )15};
static size_t EncodeTree(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                         int use_16 , int use_17 , int use_18 , unsigned char *bp ,
                         unsigned char **out___0 , size_t *outsize ) 
{ 
  unsigned int lld_total ;
  unsigned int *rle ;
  unsigned int *rle_bits ;
  size_t rle_size ;
  size_t rle_bits_size ;
  unsigned int hlit ;
  unsigned int hdist ;
  unsigned int hclen ;
  unsigned int hlit2 ;
  size_t i ;
  size_t j ;
  size_t clcounts[19] ;
  unsigned int clcl[19] ;
  unsigned int clsymbols[19] ;
  int size_only ;
  size_t result_size ;
  unsigned char symbol ;
  unsigned int tmp ;
  unsigned int count ;
  unsigned int tmp___0 ;
  unsigned int count2 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  unsigned int count2___0 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  unsigned int count2___1 ;
  unsigned int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  unsigned int symbol___0 ;

  {
  rle = (unsigned int *)0;
  rle_bits = (unsigned int *)0;
  rle_size = (size_t )0;
  rle_bits_size = (size_t )0;
  hlit = 29U;
  hdist = 29U;
  size_only = ! out___0;
  result_size = (size_t )0;
  i = (size_t )0;
  while (i < 19UL) {
    clcounts[i] = (size_t )0;
    i ++;
  }
  while (1) {
    if (hlit > 0U) {
      if (! (*(ll_lengths + ((257U + hlit) - 1U)) == 0U)) {
        break;
      }
    } else {
      break;
    }
    hlit --;
  }
  while (1) {
    if (hdist > 0U) {
      if (! (*(d_lengths + ((1U + hdist) - 1U)) == 0U)) {
        break;
      }
    } else {
      break;
    }
    hdist --;
  }
  hlit2 = hlit + 257U;
  lld_total = (hlit2 + hdist) + 1U;
  i = (size_t )0;
  while (i < (size_t )lld_total) {
    if (i < (size_t )hlit2) {
      tmp = *(ll_lengths + i);
    } else {
      tmp = *(d_lengths + (i - (size_t )hlit2));
    }
    symbol = (unsigned char )tmp;
    count = 1U;
    if (use_16) {
      goto _L___0;
    } else
    if ((int )symbol == 0) {
      if (use_17) {
        goto _L___0;
      } else
      if (use_18) {
        _L___0: /* CIL Label */ 
        j = i + 1UL;
        while (1) {
          if (j < (size_t )lld_total) {
            if (j < (size_t )hlit2) {
              tmp___0 = *(ll_lengths + j);
            } else {
              tmp___0 = *(d_lengths + (j - (size_t )hlit2));
            }
            if (! ((unsigned int const   )symbol == tmp___0)) {
              break;
            }
          } else {
            break;
          }
          count ++;
          j ++;
        }
      }
    }
    i += (size_t )(count - 1U);
    if ((int )symbol == 0) {
      if (count >= 3U) {
        if (use_18) {
          while (count >= 11U) {
            if (count > 138U) {
              tmp___1 = 138U;
            } else {
              tmp___1 = count;
            }
            count2 = tmp___1;
            if (! size_only) {
              if (! (rle_size & (rle_size - 1UL))) {
                if (rle_size == 0UL) {
                  tmp___2 = malloc(sizeof(*rle));
                  rle = (unsigned int *)tmp___2;
                } else {
                  tmp___3 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
                  rle = (unsigned int *)tmp___3;
                }
              }
              *(rle + rle_size) = 18U;
              rle_size ++;
              if (! (rle_bits_size & (rle_bits_size - 1UL))) {
                if (rle_bits_size == 0UL) {
                  tmp___4 = malloc(sizeof(*rle_bits));
                  rle_bits = (unsigned int *)tmp___4;
                } else {
                  tmp___5 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
                  rle_bits = (unsigned int *)tmp___5;
                }
              }
              *(rle_bits + rle_bits_size) = count2 - 11U;
              rle_bits_size ++;
            }
            (clcounts[18]) ++;
            count -= count2;
          }
        }
        if (use_17) {
          while (count >= 3U) {
            if (count > 10U) {
              tmp___6 = 10U;
            } else {
              tmp___6 = count;
            }
            count2___0 = tmp___6;
            if (! size_only) {
              if (! (rle_size & (rle_size - 1UL))) {
                if (rle_size == 0UL) {
                  tmp___7 = malloc(sizeof(*rle));
                  rle = (unsigned int *)tmp___7;
                } else {
                  tmp___8 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
                  rle = (unsigned int *)tmp___8;
                }
              }
              *(rle + rle_size) = 17U;
              rle_size ++;
              if (! (rle_bits_size & (rle_bits_size - 1UL))) {
                if (rle_bits_size == 0UL) {
                  tmp___9 = malloc(sizeof(*rle_bits));
                  rle_bits = (unsigned int *)tmp___9;
                } else {
                  tmp___10 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
                  rle_bits = (unsigned int *)tmp___10;
                }
              }
              *(rle_bits + rle_bits_size) = count2___0 - 3U;
              rle_bits_size ++;
            }
            (clcounts[17]) ++;
            count -= count2___0;
          }
        }
      }
    }
    if (use_16) {
      if (count >= 4U) {
        count --;
        (clcounts[symbol]) ++;
        if (! size_only) {
          if (! (rle_size & (rle_size - 1UL))) {
            if (rle_size == 0UL) {
              tmp___11 = malloc(sizeof(*rle));
              rle = (unsigned int *)tmp___11;
            } else {
              tmp___12 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
              rle = (unsigned int *)tmp___12;
            }
          }
          *(rle + rle_size) = (unsigned int )symbol;
          rle_size ++;
          if (! (rle_bits_size & (rle_bits_size - 1UL))) {
            if (rle_bits_size == 0UL) {
              tmp___13 = malloc(sizeof(*rle_bits));
              rle_bits = (unsigned int *)tmp___13;
            } else {
              tmp___14 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
              rle_bits = (unsigned int *)tmp___14;
            }
          }
          *(rle_bits + rle_bits_size) = 0U;
          rle_bits_size ++;
        }
        while (count >= 3U) {
          if (count > 6U) {
            tmp___15 = 6U;
          } else {
            tmp___15 = count;
          }
          count2___1 = tmp___15;
          if (! size_only) {
            if (! (rle_size & (rle_size - 1UL))) {
              if (rle_size == 0UL) {
                tmp___16 = malloc(sizeof(*rle));
                rle = (unsigned int *)tmp___16;
              } else {
                tmp___17 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
                rle = (unsigned int *)tmp___17;
              }
            }
            *(rle + rle_size) = 16U;
            rle_size ++;
            if (! (rle_bits_size & (rle_bits_size - 1UL))) {
              if (rle_bits_size == 0UL) {
                tmp___18 = malloc(sizeof(*rle_bits));
                rle_bits = (unsigned int *)tmp___18;
              } else {
                tmp___19 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
                rle_bits = (unsigned int *)tmp___19;
              }
            }
            *(rle_bits + rle_bits_size) = count2___1 - 3U;
            rle_bits_size ++;
          }
          (clcounts[16]) ++;
          count -= count2___1;
        }
      }
    }
    clcounts[symbol] += (size_t )count;
    while (count > 0U) {
      if (! size_only) {
        if (! (rle_size & (rle_size - 1UL))) {
          if (rle_size == 0UL) {
            tmp___20 = malloc(sizeof(*rle));
            rle = (unsigned int *)tmp___20;
          } else {
            tmp___21 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
            rle = (unsigned int *)tmp___21;
          }
        }
        *(rle + rle_size) = (unsigned int )symbol;
        rle_size ++;
        if (! (rle_bits_size & (rle_bits_size - 1UL))) {
          if (rle_bits_size == 0UL) {
            tmp___22 = malloc(sizeof(*rle_bits));
            rle_bits = (unsigned int *)tmp___22;
          } else {
            tmp___23 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
            rle_bits = (unsigned int *)tmp___23;
          }
        }
        *(rle_bits + rle_bits_size) = 0U;
        rle_bits_size ++;
      }
      count --;
    }
    i ++;
  }
  ZopfliCalculateBitLengths((size_t const   *)(clcounts), (size_t )19, 7, clcl);
  if (! size_only) {
    ZopfliLengthsToSymbols((unsigned int const   *)(clcl), (size_t )19, 7U, clsymbols);
  }
  hclen = 15U;
  while (1) {
    if (hclen > 0U) {
      if (! (clcounts[order[(hclen + 4U) - 1U]] == 0UL)) {
        break;
      }
    } else {
      break;
    }
    hclen --;
  }
  if (! size_only) {
    AddBits(hlit, 5U, bp, out___0, outsize);
    AddBits(hdist, 5U, bp, out___0, outsize);
    AddBits(hclen, 4U, bp, out___0, outsize);
    i = (size_t )0;
    while (i < (size_t )(hclen + 4U)) {
      AddBits(clcl[order[i]], 3U, bp, out___0, outsize);
      i ++;
    }
    i = (size_t )0;
    while (i < rle_size) {
      symbol___0 = clsymbols[*(rle + i)];
      AddHuffmanBits(symbol___0, clcl[*(rle + i)], bp, out___0, outsize);
      if (*(rle + i) == 16U) {
        AddBits(*(rle_bits + i), 2U, bp, out___0, outsize);
      } else
      if (*(rle + i) == 17U) {
        AddBits(*(rle_bits + i), 3U, bp, out___0, outsize);
      } else
      if (*(rle + i) == 18U) {
        AddBits(*(rle_bits + i), 7U, bp, out___0, outsize);
      }
      i ++;
    }
  }
  result_size += 14UL;
  result_size += (size_t )((hclen + 4U) * 3U);
  i = (size_t )0;
  while (i < 19UL) {
    result_size += (size_t )clcl[i] * clcounts[i];
    i ++;
  }
  result_size += clcounts[16] * 2UL;
  result_size += clcounts[17] * 3UL;
  result_size += clcounts[18] * 7UL;
  free((void *)rle);
  free((void *)rle_bits);
  return (result_size);
}
}
static void AddDynamicTree(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                           unsigned char *bp , unsigned char **out___0 , size_t *outsize ) 
{ 
  int i ;
  int best ;
  size_t bestsize ;
  size_t size ;
  size_t tmp ;

  {
  best = 0;
  bestsize = (size_t )0;
  i = 0;
  while (i < 8) {
    tmp = EncodeTree(ll_lengths, d_lengths, i & 1, i & 2, i & 4, (unsigned char *)0,
                     (unsigned char **)0, (size_t *)0);
    size = tmp;
    if (bestsize == 0UL) {
      bestsize = size;
      best = i;
    } else
    if (size < bestsize) {
      bestsize = size;
      best = i;
    }
    i ++;
  }
  EncodeTree(ll_lengths, d_lengths, best & 1, best & 2, best & 4, bp, out___0, outsize);
  return;
}
}
static size_t CalculateTreeSize(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ) 
{ 
  size_t result ;
  int i ;
  size_t size ;
  size_t tmp ;

  {
  result = (size_t )0;
  i = 0;
  while (i < 8) {
    tmp = EncodeTree(ll_lengths, d_lengths, i & 1, i & 2, i & 4, (unsigned char *)0,
                     (unsigned char **)0, (size_t *)0);
    size = tmp;
    if (result == 0UL) {
      result = size;
    } else
    if (size < result) {
      result = size;
    }
    i ++;
  }
  return (result);
}
}
static void AddLZ77Data(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                        size_t expected_data_size , unsigned int const   *ll_symbols ,
                        unsigned int const   *ll_lengths , unsigned int const   *d_symbols ,
                        unsigned int const   *d_lengths , unsigned char *bp , unsigned char **out___0 ,
                        size_t *outsize ) 
{ 
  size_t testlength ;
  size_t i ;
  unsigned int dist ;
  unsigned int litlen ;
  unsigned int lls ;
  int tmp___1 ;
  unsigned int ds ;
  int tmp___2 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  testlength = (size_t )0;
  i = lstart;
  while (i < lend) {
    dist = (unsigned int )*(lz77->dists + i);
    litlen = (unsigned int )*(lz77->litlens + i);
    if (dist == 0U) {
      if (! (litlen < 256U)) {
        __assert_fail("litlen < 256", "zopfli/src/zopfli/deflate.c", 311U, "AddLZ77Data");
      }
      if (! (*(ll_lengths + litlen) > 0U)) {
        __assert_fail("ll_lengths[litlen] > 0", "zopfli/src/zopfli/deflate.c", 312U,
                      "AddLZ77Data");
      }
      AddHuffmanBits((unsigned int )*(ll_symbols + litlen), (unsigned int )*(ll_lengths + litlen),
                     bp, out___0, outsize);
      testlength ++;
    } else {
      tmp___1 = ZopfliGetLengthSymbol((int )litlen);
      lls = (unsigned int )tmp___1;
      tmp___2 = ZopfliGetDistSymbol((int )dist);
      ds = (unsigned int )tmp___2;
      if (litlen >= 3U) {
        if (! (litlen <= 288U)) {
          __assert_fail("litlen >= 3 && litlen <= 288", "zopfli/src/zopfli/deflate.c",
                        318U, "AddLZ77Data");
        }
      } else {
        __assert_fail("litlen >= 3 && litlen <= 288", "zopfli/src/zopfli/deflate.c",
                      318U, "AddLZ77Data");
      }
      if (! (*(ll_lengths + lls) > 0U)) {
        __assert_fail("ll_lengths[lls] > 0", "zopfli/src/zopfli/deflate.c", 319U,
                      "AddLZ77Data");
      }
      if (! (*(d_lengths + ds) > 0U)) {
        __assert_fail("d_lengths[ds] > 0", "zopfli/src/zopfli/deflate.c", 320U, "AddLZ77Data");
      }
      AddHuffmanBits((unsigned int )*(ll_symbols + lls), (unsigned int )*(ll_lengths + lls),
                     bp, out___0, outsize);
      tmp___6 = ZopfliGetLengthExtraBits((int )litlen);
      tmp___7 = ZopfliGetLengthExtraBitsValue((int )litlen);
      AddBits((unsigned int )tmp___7, (unsigned int )tmp___6, bp, out___0, outsize);
      AddHuffmanBits((unsigned int )*(d_symbols + ds), (unsigned int )*(d_lengths + ds),
                     bp, out___0, outsize);
      tmp___8 = ZopfliGetDistExtraBits((int )dist);
      tmp___9 = ZopfliGetDistExtraBitsValue((int )dist);
      AddBits((unsigned int )tmp___9, (unsigned int )tmp___8, bp, out___0, outsize);
      testlength += (size_t )litlen;
    }
    i ++;
  }
  if (! (expected_data_size == 0UL)) {
    if (! (testlength == expected_data_size)) {
      __assert_fail("expected_data_size == 0 || testlength == expected_data_size",
                    "zopfli/src/zopfli/deflate.c", 332U, "AddLZ77Data");
    }
  }
  return;
}
}
static void GetFixedTree(unsigned int *ll_lengths , unsigned int *d_lengths ) 
{ 
  size_t i ;

  {
  i = (size_t )0;
  while (i < 144UL) {
    *(ll_lengths + i) = 8U;
    i ++;
  }
  i = (size_t )144;
  while (i < 256UL) {
    *(ll_lengths + i) = 9U;
    i ++;
  }
  i = (size_t )256;
  while (i < 280UL) {
    *(ll_lengths + i) = 7U;
    i ++;
  }
  i = (size_t )280;
  while (i < 288UL) {
    *(ll_lengths + i) = 8U;
    i ++;
  }
  i = (size_t )0;
  while (i < 32UL) {
    *(d_lengths + i) = 5U;
    i ++;
  }
  return;
}
}
static size_t CalculateBlockSymbolSizeSmall(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                                            ZopfliLZ77Store const   *lz77 , size_t lstart ,
                                            size_t lend ) 
{ 
  size_t result ;
  size_t i ;
  int ll_symbol ;
  int tmp___1 ;
  int d_symbol ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  result = (size_t )0;
  i = lstart;
  while (i < lend) {
    if (! (i < (size_t )lz77->size)) {
      __assert_fail("i < lz77->size", "zopfli/src/zopfli/deflate.c", 355U, "CalculateBlockSymbolSizeSmall");
    }
    if (! ((int )*(lz77->litlens + i) < 259)) {
      __assert_fail("lz77->litlens[i] < 259", "zopfli/src/zopfli/deflate.c", 356U,
                    "CalculateBlockSymbolSizeSmall");
    }
    if ((int )*(lz77->dists + i) == 0) {
      result += (size_t )*(ll_lengths + *(lz77->litlens + i));
    } else {
      tmp___1 = ZopfliGetLengthSymbol((int )*(lz77->litlens + i));
      ll_symbol = tmp___1;
      tmp___2 = ZopfliGetDistSymbol((int )*(lz77->dists + i));
      d_symbol = tmp___2;
      result += (size_t )*(ll_lengths + ll_symbol);
      result += (size_t )*(d_lengths + d_symbol);
      tmp___3 = ZopfliGetLengthSymbolExtraBits(ll_symbol);
      result += (size_t )tmp___3;
      tmp___4 = ZopfliGetDistSymbolExtraBits(d_symbol);
      result += (size_t )tmp___4;
    }
    i ++;
  }
  result += (size_t )*(ll_lengths + 256);
  return (result);
}
}
static size_t CalculateBlockSymbolSizeGivenCounts(size_t const   *ll_counts , size_t const   *d_counts ,
                                                  unsigned int const   *ll_lengths ,
                                                  unsigned int const   *d_lengths ,
                                                  ZopfliLZ77Store const   *lz77 ,
                                                  size_t lstart , size_t lend ) 
{ 
  size_t result ;
  size_t i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  result = (size_t )0;
  if (lstart + 864UL > lend) {
    tmp = CalculateBlockSymbolSizeSmall(ll_lengths, d_lengths, lz77, lstart, lend);
    return (tmp);
  } else {
    i = (size_t )0;
    while (i < 256UL) {
      result += (size_t )((size_t const   )*(ll_lengths + i) * *(ll_counts + i));
      i ++;
    }
    i = (size_t )257;
    while (i < 286UL) {
      result += (size_t )((size_t const   )*(ll_lengths + i) * *(ll_counts + i));
      tmp___0 = ZopfliGetLengthSymbolExtraBits((int )i);
      result += (size_t )((size_t const   )tmp___0 * *(ll_counts + i));
      i ++;
    }
    i = (size_t )0;
    while (i < 30UL) {
      result += (size_t )((size_t const   )*(d_lengths + i) * *(d_counts + i));
      tmp___1 = ZopfliGetDistSymbolExtraBits((int )i);
      result += (size_t )((size_t const   )tmp___1 * *(d_counts + i));
      i ++;
    }
    result += (size_t )*(ll_lengths + 256);
    return (result);
  }
}
}
static size_t CalculateBlockSymbolSize(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                                       ZopfliLZ77Store const   *lz77 , size_t lstart ,
                                       size_t lend ) 
{ 
  size_t tmp ;
  size_t ll_counts[288] ;
  size_t d_counts[32] ;
  size_t tmp___0 ;

  {
  if (lstart + 864UL > lend) {
    tmp = CalculateBlockSymbolSizeSmall(ll_lengths, d_lengths, lz77, lstart, lend);
    return (tmp);
  } else {
    ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);
    tmp___0 = CalculateBlockSymbolSizeGivenCounts((size_t const   *)(ll_counts), (size_t const   *)(d_counts),
                                                  ll_lengths, d_lengths, lz77, lstart,
                                                  lend);
    return (tmp___0);
  }
}
}
static size_t AbsDiff(size_t x , size_t y ) 
{ 


  {
  if (x > y) {
    return (x - y);
  } else {
    return (y - x);
  }
}
}
void OptimizeHuffmanForRle(unsigned int length , size_t *counts ) 
{ 
  unsigned int i ;
  int k ;
  int stride ;
  size_t symbol ;
  size_t sum ;
  size_t limit ;
  int *good_for_rle ;
  void *tmp ;
  int count ;
  size_t tmp___0 ;

  {
  while (length > 0U) {
    if (*(counts + (length - 1U)) != 0UL) {
      break;
    }
    length --;
  }
  if (length == 0U) {
    return;
  }
  tmp = malloc((unsigned long )length * sizeof(int ));
  good_for_rle = (int *)tmp;
  i = 0U;
  while (i < length) {
    *(good_for_rle + i) = 0;
    i ++;
  }
  symbol = *(counts + 0);
  stride = 0;
  i = 0U;
  while (i < length + 1U) {
    if (i == length) {
      goto _L___1;
    } else
    if (*(counts + i) != symbol) {
      _L___1: /* CIL Label */ 
      if (symbol == 0UL) {
        if (stride >= 5) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (symbol != 0UL) {
        if (stride >= 7) {
          _L: /* CIL Label */ 
          k = 0;
          while (k < stride) {
            *(good_for_rle + ((i - (unsigned int )k) - 1U)) = 1;
            k ++;
          }
        }
      }
      stride = 1;
      if (i != length) {
        symbol = *(counts + i);
      }
    } else {
      stride ++;
    }
    i ++;
  }
  stride = 0;
  limit = *(counts + 0);
  sum = (size_t )0;
  i = 0U;
  while (i < length + 1U) {
    if (i == length) {
      goto _L___3;
    } else
    if (*(good_for_rle + i)) {
      goto _L___3;
    } else {
      tmp___0 = AbsDiff(*(counts + i), limit);
      if (tmp___0 >= 4UL) {
        _L___3: /* CIL Label */ 
        if (stride >= 4) {
          goto _L___2;
        } else
        if (stride >= 3) {
          if (sum == 0UL) {
            _L___2: /* CIL Label */ 
            count = (int )((sum + (size_t )(stride / 2)) / (size_t )stride);
            if (count < 1) {
              count = 1;
            }
            if (sum == 0UL) {
              count = 0;
            }
            k = 0;
            while (k < stride) {
              *(counts + ((i - (unsigned int )k) - 1U)) = (size_t )count;
              k ++;
            }
          }
        }
        stride = 0;
        sum = (size_t )0;
        if (i < length - 3U) {
          limit = ((((*(counts + i) + *(counts + (i + 1U))) + *(counts + (i + 2U))) + *(counts + (i + 3U))) + 2UL) / 4UL;
        } else
        if (i < length) {
          limit = *(counts + i);
        } else {
          limit = (size_t )0;
        }
      }
    }
    stride ++;
    if (i != length) {
      sum += *(counts + i);
    }
    i ++;
  }
  free((void *)good_for_rle);
  return;
}
}
static double TryOptimizeHuffmanForRle(ZopfliLZ77Store const   *lz77 , size_t lstart ,
                                       size_t lend , size_t const   *ll_counts , size_t const   *d_counts ,
                                       unsigned int *ll_lengths , unsigned int *d_lengths ) 
{ 
  size_t ll_counts2[288] ;
  size_t d_counts2[32] ;
  unsigned int ll_lengths2[288] ;
  unsigned int d_lengths2[32] ;
  double treesize ;
  double datasize ;
  double treesize2 ;
  double datasize2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = CalculateTreeSize((unsigned int const   *)ll_lengths, (unsigned int const   *)d_lengths);
  treesize = (double )tmp;
  tmp___0 = CalculateBlockSymbolSizeGivenCounts(ll_counts, d_counts, (unsigned int const   *)ll_lengths,
                                                (unsigned int const   *)d_lengths,
                                                lz77, lstart, lend);
  datasize = (double )tmp___0;
  memcpy((void * __restrict  )(ll_counts2), (void const   * __restrict  )ll_counts,
         sizeof(ll_counts2));
  memcpy((void * __restrict  )(d_counts2), (void const   * __restrict  )d_counts,
         sizeof(d_counts2));
  OptimizeHuffmanForRle(288U, ll_counts2);
  OptimizeHuffmanForRle(32U, d_counts2);
  ZopfliCalculateBitLengths((size_t const   *)(ll_counts2), (size_t )288, 15, ll_lengths2);
  ZopfliCalculateBitLengths((size_t const   *)(d_counts2), (size_t )32, 15, d_lengths2);
  PatchDistanceCodesForBuggyDecoders(d_lengths2);
  tmp___1 = CalculateTreeSize((unsigned int const   *)(ll_lengths2), (unsigned int const   *)(d_lengths2));
  treesize2 = (double )tmp___1;
  tmp___2 = CalculateBlockSymbolSizeGivenCounts(ll_counts, d_counts, (unsigned int const   *)(ll_lengths2),
                                                (unsigned int const   *)(d_lengths2),
                                                lz77, lstart, lend);
  datasize2 = (double )tmp___2;
  if (treesize2 + datasize2 < treesize + datasize) {
    memcpy((void * __restrict  )ll_lengths, (void const   * __restrict  )(ll_lengths2),
           sizeof(ll_lengths2));
    memcpy((void * __restrict  )d_lengths, (void const   * __restrict  )(d_lengths2),
           sizeof(d_lengths2));
    return (treesize2 + datasize2);
  }
  return (treesize + datasize);
}
}
static double GetDynamicLengths(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                                unsigned int *ll_lengths , unsigned int *d_lengths ) 
{ 
  size_t ll_counts[288] ;
  size_t d_counts[32] ;
  double tmp ;

  {
  ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);
  ll_counts[256] = (size_t )1;
  ZopfliCalculateBitLengths((size_t const   *)(ll_counts), (size_t )288, 15, ll_lengths);
  ZopfliCalculateBitLengths((size_t const   *)(d_counts), (size_t )32, 15, d_lengths);
  PatchDistanceCodesForBuggyDecoders(d_lengths);
  tmp = TryOptimizeHuffmanForRle(lz77, lstart, lend, (size_t const   *)(ll_counts),
                                 (size_t const   *)(d_counts), ll_lengths, d_lengths);
  return (tmp);
}
}
double ZopfliCalculateBlockSize(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                                int btype ) 
{ 
  unsigned int ll_lengths[288] ;
  unsigned int d_lengths[32] ;
  double result ;
  size_t length ;
  size_t tmp ;
  size_t rem ;
  size_t blocks ;
  int tmp___0 ;
  size_t tmp___1 ;
  double tmp___2 ;

  {
  result = (double )3;
  if (btype == 0) {
    tmp = ZopfliLZ77GetByteRange(lz77, lstart, lend);
    length = tmp;
    rem = length % 65535UL;
    if (rem) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    blocks = length / 65535UL + (size_t )tmp___0;
    return ((double )((blocks * 5UL) * 8UL + length * 8UL));
  }
  if (btype == 1) {
    GetFixedTree(ll_lengths, d_lengths);
    tmp___1 = CalculateBlockSymbolSize((unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_lengths),
                                       lz77, lstart, lend);
    result += (double )tmp___1;
  } else {
    tmp___2 = GetDynamicLengths(lz77, lstart, lend, ll_lengths, d_lengths);
    result += tmp___2;
  }
  return (result);
}
}
double ZopfliCalculateBlockSizeAutoType(ZopfliLZ77Store const   *lz77 , size_t lstart ,
                                        size_t lend ) 
{ 
  double uncompressedcost ;
  double tmp ;
  double fixedcost ;
  double tmp___0 ;
  double tmp___1 ;
  double dyncost ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  tmp = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);
  uncompressedcost = tmp;
  if (lz77->size > 1000UL) {
    tmp___1 = uncompressedcost;
  } else {
    tmp___0 = ZopfliCalculateBlockSize(lz77, lstart, lend, 1);
    tmp___1 = tmp___0;
  }
  fixedcost = tmp___1;
  tmp___2 = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);
  dyncost = tmp___2;
  if (uncompressedcost < fixedcost) {
    if (uncompressedcost < dyncost) {
      tmp___4 = uncompressedcost;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (fixedcost < dyncost) {
      tmp___3 = fixedcost;
    } else {
      tmp___3 = dyncost;
    }
    tmp___4 = tmp___3;
  }
  return (tmp___4);
}
}
static void AddNonCompressedBlock(ZopfliOptions const   *options , int final , unsigned char const   *in___0 ,
                                  size_t instart , size_t inend , unsigned char *bp ,
                                  unsigned char **out___0 , size_t *outsize ) 
{ 
  size_t pos ;
  size_t i ;
  unsigned short blocksize ;
  unsigned short nlen ;
  int currentfinal ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  pos = instart;
  while (1) {
    blocksize = (unsigned short)65535;
    if (pos + (size_t )blocksize > inend) {
      blocksize = (unsigned short )(inend - pos);
    }
    currentfinal = pos + (size_t )blocksize >= inend;
    nlen = (unsigned short )(~ ((int )blocksize));
    if (final) {
      if (currentfinal) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    AddBit(tmp, bp, out___0, outsize);
    AddBit(0, bp, out___0, outsize);
    AddBit(0, bp, out___0, outsize);
    *bp = (unsigned char)0;
    if (! (*outsize & (*outsize - 1UL))) {
      if (*outsize == 0UL) {
        tmp___0 = malloc(sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___0;
      } else {
        tmp___1 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___1;
      }
    }
    *(*out___0 + *outsize) = (unsigned char )((int )blocksize % 256);
    (*outsize) ++;
    if (! (*outsize & (*outsize - 1UL))) {
      if (*outsize == 0UL) {
        tmp___2 = malloc(sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___2;
      } else {
        tmp___3 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___3;
      }
    }
    *(*out___0 + *outsize) = (unsigned char )(((int )blocksize / 256) % 256);
    (*outsize) ++;
    if (! (*outsize & (*outsize - 1UL))) {
      if (*outsize == 0UL) {
        tmp___4 = malloc(sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___4;
      } else {
        tmp___5 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___5;
      }
    }
    *(*out___0 + *outsize) = (unsigned char )((int )nlen % 256);
    (*outsize) ++;
    if (! (*outsize & (*outsize - 1UL))) {
      if (*outsize == 0UL) {
        tmp___6 = malloc(sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___6;
      } else {
        tmp___7 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
        *out___0 = (unsigned char *)tmp___7;
      }
    }
    *(*out___0 + *outsize) = (unsigned char )(((int )nlen / 256) % 256);
    (*outsize) ++;
    i = (size_t )0;
    while (i < (size_t )blocksize) {
      if (! (*outsize & (*outsize - 1UL))) {
        if (*outsize == 0UL) {
          tmp___8 = malloc(sizeof(*(*out___0)));
          *out___0 = (unsigned char *)tmp___8;
        } else {
          tmp___9 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
          *out___0 = (unsigned char *)tmp___9;
        }
      }
      *(*out___0 + *outsize) = (unsigned char )*(in___0 + (pos + i));
      (*outsize) ++;
      i ++;
    }
    if (currentfinal) {
      break;
    }
    pos += (size_t )blocksize;
  }
  return;
}
}
static void AddLZ77Block(ZopfliOptions const   *options , int btype , int final ,
                         ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                         size_t expected_data_size , unsigned char *bp , unsigned char **out___0 ,
                         size_t *outsize ) 
{ 
  unsigned int ll_lengths[288] ;
  unsigned int d_lengths[32] ;
  unsigned int ll_symbols[288] ;
  unsigned int d_symbols[32] ;
  size_t detect_block_size ;
  size_t compressed_size ;
  size_t uncompressed_size ;
  size_t i ;
  size_t length ;
  size_t tmp ;
  size_t pos ;
  size_t tmp___0 ;
  size_t end ;
  unsigned int detect_tree_size ;
  int tmp___2 ;

  {
  detect_block_size = *outsize;
  uncompressed_size = (size_t )0;
  if (btype == 0) {
    tmp = ZopfliLZ77GetByteRange(lz77, lstart, lend);
    length = tmp;
    if (lstart == lend) {
      tmp___0 = (size_t )0;
    } else {
      tmp___0 = *(lz77->pos + lstart);
    }
    pos = tmp___0;
    end = pos + length;
    AddNonCompressedBlock(options, final, (unsigned char const   *)lz77->data, pos,
                          end, bp, out___0, outsize);
    return;
  }
  AddBit(final, bp, out___0, outsize);
  AddBit(btype & 1, bp, out___0, outsize);
  AddBit((btype & 2) >> 1, bp, out___0, outsize);
  if (btype == 1) {
    GetFixedTree(ll_lengths, d_lengths);
  } else {
    if (! (btype == 2)) {
      __assert_fail("btype == 2", "zopfli/src/zopfli/deflate.c", 716U, "AddLZ77Block");
    }
    GetDynamicLengths(lz77, lstart, lend, ll_lengths, d_lengths);
    detect_tree_size = (unsigned int )*outsize;
    AddDynamicTree((unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_lengths),
                   bp, out___0, outsize);
    if (options->verbose) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"treesize: %d\n",
              (int )(*outsize - (size_t )detect_tree_size));
    }
  }
  ZopfliLengthsToSymbols((unsigned int const   *)(ll_lengths), (size_t )288, 15U,
                         ll_symbols);
  ZopfliLengthsToSymbols((unsigned int const   *)(d_lengths), (size_t )32, 15U, d_symbols);
  detect_block_size = *outsize;
  AddLZ77Data(lz77, lstart, lend, expected_data_size, (unsigned int const   *)(ll_symbols),
              (unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_symbols),
              (unsigned int const   *)(d_lengths), bp, out___0, outsize);
  AddHuffmanBits(ll_symbols[256], ll_lengths[256], bp, out___0, outsize);
  i = lstart;
  while (i < lend) {
    if ((int )*(lz77->dists + i) == 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = (int )*(lz77->litlens + i);
    }
    uncompressed_size += (size_t )tmp___2;
    i ++;
  }
  compressed_size = *outsize - detect_block_size;
  if (options->verbose) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"compressed block size: %d (%dk) (unc: %d)\n",
            (int )compressed_size, (int )(compressed_size / 1024UL), (int )uncompressed_size);
  }
  return;
}
}
static void AddLZ77BlockAutoType(ZopfliOptions const   *options , int final , ZopfliLZ77Store const   *lz77 ,
                                 size_t lstart , size_t lend , size_t expected_data_size ,
                                 unsigned char *bp , unsigned char **out___0 , size_t *outsize ) 
{ 
  double uncompressedcost ;
  double tmp ;
  double fixedcost ;
  double tmp___0 ;
  double dyncost ;
  double tmp___1 ;
  int expensivefixed ;
  int tmp___2 ;
  ZopfliLZ77Store fixedstore ;
  size_t instart ;
  size_t inend ;
  size_t tmp___3 ;
  ZopfliBlockState s ;

  {
  tmp = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);
  uncompressedcost = tmp;
  tmp___0 = ZopfliCalculateBlockSize(lz77, lstart, lend, 1);
  fixedcost = tmp___0;
  tmp___1 = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);
  dyncost = tmp___1;
  if (lz77->size < 1000UL) {
    tmp___2 = 1;
  } else
  if (fixedcost <= dyncost * 1.1) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  expensivefixed = tmp___2;
  if (lstart == lend) {
    AddBits((unsigned int )final, 1U, bp, out___0, outsize);
    AddBits(1U, 2U, bp, out___0, outsize);
    AddBits(0U, 7U, bp, out___0, outsize);
    return;
  }
  ZopfliInitLZ77Store((unsigned char const   *)lz77->data, & fixedstore);
  if (expensivefixed) {
    instart = *(lz77->pos + lstart);
    tmp___3 = ZopfliLZ77GetByteRange(lz77, lstart, lend);
    inend = instart + tmp___3;
    ZopfliInitBlockState(options, instart, inend, 1, & s);
    ZopfliLZ77OptimalFixed(& s, (unsigned char const   *)lz77->data, instart, inend,
                           & fixedstore);
    fixedcost = ZopfliCalculateBlockSize((ZopfliLZ77Store const   *)(& fixedstore),
                                         (size_t )0, fixedstore.size, 1);
    ZopfliCleanBlockState(& s);
  }
  if (uncompressedcost < fixedcost) {
    if (uncompressedcost < dyncost) {
      AddLZ77Block(options, 0, final, lz77, lstart, lend, expected_data_size, bp,
                   out___0, outsize);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (fixedcost < dyncost) {
    if (expensivefixed) {
      AddLZ77Block(options, 1, final, (ZopfliLZ77Store const   *)(& fixedstore), (size_t )0,
                   fixedstore.size, expected_data_size, bp, out___0, outsize);
    } else {
      AddLZ77Block(options, 1, final, lz77, lstart, lend, expected_data_size, bp,
                   out___0, outsize);
    }
  } else {
    AddLZ77Block(options, 2, final, lz77, lstart, lend, expected_data_size, bp, out___0,
                 outsize);
  }
  ZopfliCleanLZ77Store(& fixedstore);
  return;
}
}
void ZopfliDeflatePart(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in___0 ,
                       size_t instart , size_t inend , unsigned char *bp , unsigned char **out___0 ,
                       size_t *outsize ) 
{ 
  size_t i ;
  size_t *splitpoints_uncompressed ;
  size_t npoints ;
  size_t *splitpoints ;
  double totalcost ;
  ZopfliLZ77Store lz77 ;
  ZopfliLZ77Store store ;
  ZopfliBlockState s ;
  void *tmp ;
  size_t start ;
  size_t tmp___0 ;
  size_t end ;
  size_t tmp___1 ;
  ZopfliBlockState s___0 ;
  ZopfliLZ77Store store___0 ;
  double tmp___2 ;
  size_t *splitpoints2 ;
  size_t npoints2 ;
  double totalcost2 ;
  size_t start___0 ;
  size_t tmp___3 ;
  size_t end___0 ;
  size_t tmp___4 ;
  double tmp___5 ;
  size_t start___1 ;
  size_t tmp___6 ;
  size_t end___1 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  splitpoints_uncompressed = (size_t *)0;
  npoints = (size_t )0;
  splitpoints = (size_t *)0;
  totalcost = (double )0;
  if (btype == 0) {
    AddNonCompressedBlock(options, final, in___0, instart, inend, bp, out___0, outsize);
    return;
  } else
  if (btype == 1) {
    ZopfliInitLZ77Store(in___0, & store);
    ZopfliInitBlockState(options, instart, inend, 1, & s);
    ZopfliLZ77OptimalFixed(& s, in___0, instart, inend, & store);
    AddLZ77Block(options, btype, final, (ZopfliLZ77Store const   *)(& store), (size_t )0,
                 store.size, (size_t )0, bp, out___0, outsize);
    ZopfliCleanBlockState(& s);
    ZopfliCleanLZ77Store(& store);
    return;
  }
  if (options->blocksplitting) {
    ZopfliBlockSplit(options, in___0, instart, inend, (size_t )options->blocksplittingmax,
                     & splitpoints_uncompressed, & npoints);
    tmp = malloc(sizeof(*splitpoints) * npoints);
    splitpoints = (size_t *)tmp;
  }
  ZopfliInitLZ77Store(in___0, & lz77);
  i = (size_t )0;
  while (i <= npoints) {
    if (i == 0UL) {
      tmp___0 = instart;
    } else {
      tmp___0 = *(splitpoints_uncompressed + (i - 1UL));
    }
    start = tmp___0;
    if (i == npoints) {
      tmp___1 = inend;
    } else {
      tmp___1 = *(splitpoints_uncompressed + i);
    }
    end = tmp___1;
    ZopfliInitLZ77Store(in___0, & store___0);
    ZopfliInitBlockState(options, start, end, 1, & s___0);
    ZopfliLZ77Optimal(& s___0, in___0, start, end, (int )options->numiterations, & store___0);
    tmp___2 = ZopfliCalculateBlockSizeAutoType((ZopfliLZ77Store const   *)(& store___0),
                                               (size_t )0, store___0.size);
    totalcost += tmp___2;
    ZopfliAppendLZ77Store((ZopfliLZ77Store const   *)(& store___0), & lz77);
    if (i < npoints) {
      *(splitpoints + i) = lz77.size;
    }
    ZopfliCleanBlockState(& s___0);
    ZopfliCleanLZ77Store(& store___0);
    i ++;
  }
  if (options->blocksplitting) {
    if (npoints > 1UL) {
      splitpoints2 = (size_t *)0;
      npoints2 = (size_t )0;
      totalcost2 = (double )0;
      ZopfliBlockSplitLZ77(options, (ZopfliLZ77Store const   *)(& lz77), (size_t )options->blocksplittingmax,
                           & splitpoints2, & npoints2);
      i = (size_t )0;
      while (i <= npoints2) {
        if (i == 0UL) {
          tmp___3 = (size_t )0;
        } else {
          tmp___3 = *(splitpoints2 + (i - 1UL));
        }
        start___0 = tmp___3;
        if (i == npoints2) {
          tmp___4 = lz77.size;
        } else {
          tmp___4 = *(splitpoints2 + i);
        }
        end___0 = tmp___4;
        tmp___5 = ZopfliCalculateBlockSizeAutoType((ZopfliLZ77Store const   *)(& lz77),
                                                   start___0, end___0);
        totalcost2 += tmp___5;
        i ++;
      }
      if (totalcost2 < totalcost) {
        free((void *)splitpoints);
        splitpoints = splitpoints2;
        npoints = npoints2;
      } else {
        free((void *)splitpoints2);
      }
    }
  }
  i = (size_t )0;
  while (i <= npoints) {
    if (i == 0UL) {
      tmp___6 = (size_t )0;
    } else {
      tmp___6 = *(splitpoints + (i - 1UL));
    }
    start___1 = tmp___6;
    if (i == npoints) {
      tmp___7 = lz77.size;
    } else {
      tmp___7 = *(splitpoints + i);
    }
    end___1 = tmp___7;
    if (i == npoints) {
      if (final) {
        tmp___8 = 1;
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
    AddLZ77BlockAutoType(options, tmp___8, (ZopfliLZ77Store const   *)(& lz77), start___1,
                         end___1, (size_t )0, bp, out___0, outsize);
    i ++;
  }
  ZopfliCleanLZ77Store(& lz77);
  free((void *)splitpoints);
  free((void *)splitpoints_uncompressed);
  return;
}
}
void ZopfliDeflate(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in___0 ,
                   size_t insize , unsigned char *bp , unsigned char **out___0 , size_t *outsize ) 
{ 
  size_t offset ;
  size_t i ;
  int masterfinal ;
  int final2 ;
  int tmp ;
  size_t size ;
  size_t tmp___0 ;

  {
  offset = *outsize;
  i = (size_t )0;
  while (1) {
    masterfinal = i + 1000000UL >= insize;
    if (final) {
      if (masterfinal) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    final2 = tmp;
    if (masterfinal) {
      tmp___0 = insize - i;
    } else {
      tmp___0 = (size_t )1000000;
    }
    size = tmp___0;
    ZopfliDeflatePart(options, btype, final2, in___0, i, i + size, bp, out___0, outsize);
    i += size;
    if (! (i < insize)) {
      break;
    }
  }
  if (options->verbose) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Original Size: %lu, Deflate: %lu, Compression: %f%% Removed\n",
            insize, *outsize - offset, (100.0 * (double )(insize - (*outsize - offset))) / (double )insize);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-SmB2QYGS.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliAllocHash(size_t window_size , ZopfliHash *h ) ;
void ZopfliCleanHash(ZopfliHash *h ) ;
void ZopfliLZ77Greedy(ZopfliBlockState *s , unsigned char const   *in___0 , size_t instart ,
                      size_t inend , ZopfliLZ77Store *store , ZopfliHash *h ) ;
void ZopfliBlockSplitSimple(unsigned char const   *in___0 , size_t instart , size_t inend ,
                            size_t blocksize , size_t **splitpoints , size_t *npoints ) ;
static size_t FindMinimum(FindMinimumFun *f , void *context , size_t start , size_t end ,
                          double *smallest ) 
{ 
  double best ;
  size_t result ;
  size_t i ;
  double v ;
  double tmp ;
  size_t i___0 ;
  size_t p[9] ;
  double vp[9] ;
  size_t besti ;
  double best___0 ;
  double lastbest ;
  size_t pos ;

  {
  if (end - start < 1024UL) {
    best = 1e30;
    result = start;
    i = start;
    while (i < end) {
      tmp = (*f)(i, context);
      v = tmp;
      if (v < best) {
        best = v;
        result = i;
      }
      i ++;
    }
    *smallest = best;
    return (result);
  } else {
    lastbest = 1e30;
    pos = start;
    while (! (end - start <= 9UL)) {
      i___0 = (size_t )0;
      while (i___0 < 9UL) {
        p[i___0] = start + (i___0 + 1UL) * ((end - start) / 10UL);
        vp[i___0] = (*f)(p[i___0], context);
        i___0 ++;
      }
      besti = (size_t )0;
      best___0 = vp[0];
      i___0 = (size_t )1;
      while (i___0 < 9UL) {
        if (vp[i___0] < best___0) {
          best___0 = vp[i___0];
          besti = i___0;
        }
        i___0 ++;
      }
      if (best___0 > lastbest) {
        break;
      }
      if (besti == 0UL) {
        start = start;
      } else {
        start = p[besti - 1UL];
      }
      if (besti == 8UL) {
        end = end;
      } else {
        end = p[besti + 1UL];
      }
      pos = p[besti];
      lastbest = best___0;
    }
    *smallest = lastbest;
    return (pos);
  }
}
}
static double EstimateCost(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ) 
{ 
  double tmp ;

  {
  tmp = ZopfliCalculateBlockSizeAutoType(lz77, lstart, lend);
  return (tmp);
}
}
static double SplitCost(size_t i , void *context ) 
{ 
  SplitCostContext *c ;
  double tmp ;
  double tmp___0 ;

  {
  c = (SplitCostContext *)context;
  tmp = EstimateCost(c->lz77, c->start, i);
  tmp___0 = EstimateCost(c->lz77, i, c->end);
  return (tmp + tmp___0);
}
}
static void AddSorted(size_t value , size_t **out___0 , size_t *outsize ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  size_t j ;

  {
  if (! (*outsize & (*outsize - 1UL))) {
    if (*outsize == 0UL) {
      tmp = malloc(sizeof(*(*out___0)));
      *out___0 = (size_t *)tmp;
    } else {
      tmp___0 = realloc((void *)*out___0, (*outsize * 2UL) * sizeof(*(*out___0)));
      *out___0 = (size_t *)tmp___0;
    }
  }
  *(*out___0 + *outsize) = value;
  (*outsize) ++;
  i = (size_t )0;
  while (i + 1UL < *outsize) {
    if (*(*out___0 + i) > value) {
      j = *outsize - 1UL;
      while (j > i) {
        *(*out___0 + j) = *(*out___0 + (j - 1UL));
        j --;
      }
      *(*out___0 + i) = value;
      break;
    }
    i ++;
  }
  return;
}
}
static void PrintBlockSplitPoints(ZopfliLZ77Store const   *lz77 , size_t const   *lz77splitpoints ,
                                  size_t nlz77points ) 
{ 
  size_t *splitpoints ;
  size_t npoints ;
  size_t i ;
  size_t pos ;
  size_t length ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  splitpoints = (size_t *)0;
  npoints = (size_t )0;
  pos = (size_t )0;
  if (nlz77points > 0UL) {
    i = (size_t )0;
    while (i < (size_t )lz77->size) {
      if ((int )*(lz77->dists + i) == 0) {
        tmp = 1;
      } else {
        tmp = (int )*(lz77->litlens + i);
      }
      length = (size_t )tmp;
      if (*(lz77splitpoints + npoints) == (size_t const   )i) {
        if (! (npoints & (npoints - 1UL))) {
          if (npoints == 0UL) {
            tmp___0 = malloc(sizeof(*splitpoints));
            splitpoints = (size_t *)tmp___0;
          } else {
            tmp___1 = realloc((void *)splitpoints, (npoints * 2UL) * sizeof(*splitpoints));
            splitpoints = (size_t *)tmp___1;
          }
        }
        *(splitpoints + npoints) = pos;
        npoints ++;
        if (npoints == nlz77points) {
          break;
        }
      }
      pos += length;
      i ++;
    }
  }
  if (! (npoints == nlz77points)) {
    __assert_fail("npoints == nlz77points", "zopfli/src/zopfli/blocksplitter.c", 167U,
                  "PrintBlockSplitPoints");
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"block split points: ");
  i = (size_t )0;
  while (i < npoints) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d ", (int )*(splitpoints + i));
    i ++;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(hex:");
  i = (size_t )0;
  while (i < npoints) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %x", (int )*(splitpoints + i));
    i ++;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )")\n");
  free((void *)splitpoints);
  return;
}
}
static int FindLargestSplittableBlock(size_t lz77size , unsigned char const   *done ,
                                      size_t const   *splitpoints , size_t npoints ,
                                      size_t *lstart , size_t *lend ) 
{ 
  size_t longest ;
  int found ;
  size_t i ;
  size_t start ;
  size_t tmp ;
  size_t end ;
  size_t tmp___0 ;

  {
  longest = (size_t )0;
  found = 0;
  i = (size_t )0;
  while (i <= npoints) {
    if (i == 0UL) {
      tmp = (size_t const   )0;
    } else {
      tmp = *(splitpoints + (i - 1UL));
    }
    start = (size_t )tmp;
    if (i == npoints) {
      tmp___0 = lz77size - 1UL;
    } else {
      tmp___0 = (size_t )*(splitpoints + i);
    }
    end = tmp___0;
    if (! *(done + start)) {
      if (end - start > longest) {
        *lstart = start;
        *lend = end;
        found = 1;
        longest = end - start;
      }
    }
    i ++;
  }
  return (found);
}
}
void ZopfliBlockSplitLZ77(ZopfliOptions const   *options , ZopfliLZ77Store const   *lz77 ,
                          size_t maxblocks , size_t **splitpoints , size_t *npoints ) 
{ 
  size_t lstart ;
  size_t lend ;
  size_t i ;
  size_t llpos ;
  size_t numblocks ;
  unsigned char *done ;
  double splitcost ;
  double origcost ;
  void *tmp ;
  SplitCostContext c ;
  int tmp___3 ;

  {
  llpos = (size_t )0;
  numblocks = (size_t )1;
  if (lz77->size < 10UL) {
    return;
  }
  tmp = malloc((size_t )lz77->size);
  done = (unsigned char *)tmp;
  if (! done) {
    exit(-1);
  }
  i = (size_t )0;
  while (i < (size_t )lz77->size) {
    *(done + i) = (unsigned char)0;
    i ++;
  }
  lstart = (size_t )0;
  lend = (size_t )lz77->size;
  while (1) {
    if (maxblocks > 0UL) {
      if (numblocks >= maxblocks) {
        break;
      }
    }
    c.lz77 = lz77;
    c.start = lstart;
    c.end = lend;
    if (! (lstart < lend)) {
      __assert_fail("lstart < lend", "zopfli/src/zopfli/blocksplitter.c", 243U, "ZopfliBlockSplitLZ77");
    }
    llpos = FindMinimum(& SplitCost, (void *)(& c), lstart + 1UL, lend, & splitcost);
    if (! (llpos > lstart)) {
      __assert_fail("llpos > lstart", "zopfli/src/zopfli/blocksplitter.c", 246U, "ZopfliBlockSplitLZ77");
    }
    if (! (llpos < lend)) {
      __assert_fail("llpos < lend", "zopfli/src/zopfli/blocksplitter.c", 247U, "ZopfliBlockSplitLZ77");
    }
    origcost = EstimateCost(lz77, lstart, lend);
    if (splitcost > origcost) {
      *(done + lstart) = (unsigned char)1;
    } else
    if (llpos == lstart + 1UL) {
      *(done + lstart) = (unsigned char)1;
    } else
    if (llpos == lend) {
      *(done + lstart) = (unsigned char)1;
    } else {
      AddSorted(llpos, splitpoints, npoints);
      numblocks ++;
    }
    tmp___3 = FindLargestSplittableBlock((size_t )lz77->size, (unsigned char const   *)done,
                                         (size_t const   *)*splitpoints, *npoints,
                                         & lstart, & lend);
    if (! tmp___3) {
      break;
    }
    if (lend - lstart < 10UL) {
      break;
    }
  }
  if (options->verbose) {
    PrintBlockSplitPoints(lz77, (size_t const   *)*splitpoints, *npoints);
  }
  free((void *)done);
  return;
}
}
void ZopfliBlockSplit(ZopfliOptions const   *options , unsigned char const   *in___0 ,
                      size_t instart , size_t inend , size_t maxblocks , size_t **splitpoints ,
                      size_t *npoints ) 
{ 
  size_t pos ;
  size_t i ;
  ZopfliBlockState s ;
  size_t *lz77splitpoints ;
  size_t nlz77points ;
  ZopfliLZ77Store store ;
  ZopfliHash hash ;
  ZopfliHash *h ;
  size_t length ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  pos = (size_t )0;
  lz77splitpoints = (size_t *)0;
  nlz77points = (size_t )0;
  h = & hash;
  ZopfliInitLZ77Store(in___0, & store);
  ZopfliInitBlockState(options, instart, inend, 0, & s);
  ZopfliAllocHash((size_t )32768, h);
  *npoints = (size_t )0;
  *splitpoints = (size_t *)0;
  ZopfliLZ77Greedy(& s, in___0, instart, inend, & store, h);
  ZopfliBlockSplitLZ77(options, (ZopfliLZ77Store const   *)(& store), maxblocks, & lz77splitpoints,
                       & nlz77points);
  pos = instart;
  if (nlz77points > 0UL) {
    i = (size_t )0;
    while (i < store.size) {
      if ((int )*(store.dists + i) == 0) {
        tmp = 1;
      } else {
        tmp = (int )*(store.litlens + i);
      }
      length = (size_t )tmp;
      if (*(lz77splitpoints + *npoints) == i) {
        if (! (*npoints & (*npoints - 1UL))) {
          if (*npoints == 0UL) {
            tmp___0 = malloc(sizeof(*(*splitpoints)));
            *splitpoints = (size_t *)tmp___0;
          } else {
            tmp___1 = realloc((void *)*splitpoints, (*npoints * 2UL) * sizeof(*(*splitpoints)));
            *splitpoints = (size_t *)tmp___1;
          }
        }
        *(*splitpoints + *npoints) = pos;
        (*npoints) ++;
        if (*npoints == nlz77points) {
          break;
        }
      }
      pos += length;
      i ++;
    }
  }
  if (! (*npoints == nlz77points)) {
    __assert_fail("*npoints == nlz77points", "zopfli/src/zopfli/blocksplitter.c",
                  314U, "ZopfliBlockSplit");
  }
  free((void *)lz77splitpoints);
  ZopfliCleanBlockState(& s);
  ZopfliCleanLZ77Store(& store);
  ZopfliCleanHash(h);
  return;
}
}
void ZopfliBlockSplitSimple(unsigned char const   *in___0 , size_t instart , size_t inend ,
                            size_t blocksize , size_t **splitpoints , size_t *npoints ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
  i = instart;
  while (i < inend) {
    if (! (*npoints & (*npoints - 1UL))) {
      if (*npoints == 0UL) {
        tmp = malloc(sizeof(*(*splitpoints)));
        *splitpoints = (size_t *)tmp;
      } else {
        tmp___0 = realloc((void *)*splitpoints, (*npoints * 2UL) * sizeof(*(*splitpoints)));
        *splitpoints = (size_t *)tmp___0;
      }
    }
    *(*splitpoints + *npoints) = i;
    (*npoints) ++;
    i += blocksize;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-CEAAs2vJ.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliCalculateEntropy(size_t const   *count , size_t n , double *bitlengths ) ;
extern  __attribute__((__nothrow__)) double log(double __x ) ;
int ZopfliLengthLimitedCodeLengths(size_t const   *frequencies , int n , int maxbits ,
                                   unsigned int *bitlengths ) ;
void ZopfliLengthsToSymbols(unsigned int const   *lengths , size_t n , unsigned int maxbits ,
                            unsigned int *symbols ) 
{ 
  size_t *bl_count ;
  void *tmp ;
  size_t *next_code ;
  void *tmp___0 ;
  unsigned int bits ;
  unsigned int i ;
  unsigned int code ;
  unsigned int len ;

  {
  tmp = malloc(sizeof(size_t ) * (unsigned long )(maxbits + 1U));
  bl_count = (size_t *)tmp;
  tmp___0 = malloc(sizeof(size_t ) * (unsigned long )(maxbits + 1U));
  next_code = (size_t *)tmp___0;
  i = 0U;
  while ((size_t )i < n) {
    *(symbols + i) = 0U;
    i ++;
  }
  bits = 0U;
  while (bits <= maxbits) {
    *(bl_count + bits) = (size_t )0;
    bits ++;
  }
  i = 0U;
  while ((size_t )i < n) {
    if (! (*(lengths + i) <= (unsigned int const   )maxbits)) {
      __assert_fail("lengths[i] <= maxbits", "zopfli/src/zopfli/tree.c", 47U, "ZopfliLengthsToSymbols");
    }
    (*(bl_count + *(lengths + i))) ++;
    i ++;
  }
  code = 0U;
  *(bl_count + 0) = (size_t )0;
  bits = 1U;
  while (bits <= maxbits) {
    code = (unsigned int )(((size_t )code + *(bl_count + (bits - 1U))) << 1);
    *(next_code + bits) = (size_t )code;
    bits ++;
  }
  i = 0U;
  while ((size_t )i < n) {
    len = (unsigned int )*(lengths + i);
    if (len != 0U) {
      *(symbols + i) = (unsigned int )*(next_code + len);
      (*(next_code + len)) ++;
    }
    i ++;
  }
  free((void *)bl_count);
  free((void *)next_code);
  return;
}
}
static double const   kInvLog2  =    (double const   )1.4426950408889;
void ZopfliCalculateEntropy(size_t const   *count , size_t n , double *bitlengths ) 
{ 
  unsigned int sum ;
  unsigned int i ;
  double log2sum ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  sum = 0U;
  i = 0U;
  while ((size_t )i < n) {
    sum = (unsigned int )((size_t const   )sum + *(count + i));
    i ++;
  }
  if (sum == 0U) {
    tmp = log((double )n);
    tmp___1 = tmp;
  } else {
    tmp___0 = log((double )sum);
    tmp___1 = tmp___0;
  }
  log2sum = tmp___1 * (double )kInvLog2;
  i = 0U;
  while ((size_t )i < n) {
    if (*(count + i) == 0UL) {
      *(bitlengths + i) = log2sum;
    } else {
      tmp___2 = log((double )*(count + i));
      *(bitlengths + i) = log2sum - tmp___2 * (double )kInvLog2;
    }
    if (*(bitlengths + i) < (double )0) {
      if (*(bitlengths + i) > - 1e-5) {
        *(bitlengths + i) = (double )0;
      }
    }
    if (! (*(bitlengths + i) >= (double )0)) {
      __assert_fail("bitlengths[i] >= 0", "zopfli/src/zopfli/tree.c", 92U, "ZopfliCalculateEntropy");
    }
    i ++;
  }
  return;
}
}
void ZopfliCalculateBitLengths(size_t const   *count , size_t n , int maxbits , unsigned int *bitlengths ) 
{ 
  int error ;
  int tmp ;

  {
  tmp = ZopfliLengthLimitedCodeLengths(count, (int )n, maxbits, bitlengths);
  error = tmp;
  if (! (! error)) {
    __assert_fail("!error", "zopfli/src/zopfli/tree.c", 100U, "ZopfliCalculateBitLengths");
  }
  return;
}
}
#pragma merger("0","/tmp/cil-O19QOUCN.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliInitCache(size_t blocksize , ZopfliLongestMatchCache *lmc ) ;
void ZopfliCleanCache(ZopfliLongestMatchCache *lmc ) ;
void ZopfliSublenToCache(unsigned short const   *sublen , size_t pos , size_t length ,
                         ZopfliLongestMatchCache *lmc ) ;
void ZopfliCacheToSublen(ZopfliLongestMatchCache const   *lmc , size_t pos , size_t length ,
                         unsigned short *sublen ) ;
unsigned int ZopfliMaxCachedSublen(ZopfliLongestMatchCache const   *lmc , size_t pos ,
                                   size_t length ) ;
void ZopfliResetHash(size_t window_size , ZopfliHash *h ) ;
void ZopfliUpdateHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) ;
void ZopfliWarmupHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) ;
void ZopfliCopyLZ77Store(ZopfliLZ77Store const   *source , ZopfliLZ77Store *dest ) ;
void ZopfliStoreLitLenDist(unsigned short length , unsigned short dist , size_t pos ,
                           ZopfliLZ77Store *store ) ;
void ZopfliFindLongestMatch(ZopfliBlockState *s , ZopfliHash const   *h , unsigned char const   *array ,
                            size_t pos , size_t size , size_t limit , unsigned short *sublen ,
                            unsigned short *distance , unsigned short *length ) ;
void ZopfliVerifyLenDist(unsigned char const   *data , size_t datasize , size_t pos ,
                         unsigned short dist , unsigned short length ) ;
void ZopfliInitLZ77Store(unsigned char const   *data , ZopfliLZ77Store *store ) 
{ 


  {
  store->size = (size_t )0;
  store->litlens = (unsigned short *)0;
  store->dists = (unsigned short *)0;
  store->pos = (size_t *)0;
  store->data = data;
  store->ll_symbol = (unsigned short *)0;
  store->d_symbol = (unsigned short *)0;
  store->ll_counts = (size_t *)0;
  store->d_counts = (size_t *)0;
  return;
}
}
void ZopfliCleanLZ77Store(ZopfliLZ77Store *store ) 
{ 


  {
  free((void *)store->litlens);
  free((void *)store->dists);
  free((void *)store->pos);
  free((void *)store->ll_symbol);
  free((void *)store->d_symbol);
  free((void *)store->ll_counts);
  free((void *)store->d_counts);
  return;
}
}
static size_t CeilDiv(size_t a , size_t b ) 
{ 


  {
  return (((a + b) - 1UL) / b);
}
}
void ZopfliCopyLZ77Store(ZopfliLZ77Store const   *source , ZopfliLZ77Store *dest ) 
{ 
  size_t i ;
  size_t llsize ;
  size_t tmp ;
  size_t dsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  tmp = CeilDiv((size_t )source->size, (size_t )288);
  llsize = 288UL * tmp;
  tmp___0 = CeilDiv((size_t )source->size, (size_t )32);
  dsize = 32UL * tmp___0;
  ZopfliCleanLZ77Store(dest);
  ZopfliInitLZ77Store((unsigned char const   *)source->data, dest);
  tmp___1 = malloc(sizeof(*(dest->litlens)) * (unsigned long )source->size);
  dest->litlens = (unsigned short *)tmp___1;
  tmp___2 = malloc(sizeof(*(dest->dists)) * (unsigned long )source->size);
  dest->dists = (unsigned short *)tmp___2;
  tmp___3 = malloc(sizeof(*(dest->pos)) * (unsigned long )source->size);
  dest->pos = (size_t *)tmp___3;
  tmp___4 = malloc(sizeof(*(dest->ll_symbol)) * (unsigned long )source->size);
  dest->ll_symbol = (unsigned short *)tmp___4;
  tmp___5 = malloc(sizeof(*(dest->d_symbol)) * (unsigned long )source->size);
  dest->d_symbol = (unsigned short *)tmp___5;
  tmp___6 = malloc(sizeof(*(dest->ll_counts)) * llsize);
  dest->ll_counts = (size_t *)tmp___6;
  tmp___7 = malloc(sizeof(*(dest->d_counts)) * dsize);
  dest->d_counts = (size_t *)tmp___7;
  if (! dest->litlens) {
    exit(-1);
  } else
  if (! dest->dists) {
    exit(-1);
  }
  if (! dest->pos) {
    exit(-1);
  }
  if (! dest->ll_symbol) {
    exit(-1);
  } else
  if (! dest->d_symbol) {
    exit(-1);
  }
  if (! dest->ll_counts) {
    exit(-1);
  } else
  if (! dest->d_counts) {
    exit(-1);
  }
  dest->size = (size_t )source->size;
  i = (size_t )0;
  while (i < (size_t )source->size) {
    *(dest->litlens + i) = *(source->litlens + i);
    *(dest->dists + i) = *(source->dists + i);
    *(dest->pos + i) = *(source->pos + i);
    *(dest->ll_symbol + i) = *(source->ll_symbol + i);
    *(dest->d_symbol + i) = *(source->d_symbol + i);
    i ++;
  }
  i = (size_t )0;
  while (i < llsize) {
    *(dest->ll_counts + i) = *(source->ll_counts + i);
    i ++;
  }
  i = (size_t )0;
  while (i < dsize) {
    *(dest->d_counts + i) = *(source->d_counts + i);
    i ++;
  }
  return;
}
}
void ZopfliStoreLitLenDist(unsigned short length , unsigned short dist , size_t pos ,
                           ZopfliLZ77Store *store ) 
{ 
  size_t i ;
  size_t origsize ;
  size_t llstart ;
  size_t dstart ;
  size_t llsize ;
  void *tmp ;
  void *tmp___0 ;
  size_t dsize ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  origsize = store->size;
  llstart = 288UL * (origsize / 288UL);
  dstart = 32UL * (origsize / 32UL);
  if (origsize % 288UL == 0UL) {
    llsize = origsize;
    i = (size_t )0;
    while (i < 288UL) {
      if (! (llsize & (llsize - 1UL))) {
        if (llsize == 0UL) {
          tmp = malloc(sizeof(*(store->ll_counts)));
          store->ll_counts = (size_t *)tmp;
        } else {
          tmp___0 = realloc((void *)store->ll_counts, (llsize * 2UL) * sizeof(*(store->ll_counts)));
          store->ll_counts = (size_t *)tmp___0;
        }
      }
      if (origsize == 0UL) {
        *(store->ll_counts + llsize) = (size_t )0;
      } else {
        *(store->ll_counts + llsize) = *(store->ll_counts + ((origsize - 288UL) + i));
      }
      llsize ++;
      i ++;
    }
  }
  if (origsize % 32UL == 0UL) {
    dsize = origsize;
    i = (size_t )0;
    while (i < 32UL) {
      if (! (dsize & (dsize - 1UL))) {
        if (dsize == 0UL) {
          tmp___1 = malloc(sizeof(*(store->d_counts)));
          store->d_counts = (size_t *)tmp___1;
        } else {
          tmp___2 = realloc((void *)store->d_counts, (dsize * 2UL) * sizeof(*(store->d_counts)));
          store->d_counts = (size_t *)tmp___2;
        }
      }
      if (origsize == 0UL) {
        *(store->d_counts + dsize) = (size_t )0;
      } else {
        *(store->d_counts + dsize) = *(store->d_counts + ((origsize - 32UL) + i));
      }
      dsize ++;
      i ++;
    }
  }
  if (! (store->size & (store->size - 1UL))) {
    if (store->size == 0UL) {
      tmp___3 = malloc(sizeof(*(store->litlens)));
      store->litlens = (unsigned short *)tmp___3;
    } else {
      tmp___4 = realloc((void *)store->litlens, (store->size * 2UL) * sizeof(*(store->litlens)));
      store->litlens = (unsigned short *)tmp___4;
    }
  }
  *(store->litlens + store->size) = length;
  (store->size) ++;
  store->size = origsize;
  if (! (store->size & (store->size - 1UL))) {
    if (store->size == 0UL) {
      tmp___5 = malloc(sizeof(*(store->dists)));
      store->dists = (unsigned short *)tmp___5;
    } else {
      tmp___6 = realloc((void *)store->dists, (store->size * 2UL) * sizeof(*(store->dists)));
      store->dists = (unsigned short *)tmp___6;
    }
  }
  *(store->dists + store->size) = dist;
  (store->size) ++;
  store->size = origsize;
  if (! (store->size & (store->size - 1UL))) {
    if (store->size == 0UL) {
      tmp___7 = malloc(sizeof(*(store->pos)));
      store->pos = (size_t *)tmp___7;
    } else {
      tmp___8 = realloc((void *)store->pos, (store->size * 2UL) * sizeof(*(store->pos)));
      store->pos = (size_t *)tmp___8;
    }
  }
  *(store->pos + store->size) = pos;
  (store->size) ++;
  if (! ((int )length < 259)) {
    __assert_fail("length < 259", "zopfli/src/zopfli/lz77.c", 131U, "ZopfliStoreLitLenDist");
  }
  if ((int )dist == 0) {
    store->size = origsize;
    if (! (store->size & (store->size - 1UL))) {
      if (store->size == 0UL) {
        tmp___10 = malloc(sizeof(*(store->ll_symbol)));
        store->ll_symbol = (unsigned short *)tmp___10;
      } else {
        tmp___11 = realloc((void *)store->ll_symbol, (store->size * 2UL) * sizeof(*(store->ll_symbol)));
        store->ll_symbol = (unsigned short *)tmp___11;
      }
    }
    *(store->ll_symbol + store->size) = length;
    (store->size) ++;
    store->size = origsize;
    if (! (store->size & (store->size - 1UL))) {
      if (store->size == 0UL) {
        tmp___12 = malloc(sizeof(*(store->d_symbol)));
        store->d_symbol = (unsigned short *)tmp___12;
      } else {
        tmp___13 = realloc((void *)store->d_symbol, (store->size * 2UL) * sizeof(*(store->d_symbol)));
        store->d_symbol = (unsigned short *)tmp___13;
      }
    }
    *(store->d_symbol + store->size) = (unsigned short)0;
    (store->size) ++;
    (*(store->ll_counts + (llstart + (size_t )length))) ++;
  } else {
    store->size = origsize;
    if (! (store->size & (store->size - 1UL))) {
      if (store->size == 0UL) {
        tmp___14 = malloc(sizeof(*(store->ll_symbol)));
        store->ll_symbol = (unsigned short *)tmp___14;
      } else {
        tmp___15 = realloc((void *)store->ll_symbol, (store->size * 2UL) * sizeof(*(store->ll_symbol)));
        store->ll_symbol = (unsigned short *)tmp___15;
      }
    }
    tmp___16 = ZopfliGetLengthSymbol((int )length);
    *(store->ll_symbol + store->size) = (unsigned short )tmp___16;
    (store->size) ++;
    store->size = origsize;
    if (! (store->size & (store->size - 1UL))) {
      if (store->size == 0UL) {
        tmp___17 = malloc(sizeof(*(store->d_symbol)));
        store->d_symbol = (unsigned short *)tmp___17;
      } else {
        tmp___18 = realloc((void *)store->d_symbol, (store->size * 2UL) * sizeof(*(store->d_symbol)));
        store->d_symbol = (unsigned short *)tmp___18;
      }
    }
    tmp___19 = ZopfliGetDistSymbol((int )dist);
    *(store->d_symbol + store->size) = (unsigned short )tmp___19;
    (store->size) ++;
    tmp___20 = ZopfliGetLengthSymbol((int )length);
    (*(store->ll_counts + (llstart + (size_t )tmp___20))) ++;
    tmp___21 = ZopfliGetDistSymbol((int )dist);
    (*(store->d_counts + (dstart + (size_t )tmp___21))) ++;
  }
  return;
}
}
void ZopfliAppendLZ77Store(ZopfliLZ77Store const   *store , ZopfliLZ77Store *target ) 
{ 
  size_t i ;

  {
  i = (size_t )0;
  while (i < (size_t )store->size) {
    ZopfliStoreLitLenDist(*(store->litlens + i), *(store->dists + i), *(store->pos + i),
                          target);
    i ++;
  }
  return;
}
}
size_t ZopfliLZ77GetByteRange(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ) 
{ 
  size_t l ;
  int tmp ;

  {
  l = lend - 1UL;
  if (lstart == lend) {
    return ((size_t )0);
  }
  if ((int )*(lz77->dists + l) == 0) {
    tmp = 1;
  } else {
    tmp = (int )*(lz77->litlens + l);
  }
  return ((*(lz77->pos + l) + (size_t )tmp) - *(lz77->pos + lstart));
}
}
static void ZopfliLZ77GetHistogramAt(ZopfliLZ77Store const   *lz77 , size_t lpos ,
                                     size_t *ll_counts , size_t *d_counts ) 
{ 
  size_t llpos ;
  size_t dpos ;
  size_t i ;

  {
  llpos = 288UL * (lpos / 288UL);
  dpos = 32UL * (lpos / 32UL);
  i = (size_t )0;
  while (i < 288UL) {
    *(ll_counts + i) = *(lz77->ll_counts + (llpos + i));
    i ++;
  }
  i = lpos + 1UL;
  while (1) {
    if (i < llpos + 288UL) {
      if (! (i < (size_t )lz77->size)) {
        break;
      }
    } else {
      break;
    }
    (*(ll_counts + *(lz77->ll_symbol + i))) --;
    i ++;
  }
  i = (size_t )0;
  while (i < 32UL) {
    *(d_counts + i) = *(lz77->d_counts + (dpos + i));
    i ++;
  }
  i = lpos + 1UL;
  while (1) {
    if (i < dpos + 32UL) {
      if (! (i < (size_t )lz77->size)) {
        break;
      }
    } else {
      break;
    }
    if ((int )*(lz77->dists + i) != 0) {
      (*(d_counts + *(lz77->d_symbol + i))) --;
    }
    i ++;
  }
  return;
}
}
void ZopfliLZ77GetHistogram(ZopfliLZ77Store const   *lz77 , size_t lstart , size_t lend ,
                            size_t *ll_counts , size_t *d_counts ) 
{ 
  size_t i ;
  size_t ll_counts2[288] ;
  size_t d_counts2[32] ;

  {
  if (lstart + 864UL > lend) {
    memset((void *)ll_counts, 0, sizeof(*ll_counts) * 288UL);
    memset((void *)d_counts, 0, sizeof(*d_counts) * 32UL);
    i = lstart;
    while (i < lend) {
      (*(ll_counts + *(lz77->ll_symbol + i))) ++;
      if ((int )*(lz77->dists + i) != 0) {
        (*(d_counts + *(lz77->d_symbol + i))) ++;
      }
      i ++;
    }
  } else {
    ZopfliLZ77GetHistogramAt(lz77, lend - 1UL, ll_counts, d_counts);
    if (lstart > 0UL) {
      ZopfliLZ77GetHistogramAt(lz77, lstart - 1UL, ll_counts2, d_counts2);
      i = (size_t )0;
      while (i < 288UL) {
        *(ll_counts + i) -= ll_counts2[i];
        i ++;
      }
      i = (size_t )0;
      while (i < 32UL) {
        *(d_counts + i) -= d_counts2[i];
        i ++;
      }
    }
  }
  return;
}
}
void ZopfliInitBlockState(ZopfliOptions const   *options , size_t blockstart , size_t blockend ,
                          int add_lmc , ZopfliBlockState *s ) 
{ 
  void *tmp ;

  {
  s->options = options;
  s->blockstart = blockstart;
  s->blockend = blockend;
  if (add_lmc) {
    tmp = malloc(sizeof(ZopfliLongestMatchCache ));
    s->lmc = (ZopfliLongestMatchCache *)tmp;
    ZopfliInitCache(blockend - blockstart, s->lmc);
  } else {
    s->lmc = (ZopfliLongestMatchCache *)0;
  }
  return;
}
}
void ZopfliCleanBlockState(ZopfliBlockState *s ) 
{ 


  {
  if (s->lmc) {
    ZopfliCleanCache(s->lmc);
    free((void *)s->lmc);
  }
  return;
}
}
static int GetLengthScore(int length , int distance ) 
{ 
  int tmp ;

  {
  if (distance > 1024) {
    tmp = length - 1;
  } else {
    tmp = length;
  }
  return (tmp);
}
}
void ZopfliVerifyLenDist(unsigned char const   *data , size_t datasize , size_t pos ,
                         unsigned short dist , unsigned short length ) 
{ 
  size_t i ;

  {
  if (! (pos + (size_t )length <= datasize)) {
    __assert_fail("pos + length <= datasize", "zopfli/src/zopfli/lz77.c", 279U, "ZopfliVerifyLenDist");
  }
  i = (size_t )0;
  while (i < (size_t )length) {
    if ((int const   )*(data + ((pos - (size_t )dist) + i)) != (int const   )*(data + (pos + i))) {
      if (! ((int const   )*(data + ((pos - (size_t )dist) + i)) == (int const   )*(data + (pos + i)))) {
        __assert_fail("data[pos - dist + i] == data[pos + i]", "zopfli/src/zopfli/lz77.c",
                      282U, "ZopfliVerifyLenDist");
      }
      break;
    }
    i ++;
  }
  return;
}
}
static unsigned char const   *GetMatch(unsigned char const   *scan , unsigned char const   *match ,
                                       unsigned char const   *end , unsigned char const   *safe_end ) 
{ 


  {
  if (sizeof(size_t ) == 8UL) {
    while (1) {
      if ((unsigned long )scan < (unsigned long )safe_end) {
        if (! (*((size_t const   *)scan) == *((size_t const   *)match))) {
          break;
        }
      } else {
        break;
      }
      scan += 8;
      match += 8;
    }
  } else
  if (sizeof(unsigned int ) == 4UL) {
    while (1) {
      if ((unsigned long )scan < (unsigned long )safe_end) {
        if (! (*((unsigned int const   *)scan) == *((unsigned int const   *)match))) {
          break;
        }
      } else {
        break;
      }
      scan += 4;
      match += 4;
    }
  } else {
    while (1) {
      if ((unsigned long )scan < (unsigned long )safe_end) {
        if ((int const   )*scan == (int const   )*match) {
          scan ++;
          match ++;
          if ((int const   )*scan == (int const   )*match) {
            scan ++;
            match ++;
            if ((int const   )*scan == (int const   )*match) {
              scan ++;
              match ++;
              if ((int const   )*scan == (int const   )*match) {
                scan ++;
                match ++;
                if ((int const   )*scan == (int const   )*match) {
                  scan ++;
                  match ++;
                  if ((int const   )*scan == (int const   )*match) {
                    scan ++;
                    match ++;
                    if ((int const   )*scan == (int const   )*match) {
                      scan ++;
                      match ++;
                      if (! ((int const   )*scan == (int const   )*match)) {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      scan ++;
      match ++;
    }
  }
  while (1) {
    if ((unsigned long )scan != (unsigned long )end) {
      if (! ((int const   )*scan == (int const   )*match)) {
        break;
      }
    } else {
      break;
    }
    scan ++;
    match ++;
  }
  return (scan);
}
}
static int TryGetFromLongestMatchCache(ZopfliBlockState *s , size_t pos , size_t *limit ,
                                       unsigned short *sublen , unsigned short *distance ,
                                       unsigned short *length ) 
{ 
  size_t lmcpos ;
  unsigned char cache_available ;
  int tmp ;
  unsigned char limit_ok_for_cache ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___3 ;

  {
  lmcpos = pos - s->blockstart;
  if (s->lmc) {
    if ((int )*((s->lmc)->length + lmcpos) == 0) {
      tmp = 1;
    } else
    if ((int )*((s->lmc)->dist + lmcpos) != 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  cache_available = (unsigned char )tmp;
  if (cache_available) {
    if (*limit == 258UL) {
      tmp___1 = 1;
    } else
    if ((size_t )*((s->lmc)->length + lmcpos) <= *limit) {
      tmp___1 = 1;
    } else
    if (sublen) {
      tmp___0 = ZopfliMaxCachedSublen((ZopfliLongestMatchCache const   *)s->lmc, lmcpos,
                                      (size_t )*((s->lmc)->length + lmcpos));
      if ((size_t )tmp___0 >= *limit) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  limit_ok_for_cache = (unsigned char )tmp___1;
  if (s->lmc) {
    if (limit_ok_for_cache) {
      if (cache_available) {
        if (! sublen) {
          goto _L;
        } else {
          tmp___3 = ZopfliMaxCachedSublen((ZopfliLongestMatchCache const   *)s->lmc,
                                          lmcpos, (size_t )*((s->lmc)->length + lmcpos));
          if ((unsigned int )*((s->lmc)->length + lmcpos) <= tmp___3) {
            _L: /* CIL Label */ 
            *length = *((s->lmc)->length + lmcpos);
            if ((size_t )*length > *limit) {
              *length = (unsigned short )*limit;
            }
            if (sublen) {
              ZopfliCacheToSublen((ZopfliLongestMatchCache const   *)s->lmc, lmcpos,
                                  (size_t )*length, sublen);
              *distance = *(sublen + *length);
              if (*limit == 258UL) {
                if ((int )*length >= 3) {
                  if (! ((int )*(sublen + *length) == (int )*((s->lmc)->dist + lmcpos))) {
                    __assert_fail("sublen[*length] == s->lmc->dist[lmcpos]", "zopfli/src/zopfli/lz77.c",
                                  366U, "TryGetFromLongestMatchCache");
                  }
                }
              }
            } else {
              *distance = *((s->lmc)->dist + lmcpos);
            }
            return (1);
          }
        }
        *limit = (size_t )*((s->lmc)->length + lmcpos);
      }
    }
  }
  return (0);
}
}
static void StoreInLongestMatchCache(ZopfliBlockState *s , size_t pos , size_t limit ,
                                     unsigned short const   *sublen , unsigned short distance ,
                                     unsigned short length ) 
{ 
  size_t lmcpos ;
  unsigned char cache_available ;
  int tmp ;

  {
  lmcpos = pos - s->blockstart;
  if (s->lmc) {
    if ((int )*((s->lmc)->length + lmcpos) == 0) {
      tmp = 1;
    } else
    if ((int )*((s->lmc)->dist + lmcpos) != 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  cache_available = (unsigned char )tmp;
  if (s->lmc) {
    if (limit == 258UL) {
      if (sublen) {
        if (! cache_available) {
          if ((int )*((s->lmc)->length + lmcpos) == 1) {
            if (! ((int )*((s->lmc)->dist + lmcpos) == 0)) {
              __assert_fail("s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0",
                            "zopfli/src/zopfli/lz77.c", 399U, "StoreInLongestMatchCache");
            }
          } else {
            __assert_fail("s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0",
                          "zopfli/src/zopfli/lz77.c", 399U, "StoreInLongestMatchCache");
          }
          if ((int )length < 3) {
            *((s->lmc)->dist + lmcpos) = (unsigned short)0;
          } else {
            *((s->lmc)->dist + lmcpos) = distance;
          }
          if ((int )length < 3) {
            *((s->lmc)->length + lmcpos) = (unsigned short)0;
          } else {
            *((s->lmc)->length + lmcpos) = length;
          }
          if ((int )*((s->lmc)->length + lmcpos) == 1) {
            if ((int )*((s->lmc)->dist + lmcpos) == 0) {
              __assert_fail("!(s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0)",
                            "zopfli/src/zopfli/lz77.c", 402U, "StoreInLongestMatchCache");
            }
          }
          ZopfliSublenToCache(sublen, lmcpos, (size_t )length, s->lmc);
        }
      }
    }
  }
  return;
}
}
void ZopfliFindLongestMatch(ZopfliBlockState *s , ZopfliHash const   *h , unsigned char const   *array ,
                            size_t pos , size_t size , size_t limit , unsigned short *sublen ,
                            unsigned short *distance , unsigned short *length ) 
{ 
  unsigned short hpos ;
  unsigned short p ;
  unsigned short pp ;
  unsigned short bestdist ;
  unsigned short bestlength ;
  unsigned char const   *scan ;
  unsigned char const   *match ;
  unsigned char const   *arrayend ;
  unsigned char const   *arrayend_safe ;
  int chain_counter ;
  unsigned int dist ;
  int *hhead ;
  unsigned short *hprev ;
  int *hhashval ;
  int hval ;
  int tmp___0 ;
  unsigned short currentlength ;
  unsigned short same0 ;
  unsigned short same1 ;
  unsigned short same ;
  int tmp___11 ;
  unsigned short j ;
  int tmp___12 ;

  {
  hpos = (unsigned short )(pos & 32767UL);
  bestdist = (unsigned short)0;
  bestlength = (unsigned short)1;
  chain_counter = 8192;
  dist = 0U;
  hhead = (int *)h->head;
  hprev = (unsigned short *)h->prev;
  hhashval = (int *)h->hashval;
  hval = (int )h->val;
  tmp___0 = TryGetFromLongestMatchCache(s, pos, & limit, sublen, distance, length);
  if (tmp___0) {
    if (! (pos + (size_t )*length <= size)) {
      __assert_fail("pos + *length <= size", "zopfli/src/zopfli/lz77.c", 432U, "ZopfliFindLongestMatch");
    }
    return;
  }
  if (! (limit <= 258UL)) {
    __assert_fail("limit <= ZOPFLI_MAX_MATCH", "zopfli/src/zopfli/lz77.c", 437U, "ZopfliFindLongestMatch");
  }
  if (! (limit >= 3UL)) {
    __assert_fail("limit >= ZOPFLI_MIN_MATCH", "zopfli/src/zopfli/lz77.c", 438U, "ZopfliFindLongestMatch");
  }
  if (! (pos < size)) {
    __assert_fail("pos < size", "zopfli/src/zopfli/lz77.c", 439U, "ZopfliFindLongestMatch");
  }
  if (size - pos < 3UL) {
    *length = (unsigned short)0;
    *distance = (unsigned short)0;
    return;
  }
  if (pos + limit > size) {
    limit = size - pos;
  }
  arrayend = (array + pos) + limit;
  arrayend_safe = arrayend - 8;
  if (! (hval < 65536)) {
    __assert_fail("hval < 65536", "zopfli/src/zopfli/lz77.c", 455U, "ZopfliFindLongestMatch");
  }
  pp = (unsigned short )*(hhead + hval);
  p = *(hprev + pp);
  if (! ((int )pp == (int )hpos)) {
    __assert_fail("pp == hpos", "zopfli/src/zopfli/lz77.c", 460U, "ZopfliFindLongestMatch");
  }
  if ((int )p < (int )pp) {
    dist = (unsigned int )((int )pp - (int )p);
  } else {
    dist = (unsigned int )((32768 - (int )p) + (int )pp);
  }
  while (dist < 32768U) {
    currentlength = (unsigned short)0;
    if (! ((int )p < 32768)) {
      __assert_fail("p < ZOPFLI_WINDOW_SIZE", "zopfli/src/zopfli/lz77.c", 468U, "ZopfliFindLongestMatch");
    }
    if (! ((int )p == (int )*(hprev + pp))) {
      __assert_fail("p == hprev[pp]", "zopfli/src/zopfli/lz77.c", 469U, "ZopfliFindLongestMatch");
    }
    if (! (*(hhashval + p) == hval)) {
      __assert_fail("hhashval[p] == hval", "zopfli/src/zopfli/lz77.c", 470U, "ZopfliFindLongestMatch");
    }
    if (dist > 0U) {
      if (! (pos < size)) {
        __assert_fail("pos < size", "zopfli/src/zopfli/lz77.c", 473U, "ZopfliFindLongestMatch");
      }
      if (! ((size_t )dist <= pos)) {
        __assert_fail("dist <= pos", "zopfli/src/zopfli/lz77.c", 474U, "ZopfliFindLongestMatch");
      }
      scan = array + pos;
      match = array + (pos - (size_t )dist);
      if (pos + (size_t )bestlength >= size) {
        goto _L;
      } else
      if ((int const   )*(scan + (int )bestlength) == (int const   )*(match + (int )bestlength)) {
        _L: /* CIL Label */ 
        same0 = *(h->same + (pos & 32767UL));
        if ((int )same0 > 2) {
          if ((int const   )*scan == (int const   )*match) {
            same1 = *(h->same + ((pos - (size_t )dist) & 32767UL));
            if ((int )same0 < (int )same1) {
              tmp___11 = (int )same0;
            } else {
              tmp___11 = (int )same1;
            }
            same = (unsigned short )tmp___11;
            if ((size_t )same > limit) {
              same = (unsigned short )limit;
            }
            scan += (int )same;
            match += (int )same;
          }
        }
        scan = GetMatch(scan, match, arrayend, arrayend_safe);
        currentlength = (unsigned short )(scan - (array + pos));
      }
      if ((int )currentlength > (int )bestlength) {
        if (sublen) {
          j = (unsigned short )((int )bestlength + 1);
          while ((int )j <= (int )currentlength) {
            *(sublen + j) = (unsigned short )dist;
            j = (unsigned short )((int )j + 1);
          }
        }
        bestdist = (unsigned short )dist;
        bestlength = currentlength;
        if ((size_t )currentlength >= limit) {
          break;
        }
      }
    }
    if ((unsigned long )hhead != (unsigned long )h->head2) {
      if ((int )bestlength >= (int )*(h->same + hpos)) {
        if (h->val2 == (int const   )*(h->hashval2 + p)) {
          hhead = (int *)h->head2;
          hprev = (unsigned short *)h->prev2;
          hhashval = (int *)h->hashval2;
          hval = (int )h->val2;
        }
      }
    }
    pp = p;
    p = *(hprev + p);
    if ((int )p == (int )pp) {
      break;
    }
    if ((int )p < (int )pp) {
      tmp___12 = (int )pp - (int )p;
    } else {
      tmp___12 = (32768 - (int )p) + (int )pp;
    }
    dist += (unsigned int )tmp___12;
    chain_counter --;
    if (chain_counter <= 0) {
      break;
    }
  }
  StoreInLongestMatchCache(s, pos, limit, (unsigned short const   *)sublen, bestdist,
                           bestlength);
  if (! ((size_t )bestlength <= limit)) {
    __assert_fail("bestlength <= limit", "zopfli/src/zopfli/lz77.c", 538U, "ZopfliFindLongestMatch");
  }
  *distance = bestdist;
  *length = bestlength;
  if (! (pos + (size_t )*length <= size)) {
    __assert_fail("pos + *length <= size", "zopfli/src/zopfli/lz77.c", 542U, "ZopfliFindLongestMatch");
  }
  return;
}
}
void ZopfliLZ77Greedy(ZopfliBlockState *s , unsigned char const   *in___0 , size_t instart ,
                      size_t inend , ZopfliLZ77Store *store , ZopfliHash *h ) 
{ 
  size_t i ;
  size_t j ;
  unsigned short leng ;
  unsigned short dist ;
  int lengthscore ;
  size_t windowstart ;
  size_t tmp ;
  unsigned short dummysublen[259] ;
  unsigned int prev_length ;
  unsigned int prev_match ;
  int prevlengthscore ;
  int match_available ;

  {
  i = (size_t )0;
  if (instart > 32768UL) {
    tmp = instart - 32768UL;
  } else {
    tmp = (size_t )0;
  }
  windowstart = tmp;
  prev_length = 0U;
  prev_match = 0U;
  match_available = 0;
  if (instart == inend) {
    return;
  }
  ZopfliResetHash((size_t )32768, h);
  ZopfliWarmupHash(in___0, windowstart, inend, h);
  i = windowstart;
  while (i < instart) {
    ZopfliUpdateHash(in___0, i, inend, h);
    i ++;
  }
  i = instart;
  while (i < inend) {
    ZopfliUpdateHash(in___0, i, inend, h);
    ZopfliFindLongestMatch(s, (ZopfliHash const   *)h, in___0, i, inend, (size_t )258,
                           dummysublen, & dist, & leng);
    lengthscore = GetLengthScore((int )leng, (int )dist);
    prevlengthscore = GetLengthScore((int )prev_length, (int )prev_match);
    if (match_available) {
      match_available = 0;
      if (lengthscore > prevlengthscore + 1) {
        ZopfliStoreLitLenDist((unsigned short )*(in___0 + (i - 1UL)), (unsigned short)0,
                              i - 1UL, store);
        if (lengthscore >= 3) {
          if ((int )leng < 258) {
            match_available = 1;
            prev_length = (unsigned int )leng;
            prev_match = (unsigned int )dist;
            goto __Cont;
          }
        }
      } else {
        leng = (unsigned short )prev_length;
        dist = (unsigned short )prev_match;
        lengthscore = prevlengthscore;
        ZopfliVerifyLenDist(in___0, inend, i - 1UL, dist, leng);
        ZopfliStoreLitLenDist(leng, dist, i - 1UL, store);
        j = (size_t )2;
        while (j < (size_t )leng) {
          if (! (i < inend)) {
            __assert_fail("i < inend", "zopfli/src/zopfli/lz77.c", 601U, "ZopfliLZ77Greedy");
          }
          i ++;
          ZopfliUpdateHash(in___0, i, inend, h);
          j ++;
        }
        goto __Cont;
      }
    } else
    if (lengthscore >= 3) {
      if ((int )leng < 258) {
        match_available = 1;
        prev_length = (unsigned int )leng;
        prev_match = (unsigned int )dist;
        goto __Cont;
      }
    }
    if (lengthscore >= 3) {
      ZopfliVerifyLenDist(in___0, inend, i, dist, leng);
      ZopfliStoreLitLenDist(leng, dist, i, store);
    } else {
      leng = (unsigned short)1;
      ZopfliStoreLitLenDist((unsigned short )*(in___0 + i), (unsigned short)0, i,
                            store);
    }
    j = (size_t )1;
    while (j < (size_t )leng) {
      if (! (i < inend)) {
        __assert_fail("i < inend", "zopfli/src/zopfli/lz77.c", 626U, "ZopfliLZ77Greedy");
      }
      i ++;
      ZopfliUpdateHash(in___0, i, inend, h);
      j ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-OwRKRaOV.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliInitCache(size_t blocksize , ZopfliLongestMatchCache *lmc ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = malloc(sizeof(unsigned short ) * blocksize);
  lmc->length = (unsigned short *)tmp;
  tmp___0 = malloc(sizeof(unsigned short ) * blocksize);
  lmc->dist = (unsigned short *)tmp___0;
  tmp___1 = malloc(24UL * blocksize);
  lmc->sublen = (unsigned char *)tmp___1;
  if ((unsigned long )lmc->sublen == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Out of memory. Tried allocating %zu bytes of memory.\n",
            24UL * blocksize);
    exit(1);
  }
  i = (size_t )0;
  while (i < blocksize) {
    *(lmc->length + i) = (unsigned short)1;
    i ++;
  }
  i = (size_t )0;
  while (i < blocksize) {
    *(lmc->dist + i) = (unsigned short)0;
    i ++;
  }
  i = (size_t )0;
  while (i < (8UL * blocksize) * 3UL) {
    *(lmc->sublen + i) = (unsigned char)0;
    i ++;
  }
  return;
}
}
void ZopfliCleanCache(ZopfliLongestMatchCache *lmc ) 
{ 


  {
  free((void *)lmc->length);
  free((void *)lmc->dist);
  free((void *)lmc->sublen);
  return;
}
}
void ZopfliSublenToCache(unsigned short const   *sublen , size_t pos , size_t length ,
                         ZopfliLongestMatchCache *lmc ) 
{ 
  size_t i ;
  size_t j ;
  unsigned int bestlength ;
  unsigned char *cache ;
  unsigned int tmp___4 ;

  {
  j = (size_t )0;
  bestlength = 0U;
  cache = lmc->sublen + (8UL * pos) * 3UL;
  if (length < 3UL) {
    return;
  }
  i = (size_t )3;
  while (i <= length) {
    if (i == length) {
      goto _L;
    } else
    if ((int const   )*(sublen + i) != (int const   )*(sublen + (i + 1UL))) {
      _L: /* CIL Label */ 
      *(cache + j * 3UL) = (unsigned char )(i - 3UL);
      *(cache + (j * 3UL + 1UL)) = (unsigned char )((int const   )*(sublen + i) % 256);
      *(cache + (j * 3UL + 2UL)) = (unsigned char )(((int const   )*(sublen + i) >> 8) % 256);
      bestlength = (unsigned int )i;
      j ++;
      if (j >= 8UL) {
        break;
      }
    }
    i ++;
  }
  if (j < 8UL) {
    if (! ((size_t )bestlength == length)) {
      __assert_fail("bestlength == length", "zopfli/src/zopfli/cache.c", 79U, "ZopfliSublenToCache");
    }
    *(cache + 21) = (unsigned char )(bestlength - 3U);
  } else
  if (! ((size_t )bestlength <= length)) {
    __assert_fail("bestlength <= length", "zopfli/src/zopfli/cache.c", 82U, "ZopfliSublenToCache");
  }
  tmp___4 = ZopfliMaxCachedSublen((ZopfliLongestMatchCache const   *)lmc, pos, length);
  if (! (bestlength == tmp___4)) {
    __assert_fail("bestlength == ZopfliMaxCachedSublen(lmc, pos, length)", "zopfli/src/zopfli/cache.c",
                  84U, "ZopfliSublenToCache");
  }
  return;
}
}
void ZopfliCacheToSublen(ZopfliLongestMatchCache const   *lmc , size_t pos , size_t length ,
                         unsigned short *sublen ) 
{ 
  size_t i ;
  size_t j ;
  unsigned int maxlength ;
  unsigned int tmp ;
  unsigned int prevlength ;
  unsigned char *cache ;
  unsigned int length___0 ;
  unsigned int dist ;

  {
  tmp = ZopfliMaxCachedSublen(lmc, pos, length);
  maxlength = tmp;
  prevlength = 0U;
  if (length < 3UL) {
    return;
  }
  cache = lmc->sublen + (8UL * pos) * 3UL;
  j = (size_t )0;
  while (j < 8UL) {
    length___0 = (unsigned int )((int )*(cache + j * 3UL) + 3);
    dist = (unsigned int )((int )*(cache + (j * 3UL + 1UL)) + 256 * (int )*(cache + (j * 3UL + 2UL)));
    i = (size_t )prevlength;
    while (i <= (size_t )length___0) {
      *(sublen + i) = (unsigned short )dist;
      i ++;
    }
    if (length___0 == maxlength) {
      break;
    }
    prevlength = length___0 + 1U;
    j ++;
  }
  return;
}
}
unsigned int ZopfliMaxCachedSublen(ZopfliLongestMatchCache const   *lmc , size_t pos ,
                                   size_t length ) 
{ 
  unsigned char *cache ;

  {
  cache = lmc->sublen + (8UL * pos) * 3UL;
  if ((int )*(cache + 1) == 0) {
    if ((int )*(cache + 2) == 0) {
      return (0U);
    }
  }
  return ((unsigned int )((int )*(cache + 21) + 3));
}
}
#pragma merger("0","/tmp/cil-zwHLleeA.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliAllocHash(size_t window_size , ZopfliHash *h ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  tmp = malloc(sizeof(*(h->head)) * 65536UL);
  h->head = (int *)tmp;
  tmp___0 = malloc(sizeof(*(h->prev)) * window_size);
  h->prev = (unsigned short *)tmp___0;
  tmp___1 = malloc(sizeof(*(h->hashval)) * window_size);
  h->hashval = (int *)tmp___1;
  tmp___2 = malloc(sizeof(*(h->same)) * window_size);
  h->same = (unsigned short *)tmp___2;
  tmp___3 = malloc(sizeof(*(h->head2)) * 65536UL);
  h->head2 = (int *)tmp___3;
  tmp___4 = malloc(sizeof(*(h->prev2)) * window_size);
  h->prev2 = (unsigned short *)tmp___4;
  tmp___5 = malloc(sizeof(*(h->hashval2)) * window_size);
  h->hashval2 = (int *)tmp___5;
  return;
}
}
void ZopfliResetHash(size_t window_size , ZopfliHash *h ) 
{ 
  size_t i ;

  {
  h->val = 0;
  i = (size_t )0;
  while (i < 65536UL) {
    *(h->head + i) = -1;
    i ++;
  }
  i = (size_t )0;
  while (i < window_size) {
    *(h->prev + i) = (unsigned short )i;
    *(h->hashval + i) = -1;
    i ++;
  }
  i = (size_t )0;
  while (i < window_size) {
    *(h->same + i) = (unsigned short)0;
    i ++;
  }
  h->val2 = 0;
  i = (size_t )0;
  while (i < 65536UL) {
    *(h->head2 + i) = -1;
    i ++;
  }
  i = (size_t )0;
  while (i < window_size) {
    *(h->prev2 + i) = (unsigned short )i;
    *(h->hashval2 + i) = -1;
    i ++;
  }
  return;
}
}
void ZopfliCleanHash(ZopfliHash *h ) 
{ 


  {
  free((void *)h->head);
  free((void *)h->prev);
  free((void *)h->hashval);
  free((void *)h->head2);
  free((void *)h->prev2);
  free((void *)h->hashval2);
  free((void *)h->same);
  return;
}
}
static void UpdateHashValue(ZopfliHash *h , unsigned char c ) 
{ 


  {
  h->val = ((h->val << 5) ^ (int )c) & 32767;
  return;
}
}
void ZopfliUpdateHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) 
{ 
  unsigned short hpos ;
  size_t amount ;
  int tmp ;

  {
  hpos = (unsigned short )(pos & 32767UL);
  amount = (size_t )0;
  if (pos + 3UL <= end) {
    tmp = (int const   )*(array + ((pos + 3UL) - 1UL));
  } else {
    tmp = (int const   )0;
  }
  UpdateHashValue(h, (unsigned char )tmp);
  *(h->hashval + hpos) = h->val;
  if (*(h->head + h->val) != -1) {
    if (*(h->hashval + *(h->head + h->val)) == h->val) {
      *(h->prev + hpos) = (unsigned short )*(h->head + h->val);
    } else {
      *(h->prev + hpos) = hpos;
    }
  } else {
    *(h->prev + hpos) = hpos;
  }
  *(h->head + h->val) = (int )hpos;
  if ((int )*(h->same + ((pos - 1UL) & 32767UL)) > 1) {
    amount = (size_t )((int )*(h->same + ((pos - 1UL) & 32767UL)) - 1);
  }
  while (1) {
    if ((pos + amount) + 1UL < end) {
      if ((int const   )*(array + pos) == (int const   )*(array + ((pos + amount) + 1UL))) {
        if (! (amount < 65535UL)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    amount ++;
  }
  *(h->same + hpos) = (unsigned short )amount;
  h->val2 = (((int )*(h->same + hpos) - 3) & 255) ^ h->val;
  *(h->hashval2 + hpos) = h->val2;
  if (*(h->head2 + h->val2) != -1) {
    if (*(h->hashval2 + *(h->head2 + h->val2)) == h->val2) {
      *(h->prev2 + hpos) = (unsigned short )*(h->head2 + h->val2);
    } else {
      *(h->prev2 + hpos) = hpos;
    }
  } else {
    *(h->prev2 + hpos) = hpos;
  }
  *(h->head2 + h->val2) = (int )hpos;
  return;
}
}
void ZopfliWarmupHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) 
{ 


  {
  UpdateHashValue(h, (unsigned char )*(array + pos));
  if (pos + 1UL < end) {
    UpdateHashValue(h, (unsigned char )*(array + (pos + 1UL)));
  }
  return;
}
}
#pragma merger("0","/tmp/cil-EpgANV_m.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
void ZopfliInitOptions(ZopfliOptions *options ) 
{ 


  {
  options->verbose = 0;
  options->verbose_more = 0;
  options->numiterations = 15;
  options->blocksplitting = 1;
  options->blocksplittinglast = 0;
  options->blocksplittingmax = 15;
  return;
}
}
#pragma merger("0","/tmp/cil-SLKgO3Bh.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
static void InitStats(SymbolStats *stats ) 
{ 


  {
  memset((void *)(stats->litlens), 0, 288UL * sizeof(stats->litlens[0]));
  memset((void *)(stats->dists), 0, 32UL * sizeof(stats->dists[0]));
  memset((void *)(stats->ll_symbols), 0, 288UL * sizeof(stats->ll_symbols[0]));
  memset((void *)(stats->d_symbols), 0, 32UL * sizeof(stats->d_symbols[0]));
  return;
}
}
static void CopyStats(SymbolStats *source , SymbolStats *dest ) 
{ 


  {
  memcpy((void * __restrict  )(dest->litlens), (void const   * __restrict  )(source->litlens),
         288UL * sizeof(dest->litlens[0]));
  memcpy((void * __restrict  )(dest->dists), (void const   * __restrict  )(source->dists),
         32UL * sizeof(dest->dists[0]));
  memcpy((void * __restrict  )(dest->ll_symbols), (void const   * __restrict  )(source->ll_symbols),
         288UL * sizeof(dest->ll_symbols[0]));
  memcpy((void * __restrict  )(dest->d_symbols), (void const   * __restrict  )(source->d_symbols),
         32UL * sizeof(dest->d_symbols[0]));
  return;
}
}
static void AddWeighedStatFreqs(SymbolStats const   *stats1 , double w1 , SymbolStats const   *stats2 ,
                                double w2 , SymbolStats *result ) 
{ 
  size_t i ;

  {
  i = (size_t )0;
  while (i < 288UL) {
    result->litlens[i] = (size_t )((double )stats1->litlens[i] * w1 + (double )stats2->litlens[i] * w2);
    i ++;
  }
  i = (size_t )0;
  while (i < 32UL) {
    result->dists[i] = (size_t )((double )stats1->dists[i] * w1 + (double )stats2->dists[i] * w2);
    i ++;
  }
  result->litlens[256] = (size_t )1;
  return;
}
}
static void InitRanState(RanState *state ) 
{ 


  {
  state->m_w = 1U;
  state->m_z = 2U;
  return;
}
}
static unsigned int Ran(RanState *state ) 
{ 


  {
  state->m_z = 36969U * (state->m_z & 65535U) + (state->m_z >> 16);
  state->m_w = 18000U * (state->m_w & 65535U) + (state->m_w >> 16);
  return ((state->m_z << 16) + state->m_w);
}
}
static void RandomizeFreqs(RanState *state , size_t *freqs , int n ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  i = 0;
  while (i < n) {
    tmp___0 = Ran(state);
    if ((tmp___0 >> 4) % 3U == 0U) {
      tmp = Ran(state);
      *(freqs + i) = *(freqs + tmp % (unsigned int )n);
    }
    i ++;
  }
  return;
}
}
static void RandomizeStatFreqs(RanState *state , SymbolStats *stats ) 
{ 


  {
  RandomizeFreqs(state, stats->litlens, 288);
  RandomizeFreqs(state, stats->dists, 32);
  stats->litlens[256] = (size_t )1;
  return;
}
}
static void ClearStatFreqs(SymbolStats *stats ) 
{ 
  size_t i ;

  {
  i = (size_t )0;
  while (i < 288UL) {
    stats->litlens[i] = (size_t )0;
    i ++;
  }
  i = (size_t )0;
  while (i < 32UL) {
    stats->dists[i] = (size_t )0;
    i ++;
  }
  return;
}
}
static double GetCostFixed(unsigned int litlen , unsigned int dist , void *unused ) 
{ 
  int dbits ;
  int tmp ;
  int lbits ;
  int tmp___0 ;
  int lsym ;
  int tmp___1 ;
  int cost ;

  {
  if (dist == 0U) {
    if (litlen <= 143U) {
      return ((double )8);
    } else {
      return ((double )9);
    }
  } else {
    tmp = ZopfliGetDistExtraBits((int )dist);
    dbits = tmp;
    tmp___0 = ZopfliGetLengthExtraBits((int )litlen);
    lbits = tmp___0;
    tmp___1 = ZopfliGetLengthSymbol((int )litlen);
    lsym = tmp___1;
    cost = 0;
    if (lsym <= 279) {
      cost += 7;
    } else {
      cost += 8;
    }
    cost += 5;
    return ((double )((cost + dbits) + lbits));
  }
}
}
static double GetCostStat(unsigned int litlen , unsigned int dist , void *context ) 
{ 
  SymbolStats *stats ;
  int lsym ;
  int tmp ;
  int lbits ;
  int tmp___0 ;
  int dsym ;
  int tmp___1 ;
  int dbits ;
  int tmp___2 ;

  {
  stats = (SymbolStats *)context;
  if (dist == 0U) {
    return (stats->ll_symbols[litlen]);
  } else {
    tmp = ZopfliGetLengthSymbol((int )litlen);
    lsym = tmp;
    tmp___0 = ZopfliGetLengthExtraBits((int )litlen);
    lbits = tmp___0;
    tmp___1 = ZopfliGetDistSymbol((int )dist);
    dsym = tmp___1;
    tmp___2 = ZopfliGetDistExtraBits((int )dist);
    dbits = tmp___2;
    return (((double )(lbits + dbits) + stats->ll_symbols[lsym]) + stats->d_symbols[dsym]);
  }
}
}
static double GetCostModelMinCost(CostModelFun *costmodel , void *costcontext ) ;
static int const   dsymbols[30]  = 
  {      (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )7,      (int const   )9,      (int const   )13, 
        (int const   )17,      (int const   )25,      (int const   )33,      (int const   )49, 
        (int const   )65,      (int const   )97,      (int const   )129,      (int const   )193, 
        (int const   )257,      (int const   )385,      (int const   )513,      (int const   )769, 
        (int const   )1025,      (int const   )1537,      (int const   )2049,      (int const   )3073, 
        (int const   )4097,      (int const   )6145,      (int const   )8193,      (int const   )12289, 
        (int const   )16385,      (int const   )24577};
static double GetCostModelMinCost(CostModelFun *costmodel , void *costcontext ) 
{ 
  double mincost ;
  int bestlength ;
  int bestdist ;
  int i ;
  double c ;
  double tmp ;
  double c___0 ;
  double tmp___0 ;
  double tmp___1 ;

  {
  bestlength = 0;
  bestdist = 0;
  mincost = 1e30;
  i = 3;
  while (i < 259) {
    tmp = (*costmodel)((unsigned int )i, 1U, costcontext);
    c = tmp;
    if (c < mincost) {
      bestlength = i;
      mincost = c;
    }
    i ++;
  }
  mincost = 1e30;
  i = 0;
  while (i < 30) {
    tmp___0 = (*costmodel)(3U, (unsigned int )dsymbols[i], costcontext);
    c___0 = tmp___0;
    if (c___0 < mincost) {
      bestdist = (int )dsymbols[i];
      mincost = c___0;
    }
    i ++;
  }
  tmp___1 = (*costmodel)((unsigned int )bestlength, (unsigned int )bestdist, costcontext);
  return (tmp___1);
}
}
static size_t zopfli_min(size_t a , size_t b ) 
{ 
  size_t tmp ;

  {
  if (a < b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static double GetBestLengths(ZopfliBlockState *s , unsigned char const   *in___0 ,
                             size_t instart , size_t inend , CostModelFun *costmodel ,
                             void *costcontext , unsigned short *length_array , ZopfliHash *h ,
                             float *costs ) 
{ 
  size_t blocksize ;
  size_t i ;
  size_t k ;
  size_t kend ;
  unsigned short leng ;
  unsigned short dist ;
  unsigned short sublen[259] ;
  size_t windowstart ;
  size_t tmp ;
  double result ;
  double mincost ;
  double tmp___0 ;
  double mincostaddcostj ;
  size_t j ;
  double symbolcost ;
  double tmp___1 ;
  double newCost ;
  double tmp___2 ;
  double newCost___0 ;
  double tmp___4 ;

  {
  blocksize = inend - instart;
  i = (size_t )0;
  if (instart > 32768UL) {
    tmp = instart - 32768UL;
  } else {
    tmp = (size_t )0;
  }
  windowstart = tmp;
  tmp___0 = GetCostModelMinCost(costmodel, costcontext);
  mincost = tmp___0;
  if (instart == inend) {
    return ((double )0);
  }
  ZopfliResetHash((size_t )32768, h);
  ZopfliWarmupHash(in___0, windowstart, inend, h);
  i = windowstart;
  while (i < instart) {
    ZopfliUpdateHash(in___0, i, inend, h);
    i ++;
  }
  i = (size_t )1;
  while (i < blocksize + 1UL) {
    *(costs + i) = (float )1e30;
    i ++;
  }
  *(costs + 0) = (float )0;
  *(length_array + 0) = (unsigned short)0;
  i = instart;
  while (i < inend) {
    j = i - instart;
    ZopfliUpdateHash(in___0, i, inend, h);
    if ((int )*(h->same + (i & 32767UL)) > 516) {
      if (i > (instart + 258UL) + 1UL) {
        if ((i + 516UL) + 1UL < inend) {
          if ((int )*(h->same + ((i - 258UL) & 32767UL)) > 258) {
            tmp___1 = (*costmodel)(258U, 1U, costcontext);
            symbolcost = tmp___1;
            k = (size_t )0;
            while (k < 258UL) {
              *(costs + (j + 258UL)) = (float )((double )*(costs + j) + symbolcost);
              *(length_array + (j + 258UL)) = (unsigned short)258;
              i ++;
              j ++;
              ZopfliUpdateHash(in___0, i, inend, h);
              k ++;
            }
          }
        }
      }
    }
    ZopfliFindLongestMatch(s, (ZopfliHash const   *)h, in___0, i, inend, (size_t )258,
                           sublen, & dist, & leng);
    if (i + 1UL <= inend) {
      tmp___2 = (*costmodel)((unsigned int )*(in___0 + i), 0U, costcontext);
      newCost = tmp___2 + (double )*(costs + j);
      if (! (newCost >= (double )0)) {
        __assert_fail("newCost >= 0", "zopfli/src/zopfli/squeeze.c", 279U, "GetBestLengths");
      }
      if (newCost < (double )*(costs + (j + 1UL))) {
        *(costs + (j + 1UL)) = (float )newCost;
        *(length_array + (j + 1UL)) = (unsigned short)1;
      }
    }
    kend = zopfli_min((size_t )leng, inend - i);
    mincostaddcostj = mincost + (double )*(costs + j);
    k = (size_t )3;
    while (k <= kend) {
      if ((double )*(costs + (j + k)) <= mincostaddcostj) {
        goto __Cont;
      }
      tmp___4 = (*costmodel)((unsigned int )k, (unsigned int )sublen[k], costcontext);
      newCost___0 = tmp___4 + (double )*(costs + j);
      if (! (newCost___0 >= (double )0)) {
        __assert_fail("newCost >= 0", "zopfli/src/zopfli/squeeze.c", 296U, "GetBestLengths");
      }
      if (newCost___0 < (double )*(costs + (j + k))) {
        if (! (k <= 258UL)) {
          __assert_fail("k <= ZOPFLI_MAX_MATCH", "zopfli/src/zopfli/squeeze.c", 298U,
                        "GetBestLengths");
        }
        *(costs + (j + k)) = (float )newCost___0;
        *(length_array + (j + k)) = (unsigned short )k;
      }
      __Cont: /* CIL Label */ 
      k ++;
    }
    i ++;
  }
  if (! (*(costs + blocksize) >= (float )0)) {
    __assert_fail("costs[blocksize] >= 0", "zopfli/src/zopfli/squeeze.c", 305U, "GetBestLengths");
  }
  result = (double )*(costs + blocksize);
  return (result);
}
}
static void TraceBackwards(size_t size , unsigned short const   *length_array , unsigned short **path ,
                           size_t *pathsize ) 
{ 
  size_t index___0 ;
  void *tmp ;
  void *tmp___0 ;
  unsigned short temp ;

  {
  index___0 = size;
  if (size == 0UL) {
    return;
  }
  while (1) {
    if (! (*pathsize & (*pathsize - 1UL))) {
      if (*pathsize == 0UL) {
        tmp = malloc(sizeof(*(*path)));
        *path = (unsigned short *)tmp;
      } else {
        tmp___0 = realloc((void *)*path, (*pathsize * 2UL) * sizeof(*(*path)));
        *path = (unsigned short *)tmp___0;
      }
    }
    *(*path + *pathsize) = (unsigned short )*(length_array + index___0);
    (*pathsize) ++;
    if (! ((size_t )*(length_array + index___0) <= index___0)) {
      __assert_fail("length_array[index] <= index", "zopfli/src/zopfli/squeeze.c",
                    323U, "TraceBackwards");
    }
    if (! ((int const   )*(length_array + index___0) <= 258)) {
      __assert_fail("length_array[index] <= ZOPFLI_MAX_MATCH", "zopfli/src/zopfli/squeeze.c",
                    324U, "TraceBackwards");
    }
    if (! ((int const   )*(length_array + index___0) != 0)) {
      __assert_fail("length_array[index] != 0", "zopfli/src/zopfli/squeeze.c", 325U,
                    "TraceBackwards");
    }
    index___0 -= (size_t )*(length_array + index___0);
    if (index___0 == 0UL) {
      break;
    }
  }
  index___0 = (size_t )0;
  while (index___0 < *pathsize / 2UL) {
    temp = *(*path + index___0);
    *(*path + index___0) = *(*path + ((*pathsize - index___0) - 1UL));
    *(*path + ((*pathsize - index___0) - 1UL)) = temp;
    index___0 ++;
  }
  return;
}
}
static void FollowPath(ZopfliBlockState *s , unsigned char const   *in___0 , size_t instart ,
                       size_t inend , unsigned short *path , size_t pathsize , ZopfliLZ77Store *store ,
                       ZopfliHash *h ) 
{ 
  size_t i ;
  size_t j ;
  size_t pos ;
  size_t windowstart ;
  size_t tmp ;
  size_t total_length_test ;
  unsigned short length ;
  unsigned short dummy_length ;
  unsigned short dist ;

  {
  pos = (size_t )0;
  if (instart > 32768UL) {
    tmp = instart - 32768UL;
  } else {
    tmp = (size_t )0;
  }
  windowstart = tmp;
  total_length_test = (size_t )0;
  if (instart == inend) {
    return;
  }
  ZopfliResetHash((size_t )32768, h);
  ZopfliWarmupHash(in___0, windowstart, inend, h);
  i = windowstart;
  while (i < instart) {
    ZopfliUpdateHash(in___0, i, inend, h);
    i ++;
  }
  pos = instart;
  i = (size_t )0;
  while (i < pathsize) {
    length = *(path + i);
    if (! (pos < inend)) {
      __assert_fail("pos < inend", "zopfli/src/zopfli/squeeze.c", 361U, "FollowPath");
    }
    ZopfliUpdateHash(in___0, pos, inend, h);
    if ((int )length >= 3) {
      ZopfliFindLongestMatch(s, (ZopfliHash const   *)h, in___0, pos, inend, (size_t )length,
                             (unsigned short *)0, & dist, & dummy_length);
      if ((int )dummy_length != (int )length) {
        if ((int )length > 2) {
          if ((int )dummy_length > 2) {
            __assert_fail("!(dummy_length != length && length > 2 && dummy_length > 2)",
                          "zopfli/src/zopfli/squeeze.c", 371U, "FollowPath");
          }
        }
      }
      ZopfliVerifyLenDist(in___0, inend, pos, dist, length);
      ZopfliStoreLitLenDist(length, dist, pos, store);
      total_length_test += (size_t )length;
    } else {
      length = (unsigned short)1;
      ZopfliStoreLitLenDist((unsigned short )*(in___0 + pos), (unsigned short)0, pos,
                            store);
      total_length_test ++;
    }
    if (! (pos + (size_t )length <= inend)) {
      __assert_fail("pos + length <= inend", "zopfli/src/zopfli/squeeze.c", 382U,
                    "FollowPath");
    }
    j = (size_t )1;
    while (j < (size_t )length) {
      ZopfliUpdateHash(in___0, pos + j, inend, h);
      j ++;
    }
    pos += (size_t )length;
    i ++;
  }
  return;
}
}
static void CalculateStatistics(SymbolStats *stats ) 
{ 


  {
  ZopfliCalculateEntropy((size_t const   *)(stats->litlens), (size_t )288, stats->ll_symbols);
  ZopfliCalculateEntropy((size_t const   *)(stats->dists), (size_t )32, stats->d_symbols);
  return;
}
}
static void GetStatistics(ZopfliLZ77Store const   *store , SymbolStats *stats ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;

  {
  i = (size_t )0;
  while (i < (size_t )store->size) {
    if ((int )*(store->dists + i) == 0) {
      (stats->litlens[*(store->litlens + i)]) ++;
    } else {
      tmp = ZopfliGetLengthSymbol((int )*(store->litlens + i));
      (stats->litlens[tmp]) ++;
      tmp___0 = ZopfliGetDistSymbol((int )*(store->dists + i));
      (stats->dists[tmp___0]) ++;
    }
    i ++;
  }
  stats->litlens[256] = (size_t )1;
  CalculateStatistics(stats);
  return;
}
}
static double LZ77OptimalRun(ZopfliBlockState *s , unsigned char const   *in___0 ,
                             size_t instart , size_t inend , unsigned short **path ,
                             size_t *pathsize , unsigned short *length_array , CostModelFun *costmodel ,
                             void *costcontext , ZopfliLZ77Store *store , ZopfliHash *h ,
                             float *costs ) 
{ 
  double cost ;
  double tmp ;

  {
  tmp = GetBestLengths(s, in___0, instart, inend, costmodel, costcontext, length_array,
                       h, costs);
  cost = tmp;
  free((void *)*path);
  *path = (unsigned short *)0;
  *pathsize = (size_t )0;
  TraceBackwards(inend - instart, (unsigned short const   *)length_array, path, pathsize);
  FollowPath(s, in___0, instart, inend, *path, *pathsize, store, h);
  if (! (cost < 1e30)) {
    __assert_fail("cost < ZOPFLI_LARGE_FLOAT", "zopfli/src/zopfli/squeeze.c", 442U,
                  "LZ77OptimalRun");
  }
  return (cost);
}
}
void ZopfliLZ77Optimal(ZopfliBlockState *s , unsigned char const   *in___0 , size_t instart ,
                       size_t inend , int numiterations , ZopfliLZ77Store *store ) 
{ 
  size_t blocksize ;
  unsigned short *length_array ;
  void *tmp ;
  unsigned short *path ;
  size_t pathsize ;
  ZopfliLZ77Store currentstore ;
  ZopfliHash hash ;
  ZopfliHash *h ;
  SymbolStats stats ;
  SymbolStats beststats ;
  SymbolStats laststats ;
  int i ;
  float *costs ;
  void *tmp___0 ;
  double cost ;
  double bestcost ;
  double lastcost ;
  RanState ran_state ;
  int lastrandomstep ;

  {
  blocksize = inend - instart;
  tmp = malloc(sizeof(unsigned short ) * (blocksize + 1UL));
  length_array = (unsigned short *)tmp;
  path = (unsigned short *)0;
  pathsize = (size_t )0;
  h = & hash;
  tmp___0 = malloc(sizeof(float ) * (blocksize + 1UL));
  costs = (float *)tmp___0;
  bestcost = 1e30;
  lastcost = (double )0;
  lastrandomstep = -1;
  if (! costs) {
    exit(-1);
  }
  if (! length_array) {
    exit(-1);
  }
  InitRanState(& ran_state);
  InitStats(& stats);
  ZopfliInitLZ77Store(in___0, & currentstore);
  ZopfliAllocHash((size_t )32768, h);
  ZopfliLZ77Greedy(s, in___0, instart, inend, & currentstore, h);
  GetStatistics((ZopfliLZ77Store const   *)(& currentstore), & stats);
  i = 0;
  while (i < numiterations) {
    ZopfliCleanLZ77Store(& currentstore);
    ZopfliInitLZ77Store(in___0, & currentstore);
    LZ77OptimalRun(s, in___0, instart, inend, & path, & pathsize, length_array, & GetCostStat,
                   (void *)(& stats), & currentstore, h, costs);
    cost = ZopfliCalculateBlockSize((ZopfliLZ77Store const   *)(& currentstore), (size_t )0,
                                    currentstore.size, 2);
    if ((s->options)->verbose_more) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Iteration %d: %d bit\n",
              i, (int )cost);
    } else
    if ((s->options)->verbose) {
      if (cost < bestcost) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Iteration %d: %d bit\n",
                i, (int )cost);
      }
    }
    if (cost < bestcost) {
      ZopfliCopyLZ77Store((ZopfliLZ77Store const   *)(& currentstore), store);
      CopyStats(& stats, & beststats);
      bestcost = cost;
    }
    CopyStats(& stats, & laststats);
    ClearStatFreqs(& stats);
    GetStatistics((ZopfliLZ77Store const   *)(& currentstore), & stats);
    if (lastrandomstep != -1) {
      AddWeighedStatFreqs((SymbolStats const   *)(& stats), 1.0, (SymbolStats const   *)(& laststats),
                          0.5, & stats);
      CalculateStatistics(& stats);
    }
    if (i > 5) {
      if (cost == lastcost) {
        CopyStats(& beststats, & stats);
        RandomizeStatFreqs(& ran_state, & stats);
        CalculateStatistics(& stats);
        lastrandomstep = i;
      }
    }
    lastcost = cost;
    i ++;
  }
  free((void *)length_array);
  free((void *)path);
  free((void *)costs);
  ZopfliCleanLZ77Store(& currentstore);
  ZopfliCleanHash(h);
  return;
}
}
void ZopfliLZ77OptimalFixed(ZopfliBlockState *s , unsigned char const   *in___0 ,
                            size_t instart , size_t inend , ZopfliLZ77Store *store ) 
{ 
  size_t blocksize ;
  unsigned short *length_array ;
  void *tmp ;
  unsigned short *path ;
  size_t pathsize ;
  ZopfliHash hash ;
  ZopfliHash *h ;
  float *costs ;
  void *tmp___0 ;

  {
  blocksize = inend - instart;
  tmp = malloc(sizeof(unsigned short ) * (blocksize + 1UL));
  length_array = (unsigned short *)tmp;
  path = (unsigned short *)0;
  pathsize = (size_t )0;
  h = & hash;
  tmp___0 = malloc(sizeof(float ) * (blocksize + 1UL));
  costs = (float *)tmp___0;
  if (! costs) {
    exit(-1);
  }
  if (! length_array) {
    exit(-1);
  }
  ZopfliAllocHash((size_t )32768, h);
  s->blockstart = instart;
  s->blockend = inend;
  LZ77OptimalRun(s, in___0, instart, inend, & path, & pathsize, length_array, & GetCostFixed,
                 (void *)0, store, h, costs);
  free((void *)length_array);
  free((void *)path);
  free((void *)costs);
  ZopfliCleanHash(h);
  return;
}
}
#pragma merger("0","/tmp/cil-Vcx3s4Vl.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
static void InitNode(size_t weight , int count , Node *tail , Node *node ) 
{ 


  {
  node->weight = weight;
  node->count = count;
  node->tail = tail;
  return;
}
}
static void BoundaryPM(Node *(*lists)[2] , Node *leaves , int numsymbols , NodePool *pool ,
                       int index___0 ) 
{ 
  Node *newchain ;
  Node *oldchain ;
  int lastcount ;
  Node *tmp ;
  size_t sum ;

  {
  lastcount = ((*(lists + index___0))[1])->count;
  if (index___0 == 0) {
    if (lastcount >= numsymbols) {
      return;
    }
  }
  tmp = pool->next;
  (pool->next) ++;
  newchain = tmp;
  oldchain = (*(lists + index___0))[1];
  (*(lists + index___0))[0] = oldchain;
  (*(lists + index___0))[1] = newchain;
  if (index___0 == 0) {
    InitNode((leaves + lastcount)->weight, lastcount + 1, (Node *)0, newchain);
  } else {
    sum = ((*(lists + (index___0 - 1)))[0])->weight + ((*(lists + (index___0 - 1)))[1])->weight;
    if (lastcount < numsymbols) {
      if (sum > (leaves + lastcount)->weight) {
        InitNode((leaves + lastcount)->weight, lastcount + 1, oldchain->tail, newchain);
      } else {
        InitNode(sum, lastcount, (*(lists + (index___0 - 1)))[1], newchain);
        BoundaryPM(lists, leaves, numsymbols, pool, index___0 - 1);
        BoundaryPM(lists, leaves, numsymbols, pool, index___0 - 1);
      }
    } else {
      InitNode(sum, lastcount, (*(lists + (index___0 - 1)))[1], newchain);
      BoundaryPM(lists, leaves, numsymbols, pool, index___0 - 1);
      BoundaryPM(lists, leaves, numsymbols, pool, index___0 - 1);
    }
  }
  return;
}
}
static void BoundaryPMFinal(Node *(*lists)[2] , Node *leaves , int numsymbols , NodePool *pool ,
                            int index___0 ) 
{ 
  int lastcount ;
  size_t sum ;
  Node *newchain ;
  Node *oldchain ;

  {
  lastcount = ((*(lists + index___0))[1])->count;
  sum = ((*(lists + (index___0 - 1)))[0])->weight + ((*(lists + (index___0 - 1)))[1])->weight;
  if (lastcount < numsymbols) {
    if (sum > (leaves + lastcount)->weight) {
      newchain = pool->next;
      oldchain = ((*(lists + index___0))[1])->tail;
      (*(lists + index___0))[1] = newchain;
      newchain->count = lastcount + 1;
      newchain->tail = oldchain;
    } else {
      ((*(lists + index___0))[1])->tail = (*(lists + (index___0 - 1)))[1];
    }
  } else {
    ((*(lists + index___0))[1])->tail = (*(lists + (index___0 - 1)))[1];
  }
  return;
}
}
static void InitLists(NodePool *pool , Node const   *leaves , int maxbits , Node *(*lists)[2] ) 
{ 
  int i ;
  Node *node0 ;
  Node *tmp ;
  Node *node1 ;
  Node *tmp___0 ;

  {
  tmp = pool->next;
  (pool->next) ++;
  node0 = tmp;
  tmp___0 = pool->next;
  (pool->next) ++;
  node1 = tmp___0;
  InitNode((size_t )(leaves + 0)->weight, 1, (Node *)0, node0);
  InitNode((size_t )(leaves + 1)->weight, 2, (Node *)0, node1);
  i = 0;
  while (i < maxbits) {
    (*(lists + i))[0] = node0;
    (*(lists + i))[1] = node1;
    i ++;
  }
  return;
}
}
static void ExtractBitLengths(Node *chain , Node *leaves , unsigned int *bitlengths ) 
{ 
  int counts[16] ;
  unsigned int tmp ;
  unsigned int end ;
  unsigned int ptr ;
  unsigned int value ;
  Node *node ;
  int val ;

  {
  counts[0] = 0;
  tmp = 1U;
  while (! (tmp >= 16U)) {
    counts[tmp] = 0;
    tmp ++;
  }
  end = 16U;
  ptr = 15U;
  value = 1U;
  node = chain;
  while (node) {
    end --;
    counts[end] = node->count;
    node = node->tail;
  }
  val = counts[15];
  while (ptr >= end) {
    while (val > counts[ptr - 1U]) {
      *(bitlengths + (leaves + (val - 1))->count) = value;
      val --;
    }
    ptr --;
    value ++;
  }
  return;
}
}
static int LeafComparator(void const   *a , void const   *b ) 
{ 


  {
  return ((int )(((Node const   *)a)->weight - ((Node const   *)b)->weight));
}
}
int ZopfliLengthLimitedCodeLengths(size_t const   *frequencies , int n , int maxbits ,
                                   unsigned int *bitlengths ) 
{ 
  NodePool pool ;
  int i ;
  int numsymbols ;
  int numBoundaryPMRuns ;
  Node *nodes ;
  Node *(*lists)[2] ;
  Node *leaves ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  numsymbols = 0;
  tmp = malloc((unsigned long )n * sizeof(*leaves));
  leaves = (Node *)tmp;
  i = 0;
  while (i < n) {
    *(bitlengths + i) = 0U;
    i ++;
  }
  i = 0;
  while (i < n) {
    if (*(frequencies + i)) {
      (leaves + numsymbols)->weight = (size_t )*(frequencies + i);
      (leaves + numsymbols)->count = i;
      numsymbols ++;
    }
    i ++;
  }
  if (1 << maxbits < numsymbols) {
    free((void *)leaves);
    return (1);
  }
  if (numsymbols == 0) {
    free((void *)leaves);
    return (0);
  }
  if (numsymbols == 1) {
    *(bitlengths + (leaves + 0)->count) = 1U;
    free((void *)leaves);
    return (0);
  }
  if (numsymbols == 2) {
    (*(bitlengths + (leaves + 0)->count)) ++;
    (*(bitlengths + (leaves + 1)->count)) ++;
    free((void *)leaves);
    return (0);
  }
  i = 0;
  while (i < numsymbols) {
    if ((leaves + i)->weight >= 1UL << (sizeof((leaves + 0)->weight) * 8UL - 9UL)) {
      free((void *)leaves);
      return (1);
    }
    (leaves + i)->weight = ((leaves + i)->weight << 9) | (unsigned long )(leaves + i)->count;
    i ++;
  }
  qsort((void *)leaves, (size_t )numsymbols, sizeof(Node ), & LeafComparator);
  i = 0;
  while (i < numsymbols) {
    (leaves + i)->weight >>= 9;
    i ++;
  }
  if (numsymbols - 1 < maxbits) {
    maxbits = numsymbols - 1;
  }
  tmp___0 = malloc((unsigned long )((maxbits * 2) * numsymbols) * sizeof(Node ));
  nodes = (Node *)tmp___0;
  pool.next = nodes;
  tmp___1 = malloc((unsigned long )maxbits * sizeof(*lists));
  lists = (Node *(*)[2])tmp___1;
  InitLists(& pool, (Node const   *)leaves, maxbits, lists);
  numBoundaryPMRuns = 2 * numsymbols - 4;
  i = 0;
  while (i < numBoundaryPMRuns - 1) {
    BoundaryPM(lists, leaves, numsymbols, & pool, maxbits - 1);
    i ++;
  }
  BoundaryPMFinal(lists, leaves, numsymbols, & pool, maxbits - 1);
  ExtractBitLengths((*(lists + (maxbits - 1)))[1], leaves, bitlengths);
  free((void *)lists);
  free((void *)leaves);
  free((void *)nodes);
  return (0);
}
}
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
#pragma merger("0","/tmp/cil-idl5DIxA.i","-O3,-Wall,-Wextra,-Wno-unknown-pragmas,-Wcast-qual")
int ZopfliGetDistExtraBits(int dist ) 
{ 
  int tmp ;

  {
  if (dist < 5) {
    return (0);
  }
  tmp = __builtin_clz((unsigned int )(dist - 1));
  return ((31 ^ tmp) - 1);
}
}
int ZopfliGetDistExtraBitsValue(int dist ) 
{ 
  int l ;
  int tmp ;

  {
  if (dist < 5) {
    return (0);
  } else {
    tmp = __builtin_clz((unsigned int )(dist - 1));
    l = 31 ^ tmp;
    return ((dist - (1 + (1 << l))) & ((1 << (l - 1)) - 1));
  }
}
}
int ZopfliGetDistSymbol(int dist ) 
{ 
  int l ;
  int tmp ;
  int r ;

  {
  if (dist < 5) {
    return (dist - 1);
  } else {
    tmp = __builtin_clz((unsigned int )(dist - 1));
    l = 31 ^ tmp;
    r = ((dist - 1) >> (l - 1)) & 1;
    return (l * 2 + r);
  }
}
}
static int const   table[259]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0};
int ZopfliGetLengthExtraBits(int l ) 
{ 


  {
  return ((int )table[l]);
}
}
static int const   table___0[259]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )0};
int ZopfliGetLengthExtraBitsValue(int l ) 
{ 


  {
  return ((int )table___0[l]);
}
}
static int const   table___1[259]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )257, 
        (int const   )258,      (int const   )259,      (int const   )260,      (int const   )261, 
        (int const   )262,      (int const   )263,      (int const   )264,      (int const   )265, 
        (int const   )265,      (int const   )266,      (int const   )266,      (int const   )267, 
        (int const   )267,      (int const   )268,      (int const   )268,      (int const   )269, 
        (int const   )269,      (int const   )269,      (int const   )269,      (int const   )270, 
        (int const   )270,      (int const   )270,      (int const   )270,      (int const   )271, 
        (int const   )271,      (int const   )271,      (int const   )271,      (int const   )272, 
        (int const   )272,      (int const   )272,      (int const   )272,      (int const   )273, 
        (int const   )273,      (int const   )273,      (int const   )273,      (int const   )273, 
        (int const   )273,      (int const   )273,      (int const   )273,      (int const   )274, 
        (int const   )274,      (int const   )274,      (int const   )274,      (int const   )274, 
        (int const   )274,      (int const   )274,      (int const   )274,      (int const   )275, 
        (int const   )275,      (int const   )275,      (int const   )275,      (int const   )275, 
        (int const   )275,      (int const   )275,      (int const   )275,      (int const   )276, 
        (int const   )276,      (int const   )276,      (int const   )276,      (int const   )276, 
        (int const   )276,      (int const   )276,      (int const   )276,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )285};
int ZopfliGetLengthSymbol(int l ) 
{ 


  {
  return ((int )table___1[l]);
}
}
static int const   table___2[29]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )0};
int ZopfliGetLengthSymbolExtraBits(int s ) 
{ 


  {
  return ((int )table___2[s - 257]);
}
}
static int const   table___3[30]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )6,      (int const   )6, 
        (int const   )7,      (int const   )7,      (int const   )8,      (int const   )8, 
        (int const   )9,      (int const   )9,      (int const   )10,      (int const   )10, 
        (int const   )11,      (int const   )11,      (int const   )12,      (int const   )12, 
        (int const   )13,      (int const   )13};
int ZopfliGetDistSymbolExtraBits(int s ) 
{ 


  {
  return ((int )table___3[s]);
}
}
